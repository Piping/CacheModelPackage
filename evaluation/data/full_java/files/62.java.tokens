package org . apache . cassandra . auth ; import java . net . InetAddress ; import java . nio . charset . StandardCharsets ; import java . util . Arrays ; import java . util . Map ; import java . util . Set ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . mindrot . jbcrypt . BCrypt ; import static org . apache . cassandra . auth . CassandraRoleManager . consistencyForRole ; public class PasswordAuthenticator implements IAuthenticator { private static final Logger logger = LoggerFactory . getLogger ( PasswordAuthenticator . class ) ; private static final String SALTED_HASH = <str> ; public static final String USERNAME_KEY = <str> ; public static final String PASSWORD_KEY = <str> ; private static final byte NUL = <int> ; private SelectStatement authenticateStatement ; public static final String LEGACY_CREDENTIALS_TABLE = <str> ; private SelectStatement legacyAuthenticateStatement ; public boolean requireAuthentication ( ) { return true ; } private AuthenticatedUser authenticate ( String username , String password ) throws AuthenticationException { try { SelectStatement authenticationStatement = Schema . instance . getCFMetaData ( AuthKeyspace . NAME , LEGACY_CREDENTIALS_TABLE ) = = null ? authenticateStatement : legacyAuthenticateStatement ; return doAuthenticate ( username , password , authenticationStatement ) ; } catch ( RequestExecutionException e ) { logger . trace ( <str> , e ) ; throw new AuthenticationException ( e . toString ( ) ) ; } } public Set < DataResource > protectedResources ( ) { return ImmutableSet . of ( DataResource . table ( AuthKeyspace . NAME , AuthKeyspace . ROLES ) ) ; } public void validateConfiguration ( ) throws ConfigurationException { } public void setup ( ) { String query = String . format ( <str> , SALTED_HASH , AuthKeyspace . NAME , AuthKeyspace . ROLES ) ; authenticateStatement = prepare ( query ) ; if ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , LEGACY_CREDENTIALS_TABLE ) ! = null ) { query = String . format ( <str> , SALTED_HASH , AuthKeyspace . NAME , LEGACY_CREDENTIALS_TABLE ) ; legacyAuthenticateStatement = prepare ( query ) ; } } public AuthenticatedUser legacyAuthenticate ( Map < String , String > credentials ) throws AuthenticationException { String username = credentials . get ( USERNAME_KEY ) ; if ( username = = null ) throw new AuthenticationException ( String . format ( <str> , USERNAME_KEY ) ) ; String password = credentials . get ( PASSWORD_KEY ) ; if ( password = = null ) throw new AuthenticationException ( String . format ( <str> , PASSWORD_KEY ) ) ; return authenticate ( username , password ) ; } public SaslNegotiator newSaslNegotiator ( InetAddress clientAddress ) { return new PlainTextSaslAuthenticator ( ) ; } private AuthenticatedUser doAuthenticate ( String username , String password , SelectStatement authenticationStatement ) throws RequestExecutionException , AuthenticationException { ResultMessage . Rows rows = authenticationStatement . execute ( QueryState . forInternalCalls ( ) , QueryOptions . forInternalCalls ( consistencyForRole ( username ) , Lists . newArrayList ( ByteBufferUtil . bytes ( username ) ) ) ) ; UntypedResultSet result = UntypedResultSet . create ( rows . result ) ; if ( ( result . isEmpty ( ) | | ! result . one ( ) . has ( SALTED_HASH ) ) | | ! BCrypt . checkpw ( password , result . one ( ) . getString ( SALTED_HASH ) ) ) throw new AuthenticationException ( <str> ) ; return new AuthenticatedUser ( username ) ; } private SelectStatement prepare ( String query ) { return ( SelectStatement ) QueryProcessor . getStatement ( query , ClientState . forInternalCalls ( ) ) . statement ; } private class PlainTextSaslAuthenticator implements SaslNegotiator { private boolean complete = false ; private String username ; private String password ; public byte [ ] evaluateResponse ( byte [ ] clientResponse ) throws AuthenticationException { decodeCredentials ( clientResponse ) ; complete = true ; return null ; } public boolean isComplete ( ) { return complete ; } public AuthenticatedUser getAuthenticatedUser ( ) throws AuthenticationException { if ( ! complete ) throw new AuthenticationException ( <str> ) ; return authenticate ( username , password ) ; } private void decodeCredentials ( byte [ ] bytes ) throws AuthenticationException { logger . trace ( <str> ) ; byte [ ] user = null ; byte [ ] pass = null ; int end = bytes . length ; for ( int i = bytes . length - <int> ; i > = <int> ; i - - ) { if ( bytes [ i ] = = NUL ) { if ( pass = = null ) pass = Arrays . copyOfRange ( bytes , i + <int> , end ) ; else if ( user = = null ) user = Arrays . copyOfRange ( bytes , i + <int> , end ) ; end = i ; } } if ( user = = null ) throw new AuthenticationException ( <str> ) ; if ( pass = = null ) throw new AuthenticationException ( <str> ) ; username = new String ( user , StandardCharsets . UTF_8 ) ; password = new String ( pass , StandardCharsets . UTF_8 ) ; } } } 
