package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . physics . bullet . collision . btBvhTriangleMeshShape ; import com . badlogic . gdx . physics . bullet . collision . btSphereShape ; public class MeshShapeTest extends BaseBulletTest { @Override public void create ( ) { super . create ( ) ; final Model sphereModel = modelBuilder . createSphere ( <float> , <float> , <float> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) ) , Usage . Position | Usage . Normal ) ; disposables . add ( sphereModel ) ; final BulletConstructor sphereConstructor = new BulletConstructor ( sphereModel , <float> , new btSphereShape ( <float> ) ) ; sphereConstructor . bodyInfo . setRestitution ( <float> ) ; world . addConstructor ( <str> , sphereConstructor ) ; final Model sceneModel = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; disposables . add ( sceneModel ) ; final BulletConstructor sceneConstructor = new BulletConstructor ( sceneModel , <float> , new btBvhTriangleMeshShape ( sceneModel . meshParts ) ) ; sceneConstructor . bodyInfo . setRestitution ( <float> ) ; world . addConstructor ( <str> , sceneConstructor ) ; world . add ( <str> , ( new Matrix4 ( ) ) . setToTranslation ( <float> , <float> , <float> ) . rotate ( Vector3 . Y , - <int> ) ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; for ( float x = - <int> ; x < <int> ; x + + ) { for ( float z = - <int> ; z < <int> ; z + + ) { world . add ( <str> , x , <int> f + ( float ) Math . random ( ) * <float> , z ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; } } } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } } 
