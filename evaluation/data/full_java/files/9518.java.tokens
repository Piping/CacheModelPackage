package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static com . google . common . util . concurrent . Uninterruptibles . getUninterruptibly ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . ImmutableCollection ; import com . google . j2objc . annotations . WeakOuter ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . Nullable ; @GwtCompatible abstract class AggregateFuture < InputT , OutputT > extends AbstractFuture . TrustedFuture < OutputT > { private static final Logger logger = Logger . getLogger ( AggregateFuture . class . getName ( ) ) ; private RunningState runningState ; @Override final void done ( ) { super . done ( ) ; this . runningState = null ; } @Override public final boolean cancel ( boolean mayInterruptIfRunning ) { RunningState localRunningState = runningState ; ImmutableCollection < ? extends ListenableFuture < ? extends InputT > > futures = ( localRunningState ! = null ) ? localRunningState . futures : null ; boolean cancelled = super . cancel ( mayInterruptIfRunning ) ; if ( cancelled & futures ! = null ) { for ( ListenableFuture < ? > future : futures ) { future . cancel ( mayInterruptIfRunning ) ; } } return cancelled ; } @GwtIncompatible ( <str> ) @Override protected final void interruptTask ( ) { RunningState localRunningState = runningState ; if ( localRunningState ! = null ) { localRunningState . interruptTask ( ) ; } } final void init ( RunningState runningState ) { this . runningState = runningState ; runningState . init ( ) ; } @WeakOuter abstract class RunningState extends AggregateFutureState implements Runnable { private ImmutableCollection < ? extends ListenableFuture < ? extends InputT > > futures ; private final boolean allMustSucceed ; private final boolean collectsValues ; RunningState ( ImmutableCollection < ? extends ListenableFuture < ? extends InputT > > futures , boolean allMustSucceed , boolean collectsValues ) { super ( futures . size ( ) ) ; this . futures = checkNotNull ( futures ) ; this . allMustSucceed = allMustSucceed ; this . collectsValues = collectsValues ; } @Override public final void run ( ) { decrementCountAndMaybeComplete ( ) ; } private void init ( ) { if ( futures . isEmpty ( ) ) { handleAllCompleted ( ) ; return ; } if ( allMustSucceed ) { int i = <int> ; for ( final ListenableFuture < ? extends InputT > listenable : futures ) { final int index = i + + ; listenable . addListener ( new Runnable ( ) { @Override public void run ( ) { try { handleOneInputDone ( index , listenable ) ; } finally { decrementCountAndMaybeComplete ( ) ; } } } , directExecutor ( ) ) ; } } else { for ( ListenableFuture < ? extends InputT > listenable : futures ) { listenable . addListener ( this , directExecutor ( ) ) ; } } } private void handleException ( Throwable throwable ) { checkNotNull ( throwable ) ; boolean completedWithFailure = false ; boolean firstTimeSeeingThisException = true ; if ( allMustSucceed ) { completedWithFailure = setException ( throwable ) ; if ( completedWithFailure ) { releaseResourcesAfterFailure ( ) ; } else { firstTimeSeeingThisException = addCausalChain ( getOrInitSeenExceptions ( ) , throwable ) ; } } if ( throwable instanceof Error | ( allMustSucceed & ! completedWithFailure & firstTimeSeeingThisException ) ) { String message = ( throwable instanceof Error ) ? <str> : <str> ; logger . log ( Level . SEVERE , message , throwable ) ; } } @Override final void addInitialException ( Set < Throwable > seen ) { if ( ! isCancelled ( ) ) { addCausalChain ( seen , trustedGetException ( ) ) ; } } private void handleOneInputDone ( int index , Future < ? extends InputT > future ) { checkState ( allMustSucceed | | ! isDone ( ) | | isCancelled ( ) , <str> ) ; try { checkState ( future . isDone ( ) , <str> ) ; if ( allMustSucceed ) { if ( future . isCancelled ( ) ) { AggregateFuture . super . cancel ( false ) ; } else { InputT result = getUninterruptibly ( future ) ; if ( collectsValues ) { collectOneValue ( allMustSucceed , index , result ) ; } } } else if ( collectsValues & & ! future . isCancelled ( ) ) { collectOneValue ( allMustSucceed , index , getUninterruptibly ( future ) ) ; } } catch ( ExecutionException e ) { handleException ( e . getCause ( ) ) ; } catch ( Throwable t ) { handleException ( t ) ; } } private void decrementCountAndMaybeComplete ( ) { int newRemaining = decrementRemainingAndGet ( ) ; checkState ( newRemaining > = <int> , <str> ) ; if ( newRemaining = = <int> ) { processCompleted ( ) ; } } private void processCompleted ( ) { if ( collectsValues & ! allMustSucceed ) { int i = <int> ; for ( ListenableFuture < ? extends InputT > listenable : futures ) { handleOneInputDone ( i + + , listenable ) ; } } handleAllCompleted ( ) ; } void releaseResourcesAfterFailure ( ) { this . futures = null ; } abstract void collectOneValue ( boolean allMustSucceed , int index , @Nullable InputT returnValue ) ; abstract void handleAllCompleted ( ) ; void interruptTask ( ) { } } private static boolean addCausalChain ( Set < Throwable > seen , Throwable t ) { for ( ; t ! = null ; t = t . getCause ( ) ) { boolean firstTimeSeen = seen . add ( t ) ; if ( ! firstTimeSeen ) { return false ; } } return true ; } } 
