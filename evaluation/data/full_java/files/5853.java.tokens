package org . elasticsearch . common . inject . internal ; import org . elasticsearch . common . inject . ConfigurationException ; import org . elasticsearch . common . inject . TypeLiteral ; import org . elasticsearch . common . inject . spi . Message ; import java . io . Serializable ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . GenericDeclaration ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . lang . reflect . WildcardType ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Objects ; import static java . util . Collections . singleton ; import static java . util . Collections . unmodifiableMap ; public class MoreTypes { public static final Type [ ] EMPTY_TYPE_ARRAY = new Type [ ] { } ; private MoreTypes ( ) { } private static final Map < TypeLiteral < ? > , TypeLiteral < ? > > PRIMITIVE_TO_WRAPPER ; static { Map < TypeLiteral < ? > , TypeLiteral < ? > > primitiveToWrapper = new HashMap < > ( ) ; primitiveToWrapper . put ( TypeLiteral . get ( boolean . class ) , TypeLiteral . get ( Boolean . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( byte . class ) , TypeLiteral . get ( Byte . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( short . class ) , TypeLiteral . get ( Short . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( int . class ) , TypeLiteral . get ( Integer . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( long . class ) , TypeLiteral . get ( Long . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( float . class ) , TypeLiteral . get ( Float . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( double . class ) , TypeLiteral . get ( Double . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( char . class ) , TypeLiteral . get ( Character . class ) ) ; primitiveToWrapper . put ( TypeLiteral . get ( void . class ) , TypeLiteral . get ( Void . class ) ) ; PRIMITIVE_TO_WRAPPER = unmodifiableMap ( primitiveToWrapper ) ; } public static < T > TypeLiteral < T > makeKeySafe ( TypeLiteral < T > type ) { if ( ! isFullySpecified ( type . getType ( ) ) ) { String message = type + <str> ; throw new ConfigurationException ( singleton ( new Message ( message ) ) ) ; } @SuppressWarnings ( <str> ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( type ) ; return wrappedPrimitives ! = null ? wrappedPrimitives : type ; } private static boolean isFullySpecified ( Type type ) { if ( type instanceof Class ) { return true ; } else if ( type instanceof CompositeType ) { return ( ( CompositeType ) type ) . isFullySpecified ( ) ; } else if ( type instanceof TypeVariable ) { return false ; } else { return ( ( CompositeType ) canonicalize ( type ) ) . isFullySpecified ( ) ; } } public static Type canonicalize ( Type type ) { if ( type instanceof ParameterizedTypeImpl | | type instanceof GenericArrayTypeImpl | | type instanceof WildcardTypeImpl ) { return type ; } else if ( type instanceof ParameterizedType ) { ParameterizedType p = ( ParameterizedType ) type ; return new ParameterizedTypeImpl ( p . getOwnerType ( ) , p . getRawType ( ) , p . getActualTypeArguments ( ) ) ; } else if ( type instanceof GenericArrayType ) { GenericArrayType g = ( GenericArrayType ) type ; return new GenericArrayTypeImpl ( g . getGenericComponentType ( ) ) ; } else if ( type instanceof Class & & ( ( Class < ? > ) type ) . isArray ( ) ) { Class < ? > c = ( Class < ? > ) type ; return new GenericArrayTypeImpl ( c . getComponentType ( ) ) ; } else if ( type instanceof WildcardType ) { WildcardType w = ( WildcardType ) type ; return new WildcardTypeImpl ( w . getUpperBounds ( ) , w . getLowerBounds ( ) ) ; } else { return type ; } } public static Member serializableCopy ( Member member ) { return member instanceof MemberImpl ? member : new MemberImpl ( member ) ; } public static Class < ? > getRawType ( Type type ) { if ( type instanceof Class < ? > ) { return ( Class < ? > ) type ; } else if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type rawType = parameterizedType . getRawType ( ) ; if ( ! ( rawType instanceof Class ) ) { throw new IllegalArgumentException ( <str> + type + <str> + type . getClass ( ) . getName ( ) ) ; } return ( Class < ? > ) rawType ; } else if ( type instanceof GenericArrayType ) { return Object [ ] . class ; } else if ( type instanceof TypeVariable ) { return Object . class ; } else { throw new IllegalArgumentException ( <str> + <str> + type + <str> + type . getClass ( ) . getName ( ) ) ; } } public static boolean equals ( Type a , Type b ) { if ( a = = b ) { return true ; } else if ( a instanceof Class ) { return a . equals ( b ) ; } else if ( a instanceof ParameterizedType ) { if ( ! ( b instanceof ParameterizedType ) ) { return false ; } ParameterizedType pa = ( ParameterizedType ) a ; ParameterizedType pb = ( ParameterizedType ) b ; return Objects . equals ( pa . getOwnerType ( ) , pb . getOwnerType ( ) ) & & pa . getRawType ( ) . equals ( pb . getRawType ( ) ) & & Arrays . equals ( pa . getActualTypeArguments ( ) , pb . getActualTypeArguments ( ) ) ; } else if ( a instanceof GenericArrayType ) { if ( ! ( b instanceof GenericArrayType ) ) { return false ; } GenericArrayType ga = ( GenericArrayType ) a ; GenericArrayType gb = ( GenericArrayType ) b ; return equals ( ga . getGenericComponentType ( ) , gb . getGenericComponentType ( ) ) ; } else if ( a instanceof WildcardType ) { if ( ! ( b instanceof WildcardType ) ) { return false ; } WildcardType wa = ( WildcardType ) a ; WildcardType wb = ( WildcardType ) b ; return Arrays . equals ( wa . getUpperBounds ( ) , wb . getUpperBounds ( ) ) & & Arrays . equals ( wa . getLowerBounds ( ) , wb . getLowerBounds ( ) ) ; } else if ( a instanceof TypeVariable ) { if ( ! ( b instanceof TypeVariable ) ) { return false ; } TypeVariable < ? > va = ( TypeVariable ) a ; TypeVariable < ? > vb = ( TypeVariable ) b ; return va . getGenericDeclaration ( ) = = vb . getGenericDeclaration ( ) & & va . getName ( ) . equals ( vb . getName ( ) ) ; } else { return false ; } } public static int hashCode ( Type type ) { if ( type instanceof Class ) { return type . hashCode ( ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType p = ( ParameterizedType ) type ; return Arrays . hashCode ( p . getActualTypeArguments ( ) ) ^ p . getRawType ( ) . hashCode ( ) ^ hashCodeOrZero ( p . getOwnerType ( ) ) ; } else if ( type instanceof GenericArrayType ) { return hashCode ( ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ) ; } else if ( type instanceof WildcardType ) { WildcardType w = ( WildcardType ) type ; return Arrays . hashCode ( w . getLowerBounds ( ) ) ^ Arrays . hashCode ( w . getUpperBounds ( ) ) ; } else { return hashCodeOrZero ( type ) ; } } private static int hashCodeOrZero ( Object o ) { return o ! = null ? o . hashCode ( ) : <int> ; } public static String toString ( Type type ) { if ( type instanceof Class < ? > ) { return ( ( Class ) type ) . getName ( ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; Type ownerType = parameterizedType . getOwnerType ( ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; if ( ownerType ! = null ) { stringBuilder . append ( toString ( ownerType ) ) . append ( <str> ) ; } stringBuilder . append ( toString ( parameterizedType . getRawType ( ) ) ) ; if ( arguments . length > <int> ) { stringBuilder . append ( <str> ) . append ( toString ( arguments [ <int> ] ) ) ; for ( int i = <int> ; i < arguments . length ; i + + ) { stringBuilder . append ( <str> ) . append ( toString ( arguments [ i ] ) ) ; } } return stringBuilder . append ( <str> ) . toString ( ) ; } else if ( type instanceof GenericArrayType ) { return toString ( ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ) + <str> ; } else if ( type instanceof WildcardType ) { WildcardType wildcardType = ( WildcardType ) type ; Type [ ] lowerBounds = wildcardType . getLowerBounds ( ) ; Type [ ] upperBounds = wildcardType . getUpperBounds ( ) ; if ( upperBounds . length ! = <int> | | lowerBounds . length > <int> ) { throw new UnsupportedOperationException ( <str> + type ) ; } if ( lowerBounds . length = = <int> ) { if ( upperBounds [ <int> ] ! = Object . class ) { throw new UnsupportedOperationException ( <str> + type ) ; } return <str> + toString ( lowerBounds [ <int> ] ) ; } else if ( upperBounds [ <int> ] = = Object . class ) { return <str> ; } else { return <str> + toString ( upperBounds [ <int> ] ) ; } } else { return type . toString ( ) ; } } public static Class < ? extends Member > memberType ( Member member ) { Objects . requireNonNull ( member , <str> ) ; if ( member instanceof MemberImpl ) { return ( ( MemberImpl ) member ) . memberType ; } else if ( member instanceof Field ) { return Field . class ; } else if ( member instanceof Method ) { return Method . class ; } else if ( member instanceof Constructor ) { return Constructor . class ; } else { throw new IllegalArgumentException ( <str> + member . getClass ( ) ) ; } } public static String toString ( Member member ) { Class < ? extends Member > memberType = memberType ( member ) ; if ( memberType = = Method . class ) { return member . getDeclaringClass ( ) . getName ( ) + <str> + member . getName ( ) + <str> ; } else if ( memberType = = Field . class ) { return member . getDeclaringClass ( ) . getName ( ) + <str> + member . getName ( ) ; } else if ( memberType = = Constructor . class ) { return member . getDeclaringClass ( ) . getName ( ) + <str> ; } else { throw new AssertionError ( ) ; } } public static String memberKey ( Member member ) { Objects . requireNonNull ( member , <str> ) ; return <str> ; } public static Type getGenericSupertype ( Type type , Class < ? > rawType , Class < ? > toResolve ) { if ( toResolve = = rawType ) { return type ; } if ( toResolve . isInterface ( ) ) { Class [ ] interfaces = rawType . getInterfaces ( ) ; for ( int i = <int> , length = interfaces . length ; i < length ; i + + ) { if ( interfaces [ i ] = = toResolve ) { return rawType . getGenericInterfaces ( ) [ i ] ; } else if ( toResolve . isAssignableFrom ( interfaces [ i ] ) ) { return getGenericSupertype ( rawType . getGenericInterfaces ( ) [ i ] , interfaces [ i ] , toResolve ) ; } } } if ( ! rawType . isInterface ( ) ) { while ( rawType ! = Object . class ) { Class < ? > rawSupertype = rawType . getSuperclass ( ) ; if ( rawSupertype = = toResolve ) { return rawType . getGenericSuperclass ( ) ; } else if ( toResolve . isAssignableFrom ( rawSupertype ) ) { return getGenericSupertype ( rawType . getGenericSuperclass ( ) , rawSupertype , toResolve ) ; } rawType = rawSupertype ; } } return toResolve ; } public static Type resolveTypeVariable ( Type type , Class < ? > rawType , TypeVariable unknown ) { Class < ? > declaredByRaw = declaringClassOf ( unknown ) ; if ( declaredByRaw = = null ) { return unknown ; } Type declaredBy = getGenericSupertype ( type , rawType , declaredByRaw ) ; if ( declaredBy instanceof ParameterizedType ) { int index = indexOf ( declaredByRaw . getTypeParameters ( ) , unknown ) ; return ( ( ParameterizedType ) declaredBy ) . getActualTypeArguments ( ) [ index ] ; } return unknown ; } private static int indexOf ( Object [ ] array , Object toFind ) { for ( int i = <int> ; i < array . length ; i + + ) { if ( toFind . equals ( array [ i ] ) ) { return i ; } } throw new NoSuchElementException ( ) ; } private static Class < ? > declaringClassOf ( TypeVariable typeVariable ) { GenericDeclaration genericDeclaration = typeVariable . getGenericDeclaration ( ) ; return genericDeclaration instanceof Class ? ( Class < ? > ) genericDeclaration : null ; } public static class ParameterizedTypeImpl implements ParameterizedType , Serializable , CompositeType { private final Type ownerType ; private final Type rawType ; private final Type [ ] typeArguments ; public ParameterizedTypeImpl ( Type ownerType , Type rawType , Type . . . typeArguments ) { if ( rawType instanceof Class < ? > ) { Class rawTypeAsClass = ( Class ) rawType ; if ( ownerType = = null & & rawTypeAsClass . getEnclosingClass ( ) ! = null ) { throw new IllegalArgumentException ( <str> + rawType ) ; } if ( ownerType ! = null & & rawTypeAsClass . getEnclosingClass ( ) = = null ) { throw new IllegalArgumentException ( <str> + rawType ) ; } } this . ownerType = ownerType = = null ? null : canonicalize ( ownerType ) ; this . rawType = canonicalize ( rawType ) ; this . typeArguments = typeArguments . clone ( ) ; for ( int t = <int> ; t < this . typeArguments . length ; t + + ) { Objects . requireNonNull ( this . typeArguments [ t ] , <str> ) ; checkNotPrimitive ( this . typeArguments [ t ] , <str> ) ; this . typeArguments [ t ] = canonicalize ( this . typeArguments [ t ] ) ; } } @Override public Type [ ] getActualTypeArguments ( ) { return typeArguments . clone ( ) ; } @Override public Type getRawType ( ) { return rawType ; } @Override public Type getOwnerType ( ) { return ownerType ; } @Override public boolean isFullySpecified ( ) { if ( ownerType ! = null & & ! MoreTypes . isFullySpecified ( ownerType ) ) { return false ; } if ( ! MoreTypes . isFullySpecified ( rawType ) ) { return false ; } for ( Type type : typeArguments ) { if ( ! MoreTypes . isFullySpecified ( type ) ) { return false ; } } return true ; } @Override public boolean equals ( Object other ) { return other instanceof ParameterizedType & & MoreTypes . equals ( this , ( ParameterizedType ) other ) ; } @Override public int hashCode ( ) { return MoreTypes . hashCode ( this ) ; } @Override public String toString ( ) { return MoreTypes . toString ( this ) ; } private static final long serialVersionUID = <int> ; } public static class GenericArrayTypeImpl implements GenericArrayType , Serializable , CompositeType { private final Type componentType ; public GenericArrayTypeImpl ( Type componentType ) { this . componentType = canonicalize ( componentType ) ; } @Override public Type getGenericComponentType ( ) { return componentType ; } @Override public boolean isFullySpecified ( ) { return MoreTypes . isFullySpecified ( componentType ) ; } @Override public boolean equals ( Object o ) { return o instanceof GenericArrayType & & MoreTypes . equals ( this , ( GenericArrayType ) o ) ; } @Override public int hashCode ( ) { return MoreTypes . hashCode ( this ) ; } @Override public String toString ( ) { return MoreTypes . toString ( this ) ; } private static final long serialVersionUID = <int> ; } public static class WildcardTypeImpl implements WildcardType , Serializable , CompositeType { private final Type upperBound ; private final Type lowerBound ; public WildcardTypeImpl ( Type [ ] upperBounds , Type [ ] lowerBounds ) { if ( lowerBounds . length > <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( upperBounds . length ! = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( lowerBounds . length = = <int> ) { Objects . requireNonNull ( lowerBounds [ <int> ] , <str> ) ; checkNotPrimitive ( lowerBounds [ <int> ] , <str> ) ; if ( upperBounds [ <int> ] ! = Object . class ) { throw new IllegalArgumentException ( <str> ) ; } this . lowerBound = canonicalize ( lowerBounds [ <int> ] ) ; this . upperBound = Object . class ; } else { Objects . requireNonNull ( upperBounds [ <int> ] , <str> ) ; checkNotPrimitive ( upperBounds [ <int> ] , <str> ) ; this . lowerBound = null ; this . upperBound = canonicalize ( upperBounds [ <int> ] ) ; } } @Override public Type [ ] getUpperBounds ( ) { return new Type [ ] { upperBound } ; } @Override public Type [ ] getLowerBounds ( ) { return lowerBound ! = null ? new Type [ ] { lowerBound } : EMPTY_TYPE_ARRAY ; } @Override public boolean isFullySpecified ( ) { return MoreTypes . isFullySpecified ( upperBound ) & & ( lowerBound = = null | | MoreTypes . isFullySpecified ( lowerBound ) ) ; } @Override public boolean equals ( Object other ) { return other instanceof WildcardType & & MoreTypes . equals ( this , ( WildcardType ) other ) ; } @Override public int hashCode ( ) { return MoreTypes . hashCode ( this ) ; } @Override public String toString ( ) { return MoreTypes . toString ( this ) ; } private static final long serialVersionUID = <int> ; } private static void checkNotPrimitive ( Type type , String use ) { if ( type instanceof Class < ? > & & ( ( Class ) type ) . isPrimitive ( ) ) { throw new IllegalArgumentException ( <str> + use + <str> + type ) ; } } public static class MemberImpl implements Member , Serializable { private final Class < ? > declaringClass ; private final String name ; private final int modifiers ; private final boolean synthetic ; private final Class < ? extends Member > memberType ; private final String memberKey ; private MemberImpl ( Member member ) { this . declaringClass = member . getDeclaringClass ( ) ; this . name = member . getName ( ) ; this . modifiers = member . getModifiers ( ) ; this . synthetic = member . isSynthetic ( ) ; this . memberType = memberType ( member ) ; this . memberKey = memberKey ( member ) ; } @Override public Class getDeclaringClass ( ) { return declaringClass ; } @Override public String getName ( ) { return name ; } @Override public int getModifiers ( ) { return modifiers ; } @Override public boolean isSynthetic ( ) { return synthetic ; } @Override public String toString ( ) { return MoreTypes . toString ( this ) ; } } private interface CompositeType { boolean isFullySpecified ( ) ; } } 
