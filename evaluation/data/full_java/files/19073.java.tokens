package io . netty . handler . codec . http ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public abstract class DefaultHttpMessage extends DefaultHttpObject implements HttpMessage { private static final int HASH_CODE_PRIME = <int> ; private HttpVersion version ; private final HttpHeaders headers ; protected DefaultHttpMessage ( final HttpVersion version ) { this ( version , true , false ) ; } protected DefaultHttpMessage ( final HttpVersion version , boolean validateHeaders , boolean singleFieldHeaders ) { this . version = checkNotNull ( version , <str> ) ; headers = singleFieldHeaders ? new CombinedHttpHeaders ( validateHeaders ) : new DefaultHttpHeaders ( validateHeaders ) ; } @Override public HttpHeaders headers ( ) { return headers ; } @Override @Deprecated public HttpVersion getProtocolVersion ( ) { return protocolVersion ( ) ; } @Override public HttpVersion protocolVersion ( ) { return version ; } @Override public int hashCode ( ) { int result = <int> ; result = HASH_CODE_PRIME * result + headers . hashCode ( ) ; result = HASH_CODE_PRIME * result + version . hashCode ( ) ; result = HASH_CODE_PRIME * result + super . hashCode ( ) ; return result ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof DefaultHttpMessage ) ) { return false ; } DefaultHttpMessage other = ( DefaultHttpMessage ) o ; return headers ( ) . equals ( other . headers ( ) ) & & protocolVersion ( ) . equals ( other . protocolVersion ( ) ) & & super . equals ( o ) ; } @Override public HttpMessage setProtocolVersion ( HttpVersion version ) { if ( version = = null ) { throw new NullPointerException ( <str> ) ; } this . version = version ; return this ; } } 
