package org . elasticsearch . test . engine ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . IndexSearcher ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . shard . ShardId ; import java . util . concurrent . atomic . AtomicBoolean ; class AssertingSearcher extends Engine . Searcher { private final Engine . Searcher wrappedSearcher ; private final ShardId shardId ; private RuntimeException firstReleaseStack ; private final Object lock = new Object ( ) ; private final int initialRefCount ; private final ESLogger logger ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; AssertingSearcher ( IndexSearcher indexSearcher , final Engine . Searcher wrappedSearcher , ShardId shardId , ESLogger logger ) { super ( wrappedSearcher . source ( ) , indexSearcher ) ; this . wrappedSearcher = wrappedSearcher ; this . logger = logger ; this . shardId = shardId ; initialRefCount = wrappedSearcher . reader ( ) . getRefCount ( ) ; assert initialRefCount > <int> : <str> + initialRefCount + <str> ; } @Override public String source ( ) { return wrappedSearcher . source ( ) ; } @Override public void close ( ) { synchronized ( lock ) { if ( closed . compareAndSet ( false , true ) ) { firstReleaseStack = new RuntimeException ( ) ; final int refCount = wrappedSearcher . reader ( ) . getRefCount ( ) ; assert refCount > <int> : <str> + refCount + <str> + initialRefCount + <str> ; try { wrappedSearcher . close ( ) ; } catch ( RuntimeException ex ) { logger . debug ( <str> , ex ) ; throw ex ; } } else { AssertionError error = new AssertionError ( <str> + wrappedSearcher . source ( ) + <str> ) ; error . initCause ( firstReleaseStack ) ; throw error ; } } } public ShardId shardId ( ) { return shardId ; } public boolean isOpen ( ) { return closed . get ( ) = = false ; } } 
