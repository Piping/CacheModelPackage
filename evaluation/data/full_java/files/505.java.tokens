package org . apache . cassandra . db . rows ; import java . util . * ; import java . security . MessageDigest ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . service . paxos . Commit ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . MergeIterator ; import org . apache . cassandra . utils . SearchIterator ; import org . apache . cassandra . utils . btree . BTree ; import org . apache . cassandra . utils . btree . UpdateFunction ; public interface Row extends Unfiltered , Collection < ColumnData > { @Override public Clustering clustering ( ) ; public Collection < ColumnDefinition > columns ( ) ; public Deletion deletion ( ) ; public LivenessInfo primaryKeyLivenessInfo ( ) ; public boolean isStatic ( ) ; public boolean isEmpty ( ) ; public boolean hasLiveData ( int nowInSec ) ; public Cell getCell ( ColumnDefinition c ) ; public Cell getCell ( ColumnDefinition c , CellPath path ) ; public ComplexColumnData getComplexColumnData ( ColumnDefinition c ) ; public Iterable < Cell > cells ( ) ; public Iterable < Cell > cellsInLegacyOrder ( CFMetaData metadata , boolean reversed ) ; public boolean hasComplexDeletion ( ) ; boolean hasComplex ( ) ; public boolean hasDeletion ( int nowInSec ) ; public SearchIterator < ColumnDefinition , ColumnData > searchIterator ( ) ; public Row filter ( ColumnFilter filter , CFMetaData metadata ) ; public Row filter ( ColumnFilter filter , DeletionTime activeDeletion , boolean setActiveDeletionToRow , CFMetaData metadata ) ; public Row purge ( DeletionPurger purger , int nowInSec ) ; public Row markCounterLocalToBeCleared ( ) ; public Row updateAllTimestamp ( long newTimestamp ) ; public int dataSize ( ) ; public long unsharedHeapSizeExcludingData ( ) ; public String toString ( CFMetaData metadata , boolean fullDetails ) ; public static class Deletion { public static final Deletion LIVE = new Deletion ( DeletionTime . LIVE , false ) ; private final DeletionTime time ; private final boolean isShadowable ; public Deletion ( DeletionTime time , boolean isShadowable ) { assert ! time . isLive ( ) | | ! isShadowable ; this . time = time ; this . isShadowable = isShadowable ; } public static Deletion regular ( DeletionTime time ) { return time . isLive ( ) ? LIVE : new Deletion ( time , false ) ; } public static Deletion shadowable ( DeletionTime time ) { return new Deletion ( time , true ) ; } public DeletionTime time ( ) { return time ; } public boolean isShadowable ( ) { return isShadowable ; } public boolean isLive ( ) { return time ( ) . isLive ( ) ; } public boolean supersedes ( DeletionTime that ) { return time . supersedes ( that ) ; } public boolean supersedes ( Deletion that ) { return time . supersedes ( that . time ) ; } public boolean isShadowedBy ( LivenessInfo primaryKeyLivenessInfo ) { return isShadowable & & primaryKeyLivenessInfo . timestamp ( ) > time . markedForDeleteAt ( ) ; } public boolean deletes ( LivenessInfo info ) { return time . deletes ( info ) ; } public void digest ( MessageDigest digest ) { time . digest ( digest ) ; FBUtilities . updateWithBoolean ( digest , isShadowable ) ; } public int dataSize ( ) { return time . dataSize ( ) + <int> ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof Deletion ) ) return false ; Deletion that = ( Deletion ) o ; return this . time . equals ( that . time ) & & this . isShadowable = = that . isShadowable ; } @Override public final int hashCode ( ) { return Objects . hash ( time , isShadowable ) ; } @Override public String toString ( ) { return String . format ( <str> , time , isShadowable ? <str> : <str> ) ; } } public interface Builder { public boolean isSorted ( ) ; public void newRow ( Clustering clustering ) ; public Clustering clustering ( ) ; public void addPrimaryKeyLivenessInfo ( LivenessInfo info ) ; public void addRowDeletion ( Deletion deletion ) ; public void addCell ( Cell cell ) ; public void addComplexDeletion ( ColumnDefinition column , DeletionTime complexDeletion ) ; public Row build ( ) ; } public static class Merger { private final Row [ ] rows ; private final List < Iterator < ColumnData > > columnDataIterators ; private Clustering clustering ; private int rowsToMerge ; private int lastRowSet = - <int> ; private final List < ColumnData > dataBuffer = new ArrayList < > ( ) ; private final ColumnDataReducer columnDataReducer ; public Merger ( int size , int nowInSec , boolean hasComplex ) { this . rows = new Row [ size ] ; this . columnDataIterators = new ArrayList < > ( size ) ; this . columnDataReducer = new ColumnDataReducer ( size , nowInSec , hasComplex ) ; } public void clear ( ) { dataBuffer . clear ( ) ; Arrays . fill ( rows , null ) ; columnDataIterators . clear ( ) ; rowsToMerge = <int> ; lastRowSet = - <int> ; } public void add ( int i , Row row ) { clustering = row . clustering ( ) ; rows [ i ] = row ; + + rowsToMerge ; lastRowSet = i ; } public Row merge ( DeletionTime activeDeletion ) { if ( rowsToMerge = = <int> & & activeDeletion . isLive ( ) ) { Row row = rows [ lastRowSet ] ; assert row ! = null ; return row ; } LivenessInfo rowInfo = LivenessInfo . EMPTY ; Deletion rowDeletion = Deletion . LIVE ; for ( Row row : rows ) { if ( row = = null ) continue ; if ( row . primaryKeyLivenessInfo ( ) . supersedes ( rowInfo ) ) rowInfo = row . primaryKeyLivenessInfo ( ) ; if ( row . deletion ( ) . supersedes ( rowDeletion ) ) rowDeletion = row . deletion ( ) ; } if ( rowDeletion . isShadowedBy ( rowInfo ) ) rowDeletion = Deletion . LIVE ; if ( rowDeletion . supersedes ( activeDeletion ) ) activeDeletion = rowDeletion . time ( ) ; else rowDeletion = Deletion . LIVE ; if ( activeDeletion . deletes ( rowInfo ) ) rowInfo = LivenessInfo . EMPTY ; for ( Row row : rows ) columnDataIterators . add ( row = = null ? Collections . emptyIterator ( ) : row . iterator ( ) ) ; columnDataReducer . setActiveDeletion ( activeDeletion ) ; Iterator < ColumnData > merged = MergeIterator . get ( columnDataIterators , ColumnData . comparator , columnDataReducer ) ; while ( merged . hasNext ( ) ) { ColumnData data = merged . next ( ) ; if ( data ! = null ) dataBuffer . add ( data ) ; } return rowInfo . isEmpty ( ) & & rowDeletion . isLive ( ) & & dataBuffer . isEmpty ( ) ? null : BTreeRow . create ( clustering , rowInfo , rowDeletion , BTree . build ( dataBuffer , UpdateFunction . < ColumnData > noOp ( ) ) ) ; } public Clustering mergedClustering ( ) { return clustering ; } public Row [ ] mergedRows ( ) { return rows ; } private static class ColumnDataReducer extends MergeIterator . Reducer < ColumnData , ColumnData > { private final int nowInSec ; private ColumnDefinition column ; private final List < ColumnData > versions ; private DeletionTime activeDeletion ; private final ComplexColumnData . Builder complexBuilder ; private final List < Iterator < Cell > > complexCells ; private final CellReducer cellReducer ; public ColumnDataReducer ( int size , int nowInSec , boolean hasComplex ) { this . nowInSec = nowInSec ; this . versions = new ArrayList < > ( size ) ; this . complexBuilder = hasComplex ? ComplexColumnData . builder ( ) : null ; this . complexCells = hasComplex ? new ArrayList < > ( size ) : null ; this . cellReducer = new CellReducer ( nowInSec ) ; } public void setActiveDeletion ( DeletionTime activeDeletion ) { this . activeDeletion = activeDeletion ; } public void reduce ( int idx , ColumnData data ) { column = data . column ( ) ; versions . add ( data ) ; } protected ColumnData getReduced ( ) { if ( column . isSimple ( ) ) { Cell merged = null ; for ( ColumnData data : versions ) { Cell cell = ( Cell ) data ; if ( ! activeDeletion . deletes ( cell ) ) merged = merged = = null ? cell : Cells . reconcile ( merged , cell , nowInSec ) ; } return merged ; } else { complexBuilder . newColumn ( column ) ; complexCells . clear ( ) ; DeletionTime complexDeletion = DeletionTime . LIVE ; for ( ColumnData data : versions ) { ComplexColumnData cd = ( ComplexColumnData ) data ; if ( cd . complexDeletion ( ) . supersedes ( complexDeletion ) ) complexDeletion = cd . complexDeletion ( ) ; complexCells . add ( cd . iterator ( ) ) ; } if ( complexDeletion . supersedes ( activeDeletion ) ) { cellReducer . setActiveDeletion ( complexDeletion ) ; complexBuilder . addComplexDeletion ( complexDeletion ) ; } else { cellReducer . setActiveDeletion ( activeDeletion ) ; } Iterator < Cell > cells = MergeIterator . get ( complexCells , Cell . comparator , cellReducer ) ; while ( cells . hasNext ( ) ) { Cell merged = cells . next ( ) ; if ( merged ! = null ) complexBuilder . addCell ( merged ) ; } return complexBuilder . build ( ) ; } } protected void onKeyChange ( ) { versions . clear ( ) ; } } private static class CellReducer extends MergeIterator . Reducer < Cell , Cell > { private final int nowInSec ; private DeletionTime activeDeletion ; private Cell merged ; public CellReducer ( int nowInSec ) { this . nowInSec = nowInSec ; } public void setActiveDeletion ( DeletionTime activeDeletion ) { this . activeDeletion = activeDeletion ; onKeyChange ( ) ; } public void reduce ( int idx , Cell cell ) { if ( ! activeDeletion . deletes ( cell ) ) merged = merged = = null ? cell : Cells . reconcile ( merged , cell , nowInSec ) ; } protected Cell getReduced ( ) { return merged ; } protected void onKeyChange ( ) { merged = null ; } } } } 
