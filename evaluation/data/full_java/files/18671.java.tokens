package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . utils . AnimationController ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . StringBuilder ; public class ModelTest extends BaseG3dHudTest { protected Environment environment ; ObjectMap < ModelInstance , AnimationController > animationControllers = new ObjectMap < ModelInstance , AnimationController > ( ) ; @Override public void create ( ) { super . create ( ) ; environment = new Environment ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; environment . add ( new DirectionalLight ( ) . set ( <float> , <float> , <float> , - <float> , - <float> , - <float> ) ) ; cam . position . set ( <int> , <int> , <int> ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . update ( ) ; showAxes = true ; onModelClicked ( <str> ) ; } private final Vector3 tmpV1 = new Vector3 ( ) , tmpV2 = new Vector3 ( ) ; private final Quaternion tmpQ = new Quaternion ( ) ; private final BoundingBox bounds = new BoundingBox ( ) ; @Override protected void render ( ModelBatch batch , Array < ModelInstance > instances ) { for ( ObjectMap . Entry < ModelInstance , AnimationController > e : animationControllers . entries ( ) ) e . value . update ( Gdx . graphics . getDeltaTime ( ) ) ; batch . render ( instances , environment ) ; } @Override protected void getStatus ( StringBuilder stringBuilder ) { super . getStatus ( stringBuilder ) ; for ( final ModelInstance instance : instances ) { if ( instance . animations . size > <int> ) { stringBuilder . append ( <str> ) ; break ; } } } protected String currentlyLoading ; @Override protected void onModelClicked ( final String name ) { if ( name = = null ) return ; currentlyLoading = <str> + name ; assets . load ( currentlyLoading , Model . class ) ; loading = true ; } @Override protected void onLoaded ( ) { if ( currentlyLoading = = null | | currentlyLoading . length ( ) = = <int> ) return ; instances . clear ( ) ; animationControllers . clear ( ) ; final ModelInstance instance = new ModelInstance ( assets . get ( currentlyLoading , Model . class ) ) ; instance . transform = transform ; instances . add ( instance ) ; if ( instance . animations . size > <int> ) animationControllers . put ( instance , new AnimationController ( instance ) ) ; currentlyLoading = null ; instance . calculateBoundingBox ( bounds ) ; cam . position . set ( <int> , <int> , <int> ) . nor ( ) . scl ( bounds . getDimensions ( tmpV1 ) . len ( ) * <float> + bounds . getCenter ( tmpV2 ) . len ( ) ) ; cam . up . set ( <int> , <int> , <int> ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . far = <int> f + bounds . getDimensions ( tmpV1 ) . len ( ) * <float> ; cam . update ( ) ; } protected void switchAnimation ( ) { for ( ObjectMap . Entry < ModelInstance , AnimationController > e : animationControllers . entries ( ) ) { int animIndex = <int> ; if ( e . value . current ! = null ) { for ( int i = <int> ; i < e . key . animations . size ; i + + ) { final Animation animation = e . key . animations . get ( i ) ; if ( e . value . current . animation = = animation ) { animIndex = i ; break ; } } } animIndex = ( animIndex + <int> ) % ( e . key . animations . size + <int> ) ; e . value . animate ( ( animIndex = = e . key . animations . size ) ? null : e . key . animations . get ( animIndex ) . id , - <int> , <float> , null , <float> ) ; } } @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . SPACE | | keycode = = Keys . MENU ) switchAnimation ( ) ; return super . keyUp ( keycode ) ; } } 
