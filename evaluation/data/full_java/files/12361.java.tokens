package org . gradle . api . internal ; import org . gradle . api . InvalidUserDataException ; import org . gradle . util . TestUtil ; import org . gradle . util . TestTask ; import org . junit . Before ; import org . junit . Test ; import java . util . List ; import java . util . concurrent . Callable ; import static java . util . Collections . emptyList ; import static java . util . Collections . emptyMap ; import static org . gradle . util . WrapUtil . toList ; import static org . gradle . util . WrapUtil . toMap ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . sameInstance ; import static org . junit . Assert . * ; public class ConventionAwareHelperTest { ConventionAwareHelper conventionAware ; TestTask testTask ; @Before public void setUp ( ) { testTask = TestUtil . createTask ( TestTask . class ) ; conventionAware = new ConventionAwareHelper ( testTask ) ; } @Test public void canMapPropertiesUsingClosure ( ) { conventionAware . map ( <str> , TestUtil . toClosure ( <str> ) ) ; assertThat ( conventionAware . getConventionValue ( null , <str> , false ) , equalTo ( ( Object ) toList ( <str> ) ) ) ; conventionAware . map ( <str> , TestUtil . toClosure ( <str> ) ) ; assertThat ( conventionAware . getConventionValue ( null , <str> , false ) , equalTo ( ( Object ) toList ( conventionAware . getConvention ( ) ) ) ) ; conventionAware . map ( <str> , TestUtil . toClosure ( <str> ) ) ; assertThat ( conventionAware . getConventionValue ( null , <str> , false ) , equalTo ( ( Object ) toList ( conventionAware . getConvention ( ) , testTask ) ) ) ; } @Test public void canMapPropertiesUsingCallable ( ) { Callable callable = new Callable ( ) { public Object call ( ) throws Exception { return toList ( <str> ) ; } } ; conventionAware . map ( <str> , callable ) ; assertThat ( conventionAware . getConventionValue ( null , <str> , false ) , equalTo ( ( Object ) toList ( <str> ) ) ) ; } @Test public void canSetMappingUsingDynamicProperty ( ) { TestUtil . call ( <str> , conventionAware ) ; assertThat ( conventionAware . getConventionValue ( null , <str> , false ) , equalTo ( ( Object ) toList ( <str> ) ) ) ; } @Test ( expected = InvalidUserDataException . class ) public void cannotMapUnknownProperty ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } } ) ; } @Test public void canOverwriteProperties ( ) { final List conventionList1 = toList ( <str> ) ; conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return conventionList1 ; } } ) ; assertSame ( conventionList1 , conventionAware . getConventionValue ( null , <str> , false ) ) ; List expectedList1 = toList ( <str> ) ; assertSame ( expectedList1 , conventionAware . getConventionValue ( expectedList1 , <str> , true ) ) ; } @Test public void canEnableCachingOfPropertyValue ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return toList ( <str> ) ; } } ) . cache ( ) ; assertSame ( conventionAware . getConventionValue ( null , <str> , false ) , conventionAware . getConventionValue ( null , <str> , false ) ) ; } @Test public void notCachesPropertyValuesByDefault ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return toList ( <str> ) ; } } ) ; Object value1 = conventionAware . getConventionValue ( null , <str> , false ) ; Object value2 = conventionAware . getConventionValue ( null , <str> , false ) ; assertEquals ( value1 , value2 ) ; assertNotSame ( value1 , value2 ) ; } @Test public void doesNotUseMappingWhenExplicitValueProvided ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { throw new UnsupportedOperationException ( ) ; } } ) ; List < Object > value = emptyList ( ) ; assertThat ( conventionAware . getConventionValue ( value , <str> , true ) , sameInstance ( value ) ) ; } @Test public void usesConventionValueForEmptyCollection ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return toList ( <str> ) ; } } ) ; assertThat ( conventionAware . getConventionValue ( emptyList ( ) , <str> , false ) , equalTo ( ( Object ) toList ( <str> ) ) ) ; } @Test public void usesConventionValueForEmptyMap ( ) { conventionAware . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return toMap ( <str> , <str> ) ; } } ) ; assertThat ( conventionAware . getConventionValue ( emptyMap ( ) , <str> , false ) , equalTo ( ( Object ) toMap ( <str> , <str> ) ) ) ; } } 
