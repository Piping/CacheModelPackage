package org . eclipse . debug . tests . viewer . model ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ICheckUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenCountUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementCompareRequest ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementLabelProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementMementoProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementMementoRequest ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IHasChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxyFactory2 ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicyFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . provisional . AbstractModelProxy ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . widgets . Display ; import org . junit . Assert ; public class TestModel implements IElementContentProvider , IElementLabelProvider , IModelProxyFactory2 , IElementMementoProvider , IModelSelectionPolicyFactory { public static class TestElement extends PlatformObject { private final TestModel fModel ; private final String fID ; TestElement [ ] fChildren ; String fLabelAppendix = <str> ; boolean fExpanded ; boolean fChecked ; boolean fGrayed ; public TestElement ( TestModel model , String text , TestElement [ ] children ) { this ( model , text , false , false , children ) ; } public TestElement ( TestModel model , String text , boolean checked , boolean grayed , TestElement [ ] children ) { fModel = model ; fID = text ; fChildren = children ; fChecked = checked ; fGrayed = grayed ; } public TestModel getModel ( ) { return fModel ; } @SuppressWarnings ( <str> ) @Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter . isInstance ( fModel ) ) { return ( T ) fModel ; } return null ; } public String getID ( ) { return fID ; } public void setLabelAppendix ( String appendix ) { fLabelAppendix = appendix ; } public String getLabel ( ) { return fID + fLabelAppendix ; } public TestElement [ ] getChildren ( ) { return fChildren ; } public boolean isExpanded ( ) { return fExpanded ; } public boolean getGrayed ( ) { return fGrayed ; } public boolean getChecked ( ) { return fChecked ; } public void setChecked ( boolean checked , boolean grayed ) { fChecked = checked ; fGrayed = grayed ; } @Override public boolean equals ( Object obj ) { return obj instanceof TestElement & & fID . equals ( ( ( TestElement ) obj ) . fID ) ; } @Override public int hashCode ( ) { return fID . hashCode ( ) ; } @Override public String toString ( ) { return getLabel ( ) ; } public int indexOf ( TestElement child ) { return Arrays . asList ( fChildren ) . indexOf ( child ) ; } } private class ModelProxy extends AbstractModelProxy { @Override public void installed ( Viewer viewer ) { super . installed ( viewer ) ; ModelDelta rootDelta = TestModel . this . getBaseDelta ( new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ) ; installSubModelProxies ( fRootPath , rootDelta ) ; fireModelChanged ( rootDelta ) ; } private void installSubModelProxies ( TreePath path , ModelDelta delta ) { TestElement element = getElement ( path ) ; if ( element . fModel ! = TestModel . this ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . INSTALL ) ; } else { TestElement [ ] children = element . getChildren ( ) ; for ( int i = <int> ; i < children . length ; i + + ) { installSubModelProxies ( path . createChildPath ( children [ i ] ) , delta . addNode ( children [ i ] , IModelDelta . NO_CHANGE ) ) ; } } } } private TestElement fRoot ; private Object fInput = null ; private TreePath fRootPath = TreePath . EMPTY ; private ModelProxy fModelProxy ; private IModelSelectionPolicy fModelSelectionPolicy ; private boolean fQueueingUpdates = false ; private boolean fDelayUpdates = false ; private List < IViewerUpdate > fQueuedUpdates = new LinkedList < IViewerUpdate > ( ) ; public TestModel ( ) { } public TestElement getRootElement ( ) { return fRoot ; } public void setSelectionPolicy ( IModelSelectionPolicy modelSelectionPolicy ) { fModelSelectionPolicy = modelSelectionPolicy ; } @Override public IModelSelectionPolicy createModelSelectionPolicyAdapter ( Object element , IPresentationContext context ) { return fModelSelectionPolicy ; } public ModelDelta getBaseDelta ( ModelDelta rootDelta ) { ModelDelta delta = rootDelta ; for ( int i = <int> ; i < fRootPath . getSegmentCount ( ) ; i + + ) { ModelDelta subDelta = delta . getChildDelta ( fRootPath . getSegment ( i ) ) ; if ( subDelta = = null ) { subDelta = delta . addNode ( fRootPath . getSegment ( i ) , IModelDelta . NO_CHANGE ) ; } delta = subDelta ; } delta . setChildCount ( getRootElement ( ) . getChildren ( ) . length ) ; return delta ; } public int getModelDepth ( ) { return getDepth ( getRootElement ( ) , <int> ) ; } private int getDepth ( TestElement element , int atDepth ) { TestElement [ ] children = element . getChildren ( ) ; if ( children . length = = <int> ) { return atDepth ; } int depth = atDepth + <int> ; for ( int i = <int> ; i < children . length ; i + + ) { depth = Math . max ( depth , getDepth ( children [ i ] , atDepth + <int> ) ) ; } return depth ; } public void setQeueueingUpdate ( boolean queueingUpdates ) { fQueueingUpdates = queueingUpdates ; if ( ! fQueueingUpdates ) { processQueuedUpdates ( ) ; } } public void setDelayUpdates ( boolean delayUpdates ) { fDelayUpdates = delayUpdates ; } public List < IViewerUpdate > getQueuedUpdates ( ) { return fQueuedUpdates ; } public void processQueuedUpdates ( ) { List < IViewerUpdate > updates = new ArrayList < IViewerUpdate > ( fQueuedUpdates ) ; fQueuedUpdates . clear ( ) ; for ( int i = <int> ; i < updates . size ( ) ; i + + ) { processUpdate ( updates . get ( i ) ) ; } } public void processUpdate ( IViewerUpdate update ) { if ( update instanceof IHasChildrenUpdate ) { doHasChildrenUpdate ( ( IHasChildrenUpdate ) update ) ; } else if ( update instanceof IChildrenCountUpdate ) { doChildrenCountUpdate ( ( IChildrenCountUpdate ) update ) ; } else if ( update instanceof IChildrenUpdate ) { doChildrenUpdate ( ( IChildrenUpdate ) update ) ; } else if ( update instanceof ILabelUpdate ) { doLabelUpdate ( ( ILabelUpdate ) update ) ; } else if ( update instanceof IElementCompareRequest ) { doCompareElements ( ( IElementCompareRequest ) update ) ; } else if ( update instanceof IElementMementoRequest ) { doEncodeElements ( ( IElementMementoRequest ) update ) ; } } private void processUpdates ( IViewerUpdate [ ] updates ) { for ( int i = <int> ; i < updates . length ; i + + ) { processUpdate ( updates [ i ] ) ; } } private void doUpdate ( final IViewerUpdate [ ] updates ) { if ( fQueueingUpdates ) { fQueuedUpdates . addAll ( Arrays . asList ( updates ) ) ; } else if ( fDelayUpdates ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { processUpdates ( updates ) ; } } ) ; } else { processUpdates ( updates ) ; } } @Override public void update ( IHasChildrenUpdate [ ] updates ) { doUpdate ( updates ) ; } private void doHasChildrenUpdate ( IHasChildrenUpdate update ) { TestElement element = ( TestElement ) update . getElement ( ) ; update . setHasChilren ( element . getChildren ( ) . length > <int> ) ; update . done ( ) ; } @Override public void update ( IChildrenCountUpdate [ ] updates ) { doUpdate ( updates ) ; } private void doChildrenCountUpdate ( IChildrenCountUpdate update ) { TestElement element = ( TestElement ) update . getElement ( ) ; update . setChildCount ( element . getChildren ( ) . length ) ; update . done ( ) ; } @Override public void update ( IChildrenUpdate [ ] updates ) { doUpdate ( updates ) ; } private void doChildrenUpdate ( IChildrenUpdate update ) { TestElement element = ( TestElement ) update . getElement ( ) ; int endOffset = update . getOffset ( ) + update . getLength ( ) ; for ( int j = update . getOffset ( ) ; j < endOffset ; j + + ) { if ( j < element . getChildren ( ) . length ) { update . setChild ( element . getChildren ( ) [ j ] , j ) ; } } update . done ( ) ; } @Override public void update ( ILabelUpdate [ ] updates ) { doUpdate ( updates ) ; } private void doLabelUpdate ( ILabelUpdate update ) { TestElement element = ( TestElement ) update . getElement ( ) ; update . setLabel ( element . getLabel ( ) , <int> ) ; if ( update instanceof ICheckUpdate & & Boolean . TRUE . equals ( update . getPresentationContext ( ) . getProperty ( ICheckUpdate . PROP_CHECK ) ) ) { ( ( ICheckUpdate ) update ) . setChecked ( element . getChecked ( ) , element . getGrayed ( ) ) ; } update . done ( ) ; } public final static String ELEMENT_MEMENTO_ID = <str> ; @Override public void compareElements ( final IElementCompareRequest [ ] updates ) { doUpdate ( updates ) ; } private void doCompareElements ( IElementCompareRequest update ) { String elementID = ( ( TestElement ) update . getElement ( ) ) . getID ( ) ; String mementoID = update . getMemento ( ) . getString ( ELEMENT_MEMENTO_ID ) ; update . setEqual ( elementID . equals ( mementoID ) ) ; update . done ( ) ; } @Override public void encodeElements ( IElementMementoRequest [ ] updates ) { doUpdate ( updates ) ; } private void doEncodeElements ( IElementMementoRequest update ) { String elementID = ( ( TestElement ) update . getElement ( ) ) . getID ( ) ; update . getMemento ( ) . putString ( ELEMENT_MEMENTO_ID , elementID ) ; update . done ( ) ; } public void elementChecked ( IPresentationContext context , Object viewerInput , TreePath path , boolean checked ) { TestElement element = getElement ( path ) ; Assert . assertFalse ( element . getGrayed ( ) ) ; element . setChecked ( checked , false ) ; } @Override public IModelProxy createTreeModelProxy ( Object input , TreePath path , IPresentationContext context ) { fModelProxy = new ModelProxy ( ) ; fInput = input ; fRootPath = path ; return fModelProxy ; } public IModelProxy getModelProxy ( ) { return fModelProxy ; } public TestElement getElement ( TreePath path ) { if ( path . getSegmentCount ( ) = = <int> ) { return getRootElement ( ) ; } else { return ( TestElement ) path . getLastSegment ( ) ; } } public void setAllExpanded ( ) { doSetExpanded ( fRoot ) ; } private void doSetExpanded ( TestElement element ) { element . fExpanded = true ; for ( int i = <int> ; i < element . fChildren . length ; i + + ) { doSetExpanded ( element . fChildren [ i ] ) ; } } public void setAllAppendix ( String appendix ) { doSetAllAppendix ( fRoot , appendix ) ; } private void doSetAllAppendix ( TestElement element , String appendix ) { element . setLabelAppendix ( appendix ) ; for ( int i = <int> ; i < element . fChildren . length ; i + + ) { doSetAllAppendix ( element . fChildren [ i ] , appendix ) ; } } public void validateData ( ITreeModelViewer viewer , TreePath path ) { validateData ( viewer , path , false ) ; } public void validateData ( ITreeModelViewer _viewer , TreePath path , boolean expandedElementsOnly ) { validateData ( _viewer , path , expandedElementsOnly , TestModelUpdatesListener . EMPTY_FILTER_ARRAY ) ; } public void validateData ( ITreeModelViewer _viewer , TreePath path , boolean expandedElementsOnly , ViewerFilter [ ] filters ) { IInternalTreeModelViewer viewer = ( IInternalTreeModelViewer ) _viewer ; TestElement element = getElement ( path ) ; if ( Boolean . TRUE . equals ( _viewer . getPresentationContext ( ) . getProperty ( ICheckUpdate . PROP_CHECK ) ) ) { Assert . assertTrue ( element . getChecked ( ) = = viewer . getElementChecked ( path ) ) ; Assert . assertTrue ( element . getGrayed ( ) = = viewer . getElementGrayed ( path ) ) ; } if ( ! expandedElementsOnly | | path . getSegmentCount ( ) = = <int> | | viewer . getExpandedState ( path ) ) { TestElement [ ] children = element . getChildren ( ) ; int viewerIndex = <int> ; for ( int i = <int> ; i < children . length ; i + + ) { if ( TestModelUpdatesListener . isFiltered ( children [ i ] , filters ) ) { continue ; } Assert . assertEquals ( children [ i ] , viewer . getChildElement ( path , viewerIndex ) ) ; validateData ( viewer , path . createChildPath ( children [ i ] ) , expandedElementsOnly , filters ) ; viewerIndex + + ; } Assert . assertEquals ( viewerIndex , viewer . getChildCount ( path ) ) ; } else if ( ! viewer . getExpandedState ( path ) ) { Assert . assertTrue ( viewer . getHasChildren ( path ) = = element . getChildren ( ) . length > <int> ) ; } } public void setRoot ( TestElement root ) { fRoot = root ; } public void postDelta ( IModelDelta delta ) { fModelProxy . fireModelChanged ( delta ) ; } public ModelDelta getElementDelta ( ModelDelta baseDelta , TreePath path , boolean combine ) { TestElement element = getRootElement ( ) ; ModelDelta delta = baseDelta ; for ( int i = <int> ; i < path . getSegmentCount ( ) ; i + + ) { TestElement [ ] children = element . getChildren ( ) ; delta . setChildCount ( children . length ) ; Object segment = path . getSegment ( i ) ; int j ; for ( j = <int> ; j < children . length ; j + + ) { if ( segment . equals ( children [ j ] ) ) { element = children [ j ] ; ModelDelta nextDelta = null ; if ( combine ) { nextDelta = delta . getChildDelta ( element ) ; } if ( nextDelta = = null ) { nextDelta = delta . addNode ( element , j , IModelDelta . NO_CHANGE , element . getChildren ( ) . length ) ; } delta = nextDelta ; break ; } } if ( j = = children . length ) { throw new IllegalArgumentException ( <str> ) ; } } return delta ; } private TreePath getRelativePath ( TreePath path ) { Object [ ] segments = new Object [ path . getSegmentCount ( ) - fRootPath . getSegmentCount ( ) ] ; for ( int i = fRootPath . getSegmentCount ( ) , _i = <int> ; i < path . getSegmentCount ( ) ; i + + , _i + + ) { segments [ _i ] = path . getSegment ( i ) ; } return new TreePath ( segments ) ; } public ModelDelta appendElementLabel ( TreePath path , String labelAppendix ) { org . junit . Assert . assertTrue ( path . startsWith ( fRootPath , null ) ) ; ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( path ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , false ) ; element . setLabelAppendix ( labelAppendix ) ; delta . setFlags ( delta . getFlags ( ) | IModelDelta . STATE ) ; return rootDelta ; } public ModelDelta setElementChecked ( TreePath path , boolean checked , boolean grayed ) { Assert . assertTrue ( path . startsWith ( fRootPath , null ) ) ; ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( path ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , false ) ; element . setChecked ( checked , grayed ) ; delta . setFlags ( delta . getFlags ( ) | IModelDelta . STATE ) ; return rootDelta ; } public ModelDelta setElementChildren ( TreePath path , TestElement [ ] children ) { Assert . assertTrue ( path . startsWith ( fRootPath , null ) ) ; ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( path ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , false ) ; element . fChildren = children ; delta . setFlags ( delta . getFlags ( ) | IModelDelta . CONTENT ) ; delta . setChildCount ( children . length ) ; return rootDelta ; } public ModelDelta replaceElementChild ( TreePath parentPath , int index , TestElement child ) { ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( parentPath ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , false ) ; TestElement oldChild = element . fChildren [ index ] ; element . fChildren [ index ] = child ; delta . addNode ( oldChild , child , IModelDelta . REPLACED ) ; return rootDelta ; } public ModelDelta addElementChild ( TreePath parentPath , ModelDelta rootDelta , int index , TestElement newChild ) { if ( rootDelta = = null ) { rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; } ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( parentPath ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , true ) ; element . fChildren = doInsertElementInArray ( element . fChildren , index , newChild ) ; delta . setChildCount ( element . getChildren ( ) . length ) ; delta . addNode ( newChild , index , IModelDelta . ADDED ) ; return rootDelta ; } public ModelDelta insertElementChild ( TreePath parentPath , int index , TestElement newChild ) { return insertElementChild ( null , parentPath , index , newChild ) ; } public ModelDelta insertElementChild ( ModelDelta rootDelta , TreePath parentPath , int index , TestElement newChild ) { if ( rootDelta = = null ) { rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; } ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TreePath relativePath = getRelativePath ( parentPath ) ; TestElement element = getElement ( relativePath ) ; ModelDelta delta = getElementDelta ( baseDelta , relativePath , false ) ; element . fChildren = doInsertElementInArray ( element . fChildren , index , newChild ) ; delta . setChildCount ( element . getChildren ( ) . length ) ; delta . addNode ( newChild , index , IModelDelta . INSERTED ) ; return rootDelta ; } private TestElement [ ] doInsertElementInArray ( TestElement [ ] children , int index , TestElement newChild ) { TestElement [ ] newChildren = new TestElement [ children . length + <int> ] ; System . arraycopy ( children , <int> , newChildren , <int> , index ) ; newChildren [ index ] = newChild ; System . arraycopy ( children , index , newChildren , index + <int> , children . length - index ) ; return newChildren ; } public ModelDelta removeElementChild ( TreePath parentPath , int index ) { ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; TestElement element = getElement ( parentPath ) ; ModelDelta delta = getElementDelta ( baseDelta , parentPath , false ) ; TestElement [ ] children = element . getChildren ( ) ; TestElement childToRemove = children [ index ] ; TestElement [ ] newChildren = new TestElement [ children . length - <int> ] ; System . arraycopy ( children , <int> , newChildren , <int> , index ) ; System . arraycopy ( children , index + <int> , newChildren , index , children . length - index - <int> ) ; element . fChildren = newChildren ; delta . setChildCount ( element . getChildren ( ) . length ) ; delta . addNode ( childToRemove , index , IModelDelta . REMOVED ) ; return rootDelta ; } public ModelDelta makeElementDelta ( TreePath path , int flags ) { ModelDelta rootDelta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = getBaseDelta ( rootDelta ) ; ModelDelta delta = getElementDelta ( baseDelta , path , false ) ; delta . setFlags ( flags ) ; return rootDelta ; } public TreePath findElement ( String label ) { return findElement ( TreePath . EMPTY , label ) ; } public TreePath findElement ( TreePath startPath , String label ) { TestElement element = getElement ( startPath ) ; for ( int i = <int> ; i < element . getChildren ( ) . length ; i + + ) { TestElement child = element . getChildren ( ) [ i ] ; TreePath path = startPath . createChildPath ( child ) ; if ( label . equals ( child . getLabel ( ) ) ) { return path ; } else { TreePath subPath = findElement ( path , label ) ; if ( subPath ! = null ) { return subPath ; } } } return null ; } @Override public String toString ( ) { return getElementString ( fRoot , <str> ) ; } public String getElementString ( TestElement element , String indent ) { StringBuffer builder = new StringBuffer ( ) ; builder . append ( indent ) ; builder . append ( element . toString ( ) ) ; builder . append ( <str> ) ; TestElement [ ] children = element . getChildren ( ) ; for ( int i = <int> ; i < children . length ; i + + ) { builder . append ( getElementString ( children [ i ] , indent + <str> ) ) ; } return builder . toString ( ) ; } public static TestModel simpleSingleLevel ( ) { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , makeSingleLevelModelElements ( model , <int> , <str> ) ) ) ; return model ; } public static TestElement [ ] makeSingleLevelModelElements ( TestModel model , int length , String prefix ) { TestElement [ ] elements = new TestElement [ length ] ; for ( int i = <int> ; i < = length ; i + + ) { String name = prefix + i ; elements [ i - <int> ] = new TestElement ( model , name , new TestElement [ <int> ] ) ; } return elements ; } public static TestElement [ ] makeMultiLevelElements ( TestModel model , int depth , String prefix ) { TestElement [ ] elements = new TestElement [ depth ] ; for ( int i = <int> ; i < depth ; i + + ) { String name = prefix + i ; elements [ i ] = new TestElement ( model , name , makeMultiLevelElements ( model , i , name + <str> ) ) ; } return elements ; } public static TestElement [ ] makeMultiLevelElements2 ( TestModel model , int [ ] levelCounts , String prefix ) { if ( levelCounts . length = = <int> ) { return new TestElement [ <int> ] ; } int count = levelCounts [ <int> ] ; int [ ] oldLevelCounts = levelCounts ; levelCounts = new int [ levelCounts . length - <int> ] ; System . arraycopy ( oldLevelCounts , <int> , levelCounts , <int> , levelCounts . length ) ; TestElement [ ] elements = new TestElement [ count ] ; for ( int i = <int> ; i < count ; i + + ) { String name = prefix + i ; elements [ i ] = new TestElement ( model , name , makeMultiLevelElements2 ( model , levelCounts , name + <str> ) ) ; } return elements ; } public static TestModel simpleMultiLevel ( ) { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , true , false , new TestElement [ ] { new TestElement ( model , <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( model , <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( model , <str> , true , false , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , } ) } ) ) ; return model ; } public static TestModel compositeMultiLevel ( ) { TestModel m2 = new TestModel ( ) ; m2 . setRoot ( new TestElement ( m2 , <str> , new TestElement [ ] { new TestElement ( m2 , <str> , new TestElement [ <int> ] ) , new TestElement ( m2 , <str> , true , false , new TestElement [ ] { new TestElement ( m2 , <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( m2 , <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( m2 , <str> , true , false , new TestElement [ <int> ] ) , } ) , } ) ) ; TestModel m3 = new TestModel ( ) ; m3 . setRoot ( new TestElement ( m3 , <str> , new TestElement [ ] { new TestElement ( m3 , <str> , new TestElement [ <int> ] ) , new TestElement ( m3 , <str> , true , false , new TestElement [ ] { new TestElement ( m3 , <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( m3 , <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( m3 , <str> , true , false , new TestElement [ <int> ] ) , } ) , } ) ) ; TestModel m4 = new TestModel ( ) ; m4 . setRoot ( new TestElement ( m4 , <str> , new TestElement [ ] { new TestElement ( m4 , <str> , new TestElement [ <int> ] ) , new TestElement ( m4 , <str> , true , false , new TestElement [ ] { new TestElement ( m4 , <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( m4 , <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( m4 , <str> , true , false , new TestElement [ <int> ] ) , } ) , } ) ) ; TestModel m1 = new TestModel ( ) ; m1 . setRoot ( new TestElement ( m1 , <str> , new TestElement [ ] { new TestElement ( m1 , <str> , new TestElement [ <int> ] ) , new TestElement ( m1 , <str> , true , false , new TestElement [ ] { m2 . fRoot , m3 . fRoot , m4 . fRoot , } ) , } ) ) ; return m1 ; } public static TestModel simpleDeepMultiLevel ( ) { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , true , false , new TestElement [ ] { new TestElement ( model , <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( model , <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( model , <str> , true , false , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) , } ) , } ) , } ) , } ) , } ) , } ) , } ) } ) ) ; return model ; } } 
