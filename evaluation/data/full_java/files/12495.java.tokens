package org . gradle . api . internal . artifacts . dsl ; import com . google . common . base . Joiner ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . artifacts . ComponentModuleMetadataDetails ; import org . gradle . api . artifacts . ModuleIdentifier ; import org . gradle . api . internal . notations . ModuleIdentifierNotationConverter ; import org . gradle . internal . typeconversion . NotationParser ; import org . gradle . internal . typeconversion . NotationParserBuilder ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import static com . google . common . collect . Maps . newHashMap ; import static java . lang . String . format ; public class ComponentModuleMetadataContainer implements ModuleReplacementsData { private final Map < ModuleIdentifier , ModuleIdentifier > replacements = newHashMap ( ) ; public ComponentModuleMetadataDetails module ( final Object sourceModule ) { final NotationParser < Object , ModuleIdentifier > parser = parser ( ) ; final ModuleIdentifier source = parser . parseNotation ( sourceModule ) ; return new ComponentModuleMetadataDetails ( ) { public void replacedBy ( final Object targetModule ) { ModuleIdentifier target = parser . parseNotation ( targetModule ) ; detectCycles ( replacements , source , target ) ; replacements . put ( source , target ) ; } public ModuleIdentifier getId ( ) { return source ; } public ModuleIdentifier getReplacedBy ( ) { return replacements . get ( source ) ; } } ; } public ModuleIdentifier getReplacementFor ( ModuleIdentifier sourceModule ) { return replacements . get ( sourceModule ) ; } private static void detectCycles ( Map < ModuleIdentifier , ModuleIdentifier > replacements , ModuleIdentifier source , ModuleIdentifier target ) { if ( source . equals ( target ) ) { throw new InvalidUserDataException ( String . format ( <str> , source , target ) ) ; } ModuleIdentifier m = replacements . get ( target ) ; if ( m = = null ) { return ; } Set < ModuleIdentifier > visited = new LinkedHashSet < ModuleIdentifier > ( ) ; visited . add ( source ) ; visited . add ( target ) ; while ( m ! = null ) { if ( ! visited . add ( m ) ) { throw new InvalidUserDataException ( format ( <str> , source , target , Joiner . on ( <str> ) . join ( visited ) + <str> + source ) ) ; } m = replacements . get ( m ) ; } } private static NotationParser < Object , ModuleIdentifier > parser ( ) { return NotationParserBuilder . toType ( ModuleIdentifier . class ) . converter ( new ModuleIdentifierNotationConverter ( ) ) . toComposite ( ) ; } } 
