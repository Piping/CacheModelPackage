package org . elasticsearch . search . suggest . completion . context ; import org . apache . lucene . document . StringField ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . ParseContext . Document ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapper ; import java . io . IOException ; import java . util . * ; public class GeoContextMapping extends ContextMapping { public static final String FIELD_PRECISION = <str> ; public static final String FIELD_FIELDNAME = <str> ; public static final int DEFAULT_PRECISION = <int> ; static final String CONTEXT_VALUE = <str> ; static final String CONTEXT_BOOST = <str> ; static final String CONTEXT_PRECISION = <str> ; static final String CONTEXT_NEIGHBOURS = <str> ; private final int precision ; private final String fieldName ; private GeoContextMapping ( String name , String fieldName , int precision ) { super ( Type . GEO , name ) ; this . precision = precision ; this . fieldName = fieldName ; } public String getFieldName ( ) { return fieldName ; } public int getPrecision ( ) { return precision ; } protected static GeoContextMapping load ( String name , Map < String , Object > config ) { final GeoContextMapping . Builder builder = new GeoContextMapping . Builder ( name ) ; if ( config ! = null ) { final Object configPrecision = config . get ( FIELD_PRECISION ) ; if ( configPrecision ! = null ) { if ( configPrecision instanceof Integer ) { builder . precision ( ( Integer ) configPrecision ) ; } else if ( configPrecision instanceof Long ) { builder . precision ( ( Long ) configPrecision ) ; } else if ( configPrecision instanceof Double ) { builder . precision ( ( Double ) configPrecision ) ; } else if ( configPrecision instanceof Float ) { builder . precision ( ( Float ) configPrecision ) ; } else { builder . precision ( configPrecision . toString ( ) ) ; } config . remove ( FIELD_PRECISION ) ; } final Object fieldName = config . get ( FIELD_FIELDNAME ) ; if ( fieldName ! = null ) { builder . field ( fieldName . toString ( ) ) ; config . remove ( FIELD_FIELDNAME ) ; } } return builder . build ( ) ; } @Override protected XContentBuilder toInnerXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( FIELD_PRECISION , precision ) ; if ( fieldName ! = null ) { builder . field ( FIELD_FIELDNAME , fieldName ) ; } return builder ; } @Override public Set < CharSequence > parseContext ( ParseContext parseContext , XContentParser parser ) throws IOException , ElasticsearchParseException { if ( fieldName ! = null ) { FieldMapper mapper = parseContext . docMapper ( ) . mappers ( ) . getMapper ( fieldName ) ; if ( ! ( mapper instanceof GeoPointFieldMapper ) ) { throw new ElasticsearchParseException ( <str> ) ; } } final Set < CharSequence > contexts = new HashSet < > ( ) ; Token token = parser . currentToken ( ) ; if ( token = = Token . START_ARRAY ) { token = parser . nextToken ( ) ; if ( token = = Token . VALUE_NUMBER ) { double lon = parser . doubleValue ( ) ; if ( parser . nextToken ( ) = = Token . VALUE_NUMBER ) { double lat = parser . doubleValue ( ) ; if ( parser . nextToken ( ) = = Token . END_ARRAY ) { contexts . add ( GeoHashUtils . stringEncode ( lon , lat , precision ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } else { throw new ElasticsearchParseException ( <str> ) ; } } else { while ( token ! = Token . END_ARRAY ) { GeoPoint point = GeoUtils . parseGeoPoint ( parser ) ; contexts . add ( GeoHashUtils . stringEncode ( point . getLon ( ) , point . getLat ( ) , precision ) ) ; token = parser . nextToken ( ) ; } } } else if ( token = = Token . VALUE_STRING ) { final String geoHash = parser . text ( ) ; final CharSequence truncatedGeoHash = geoHash . subSequence ( <int> , Math . min ( geoHash . length ( ) , precision ) ) ; contexts . add ( truncatedGeoHash ) ; } else { GeoPoint point = GeoUtils . parseGeoPoint ( parser ) ; contexts . add ( GeoHashUtils . stringEncode ( point . getLon ( ) , point . getLat ( ) , precision ) ) ; } return contexts ; } @Override public Set < CharSequence > parseContext ( Document document ) { final Set < CharSequence > geohashes = new HashSet < > ( ) ; if ( fieldName ! = null ) { IndexableField [ ] fields = document . getFields ( fieldName ) ; GeoPoint spare = new GeoPoint ( ) ; if ( fields . length = = <int> ) { IndexableField [ ] lonFields = document . getFields ( fieldName + <str> ) ; IndexableField [ ] latFields = document . getFields ( fieldName + <str> ) ; if ( lonFields . length > <int> & & latFields . length > <int> ) { for ( int i = <int> ; i < lonFields . length ; i + + ) { IndexableField lonField = lonFields [ i ] ; IndexableField latField = latFields [ i ] ; assert lonField . fieldType ( ) . docValuesType ( ) = = latField . fieldType ( ) . docValuesType ( ) ; if ( lonField . fieldType ( ) . docValuesType ( ) = = DocValuesType . NONE ) { spare . reset ( latField . numericValue ( ) . doubleValue ( ) , lonField . numericValue ( ) . doubleValue ( ) ) ; geohashes . add ( GeoHashUtils . stringEncode ( spare . getLon ( ) , spare . getLat ( ) , precision ) ) ; } } } } else { for ( IndexableField field : fields ) { if ( field instanceof StringField ) { spare . resetFromString ( field . stringValue ( ) ) ; } else { spare . resetFromIndexHash ( Long . parseLong ( field . stringValue ( ) ) ) ; } geohashes . add ( spare . geohash ( ) ) ; } } } Set < CharSequence > locations = new HashSet < > ( ) ; for ( CharSequence geohash : geohashes ) { int precision = Math . min ( this . precision , geohash . length ( ) ) ; CharSequence truncatedGeohash = geohash . subSequence ( <int> , precision ) ; locations . add ( truncatedGeohash ) ; } return locations ; } @Override public List < QueryContext > parseQueryContext ( XContentParser parser ) throws IOException , ElasticsearchParseException { List < GeoQueryContext > queryContexts = new ArrayList < > ( ) ; Token token = parser . nextToken ( ) ; if ( token = = Token . START_OBJECT | | token = = Token . VALUE_STRING ) { queryContexts . add ( GeoQueryContext . parse ( parser ) ) ; } else if ( token = = Token . START_ARRAY ) { while ( parser . nextToken ( ) ! = Token . END_ARRAY ) { queryContexts . add ( GeoQueryContext . parse ( parser ) ) ; } } List < QueryContext > queryContextList = new ArrayList < > ( ) ; for ( GeoQueryContext queryContext : queryContexts ) { int minPrecision = this . precision ; if ( queryContext . getPrecision ( ) ! = - <int> ) { minPrecision = Math . min ( minPrecision , queryContext . getPrecision ( ) ) ; } GeoPoint point = queryContext . getGeoPoint ( ) ; final Collection < String > locations = new HashSet < > ( ) ; String geoHash = GeoHashUtils . stringEncode ( point . getLon ( ) , point . getLat ( ) , minPrecision ) ; locations . add ( geoHash ) ; if ( queryContext . getNeighbours ( ) . isEmpty ( ) & & geoHash . length ( ) = = this . precision ) { GeoHashUtils . addNeighbors ( geoHash , locations ) ; } else if ( queryContext . getNeighbours ( ) . isEmpty ( ) = = false ) { for ( Integer neighbourPrecision : queryContext . getNeighbours ( ) ) { if ( neighbourPrecision < geoHash . length ( ) ) { String truncatedGeoHash = geoHash . substring ( <int> , neighbourPrecision ) ; locations . add ( truncatedGeoHash ) ; GeoHashUtils . addNeighbors ( truncatedGeoHash , locations ) ; } } } for ( String location : locations ) { queryContextList . add ( new QueryContext ( location , queryContext . getBoost ( ) , location . length ( ) < this . precision ) ) ; } } return queryContextList ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; GeoContextMapping that = ( GeoContextMapping ) o ; if ( precision ! = that . precision ) return false ; return ! ( fieldName ! = null ? ! fieldName . equals ( that . fieldName ) : that . fieldName ! = null ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , precision , fieldName ) ; } public static class Builder extends ContextBuilder < GeoContextMapping > { private int precision = DEFAULT_PRECISION ; private String fieldName = null ; protected Builder ( String name ) { super ( name ) ; } public Builder precision ( String precision ) { return precision ( DistanceUnit . parse ( precision , DistanceUnit . METERS , DistanceUnit . METERS ) ) ; } public Builder precision ( double precision , DistanceUnit unit ) { return precision ( unit . toMeters ( precision ) ) ; } public Builder precision ( double meters ) { int level = GeoUtils . geoHashLevelsForPrecision ( meters ) ; if ( GeoUtils . geoHashCellSize ( level ) < meters ) { level = Math . max ( <int> , level - <int> ) ; } return precision ( level ) ; } public Builder precision ( int level ) { this . precision = level ; return this ; } public Builder field ( String fieldName ) { this . fieldName = fieldName ; return this ; } @Override public GeoContextMapping build ( ) { return new GeoContextMapping ( name , fieldName , precision ) ; } } } 
