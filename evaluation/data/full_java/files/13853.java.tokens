package org . gradle . launcher . daemon . server ; import org . gradle . api . logging . Logging ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . initialization . DefaultBuildCancellationToken ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . server . api . DaemonStateControl ; import org . gradle . launcher . daemon . server . api . DaemonStoppedException ; import org . gradle . launcher . daemon . server . api . DaemonUnavailableException ; import org . slf4j . Logger ; import java . util . Date ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DaemonStateCoordinator implements Stoppable , DaemonStateControl { private static final Logger LOGGER = Logging . getLogger ( DaemonStateCoordinator . class ) ; private enum State { Running , StopRequested , Stopped , Broken } private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final long cancelTimeoutMs ; private State state = State . Running ; private long lastActivityAt = - <int> ; private String currentCommandExecution ; private Object result ; private volatile DefaultBuildCancellationToken cancellationToken ; private final StoppableExecutor executor ; private final Runnable onStartCommand ; private final Runnable onFinishCommand ; public DaemonStateCoordinator ( ExecutorFactory executorFactory , Runnable onStartCommand , Runnable onFinishCommand ) { this ( executorFactory , onStartCommand , onFinishCommand , <int> * <int> ) ; } DaemonStateCoordinator ( ExecutorFactory executorFactory , Runnable onStartCommand , Runnable onFinishCommand , long cancelTimeoutMs ) { executor = executorFactory . create ( <str> ) ; this . onStartCommand = onStartCommand ; this . onFinishCommand = onFinishCommand ; this . cancelTimeoutMs = cancelTimeoutMs ; updateActivityTimestamp ( ) ; cancellationToken = new DefaultBuildCancellationToken ( ) ; } private void setState ( State state ) { this . state = state ; condition . signalAll ( ) ; } private boolean awaitStop ( long timeoutMs ) { lock . lock ( ) ; try { LOGGER . debug ( <str> , timeoutMs ) ; while ( true ) { try { switch ( state ) { case Running : if ( isBusy ( ) ) { LOGGER . debug ( DaemonMessages . DAEMON_BUSY ) ; condition . await ( ) ; } else if ( hasBeenIdleFor ( timeoutMs ) ) { LOGGER . debug ( <str> ) ; stopNow ( <str> ) ; return false ; } else { Date waitUntil = new Date ( lastActivityAt + timeoutMs ) ; LOGGER . debug ( <str> , DaemonMessages . DAEMON_IDLE , waitUntil ) ; condition . awaitUntil ( waitUntil ) ; } break ; case Broken : throw new IllegalStateException ( <str> ) ; case StopRequested : LOGGER . debug ( <str> ) ; condition . await ( ) ; break ; case Stopped : LOGGER . debug ( <str> ) ; return true ; } } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } finally { lock . unlock ( ) ; } } public void stopOnIdleTimeout ( int timeout , TimeUnit timeoutUnits ) { awaitStop ( timeoutUnits . toMillis ( timeout ) ) ; } public void requestStop ( ) { lock . lock ( ) ; try { LOGGER . debug ( <str> , isBusy ( ) ) ; if ( isBusy ( ) ) { beginStopping ( ) ; } else { stopNow ( <str> ) ; } } finally { lock . unlock ( ) ; } } public void stop ( ) { stopNow ( <str> ) ; } private void stopNow ( String reason ) { lock . lock ( ) ; try { switch ( state ) { case Running : case Broken : case StopRequested : LOGGER . debug ( <str> , reason , isBusy ( ) ) ; setState ( State . Stopped ) ; break ; case Stopped : break ; default : throw new IllegalStateException ( <str> + state ) ; } } finally { lock . unlock ( ) ; } } private void beginStopping ( ) { switch ( state ) { case Running : case Broken : setState ( State . StopRequested ) ; break ; case StopRequested : case Stopped : break ; default : throw new IllegalStateException ( <str> + state ) ; } } public void requestForcefulStop ( ) { LOGGER . debug ( <str> ) ; stopNow ( <str> ) ; } public BuildCancellationToken getCancellationToken ( ) { return cancellationToken ; } private void updateCancellationToken ( ) { cancellationToken = new DefaultBuildCancellationToken ( ) ; } public void cancelBuild ( ) { long waitUntil = System . currentTimeMillis ( ) + cancelTimeoutMs ; Date expiry = new Date ( waitUntil ) ; LOGGER . debug ( <str> ) ; try { cancellationToken . cancel ( ) ; } catch ( Exception ex ) { LOGGER . error ( <str> , ex ) ; } lock . lock ( ) ; try { while ( System . currentTimeMillis ( ) < waitUntil ) { try { switch ( state ) { case Running : if ( isIdle ( ) ) { LOGGER . debug ( <str> ) ; return ; } case StopRequested : LOGGER . debug ( <str> ) ; condition . awaitUntil ( expiry ) ; break ; case Broken : throw new IllegalStateException ( <str> ) ; case Stopped : LOGGER . debug ( <str> ) ; return ; } } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } LOGGER . debug ( <str> ) ; stopNow ( <str> ) ; } finally { lock . unlock ( ) ; } } public void runCommand ( final Runnable command , String commandDisplayName ) throws DaemonUnavailableException { onStartCommand ( commandDisplayName ) ; try { executor . execute ( new Runnable ( ) { public void run ( ) { try { command . run ( ) ; onCommandSuccessful ( ) ; } catch ( Throwable t ) { onCommandFailed ( t ) ; } } } ) ; waitForCommandCompletion ( ) ; } finally { onFinishCommand ( ) ; } } private void waitForCommandCompletion ( ) { lock . lock ( ) ; try { while ( ( state = = State . Running | | state = = State . StopRequested ) & & result = = null ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } LOGGER . debug ( <str> , currentCommandExecution , result , state ) ; if ( result instanceof Throwable ) { throw UncheckedException . throwAsUncheckedException ( ( Throwable ) result ) ; } if ( result ! = null ) { return ; } switch ( state ) { case Stopped : throw new DaemonStoppedException ( ) ; case Broken : throw new DaemonUnavailableException ( <str> ) ; default : throw new IllegalStateException ( <str> + state ) ; } } finally { lock . unlock ( ) ; } } private void onCommandFailed ( Throwable failure ) { lock . lock ( ) ; try { result = failure ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private void onCommandSuccessful ( ) { lock . lock ( ) ; try { result = this ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private void onStartCommand ( String commandDisplayName ) { lock . lock ( ) ; try { switch ( state ) { case Broken : throw new DaemonUnavailableException ( <str> ) ; case StopRequested : throw new DaemonUnavailableException ( <str> ) ; case Stopped : throw new DaemonUnavailableException ( <str> ) ; } if ( currentCommandExecution ! = null ) { throw new DaemonUnavailableException ( String . format ( <str> , currentCommandExecution ) ) ; } LOGGER . debug ( <str> , commandDisplayName , getIdleMinutes ( ) ) ; try { onStartCommand . run ( ) ; currentCommandExecution = commandDisplayName ; result = null ; updateActivityTimestamp ( ) ; updateCancellationToken ( ) ; condition . signalAll ( ) ; } catch ( Throwable throwable ) { setState ( State . Broken ) ; throw UncheckedException . throwAsUncheckedException ( throwable ) ; } } finally { lock . unlock ( ) ; } } private void onFinishCommand ( ) { lock . lock ( ) ; try { LOGGER . debug ( <str> , currentCommandExecution ) ; currentCommandExecution = null ; result = null ; updateActivityTimestamp ( ) ; switch ( state ) { case Running : try { onFinishCommand . run ( ) ; condition . signalAll ( ) ; } catch ( Throwable throwable ) { setState ( State . Broken ) ; throw UncheckedException . throwAsUncheckedException ( throwable ) ; } break ; case StopRequested : stopNow ( <str> ) ; break ; case Stopped : break ; default : throw new IllegalStateException ( <str> + state ) ; } } finally { lock . unlock ( ) ; } } private void updateActivityTimestamp ( ) { long now = System . currentTimeMillis ( ) ; LOGGER . debug ( <str> , now ) ; lastActivityAt = now ; } private double getIdleMinutes ( ) { lock . lock ( ) ; try { return ( System . currentTimeMillis ( ) - lastActivityAt ) / <int> / <int> ; } finally { lock . unlock ( ) ; } } private boolean hasBeenIdleFor ( long milliseconds ) { return lastActivityAt < ( System . currentTimeMillis ( ) - milliseconds ) ; } boolean isStopped ( ) { return state = = State . Stopped ; } boolean isWillRefuseNewCommands ( ) { return state ! = State . Running ; } boolean isIdle ( ) { return state = = State . Running & & currentCommandExecution = = null ; } boolean isBusy ( ) { return state = = State . Running & & currentCommandExecution ! = null ; } } 
