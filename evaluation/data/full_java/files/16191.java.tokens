package org . gradle . foundation . ipc . basic ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . foundation . common . ObserverLord ; import java . io . IOException ; import java . io . Serializable ; import java . net . ServerSocket ; import java . net . Socket ; public class Server < P extends Server . Protocol , O extends Server . ServerObserver > { private final Logger logger = Logging . getLogger ( Server . class ) ; private ServerSocket serverSocket ; private boolean isServerRunning ; private boolean hasRequestedShutdown ; private ObjectSocketWrapper clientSocket ; protected P protocol ; private Thread communicationThread ; private int port ; protected ObserverLord < O > observerLord = new ObserverLord < O > ( ) ; public interface Protocol < S extends Server > { public void initialize ( S server ) ; public void connectionAccepted ( ) ; public boolean continueConnection ( ) ; public void messageReceived ( MessageObject message ) ; public void clientCommunicationStopped ( ) ; void readFailureOccurred ( ) ; } public interface ServerObserver { public void serverExited ( ) ; } public Server ( P protocol ) { this . protocol = protocol ; protocol . initialize ( this ) ; } public int getPort ( ) { return port ; } public boolean start ( ) { port = connect ( ) ; if ( port = = - <int> ) { return false ; } communicationThread = new Thread ( new Runnable ( ) { public void run ( ) { listenForConnections ( ) ; } } ) ; communicationThread . start ( ) ; communicationsStarted ( ) ; return true ; } protected void communicationsStarted ( ) { } private int connect ( ) { try { serverSocket = new ServerSocket ( <int> ) ; return serverSocket . getLocalPort ( ) ; } catch ( IOException e ) { logger . error ( <str> + port , e ) ; return - <int> ; } } private void listenForConnections ( ) { int consecutiveFailures = <int> ; while ( ! hasRequestedShutdown ) { Socket socket = null ; try { serverSocket . setSoTimeout ( <int> ) ; socket = serverSocket . accept ( ) ; clientSocket = new ObjectSocketWrapper ( socket ) ; protocol . connectionAccepted ( ) ; consecutiveFailures = <int> ; serverSocket . setSoTimeout ( <int> ) ; processCommunications ( ) ; clientSocket . close ( ) ; } catch ( IOException e ) { consecutiveFailures + + ; if ( consecutiveFailures > = <int> ) { requestShutdown ( ) ; } if ( consecutiveFailures > <int> ) { logger . error ( <str> + consecutiveFailures + <str> ) ; } } catch ( Throwable t ) { logger . error ( <str> , t ) ; requestShutdown ( ) ; } } isServerRunning = false ; stop ( ) ; notifyServerExited ( ) ; } private void processCommunications ( ) { boolean hasClientStopped = false ; int failureCount = <int> ; while ( ! hasClientStopped & & protocol . continueConnection ( ) & & ! hasRequestedShutdown ) { Object object = clientSocket . readObject ( ) ; if ( object = = null ) { if ( ! hasRequestedShutdown ) { failureCount + + ; protocol . readFailureOccurred ( ) ; if ( failureCount = = <int> ) { hasClientStopped = true ; protocol . clientCommunicationStopped ( ) ; } } } else { failureCount = <int> ; if ( object instanceof String ) { protocol . messageReceived ( new MessageObject ( <str> , object . toString ( ) , null ) ) ; } else if ( object instanceof MessageObject ) { protocol . messageReceived ( ( MessageObject ) object ) ; } } } } public void requestShutdown ( ) { hasRequestedShutdown = true ; } public boolean isServerRunning ( ) { return isServerRunning ; } public void sendMessage ( String messageType , String message ) { clientSocket . sendObject ( new MessageObject ( messageType , message , null ) ) ; } public void sendMessage ( String messageType , String message , Serializable data ) { clientSocket . sendObject ( new MessageObject ( messageType , message , data ) ) ; } public void stop ( ) { try { serverSocket . close ( ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; } } private void notifyServerExited ( ) { observerLord . notifyObservers ( new ObserverLord . ObserverNotification < O > ( ) { public void notify ( ServerObserver observer ) { observer . serverExited ( ) ; } } ) ; } public void addServerObserver ( O observer , boolean inEventQueue ) { observerLord . addObserver ( observer , inEventQueue ) ; } public void removeServerObserver ( O observer ) { observerLord . removeObserver ( observer ) ; } } 
