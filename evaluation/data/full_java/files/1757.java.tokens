package org . apache . cassandra . stress . settings ; import java . io . Serializable ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import com . google . common . util . concurrent . Uninterruptibles ; import org . apache . cassandra . stress . operations . OpDistributionFactory ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . thrift . ConsistencyLevel ; public abstract class SettingsCommand implements Serializable { public static enum TruncateWhen { NEVER , ONCE , ALWAYS } public final Command type ; public final long count ; public final long duration ; public final TimeUnit durationUnits ; public final boolean noWarmup ; public final TruncateWhen truncate ; public final ConsistencyLevel consistencyLevel ; public final double targetUncertainty ; public final int minimumUncertaintyMeasurements ; public final int maximumUncertaintyMeasurements ; public abstract OpDistributionFactory getFactory ( StressSettings settings ) ; public SettingsCommand ( Command type , GroupedOptions options ) { this ( type , ( Options ) options , options instanceof Count ? ( Count ) options : null , options instanceof Duration ? ( Duration ) options : null , options instanceof Uncertainty ? ( Uncertainty ) options : null ) ; } public SettingsCommand ( Command type , Options options , Count count , Duration duration , Uncertainty uncertainty ) { this . type = type ; this . consistencyLevel = ConsistencyLevel . valueOf ( options . consistencyLevel . value ( ) . toUpperCase ( ) ) ; this . noWarmup = options . noWarmup . setByUser ( ) ; this . truncate = TruncateWhen . valueOf ( options . truncate . value ( ) . toUpperCase ( ) ) ; if ( count ! = null ) { this . count = OptionDistribution . parseLong ( count . count . value ( ) ) ; this . duration = <int> ; this . durationUnits = null ; this . targetUncertainty = - <int> ; this . minimumUncertaintyMeasurements = - <int> ; this . maximumUncertaintyMeasurements = - <int> ; } else if ( duration ! = null ) { this . count = - <int> ; this . duration = Long . parseLong ( duration . duration . value ( ) . substring ( <int> , duration . duration . value ( ) . length ( ) - <int> ) ) ; switch ( duration . duration . value ( ) . toLowerCase ( ) . charAt ( duration . duration . value ( ) . length ( ) - <int> ) ) { case <str> : this . durationUnits = TimeUnit . SECONDS ; break ; case <str> : this . durationUnits = TimeUnit . MINUTES ; break ; case <str> : this . durationUnits = TimeUnit . HOURS ; break ; default : throw new IllegalStateException ( ) ; } this . targetUncertainty = - <int> ; this . minimumUncertaintyMeasurements = - <int> ; this . maximumUncertaintyMeasurements = - <int> ; } else { this . count = - <int> ; this . duration = <int> ; this . durationUnits = null ; this . targetUncertainty = Double . parseDouble ( uncertainty . uncertainty . value ( ) ) ; this . minimumUncertaintyMeasurements = Integer . parseInt ( uncertainty . minMeasurements . value ( ) ) ; this . maximumUncertaintyMeasurements = Integer . parseInt ( uncertainty . maxMeasurements . value ( ) ) ; } } static abstract class Options extends GroupedOptions { final OptionSimple noWarmup = new OptionSimple ( <str> , <str> , null , <str> , false ) ; final OptionSimple truncate = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple consistencyLevel = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; } static class Count extends Options { final OptionSimple count = new OptionSimple ( <str> , <str> , null , <str> , true ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( count , noWarmup , truncate , consistencyLevel ) ; } } static class Duration extends Options { final OptionSimple duration = new OptionSimple ( <str> , <str> , null , <str> , true ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( duration , noWarmup , truncate , consistencyLevel ) ; } } static class Uncertainty extends Options { final OptionSimple uncertainty = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple minMeasurements = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple maxMeasurements = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( uncertainty , minMeasurements , maxMeasurements , noWarmup , truncate , consistencyLevel ) ; } } public abstract void truncateTables ( StressSettings settings ) ; protected void truncateTables ( StressSettings settings , String ks , String . . . tables ) { JavaDriverClient client = settings . getJavaDriverClient ( false ) ; assert settings . command . truncate ! = SettingsCommand . TruncateWhen . NEVER ; for ( String table : tables ) { String cql = String . format ( <str> , ks , table ) ; client . execute ( cql , org . apache . cassandra . db . ConsistencyLevel . ONE ) ; } System . out . println ( String . format ( <str> , ks , Arrays . toString ( tables ) , settings . node . nodes . size ( ) ) ) ; Uninterruptibles . sleepUninterruptibly ( settings . node . nodes . size ( ) , TimeUnit . SECONDS ) ; } static SettingsCommand get ( Map < String , String [ ] > clArgs ) { for ( Command cmd : Command . values ( ) ) { if ( cmd . category = = null ) continue ; for ( String name : cmd . names ) { final String [ ] params = clArgs . remove ( name ) ; if ( params = = null ) continue ; switch ( cmd . category ) { case BASIC : return SettingsCommandPreDefined . build ( cmd , params ) ; case MIXED : return SettingsCommandPreDefinedMixed . build ( params ) ; case USER : return SettingsCommandUser . build ( params ) ; } } } return null ; } static void printHelp ( Command type ) { printHelp ( type . toString ( ) . toLowerCase ( ) ) ; } static void printHelp ( String type ) { GroupedOptions . printOptions ( System . out , type . toLowerCase ( ) , new Uncertainty ( ) , new Count ( ) , new Duration ( ) ) ; } static Runnable helpPrinter ( final Command type ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( type ) ; } } ; } } 
