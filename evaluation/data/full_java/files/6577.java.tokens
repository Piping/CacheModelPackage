package org . elasticsearch . index . mapper . internal ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . NumericDocValuesField ; import org . apache . lucene . index . DocValuesType ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . MetadataFieldMapper ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . ParseContext . Document ; import java . io . IOException ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class VersionFieldMapper extends MetadataFieldMapper { public static final String NAME = <str> ; public static final String CONTENT_TYPE = <str> ; public static class Defaults { public static final String NAME = VersionFieldMapper . NAME ; public static final MappedFieldType FIELD_TYPE = new VersionFieldType ( ) ; static { FIELD_TYPE . setNames ( new MappedFieldType . Names ( NAME ) ) ; FIELD_TYPE . setDocValuesType ( DocValuesType . NUMERIC ) ; FIELD_TYPE . setHasDocValues ( true ) ; FIELD_TYPE . freeze ( ) ; } } public static class Builder extends MetadataFieldMapper . Builder < Builder , VersionFieldMapper > { public Builder ( ) { super ( Defaults . NAME , Defaults . FIELD_TYPE ) ; } @Override public VersionFieldMapper build ( BuilderContext context ) { return new VersionFieldMapper ( context . indexSettings ( ) ) ; } } public static class TypeParser implements MetadataFieldMapper . TypeParser { @Override public MetadataFieldMapper . Builder < ? , ? > parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { Builder builder = new Builder ( ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; if ( fieldName . equals ( <str> ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { iterator . remove ( ) ; } } return builder ; } @Override public MetadataFieldMapper getDefault ( Settings indexSettings , MappedFieldType fieldType , String typeName ) { return new VersionFieldMapper ( indexSettings ) ; } } static final class VersionFieldType extends MappedFieldType { public VersionFieldType ( ) { setFieldDataType ( new FieldDataType ( <str> ) ) ; } protected VersionFieldType ( VersionFieldType ref ) { super ( ref ) ; } @Override public MappedFieldType clone ( ) { return new VersionFieldType ( this ) ; } @Override public String typeName ( ) { return CONTENT_TYPE ; } @Override public Long value ( Object value ) { if ( value = = null | | ( value instanceof Long ) ) { return ( Long ) value ; } else { return Long . parseLong ( value . toString ( ) ) ; } } } private VersionFieldMapper ( Settings indexSettings ) { super ( NAME , Defaults . FIELD_TYPE , Defaults . FIELD_TYPE , indexSettings ) ; } @Override public void preParse ( ParseContext context ) throws IOException { super . parse ( context ) ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { final Field version = new NumericDocValuesField ( NAME , - <int> ) ; context . version ( version ) ; fields . add ( version ) ; } @Override public Mapper parse ( ParseContext context ) throws IOException { return null ; } @Override public void postParse ( ParseContext context ) throws IOException { for ( int i = <int> ; i < context . docs ( ) . size ( ) ; i + + ) { final Document doc = context . docs ( ) . get ( i ) ; doc . add ( new NumericDocValuesField ( NAME , <int> ) ) ; } } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { return builder ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { } } 
