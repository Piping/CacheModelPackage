package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . SnapshotsInProgress ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; public class SnapshotInProgressAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED = <str> ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { boolean newEnableRelocation = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED , enableRelocation ) ; if ( newEnableRelocation ! = enableRelocation ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED , enableRelocation , newEnableRelocation ) ; enableRelocation = newEnableRelocation ; } } } private volatile boolean enableRelocation = false ; public SnapshotInProgressAllocationDecider ( ) { this ( Settings . Builder . EMPTY_SETTINGS ) ; } public SnapshotInProgressAllocationDecider ( Settings settings ) { this ( settings , new NodeSettingsService ( settings ) ) ; } @Inject public SnapshotInProgressAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; enableRelocation = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED , enableRelocation ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } @Override public Decision canRebalance ( ShardRouting shardRouting , RoutingAllocation allocation ) { return canMove ( shardRouting , allocation ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return canMove ( shardRouting , allocation ) ; } private Decision canMove ( ShardRouting shardRouting , RoutingAllocation allocation ) { if ( ! enableRelocation & & shardRouting . primary ( ) ) { SnapshotsInProgress snapshotsInProgress = allocation . routingNodes ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshotsInProgress = = null ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } for ( SnapshotsInProgress . Entry snapshot : snapshotsInProgress . entries ( ) ) { SnapshotsInProgress . ShardSnapshotStatus shardSnapshotStatus = snapshot . shards ( ) . get ( shardRouting . shardId ( ) ) ; if ( shardSnapshotStatus ! = null & & ! shardSnapshotStatus . state ( ) . completed ( ) & & shardSnapshotStatus . nodeId ( ) ! = null & & shardSnapshotStatus . nodeId ( ) . equals ( shardRouting . currentNodeId ( ) ) ) { logger . trace ( <str> , shardRouting . shardId ( ) , shardSnapshotStatus . nodeId ( ) ) ; return allocation . decision ( Decision . NO , NAME , <str> , shardRouting . shardId ( ) , shardSnapshotStatus . nodeId ( ) ) ; } } } return allocation . decision ( Decision . YES , NAME , <str> ) ; } } 
