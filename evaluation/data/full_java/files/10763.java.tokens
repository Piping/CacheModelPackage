package org . gradle . api . plugins . antlr ; import org . gradle . api . Action ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . file . SourceDirectorySet ; import org . gradle . api . plugins . antlr . internal . * ; import org . gradle . api . tasks . * ; import org . gradle . api . tasks . incremental . IncrementalTaskInputs ; import org . gradle . api . tasks . incremental . InputFileDetails ; import org . gradle . internal . Factory ; import org . gradle . process . internal . WorkerProcessBuilder ; import org . gradle . util . GFileUtils ; import javax . inject . Inject ; import java . io . File ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . atomic . AtomicBoolean ; public class AntlrTask extends SourceTask { private boolean trace ; private boolean traceLexer ; private boolean traceParser ; private boolean traceTreeWalker ; private List < String > arguments = new ArrayList < String > ( ) ; private FileCollection antlrClasspath ; private File outputDirectory ; private String maxHeapSize ; private SourceDirectorySet sourceDirectorySet ; public boolean isTrace ( ) { return trace ; } public void setTrace ( boolean trace ) { this . trace = trace ; } public boolean isTraceLexer ( ) { return traceLexer ; } public void setTraceLexer ( boolean traceLexer ) { this . traceLexer = traceLexer ; } public boolean isTraceParser ( ) { return traceParser ; } public void setTraceParser ( boolean traceParser ) { this . traceParser = traceParser ; } public boolean isTraceTreeWalker ( ) { return traceTreeWalker ; } public void setTraceTreeWalker ( boolean traceTreeWalker ) { this . traceTreeWalker = traceTreeWalker ; } public String getMaxHeapSize ( ) { return maxHeapSize ; } public void setMaxHeapSize ( String maxHeapSize ) { this . maxHeapSize = maxHeapSize ; } public void setArguments ( List < String > arguments ) { if ( arguments ! = null ) { this . arguments = arguments ; } } @Input public List < String > getArguments ( ) { return arguments ; } @OutputDirectory public File getOutputDirectory ( ) { return outputDirectory ; } public void setOutputDirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } @InputFiles public FileCollection getAntlrClasspath ( ) { return antlrClasspath ; } protected void setAntlrClasspath ( FileCollection antlrClasspath ) { this . antlrClasspath = antlrClasspath ; } @Inject protected Factory < WorkerProcessBuilder > getWorkerProcessBuilderFactory ( ) { throw new UnsupportedOperationException ( ) ; } @TaskAction public void execute ( IncrementalTaskInputs inputs ) { final Set < File > grammarFiles = new HashSet < File > ( ) ; final Set < File > sourceFiles = getSource ( ) . getFiles ( ) ; final AtomicBoolean cleanRebuild = new AtomicBoolean ( ) ; inputs . outOfDate ( new Action < InputFileDetails > ( ) { public void execute ( InputFileDetails details ) { File input = details . getFile ( ) ; if ( sourceFiles . contains ( input ) ) { grammarFiles . add ( input ) ; } else { cleanRebuild . set ( true ) ; } } } ) ; inputs . removed ( new Action < InputFileDetails > ( ) { @Override public void execute ( InputFileDetails details ) { if ( details . isRemoved ( ) ) { cleanRebuild . set ( true ) ; } } } ) ; if ( cleanRebuild . get ( ) ) { GFileUtils . cleanDirectory ( outputDirectory ) ; grammarFiles . addAll ( sourceFiles ) ; } AntlrWorkerManager manager = new AntlrWorkerManager ( ) ; AntlrSpec spec = new AntlrSpecFactory ( ) . create ( this , grammarFiles , sourceDirectorySet ) ; AntlrResult result = manager . runWorker ( getProject ( ) . getProjectDir ( ) , getWorkerProcessBuilderFactory ( ) , getAntlrClasspath ( ) , spec ) ; evaluate ( result ) ; } private void evaluate ( AntlrResult result ) { int errorCount = result . getErrorCount ( ) ; if ( errorCount = = <int> ) { throw new AntlrSourceGenerationException ( <str> , result . getException ( ) ) ; } else if ( errorCount > <int> ) { throw new AntlrSourceGenerationException ( <str> + errorCount + <str> , result . getException ( ) ) ; } } @Override public void setSource ( Object source ) { super . setSource ( source ) ; if ( source instanceof SourceDirectorySet ) { this . sourceDirectorySet = ( SourceDirectorySet ) source ; } } @InputFiles @SkipWhenEmpty public FileTree getSource ( ) { return super . getSource ( ) ; } } 
