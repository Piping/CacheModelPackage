package jcuda . jcublas ; import static jcuda . runtime . JCuda . * ; import static jcuda . runtime . JCuda . cudaHostGetDevicePointer ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . assertArrayEquals ; import jcuda . Pointer ; import jcuda . Sizeof ; import jcuda . runtime . JCuda ; import org . junit . Ignore ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . jcublas . CublasPointer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . jcublas . buffer . allocation . PinnedMemoryStrategy ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . jcublas . context . CudaContext ; import org . nd4j . linalg . jcublas . kernel . KernelFunctionLoader ; import org . nd4j . linalg . jcublas . kernel . KernelFunctions ; import org . nd4j . linalg . jcublas . util . PointerUtil ; import org . nd4j . linalg . util . ComplexUtil ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . util . NioUtil ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . FloatBuffer ; @net.jcip.annotations.NotThreadSafe public class CublasPointerTests { @Test public void testAllocateArrays ( ) { INDArray arr1OffsetFor = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray arr1Offset = arr1OffsetFor . get ( NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . all ( ) ) ; arr1Offset = Shape . toOffsetZero ( arr1Offset ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer p = new CublasPointer ( arr1Offset , ctx ) ; if ( ! ( ContextHolder . getInstance ( ) . getMemoryStrategy ( ) instanceof PinnedMemoryStrategy ) ) { float [ ] data = new float [ <int> ] ; float [ ] assertion = { <int> , <int> , <int> , <int> , <int> , <int> } ; JCublas2 . cublasGetVectorAsync ( <int> , Sizeof . FLOAT , p . getDevicePointer ( ) . withByteOffset ( arr1Offset . offset ( ) * arr1Offset . data ( ) . getElementSize ( ) ) , arr1Offset . elementWiseStride ( ) , Pointer . to ( data ) , <int> , ctx . getOldStream ( ) ) ; ctx . syncOldStream ( ) ; for ( int i = <int> ; i < assertion . length ; i + + ) { if ( assertion [ i ] ! = data [ i ] ) System . out . println ( <str> + p ) ; assertEquals ( assertion [ i ] , data [ i ] , <float> ) ; } } ctx . destroy ( ) ; } @Test public void testAllocInt ( ) { JCudaBuffer intBuffer = KernelFunctions . alloc ( new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ) ; assertEquals ( <int> , intBuffer . length ( ) ) ; for ( int i = <int> ; i < intBuffer . length ( ) ; i + + ) { assertEquals ( i + <int> , intBuffer . getInt ( i ) ) ; } CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer pointer = new CublasPointer ( intBuffer , ctx ) ; pointer . copyToHost ( ) ; for ( int i = <int> ; i < intBuffer . length ( ) ; i + + ) { assertEquals ( i + <int> , intBuffer . getInt ( i ) ) ; } } @Test public void testVectorAlongDimension ( ) throws Exception { INDArray arr = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } , <str> ) ; INDArray column = arr . getColumn ( <int> ) ; INDArray otherColumnAssertion = column . dup ( ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer p = new CublasPointer ( column , ctx ) ; p . copyToHost ( ) ; assertEquals ( otherColumnAssertion , column ) ; p . close ( ) ; ctx . destroy ( ) ; } @Test @Ignore public void testTwoByTwoBuffer ( ) throws Exception { IComplexNDArray arr = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) , new int [ ] { <int> , <int> } ) ; IComplexNDArray dup = arr . dup ( ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer pointer = new CublasPointer ( arr , ctx ) ; pointer . copyToHost ( ) ; assertEquals ( dup , arr ) ; pointer . close ( ) ; ctx . destroy ( ) ; } @Test public void testHostMemory ( ) { Pointer hostPointer = Pointer . to ( new double [ ] { <int> } ) ; JCuda . cudaHostAlloc ( hostPointer , Sizeof . DOUBLE , <int> ) ; Pointer devicePointer = new Pointer ( ) ; JCuda . cudaHostGetDevicePointer ( devicePointer , hostPointer , JCuda . cudaHostAllocMapped ) ; JCuda . cudaFreeHost ( hostPointer ) ; } @Test @Ignore public void testHostPrinting ( ) { cudaSetDeviceFlags ( cudaDeviceMapHost ) ; int n = <int> ; Pointer host = new Pointer ( ) ; cudaHostAlloc ( host , n * Sizeof . INT , cudaHostAllocMapped ) ; Pointer device = new Pointer ( ) ; cudaHostGetDevicePointer ( device , host , <int> ) ; ByteBuffer byteBuffer = host . getByteBuffer ( <int> , n * Sizeof . INT ) ; byteBuffer . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer buf = byteBuffer . asFloatBuffer ( ) ; for ( int i = <int> ; i < n ; i + + ) { buf . put ( i , ( float ) i + <int> ) ; } DataBuffer buffer = Nd4j . createBuffer ( new float [ ] { <int> , <int> , <int> , <int> , <int> } ) ; ByteBuffer nio = buffer . asNio ( ) ; nio . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer buf2 = nio . asFloatBuffer ( ) ; for ( int i = <int> ; i < n ; i + + ) { System . out . println ( <str> + buf2 . get ( i ) ) ; } NioUtil . copyAtStride ( <int> , NioUtil . BufferType . FLOAT , nio , <int> , <int> , byteBuffer , <int> , <int> ) ; JCublas . printVector ( n , device ) ; System . out . println ( ) ; } @Test public void testPrinting ( ) throws Exception { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; int [ ] buff = PointerUtil . toShapeInfoBuffer ( arr ) ; DataBuffer shapeBuffer = Nd4j . createBuffer ( buff ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; ContextHolder . getInstance ( ) . setContext ( ) ; KernelFunctionLoader . printBuffer ( ( JCudaBuffer ) shapeBuffer , ctx ) ; } @Test public void testBufferPointer ( ) throws Exception { DataBuffer buff = Nd4j . createBuffer ( new double [ ] { <int> } ) ; DataBuffer clone = buff . dup ( ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer pointer = new CublasPointer ( ( JCudaBuffer ) buff , ctx ) ; pointer . copyToHost ( ) ; pointer . close ( ) ; assertEquals ( clone , buff ) ; INDArray arr = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; System . err . println ( <str> + arr ) ; INDArray brr = Nd4j . create ( new float [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; System . err . println ( <str> + brr ) ; INDArray row = arr . getRow ( <int> ) ; INDArray assertionRow = row . dup ( ) ; CublasPointer pointer2 = new CublasPointer ( row , ctx ) ; pointer2 . copyToHost ( ) ; ctx . destroy ( ) ; assertEquals ( assertionRow , row ) ; } @Test public void testAllocateAndCopyBackToHostC ( ) throws Exception { Nd4j . factory ( ) . setOrder ( <str> ) ; INDArray test = Nd4j . rand ( <int> , <int> ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer p = new CublasPointer ( test , ctx ) ; CublasPointer p1 = new CublasPointer ( ( JCudaBuffer ) test . data ( ) , ctx ) ; p . copyToHost ( ) ; p1 . copyToHost ( ) ; assertEquals ( p . getBuffer ( ) , p1 . getBuffer ( ) ) ; assertArrayEquals ( p . getBuffer ( ) . asBytes ( ) , p1 . getBuffer ( ) . asBytes ( ) ) ; p . close ( ) ; p1 . close ( ) ; ctx . destroy ( ) ; } @Test public void testAllocateAndCopyBackToHost ( ) throws Exception { INDArray test = Nd4j . rand ( <int> , <int> ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; CublasPointer p = new CublasPointer ( test , ctx ) ; CublasPointer p1 = new CublasPointer ( ( JCudaBuffer ) test . data ( ) , ctx ) ; p . copyToHost ( ) ; p1 . copyToHost ( ) ; assertEquals ( p . getBuffer ( ) , p1 . getBuffer ( ) ) ; assertArrayEquals ( p . getBuffer ( ) . asBytes ( ) , p1 . getBuffer ( ) . asBytes ( ) ) ; p . close ( ) ; p1 . close ( ) ; ctx . destroy ( ) ; } @Test public void testColumnCopy ( ) throws Exception { CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; INDArray mat = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray column = mat . getColumn ( <int> ) ; INDArray columnDup = column . dup ( ) ; CublasPointer copy = new CublasPointer ( column , ctx ) ; copy . getDevicePointer ( ) ; copy . copyToHost ( ) ; copy . close ( ) ; assertEquals ( columnDup , column ) ; ctx . destroy ( ) ; } @Test public void testColumnCopyCOrdering ( ) throws Exception { Nd4j . factory ( ) . setOrder ( <str> ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; INDArray mat = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray column = mat . getColumn ( <int> ) ; INDArray columnDup = column . dup ( ) ; CublasPointer copy = new CublasPointer ( column , ctx ) ; copy . getDevicePointer ( ) ; copy . copyToHost ( ) ; copy . close ( ) ; assertEquals ( columnDup , column ) ; Nd4j . factory ( ) . setOrder ( <str> ) ; ctx . destroy ( ) ; } @Test public void testSlicePointers ( ) throws Exception { INDArray arr = Nd4j . create ( <int> , <int> ) ; CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; JCudaBuffer buffer = ( JCudaBuffer ) arr . data ( ) ; for ( int i = <int> ; i < arr . slices ( ) ; i + + ) { CublasPointer pointer = new CublasPointer ( arr . slice ( i ) , ctx ) ; pointer . copyToHost ( ) ; pointer . close ( ) ; } ctx . destroy ( ) ; } } 
