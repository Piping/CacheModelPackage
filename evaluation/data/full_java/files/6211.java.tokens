package org . elasticsearch . gateway ; import com . carrotsearch . hppc . ObjectLongHashMap ; import com . carrotsearch . hppc . ObjectLongMap ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectLongCursor ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . store . StoreFileMetaData ; import org . elasticsearch . indices . store . TransportNodesListShardStoreMetaData ; import java . util . Map ; public abstract class ReplicaShardAllocator extends AbstractComponent { public ReplicaShardAllocator ( Settings settings ) { super ( settings ) ; } public boolean processExistingRecoveries ( RoutingAllocation allocation ) { boolean changed = false ; for ( RoutingNodes . RoutingNodesIterator nodes = allocation . routingNodes ( ) . nodes ( ) ; nodes . hasNext ( ) ; ) { nodes . next ( ) ; for ( RoutingNodes . RoutingNodeIterator it = nodes . nodeShards ( ) ; it . hasNext ( ) ; ) { ShardRouting shard = it . next ( ) ; if ( shard . primary ( ) = = true ) { continue ; } if ( shard . initializing ( ) = = false ) { continue ; } if ( shard . relocatingNodeId ( ) ! = null ) { continue ; } if ( shard . allocatedPostIndexCreate ( ) = = false ) { continue ; } AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > shardStores = fetchData ( shard , allocation ) ; if ( shardStores . hasData ( ) = = false ) { logger . trace ( <str> , shard ) ; continue ; } ShardRouting primaryShard = allocation . routingNodes ( ) . activePrimary ( shard ) ; assert primaryShard ! = null : <str> ; TransportNodesListShardStoreMetaData . StoreFilesMetaData primaryStore = findStore ( primaryShard , allocation , shardStores ) ; if ( primaryStore = = null | | primaryStore . allocated ( ) = = false ) { logger . trace ( <str> , shard ) ; continue ; } MatchingNodes matchingNodes = findMatchingNodes ( shard , allocation , primaryStore , shardStores ) ; if ( matchingNodes . getNodeWithHighestMatch ( ) ! = null ) { DiscoveryNode currentNode = allocation . nodes ( ) . get ( shard . currentNodeId ( ) ) ; DiscoveryNode nodeWithHighestMatch = matchingNodes . getNodeWithHighestMatch ( ) ; if ( currentNode . equals ( nodeWithHighestMatch ) = = false & & matchingNodes . isNodeMatchBySyncID ( currentNode ) = = false & & matchingNodes . isNodeMatchBySyncID ( nodeWithHighestMatch ) = = true ) { it . moveToUnassigned ( new UnassignedInfo ( UnassignedInfo . Reason . REALLOCATED_REPLICA , <str> + currentNode + <str> + nodeWithHighestMatch + <str> , null , allocation . getCurrentNanoTime ( ) , System . currentTimeMillis ( ) ) ) ; changed = true ; } } } } return changed ; } public boolean allocateUnassigned ( RoutingAllocation allocation ) { boolean changed = false ; final RoutingNodes routingNodes = allocation . routingNodes ( ) ; final RoutingNodes . UnassignedShards . UnassignedIterator unassignedIterator = routingNodes . unassigned ( ) . iterator ( ) ; while ( unassignedIterator . hasNext ( ) ) { ShardRouting shard = unassignedIterator . next ( ) ; if ( shard . primary ( ) ) { continue ; } if ( shard . allocatedPostIndexCreate ( ) = = false ) { continue ; } if ( canBeAllocatedToAtLeastOneNode ( shard , allocation ) = = false ) { logger . trace ( <str> , shard ) ; unassignedIterator . removeAndIgnore ( ) ; continue ; } AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > shardStores = fetchData ( shard , allocation ) ; if ( shardStores . hasData ( ) = = false ) { logger . trace ( <str> , shard ) ; allocation . setHasPendingAsyncFetch ( ) ; unassignedIterator . removeAndIgnore ( ) ; continue ; } ShardRouting primaryShard = routingNodes . activePrimary ( shard ) ; assert primaryShard ! = null : <str> ; TransportNodesListShardStoreMetaData . StoreFilesMetaData primaryStore = findStore ( primaryShard , allocation , shardStores ) ; if ( primaryStore = = null | | primaryStore . allocated ( ) = = false ) { logger . trace ( <str> , shard ) ; continue ; } MatchingNodes matchingNodes = findMatchingNodes ( shard , allocation , primaryStore , shardStores ) ; if ( matchingNodes . getNodeWithHighestMatch ( ) ! = null ) { RoutingNode nodeWithHighestMatch = allocation . routingNodes ( ) . node ( matchingNodes . getNodeWithHighestMatch ( ) . id ( ) ) ; Decision decision = allocation . deciders ( ) . canAllocate ( shard , nodeWithHighestMatch , allocation ) ; if ( decision . type ( ) = = Decision . Type . THROTTLE ) { logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , nodeWithHighestMatch . node ( ) ) ; unassignedIterator . removeAndIgnore ( ) ; } else { logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , nodeWithHighestMatch . node ( ) ) ; changed = true ; unassignedIterator . initialize ( nodeWithHighestMatch . nodeId ( ) , shard . version ( ) , allocation . clusterInfo ( ) . getShardSize ( shard , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; } } else if ( matchingNodes . hasAnyData ( ) = = false ) { changed | = ignoreUnassignedIfDelayed ( unassignedIterator , shard ) ; } } return changed ; } public boolean ignoreUnassignedIfDelayed ( RoutingNodes . UnassignedShards . UnassignedIterator unassignedIterator , ShardRouting shard ) { long delay = shard . unassignedInfo ( ) . getLastComputedLeftDelayNanos ( ) ; if ( delay > <int> ) { logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , TimeValue . timeValueNanos ( delay ) ) ; unassignedIterator . removeAndIgnore ( ) ; return true ; } return false ; } private boolean canBeAllocatedToAtLeastOneNode ( ShardRouting shard , RoutingAllocation allocation ) { for ( ObjectCursor < DiscoveryNode > cursor : allocation . nodes ( ) . dataNodes ( ) . values ( ) ) { RoutingNode node = allocation . routingNodes ( ) . node ( cursor . value . id ( ) ) ; if ( node = = null ) { continue ; } Decision decision = allocation . deciders ( ) . canAllocate ( shard , node , allocation ) ; if ( decision . type ( ) = = Decision . Type . YES ) { return true ; } } return false ; } private TransportNodesListShardStoreMetaData . StoreFilesMetaData findStore ( ShardRouting shard , RoutingAllocation allocation , AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > data ) { assert shard . currentNodeId ( ) ! = null ; DiscoveryNode primaryNode = allocation . nodes ( ) . get ( shard . currentNodeId ( ) ) ; if ( primaryNode = = null ) { return null ; } TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData primaryNodeFilesStore = data . getData ( ) . get ( primaryNode ) ; if ( primaryNodeFilesStore = = null ) { return null ; } return primaryNodeFilesStore . storeFilesMetaData ( ) ; } private MatchingNodes findMatchingNodes ( ShardRouting shard , RoutingAllocation allocation , TransportNodesListShardStoreMetaData . StoreFilesMetaData primaryStore , AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > data ) { ObjectLongMap < DiscoveryNode > nodesToSize = new ObjectLongHashMap < > ( ) ; for ( Map . Entry < DiscoveryNode , TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > nodeStoreEntry : data . getData ( ) . entrySet ( ) ) { DiscoveryNode discoNode = nodeStoreEntry . getKey ( ) ; TransportNodesListShardStoreMetaData . StoreFilesMetaData storeFilesMetaData = nodeStoreEntry . getValue ( ) . storeFilesMetaData ( ) ; if ( storeFilesMetaData = = null ) { continue ; } RoutingNode node = allocation . routingNodes ( ) . node ( discoNode . id ( ) ) ; if ( node = = null ) { continue ; } Decision decision = allocation . deciders ( ) . canAllocate ( shard , node , allocation ) ; if ( decision . type ( ) = = Decision . Type . NO ) { continue ; } if ( storeFilesMetaData . allocated ( ) ) { continue ; } if ( storeFilesMetaData . iterator ( ) . hasNext ( ) = = false ) { continue ; } String primarySyncId = primaryStore . syncId ( ) ; String replicaSyncId = storeFilesMetaData . syncId ( ) ; if ( replicaSyncId ! = null & & replicaSyncId . equals ( primarySyncId ) ) { logger . trace ( <str> , shard , discoNode . name ( ) , replicaSyncId ) ; nodesToSize . put ( discoNode , Long . MAX_VALUE ) ; } else { long sizeMatched = <int> ; for ( StoreFileMetaData storeFileMetaData : storeFilesMetaData ) { String metaDataFileName = storeFileMetaData . name ( ) ; if ( primaryStore . fileExists ( metaDataFileName ) & & primaryStore . file ( metaDataFileName ) . isSame ( storeFileMetaData ) ) { sizeMatched + = storeFileMetaData . length ( ) ; } } logger . trace ( <str> , shard , discoNode . name ( ) , new ByteSizeValue ( sizeMatched ) , sizeMatched ) ; nodesToSize . put ( discoNode , sizeMatched ) ; } } return new MatchingNodes ( nodesToSize ) ; } protected abstract AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > fetchData ( ShardRouting shard , RoutingAllocation allocation ) ; static class MatchingNodes { private final ObjectLongMap < DiscoveryNode > nodesToSize ; private final DiscoveryNode nodeWithHighestMatch ; public MatchingNodes ( ObjectLongMap < DiscoveryNode > nodesToSize ) { this . nodesToSize = nodesToSize ; long highestMatchSize = <int> ; DiscoveryNode highestMatchNode = null ; for ( ObjectLongCursor < DiscoveryNode > cursor : nodesToSize ) { if ( cursor . value > highestMatchSize ) { highestMatchSize = cursor . value ; highestMatchNode = cursor . key ; } } this . nodeWithHighestMatch = highestMatchNode ; } @Nullable public DiscoveryNode getNodeWithHighestMatch ( ) { return this . nodeWithHighestMatch ; } public boolean isNodeMatchBySyncID ( DiscoveryNode node ) { return nodesToSize . get ( node ) = = Long . MAX_VALUE ; } public boolean hasAnyData ( ) { return nodesToSize . isEmpty ( ) = = false ; } } } 
