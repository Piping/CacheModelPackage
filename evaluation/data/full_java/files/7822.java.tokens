package org . elasticsearch . cluster . metadata ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver . Context ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver . DateMathExpressionResolver ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . format . DateTimeFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . joda . time . DateTimeZone . UTC ; public class DateMathExpressionResolverTests extends ESTestCase { private final DateMathExpressionResolver expressionResolver = new DateMathExpressionResolver ( Settings . EMPTY ) ; private final Context context = new Context ( ClusterState . builder ( new ClusterName ( <str> ) ) . build ( ) , IndicesOptions . strictExpand ( ) ) ; public void testNormal ( ) throws Exception { int numIndexExpressions = randomIntBetween ( <int> , <int> ) ; List < String > indexExpressions = new ArrayList < > ( numIndexExpressions ) ; for ( int i = <int> ; i < numIndexExpressions ; i + + ) { indexExpressions . add ( randomAsciiOfLength ( <int> ) ) ; } List < String > result = expressionResolver . resolve ( context , indexExpressions ) ; assertThat ( result . size ( ) , equalTo ( indexExpressions . size ( ) ) ) ; for ( int i = <int> ; i < indexExpressions . size ( ) ; i + + ) { assertThat ( result . get ( i ) , equalTo ( indexExpressions . get ( i ) ) ) ; } } public void testExpression ( ) throws Exception { List < String > indexExpressions = Arrays . asList ( <str> , <str> , <str> ) ; List < String > result = expressionResolver . resolve ( context , indexExpressions ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; } public void testEmpty ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Collections . < String > emptyList ( ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; } public void testExpression_Static ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> ) ) ; } public void testExpression_MultiParts ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) + <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) . withDayOfMonth ( <int> ) ) ) ) ; } public void testExpression_CustomFormat ( ) throws Exception { List < String > results = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; } public void testExpression_EscapeStatic ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; } public void testExpression_EscapeDateFormat ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; } public void testExpression_MixedArray ( ) throws Exception { List < String > result = expressionResolver . resolve ( context , Arrays . asList ( <str> , <str> , <str> , <str> ) ) ; assertThat ( result . size ( ) , equalTo ( <int> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) ) ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> ) ) ; assertThat ( result . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( new DateTime ( context . getStartTime ( ) , UTC ) . withDayOfMonth ( <int> ) ) ) ) ; } public void testExpression_CustomTimeZoneInSetting ( ) throws Exception { DateTimeZone timeZone ; int hoursOffset ; int minutesOffset = <int> ; if ( randomBoolean ( ) ) { hoursOffset = randomIntBetween ( - <int> , <int> ) ; timeZone = DateTimeZone . forOffsetHours ( hoursOffset ) ; } else { hoursOffset = randomIntBetween ( - <int> , <int> ) ; minutesOffset = randomIntBetween ( <int> , <int> ) ; timeZone = DateTimeZone . forOffsetHoursMinutes ( hoursOffset , minutesOffset ) ; } DateTime now ; if ( hoursOffset > = <int> ) { now = DateTime . now ( UTC ) . plusHours ( hoursOffset ) . plusMinutes ( minutesOffset ) . withHourOfDay ( <int> ) . withMinuteOfHour ( <int> ) . withSecondOfMinute ( <int> ) ; } else { now = DateTime . now ( UTC ) . withHourOfDay ( <int> ) . withMinuteOfHour ( <int> ) . withSecondOfMinute ( <int> ) ; } Settings settings = Settings . builder ( ) . put ( <str> , timeZone . getID ( ) ) . build ( ) ; DateMathExpressionResolver expressionResolver = new DateMathExpressionResolver ( settings ) ; Context context = new Context ( this . context . getState ( ) , this . context . getOptions ( ) , now . getMillis ( ) ) ; List < String > results = expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> , timeZone , now , results . get ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( now . withZone ( timeZone ) ) ) ) ; } public void testExpression_CustomTimeZoneInIndexName ( ) throws Exception { DateTimeZone timeZone ; int hoursOffset ; int minutesOffset = <int> ; if ( randomBoolean ( ) ) { hoursOffset = randomIntBetween ( - <int> , <int> ) ; timeZone = DateTimeZone . forOffsetHours ( hoursOffset ) ; } else { hoursOffset = randomIntBetween ( - <int> , <int> ) ; minutesOffset = randomIntBetween ( <int> , <int> ) ; timeZone = DateTimeZone . forOffsetHoursMinutes ( hoursOffset , minutesOffset ) ; } DateTime now ; if ( hoursOffset > = <int> ) { now = DateTime . now ( UTC ) . plusHours ( hoursOffset ) . plusMinutes ( minutesOffset ) . withHourOfDay ( <int> ) . withMinuteOfHour ( <int> ) . withSecondOfMinute ( <int> ) ; } else { now = DateTime . now ( UTC ) . withHourOfDay ( <int> ) . withMinuteOfHour ( <int> ) . withSecondOfMinute ( <int> ) ; } Context context = new Context ( this . context . getState ( ) , this . context . getOptions ( ) , now . getMillis ( ) ) ; List < String > results = expressionResolver . resolve ( context , Arrays . asList ( <str> + timeZone . getID ( ) + <str> ) ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> , timeZone , now , results . get ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <str> + DateTimeFormat . forPattern ( <str> ) . print ( now . withZone ( timeZone ) ) ) ) ; } public void testExpressionInvalidUnescaped ( ) throws Exception { try { expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testExpressionInvalidDateMathFormat ( ) throws Exception { try { expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testExpressionInvalidEmptyDateMathFormat ( ) throws Exception { try { expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testExpressionInvalidOpenEnded ( ) throws Exception { try { expressionResolver . resolve ( context , Arrays . asList ( <str> ) ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } } 
