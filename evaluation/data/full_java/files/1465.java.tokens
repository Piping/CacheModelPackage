package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . Iterator ; import org . junit . Assert ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . filter . DataLimits ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public class SinglePartitionSliceCommandTest { private static final Logger logger = LoggerFactory . getLogger ( SinglePartitionSliceCommandTest . class ) ; private static final String KEYSPACE = <str> ; private static final String TABLE = <str> ; private static CFMetaData cfm ; private static ColumnDefinition v ; private static ColumnDefinition s ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { cfm = CFMetaData . Builder . create ( KEYSPACE , TABLE ) . addPartitionKey ( <str> , UTF8Type . instance ) . addStaticColumn ( <str> , UTF8Type . instance ) . addClusteringColumn ( <str> , IntegerType . instance ) . addRegularColumn ( <str> , UTF8Type . instance ) . build ( ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , cfm ) ; cfm = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; v = cfm . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; s = cfm . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; } @Before public void truncate ( ) { Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( TABLE ) . truncateBlocking ( ) ; } @Test public void staticColumnsAreFiltered ( ) throws IOException { DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( <str> ) ) ; UntypedResultSet rows ; QueryProcessor . executeInternal ( <str> ) ; QueryProcessor . executeInternal ( <str> ) ; QueryProcessor . executeInternal ( <str> ) ; rows = QueryProcessor . executeInternal ( <str> ) ; for ( UntypedResultSet . Row row : rows ) { logger . debug ( <str> , ( row . has ( <str> ) ? row . getString ( <str> ) : null ) , ( row . has ( <str> ) ? row . getString ( <str> ) : null ) , ( row . has ( <str> ) ? row . getString ( <str> ) : null ) ) ; } assert rows . isEmpty ( ) ; ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( v ) ) ; ByteBuffer zero = ByteBufferUtil . bytes ( <int> ) ; Slices slices = Slices . with ( cfm . comparator , Slice . make ( Slice . Bound . inclusiveStartOf ( zero ) , Slice . Bound . inclusiveEndOf ( zero ) ) ) ; ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( slices , false ) ; ReadCommand cmd = new SinglePartitionReadCommand ( false , MessagingService . VERSION_30 , true , cfm , FBUtilities . nowInSeconds ( ) , columnFilter , RowFilter . NONE , DataLimits . NONE , key , sliceFilter ) ; DataOutputBuffer out = new DataOutputBuffer ( ( int ) ReadCommand . legacyReadCommandSerializer . serializedSize ( cmd , MessagingService . VERSION_21 ) ) ; ReadCommand . legacyReadCommandSerializer . serialize ( cmd , out , MessagingService . VERSION_21 ) ; DataInputPlus in = new DataInputBuffer ( out . buffer ( ) , true ) ; cmd = ReadCommand . legacyReadCommandSerializer . deserialize ( in , MessagingService . VERSION_21 ) ; logger . debug ( <str> , cmd ) ; UnfilteredPartitionIterator partitionIterator = cmd . executeLocally ( ReadExecutionController . empty ( ) ) ; ReadResponse response = ReadResponse . createDataResponse ( partitionIterator , cmd . columnFilter ( ) ) ; logger . debug ( <str> , response ) ; partitionIterator = response . makeIterator ( cfm , null ) ; assert partitionIterator . hasNext ( ) ; UnfilteredRowIterator partition = partitionIterator . next ( ) ; LegacyLayout . LegacyUnfilteredPartition rowIter = LegacyLayout . fromUnfilteredRowIterator ( partition ) ; Assert . assertEquals ( Collections . emptyList ( ) , rowIter . cells ) ; } private void checkForS ( UnfilteredPartitionIterator pi ) { Assert . assertTrue ( pi . toString ( ) , pi . hasNext ( ) ) ; UnfilteredRowIterator ri = pi . next ( ) ; Assert . assertTrue ( ri . columns ( ) . contains ( s ) ) ; Row staticRow = ri . staticRow ( ) ; Iterator < Cell > cellIterator = staticRow . cells ( ) . iterator ( ) ; Assert . assertTrue ( staticRow . toString ( cfm , true ) , cellIterator . hasNext ( ) ) ; Cell cell = cellIterator . next ( ) ; Assert . assertEquals ( s , cell . column ( ) ) ; Assert . assertEquals ( ByteBufferUtil . bytesToHex ( cell . value ( ) ) , ByteBufferUtil . bytes ( <str> ) , cell . value ( ) ) ; Assert . assertFalse ( cellIterator . hasNext ( ) ) ; } @Test public void staticColumnsAreReturned ( ) throws IOException { DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( <str> ) ) ; QueryProcessor . executeInternal ( <str> ) ; Assert . assertFalse ( QueryProcessor . executeInternal ( <str> ) . isEmpty ( ) ) ; ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( s ) ) ; ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( Slices . NONE , false ) ; ReadCommand cmd = new SinglePartitionReadCommand ( false , MessagingService . VERSION_30 , true , cfm , FBUtilities . nowInSeconds ( ) , columnFilter , RowFilter . NONE , DataLimits . NONE , key , sliceFilter ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator pi = cmd . executeLocally ( executionController ) ) { checkForS ( pi ) ; } ReadResponse response ; DataOutputBuffer out ; DataInputPlus in ; ReadResponse dst ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator pi = cmd . executeLocally ( executionController ) ) { response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; } out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION_30 ) ) ; ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION_30 ) ; in = new DataInputBuffer ( out . buffer ( ) , true ) ; dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION_30 ) ; try ( UnfilteredPartitionIterator pi = dst . makeIterator ( cfm , cmd ) ) { checkForS ( pi ) ; } Schema . instance . getColumnFamilyStoreInstance ( cfm . cfId ) . forceBlockingFlush ( ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator pi = cmd . executeLocally ( executionController ) ) { response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; } out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION_30 ) ) ; ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION_30 ) ; in = new DataInputBuffer ( out . buffer ( ) , true ) ; dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION_30 ) ; try ( UnfilteredPartitionIterator pi = dst . makeIterator ( cfm , cmd ) ) { checkForS ( pi ) ; } } } 
