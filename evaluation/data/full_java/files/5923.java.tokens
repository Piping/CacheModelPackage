package org . elasticsearch . common . io ; import org . elasticsearch . common . SuppressForbidden ; import org . jboss . netty . buffer . ChannelBuffer ; import java . io . EOFException ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . WritableByteChannel ; @SuppressForbidden ( reason = <str> ) public final class Channels { private Channels ( ) { } private static final int READ_CHUNK_SIZE = <int> ; private static final int WRITE_CHUNK_SIZE = <int> ; public static byte [ ] readFromFileChannel ( FileChannel channel , long position , int length ) throws IOException { byte [ ] res = new byte [ length ] ; readFromFileChannelWithEofException ( channel , position , res , <int> , length ) ; return res ; } public static void readFromFileChannelWithEofException ( FileChannel channel , long channelPosition , byte [ ] dest , int destOffset , int length ) throws IOException { int read = readFromFileChannel ( channel , channelPosition , dest , destOffset , length ) ; if ( read < <int> ) { throw new EOFException ( <str> + channelPosition + <str> + length + <str> + channel . size ( ) + <str> ) ; } } public static int readFromFileChannel ( FileChannel channel , long channelPosition , byte [ ] dest , int destOffset , int length ) throws IOException { ByteBuffer buffer = ByteBuffer . wrap ( dest , destOffset , length ) ; return readFromFileChannel ( channel , channelPosition , buffer ) ; } public static void readFromFileChannelWithEofException ( FileChannel channel , long channelPosition , ByteBuffer dest ) throws IOException { int read = readFromFileChannel ( channel , channelPosition , dest ) ; if ( read < <int> ) { throw new EOFException ( <str> + channelPosition + <str> + dest . limit ( ) + <str> + channel . size ( ) + <str> ) ; } } public static int readFromFileChannel ( FileChannel channel , long channelPosition , ByteBuffer dest ) throws IOException { if ( dest . isDirect ( ) | | ( dest . remaining ( ) < READ_CHUNK_SIZE ) ) { return readSingleChunk ( channel , channelPosition , dest ) ; } else { int bytesRead = <int> ; int bytesToRead = dest . remaining ( ) ; ByteBuffer tmpBuffer = dest . duplicate ( ) ; try { while ( dest . hasRemaining ( ) ) { tmpBuffer . limit ( Math . min ( dest . limit ( ) , tmpBuffer . position ( ) + READ_CHUNK_SIZE ) ) ; int read = readSingleChunk ( channel , channelPosition , tmpBuffer ) ; if ( read < <int> ) { return read ; } bytesRead + = read ; channelPosition + = read ; dest . position ( tmpBuffer . position ( ) ) ; } } finally { dest . position ( tmpBuffer . position ( ) ) ; } assert bytesRead = = bytesToRead : <str> + bytesRead + <str> + bytesToRead + <str> ; return bytesRead ; } } private static int readSingleChunk ( FileChannel channel , long channelPosition , ByteBuffer dest ) throws IOException { int bytesRead = <int> ; while ( dest . hasRemaining ( ) ) { int read = channel . read ( dest , channelPosition ) ; if ( read < <int> ) { return read ; } assert read > <int> : <str> ; bytesRead + = read ; channelPosition + = read ; } return bytesRead ; } public static void writeToChannel ( ChannelBuffer source , int sourceIndex , int length , GatheringByteChannel channel ) throws IOException { while ( length > <int> ) { int written = source . getBytes ( sourceIndex , channel , length ) ; sourceIndex + = written ; length - = written ; } assert length = = <int> ; } public static void writeToChannel ( byte [ ] source , WritableByteChannel channel ) throws IOException { writeToChannel ( source , <int> , source . length , channel ) ; } public static void writeToChannel ( byte [ ] source , int offset , int length , WritableByteChannel channel ) throws IOException { int toWrite = Math . min ( length , WRITE_CHUNK_SIZE ) ; ByteBuffer buffer = ByteBuffer . wrap ( source , offset , toWrite ) ; int written = channel . write ( buffer ) ; length - = written ; while ( length > <int> ) { toWrite = Math . min ( length , WRITE_CHUNK_SIZE ) ; buffer . limit ( buffer . position ( ) + toWrite ) ; written = channel . write ( buffer ) ; length - = written ; } assert length = = <int> : <str> + length + <str> ; } public static void writeToChannel ( ByteBuffer byteBuffer , WritableByteChannel channel ) throws IOException { if ( byteBuffer . isDirect ( ) | | ( byteBuffer . remaining ( ) < = WRITE_CHUNK_SIZE ) ) { while ( byteBuffer . hasRemaining ( ) ) { channel . write ( byteBuffer ) ; } } else { ByteBuffer tmpBuffer = byteBuffer . duplicate ( ) ; try { while ( byteBuffer . hasRemaining ( ) ) { tmpBuffer . limit ( Math . min ( byteBuffer . limit ( ) , tmpBuffer . position ( ) + WRITE_CHUNK_SIZE ) ) ; while ( tmpBuffer . hasRemaining ( ) ) { channel . write ( tmpBuffer ) ; } byteBuffer . position ( tmpBuffer . position ( ) ) ; } } finally { byteBuffer . position ( tmpBuffer . position ( ) ) ; } } } } 
