package io . netty . example . http2 . helloworld . client ; import io . netty . bootstrap . Bootstrap ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelOption ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpScheme ; import io . netty . handler . codec . http2 . Http2SecurityUtil ; import io . netty . handler . codec . http2 . HttpConversionUtil ; import io . netty . handler . ssl . ApplicationProtocolConfig ; import io . netty . handler . ssl . ApplicationProtocolConfig . Protocol ; import io . netty . handler . ssl . ApplicationProtocolConfig . SelectedListenerFailureBehavior ; import io . netty . handler . ssl . ApplicationProtocolConfig . SelectorFailureBehavior ; import io . netty . handler . ssl . ApplicationProtocolNames ; import io . netty . handler . ssl . OpenSsl ; import io . netty . handler . ssl . SslContext ; import io . netty . handler . ssl . SslContextBuilder ; import io . netty . handler . ssl . SslProvider ; import io . netty . handler . ssl . SupportedCipherSuiteFilter ; import io . netty . handler . ssl . util . InsecureTrustManagerFactory ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import java . util . concurrent . TimeUnit ; import static io . netty . handler . codec . http . HttpMethod . GET ; import static io . netty . handler . codec . http . HttpMethod . POST ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; public final class Http2Client { static final boolean SSL = System . getProperty ( <str> ) ! = null ; static final String HOST = System . getProperty ( <str> , <str> ) ; static final int PORT = Integer . parseInt ( System . getProperty ( <str> , SSL ? <str> : <str> ) ) ; static final String URL = System . getProperty ( <str> , <str> ) ; static final String URL2 = System . getProperty ( <str> ) ; static final String URL2DATA = System . getProperty ( <str> , <str> ) ; public static void main ( String [ ] args ) throws Exception { final SslContext sslCtx ; if ( SSL ) { SslProvider provider = OpenSsl . isAlpnSupported ( ) ? SslProvider . OPENSSL : SslProvider . JDK ; sslCtx = SslContextBuilder . forClient ( ) . sslProvider ( provider ) . ciphers ( Http2SecurityUtil . CIPHERS , SupportedCipherSuiteFilter . INSTANCE ) . trustManager ( InsecureTrustManagerFactory . INSTANCE ) . applicationProtocolConfig ( new ApplicationProtocolConfig ( Protocol . ALPN , SelectorFailureBehavior . NO_ADVERTISE , SelectedListenerFailureBehavior . ACCEPT , ApplicationProtocolNames . HTTP_2 , ApplicationProtocolNames . HTTP_1_1 ) ) . build ( ) ; } else { sslCtx = null ; } EventLoopGroup workerGroup = new NioEventLoopGroup ( ) ; Http2ClientInitializer initializer = new Http2ClientInitializer ( sslCtx , Integer . MAX_VALUE ) ; try { Bootstrap b = new Bootstrap ( ) ; b . group ( workerGroup ) ; b . channel ( NioSocketChannel . class ) ; b . option ( ChannelOption . SO_KEEPALIVE , true ) ; b . remoteAddress ( HOST , PORT ) ; b . handler ( initializer ) ; Channel channel = b . connect ( ) . syncUninterruptibly ( ) . channel ( ) ; System . out . println ( <str> + HOST + <str> + PORT + <str> ) ; Http2SettingsHandler http2SettingsHandler = initializer . settingsHandler ( ) ; http2SettingsHandler . awaitSettings ( <int> , TimeUnit . SECONDS ) ; HttpResponseHandler responseHandler = initializer . responseHandler ( ) ; int streamId = <int> ; HttpScheme scheme = SSL ? HttpScheme . HTTPS : HttpScheme . HTTP ; AsciiString hostName = new AsciiString ( HOST + <str> + PORT ) ; System . err . println ( <str> ) ; if ( URL ! = null ) { FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , URL ) ; request . headers ( ) . add ( HttpHeaderNames . HOST , hostName ) ; request . headers ( ) . add ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , scheme . name ( ) ) ; request . headers ( ) . add ( HttpHeaderNames . ACCEPT_ENCODING , HttpHeaderValues . GZIP ) ; request . headers ( ) . add ( HttpHeaderNames . ACCEPT_ENCODING , HttpHeaderValues . DEFLATE ) ; responseHandler . put ( streamId , channel . writeAndFlush ( request ) , channel . newPromise ( ) ) ; streamId + = <int> ; } if ( URL2 ! = null ) { FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , POST , URL2 , Unpooled . copiedBuffer ( URL2DATA . getBytes ( CharsetUtil . UTF_8 ) ) ) ; request . headers ( ) . add ( HttpHeaderNames . HOST , hostName ) ; request . headers ( ) . add ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , scheme . name ( ) ) ; request . headers ( ) . add ( HttpHeaderNames . ACCEPT_ENCODING , HttpHeaderValues . GZIP ) ; request . headers ( ) . add ( HttpHeaderNames . ACCEPT_ENCODING , HttpHeaderValues . DEFLATE ) ; responseHandler . put ( streamId , channel . writeAndFlush ( request ) , channel . newPromise ( ) ) ; streamId + = <int> ; } responseHandler . awaitResponses ( <int> , TimeUnit . SECONDS ) ; System . out . println ( <str> ) ; channel . close ( ) . syncUninterruptibly ( ) ; } finally { workerGroup . shutdownGracefully ( ) ; } } } 
