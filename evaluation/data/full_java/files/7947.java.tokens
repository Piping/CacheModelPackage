package org . elasticsearch . common . network ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . network . Cidrs ; import org . elasticsearch . search . aggregations . bucket . range . ipv4 . IPv4RangeBuilder ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; import static org . hamcrest . Matchers . * ; public class CidrsTests extends ESTestCase { public void testNullCidr ( ) { try { Cidrs . cidrMaskToMinMax ( null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; } } public void testSplittingSlash ( ) { List < String > cases = new ArrayList < > ( ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; for ( String test : cases ) { try { Cidrs . cidrMaskToMinMax ( test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; } } } public void testSplittingDot ( ) { List < String > cases = new ArrayList < > ( ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; for ( String test : cases ) { try { Cidrs . cidrMaskToMinMax ( test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; } } } public void testValidSpecificCases ( ) { List < Tuple < String , long [ ] > > cases = new ArrayList < > ( ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { ( <int> < < <int> ) + ( <int> < < <int> ) , ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) } ) ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) , ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) } ) ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { <int> < < <int> , ( <int> < < <int> ) + ( <int> < < <int> ) } ) ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { <int> , <int> < < <int> } ) ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { <int> , <int> < < <int> } ) ) ; cases . add ( new Tuple < > ( <str> , new long [ ] { ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + ( <int> < < <int> ) + ( <int> < < <int> ) + <int> + <int> } ) ) ; for ( Tuple < String , long [ ] > test : cases ) { long [ ] actual = Cidrs . cidrMaskToMinMax ( test . v1 ( ) ) ; assertArrayEquals ( test . v1 ( ) , test . v2 ( ) , actual ) ; } } public void testInvalidSpecificOctetCases ( ) { List < String > cases = new ArrayList < > ( ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; for ( String test : cases ) { try { Cidrs . cidrMaskToMinMax ( test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; } } } public void testInvalidSpecificNetworkMaskCases ( ) { List < String > cases = new ArrayList < > ( ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; for ( String test : cases ) { try { Cidrs . cidrMaskToMinMax ( test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e , hasToString ( containsString ( <str> ) ) ) ; } } } public void testValidCombinations ( ) { for ( long i = <int> ; i < ( <int> < < <int> ) ; i + + ) { for ( int mask = <int> ; mask < = <int> ; mask + + ) { String test = Cidrs . octetsToCIDR ( Cidrs . longToOctets ( i < < <int> ) , mask ) ; long [ ] actual = Cidrs . cidrMaskToMinMax ( test ) ; assertNotNull ( test , actual ) ; assertEquals ( test , <int> , actual . length ) ; assertEquals ( test , i < < <int> , actual [ <int> ] ) ; assertEquals ( test , ( i < < <int> ) + ( <int> < < ( <int> - mask ) ) , actual [ <int> ] ) ; } } } public void testInvalidCombinations ( ) { List < String > cases = new ArrayList < > ( ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; cases . add ( <str> ) ; int value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { cases . add ( Cidrs . octetsToCIDR ( Cidrs . longToOctets ( value ) , <int> - i - <int> ) ) ; value < < = <int> ; } for ( String test : cases ) { try { Cidrs . cidrMaskToMinMax ( test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( test , e , hasToString ( containsString ( <str> ) ) ) ; } } } public void testRandomValidCombinations ( ) { List < Tuple < String , Integer > > cases = new ArrayList < > ( ) ; for ( int i = <int> ; i < randomIntBetween ( <int> , <int> ) ; i + + ) { int networkMask = randomIntBetween ( <int> , <int> ) ; long mask = ( <int> < < ( <int> - networkMask ) ) - <int> ; long address = randomLongInIPv4Range ( ) & ~ mask ; cases . add ( new Tuple < > ( Cidrs . octetsToCIDR ( Cidrs . longToOctets ( address ) , networkMask ) , networkMask ) ) ; } for ( Tuple < String , Integer > test : cases ) { long [ ] actual = Cidrs . cidrMaskToMinMax ( test . v1 ( ) ) ; assertNotNull ( test . v1 ( ) , actual ) ; assertEquals ( test . v1 ( ) , <int> , actual . length ) ; assertEquals ( test . v1 ( ) , <int> < < ( <int> - test . v2 ( ) ) , actual [ <int> ] - actual [ <int> ] ) ; } } private long randomLongInIPv4Range ( ) { return randomLong ( ) & <hex> ; } } 
