package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . Iterables ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . Term . MultiItemTerminal ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . ByteBufferUtil ; import static java . util . Arrays . asList ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class PrimaryKeyRestrictionSetTest { @Test public void testboundsAsClusteringWithNoRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; } @Test public void testboundsAsClusteringWithOneEqRestrictionsAndOneClusteringColumn ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer clustering_0 = ByteBufferUtil . bytes ( <int> ) ; Restriction eq = newSingleEq ( cfMetaData , <int> , clustering_0 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , clustering_0 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , clustering_0 ) ; } @Test public void testboundsAsClusteringWithOneEqRestrictionsAndTwoClusteringColumns ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer clustering_0 = ByteBufferUtil . bytes ( <int> ) ; Restriction eq = newSingleEq ( cfMetaData , <int> , clustering_0 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , clustering_0 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , clustering_0 ) ; } @Test public void testboundsAsClusteringWithOneInRestrictionsAndOneClusteringColumn ( ) throws InvalidRequestException { ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; CFMetaData cfMetaData = newCFMetaData ( <int> ) ; Restriction in = newSingleIN ( cfMetaData , <int> , value1 , value2 , value3 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( in ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 ) ; assertStartBound ( get ( bounds , <int> ) , true , value2 ) ; assertStartBound ( get ( bounds , <int> ) , true , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 ) ; assertEndBound ( get ( bounds , <int> ) , true , value2 ) ; assertEndBound ( get ( bounds , <int> ) , true , value3 ) ; } @Test public void testboundsAsClusteringWithSliceRestrictionsAndOneClusteringColumn ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; Restriction slice = newSingleSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . END , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . END , false , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value1 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; Restriction slice2 = newSingleSlice ( cfMetaData , <int> , Bound . END , false , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value2 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; slice2 = newSingleSlice ( cfMetaData , <int> , Bound . END , true , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value2 ) ; } @Test public void testboundsAsClusteringWithEqAndInRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; Restriction eq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction in = newSingleIN ( cfMetaData , <int> , value1 , value2 , value3 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( in ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value1 ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value1 ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value3 ) ; } @Test public void testboundsAsClusteringWithEqAndSliceRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; Restriction eq = newSingleEq ( cfMetaData , <int> , value3 ) ; Restriction slice = newSingleSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value3 , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value3 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value3 , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value3 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . END , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value3 , value1 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . END , false , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value3 , value1 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; Restriction slice2 = newSingleSlice ( cfMetaData , <int> , Bound . END , false , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value3 , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value3 , value2 ) ; slice = newSingleSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; slice2 = newSingleSlice ( cfMetaData , <int> , Bound . END , true , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value3 , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value3 , value2 ) ; } @Test public void testboundsAsClusteringWithMultiEqRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; Restriction eq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( eq ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; } @Test public void testboundsAsClusteringWithMultiInRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; Restriction in = newMultiIN ( cfMetaData , <int> , asList ( value1 , value2 ) , asList ( value2 , value3 ) ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( in ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; assertStartBound ( get ( bounds , <int> ) , true , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; assertEndBound ( get ( bounds , <int> ) , true , value2 , value3 ) ; } @Test public void testboundsAsClusteringWithMultiSliceRestrictionsWithOneClusteringColumn ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; Restriction slice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . END , true , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . END , false , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value1 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value1 ) ; Restriction slice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , false , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value2 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , true , value1 ) ; slice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , true , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value2 ) ; } @Test public void testboundsAsClusteringWithMultiSliceRestrictionsWithTwoClusteringColumn ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; Restriction slice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value1 , value2 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , true , value1 , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyEnd ( get ( bounds , <int> ) ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . END , true , value1 , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . END , false , value1 , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEmptyStart ( get ( bounds , <int> ) ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value1 , value2 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value1 , value2 ) ; Restriction slice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , false , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value2 ) ; slice = newMultiSlice ( cfMetaData , <int> , Bound . START , true , value1 , value2 ) ; slice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , true , value2 , value1 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( slice ) . mergeWith ( slice2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value2 , value1 ) ; } @Test public void testboundsAsClusteringWithSingleEqAndMultiEqRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value4 = ByteBufferUtil . bytes ( <int> ) ; Restriction singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction multiEq = newMultiEq ( cfMetaData , <int> , value2 , value3 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiEq ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction singleEq2 = newSingleEq ( cfMetaData , <int> , value2 ) ; multiEq = newMultiEq ( cfMetaData , <int> , value3 , value4 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( singleEq2 ) . mergeWith ( multiEq ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value3 ) ; multiEq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiEq ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; singleEq2 = newSingleEq ( cfMetaData , <int> , value4 ) ; multiEq = newMultiEq ( cfMetaData , <int> , value2 , value3 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiEq ) . mergeWith ( singleEq2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; } @Test public void testboundsAsClusteringWithSingleEqAndMultiINRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value4 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value5 = ByteBufferUtil . bytes ( <int> ) ; Restriction singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction multiIN = newMultiIN ( cfMetaData , <int> , asList ( value2 , value3 ) , asList ( value4 , value5 ) ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiIN ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value4 , value5 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value4 , value5 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; multiIN = newMultiIN ( cfMetaData , <int> , asList ( value2 , value3 ) ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiIN ) . mergeWith ( singleEq ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction singleEq2 = newSingleEq ( cfMetaData , <int> , value5 ) ; multiIN = newMultiIN ( cfMetaData , <int> , asList ( value2 , value3 ) , asList ( value4 , value5 ) ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiIN ) . mergeWith ( singleEq2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value5 , value2 , value3 ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value5 , value4 , value5 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value5 , value2 , value3 ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value5 , value4 , value5 ) ; } @Test public void testboundsAsClusteringWithSingleEqAndSliceRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value4 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value5 = ByteBufferUtil . bytes ( <int> ) ; Restriction singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; Restriction multiSlice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value2 , value3 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( singleEq ) . mergeWith ( multiSlice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; multiSlice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value2 , value3 ) ; Restriction multiSlice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , false , value4 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiSlice2 ) . mergeWith ( singleEq ) . mergeWith ( multiSlice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , false , value1 , value4 ) ; singleEq = newSingleEq ( cfMetaData , <int> , value1 ) ; multiSlice = newMultiSlice ( cfMetaData , <int> , Bound . START , true , value2 , value3 ) ; multiSlice2 = newMultiSlice ( cfMetaData , <int> , Bound . END , true , value4 , value5 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiSlice2 ) . mergeWith ( singleEq ) . mergeWith ( multiSlice ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value4 , value5 ) ; } @Test public void testboundsAsClusteringWithMultiEqAndSingleSliceRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; Restriction multiEq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; Restriction singleSlice = newSingleSlice ( cfMetaData , <int> , Bound . START , false , value3 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiEq ) . mergeWith ( singleSlice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 , value3 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; } @Test public void testboundsAsClusteringWithSeveralMultiColumnRestrictions ( ) throws InvalidRequestException { CFMetaData cfMetaData = newCFMetaData ( <int> ) ; ByteBuffer value1 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value2 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value3 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value4 = ByteBufferUtil . bytes ( <int> ) ; ByteBuffer value5 = ByteBufferUtil . bytes ( <int> ) ; Restriction multiEq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; Restriction multiSlice = newMultiSlice ( cfMetaData , <int> , Bound . START , false , value3 , value4 ) ; PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiEq ) . mergeWith ( multiSlice ) ; SortedSet < Slice . Bound > bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , false , value1 , value2 , value3 , value4 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 ) ; multiEq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; Restriction multiIN = newMultiIN ( cfMetaData , <int> , asList ( value3 , value4 ) , asList ( value4 , value5 ) ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiEq ) . mergeWith ( multiIN ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value4 , value5 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value4 , value5 ) ; multiEq = newMultiEq ( cfMetaData , <int> , value1 , value2 ) ; Restriction multiEq2 = newMultiEq ( cfMetaData , <int> , value3 , value4 ) ; restrictions = new PrimaryKeyRestrictionSet ( cfMetaData . comparator , false ) ; restrictions = restrictions . mergeWith ( multiEq ) . mergeWith ( multiEq2 ) ; bounds = restrictions . boundsAsClustering ( Bound . START , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertStartBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; bounds = restrictions . boundsAsClustering ( Bound . END , QueryOptions . DEFAULT ) ; assertEquals ( <int> , bounds . size ( ) ) ; assertEndBound ( get ( bounds , <int> ) , true , value1 , value2 , value3 , value4 ) ; } private static void assertEmptyStart ( Slice . Bound bound ) { assertEquals ( Slice . Bound . BOTTOM , bound ) ; } private static void assertEmptyEnd ( Slice . Bound bound ) { assertEquals ( Slice . Bound . TOP , bound ) ; } private static void assertStartBound ( Slice . Bound bound , boolean isInclusive , ByteBuffer . . . elements ) { assertBound ( bound , true , isInclusive , elements ) ; } private static void assertEndBound ( Slice . Bound bound , boolean isInclusive , ByteBuffer . . . elements ) { assertBound ( bound , false , isInclusive , elements ) ; } private static void assertBound ( Slice . Bound bound , boolean isStart , boolean isInclusive , ByteBuffer . . . elements ) { assertEquals ( <str> , elements . length , bound . size ( ) ) ; assertEquals ( <str> + ( isStart ? <str> : <str> ) + <str> + ( bound . isStart ( ) ? <str> : <str> ) , isStart , bound . isStart ( ) ) ; assertEquals ( <str> , isInclusive , bound . isInclusive ( ) ) ; for ( int i = <int> , m = elements . length ; i < m ; i + + ) { ByteBuffer element = elements [ i ] ; assertTrue ( String . format ( <str> , i , ByteBufferUtil . toInt ( element ) , ByteBufferUtil . toInt ( bound . get ( i ) ) ) , element . equals ( bound . get ( i ) ) ) ; } } private static CFMetaData newCFMetaData ( int numberOfClusteringColumns ) { List < AbstractType < ? > > types = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfClusteringColumns ; i + + ) types . add ( Int32Type . instance ) ; CFMetaData . Builder builder = CFMetaData . Builder . create ( <str> , <str> ) . addPartitionKey ( <str> , Int32Type . instance ) ; for ( int i = <int> ; i < numberOfClusteringColumns ; i + + ) builder . addClusteringColumn ( <str> + i , Int32Type . instance ) ; return builder . build ( ) ; } private static Restriction newSingleEq ( CFMetaData cfMetaData , int index , ByteBuffer value ) { ColumnDefinition columnDef = getClusteringColumnDefinition ( cfMetaData , index ) ; return new SingleColumnRestriction . EQRestriction ( columnDef , toTerm ( value ) ) ; } private static Restriction newMultiEq ( CFMetaData cfMetaData , int firstIndex , ByteBuffer . . . values ) { List < ColumnDefinition > columnDefinitions = new ArrayList < > ( ) ; for ( int i = <int> ; i < values . length ; i + + ) { columnDefinitions . add ( getClusteringColumnDefinition ( cfMetaData , firstIndex + i ) ) ; } return new MultiColumnRestriction . EQRestriction ( columnDefinitions , toMultiItemTerminal ( values ) ) ; } @SafeVarargs private static Restriction newMultiIN ( CFMetaData cfMetaData , int firstIndex , List < ByteBuffer > . . . values ) { List < ColumnDefinition > columnDefinitions = new ArrayList < > ( ) ; List < Term > terms = new ArrayList < > ( ) ; for ( int i = <int> ; i < values . length ; i + + ) { columnDefinitions . add ( getClusteringColumnDefinition ( cfMetaData , firstIndex + i ) ) ; terms . add ( toMultiItemTerminal ( values [ i ] . toArray ( new ByteBuffer [ <int> ] ) ) ) ; } return new MultiColumnRestriction . InRestrictionWithValues ( columnDefinitions , terms ) ; } private static Restriction newSingleIN ( CFMetaData cfMetaData , int index , ByteBuffer . . . values ) { ColumnDefinition columnDef = getClusteringColumnDefinition ( cfMetaData , index ) ; return new SingleColumnRestriction . InRestrictionWithValues ( columnDef , toTerms ( values ) ) ; } private static ColumnDefinition getClusteringColumnDefinition ( CFMetaData cfMetaData , int index ) { return cfMetaData . clusteringColumns ( ) . get ( index ) ; } private static Restriction newSingleSlice ( CFMetaData cfMetaData , int index , Bound bound , boolean inclusive , ByteBuffer value ) { ColumnDefinition columnDef = getClusteringColumnDefinition ( cfMetaData , index ) ; return new SingleColumnRestriction . SliceRestriction ( columnDef , bound , inclusive , toTerm ( value ) ) ; } private static Restriction newMultiSlice ( CFMetaData cfMetaData , int firstIndex , Bound bound , boolean inclusive , ByteBuffer . . . values ) { List < ColumnDefinition > columnDefinitions = new ArrayList < > ( ) ; for ( int i = <int> ; i < values . length ; i + + ) { columnDefinitions . add ( getClusteringColumnDefinition ( cfMetaData , i + firstIndex ) ) ; } return new MultiColumnRestriction . SliceRestriction ( columnDefinitions , bound , inclusive , toMultiItemTerminal ( values ) ) ; } private static MultiItemTerminal toMultiItemTerminal ( ByteBuffer . . . values ) { return new Tuples . Value ( values ) ; } private static Term toTerm ( ByteBuffer value ) { return new Constants . Value ( value ) ; } private static List < Term > toTerms ( ByteBuffer . . . values ) { List < Term > terms = new ArrayList < > ( ) ; for ( ByteBuffer value : values ) terms . add ( toTerm ( value ) ) ; return terms ; } private static < T > T get ( SortedSet < T > set , int i ) { return Iterables . get ( set , i ) ; } } 
