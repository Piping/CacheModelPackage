package org . apache . cassandra . cql3 . statements ; import java . util . * ; import com . google . common . base . Optional ; import com . google . common . base . Strings ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . CFName ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . IndexName ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . exceptions . UnauthorizedException ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . schema . Indexes ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . Event ; public class CreateIndexStatement extends SchemaAlteringStatement { private static final Logger logger = LoggerFactory . getLogger ( CreateIndexStatement . class ) ; private final String indexName ; private final List < IndexTarget . Raw > rawTargets ; private final IndexPropDefs properties ; private final boolean ifNotExists ; public CreateIndexStatement ( CFName name , IndexName indexName , List < IndexTarget . Raw > targets , IndexPropDefs properties , boolean ifNotExists ) { super ( name ) ; this . indexName = indexName . getIdx ( ) ; this . rawTargets = targets ; this . properties = properties ; this . ifNotExists = ifNotExists ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . hasColumnFamilyAccess ( keyspace ( ) , columnFamily ( ) , Permission . ALTER ) ; } public void validate ( ClientState state ) throws RequestValidationException { CFMetaData cfm = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; if ( cfm . isCounter ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . isView ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . isCompactTable ( ) & & ! cfm . isStaticCompactTable ( ) ) throw new InvalidRequestException ( <str> ) ; List < IndexTarget > targets = new ArrayList < > ( rawTargets . size ( ) ) ; for ( IndexTarget . Raw rawTarget : rawTargets ) targets . add ( rawTarget . prepare ( cfm ) ) ; if ( targets . isEmpty ( ) & & ! properties . isCustom ) throw new InvalidRequestException ( <str> ) ; if ( targets . size ( ) > <int> ) validateTargetsForMultiColumnIndex ( targets ) ; for ( IndexTarget target : targets ) { ColumnDefinition cd = cfm . getColumnDefinition ( target . column ) ; if ( cd = = null ) throw new InvalidRequestException ( <str> + target . column ) ; if ( cfm . isCompactTable ( ) & & cd . isPrimaryKeyColumn ( ) ) throw new InvalidRequestException ( <str> ) ; if ( ! cfm . isCompactTable ( ) & & cd . isStatic ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cd . kind = = ColumnDefinition . Kind . PARTITION_KEY & & cfm . getKeyValidatorAsClusteringComparator ( ) . size ( ) = = <int> ) throw new InvalidRequestException ( String . format ( <str> , target . column ) ) ; boolean isMap = cd . type instanceof MapType ; boolean isFrozenCollection = cd . type . isCollection ( ) & & ! cd . type . isMultiCell ( ) ; if ( isFrozenCollection ) { validateForFrozenCollection ( target ) ; } else { validateNotFullIndex ( target ) ; validateIsSimpleIndexIfTargetColumnNotCollection ( cd , target ) ; validateTargetColumnIsMapIfIndexInvolvesKeys ( isMap , target ) ; } } if ( ! Strings . isNullOrEmpty ( indexName ) ) { if ( Schema . instance . getKSMetaData ( keyspace ( ) ) . existingIndexNames ( null ) . contains ( indexName ) ) { if ( ifNotExists ) return ; else throw new InvalidRequestException ( String . format ( <str> , indexName ) ) ; } } properties . validate ( ) ; } private void validateForFrozenCollection ( IndexTarget target ) throws InvalidRequestException { if ( target . type ! = IndexTarget . Type . FULL ) throw new InvalidRequestException ( String . format ( <str> + <str> , target . type , target . column ) ) ; } private void validateNotFullIndex ( IndexTarget target ) throws InvalidRequestException { if ( target . type = = IndexTarget . Type . FULL ) throw new InvalidRequestException ( <str> ) ; } private void validateIsSimpleIndexIfTargetColumnNotCollection ( ColumnDefinition cd , IndexTarget target ) throws InvalidRequestException { if ( ! cd . type . isCollection ( ) & & target . type ! = IndexTarget . Type . SIMPLE ) throw new InvalidRequestException ( String . format ( <str> + <str> , target . type . toString ( ) , target . column ) ) ; } private void validateTargetColumnIsMapIfIndexInvolvesKeys ( boolean isMap , IndexTarget target ) throws InvalidRequestException { if ( target . type = = IndexTarget . Type . KEYS | | target . type = = IndexTarget . Type . KEYS_AND_VALUES ) { if ( ! isMap ) throw new InvalidRequestException ( String . format ( <str> , target . type , target . column ) ) ; } } private void validateTargetsForMultiColumnIndex ( List < IndexTarget > targets ) { if ( ! properties . isCustom ) throw new InvalidRequestException ( <str> ) ; Set < ColumnIdentifier > columns = new HashSet < > ( ) ; for ( IndexTarget target : targets ) if ( ! columns . add ( target . column ) ) throw new InvalidRequestException ( <str> + target . column + <str> ) ; } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace ( ) , columnFamily ( ) ) . copy ( ) ; List < IndexTarget > targets = new ArrayList < > ( rawTargets . size ( ) ) ; for ( IndexTarget . Raw rawTarget : rawTargets ) targets . add ( rawTarget . prepare ( cfm ) ) ; String acceptedName = indexName ; if ( Strings . isNullOrEmpty ( acceptedName ) ) { acceptedName = Indexes . getAvailableIndexName ( keyspace ( ) , columnFamily ( ) , targets . size ( ) = = <int> ? targets . get ( <int> ) . column . toString ( ) : null ) ; } if ( Schema . instance . getKSMetaData ( keyspace ( ) ) . existingIndexNames ( null ) . contains ( acceptedName ) ) { if ( ifNotExists ) return null ; else throw new InvalidRequestException ( String . format ( <str> , acceptedName ) ) ; } IndexMetadata . Kind kind ; Map < String , String > indexOptions ; if ( properties . isCustom ) { kind = IndexMetadata . Kind . CUSTOM ; indexOptions = properties . getOptions ( ) ; } else { indexOptions = Collections . emptyMap ( ) ; kind = cfm . isCompound ( ) ? IndexMetadata . Kind . COMPOSITES : IndexMetadata . Kind . KEYS ; } IndexMetadata index = IndexMetadata . fromIndexTargets ( cfm , targets , acceptedName , kind , indexOptions ) ; Optional < IndexMetadata > existingIndex = Iterables . tryFind ( cfm . getIndexes ( ) , existing - > existing . equalsWithoutName ( index ) ) ; if ( existingIndex . isPresent ( ) ) throw new InvalidRequestException ( String . format ( <str> , index . name , existingIndex . get ( ) . name ) ) ; logger . trace ( <str> , indexName ) ; cfm . indexes ( cfm . getIndexes ( ) . with ( index ) ) ; MigrationManager . announceColumnFamilyUpdate ( cfm , false , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , keyspace ( ) , columnFamily ( ) ) ; } } 
