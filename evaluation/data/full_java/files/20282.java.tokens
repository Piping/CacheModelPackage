package io . netty . channel . oio ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . FileRegion ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . socket . ChannelInputShutdownEvent ; import io . netty . util . internal . StringUtil ; import java . io . IOException ; public abstract class AbstractOioByteChannel extends AbstractOioChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( false ) ; private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( FileRegion . class ) + <str> ; private volatile boolean inputShutdown ; protected AbstractOioByteChannel ( Channel parent ) { super ( parent ) ; } protected boolean isInputShutdown ( ) { return inputShutdown ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } protected boolean checkInputShutdown ( ) { if ( inputShutdown ) { try { Thread . sleep ( SO_TIMEOUT ) ; } catch ( InterruptedException e ) { } return true ; } return false ; } void setInputShutdown ( ) { inputShutdown = true ; } private void closeOnRead ( ChannelPipeline pipeline ) { setInputShutdown ( ) ; if ( isOpen ( ) ) { if ( Boolean . TRUE . equals ( config ( ) . getOption ( ChannelOption . ALLOW_HALF_CLOSURE ) ) ) { pipeline . fireUserEventTriggered ( ChannelInputShutdownEvent . INSTANCE ) ; } else { unsafe ( ) . close ( unsafe ( ) . voidPromise ( ) ) ; } } } private void handleReadException ( ChannelPipeline pipeline , ByteBuf byteBuf , Throwable cause , boolean close , RecvByteBufAllocator . Handle allocHandle ) { if ( byteBuf ! = null ) { if ( byteBuf . isReadable ( ) ) { setReadPending ( false ) ; pipeline . fireChannelRead ( byteBuf ) ; } else { byteBuf . release ( ) ; } } allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; pipeline . fireExceptionCaught ( cause ) ; if ( close | | cause instanceof IOException ) { closeOnRead ( pipeline ) ; } } @Override protected void doRead ( ) { final ChannelConfig config = config ( ) ; if ( isInputShutdown ( ) | | ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { return ; } setReadPending ( false ) ; final ChannelPipeline pipeline = pipeline ( ) ; final ByteBufAllocator allocator = config . getAllocator ( ) ; final RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; ByteBuf byteBuf = null ; boolean read = false ; try { byteBuf = allocHandle . allocate ( allocator ) ; do { allocHandle . lastBytesRead ( doReadBytes ( byteBuf ) ) ; if ( allocHandle . lastBytesRead ( ) < = <int> ) { if ( ! read ) { byteBuf . release ( ) ; byteBuf = null ; } break ; } read = true ; final int available = available ( ) ; if ( available < = <int> ) { break ; } if ( ! byteBuf . isWritable ( ) ) { final int capacity = byteBuf . capacity ( ) ; final int maxCapacity = byteBuf . maxCapacity ( ) ; if ( capacity = = maxCapacity ) { allocHandle . incMessagesRead ( <int> ) ; read = false ; pipeline . fireChannelRead ( byteBuf ) ; byteBuf = allocHandle . allocate ( allocator ) ; } else { final int writerIndex = byteBuf . writerIndex ( ) ; if ( writerIndex + available > maxCapacity ) { byteBuf . capacity ( maxCapacity ) ; } else { byteBuf . ensureWritable ( available ) ; } } } } while ( allocHandle . continueReading ( ) ) ; if ( read ) { pipeline . fireChannelRead ( byteBuf ) ; byteBuf = null ; } allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( allocHandle . lastBytesRead ( ) < <int> ) { closeOnRead ( pipeline ) ; } } catch ( Throwable t ) { handleReadException ( pipeline , byteBuf , t , allocHandle . lastBytesRead ( ) < <int> , allocHandle ) ; } finally { if ( allocHandle . lastBytesRead ( ) = = <int> & & isActive ( ) ) { read ( ) ; } } } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { break ; } if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; int readableBytes = buf . readableBytes ( ) ; while ( readableBytes > <int> ) { doWriteBytes ( buf ) ; int newReadableBytes = buf . readableBytes ( ) ; in . progress ( readableBytes - newReadableBytes ) ; readableBytes = newReadableBytes ; } in . remove ( ) ; } else if ( msg instanceof FileRegion ) { FileRegion region = ( FileRegion ) msg ; long transfered = region . transfered ( ) ; doWriteFileRegion ( region ) ; in . progress ( region . transfered ( ) - transfered ) ; in . remove ( ) ; } else { in . remove ( new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) ) ) ; } } } @Override protected final Object filterOutboundMessage ( Object msg ) throws Exception { if ( msg instanceof ByteBuf | | msg instanceof FileRegion ) { return msg ; } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } protected abstract int available ( ) ; protected abstract int doReadBytes ( ByteBuf buf ) throws Exception ; protected abstract void doWriteBytes ( ByteBuf buf ) throws Exception ; protected abstract void doWriteFileRegion ( FileRegion region ) throws Exception ; } 
