package io . netty . handler . codec . http ; import io . netty . handler . codec . DefaultHeaders ; import io . netty . handler . codec . ValueConverter ; import io . netty . util . HashingStrategy ; import io . netty . handler . codec . Headers ; import io . netty . util . internal . StringUtil ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import static io . netty . util . AsciiString . CASE_INSENSITIVE_HASHER ; import static io . netty . util . internal . StringUtil . COMMA ; public class CombinedHttpHeaders extends DefaultHttpHeaders { public CombinedHttpHeaders ( boolean validate ) { super ( new CombinedHttpHeadersImpl ( CASE_INSENSITIVE_HASHER , valueConverter ( validate ) , nameValidator ( validate ) ) ) ; } private static final class CombinedHttpHeadersImpl extends DefaultHeaders < CharSequence , CharSequence , CombinedHttpHeadersImpl > { private static final int VALUE_LENGTH_ESTIMATE = <int> ; private CsvValueEscaper < Object > objectEscaper ; private CsvValueEscaper < CharSequence > charSequenceEscaper ; private CsvValueEscaper < Object > objectEscaper ( ) { if ( objectEscaper = = null ) { objectEscaper = new CsvValueEscaper < Object > ( ) { @Override public CharSequence escape ( Object value ) { return StringUtil . escapeCsv ( valueConverter ( ) . convertObject ( value ) ) ; } } ; } return objectEscaper ; } private CsvValueEscaper < CharSequence > charSequenceEscaper ( ) { if ( charSequenceEscaper = = null ) { charSequenceEscaper = new CsvValueEscaper < CharSequence > ( ) { @Override public CharSequence escape ( CharSequence value ) { return StringUtil . escapeCsv ( value ) ; } } ; } return charSequenceEscaper ; } public CombinedHttpHeadersImpl ( HashingStrategy < CharSequence > nameHashingStrategy , ValueConverter < CharSequence > valueConverter , io . netty . handler . codec . DefaultHeaders . NameValidator < CharSequence > nameValidator ) { super ( nameHashingStrategy , valueConverter , nameValidator ) ; } @Override public CombinedHttpHeadersImpl add ( Headers < ? extends CharSequence , ? extends CharSequence , ? > headers ) { if ( headers = = this ) { throw new IllegalArgumentException ( <str> ) ; } if ( headers instanceof CombinedHttpHeadersImpl ) { if ( isEmpty ( ) ) { addImpl ( headers ) ; } else { for ( Map . Entry < ? extends CharSequence , ? extends CharSequence > header : headers ) { addEscapedValue ( header . getKey ( ) , header . getValue ( ) ) ; } } } else { for ( Map . Entry < ? extends CharSequence , ? extends CharSequence > header : headers ) { add ( header . getKey ( ) , header . getValue ( ) ) ; } } return this ; } @Override public CombinedHttpHeadersImpl set ( Headers < ? extends CharSequence , ? extends CharSequence , ? > headers ) { if ( headers = = this ) { return this ; } clear ( ) ; return add ( headers ) ; } @Override public CombinedHttpHeadersImpl setAll ( Headers < ? extends CharSequence , ? extends CharSequence , ? > headers ) { if ( headers = = this ) { return this ; } for ( CharSequence key : headers . names ( ) ) { remove ( key ) ; } return add ( headers ) ; } @Override public CombinedHttpHeadersImpl add ( CharSequence name , CharSequence value ) { return addEscapedValue ( name , StringUtil . escapeCsv ( value ) ) ; } @Override public CombinedHttpHeadersImpl add ( CharSequence name , CharSequence . . . values ) { return addEscapedValue ( name , commaSeparate ( charSequenceEscaper ( ) , values ) ) ; } @Override public CombinedHttpHeadersImpl add ( CharSequence name , Iterable < ? extends CharSequence > values ) { return addEscapedValue ( name , commaSeparate ( charSequenceEscaper ( ) , values ) ) ; } @Override public CombinedHttpHeadersImpl addObject ( CharSequence name , Iterable < ? > values ) { return addEscapedValue ( name , commaSeparate ( objectEscaper ( ) , values ) ) ; } @Override public CombinedHttpHeadersImpl addObject ( CharSequence name , Object . . . values ) { return addEscapedValue ( name , commaSeparate ( objectEscaper ( ) , values ) ) ; } @Override public CombinedHttpHeadersImpl set ( CharSequence name , CharSequence . . . values ) { super . set ( name , commaSeparate ( charSequenceEscaper ( ) , values ) ) ; return this ; } @Override public CombinedHttpHeadersImpl set ( CharSequence name , Iterable < ? extends CharSequence > values ) { super . set ( name , commaSeparate ( charSequenceEscaper ( ) , values ) ) ; return this ; } @Override public CombinedHttpHeadersImpl setObject ( CharSequence name , Object . . . values ) { super . set ( name , commaSeparate ( objectEscaper ( ) , values ) ) ; return this ; } @Override public CombinedHttpHeadersImpl setObject ( CharSequence name , Iterable < ? > values ) { super . set ( name , commaSeparate ( objectEscaper ( ) , values ) ) ; return this ; } private CombinedHttpHeadersImpl addEscapedValue ( CharSequence name , CharSequence escapedValue ) { CharSequence currentValue = super . get ( name ) ; if ( currentValue = = null ) { super . add ( name , escapedValue ) ; } else { super . set ( name , commaSeparateEscapedValues ( currentValue , escapedValue ) ) ; } return this ; } private static < T > CharSequence commaSeparate ( CsvValueEscaper < T > escaper , T . . . values ) { StringBuilder sb = new StringBuilder ( values . length * VALUE_LENGTH_ESTIMATE ) ; if ( values . length > <int> ) { int end = values . length - <int> ; for ( int i = <int> ; i < end ; i + + ) { sb . append ( escaper . escape ( values [ i ] ) ) . append ( COMMA ) ; } sb . append ( escaper . escape ( values [ end ] ) ) ; } return sb ; } private static < T > CharSequence commaSeparate ( CsvValueEscaper < T > escaper , Iterable < ? extends T > values ) { @SuppressWarnings ( <str> ) final StringBuilder sb = values instanceof Collection ? new StringBuilder ( ( ( Collection ) values ) . size ( ) * VALUE_LENGTH_ESTIMATE ) : new StringBuilder ( ) ; Iterator < ? extends T > iterator = values . iterator ( ) ; if ( iterator . hasNext ( ) ) { T next = iterator . next ( ) ; while ( iterator . hasNext ( ) ) { sb . append ( escaper . escape ( next ) ) . append ( COMMA ) ; next = iterator . next ( ) ; } sb . append ( escaper . escape ( next ) ) ; } return sb ; } private CharSequence commaSeparateEscapedValues ( CharSequence currentValue , CharSequence value ) { return new StringBuilder ( currentValue . length ( ) + <int> + value . length ( ) ) . append ( currentValue ) . append ( COMMA ) . append ( value ) ; } private interface CsvValueEscaper < T > { CharSequence escape ( T value ) ; } } } 
