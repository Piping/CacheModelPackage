package org . eclipse . debug . examples . internal . memory . engine ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Random ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . examples . internal . memory . core . SampleDebugTarget ; import org . eclipse . debug . examples . internal . memory . core . SampleMemoryBlock ; import org . eclipse . debug . examples . internal . memory . core . SampleStackFrame ; import org . eclipse . debug . examples . internal . memory . core . SampleThread ; public class SampleEngine { Random fRandom = new Random ( ) ; byte [ ] fMemory ; Hashtable < BigInteger , SampleMemoryUnit > memoryBlockTable ; Hashtable < String , BigInteger > expressionAddressTable = new Hashtable < String , BigInteger > ( ) ; Hashtable < SampleDebugTarget , Object > threadTable = new Hashtable < SampleDebugTarget , Object > ( ) ; Hashtable < SampleThread , Object > stackframeTable = new Hashtable < SampleThread , Object > ( ) ; Random random = new Random ( ) ; synchronized public MemoryByte [ ] getBytesFromAddress ( BigInteger address , long length ) throws RuntimeException { if ( memoryBlockTable = = null ) { memoryBlockTable = new Hashtable < BigInteger , SampleMemoryUnit > ( ) ; byte [ ] bytes = new byte [ ( int ) length * getAddressableSize ( ) ] ; BigInteger addressKey = address ; random . nextBytes ( bytes ) ; for ( int i = <int> ; i < bytes . length ; i = i + getAddressableSize ( ) ) { addressKey = addressKey . add ( BigInteger . valueOf ( <int> ) ) ; MemoryByte [ ] byteUnit = new MemoryByte [ getAddressableSize ( ) ] ; for ( int j = <int> ; j < getAddressableSize ( ) ; j + + ) { MemoryByte oneByte = new MemoryByte ( bytes [ i + j ] ) ; oneByte . setBigEndian ( isBigEndian ( addressKey ) ) ; oneByte . setWritable ( isWritable ( addressKey ) ) ; oneByte . setReadable ( isReadable ( addressKey ) ) ; byteUnit [ j ] = oneByte ; } SampleMemoryUnit unit = new SampleMemoryUnit ( byteUnit ) ; memoryBlockTable . put ( addressKey , unit ) ; } } MemoryByte [ ] returnBytes = new MemoryByte [ ( int ) length * getAddressableSize ( ) ] ; BigInteger addressKey ; for ( int i = <int> ; i < returnBytes . length ; i = i + getAddressableSize ( ) ) { addressKey = address . add ( BigInteger . valueOf ( i / getAddressableSize ( ) ) ) ; SampleMemoryUnit temp = ( memoryBlockTable . get ( addressKey ) ) ; if ( temp = = null ) { byte [ ] x = new byte [ getAddressableSize ( ) ] ; random . nextBytes ( x ) ; byte flag = <int> ; flag | = MemoryByte . READABLE ; flag | = MemoryByte . ENDIANESS_KNOWN ; flag | = MemoryByte . WRITABLE ; MemoryByte [ ] byteUnit = new MemoryByte [ getAddressableSize ( ) ] ; for ( int j = <int> ; j < getAddressableSize ( ) ; j + + ) { MemoryByte oneByte = new MemoryByte ( x [ j ] , flag ) ; byteUnit [ j ] = oneByte ; byteUnit [ j ] . setBigEndian ( isBigEndian ( addressKey ) ) ; byteUnit [ j ] . setWritable ( isWritable ( addressKey ) ) ; byteUnit [ j ] . setReadable ( isReadable ( addressKey ) ) ; returnBytes [ i + j ] = oneByte ; } SampleMemoryUnit unit = new SampleMemoryUnit ( byteUnit ) ; memoryBlockTable . put ( addressKey , unit ) ; } else { MemoryByte [ ] bytes = temp . getBytes ( ) ; for ( int j = <int> ; j < bytes . length ; j + + ) { MemoryByte oneByte = new MemoryByte ( bytes [ j ] . getValue ( ) , bytes [ j ] . getFlags ( ) ) ; returnBytes [ i + j ] = oneByte ; returnBytes [ i + j ] . setBigEndian ( isBigEndian ( addressKey ) ) ; returnBytes [ i + j ] . setWritable ( isWritable ( addressKey ) ) ; } } } return returnBytes ; } public void resume ( ) { changeValue ( ) ; } synchronized public void changeValue ( ) { if ( memoryBlockTable = = null ) { return ; } Enumeration < BigInteger > enumeration = memoryBlockTable . keys ( ) ; long randomChange = random . nextInt ( <int> ) ; while ( randomChange < = <int> ) { randomChange = random . nextInt ( <int> ) ; } while ( enumeration . hasMoreElements ( ) ) { BigInteger key = enumeration . nextElement ( ) ; if ( key . remainder ( BigInteger . valueOf ( randomChange ) ) . equals ( BigInteger . valueOf ( <int> ) ) ) { byte [ ] x = new byte [ getAddressableSize ( ) ] ; random . nextBytes ( x ) ; MemoryByte unitBytes [ ] = new MemoryByte [ getAddressableSize ( ) ] ; for ( int i = <int> ; i < x . length ; i + + ) { MemoryByte oneByte = new MemoryByte ( ) ; oneByte . setValue ( x [ i ] ) ; oneByte . setReadable ( true ) ; oneByte . setChanged ( true ) ; oneByte . setHistoryKnown ( true ) ; oneByte . setBigEndian ( isBigEndian ( key ) ) ; oneByte . setWritable ( isWritable ( key ) ) ; oneByte . setReadable ( isReadable ( key ) ) ; unitBytes [ i ] = oneByte ; } SampleMemoryUnit unit = new SampleMemoryUnit ( unitBytes ) ; memoryBlockTable . put ( key , unit ) ; } else { SampleMemoryUnit unit = memoryBlockTable . get ( key ) ; MemoryByte [ ] bytes = unit . getBytes ( ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { bytes [ i ] . setChanged ( false ) ; bytes [ i ] . setHistoryKnown ( true ) ; } unit . setBytes ( bytes ) ; memoryBlockTable . put ( key , unit ) ; } } } public BigInteger evaluateExpression ( String expression , Object evalContext ) { BigInteger expAddress = expressionAddressTable . get ( expression ) ; if ( expAddress = = null ) { int address = random . nextInt ( ) ; if ( address < <int> ) { address = address * - <int> ; } expAddress = BigInteger . valueOf ( address ) ; expressionAddressTable . put ( expression , expAddress ) ; } return expAddress ; } public boolean supportsStorageRetrieval ( ) { return true ; } public void setValue ( BigInteger address , byte [ ] bytes ) throws RuntimeException { BigInteger convertedAddress = address ; for ( int i = <int> ; i < bytes . length ; i = i + getAddressableSize ( ) ) { SampleMemoryUnit unit = memoryBlockTable . get ( convertedAddress ) ; MemoryByte [ ] unitBytes = unit . getBytes ( ) ; for ( int j = <int> ; j < unitBytes . length ; j + + ) { unitBytes [ j ] . setValue ( bytes [ i + j ] ) ; unitBytes [ j ] . setChanged ( true ) ; unitBytes [ j ] . setHistoryKnown ( true ) ; } convertedAddress = convertedAddress . add ( BigInteger . valueOf ( <int> ) ) ; } } public int getAddressableSize ( ) { return <int> ; } public boolean isBigEndian ( BigInteger address ) { BigInteger boundary = new BigInteger ( <str> , <int> ) ; if ( address . compareTo ( boundary ) > <int> ) { return true ; } return false ; } public boolean isWritable ( BigInteger address ) { BigInteger boundary = new BigInteger ( <str> , <int> ) ; BigInteger boundaryEnd = new BigInteger ( <str> , <int> ) ; if ( address . compareTo ( boundary ) > <int> & & address . compareTo ( boundaryEnd ) < <int> ) { return false ; } boundary = new BigInteger ( <str> , <int> ) ; boundaryEnd = new BigInteger ( <str> , <int> ) ; if ( address . compareTo ( boundary ) > <int> & & address . compareTo ( boundaryEnd ) < <int> ) { return false ; } return true ; } public boolean isReadable ( BigInteger address ) { BigInteger boundary = new BigInteger ( <str> , <int> ) ; BigInteger boundaryEnd = new BigInteger ( <str> , <int> ) ; if ( address . compareTo ( boundary ) > <int> & & address . compareTo ( boundaryEnd ) < <int> ) { return false ; } return true ; } public SampleThread [ ] getThreads ( SampleDebugTarget target ) { Object thread = threadTable . get ( target ) ; if ( thread = = null ) { thread = new SampleThread ( target ) ; threadTable . put ( target , thread ) ; } return new SampleThread [ ] { ( SampleThread ) thread } ; } public SampleStackFrame [ ] getStackframes ( SampleThread thread ) { Object stackframes = stackframeTable . get ( thread ) ; if ( stackframes = = null ) { stackframes = createStackframes ( thread ) ; stackframeTable . put ( thread , stackframes ) ; } return ( SampleStackFrame [ ] ) stackframes ; } private SampleStackFrame [ ] createStackframes ( SampleThread thread ) { SampleStackFrame [ ] stackframes = new SampleStackFrame [ <int> ] ; stackframes [ <int> ] = new SampleStackFrame ( thread , <str> ) ; stackframes [ <int> ] = new SampleStackFrame ( thread , <str> ) ; return stackframes ; } public boolean suppostsBaseAddressModification ( SampleMemoryBlock mb ) { return false ; } public void setBaseAddress ( SampleMemoryBlock mb , BigInteger address ) throws CoreException { } public boolean supportsValueModification ( SampleMemoryBlock mb ) { return true ; } public int getAddressSize ( ) throws CoreException { return <int> ; } } 
