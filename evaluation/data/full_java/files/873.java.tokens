package org . apache . cassandra . scheduler ; import java . util . Map ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeoutException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . RequestSchedulerOptions ; import org . cliffc . high_scale_lib . NonBlockingHashMap ; public class RoundRobinScheduler implements IRequestScheduler { private static final Logger logger = LoggerFactory . getLogger ( RoundRobinScheduler . class ) ; private final NonBlockingHashMap < String , WeightedQueue > queues ; private final Semaphore taskCount ; private final Semaphore queueSize = new Semaphore ( <int> , false ) ; private final int defaultWeight ; private final Map < String , Integer > weights ; public RoundRobinScheduler ( RequestSchedulerOptions options ) { defaultWeight = options . default_weight ; weights = options . weights ; taskCount = new Semaphore ( options . throttle_limit - <int> ) ; queues = new NonBlockingHashMap < String , WeightedQueue > ( ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { while ( true ) { schedule ( ) ; } } } ; Thread scheduler = new Thread ( runnable , <str> ) ; scheduler . start ( ) ; logger . info ( <str> ) ; } public void queue ( Thread t , String id , long timeoutMS ) throws TimeoutException { WeightedQueue weightedQueue = getWeightedQueue ( id ) ; try { queueSize . release ( ) ; try { weightedQueue . put ( t , timeoutMS ) ; } catch ( TimeoutException | InterruptedException e ) { queueSize . acquireUninterruptibly ( ) ; throw e ; } } catch ( InterruptedException e ) { throw new RuntimeException ( <str> , e ) ; } } public void release ( ) { taskCount . release ( ) ; } private void schedule ( ) { queueSize . acquireUninterruptibly ( ) ; for ( Map . Entry < String , WeightedQueue > request : queues . entrySet ( ) ) { WeightedQueue queue = request . getValue ( ) ; for ( int i = <int> ; i < queue . weight ; i + + ) { Thread t = queue . poll ( ) ; if ( t = = null ) break ; else { taskCount . acquireUninterruptibly ( ) ; queueSize . acquireUninterruptibly ( ) ; } } } queueSize . release ( ) ; } private WeightedQueue getWeightedQueue ( String id ) { WeightedQueue weightedQueue = queues . get ( id ) ; if ( weightedQueue ! = null ) return weightedQueue ; WeightedQueue maybenew = new WeightedQueue ( id , getWeight ( id ) ) ; weightedQueue = queues . putIfAbsent ( id , maybenew ) ; if ( weightedQueue = = null ) { return maybenew ; } return weightedQueue ; } Semaphore getTaskCount ( ) { return taskCount ; } private int getWeight ( String weightingVar ) { return ( weights ! = null & & weights . containsKey ( weightingVar ) ) ? weights . get ( weightingVar ) : defaultWeight ; } } 
