package com . badlogic . gdx . maps . tiled ; import com . badlogic . gdx . assets . AssetDescriptor ; import com . badlogic . gdx . assets . AssetLoaderParameters ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . assets . loaders . FileHandleResolver ; import com . badlogic . gdx . assets . loaders . SynchronousAssetLoader ; import com . badlogic . gdx . assets . loaders . resolvers . InternalFileHandleResolver ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . maps . ImageResolver ; import com . badlogic . gdx . maps . ImageResolver . AssetManagerImageResolver ; import com . badlogic . gdx . maps . ImageResolver . DirectImageResolver ; import com . badlogic . gdx . maps . MapProperties ; import com . badlogic . gdx . maps . tiled . TiledMapTileLayer . Cell ; import com . badlogic . gdx . maps . tiled . tiles . AnimatedTiledMapTile ; import com . badlogic . gdx . maps . tiled . tiles . StaticTiledMapTile ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . XmlReader ; import com . badlogic . gdx . utils . XmlReader . Element ; import java . io . IOException ; import java . util . StringTokenizer ; public class TideMapLoader extends SynchronousAssetLoader < TiledMap , TideMapLoader . Parameters > { public static class Parameters extends AssetLoaderParameters < TiledMap > { } private XmlReader xml = new XmlReader ( ) ; private Element root ; public TideMapLoader ( ) { super ( new InternalFileHandleResolver ( ) ) ; } public TideMapLoader ( FileHandleResolver resolver ) { super ( resolver ) ; } public TiledMap load ( String fileName ) { try { FileHandle tideFile = resolve ( fileName ) ; root = xml . parse ( tideFile ) ; ObjectMap < String , Texture > textures = new ObjectMap < String , Texture > ( ) ; for ( FileHandle textureFile : loadTileSheets ( root , tideFile ) ) { textures . put ( textureFile . path ( ) , new Texture ( textureFile ) ) ; } DirectImageResolver imageResolver = new DirectImageResolver ( textures ) ; TiledMap map = loadMap ( root , tideFile , imageResolver ) ; map . setOwnedResources ( textures . values ( ) . toArray ( ) ) ; return map ; } catch ( IOException e ) { throw new GdxRuntimeException ( <str> + fileName + <str> , e ) ; } } @Override public TiledMap load ( AssetManager assetManager , String fileName , FileHandle tideFile , Parameters parameter ) { try { return loadMap ( root , tideFile , new AssetManagerImageResolver ( assetManager ) ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + fileName + <str> , e ) ; } } @Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle tmxFile , Parameters parameter ) { Array < AssetDescriptor > dependencies = new Array < AssetDescriptor > ( ) ; try { root = xml . parse ( tmxFile ) ; for ( FileHandle image : loadTileSheets ( root , tmxFile ) ) { dependencies . add ( new AssetDescriptor ( image . path ( ) , Texture . class ) ) ; } return dependencies ; } catch ( IOException e ) { throw new GdxRuntimeException ( <str> + fileName + <str> , e ) ; } } private TiledMap loadMap ( Element root , FileHandle tmxFile , ImageResolver imageResolver ) { TiledMap map = new TiledMap ( ) ; Element properties = root . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( map . getProperties ( ) , properties ) ; } Element tilesheets = root . getChildByName ( <str> ) ; for ( Element tilesheet : tilesheets . getChildrenByName ( <str> ) ) { loadTileSheet ( map , tilesheet , tmxFile , imageResolver ) ; } Element layers = root . getChildByName ( <str> ) ; for ( Element layer : layers . getChildrenByName ( <str> ) ) { loadLayer ( map , layer ) ; } return map ; } private Array < FileHandle > loadTileSheets ( Element root , FileHandle tideFile ) throws IOException { Array < FileHandle > images = new Array < FileHandle > ( ) ; Element tilesheets = root . getChildByName ( <str> ) ; for ( Element tileset : tilesheets . getChildrenByName ( <str> ) ) { Element imageSource = tileset . getChildByName ( <str> ) ; FileHandle image = getRelativeFileHandle ( tideFile , imageSource . getText ( ) ) ; images . add ( image ) ; } return images ; } private void loadTileSheet ( TiledMap map , Element element , FileHandle tideFile , ImageResolver imageResolver ) { if ( element . getName ( ) . equals ( <str> ) ) { String id = element . getAttribute ( <str> ) ; String description = element . getChildByName ( <str> ) . getText ( ) ; String imageSource = element . getChildByName ( <str> ) . getText ( ) ; Element alignment = element . getChildByName ( <str> ) ; String sheetSize = alignment . getAttribute ( <str> ) ; String tileSize = alignment . getAttribute ( <str> ) ; String margin = alignment . getAttribute ( <str> ) ; String spacing = alignment . getAttribute ( <str> ) ; String [ ] sheetSizeParts = sheetSize . split ( <str> ) ; int sheetSizeX = Integer . parseInt ( sheetSizeParts [ <int> ] ) ; int sheetSizeY = Integer . parseInt ( sheetSizeParts [ <int> ] ) ; String [ ] tileSizeParts = tileSize . split ( <str> ) ; int tileSizeX = Integer . parseInt ( tileSizeParts [ <int> ] ) ; int tileSizeY = Integer . parseInt ( tileSizeParts [ <int> ] ) ; String [ ] marginParts = margin . split ( <str> ) ; int marginX = Integer . parseInt ( marginParts [ <int> ] ) ; int marginY = Integer . parseInt ( marginParts [ <int> ] ) ; String [ ] spacingParts = margin . split ( <str> ) ; int spacingX = Integer . parseInt ( spacingParts [ <int> ] ) ; int spacingY = Integer . parseInt ( spacingParts [ <int> ] ) ; FileHandle image = getRelativeFileHandle ( tideFile , imageSource ) ; TextureRegion texture = imageResolver . getImage ( image . path ( ) ) ; TiledMapTileSets tilesets = map . getTileSets ( ) ; int firstgid = <int> ; for ( TiledMapTileSet tileset : tilesets ) { firstgid + = tileset . size ( ) ; } TiledMapTileSet tileset = new TiledMapTileSet ( ) ; tileset . setName ( id ) ; tileset . getProperties ( ) . put ( <str> , firstgid ) ; int gid = firstgid ; int stopWidth = texture . getRegionWidth ( ) - tileSizeX ; int stopHeight = texture . getRegionHeight ( ) - tileSizeY ; for ( int y = marginY ; y < = stopHeight ; y + = tileSizeY + spacingY ) { for ( int x = marginX ; x < = stopWidth ; x + = tileSizeX + spacingX ) { TiledMapTile tile = new StaticTiledMapTile ( new TextureRegion ( texture , x , y , tileSizeX , tileSizeY ) ) ; tile . setId ( gid ) ; tileset . putTile ( gid + + , tile ) ; } } Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( tileset . getProperties ( ) , properties ) ; } tilesets . addTileSet ( tileset ) ; } } private void loadLayer ( TiledMap map , Element element ) { if ( element . getName ( ) . equals ( <str> ) ) { String id = element . getAttribute ( <str> ) ; String visible = element . getAttribute ( <str> ) ; Element dimensions = element . getChildByName ( <str> ) ; String layerSize = dimensions . getAttribute ( <str> ) ; String tileSize = dimensions . getAttribute ( <str> ) ; String [ ] layerSizeParts = layerSize . split ( <str> ) ; int layerSizeX = Integer . parseInt ( layerSizeParts [ <int> ] ) ; int layerSizeY = Integer . parseInt ( layerSizeParts [ <int> ] ) ; String [ ] tileSizeParts = tileSize . split ( <str> ) ; int tileSizeX = Integer . parseInt ( tileSizeParts [ <int> ] ) ; int tileSizeY = Integer . parseInt ( tileSizeParts [ <int> ] ) ; TiledMapTileLayer layer = new TiledMapTileLayer ( layerSizeX , layerSizeY , tileSizeX , tileSizeY ) ; layer . setName ( id ) ; layer . setVisible ( visible . equalsIgnoreCase ( <str> ) ) ; Element tileArray = element . getChildByName ( <str> ) ; Array < Element > rows = tileArray . getChildrenByName ( <str> ) ; TiledMapTileSets tilesets = map . getTileSets ( ) ; TiledMapTileSet currentTileSet = null ; int firstgid = <int> ; int x , y ; for ( int row = <int> , rowCount = rows . size ; row < rowCount ; row + + ) { Element currentRow = rows . get ( row ) ; y = rowCount - <int> - row ; x = <int> ; for ( int child = <int> , childCount = currentRow . getChildCount ( ) ; child < childCount ; child + + ) { Element currentChild = currentRow . getChild ( child ) ; String name = currentChild . getName ( ) ; if ( name . equals ( <str> ) ) { currentTileSet = tilesets . getTileSet ( currentChild . getAttribute ( <str> ) ) ; firstgid = currentTileSet . getProperties ( ) . get ( <str> , Integer . class ) ; } else if ( name . equals ( <str> ) ) { x + = currentChild . getIntAttribute ( <str> ) ; } else if ( name . equals ( <str> ) ) { Cell cell = new Cell ( ) ; cell . setTile ( currentTileSet . getTile ( firstgid + currentChild . getIntAttribute ( <str> ) ) ) ; layer . setCell ( x + + , y , cell ) ; } else if ( name . equals ( <str> ) ) { int interval = currentChild . getInt ( <str> ) ; Element frames = currentChild . getChildByName ( <str> ) ; Array < StaticTiledMapTile > frameTiles = new Array < StaticTiledMapTile > ( ) ; for ( int frameChild = <int> , frameChildCount = frames . getChildCount ( ) ; frameChild < frameChildCount ; frameChild + + ) { Element frame = frames . getChild ( frameChild ) ; String frameName = frame . getName ( ) ; if ( frameName . equals ( <str> ) ) { currentTileSet = tilesets . getTileSet ( frame . getAttribute ( <str> ) ) ; firstgid = currentTileSet . getProperties ( ) . get ( <str> , Integer . class ) ; } else if ( frameName . equals ( <str> ) ) { frameTiles . add ( ( StaticTiledMapTile ) currentTileSet . getTile ( firstgid + frame . getIntAttribute ( <str> ) ) ) ; } } Cell cell = new Cell ( ) ; cell . setTile ( new AnimatedTiledMapTile ( interval / <int> f , frameTiles ) ) ; layer . setCell ( x + + , y , cell ) ; } } } Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( layer . getProperties ( ) , properties ) ; } map . getLayers ( ) . add ( layer ) ; } } private void loadProperties ( MapProperties properties , Element element ) { if ( element . getName ( ) . equals ( <str> ) ) { for ( Element property : element . getChildrenByName ( <str> ) ) { String key = property . getAttribute ( <str> , null ) ; String type = property . getAttribute ( <str> , null ) ; String value = property . getText ( ) ; if ( type . equals ( <str> ) ) { properties . put ( key , Integer . parseInt ( value ) ) ; } else if ( type . equals ( <str> ) ) { properties . put ( key , value ) ; } else if ( type . equals ( <str> ) ) { properties . put ( key , value . equalsIgnoreCase ( <str> ) ) ; } else { properties . put ( key , value ) ; } } } } private static FileHandle getRelativeFileHandle ( FileHandle file , String path ) { StringTokenizer tokenizer = new StringTokenizer ( path , <str> ) ; FileHandle result = file . parent ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( <str> ) ) result = result . parent ( ) ; else { result = result . child ( token ) ; } } return result ; } } 
