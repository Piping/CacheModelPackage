package org . eclipse . debug . internal . ui . views . breakpoints ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . commands . operations . IUndoContext ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IBreakpointManagerListener ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IDebugHelpContextIds ; import org . eclipse . debug . internal . ui . VariablesViewModelPresentation ; import org . eclipse . debug . internal . ui . actions . breakpointGroups . PasteBreakpointsAction ; import org . eclipse . debug . internal . ui . actions . breakpointGroups . RemoveFromWorkingSetAction ; import org . eclipse . debug . internal . ui . actions . breakpoints . OpenBreakpointMarkerAction ; import org . eclipse . debug . internal . ui . actions . breakpoints . ShowTargetBreakpointsAction ; import org . eclipse . debug . internal . ui . actions . breakpoints . SkipAllBreakpointsAction ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointContainer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointUIConstants ; import org . eclipse . debug . internal . ui . elements . adapters . DefaultBreakpointsViewInput ; import org . eclipse . debug . internal . ui . preferences . IDebugPreferenceConstants ; import org . eclipse . debug . internal . ui . viewers . model . VirtualFindAction ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerInputUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . TreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . VirtualTreeModelViewer ; import org . eclipse . debug . internal . ui . views . DebugUIViewsMessages ; import org . eclipse . debug . internal . ui . views . variables . VariablesView ; import org . eclipse . debug . internal . ui . views . variables . details . AvailableDetailPanesAction ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IBreakpointOrganizerDelegateExtension ; import org . eclipse . debug . ui . IDebugModelPresentation ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . util . LocalSelectionTransfer ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . Clipboard ; import org . eclipse . swt . dnd . DND ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . actions . SelectionListenerAction ; import org . eclipse . ui . operations . RedoActionHandler ; import org . eclipse . ui . operations . UndoActionHandler ; public class BreakpointsView extends VariablesView implements IBreakpointManagerListener { private static final String ACTION_GOTO_MARKER = <str> ; private static final String ACTION_SKIP_BREAKPOINTS = <str> ; private static final String ACTION_SHOW_MODEL_BREAKPOINT = <str> ; private static final String ACTION_REMOVE_FROM_GROUP = <str> ; private static final String KEY_VALUE = <str> ; private Clipboard fClipboard ; private IBreakpointOrganizer [ ] fOrganizers ; private boolean fFirstInputSet = false ; private UndoActionHandler fUndoAction ; private RedoActionHandler fRedoAction ; @Override public void dispose ( ) { if ( fClipboard ! = null ) { fClipboard . dispose ( ) ; } DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . removeBreakpointManagerListener ( this ) ; fUndoAction . dispose ( ) ; fRedoAction . dispose ( ) ; super . dispose ( ) ; } @Override protected String getDetailPanePreferenceKey ( ) { return IDebugPreferenceConstants . BREAKPOINTS_DETAIL_PANE_ORIENTATION ; } @Override protected String getHelpContextId ( ) { return IDebugHelpContextIds . BREAKPOINT_VIEW ; } @Override protected int getViewerStyle ( ) { return SWT . MULTI | SWT . V_SCROLL | SWT . H_SCROLL | SWT . VIRTUAL | SWT . FULL_SELECTION | SWT . CHECK ; } @Override public Viewer createViewer ( Composite parent ) { TreeModelViewer viewer = ( TreeModelViewer ) super . createViewer ( parent ) ; initBreakpointOrganizers ( getMemento ( ) ) ; IPresentationContext presentationContext = viewer . getPresentationContext ( ) ; presentationContext . setProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_ORGANIZERS , fOrganizers ) ; presentationContext . setProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_ELEMENT_COMPARATOR , new ElementComparator ( presentationContext ) ) ; return viewer ; } @Override protected IDebugModelPresentation getModelPresentation ( ) { if ( fModelPresentation = = null ) { fModelPresentation = new VariablesViewModelPresentation ( ) { @Override public String getText ( Object element ) { IDebugModelPresentation lp = getConfiguredPresentation ( element ) ; if ( lp ! = null ) { return lp . getText ( element ) ; } return getDefaultText ( element ) ; } } ; } return fModelPresentation ; } public TreeModelViewer getTreeModelViewer ( ) { return ( TreeModelViewer ) getViewer ( ) ; } @Override protected void configureToolBar ( IToolBarManager tbm ) { tbm . add ( new Separator ( IDebugUIConstants . BREAKPOINT_GROUP ) ) ; tbm . add ( getAction ( ACTION_SHOW_MODEL_BREAKPOINT ) ) ; tbm . add ( getAction ( ACTION_GOTO_MARKER ) ) ; tbm . add ( getAction ( ACTION_SKIP_BREAKPOINTS ) ) ; tbm . add ( new Separator ( IDebugUIConstants . RENDER_GROUP ) ) ; } @Override protected void fillContextMenu ( IMenuManager menu ) { updateObjects ( ) ; menu . add ( new Separator ( IDebugUIConstants . EMPTY_NAVIGATION_GROUP ) ) ; menu . add ( new Separator ( IDebugUIConstants . NAVIGATION_GROUP ) ) ; menu . add ( getAction ( ACTION_GOTO_MARKER ) ) ; menu . add ( new Separator ( IDebugUIConstants . EMPTY_BREAKPOINT_GROUP ) ) ; menu . add ( new Separator ( IDebugUIConstants . BREAKPOINT_GROUP ) ) ; menu . add ( getAction ( PASTE_ACTION ) ) ; IAction action = getAction ( ACTION_REMOVE_FROM_GROUP ) ; if ( action ! = null & & action . isEnabled ( ) ) { menu . add ( action ) ; } menu . add ( new Separator ( IDebugUIConstants . EMPTY_RENDER_GROUP ) ) ; action = new AvailableDetailPanesAction ( this ) ; if ( isDetailPaneVisible ( ) & & action . isEnabled ( ) ) { menu . add ( action ) ; } menu . add ( new Separator ( IDebugUIConstants . BREAKPOINT_GROUP_GROUP ) ) ; menu . add ( new Separator ( IWorkbenchActionConstants . MB_ADDITIONS ) ) ; } @Override protected void createActions ( ) { IAction action = new OpenBreakpointMarkerAction ( getViewer ( ) ) ; setAction ( ACTION_GOTO_MARKER , action ) ; setAction ( DOUBLE_CLICK_ACTION , action ) ; setAction ( ACTION_SHOW_MODEL_BREAKPOINT , new ShowTargetBreakpointsAction ( this ) ) ; SkipAllBreakpointsAction skipAll = new SkipAllBreakpointsAction ( this ) ; setAction ( ACTION_SKIP_BREAKPOINTS , skipAll ) ; skipAll . setActionDefinitionId ( SkipAllBreakpointsAction . ACTION_DEFINITION_ID ) ; DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . addBreakpointManagerListener ( this ) ; fClipboard = new Clipboard ( getSite ( ) . getShell ( ) . getDisplay ( ) ) ; PasteBreakpointsAction paste = new PasteBreakpointsAction ( this ) ; setAction ( PASTE_ACTION , paste ) ; paste . setActionDefinitionId ( ActionFactory . PASTE . getCommandId ( ) ) ; setGlobalAction ( PASTE_ACTION , paste ) ; getViewer ( ) . addSelectionChangedListener ( paste ) ; paste . setImageDescriptor ( PlatformUI . getWorkbench ( ) . getSharedImages ( ) . getImageDescriptor ( ISharedImages . IMG_TOOL_PASTE ) ) ; SelectionListenerAction remove = new RemoveFromWorkingSetAction ( this ) ; setAction ( ACTION_REMOVE_FROM_GROUP , remove ) ; getViewer ( ) . addSelectionChangedListener ( remove ) ; IUndoContext undoContext = DebugUITools . getBreakpointsUndoContext ( ) ; fUndoAction = new UndoActionHandler ( getSite ( ) , undoContext ) ; fUndoAction . setActionDefinitionId ( IWorkbenchCommandConstants . EDIT_UNDO ) ; fRedoAction = new RedoActionHandler ( getSite ( ) , undoContext ) ; fRedoAction . setActionDefinitionId ( IWorkbenchCommandConstants . EDIT_REDO ) ; setGlobalAction ( ActionFactory . UNDO . getId ( ) , fUndoAction ) ; setGlobalAction ( ActionFactory . REDO . getId ( ) , fRedoAction ) ; setGlobalAction ( FIND_ACTION , new VirtualFindAction ( getVariablesViewer ( ) ) ) ; } @Override protected String getToggleActionLabel ( ) { return DebugUIViewsMessages . BreakpointsView_12 ; } @Override protected String getPresentationContextId ( ) { return IDebugUIConstants . ID_BREAKPOINT_VIEW ; } @Override protected void contextActivated ( ISelection selection ) { IPresentationContext presentationContext = getTreeModelViewer ( ) . getPresentationContext ( ) ; if ( selection = = null | | selection . isEmpty ( ) ) { Object input = new DefaultBreakpointsViewInput ( presentationContext ) ; super . contextActivated ( new StructuredSelection ( input ) ) ; } else { super . contextActivated ( selection ) ; } if ( isAvailable ( ) & & isVisible ( ) ) { updateAction ( <str> ) ; } } @Override protected void setViewerInput ( Object context ) { Object current = getViewer ( ) . getInput ( ) ; if ( current = = null & & context = = null ) { return ; } if ( current ! = null & & current . equals ( context ) ) { return ; } showViewer ( ) ; getViewer ( ) . setInput ( context ) ; if ( ! fFirstInputSet ) { fFirstInputSet = true ; expandAllElementsInViewer ( ) ; } } @Override protected void viewerInputUpdateComplete ( IViewerInputUpdate update ) { IStatus status = update . getStatus ( ) ; if ( ( status = = null | | status . isOK ( ) ) & & update . getElement ( ) ! = null ) { setViewerInput ( update . getInputElement ( ) ) ; } else { setViewerInput ( new DefaultBreakpointsViewInput ( getTreeModelViewer ( ) . getPresentationContext ( ) ) ) ; } } public boolean isTrackingSelection ( ) { final TreeModelViewer viewer = getTreeModelViewer ( ) ; if ( viewer ! = null ) { return Boolean . TRUE . equals ( viewer . getPresentationContext ( ) . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_TRACK_SELECTION ) ) ; } return false ; } public void setTrackSelection ( boolean trackSelection ) { final TreeModelViewer viewer = getTreeModelViewer ( ) ; if ( viewer ! = null ) { viewer . getPresentationContext ( ) . setProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_TRACK_SELECTION , trackSelection ? Boolean . TRUE : Boolean . FALSE ) ; } } private void initBreakpointOrganizers ( IMemento memento ) { if ( memento ! = null ) { IMemento node = memento . getChild ( IDebugUIConstants . EXTENSION_POINT_BREAKPOINT_ORGANIZERS ) ; if ( node = = null ) { fOrganizers = null ; } else { String value = node . getString ( KEY_VALUE ) ; if ( value ! = null ) { String [ ] ids = value . split ( <str> ) ; BreakpointOrganizerManager manager = BreakpointOrganizerManager . getDefault ( ) ; List < IBreakpointOrganizer > organziers = new ArrayList < IBreakpointOrganizer > ( ) ; for ( int i = <int> ; i < ids . length ; i + + ) { IBreakpointOrganizer organizer = manager . getOrganizer ( ids [ i ] ) ; if ( organizer ! = null ) { organziers . add ( organizer ) ; } } fOrganizers = organziers . toArray ( new IBreakpointOrganizer [ organziers . size ( ) ] ) ; for ( int i = <int> ; i < fOrganizers . length ; i + + ) { fOrganizers [ i ] . addPropertyChangeListener ( this ) ; } } } } } @Override protected void initDragAndDrop ( TreeModelViewer viewer ) { int ops = DND . DROP_MOVE | DND . DROP_COPY ; viewer . addDropSupport ( ops , new Transfer [ ] { LocalSelectionTransfer . getTransfer ( ) } , new BreakpointsDropAdapter ( viewer , this ) ) ; viewer . addDragSupport ( ops , new Transfer [ ] { LocalSelectionTransfer . getTransfer ( ) } , new BreakpointsDragAdapter ( viewer , this ) ) ; } @Override public void saveViewerState ( IMemento memento ) { StringBuffer buffer = new StringBuffer ( ) ; if ( fOrganizers ! = null ) { for ( int i = <int> ; i < fOrganizers . length ; i + + ) { IBreakpointOrganizer organizer = fOrganizers [ i ] ; buffer . append ( organizer . getIdentifier ( ) ) ; if ( i < ( fOrganizers . length - <int> ) ) { buffer . append ( <str> ) ; } } IMemento node = memento . createChild ( IDebugUIConstants . EXTENSION_POINT_BREAKPOINT_ORGANIZERS ) ; node . putString ( KEY_VALUE , buffer . toString ( ) ) ; } super . saveViewerState ( memento ) ; } public void preserveSelection ( IStructuredSelection selection ) { if ( selection instanceof ITreeSelection & & ! selection . isEmpty ( ) ) { TreePath path = ( ( ITreeSelection ) selection ) . getPaths ( ) [ <int> ] ; TreeItem item = ( TreeItem ) ( ( TreeModelViewer ) getViewer ( ) ) . findItem ( path ) ; Object toselect = null ; TreeItem [ ] siblings = null ; if ( item ! = null ) { TreeItem parent = item . getParentItem ( ) ; if ( parent ! = null ) { siblings = parent . getItems ( ) ; } else { siblings = item . getParent ( ) . getItems ( ) ; } if ( siblings . length > <int> ) { for ( int i = <int> ; i < siblings . length ; i + + ) { if ( item . equals ( siblings [ i ] ) ) { if ( i + <int> > = siblings . length ) { toselect = siblings [ i - <int> ] . getData ( ) ; break ; } else { toselect = siblings [ i + <int> ] . getData ( ) ; break ; } } } } } if ( toselect ! = null ) { getViewer ( ) . setSelection ( new StructuredSelection ( toselect ) , true ) ; } } } public void setBreakpointOrganizers ( IBreakpointOrganizer [ ] organizers ) { fOrganizers = organizers ; TreeModelViewer viewer = getTreeModelViewer ( ) ; if ( viewer ! = null ) { viewer . getPresentationContext ( ) . setProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_ORGANIZERS , fOrganizers ) ; } } public void setFilterSelection ( boolean filter ) { TreeModelViewer viewer = getTreeModelViewer ( ) ; if ( viewer ! = null ) { viewer . getPresentationContext ( ) . setProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_FILTER_SELECTION , filter ? Boolean . TRUE : Boolean . FALSE ) ; } } @Override public void breakpointManagerEnablementChanged ( boolean enabled ) { DebugUIPlugin . getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { IAction action = getAction ( ACTION_SKIP_BREAKPOINTS ) ; if ( action ! = null ) { ( ( SkipAllBreakpointsAction ) action ) . updateActionCheckedState ( ) ; } } } ) ; } public void expandAllElementsInViewer ( ) { Display display = getSite ( ) . getShell ( ) . getDisplay ( ) ; final VirtualTreeModelViewer virtualViewer = new VirtualTreeModelViewer ( display , <int> , ( ( ITreeModelViewer ) getViewer ( ) ) . getPresentationContext ( ) ) ; virtualViewer . setAutoExpandLevel ( - <int> ) ; virtualViewer . addViewerUpdateListener ( new IViewerUpdateListener ( ) { @Override public void viewerUpdatesComplete ( ) { ModelDelta stateDelta = new ModelDelta ( virtualViewer . getInput ( ) , IModelDelta . NO_CHANGE ) ; virtualViewer . saveElementState ( TreePath . EMPTY , stateDelta , IModelDelta . EXPAND ) ; ITreeModelViewer treeModelViewer = ( ( ITreeModelViewer ) getViewer ( ) ) ; if ( treeModelViewer ! = null ) { ( ( ITreeModelViewer ) getViewer ( ) ) . updateViewer ( stateDelta ) ; } virtualViewer . dispose ( ) ; } @Override public void viewerUpdatesBegin ( ) { } @Override public void updateStarted ( IViewerUpdate update ) { } @Override public void updateComplete ( IViewerUpdate update ) { } } ) ; virtualViewer . setInput ( getViewer ( ) . getInput ( ) ) ; } public IBreakpointOrganizer [ ] getBreakpointOrganizers ( ) { return fOrganizers ; } public boolean canPaste ( Object target , ISelection selection ) { if ( ! ( target instanceof IBreakpointContainer ) | | ! ( selection instanceof IStructuredSelection ) ) { return false ; } if ( selection = = null | | selection . isEmpty ( ) ) { return false ; } IStructuredSelection ss = ( IStructuredSelection ) selection ; IBreakpointContainer container = ( IBreakpointContainer ) target ; for ( Iterator < ? > iter = ss . iterator ( ) ; iter . hasNext ( ) ; ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( iter . next ( ) , IBreakpoint . class ) ; if ( breakpoint = = null | | container . contains ( breakpoint ) | | ! container . getOrganizer ( ) . canAdd ( breakpoint , container . getCategory ( ) ) ) { return false ; } } return true ; } public boolean performPaste ( Object target , ISelection selection ) { if ( target instanceof IBreakpointContainer & & selection instanceof IStructuredSelection ) { IBreakpointContainer container = ( IBreakpointContainer ) target ; Object [ ] objects = ( ( IStructuredSelection ) selection ) . toArray ( ) ; for ( int i = <int> ; i < objects . length ; i + + ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( objects [ i ] , IBreakpoint . class ) ; if ( breakpoint ! = null ) { container . getOrganizer ( ) . addBreakpoint ( breakpoint , container . getCategory ( ) ) ; } } return true ; } return false ; } public IBreakpointContainer getRemovableContainer ( TreePath path ) { if ( path ! = null ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( path . getLastSegment ( ) , IBreakpoint . class ) ; if ( breakpoint ! = null ) { IBreakpointContainer container = null ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { Object segment = path . getSegment ( i ) ; if ( segment instanceof IBreakpointContainer ) { container = ( IBreakpointContainer ) segment ; if ( container . contains ( breakpoint ) & & container . getOrganizer ( ) ! = null & & container . getOrganizer ( ) . canRemove ( breakpoint , container . getCategory ( ) ) ) { return container ; } } } } } return null ; } protected IBreakpointContainer getAddableContainer ( TreePath path ) { if ( path ! = null ) { Object element = path . getLastSegment ( ) ; if ( element instanceof IBreakpointContainer ) { return ( IBreakpointContainer ) element ; } IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( element , IBreakpoint . class ) ; if ( breakpoint ! = null ) { IBreakpointContainer container = null ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { Object segment = path . getSegment ( i ) ; if ( segment instanceof IBreakpointContainer ) { container = ( IBreakpointContainer ) segment ; if ( container . contains ( breakpoint ) & & container . getOrganizer ( ) . canAdd ( breakpoint , container . getCategory ( ) ) ) { return container ; } } } } } return null ; } private boolean checkAddableParentContainers ( TreePath path , IBreakpoint breakpoint ) { if ( path ! = null ) { Object element = null ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { element = path . getSegment ( i ) ; if ( element instanceof IBreakpointContainer ) { IBreakpointContainer container = ( IBreakpointContainer ) element ; if ( container . contains ( breakpoint ) | | ! container . getOrganizer ( ) . canAdd ( breakpoint , container . getCategory ( ) ) ) { return false ; } } } } return true ; } boolean canDrag ( TreePath [ ] items ) { if ( items = = null ) { return false ; } if ( items . length = = <int> ) { return false ; } for ( int i = <int> ; i < items . length ; i + + ) { if ( getRemovableContainer ( items [ i ] ) = = null ) { return false ; } } return true ; } void performDrag ( TreePath [ ] paths ) { if ( paths = = null ) { return ; } Map < IBreakpointContainer , List < IBreakpoint > > containersToBreakpoints = new HashMap < IBreakpointContainer , List < IBreakpoint > > ( ) ; for ( int i = <int> ; i < paths . length ; i + + ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( paths [ i ] . getLastSegment ( ) , IBreakpoint . class ) ; if ( breakpoint ! = null ) { IBreakpointContainer container = getRemovableContainer ( paths [ i ] ) ; if ( container ! = null ) { List < IBreakpoint > list = containersToBreakpoints . get ( container ) ; if ( list = = null ) { list = new ArrayList < IBreakpoint > ( ) ; containersToBreakpoints . put ( container , list ) ; } list . add ( breakpoint ) ; } } } for ( Entry < IBreakpointContainer , List < IBreakpoint > > entry : containersToBreakpoints . entrySet ( ) ) { IBreakpointContainer container = entry . getKey ( ) ; List < IBreakpoint > list = entry . getValue ( ) ; IBreakpointOrganizer organizer = container . getOrganizer ( ) ; IBreakpoint [ ] breakpoints = list . toArray ( new IBreakpoint [ list . size ( ) ] ) ; if ( organizer instanceof IBreakpointOrganizerDelegateExtension ) { IBreakpointOrganizerDelegateExtension extension = ( IBreakpointOrganizerDelegateExtension ) organizer ; extension . removeBreakpoints ( breakpoints , container . getCategory ( ) ) ; } else { for ( int i = <int> ; i < breakpoints . length ; i + + ) { organizer . removeBreakpoint ( breakpoints [ i ] , container . getCategory ( ) ) ; } } } } protected boolean performDrop ( TreePath target , ITreeSelection selection ) { if ( target = = null | | selection = = null ) { return false ; } IBreakpointContainer container = getAddableContainer ( target ) ; if ( container = = null ) { return false ; } IBreakpointOrganizer organizer = container . getOrganizer ( ) ; List < IBreakpoint > breakpoints = new ArrayList < IBreakpoint > ( selection . size ( ) ) ; for ( Iterator < ? > iter = selection . iterator ( ) ; iter . hasNext ( ) ; ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( iter . next ( ) , IBreakpoint . class ) ; if ( breakpoint ! = null ) { breakpoints . add ( breakpoint ) ; } } if ( organizer instanceof IBreakpointOrganizerDelegateExtension ) { IBreakpointOrganizerDelegateExtension extension = ( IBreakpointOrganizerDelegateExtension ) organizer ; extension . addBreakpoints ( breakpoints . toArray ( new IBreakpoint [ breakpoints . size ( ) ] ) , container . getCategory ( ) ) ; } else { for ( int i = <int> ; i < breakpoints . size ( ) ; i + + ) { organizer . addBreakpoint ( breakpoints . get ( i ) , container . getCategory ( ) ) ; } } return true ; } boolean canDrop ( TreePath target , ITreeSelection selection ) { if ( selection = = null | | target = = null ) { return false ; } for ( Iterator < ? > iter = selection . iterator ( ) ; iter . hasNext ( ) ; ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( iter . next ( ) , IBreakpoint . class ) ; if ( breakpoint = = null | | ! checkAddableParentContainers ( target , breakpoint ) ) { return false ; } } return true ; } } 
