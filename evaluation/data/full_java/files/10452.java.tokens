package com . google . common . eventbus ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Queues ; import com . google . common . util . concurrent . Uninterruptibles ; import junit . framework . TestCase ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; public class DispatcherTest extends TestCase { private final EventBus bus = new EventBus ( ) ; private final IntegerSubscriber i1 = new IntegerSubscriber ( <str> ) ; private final IntegerSubscriber i2 = new IntegerSubscriber ( <str> ) ; private final IntegerSubscriber i3 = new IntegerSubscriber ( <str> ) ; private final ImmutableList < Subscriber > integerSubscribers = ImmutableList . of ( subscriber ( bus , i1 , <str> , Integer . class ) , subscriber ( bus , i2 , <str> , Integer . class ) , subscriber ( bus , i3 , <str> , Integer . class ) ) ; private final StringSubscriber s1 = new StringSubscriber ( <str> ) ; private final StringSubscriber s2 = new StringSubscriber ( <str> ) ; private final ImmutableList < Subscriber > stringSubscribers = ImmutableList . of ( subscriber ( bus , s1 , <str> , String . class ) , subscriber ( bus , s2 , <str> , String . class ) ) ; private final ConcurrentLinkedQueue < Object > dispatchedSubscribers = Queues . newConcurrentLinkedQueue ( ) ; private Dispatcher dispatcher ; public void testPerThreadQueuedDispatcher ( ) { dispatcher = Dispatcher . perThreadDispatchQueue ( ) ; dispatcher . dispatch ( <int> , integerSubscribers . iterator ( ) ) ; assertThat ( dispatchedSubscribers ) . containsExactly ( i1 , i2 , i3 , s1 , s2 , s1 , s2 , s1 , s2 ) . inOrder ( ) ; } public void testLegacyAsyncDispatcher ( ) { dispatcher = Dispatcher . legacyAsync ( ) ; final CyclicBarrier barrier = new CyclicBarrier ( <int> ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } dispatcher . dispatch ( <int> , integerSubscribers . iterator ( ) ) ; latch . countDown ( ) ; } } ) . start ( ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } dispatcher . dispatch ( <str> , stringSubscribers . iterator ( ) ) ; latch . countDown ( ) ; } } ) . start ( ) ; Uninterruptibles . awaitUninterruptibly ( latch ) ; assertThat ( dispatchedSubscribers ) . containsExactly ( i1 , i2 , i3 , s1 , s1 , s1 , s1 , s2 , s2 , s2 , s2 ) ; } public void testImmediateDispatcher ( ) { dispatcher = Dispatcher . immediate ( ) ; dispatcher . dispatch ( <int> , integerSubscribers . iterator ( ) ) ; assertThat ( dispatchedSubscribers ) . containsExactly ( i1 , s1 , s2 , i2 , s1 , s2 , i3 , s1 , s2 ) . inOrder ( ) ; } private static Subscriber subscriber ( EventBus bus , Object target , String methodName , Class < ? > eventType ) { try { return Subscriber . create ( bus , target , target . getClass ( ) . getMethod ( methodName , eventType ) ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } } public final class IntegerSubscriber { private final String name ; public IntegerSubscriber ( String name ) { this . name = name ; } @Subscribe public void handleInteger ( Integer integer ) { dispatchedSubscribers . add ( this ) ; dispatcher . dispatch ( <str> , stringSubscribers . iterator ( ) ) ; } @Override public String toString ( ) { return name ; } } public final class StringSubscriber { private final String name ; public StringSubscriber ( String name ) { this . name = name ; } @Subscribe public void handleString ( String string ) { dispatchedSubscribers . add ( this ) ; } @Override public String toString ( ) { return name ; } } } 
