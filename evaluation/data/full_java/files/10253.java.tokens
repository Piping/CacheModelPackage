package com . google . common . base ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . FluentIterable ; import com . google . common . collect . ImmutableList ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . util . Collections ; import java . util . List ; import java . util . Set ; @GwtCompatible ( emulated = true ) public final class OptionalTest extends TestCase { public void testAbsent ( ) { Optional < String > optionalName = Optional . absent ( ) ; assertFalse ( optionalName . isPresent ( ) ) ; } public void testOf ( ) { assertEquals ( <str> , Optional . of ( <str> ) . get ( ) ) ; } @SuppressWarnings ( <str> ) public void testOf_null ( ) { try { Optional . of ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testFromNullable ( ) { Optional < String > optionalName = Optional . fromNullable ( <str> ) ; assertEquals ( <str> , optionalName . get ( ) ) ; } public void testFromNullable_null ( ) { assertSame ( Optional . absent ( ) , Optional . fromNullable ( null ) ) ; } public void testIsPresent_no ( ) { assertFalse ( Optional . absent ( ) . isPresent ( ) ) ; } public void testIsPresent_yes ( ) { assertTrue ( Optional . of ( <str> ) . isPresent ( ) ) ; } @SuppressWarnings ( <str> ) public void testGet_absent ( ) { Optional < String > optional = Optional . absent ( ) ; try { optional . get ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testGet_present ( ) { assertEquals ( <str> , Optional . of ( <str> ) . get ( ) ) ; } public void testOr_T_present ( ) { assertEquals ( <str> , Optional . of ( <str> ) . or ( <str> ) ) ; } public void testOr_T_absent ( ) { assertEquals ( <str> , Optional . absent ( ) . or ( <str> ) ) ; } public void testOr_supplier_present ( ) { assertEquals ( <str> , Optional . of ( <str> ) . or ( Suppliers . ofInstance ( <str> ) ) ) ; } public void testOr_supplier_absent ( ) { assertEquals ( <str> , Optional . absent ( ) . or ( Suppliers . ofInstance ( <str> ) ) ) ; } @SuppressWarnings ( <str> ) public void testOr_nullSupplier_absent ( ) { Supplier < Object > nullSupplier = Suppliers . ofInstance ( null ) ; Optional < Object > absentOptional = Optional . absent ( ) ; try { absentOptional . or ( nullSupplier ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOr_nullSupplier_present ( ) { Supplier < String > nullSupplier = Suppliers . ofInstance ( null ) ; assertEquals ( <str> , Optional . of ( <str> ) . or ( nullSupplier ) ) ; } public void testOr_Optional_present ( ) { assertEquals ( Optional . of ( <str> ) , Optional . of ( <str> ) . or ( Optional . of ( <str> ) ) ) ; } public void testOr_Optional_absent ( ) { assertEquals ( Optional . of ( <str> ) , Optional . absent ( ) . or ( Optional . of ( <str> ) ) ) ; } public void testOrNull_present ( ) { assertEquals ( <str> , Optional . of ( <str> ) . orNull ( ) ) ; } public void testOrNull_absent ( ) { assertNull ( Optional . absent ( ) . orNull ( ) ) ; } public void testAsSet_present ( ) { Set < String > expected = Collections . singleton ( <str> ) ; assertEquals ( expected , Optional . of ( <str> ) . asSet ( ) ) ; } public void testAsSet_absent ( ) { assertTrue ( <str> , Optional . absent ( ) . asSet ( ) . isEmpty ( ) ) ; } public void testAsSet_presentIsImmutable ( ) { Set < String > presentAsSet = Optional . of ( <str> ) . asSet ( ) ; try { presentAsSet . add ( <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testAsSet_absentIsImmutable ( ) { Set < Object > absentAsSet = Optional . absent ( ) . asSet ( ) ; try { absentAsSet . add ( <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testTransform_absent ( ) { assertEquals ( Optional . absent ( ) , Optional . absent ( ) . transform ( Functions . identity ( ) ) ) ; assertEquals ( Optional . absent ( ) , Optional . absent ( ) . transform ( Functions . toStringFunction ( ) ) ) ; } public void testTransform_presentIdentity ( ) { assertEquals ( Optional . of ( <str> ) , Optional . of ( <str> ) . transform ( Functions . identity ( ) ) ) ; } public void testTransform_presentToString ( ) { assertEquals ( Optional . of ( <str> ) , Optional . of ( <int> ) . transform ( Functions . toStringFunction ( ) ) ) ; } @SuppressWarnings ( <str> ) public void testTransform_present_functionReturnsNull ( ) { try { Optional . of ( <str> ) . transform ( new Function < String , String > ( ) { @Override public String apply ( String input ) { return null ; } } ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testTransform_abssent_functionReturnsNull ( ) { assertEquals ( Optional . absent ( ) , Optional . absent ( ) . transform ( new Function < Object , Object > ( ) { @Override public Object apply ( Object input ) { return null ; } } ) ) ; } public void testEqualsAndHashCode_absent ( ) { assertEquals ( Optional . < String > absent ( ) , Optional . < Integer > absent ( ) ) ; assertEquals ( Optional . absent ( ) . hashCode ( ) , Optional . absent ( ) . hashCode ( ) ) ; assertThat ( Optional . absent ( ) . hashCode ( ) ) . isNotEqualTo ( Optional . of ( <int> ) . hashCode ( ) ) ; } public void testEqualsAndHashCode_present ( ) { assertEquals ( Optional . of ( <str> ) , Optional . of ( <str> ) ) ; assertFalse ( Optional . of ( <str> ) . equals ( Optional . of ( <str> ) ) ) ; assertFalse ( Optional . of ( <str> ) . equals ( Optional . absent ( ) ) ) ; assertEquals ( Optional . of ( <str> ) . hashCode ( ) , Optional . of ( <str> ) . hashCode ( ) ) ; } public void testToString_absent ( ) { assertEquals ( <str> , Optional . absent ( ) . toString ( ) ) ; } public void testToString_present ( ) { assertEquals ( <str> , Optional . of ( <str> ) . toString ( ) ) ; } public void testPresentInstances_allPresent ( ) { List < Optional < String > > optionals = ImmutableList . of ( Optional . of ( <str> ) , Optional . of ( <str> ) , Optional . of ( <str> ) ) ; assertThat ( Optional . presentInstances ( optionals ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testPresentInstances_allAbsent ( ) { List < Optional < Object > > optionals = ImmutableList . of ( Optional . absent ( ) , Optional . absent ( ) ) ; assertThat ( Optional . presentInstances ( optionals ) ) . isEmpty ( ) ; } public void testPresentInstances_somePresent ( ) { List < Optional < String > > optionals = ImmutableList . of ( Optional . of ( <str> ) , Optional . < String > absent ( ) , Optional . of ( <str> ) ) ; assertThat ( Optional . presentInstances ( optionals ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testPresentInstances_callingIteratorTwice ( ) { List < Optional < String > > optionals = ImmutableList . of ( Optional . of ( <str> ) , Optional . < String > absent ( ) , Optional . of ( <str> ) ) ; Iterable < String > onlyPresent = Optional . presentInstances ( optionals ) ; assertThat ( onlyPresent ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( onlyPresent ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testPresentInstances_wildcards ( ) { List < Optional < ? extends Number > > optionals = ImmutableList . < Optional < ? extends Number > > of ( Optional . < Double > absent ( ) , Optional . of ( <int> ) ) ; Iterable < Number > onlyPresent = Optional . presentInstances ( optionals ) ; assertThat ( onlyPresent ) . containsExactly ( <int> ) . inOrder ( ) ; } private static Optional < Integer > getSomeOptionalInt ( ) { return Optional . of ( <int> ) ; } private static FluentIterable < ? extends Number > getSomeNumbers ( ) { return FluentIterable . from ( ImmutableList . < Number > of ( ) ) ; } @SuppressWarnings ( <str> ) public void testSampleCodeError1 ( ) { Optional < Integer > optionalInt = getSomeOptionalInt ( ) ; } @SuppressWarnings ( <str> ) public void testSampleCodeError2 ( ) { FluentIterable < ? extends Number > numbers = getSomeNumbers ( ) ; Optional < ? extends Number > first = numbers . first ( ) ; } @SuppressWarnings ( <str> ) public void testSampleCodeFine1 ( ) { Optional < Number > optionalInt = Optional . of ( ( Number ) <int> ) ; Number value = optionalInt . or ( <float> ) ; } @SuppressWarnings ( <str> ) public void testSampleCodeFine2 ( ) { FluentIterable < ? extends Number > numbers = getSomeNumbers ( ) ; @SuppressWarnings ( <str> ) Optional < Number > first = ( Optional ) numbers . first ( ) ; Number value = first . or ( <float> ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { SerializableTester . reserializeAndAssert ( Optional . absent ( ) ) ; SerializableTester . reserializeAndAssert ( Optional . of ( <str> ) ) ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester npTester = new NullPointerTester ( ) ; npTester . testAllPublicConstructors ( Optional . class ) ; npTester . testAllPublicStaticMethods ( Optional . class ) ; npTester . testAllPublicInstanceMethods ( Optional . absent ( ) ) ; npTester . testAllPublicInstanceMethods ( Optional . of ( <str> ) ) ; } } 
