package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; public class SpanNotQueryParser implements QueryParser < SpanNotQueryBuilder > { public static final ParseField POST_FIELD = new ParseField ( <str> ) ; public static final ParseField PRE_FIELD = new ParseField ( <str> ) ; public static final ParseField DIST_FIELD = new ParseField ( <str> ) ; public static final ParseField EXCLUDE_FIELD = new ParseField ( <str> ) ; public static final ParseField INCLUDE_FIELD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { SpanNotQueryBuilder . NAME , Strings . toCamelCase ( SpanNotQueryBuilder . NAME ) } ; } @Override public SpanNotQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; SpanQueryBuilder include = null ; SpanQueryBuilder exclude = null ; Integer dist = null ; Integer pre = null ; Integer post = null ; String queryName = null ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , INCLUDE_FIELD ) ) { QueryBuilder query = parseContext . parseInnerQueryBuilder ( ) ; if ( ! ( query instanceof SpanQueryBuilder ) ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } include = ( SpanQueryBuilder ) query ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , EXCLUDE_FIELD ) ) { QueryBuilder query = parseContext . parseInnerQueryBuilder ( ) ; if ( ! ( query instanceof SpanQueryBuilder ) ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } exclude = ( SpanQueryBuilder ) query ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , DIST_FIELD ) ) { dist = parser . intValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , PRE_FIELD ) ) { pre = parser . intValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , POST_FIELD ) ) { post = parser . intValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . BOOST_FIELD ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . NAME_FIELD ) ) { queryName = parser . text ( ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } } if ( include = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } if ( exclude = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } if ( dist ! = null & & ( pre ! = null | | post ! = null ) ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } SpanNotQueryBuilder spanNotQuery = new SpanNotQueryBuilder ( include , exclude ) ; if ( dist ! = null ) { spanNotQuery . dist ( dist ) ; } if ( pre ! = null ) { spanNotQuery . pre ( pre ) ; } if ( post ! = null ) { spanNotQuery . post ( post ) ; } spanNotQuery . boost ( boost ) ; spanNotQuery . queryName ( queryName ) ; return spanNotQuery ; } @Override public SpanNotQueryBuilder getBuilderPrototype ( ) { return SpanNotQueryBuilder . PROTOTYPE ; } } 
