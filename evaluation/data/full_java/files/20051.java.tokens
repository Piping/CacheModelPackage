package io . netty . handler . proxy ; import io . netty . bootstrap . Bootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . PooledByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . SocketChannel ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . codec . LineBasedFrameDecoder ; import io . netty . handler . ssl . SslContext ; import io . netty . handler . ssl . util . InsecureTrustManagerFactory ; import io . netty . handler . ssl . util . SelfSignedCertificate ; import io . netty . resolver . NoopNameResolverGroup ; import io . netty . util . CharsetUtil ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . concurrent . Future ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . junit . runners . Parameterized ; import org . junit . runners . Parameterized . Parameters ; import java . net . InetSocketAddress ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; @RunWith ( Parameterized . class ) public class ProxyHandlerTest { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ProxyHandlerTest . class ) ; private static final InetSocketAddress DESTINATION = InetSocketAddress . createUnresolved ( <str> , <int> ) ; private static final InetSocketAddress BAD_DESTINATION = new InetSocketAddress ( <str> , <int> ) ; private static final String USERNAME = <str> ; private static final String PASSWORD = <str> ; private static final String BAD_USERNAME = <str> ; private static final String BAD_PASSWORD = <str> ; static final EventLoopGroup group = new NioEventLoopGroup ( <int> , new DefaultThreadFactory ( <str> , true ) ) ; static final SslContext serverSslCtx ; static final SslContext clientSslCtx ; static { SslContext sctx ; SslContext cctx ; try { SelfSignedCertificate ssc = new SelfSignedCertificate ( ) ; sctx = SslContext . newServerContext ( ssc . certificate ( ) , ssc . privateKey ( ) ) ; cctx = SslContext . newClientContext ( InsecureTrustManagerFactory . INSTANCE ) ; } catch ( Exception e ) { throw new Error ( e ) ; } serverSslCtx = sctx ; clientSslCtx = cctx ; } static final ProxyServer deadHttpProxy = new HttpProxyServer ( false , TestMode . UNRESPONSIVE , null ) ; static final ProxyServer interHttpProxy = new HttpProxyServer ( false , TestMode . INTERMEDIARY , null ) ; static final ProxyServer anonHttpProxy = new HttpProxyServer ( false , TestMode . TERMINAL , DESTINATION ) ; static final ProxyServer httpProxy = new HttpProxyServer ( false , TestMode . TERMINAL , DESTINATION , USERNAME , PASSWORD ) ; static final ProxyServer deadHttpsProxy = new HttpProxyServer ( true , TestMode . UNRESPONSIVE , null ) ; static final ProxyServer interHttpsProxy = new HttpProxyServer ( true , TestMode . INTERMEDIARY , null ) ; static final ProxyServer anonHttpsProxy = new HttpProxyServer ( true , TestMode . TERMINAL , DESTINATION ) ; static final ProxyServer httpsProxy = new HttpProxyServer ( true , TestMode . TERMINAL , DESTINATION , USERNAME , PASSWORD ) ; static final ProxyServer deadSocks4Proxy = new Socks4ProxyServer ( false , TestMode . UNRESPONSIVE , null ) ; static final ProxyServer interSocks4Proxy = new Socks4ProxyServer ( false , TestMode . INTERMEDIARY , null ) ; static final ProxyServer anonSocks4Proxy = new Socks4ProxyServer ( false , TestMode . TERMINAL , DESTINATION ) ; static final ProxyServer socks4Proxy = new Socks4ProxyServer ( false , TestMode . TERMINAL , DESTINATION , USERNAME ) ; static final ProxyServer deadSocks5Proxy = new Socks5ProxyServer ( false , TestMode . UNRESPONSIVE , null ) ; static final ProxyServer interSocks5Proxy = new Socks5ProxyServer ( false , TestMode . INTERMEDIARY , null ) ; static final ProxyServer anonSocks5Proxy = new Socks5ProxyServer ( false , TestMode . TERMINAL , DESTINATION ) ; static final ProxyServer socks5Proxy = new Socks5ProxyServer ( false , TestMode . TERMINAL , DESTINATION , USERNAME , PASSWORD ) ; private static final Collection < ProxyServer > allProxies = Arrays . asList ( deadHttpProxy , interHttpProxy , anonHttpProxy , httpProxy , deadHttpsProxy , interHttpsProxy , anonHttpsProxy , httpsProxy , deadSocks4Proxy , interSocks4Proxy , anonSocks4Proxy , socks4Proxy , deadSocks5Proxy , interSocks5Proxy , anonSocks5Proxy , socks5Proxy ) ; @Parameters ( name = <str> ) public static List < Object [ ] > testItems ( ) { List < TestItem > items = Arrays . asList ( new SuccessTestItem ( <str> , DESTINATION , new HttpProxyHandler ( anonHttpProxy . address ( ) ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new HttpProxyHandler ( anonHttpProxy . address ( ) ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new HttpProxyHandler ( httpProxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new HttpProxyHandler ( httpProxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new HttpProxyHandler ( httpProxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new HttpProxyHandler ( httpProxy . address ( ) , BAD_USERNAME , BAD_PASSWORD ) ) , new TimeoutTestItem ( <str> , new HttpProxyHandler ( deadHttpProxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( anonHttpsProxy . address ( ) ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( anonHttpsProxy . address ( ) ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( httpsProxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( httpsProxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( httpsProxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( httpsProxy . address ( ) , BAD_USERNAME , BAD_PASSWORD ) ) , new TimeoutTestItem ( <str> , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( deadHttpsProxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks4ProxyHandler ( anonSocks4Proxy . address ( ) ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new Socks4ProxyHandler ( anonSocks4Proxy . address ( ) ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new Socks4ProxyHandler ( socks4Proxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks4ProxyHandler ( socks4Proxy . address ( ) , USERNAME ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new Socks4ProxyHandler ( socks4Proxy . address ( ) , USERNAME ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new Socks4ProxyHandler ( socks4Proxy . address ( ) , BAD_USERNAME ) ) , new TimeoutTestItem ( <str> , new Socks4ProxyHandler ( deadSocks4Proxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks5ProxyHandler ( anonSocks5Proxy . address ( ) ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new Socks5ProxyHandler ( anonSocks5Proxy . address ( ) ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new Socks5ProxyHandler ( socks5Proxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks5ProxyHandler ( socks5Proxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , BAD_DESTINATION , <str> , new Socks5ProxyHandler ( socks5Proxy . address ( ) , USERNAME , PASSWORD ) ) , new FailureTestItem ( <str> , DESTINATION , <str> , new Socks5ProxyHandler ( socks5Proxy . address ( ) , BAD_USERNAME , BAD_PASSWORD ) ) , new TimeoutTestItem ( <str> , new Socks5ProxyHandler ( deadSocks5Proxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks5ProxyHandler ( interSocks5Proxy . address ( ) ) , new Socks4ProxyHandler ( interSocks4Proxy . address ( ) ) , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( interHttpsProxy . address ( ) ) , new HttpProxyHandler ( interHttpProxy . address ( ) ) , new HttpProxyHandler ( anonHttpProxy . address ( ) ) ) , new SuccessTestItem ( <str> , DESTINATION , new Socks5ProxyHandler ( interSocks5Proxy . address ( ) ) , new Socks4ProxyHandler ( interSocks4Proxy . address ( ) ) , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( interHttpsProxy . address ( ) ) , new HttpProxyHandler ( interHttpProxy . address ( ) ) , new Socks5ProxyHandler ( interSocks5Proxy . address ( ) ) , new Socks4ProxyHandler ( interSocks4Proxy . address ( ) ) , clientSslCtx . newHandler ( PooledByteBufAllocator . DEFAULT ) , new HttpProxyHandler ( interHttpsProxy . address ( ) ) , new HttpProxyHandler ( interHttpProxy . address ( ) ) , new HttpProxyHandler ( anonHttpProxy . address ( ) ) ) ) ; List < Object [ ] > params = new ArrayList < Object [ ] > ( items . size ( ) ) ; for ( Object i : items ) { params . add ( new Object [ ] { i } ) ; } Collections . shuffle ( params ) ; return params ; } @AfterClass public static void stopServers ( ) { for ( ProxyServer p : allProxies ) { p . stop ( ) ; } } private final TestItem testItem ; public ProxyHandlerTest ( TestItem testItem ) { this . testItem = testItem ; } @Before public void clearServerExceptions ( ) throws Exception { for ( ProxyServer p : allProxies ) { p . clearExceptions ( ) ; } } @Test public void test ( ) throws Exception { testItem . test ( ) ; } @After public void checkServerExceptions ( ) throws Exception { for ( ProxyServer p : allProxies ) { p . checkExceptions ( ) ; } } private static final class SuccessTestHandler extends SimpleChannelInboundHandler < Object > { final Queue < String > received = new LinkedBlockingQueue < String > ( ) ; final Queue < Throwable > exceptions = new LinkedBlockingQueue < Throwable > ( ) ; volatile int eventCount ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { ctx . writeAndFlush ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; } @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof ProxyConnectionEvent ) { eventCount + + ; if ( eventCount = = <int> ) { ctx . writeAndFlush ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; } } } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { String str = ( ( ByteBuf ) msg ) . toString ( CharsetUtil . US_ASCII ) ; received . add ( str ) ; if ( <str> . equals ( str ) ) { ctx . writeAndFlush ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { exceptions . add ( cause ) ; ctx . close ( ) ; } } private static final class FailureTestHandler extends SimpleChannelInboundHandler < Object > { final Queue < Throwable > exceptions = new LinkedBlockingQueue < Throwable > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { ctx . writeAndFlush ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { latch . countDown ( ) ; if ( ! ( future . cause ( ) instanceof ProxyConnectException ) ) { exceptions . add ( new AssertionError ( <str> + future . cause ( ) ) ) ; } } } ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { latch . countDown ( ) ; } @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof ProxyConnectionEvent ) { fail ( <str> + evt ) ; } } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { fail ( <str> + msg ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { exceptions . add ( cause ) ; ctx . close ( ) ; } } private abstract static class TestItem { final String name ; final InetSocketAddress destination ; final ChannelHandler [ ] clientHandlers ; protected TestItem ( String name , InetSocketAddress destination , ChannelHandler . . . clientHandlers ) { this . name = name ; this . destination = destination ; this . clientHandlers = clientHandlers ; } abstract void test ( ) throws Exception ; protected void assertProxyHandlers ( boolean success ) { for ( ChannelHandler h : clientHandlers ) { if ( h instanceof ProxyHandler ) { ProxyHandler ph = ( ProxyHandler ) h ; String type = StringUtil . simpleClassName ( ph ) ; Future < Channel > f = ph . connectFuture ( ) ; if ( ! f . isDone ( ) ) { logger . warn ( <str> , type ) ; } else if ( f . isSuccess ( ) ) { if ( success ) { logger . debug ( <str> , type ) ; } else { logger . warn ( <str> , type ) ; } } else { if ( success ) { logger . warn ( <str> , type , f . cause ( ) ) ; } else { logger . debug ( <str> , type , f . cause ( ) ) ; } } } } for ( ChannelHandler h : clientHandlers ) { if ( h instanceof ProxyHandler ) { ProxyHandler ph = ( ProxyHandler ) h ; assertThat ( ph . connectFuture ( ) . isDone ( ) , is ( true ) ) ; assertThat ( ph . connectFuture ( ) . isSuccess ( ) , is ( success ) ) ; } } } @Override public String toString ( ) { return name ; } } private static final class SuccessTestItem extends TestItem { private final int expectedEventCount ; SuccessTestItem ( String name , InetSocketAddress destination , ChannelHandler . . . clientHandlers ) { super ( name , destination , clientHandlers ) ; int expectedEventCount = <int> ; for ( ChannelHandler h : clientHandlers ) { if ( h instanceof ProxyHandler ) { expectedEventCount + + ; } } this . expectedEventCount = expectedEventCount ; } @Override protected void test ( ) throws Exception { final SuccessTestHandler testHandler = new SuccessTestHandler ( ) ; Bootstrap b = new Bootstrap ( ) ; b . group ( group ) ; b . channel ( NioSocketChannel . class ) ; b . resolver ( NoopNameResolverGroup . INSTANCE ) ; b . handler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( clientHandlers ) ; p . addLast ( new LineBasedFrameDecoder ( <int> ) ) ; p . addLast ( testHandler ) ; } } ) ; boolean finished = b . connect ( destination ) . channel ( ) . closeFuture ( ) . await ( <int> , TimeUnit . SECONDS ) ; logger . debug ( <str> , testHandler . received ) ; if ( testHandler . exceptions . isEmpty ( ) ) { logger . debug ( <str> ) ; } else { for ( Throwable t : testHandler . exceptions ) { logger . debug ( <str> , t ) ; } } assertProxyHandlers ( true ) ; assertThat ( testHandler . received . toArray ( ) , is ( new Object [ ] { <str> , <str> , <str> , <str> } ) ) ; assertThat ( testHandler . exceptions . toArray ( ) , is ( EmptyArrays . EMPTY_OBJECTS ) ) ; assertThat ( testHandler . eventCount , is ( expectedEventCount ) ) ; assertThat ( finished , is ( true ) ) ; } } private static final class FailureTestItem extends TestItem { private final String expectedMessage ; FailureTestItem ( String name , InetSocketAddress destination , String expectedMessage , ChannelHandler . . . clientHandlers ) { super ( name , destination , clientHandlers ) ; this . expectedMessage = expectedMessage ; } @Override protected void test ( ) throws Exception { final FailureTestHandler testHandler = new FailureTestHandler ( ) ; Bootstrap b = new Bootstrap ( ) ; b . group ( group ) ; b . channel ( NioSocketChannel . class ) ; b . resolver ( NoopNameResolverGroup . INSTANCE ) ; b . handler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( clientHandlers ) ; p . addLast ( new LineBasedFrameDecoder ( <int> ) ) ; p . addLast ( testHandler ) ; } } ) ; boolean finished = b . connect ( destination ) . channel ( ) . closeFuture ( ) . await ( <int> , TimeUnit . SECONDS ) ; finished & = testHandler . latch . await ( <int> , TimeUnit . SECONDS ) ; logger . debug ( <str> , testHandler . exceptions ) ; assertProxyHandlers ( false ) ; assertThat ( testHandler . exceptions . size ( ) , is ( <int> ) ) ; Throwable e = testHandler . exceptions . poll ( ) ; assertThat ( e , is ( instanceOf ( ProxyConnectException . class ) ) ) ; assertThat ( String . valueOf ( e ) , containsString ( expectedMessage ) ) ; assertThat ( finished , is ( true ) ) ; } } private static final class TimeoutTestItem extends TestItem { TimeoutTestItem ( String name , ChannelHandler . . . clientHandlers ) { super ( name , null , clientHandlers ) ; } @Override protected void test ( ) throws Exception { final long TIMEOUT = <int> ; for ( ChannelHandler h : clientHandlers ) { if ( h instanceof ProxyHandler ) { ( ( ProxyHandler ) h ) . setConnectTimeoutMillis ( TIMEOUT ) ; } } final FailureTestHandler testHandler = new FailureTestHandler ( ) ; Bootstrap b = new Bootstrap ( ) ; b . group ( group ) ; b . channel ( NioSocketChannel . class ) ; b . resolver ( NoopNameResolverGroup . INSTANCE ) ; b . handler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( clientHandlers ) ; p . addLast ( new LineBasedFrameDecoder ( <int> ) ) ; p . addLast ( testHandler ) ; } } ) ; ChannelFuture cf = b . connect ( DESTINATION ) . channel ( ) . closeFuture ( ) ; boolean finished = cf . await ( TIMEOUT * <int> , TimeUnit . MILLISECONDS ) ; finished & = testHandler . latch . await ( TIMEOUT * <int> , TimeUnit . MILLISECONDS ) ; logger . debug ( <str> , testHandler . exceptions ) ; assertProxyHandlers ( false ) ; assertThat ( testHandler . exceptions . size ( ) , is ( <int> ) ) ; Throwable e = testHandler . exceptions . poll ( ) ; assertThat ( e , is ( instanceOf ( ProxyConnectException . class ) ) ) ; assertThat ( String . valueOf ( e ) , containsString ( <str> ) ) ; assertThat ( finished , is ( true ) ) ; } } } 
