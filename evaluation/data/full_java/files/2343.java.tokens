package org . nd4j . bytebuddy . shape ; import net . bytebuddy . ByteBuddy ; import net . bytebuddy . dynamic . DynamicType ; import net . bytebuddy . dynamic . loading . ClassLoadingStrategy ; import net . bytebuddy . implementation . Implementation ; import net . bytebuddy . implementation . bytecode . StackManipulation ; import net . bytebuddy . implementation . bytecode . constant . IntegerConstant ; import net . bytebuddy . implementation . bytecode . member . MethodReturn ; import net . bytebuddy . implementation . bytecode . member . MethodVariableAccess ; import net . bytebuddy . jar . asm . Label ; import net . bytebuddy . matcher . ElementMatchers ; import org . nd4j . bytebuddy . arithmetic . ByteBuddyIntArithmetic ; import org . nd4j . bytebuddy . arithmetic . stackmanipulation . OpStackManipulation ; import org . nd4j . bytebuddy . arrays . create . stackmanipulation . CreateIntArrayStackManipulation ; import org . nd4j . bytebuddy . arrays . stackmanipulation . ArrayStackManipulation ; import org . nd4j . bytebuddy . branching . stackmanipulation . IfeqNotEquals ; import org . nd4j . bytebuddy . frame . VisitFrameFullInt ; import org . nd4j . bytebuddy . frame . VisitFrameSameInt ; import org . nd4j . bytebuddy . gotoop . GoToOp ; import org . nd4j . bytebuddy . labelvisit . LabelVisitorStackManipulation ; import org . nd4j . bytebuddy . stackmanipulation . StackManipulationImplementation ; import org . nd4j . bytebuddy . storeint . stackmanipulation . StoreIntStackManipulation ; import org . nd4j . bytebuddy . storeref . stackmanipulation . StoreRefStackManipulation ; import java . util . ArrayList ; import java . util . List ; public class ShapeMapper { public static IndexMapper getInd2SubInstance ( char ordering , int rank ) { Implementation impl = ShapeMapper . getInd2Sub ( ordering , rank ) ; DynamicType . Unloaded < IndexMapper > c = new ByteBuddy ( ) . subclass ( IndexMapper . class ) . method ( ElementMatchers . isDeclaredBy ( IndexMapper . class ) ) . intercept ( impl ) . make ( ) ; Class < IndexMapper > dynamicType = ( Class < IndexMapper > ) c . load ( IndexMapper . class . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) ; try { return dynamicType . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> + rank ) ; } } public static OffsetMapper getOffsetMapperInstance ( int rank ) { Implementation impl = ShapeMapper . getOffsetMapper ( rank ) ; DynamicType . Unloaded < OffsetMapper > c = new ByteBuddy ( ) . subclass ( OffsetMapper . class ) . method ( ElementMatchers . isDeclaredBy ( OffsetMapper . class ) ) . intercept ( impl ) . make ( ) ; Class < OffsetMapper > dynamicType = ( Class < OffsetMapper > ) c . load ( OffsetMapper . class . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) ; try { return dynamicType . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> + rank ) ; } } public static Implementation getOffsetMapper ( int rank ) { int startOffsetIndex = <int> ; int shapeIndex = <int> ; int strideIndex = <int> ; int indicesIndex = <int> ; List < StackManipulation > impls = new ArrayList < > ( ) ; for ( int i = <int> ; i < rank ; i + + ) { Label label = new Label ( ) ; Label goToLabel = new Label ( ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( startOffsetIndex ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( shapeIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( ArrayStackManipulation . load ( ) ) ; impls . add ( new IfeqNotEquals ( label ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( strideIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( ArrayStackManipulation . load ( ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( indicesIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( ArrayStackManipulation . load ( ) ) ; impls . add ( ByteBuddyIntArithmetic . IntegerMultiplication . INSTANCE ) ; impls . add ( new GoToOp ( goToLabel ) ) ; impls . add ( new LabelVisitorStackManipulation ( label ) ) ; impls . add ( new VisitFrameSameInt ( <int> , <int> ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( new LabelVisitorStackManipulation ( goToLabel ) ) ; impls . add ( new VisitFrameFullInt ( <int> , <int> ) ) ; impls . add ( ByteBuddyIntArithmetic . IntegerAddition . INSTANCE ) ; impls . add ( new StoreIntStackManipulation ( startOffsetIndex ) ) ; } impls . add ( MethodVariableAccess . INTEGER . loadOffset ( startOffsetIndex ) ) ; impls . add ( MethodReturn . INTEGER ) ; return new StackManipulationImplementation ( new StackManipulation . Compound ( impls . toArray ( new StackManipulation [ impls . size ( ) ] ) ) ) ; } public static Implementation getInd2Sub ( char ordering , int rank ) { int retArrayIndex = <int> ; int linearIndexArg = <int> ; int totalindexarg = <int> ; int arrayArgIndex = <int> ; List < StackManipulation > impls = new ArrayList < > ( ) ; impls . add ( IntegerConstant . forValue ( rank ) ) ; impls . add ( new CreateIntArrayStackManipulation ( ) ) ; impls . add ( new StoreRefStackManipulation ( retArrayIndex ) ) ; if ( ordering = = <str> ) { for ( int i = rank - <int> ; i > = <int> ; i - - ) { impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( arrayArgIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( ArrayStackManipulation . load ( ) ) ; impls . add ( OpStackManipulation . div ( ) ) ; impls . add ( new StoreIntStackManipulation ( totalindexarg ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( retArrayIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( linearIndexArg ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( OpStackManipulation . div ( ) ) ; impls . add ( ArrayStackManipulation . store ( ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( linearIndexArg ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( OpStackManipulation . mod ( ) ) ; impls . add ( new StoreIntStackManipulation ( linearIndexArg ) ) ; } } else { for ( int i = <int> ; i < rank ; i + + ) { impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( arrayArgIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( ArrayStackManipulation . load ( ) ) ; impls . add ( OpStackManipulation . div ( ) ) ; impls . add ( new StoreIntStackManipulation ( totalindexarg ) ) ; impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( retArrayIndex ) ) ; impls . add ( IntegerConstant . forValue ( i ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( linearIndexArg ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( OpStackManipulation . div ( ) ) ; impls . add ( ArrayStackManipulation . store ( ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( linearIndexArg ) ) ; impls . add ( MethodVariableAccess . INTEGER . loadOffset ( totalindexarg ) ) ; impls . add ( OpStackManipulation . mod ( ) ) ; impls . add ( new StoreIntStackManipulation ( linearIndexArg ) ) ; } } impls . add ( MethodVariableAccess . REFERENCE . loadOffset ( retArrayIndex ) ) ; impls . add ( MethodReturn . REFERENCE ) ; return new StackManipulationImplementation ( new StackManipulation . Compound ( impls . toArray ( new StackManipulation [ impls . size ( ) ] ) ) ) ; } } 
