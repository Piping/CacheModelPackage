package io . netty . buffer ; import org . junit . Test ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ReadOnlyBufferException ; import java . nio . channels . ScatteringByteChannel ; import java . nio . charset . Charset ; import static io . netty . buffer . Unpooled . * ; import static io . netty . util . ReferenceCountUtil . * ; import static org . junit . Assert . * ; public class FixedCompositeByteBufTest { private static ByteBuf newBuffer ( ByteBuf . . . buffers ) { return releaseLater ( new FixedCompositeByteBuf ( UnpooledByteBufAllocator . DEFAULT , buffers ) ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetBoolean ( ) { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setBoolean ( <int> , true ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetByte ( ) { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setByte ( <int> , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetBytesWithByteBuf ( ) { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setBytes ( <int> , wrappedBuffer ( new byte [ <int> ] ) ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetBytesWithByteBuffer ( ) { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setBytes ( <int> , ByteBuffer . wrap ( new byte [ <int> ] ) ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetBytesWithInputStream ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setBytes ( <int> , new ByteArrayInputStream ( new byte [ <int> ] ) , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetBytesWithChannel ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setBytes ( <int> , new ScatteringByteChannel ( ) { @Override public long read ( ByteBuffer [ ] dsts , int offset , int length ) { return <int> ; } @Override public long read ( ByteBuffer [ ] dsts ) { return <int> ; } @Override public int read ( ByteBuffer dst ) { return <int> ; } @Override public boolean isOpen ( ) { return true ; } @Override public void close ( ) { } } , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetChar ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setChar ( <int> , <str> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetDouble ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setDouble ( <int> , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetFloat ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setFloat ( <int> , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetInt ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setInt ( <int> , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetLong ( ) { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setLong ( <int> , <int> ) ; } @Test ( expected = ReadOnlyBufferException . class ) public void testSetMedium ( ) throws IOException { ByteBuf buf = newBuffer ( wrappedBuffer ( new byte [ <int> ] ) ) ; buf . setMedium ( <int> , <int> ) ; } @Test public void testGatheringWritesHeap ( ) throws Exception { testGatheringWrites ( buffer ( ) , buffer ( ) ) ; } @Test public void testGatheringWritesDirect ( ) throws Exception { testGatheringWrites ( directBuffer ( ) , directBuffer ( ) ) ; } @Test public void testGatheringWritesMixes ( ) throws Exception { testGatheringWrites ( buffer ( ) , directBuffer ( ) ) ; } @Test public void testGatheringWritesHeapPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) , PooledByteBufAllocator . DEFAULT . heapBuffer ( ) ) ; } @Test public void testGatheringWritesDirectPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . directBuffer ( ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) ) ; } @Test public void testGatheringWritesMixesPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) ) ; } private static void testGatheringWrites ( ByteBuf buf1 , ByteBuf buf2 ) throws Exception { CompositeByteBuf buf = compositeBuffer ( ) ; buf . addComponent ( buf1 . writeBytes ( new byte [ ] { <int> , <int> } ) ) ; buf . addComponent ( buf2 . writeBytes ( new byte [ ] { <int> , <int> } ) ) ; buf . writerIndex ( <int> ) ; buf . readerIndex ( <int> ) ; AbstractByteBufTest . TestGatheringByteChannel channel = new AbstractByteBufTest . TestGatheringByteChannel ( ) ; buf . readBytes ( channel , <int> ) ; byte [ ] data = new byte [ <int> ] ; buf . getBytes ( <int> , data ) ; buf . release ( ) ; assertArrayEquals ( data , channel . writtenBytes ( ) ) ; } @Test public void testGatheringWritesPartialHeap ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) , buffer ( ) ) ; } @Test public void testGatheringWritesPartialDirect ( ) throws Exception { testGatheringWritesPartial ( directBuffer ( ) , directBuffer ( ) ) ; } @Test public void testGatheringWritesPartialMixes ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) , directBuffer ( ) ) ; } @Test public void testGatheringWritesPartialHeapPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) , PooledByteBufAllocator . DEFAULT . heapBuffer ( ) ) ; } @Test public void testGatheringWritesPartialDirectPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . directBuffer ( ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) ) ; } @Test public void testGatheringWritesPartialMixesPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) ) ; } private static void testGatheringWritesPartial ( ByteBuf buf1 , ByteBuf buf2 ) throws Exception { buf1 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; buf2 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; ByteBuf buf = newBuffer ( buf1 , buf2 ) ; AbstractByteBufTest . TestGatheringByteChannel channel = new AbstractByteBufTest . TestGatheringByteChannel ( <int> ) ; while ( buf . isReadable ( ) ) { buf . readBytes ( channel , buf . readableBytes ( ) ) ; } byte [ ] data = new byte [ <int> ] ; buf . getBytes ( <int> , data ) ; assertArrayEquals ( data , channel . writtenBytes ( ) ) ; buf . release ( ) ; } @Test public void testGatheringWritesSingleHeap ( ) throws Exception { testGatheringWritesSingleBuf ( buffer ( ) ) ; } @Test public void testGatheringWritesSingleDirect ( ) throws Exception { testGatheringWritesSingleBuf ( directBuffer ( ) ) ; } private static void testGatheringWritesSingleBuf ( ByteBuf buf1 ) throws Exception { ByteBuf buf = newBuffer ( buf1 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ) ; buf . readerIndex ( <int> ) ; AbstractByteBufTest . TestGatheringByteChannel channel = new AbstractByteBufTest . TestGatheringByteChannel ( ) ; buf . readBytes ( channel , <int> ) ; byte [ ] data = new byte [ <int> ] ; buf . getBytes ( <int> , data ) ; assertArrayEquals ( data , channel . writtenBytes ( ) ) ; buf . release ( ) ; } @Test public void testCopyingToOtherBuffer ( ) { ByteBuf buf1 = directBuffer ( <int> ) ; ByteBuf buf2 = buffer ( <int> ) ; ByteBuf buf3 = directBuffer ( <int> ) ; buf1 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf2 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf3 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; ByteBuf composite = unmodifiableBuffer ( buf1 , buf2 , buf3 ) ; ByteBuf copy = directBuffer ( <int> ) ; ByteBuf copy2 = buffer ( <int> ) ; copy . setBytes ( <int> , composite , <int> , <int> ) ; copy2 . setBytes ( <int> , composite , <int> , <int> ) ; copy . writerIndex ( <int> ) ; copy2 . writerIndex ( <int> ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy , composite ) ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy2 , composite ) ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy , copy2 ) ) ; copy . release ( ) ; copy2 . release ( ) ; composite . release ( ) ; } @Test public void testCopyingToOutputStream ( ) throws IOException { ByteBuf buf1 = directBuffer ( <int> ) ; ByteBuf buf2 = buffer ( <int> ) ; ByteBuf buf3 = directBuffer ( <int> ) ; buf1 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf2 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf3 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; ByteBuf composite = unmodifiableBuffer ( buf1 , buf2 , buf3 ) ; ByteBuf copy = directBuffer ( <int> ) ; ByteBuf copy2 = buffer ( <int> ) ; composite . getBytes ( <int> , new ByteBufOutputStream ( copy ) , <int> ) ; composite . getBytes ( <int> , new ByteBufOutputStream ( copy2 ) , <int> ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy , composite ) ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy2 , composite ) ) ; assertEquals ( <int> , ByteBufUtil . compare ( copy , copy2 ) ) ; copy . release ( ) ; copy2 . release ( ) ; composite . release ( ) ; } @Test public void testExtractNioBuffers ( ) { ByteBuf buf1 = directBuffer ( <int> ) ; ByteBuf buf2 = buffer ( <int> ) ; ByteBuf buf3 = directBuffer ( <int> ) ; buf1 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf2 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; buf3 . writeBytes ( <str> . getBytes ( Charset . defaultCharset ( ) ) ) ; ByteBuf composite = unmodifiableBuffer ( buf1 , buf2 , buf3 ) ; ByteBuffer [ ] byteBuffers = composite . nioBuffers ( <int> , <int> ) ; assertEquals ( <int> , byteBuffers . length ) ; assertEquals ( <int> , byteBuffers [ <int> ] . limit ( ) ) ; assertEquals ( <int> , byteBuffers [ <int> ] . limit ( ) ) ; assertEquals ( <int> , byteBuffers [ <int> ] . limit ( ) ) ; composite . release ( ) ; } } 
