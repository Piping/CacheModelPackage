package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . Objects ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . ObjectSizes ; public abstract class AbstractClusteringPrefix implements ClusteringPrefix { protected static final ByteBuffer [ ] EMPTY_VALUES_ARRAY = new ByteBuffer [ <int> ] ; private static final long EMPTY_SIZE = ObjectSizes . measure ( new Clustering ( EMPTY_VALUES_ARRAY ) ) ; protected final Kind kind ; protected final ByteBuffer [ ] values ; protected AbstractClusteringPrefix ( Kind kind , ByteBuffer [ ] values ) { this . kind = kind ; this . values = values ; } public Kind kind ( ) { return kind ; } public ClusteringPrefix clustering ( ) { return this ; } public int size ( ) { return values . length ; } public ByteBuffer get ( int i ) { return values [ i ] ; } public ByteBuffer [ ] getRawValues ( ) { return values ; } public int dataSize ( ) { int size = <int> ; for ( int i = <int> ; i < size ( ) ; i + + ) { ByteBuffer bb = get ( i ) ; size + = bb = = null ? <int> : bb . remaining ( ) ; } return size ; } public void digest ( MessageDigest digest ) { for ( int i = <int> ; i < size ( ) ; i + + ) { ByteBuffer bb = get ( i ) ; if ( bb ! = null ) digest . update ( bb . duplicate ( ) ) ; } FBUtilities . updateWithByte ( digest , kind ( ) . ordinal ( ) ) ; } public long unsharedHeapSize ( ) { return EMPTY_SIZE + ObjectSizes . sizeOnHeapOf ( values ) ; } public long unsharedHeapSizeExcludingData ( ) { return EMPTY_SIZE + ObjectSizes . sizeOnHeapExcludingData ( values ) ; } @Override public final int hashCode ( ) { int result = <int> ; for ( int i = <int> ; i < size ( ) ; i + + ) result + = <int> * Objects . hashCode ( get ( i ) ) ; return <int> * result + Objects . hashCode ( kind ( ) ) ; } @Override public final boolean equals ( Object o ) { if ( ! ( o instanceof ClusteringPrefix ) ) return false ; ClusteringPrefix that = ( ClusteringPrefix ) o ; if ( this . kind ( ) ! = that . kind ( ) | | this . size ( ) ! = that . size ( ) ) return false ; for ( int i = <int> ; i < size ( ) ; i + + ) if ( ! Objects . equals ( this . get ( i ) , that . get ( i ) ) ) return false ; return true ; } } 
