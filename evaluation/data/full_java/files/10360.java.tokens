package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableBiMap . Builder ; import com . google . common . collect . testing . MapInterfaceTest ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . BiMapGenerators . ImmutableBiMapCopyOfEntriesGenerator ; import com . google . common . collect . testing . google . BiMapGenerators . ImmutableBiMapCopyOfGenerator ; import com . google . common . collect . testing . google . BiMapGenerators . ImmutableBiMapGenerator ; import com . google . common . collect . testing . google . BiMapInverseTester ; import com . google . common . collect . testing . google . BiMapTestSuiteBuilder ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; @GwtCompatible ( emulated = true ) public class ImmutableBiMapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( MapTests . class ) ; suite . addTestSuite ( InverseMapTests . class ) ; suite . addTestSuite ( CreationTests . class ) ; suite . addTestSuite ( BiMapSpecificTests . class ) ; suite . addTest ( BiMapTestSuiteBuilder . using ( new ImmutableBiMapGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . KNOWN_ORDER , MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . suppressing ( BiMapInverseTester . getInverseSameAfterSerializingMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( BiMapTestSuiteBuilder . using ( new ImmutableBiMapCopyOfGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . KNOWN_ORDER , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . suppressing ( BiMapInverseTester . getInverseSameAfterSerializingMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( BiMapTestSuiteBuilder . using ( new ImmutableBiMapCopyOfEntriesGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . KNOWN_ORDER , MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . suppressing ( BiMapInverseTester . getInverseSameAfterSerializingMethods ( ) ) . createTestSuite ( ) ) ; return suite ; } public static abstract class AbstractMapTests < K , V > extends MapInterfaceTest < K , V > { public AbstractMapTests ( ) { super ( false , false , false , false , false ) ; } @Override protected Map < K , V > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } private static final Joiner joiner = Joiner . on ( <str> ) ; @Override protected void assertMoreInvariants ( Map < K , V > map ) { BiMap < K , V > bimap = ( BiMap < K , V > ) map ; for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( entry . getKey ( ) + <str> + entry . getValue ( ) , entry . toString ( ) ) ; assertEquals ( entry . getKey ( ) , bimap . inverse ( ) . get ( entry . getValue ( ) ) ) ; } assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . entrySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . keySet ( ) ) + <str> , map . keySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . values ( ) ) + <str> , map . values ( ) . toString ( ) ) ; assertEquals ( Sets . newHashSet ( map . entrySet ( ) ) , map . entrySet ( ) ) ; assertEquals ( Sets . newHashSet ( map . keySet ( ) ) , map . keySet ( ) ) ; } } public static class MapTests extends AbstractMapTests < String , Integer > { @Override protected Map < String , Integer > makeEmptyMap ( ) { return ImmutableBiMap . of ( ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class InverseMapTests extends AbstractMapTests < String , Integer > { @Override protected Map < String , Integer > makeEmptyMap ( ) { return ImmutableBiMap . of ( ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableBiMap . of ( <int> , <str> , <int> , <str> , <int> , <str> ) . inverse ( ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class CreationTests extends TestCase { public void testEmptyBuilder ( ) { ImmutableBiMap < String , Integer > map = new Builder < String , Integer > ( ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; assertEquals ( Collections . < Integer , String > emptyMap ( ) , map . inverse ( ) ) ; assertSame ( ImmutableBiMap . of ( ) , map ) ; } public void testSingletonBuilder ( ) { ImmutableBiMap < String , Integer > map = new Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; assertMapEquals ( map . inverse ( ) , <int> , <str> ) ; } public void testBuilder_withImmutableEntry ( ) { ImmutableBiMap < String , Integer > map = new Builder < String , Integer > ( ) . put ( Maps . immutableEntry ( <str> , <int> ) ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; } public void testBuilder ( ) { ImmutableBiMap < String , Integer > map = ImmutableBiMap . < String , Integer > builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( map . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testBuilder_orderEntriesByValue ( ) { ImmutableBiMap < String , Integer > map = ImmutableBiMap . < String , Integer > builder ( ) . orderEntriesByValue ( Ordering . natural ( ) ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( map . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testBuilder_orderEntriesByValueAfterExactSizeBuild ( ) { ImmutableBiMap . Builder < String , Integer > builder = new ImmutableBiMap . Builder < String , Integer > ( <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; ImmutableMap < String , Integer > keyOrdered = builder . build ( ) ; ImmutableMap < String , Integer > valueOrdered = builder . orderEntriesByValue ( Ordering . natural ( ) ) . build ( ) ; assertMapEquals ( keyOrdered , <str> , <int> , <str> , <int> ) ; assertMapEquals ( valueOrdered , <str> , <int> , <str> , <int> ) ; } public void testBuilder_orderEntriesByValue_usedTwiceFails ( ) { ImmutableBiMap . Builder < String , Integer > builder = new Builder < String , Integer > ( ) . orderEntriesByValue ( Ordering . natural ( ) ) ; try { builder . orderEntriesByValue ( Ordering . natural ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testBuilderPutAllWithEmptyMap ( ) { ImmutableBiMap < String , Integer > map = new Builder < String , Integer > ( ) . putAll ( Collections . < String , Integer > emptyMap ( ) ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; } public void testBuilderPutAll ( ) { Map < String , Integer > toPut = new LinkedHashMap < String , Integer > ( ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; Map < String , Integer > moreToPut = new LinkedHashMap < String , Integer > ( ) ; moreToPut . put ( <str> , <int> ) ; moreToPut . put ( <str> , <int> ) ; ImmutableBiMap < String , Integer > map = new Builder < String , Integer > ( ) . putAll ( toPut ) . putAll ( moreToPut ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( map . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testBuilderReuse ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; ImmutableBiMap < String , Integer > mapOne = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; ImmutableBiMap < String , Integer > mapTwo = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( mapOne , <str> , <int> , <str> , <int> ) ; assertMapEquals ( mapOne . inverse ( ) , <int> , <str> , <int> , <str> ) ; assertMapEquals ( mapTwo , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( mapTwo . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testBuilderPutNullKey ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValue ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullKeyViaPutAll ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValueViaPutAll ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( <str> , null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testPuttingTheSameKeyTwiceThrowsOnBuild ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; try { builder . build ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> ) ; } } public void testOf ( ) { assertMapEquals ( ImmutableBiMap . of ( <str> , <int> ) , <str> , <int> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> ) . inverse ( ) , <int> , <str> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> ) . inverse ( ) , <int> , <str> , <int> , <str> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableBiMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testOfNullKey ( ) { try { ImmutableBiMap . of ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableBiMap . of ( <str> , <int> , null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfNullValue ( ) { try { ImmutableBiMap . of ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableBiMap . of ( <str> , <int> , <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfWithDuplicateKey ( ) { try { ImmutableBiMap . of ( <str> , <int> , <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> ) ; } } public void testCopyOfEmptyMap ( ) { ImmutableBiMap < String , Integer > copy = ImmutableBiMap . copyOf ( Collections . < String , Integer > emptyMap ( ) ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , copy ) ; assertSame ( copy , ImmutableBiMap . copyOf ( copy ) ) ; assertSame ( ImmutableBiMap . of ( ) , copy ) ; } public void testCopyOfSingletonMap ( ) { ImmutableBiMap < String , Integer > copy = ImmutableBiMap . copyOf ( Collections . singletonMap ( <str> , <int> ) ) ; assertMapEquals ( copy , <str> , <int> ) ; assertSame ( copy , ImmutableBiMap . copyOf ( copy ) ) ; } public void testCopyOf ( ) { Map < String , Integer > original = new LinkedHashMap < String , Integer > ( ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableBiMap < String , Integer > copy = ImmutableBiMap . copyOf ( original ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableBiMap . copyOf ( copy ) ) ; } public void testEmpty ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . of ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , bimap ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , bimap . inverse ( ) ) ; } public void testFromHashMap ( ) { Map < String , Integer > hashMap = Maps . newLinkedHashMap ( ) ; hashMap . put ( <str> , <int> ) ; hashMap . put ( <str> , <int> ) ; ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) ) ; assertMapEquals ( bimap , <str> , <int> , <str> , <int> ) ; assertMapEquals ( bimap . inverse ( ) , <int> , <str> , <int> , <str> ) ; } public void testFromImmutableMap ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( new ImmutableMap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ) ; assertMapEquals ( bimap , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( bimap . inverse ( ) , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> ) ; } public void testDuplicateValues ( ) { ImmutableMap < String , Integer > map = new ImmutableMap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; try { ImmutableBiMap . copyOf ( map ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> ) ; } } } public static class BiMapSpecificTests extends TestCase { @SuppressWarnings ( <str> ) public void testForcePut ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) ) ; try { bimap . forcePut ( <str> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testKeySet ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Set < String > keys = bimap . keySet ( ) ; assertEquals ( Sets . newHashSet ( <str> , <str> , <str> , <str> ) , keys ) ; assertThat ( keys ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testValues ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Set < Integer > values = bimap . values ( ) ; assertEquals ( Sets . newHashSet ( <int> , <int> , <int> , <int> ) , values ) ; assertThat ( values ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testDoubleInverse ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) ) ; assertSame ( bimap , bimap . inverse ( ) . inverse ( ) ) ; } @GwtIncompatible ( <str> ) public void testEmptySerialization ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . of ( ) ; assertSame ( bimap , SerializableTester . reserializeAndAssert ( bimap ) ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) ) ; ImmutableBiMap < String , Integer > copy = SerializableTester . reserializeAndAssert ( bimap ) ; assertEquals ( Integer . valueOf ( <int> ) , copy . get ( <str> ) ) ; assertEquals ( <str> , copy . inverse ( ) . get ( <int> ) ) ; assertSame ( copy , copy . inverse ( ) . inverse ( ) ) ; } @GwtIncompatible ( <str> ) public void testInverseSerialization ( ) { ImmutableBiMap < String , Integer > bimap = ImmutableBiMap . copyOf ( ImmutableMap . of ( <int> , <str> , <int> , <str> ) ) . inverse ( ) ; ImmutableBiMap < String , Integer > copy = SerializableTester . reserializeAndAssert ( bimap ) ; assertEquals ( Integer . valueOf ( <int> ) , copy . get ( <str> ) ) ; assertEquals ( <str> , copy . inverse ( ) . get ( <int> ) ) ; assertSame ( copy , copy . inverse ( ) . inverse ( ) ) ; } } private static < K , V > void assertMapEquals ( Map < K , V > map , Object . . . alternatingKeysAndValues ) { int i = <int> ; for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getKey ( ) ) ; assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getValue ( ) ) ; } } } 
