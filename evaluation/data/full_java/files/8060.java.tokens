package org . elasticsearch . http . netty ; import org . elasticsearch . cache . recycler . MockPageCacheRecycler ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . util . MockBigArrays ; import org . elasticsearch . http . HttpServerTransport ; import org . elasticsearch . http . netty . NettyHttpServerTransport . HttpChannelPipelineFactory ; import org . elasticsearch . http . netty . pipelining . OrderedDownstreamChannelEvent ; import org . elasticsearch . http . netty . pipelining . OrderedUpstreamMessageEvent ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . ChannelPipeline ; import org . jboss . netty . channel . ChannelPipelineFactory ; import org . jboss . netty . channel . ExceptionEvent ; import org . jboss . netty . channel . MessageEvent ; import org . jboss . netty . channel . SimpleChannelUpstreamHandler ; import org . jboss . netty . handler . codec . http . DefaultHttpResponse ; import org . jboss . netty . handler . codec . http . HttpRequest ; import org . jboss . netty . handler . codec . http . HttpResponse ; import org . jboss . netty . handler . codec . http . QueryStringDecoder ; import org . junit . After ; import org . junit . Before ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . http . netty . NettyHttpClient . returnHttpResponseBodies ; import static org . hamcrest . Matchers . contains ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; import static org . jboss . netty . handler . codec . http . HttpHeaders . Names . CONTENT_LENGTH ; import static org . jboss . netty . handler . codec . http . HttpResponseStatus . OK ; import static org . jboss . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; public class NettyHttpServerPipeliningTests extends ESTestCase { private NetworkService networkService ; private ThreadPool threadPool ; private MockPageCacheRecycler mockPageCacheRecycler ; private MockBigArrays bigArrays ; private CustomNettyHttpServerTransport httpServerTransport ; @Before public void setup ( ) throws Exception { networkService = new NetworkService ( Settings . EMPTY ) ; threadPool = new ThreadPool ( <str> ) ; mockPageCacheRecycler = new MockPageCacheRecycler ( Settings . EMPTY , threadPool ) ; bigArrays = new MockBigArrays ( mockPageCacheRecycler , new NoneCircuitBreakerService ( ) ) ; } @After public void shutdown ( ) throws Exception { if ( threadPool ! = null ) { threadPool . shutdownNow ( ) ; } if ( httpServerTransport ! = null ) { httpServerTransport . close ( ) ; } } public void testThatHttpPipeliningWorksWhenEnabled ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , true ) . put ( <str> , <str> ) . build ( ) ; httpServerTransport = new CustomNettyHttpServerTransport ( settings ) ; httpServerTransport . start ( ) ; InetSocketTransportAddress transportAddress = ( InetSocketTransportAddress ) randomFrom ( httpServerTransport . boundAddress ( ) . boundAddresses ( ) ) ; List < String > requests = Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ; try ( NettyHttpClient nettyHttpClient = new NettyHttpClient ( ) ) { Collection < HttpResponse > responses = nettyHttpClient . sendRequests ( transportAddress . address ( ) , requests . toArray ( new String [ ] { } ) ) ; Collection < String > responseBodies = returnHttpResponseBodies ( responses ) ; assertThat ( responseBodies , contains ( <str> , <str> , <str> , <str> , <str> ) ) ; } } public void testThatHttpPipeliningCanBeDisabled ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , false ) . put ( <str> , <str> ) . build ( ) ; httpServerTransport = new CustomNettyHttpServerTransport ( settings ) ; httpServerTransport . start ( ) ; InetSocketTransportAddress transportAddress = ( InetSocketTransportAddress ) randomFrom ( httpServerTransport . boundAddress ( ) . boundAddresses ( ) ) ; List < String > requests = Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ; try ( NettyHttpClient nettyHttpClient = new NettyHttpClient ( ) ) { Collection < HttpResponse > responses = nettyHttpClient . sendRequests ( transportAddress . address ( ) , requests . toArray ( new String [ ] { } ) ) ; List < String > responseBodies = new ArrayList < > ( returnHttpResponseBodies ( responses ) ) ; assertThat ( responseBodies , hasSize ( <int> ) ) ; assertThat ( responseBodies . get ( <int> ) , is ( <str> ) ) ; assertThat ( responseBodies . get ( <int> ) , is ( <str> ) ) ; } } class CustomNettyHttpServerTransport extends NettyHttpServerTransport { private final ExecutorService executorService ; public CustomNettyHttpServerTransport ( Settings settings ) { super ( settings , NettyHttpServerPipeliningTests . this . networkService , NettyHttpServerPipeliningTests . this . bigArrays ) ; this . executorService = Executors . newFixedThreadPool ( <int> ) ; } @Override public ChannelPipelineFactory configureServerChannelPipelineFactory ( ) { return new CustomHttpChannelPipelineFactory ( this , executorService ) ; } @Override public HttpServerTransport stop ( ) { executorService . shutdownNow ( ) ; return super . stop ( ) ; } } private class CustomHttpChannelPipelineFactory extends HttpChannelPipelineFactory { private final ExecutorService executorService ; public CustomHttpChannelPipelineFactory ( NettyHttpServerTransport transport , ExecutorService executorService ) { super ( transport , randomBoolean ( ) ) ; this . executorService = executorService ; } @Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline pipeline = super . getPipeline ( ) ; pipeline . replace ( <str> , <str> , new PossiblySlowUpstreamHandler ( executorService ) ) ; return pipeline ; } } class PossiblySlowUpstreamHandler extends SimpleChannelUpstreamHandler { private final ExecutorService executorService ; public PossiblySlowUpstreamHandler ( ExecutorService executorService ) { this . executorService = executorService ; } @Override public void messageReceived ( final ChannelHandlerContext ctx , final MessageEvent e ) throws Exception { executorService . submit ( new PossiblySlowRunnable ( ctx , e ) ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) { e . getCause ( ) . printStackTrace ( ) ; e . getChannel ( ) . close ( ) ; } } class PossiblySlowRunnable implements Runnable { private ChannelHandlerContext ctx ; private MessageEvent e ; public PossiblySlowRunnable ( ChannelHandlerContext ctx , MessageEvent e ) { this . ctx = ctx ; this . e = e ; } @Override public void run ( ) { HttpRequest request ; OrderedUpstreamMessageEvent oue = null ; if ( e instanceof OrderedUpstreamMessageEvent ) { oue = ( OrderedUpstreamMessageEvent ) e ; request = ( HttpRequest ) oue . getMessage ( ) ; } else { request = ( HttpRequest ) e . getMessage ( ) ; } ChannelBuffer buffer = ChannelBuffers . copiedBuffer ( request . getUri ( ) , StandardCharsets . UTF_8 ) ; DefaultHttpResponse httpResponse = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; httpResponse . headers ( ) . add ( CONTENT_LENGTH , buffer . readableBytes ( ) ) ; httpResponse . setContent ( buffer ) ; QueryStringDecoder decoder = new QueryStringDecoder ( request . getUri ( ) ) ; final int timeout = request . getUri ( ) . startsWith ( <str> ) & & decoder . getParameters ( ) . containsKey ( <str> ) ? Integer . valueOf ( decoder . getParameters ( ) . get ( <str> ) . get ( <int> ) ) : <int> ; if ( timeout > <int> ) { try { Thread . sleep ( timeout ) ; } catch ( InterruptedException e1 ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e1 ) ; } } if ( oue ! = null ) { ctx . sendDownstream ( new OrderedDownstreamChannelEvent ( oue , <int> , true , httpResponse ) ) ; } else { ctx . getChannel ( ) . write ( httpResponse ) ; } } } } 
