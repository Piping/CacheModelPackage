package org . elasticsearch . index . translog ; import org . elasticsearch . ElasticsearchException ; import org . hamcrest . Description ; import org . hamcrest . Matcher ; import org . hamcrest . TypeSafeMatcher ; import java . io . IOException ; import java . util . ArrayList ; public final class SnapshotMatchers { private SnapshotMatchers ( ) { } public static Matcher < Translog . Snapshot > size ( int size ) { return new SizeMatcher ( size ) ; } public static Matcher < Translog . Snapshot > equalsTo ( Translog . Operation . . . ops ) { return new EqualMatcher ( ops ) ; } public static Matcher < Translog . Snapshot > equalsTo ( ArrayList < Translog . Operation > ops ) { return new EqualMatcher ( ops . toArray ( new Translog . Operation [ ops . size ( ) ] ) ) ; } public static class SizeMatcher extends TypeSafeMatcher < Translog . Snapshot > { private final int size ; public SizeMatcher ( int size ) { this . size = size ; } @Override public boolean matchesSafely ( Translog . Snapshot snapshot ) { int count = <int> ; try { while ( snapshot . next ( ) ! = null ) { count + + ; } } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } return size = = count ; } @Override public void describeTo ( Description description ) { description . appendText ( <str> ) . appendValue ( size ) ; } } public static class EqualMatcher extends TypeSafeMatcher < Translog . Snapshot > { private final Translog . Operation [ ] expectedOps ; String failureMsg = null ; public EqualMatcher ( Translog . Operation [ ] expectedOps ) { this . expectedOps = expectedOps ; } @Override protected boolean matchesSafely ( Translog . Snapshot snapshot ) { try { Translog . Operation op ; int i ; for ( i = <int> , op = snapshot . next ( ) ; op ! = null & & i < expectedOps . length ; i + + , op = snapshot . next ( ) ) { if ( expectedOps [ i ] . equals ( op ) = = false ) { failureMsg = <str> + i + <str> + expectedOps [ i ] + <str> + op + <str> ; return false ; } } if ( i < expectedOps . length ) { failureMsg = <str> + expectedOps . length + <str> + i + <str> ; return false ; } if ( op ! = null ) { int count = <int> ; while ( snapshot . next ( ) ! = null ) { count + + ; } failureMsg = <str> + expectedOps . length + <str> + ( expectedOps . length + count ) + <str> ; return false ; } return true ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } @Override public void describeTo ( Description description ) { description . appendText ( failureMsg ) ; } } } 
