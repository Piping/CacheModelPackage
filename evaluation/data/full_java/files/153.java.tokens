package org . apache . cassandra . cql3 ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . ListType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . db . marshal . SetType ; public enum Operator { EQ ( <int> ) { @Override public String toString ( ) { return <str> ; } } , LT ( <int> ) { @Override public String toString ( ) { return <str> ; } } , LTE ( <int> ) { @Override public String toString ( ) { return <str> ; } } , GTE ( <int> ) { @Override public String toString ( ) { return <str> ; } } , GT ( <int> ) { @Override public String toString ( ) { return <str> ; } } , IN ( <int> ) { } , CONTAINS ( <int> ) { } , CONTAINS_KEY ( <int> ) { @Override public String toString ( ) { return <str> ; } } , NEQ ( <int> ) { @Override public String toString ( ) { return <str> ; } } , IS_NOT ( <int> ) { @Override public String toString ( ) { return <str> ; } } ; private final int b ; private Operator ( int b ) { this . b = b ; } public void writeTo ( DataOutput output ) throws IOException { output . writeInt ( b ) ; } public int getValue ( ) { return b ; } public static Operator readFrom ( DataInput input ) throws IOException { int b = input . readInt ( ) ; for ( Operator operator : values ( ) ) if ( operator . b = = b ) return operator ; throw new IOException ( String . format ( <str> , b ) ) ; } public boolean isSatisfiedBy ( AbstractType < ? > type , ByteBuffer leftOperand , ByteBuffer rightOperand ) { switch ( this ) { case EQ : return type . compareForCQL ( leftOperand , rightOperand ) = = <int> ; case LT : return type . compareForCQL ( leftOperand , rightOperand ) < <int> ; case LTE : return type . compareForCQL ( leftOperand , rightOperand ) < = <int> ; case GT : return type . compareForCQL ( leftOperand , rightOperand ) > <int> ; case GTE : return type . compareForCQL ( leftOperand , rightOperand ) > = <int> ; case NEQ : return type . compareForCQL ( leftOperand , rightOperand ) ! = <int> ; case IN : List inValues = ( ( List ) ListType . getInstance ( type , false ) . getSerializer ( ) . deserialize ( rightOperand ) ) ; return inValues . contains ( type . getSerializer ( ) . deserialize ( leftOperand ) ) ; case CONTAINS : if ( type instanceof ListType ) { List list = ( List ) type . getSerializer ( ) . deserialize ( leftOperand ) ; return list . contains ( ( ( ListType ) type ) . getElementsType ( ) . getSerializer ( ) . deserialize ( rightOperand ) ) ; } else if ( type instanceof SetType ) { Set set = ( Set ) type . getSerializer ( ) . deserialize ( leftOperand ) ; return set . contains ( ( ( SetType ) type ) . getElementsType ( ) . getSerializer ( ) . deserialize ( rightOperand ) ) ; } else { Map map = ( Map ) type . getSerializer ( ) . deserialize ( leftOperand ) ; return map . containsValue ( ( ( MapType ) type ) . getValuesType ( ) . getSerializer ( ) . deserialize ( rightOperand ) ) ; } case CONTAINS_KEY : Map map = ( Map ) type . getSerializer ( ) . deserialize ( leftOperand ) ; return map . containsKey ( ( ( MapType ) type ) . getKeysType ( ) . getSerializer ( ) . deserialize ( rightOperand ) ) ; default : throw new AssertionError ( ) ; } } public int serializedSize ( ) { return <int> ; } @Override public String toString ( ) { return this . name ( ) ; } } 
