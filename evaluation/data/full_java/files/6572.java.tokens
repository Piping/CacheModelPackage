package org . elasticsearch . index . mapper . internal ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StoredField ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . common . xcontent . support . XContentMapValues ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . MetadataFieldMapper ; import org . elasticsearch . index . mapper . ParseContext ; import java . io . IOException ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeBooleanValue ; public class SourceFieldMapper extends MetadataFieldMapper { public static final String NAME = <str> ; public static final String CONTENT_TYPE = <str> ; public static class Defaults { public static final String NAME = SourceFieldMapper . NAME ; public static final boolean ENABLED = true ; public static final MappedFieldType FIELD_TYPE = new SourceFieldType ( ) ; static { FIELD_TYPE . setIndexOptions ( IndexOptions . NONE ) ; FIELD_TYPE . setStored ( true ) ; FIELD_TYPE . setOmitNorms ( true ) ; FIELD_TYPE . setIndexAnalyzer ( Lucene . KEYWORD_ANALYZER ) ; FIELD_TYPE . setSearchAnalyzer ( Lucene . KEYWORD_ANALYZER ) ; FIELD_TYPE . setNames ( new MappedFieldType . Names ( NAME ) ) ; FIELD_TYPE . freeze ( ) ; } } public static class Builder extends MetadataFieldMapper . Builder < Builder , SourceFieldMapper > { private boolean enabled = Defaults . ENABLED ; private String [ ] includes = null ; private String [ ] excludes = null ; public Builder ( ) { super ( Defaults . NAME , Defaults . FIELD_TYPE ) ; } public Builder enabled ( boolean enabled ) { this . enabled = enabled ; return this ; } public Builder includes ( String [ ] includes ) { this . includes = includes ; return this ; } public Builder excludes ( String [ ] excludes ) { this . excludes = excludes ; return this ; } @Override public SourceFieldMapper build ( BuilderContext context ) { return new SourceFieldMapper ( enabled , includes , excludes , context . indexSettings ( ) ) ; } } public static class TypeParser implements MetadataFieldMapper . TypeParser { @Override public MetadataFieldMapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { Builder builder = new Builder ( ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object fieldNode = entry . getValue ( ) ; if ( fieldName . equals ( <str> ) ) { builder . enabled ( nodeBooleanValue ( fieldNode ) ) ; iterator . remove ( ) ; } else if ( <str> . equals ( fieldName ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_3_0_0 ) ) { iterator . remove ( ) ; } else if ( fieldName . equals ( <str> ) ) { List < Object > values = ( List < Object > ) fieldNode ; String [ ] includes = new String [ values . size ( ) ] ; for ( int i = <int> ; i < includes . length ; i + + ) { includes [ i ] = values . get ( i ) . toString ( ) ; } builder . includes ( includes ) ; iterator . remove ( ) ; } else if ( fieldName . equals ( <str> ) ) { List < Object > values = ( List < Object > ) fieldNode ; String [ ] excludes = new String [ values . size ( ) ] ; for ( int i = <int> ; i < excludes . length ; i + + ) { excludes [ i ] = values . get ( i ) . toString ( ) ; } builder . excludes ( excludes ) ; iterator . remove ( ) ; } } return builder ; } @Override public MetadataFieldMapper getDefault ( Settings indexSettings , MappedFieldType fieldType , String typeName ) { return new SourceFieldMapper ( indexSettings ) ; } } static final class SourceFieldType extends MappedFieldType { public SourceFieldType ( ) { } protected SourceFieldType ( SourceFieldType ref ) { super ( ref ) ; } @Override public MappedFieldType clone ( ) { return new SourceFieldType ( this ) ; } @Override public String typeName ( ) { return CONTENT_TYPE ; } @Override public byte [ ] value ( Object value ) { if ( value = = null ) { return null ; } BytesReference bValue ; if ( value instanceof BytesRef ) { bValue = new BytesArray ( ( BytesRef ) value ) ; } else { bValue = ( BytesReference ) value ; } try { return CompressorFactory . uncompressIfNeeded ( bValue ) . toBytes ( ) ; } catch ( IOException e ) { throw new ElasticsearchParseException ( <str> , e ) ; } } } private final boolean enabled ; private final boolean complete ; private final String [ ] includes ; private final String [ ] excludes ; private SourceFieldMapper ( Settings indexSettings ) { this ( Defaults . ENABLED , null , null , indexSettings ) ; } private SourceFieldMapper ( boolean enabled , String [ ] includes , String [ ] excludes , Settings indexSettings ) { super ( NAME , Defaults . FIELD_TYPE . clone ( ) , Defaults . FIELD_TYPE , indexSettings ) ; this . enabled = enabled ; this . includes = includes ; this . excludes = excludes ; this . complete = enabled & & includes = = null & & excludes = = null ; } public boolean enabled ( ) { return enabled ; } public String [ ] excludes ( ) { return this . excludes ! = null ? this . excludes : Strings . EMPTY_ARRAY ; } public String [ ] includes ( ) { return this . includes ! = null ? this . includes : Strings . EMPTY_ARRAY ; } public boolean isComplete ( ) { return complete ; } @Override public void preParse ( ParseContext context ) throws IOException { super . parse ( context ) ; } @Override public void postParse ( ParseContext context ) throws IOException { } @Override public Mapper parse ( ParseContext context ) throws IOException { return null ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { if ( ! enabled ) { return ; } if ( ! fieldType ( ) . stored ( ) ) { return ; } if ( context . flyweight ( ) ) { return ; } BytesReference source = context . source ( ) ; boolean filtered = ( includes ! = null & & includes . length > <int> ) | | ( excludes ! = null & & excludes . length > <int> ) ; if ( filtered ) { Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( source , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , includes , excludes ) ; BytesStreamOutput bStream = new BytesStreamOutput ( ) ; XContentType contentType = mapTuple . v1 ( ) ; XContentBuilder builder = XContentFactory . contentBuilder ( contentType , bStream ) . map ( filteredSource ) ; builder . close ( ) ; source = bStream . bytes ( ) ; } if ( ! source . hasArray ( ) ) { source = source . toBytesArray ( ) ; } fields . add ( new StoredField ( fieldType ( ) . names ( ) . indexName ( ) , source . array ( ) , source . arrayOffset ( ) , source . length ( ) ) ) ; } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { boolean includeDefaults = params . paramAsBoolean ( <str> , false ) ; if ( ! includeDefaults & & enabled = = Defaults . ENABLED & & includes = = null & & excludes = = null ) { return builder ; } builder . startObject ( contentType ( ) ) ; if ( includeDefaults | | enabled ! = Defaults . ENABLED ) { builder . field ( <str> , enabled ) ; } if ( includes ! = null ) { builder . field ( <str> , includes ) ; } else if ( includeDefaults ) { builder . field ( <str> , Strings . EMPTY_ARRAY ) ; } if ( excludes ! = null ) { builder . field ( <str> , excludes ) ; } else if ( includeDefaults ) { builder . field ( <str> , Strings . EMPTY_ARRAY ) ; } builder . endObject ( ) ; return builder ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { SourceFieldMapper sourceMergeWith = ( SourceFieldMapper ) mergeWith ; if ( mergeResult . simulate ( ) ) { if ( this . enabled ! = sourceMergeWith . enabled ) { mergeResult . addConflict ( <str> ) ; } if ( Arrays . equals ( includes ( ) , sourceMergeWith . includes ( ) ) = = false ) { mergeResult . addConflict ( <str> ) ; } if ( Arrays . equals ( excludes ( ) , sourceMergeWith . excludes ( ) ) = = false ) { mergeResult . addConflict ( <str> ) ; } } } } 
