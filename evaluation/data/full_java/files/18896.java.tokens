package io . netty . handler . codec . compression ; import com . jcraft . jzlib . Inflater ; import com . jcraft . jzlib . JZlib ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . util . List ; public class JZlibDecoder extends ZlibDecoder { private final Inflater z = new Inflater ( ) ; private byte [ ] dictionary ; private volatile boolean finished ; public JZlibDecoder ( ) { this ( ZlibWrapper . ZLIB ) ; } public JZlibDecoder ( ZlibWrapper wrapper ) { if ( wrapper = = null ) { throw new NullPointerException ( <str> ) ; } int resultCode = z . init ( ZlibUtil . convertWrapperType ( wrapper ) ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } } public JZlibDecoder ( byte [ ] dictionary ) { if ( dictionary = = null ) { throw new NullPointerException ( <str> ) ; } this . dictionary = dictionary ; int resultCode ; resultCode = z . inflateInit ( JZlib . W_ZLIB ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } } @Override public boolean isClosed ( ) { return finished ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( finished ) { in . skipBytes ( in . readableBytes ( ) ) ; return ; } final int inputLength = in . readableBytes ( ) ; if ( inputLength = = <int> ) { return ; } try { z . avail_in = inputLength ; if ( in . hasArray ( ) ) { z . next_in = in . array ( ) ; z . next_in_index = in . arrayOffset ( ) + in . readerIndex ( ) ; } else { byte [ ] array = new byte [ inputLength ] ; in . getBytes ( in . readerIndex ( ) , array ) ; z . next_in = array ; z . next_in_index = <int> ; } int oldNextInIndex = z . next_in_index ; int maxOutputLength = inputLength < < <int> ; ByteBuf decompressed = ctx . alloc ( ) . heapBuffer ( maxOutputLength ) ; try { loop : for ( ; ; ) { z . avail_out = maxOutputLength ; decompressed . ensureWritable ( maxOutputLength ) ; z . next_out = decompressed . array ( ) ; z . next_out_index = decompressed . arrayOffset ( ) + decompressed . writerIndex ( ) ; int oldNextOutIndex = z . next_out_index ; int resultCode = z . inflate ( JZlib . Z_SYNC_FLUSH ) ; int outputLength = z . next_out_index - oldNextOutIndex ; if ( outputLength > <int> ) { decompressed . writerIndex ( decompressed . writerIndex ( ) + outputLength ) ; } switch ( resultCode ) { case JZlib . Z_NEED_DICT : if ( dictionary = = null ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } else { resultCode = z . inflateSetDictionary ( dictionary , dictionary . length ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } } break ; case JZlib . Z_STREAM_END : finished = true ; z . inflateEnd ( ) ; break loop ; case JZlib . Z_OK : break ; case JZlib . Z_BUF_ERROR : if ( z . avail_in < = <int> ) { break loop ; } break ; default : ZlibUtil . fail ( z , <str> , resultCode ) ; } } } finally { in . skipBytes ( z . next_in_index - oldNextInIndex ) ; if ( decompressed . isReadable ( ) ) { out . add ( decompressed ) ; } else { decompressed . release ( ) ; } } } finally { z . next_in = null ; z . next_out = null ; } } } 
