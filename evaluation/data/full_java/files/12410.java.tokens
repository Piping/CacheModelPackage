package org . gradle . execution . taskgraph ; import groovy . lang . Closure ; import org . gradle . api . CircularReferenceException ; import org . gradle . api . Task ; import org . gradle . api . execution . TaskExecutionGraphListener ; import org . gradle . api . execution . TaskExecutionListener ; import org . gradle . api . execution . internal . InternalTaskExecutionListener ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . internal . tasks . * ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . api . tasks . TaskOutputs ; import org . gradle . execution . TaskFailureHandler ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . Factories ; import org . gradle . internal . TrueTimeProvider ; import org . gradle . internal . event . ListenerBroadcast ; import org . gradle . internal . event . ListenerManager ; import org . gradle . internal . progress . BuildOperationExecutor ; import org . gradle . util . JUnit4GroovyMockery ; import org . gradle . util . TestClosure ; import org . hamcrest . Description ; import org . jmock . Expectations ; import org . jmock . api . Invocation ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . util . ArrayList ; import java . util . List ; import static org . gradle . util . TestUtil . createRootProject ; import static org . gradle . util . TestUtil . toClosure ; import static org . gradle . util . WrapUtil . toList ; import static org . gradle . util . WrapUtil . toSet ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class DefaultTaskGraphExecuterTest { final JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; final ListenerManager listenerManager = context . mock ( ListenerManager . class ) ; final BuildCancellationToken cancellationToken = context . mock ( BuildCancellationToken . class ) ; final BuildOperationExecutor buildOperationExecutor = context . mock ( BuildOperationExecutor . class ) ; final TaskExecuter executer = context . mock ( TaskExecuter . class ) ; DefaultTaskGraphExecuter taskExecuter ; ProjectInternal root ; List < Task > executedTasks = new ArrayList < Task > ( ) ; @Before public void setUp ( ) { root = createRootProject ( ) ; context . checking ( new Expectations ( ) { { one ( listenerManager ) . createAnonymousBroadcaster ( TaskExecutionGraphListener . class ) ; will ( returnValue ( new ListenerBroadcast < TaskExecutionGraphListener > ( TaskExecutionGraphListener . class ) ) ) ; one ( listenerManager ) . createAnonymousBroadcaster ( TaskExecutionListener . class ) ; will ( returnValue ( new ListenerBroadcast < TaskExecutionListener > ( TaskExecutionListener . class ) ) ) ; one ( listenerManager ) . createAnonymousBroadcaster ( InternalTaskExecutionListener . class ) ; will ( returnValue ( new ListenerBroadcast < InternalTaskExecutionListener > ( InternalTaskExecutionListener . class ) ) ) ; allowing ( cancellationToken ) . isCancellationRequested ( ) ; allowing ( buildOperationExecutor ) . getCurrentOperationId ( ) ; } } ) ; taskExecuter = new DefaultTaskGraphExecuter ( listenerManager , new DefaultTaskPlanExecutor ( ) , Factories . constant ( executer ) , cancellationToken , new TrueTimeProvider ( ) , buildOperationExecutor ) ; } @Test public void testExecutesTasksInDependencyOrder ( ) { Task a = task ( <str> ) ; Task b = task ( <str> , a ) ; Task c = task ( <str> , b , a ) ; Task d = task ( <str> , c ) ; taskExecuter . addTasks ( toList ( d ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( a , b , c , d ) ) ) ; } @Test public void testExecutesDependenciesInNameOrder ( ) { Task a = task ( <str> ) ; Task b = task ( <str> ) ; Task c = task ( <str> ) ; Task d = task ( <str> , b , a , c ) ; taskExecuter . addTasks ( toList ( d ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( a , b , c , d ) ) ) ; } @Test public void testExecutesTasksInASingleBatchInNameOrder ( ) { Task a = task ( <str> ) ; Task b = task ( <str> ) ; Task c = task ( <str> ) ; taskExecuter . addTasks ( toList ( b , c , a ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( a , b , c ) ) ) ; } @Test public void testExecutesBatchesInOrderAdded ( ) { Task a = task ( <str> ) ; Task b = task ( <str> ) ; Task c = task ( <str> ) ; Task d = task ( <str> ) ; taskExecuter . addTasks ( toList ( c , b ) ) ; taskExecuter . addTasks ( toList ( d , a ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( b , c , a , d ) ) ) ; } @Test public void testExecutesSharedDependenciesOfBatchesOnceOnly ( ) { Task a = task ( <str> ) ; Task b = task ( <str> ) ; Task c = task ( <str> , a , b ) ; Task d = task ( <str> ) ; Task e = task ( <str> , b , d ) ; taskExecuter . addTasks ( toList ( c ) ) ; taskExecuter . addTasks ( toList ( e ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( a , b , c , d , e ) ) ) ; } @Test public void testAddTasksAddsDependencies ( ) { Task a = task ( <str> ) ; Task b = task ( <str> , a ) ; Task c = task ( <str> , b , a ) ; Task d = task ( <str> , c ) ; taskExecuter . addTasks ( toList ( d ) ) ; assertTrue ( taskExecuter . hasTask ( <str> ) ) ; assertTrue ( taskExecuter . hasTask ( a ) ) ; assertTrue ( taskExecuter . hasTask ( <str> ) ) ; assertTrue ( taskExecuter . hasTask ( b ) ) ; assertTrue ( taskExecuter . hasTask ( <str> ) ) ; assertTrue ( taskExecuter . hasTask ( c ) ) ; assertTrue ( taskExecuter . hasTask ( <str> ) ) ; assertTrue ( taskExecuter . hasTask ( d ) ) ; assertThat ( taskExecuter . getAllTasks ( ) , equalTo ( toList ( a , b , c , d ) ) ) ; } @Test public void testGetAllTasksReturnsTasksInExecutionOrder ( ) { Task d = task ( <str> ) ; Task c = task ( <str> ) ; Task b = task ( <str> , d , c ) ; Task a = task ( <str> , b ) ; taskExecuter . addTasks ( toList ( a ) ) ; assertThat ( taskExecuter . getAllTasks ( ) , equalTo ( toList ( c , d , b , a ) ) ) ; } @Test public void testCannotUseGetterMethodsWhenGraphHasNotBeenCalculated ( ) { try { taskExecuter . hasTask ( <str> ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } try { taskExecuter . hasTask ( task ( <str> ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } try { taskExecuter . getAllTasks ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } } @Test public void testDiscardsTasksAfterExecute ( ) { Task a = task ( <str> ) ; Task b = task ( <str> , a ) ; taskExecuter . addTasks ( toList ( b ) ) ; taskExecuter . execute ( ) ; assertFalse ( taskExecuter . hasTask ( <str> ) ) ; assertFalse ( taskExecuter . hasTask ( a ) ) ; assertTrue ( taskExecuter . getAllTasks ( ) . isEmpty ( ) ) ; } @Test public void testCanExecuteMultipleTimes ( ) { Task a = task ( <str> ) ; Task b = task ( <str> , a ) ; Task c = task ( <str> ) ; taskExecuter . addTasks ( toList ( b ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( a , b ) ) ) ; executedTasks . clear ( ) ; taskExecuter . addTasks ( toList ( c ) ) ; assertThat ( taskExecuter . getAllTasks ( ) , equalTo ( toList ( c ) ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( c ) ) ) ; } @Test public void testCannotAddTaskWithCircularReference ( ) { Task a = createTask ( <str> ) ; Task b = task ( <str> , a ) ; Task c = task ( <str> , b ) ; dependsOn ( a , c ) ; taskExecuter . addTasks ( toList ( c ) ) ; try { taskExecuter . execute ( ) ; fail ( ) ; } catch ( CircularReferenceException e ) { } } @Test public void testNotifiesGraphListenerBeforeExecute ( ) { final TaskExecutionGraphListener listener = context . mock ( TaskExecutionGraphListener . class ) ; Task a = task ( <str> ) ; taskExecuter . addTaskExecutionGraphListener ( listener ) ; taskExecuter . addTasks ( toList ( a ) ) ; context . checking ( new Expectations ( ) { { one ( listener ) . graphPopulated ( taskExecuter ) ; } } ) ; taskExecuter . execute ( ) ; } @Test public void testExecutesWhenReadyClosureBeforeExecute ( ) { final TestClosure runnable = context . mock ( TestClosure . class ) ; Task a = task ( <str> ) ; taskExecuter . whenReady ( toClosure ( runnable ) ) ; taskExecuter . addTasks ( toList ( a ) ) ; context . checking ( new Expectations ( ) { { one ( runnable ) . call ( taskExecuter ) ; } } ) ; taskExecuter . execute ( ) ; } @Test public void testStopsExecutionOnFirstFailureWhenNoFailureHandlerProvided ( ) { final RuntimeException failure = new RuntimeException ( ) ; final Task a = brokenTask ( <str> , failure ) ; final Task b = task ( <str> ) ; taskExecuter . addTasks ( toList ( a , b ) ) ; try { taskExecuter . execute ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertThat ( e , sameInstance ( failure ) ) ; } assertThat ( executedTasks , equalTo ( toList ( a ) ) ) ; } @Test public void testStopsExecutionOnFailureWhenFailureHandlerIndicatesThatExecutionShouldStop ( ) { final TaskFailureHandler handler = context . mock ( TaskFailureHandler . class ) ; final RuntimeException failure = new RuntimeException ( ) ; final RuntimeException wrappedFailure = new RuntimeException ( ) ; final Task a = brokenTask ( <str> , failure ) ; final Task b = task ( <str> ) ; taskExecuter . useFailureHandler ( handler ) ; taskExecuter . addTasks ( toList ( a , b ) ) ; context . checking ( new Expectations ( ) { { one ( handler ) . onTaskFailure ( a ) ; will ( throwException ( wrappedFailure ) ) ; } } ) ; try { taskExecuter . execute ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertThat ( e , sameInstance ( wrappedFailure ) ) ; } assertThat ( executedTasks , equalTo ( toList ( a ) ) ) ; } @Test public void testNotifiesBeforeTaskClosureAsTasksAreExecuted ( ) { final TestClosure runnable = context . mock ( TestClosure . class ) ; final Task a = task ( <str> ) ; final Task b = task ( <str> ) ; final Closure closure = toClosure ( runnable ) ; taskExecuter . beforeTask ( closure ) ; taskExecuter . addTasks ( toList ( a , b ) ) ; context . checking ( new Expectations ( ) { { one ( runnable ) . call ( a ) ; one ( runnable ) . call ( b ) ; } } ) ; taskExecuter . execute ( ) ; } @Test public void testNotifiesAfterTaskClosureAsTasksAreExecuted ( ) { final TestClosure runnable = context . mock ( TestClosure . class ) ; final Task a = task ( <str> ) ; final Task b = task ( <str> ) ; taskExecuter . afterTask ( toClosure ( runnable ) ) ; taskExecuter . addTasks ( toList ( a , b ) ) ; context . checking ( new Expectations ( ) { { one ( runnable ) . call ( a ) ; one ( runnable ) . call ( b ) ; } } ) ; taskExecuter . execute ( ) ; } @Test public void doesNotExecuteFilteredTasks ( ) { final Task a = task ( <str> , task ( <str> ) ) ; Task b = task ( <str> ) ; Spec < Task > spec = new Spec < Task > ( ) { public boolean isSatisfiedBy ( Task element ) { return element ! = a ; } } ; taskExecuter . useFilter ( spec ) ; taskExecuter . addTasks ( toList ( a , b ) ) ; assertThat ( taskExecuter . getAllTasks ( ) , equalTo ( toList ( b ) ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( b ) ) ) ; } @Test public void doesNotExecuteFilteredDependencies ( ) { final Task a = task ( <str> , task ( <str> ) ) ; Task b = task ( <str> ) ; Task c = task ( <str> , a , b ) ; Spec < Task > spec = new Spec < Task > ( ) { public boolean isSatisfiedBy ( Task element ) { return element ! = a ; } } ; taskExecuter . useFilter ( spec ) ; taskExecuter . addTasks ( toList ( c ) ) ; assertThat ( taskExecuter . getAllTasks ( ) , equalTo ( toList ( b , c ) ) ) ; taskExecuter . execute ( ) ; assertThat ( executedTasks , equalTo ( toList ( b , c ) ) ) ; } @Test public void willExecuteATaskWhoseDependenciesHaveBeenFilteredOnFailure ( ) { final TaskFailureHandler handler = context . mock ( TaskFailureHandler . class ) ; final RuntimeException failure = new RuntimeException ( ) ; final Task a = brokenTask ( <str> , failure ) ; final Task b = task ( <str> ) ; final Task c = task ( <str> , b ) ; taskExecuter . useFailureHandler ( handler ) ; taskExecuter . useFilter ( new Spec < Task > ( ) { public boolean isSatisfiedBy ( Task element ) { return element ! = b ; } } ) ; taskExecuter . addTasks ( toList ( a , c ) ) ; context . checking ( new Expectations ( ) { { ignoring ( handler ) ; } } ) ; try { taskExecuter . execute ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertThat ( e , sameInstance ( failure ) ) ; } assertThat ( executedTasks , equalTo ( toList ( a , c ) ) ) ; } private void dependsOn ( final Task task , final Task . . . dependsOn ) { context . checking ( new Expectations ( ) { { TaskDependency taskDependency = context . mock ( TaskDependency . class ) ; allowing ( task ) . getTaskDependencies ( ) ; will ( returnValue ( taskDependency ) ) ; allowing ( taskDependency ) . getDependencies ( task ) ; will ( returnValue ( toSet ( dependsOn ) ) ) ; } } ) ; } private Task brokenTask ( String name , final RuntimeException failure , final Task . . . dependsOn ) { final TaskInternal task = context . mock ( TaskInternal . class ) ; final TaskStateInternal state = context . mock ( TaskStateInternal . class ) ; final TaskOutputs outputs = context . mock ( DefaultTaskOutputs . class ) ; setExpectations ( name , task , state , outputs ) ; dependsOn ( task , dependsOn ) ; context . checking ( new Expectations ( ) { { atMost ( <int> ) . of ( executer ) . execute ( with ( sameInstance ( task ) ) , with ( sameInstance ( state ) ) , with ( notNullValue ( TaskExecutionContext . class ) ) ) ; will ( new ExecuteTaskAction ( task ) ) ; allowing ( state ) . getFailure ( ) ; will ( returnValue ( failure ) ) ; allowing ( state ) . rethrowFailure ( ) ; will ( throwException ( failure ) ) ; } } ) ; return task ; } private Task task ( final String name , final Task . . . dependsOn ) { final TaskInternal task = context . mock ( TaskInternal . class ) ; final TaskStateInternal state = context . mock ( TaskStateInternal . class ) ; final TaskOutputs outputs = context . mock ( DefaultTaskOutputs . class ) ; setExpectations ( name , task , state , outputs ) ; dependsOn ( task , dependsOn ) ; context . checking ( new Expectations ( ) { { atMost ( <int> ) . of ( executer ) . execute ( with ( sameInstance ( task ) ) , with ( sameInstance ( state ) ) , with ( notNullValue ( TaskExecutionContext . class ) ) ) ; will ( new ExecuteTaskAction ( task ) ) ; allowing ( state ) . getFailure ( ) ; will ( returnValue ( null ) ) ; } } ) ; return task ; } private TaskInternal createTask ( final String name ) { TaskInternal task = context . mock ( TaskInternal . class ) ; TaskStateInternal state = context . mock ( TaskStateInternal . class ) ; final TaskOutputs outputs = context . mock ( DefaultTaskOutputs . class ) ; setExpectations ( name , task , state , outputs ) ; return task ; } private void setExpectations ( final String name , final TaskInternal task , final TaskStateInternal state , final TaskOutputs outputs ) { context . checking ( new Expectations ( ) { { allowing ( task ) . getProject ( ) ; will ( returnValue ( root ) ) ; allowing ( task ) . getName ( ) ; will ( returnValue ( name ) ) ; allowing ( task ) . getPath ( ) ; will ( returnValue ( <str> + name ) ) ; allowing ( task ) . getState ( ) ; will ( returnValue ( state ) ) ; allowing ( ( Task ) task ) . getState ( ) ; will ( returnValue ( state ) ) ; allowing ( task ) . getMustRunAfter ( ) ; will ( returnValue ( new DefaultTaskDependency ( ) ) ) ; allowing ( task ) . getFinalizedBy ( ) ; will ( returnValue ( new DefaultTaskDependency ( ) ) ) ; allowing ( task ) . getShouldRunAfter ( ) ; will ( returnValue ( new DefaultTaskDependency ( ) ) ) ; allowing ( task ) . getDidWork ( ) ; will ( returnValue ( true ) ) ; allowing ( task ) . compareTo ( with ( notNullValue ( TaskInternal . class ) ) ) ; will ( new org . jmock . api . Action ( ) { public Object invoke ( Invocation invocation ) throws Throwable { return name . compareTo ( ( ( Task ) invocation . getParameter ( <int> ) ) . getName ( ) ) ; } public void describeTo ( Description description ) { description . appendText ( <str> ) ; } } ) ; allowing ( task ) . getOutputs ( ) ; will ( returnValue ( outputs ) ) ; allowing ( outputs ) . getFiles ( ) ; will ( returnValue ( root . files ( ) ) ) ; } } ) ; } private class ExecuteTaskAction implements org . jmock . api . Action { private final TaskInternal task ; public ExecuteTaskAction ( TaskInternal task ) { this . task = task ; } public Object invoke ( Invocation invocation ) throws Throwable { executedTasks . add ( task ) ; return null ; } public void describeTo ( Description description ) { description . appendText ( <str> ) ; } } } 
