package org . elasticsearch . search . aggregations . support ; import org . elasticsearch . common . Strings ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . HasAggregations ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregation ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . metrics . InternalNumericMetricsAggregation ; import org . elasticsearch . search . aggregations . metrics . NumericMetricsAggregator ; import java . util . ArrayList ; import java . util . List ; public class AggregationPath { private final static String AGG_DELIM = <str> ; public static AggregationPath parse ( String path ) { String [ ] elements = Strings . tokenizeToStringArray ( path , AGG_DELIM ) ; List < PathElement > tokens = new ArrayList < > ( elements . length ) ; String [ ] tuple = new String [ <int> ] ; for ( int i = <int> ; i < elements . length ; i + + ) { String element = elements [ i ] ; if ( i = = elements . length - <int> ) { int index = element . lastIndexOf ( <str> ) ; if ( index > = <int> ) { if ( index = = <int> | | index > element . length ( ) - <int> ) { throw new AggregationExecutionException ( <str> + element + <str> + path + <str> ) ; } if ( element . charAt ( element . length ( ) - <int> ) ! = <str> ) { throw new AggregationExecutionException ( <str> + element + <str> + path + <str> ) ; } tokens . add ( new PathElement ( element , element . substring ( <int> , index ) , element . substring ( index + <int> , element . length ( ) - <int> ) ) ) ; continue ; } index = element . lastIndexOf ( <str> ) ; if ( index < <int> ) { tokens . add ( new PathElement ( element , element , null ) ) ; continue ; } if ( index = = <int> | | index > element . length ( ) - <int> ) { throw new AggregationExecutionException ( <str> + element + <str> + path + <str> ) ; } tuple = split ( element , index , tuple ) ; tokens . add ( new PathElement ( element , tuple [ <int> ] , tuple [ <int> ] ) ) ; } else { int index = element . lastIndexOf ( <str> ) ; if ( index > = <int> ) { if ( index = = <int> | | index > element . length ( ) - <int> ) { throw new AggregationExecutionException ( <str> + element + <str> + path + <str> ) ; } if ( element . charAt ( element . length ( ) - <int> ) ! = <str> ) { throw new AggregationExecutionException ( <str> + element + <str> + path + <str> ) ; } tokens . add ( new PathElement ( element , element . substring ( <int> , index ) , element . substring ( index + <int> , element . length ( ) - <int> ) ) ) ; continue ; } tokens . add ( new PathElement ( element , element , null ) ) ; } } return new AggregationPath ( tokens ) ; } public static class PathElement { private final String fullName ; public final String name ; public final String key ; public PathElement ( String fullName , String name , String key ) { this . fullName = fullName ; this . name = name ; this . key = key ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; PathElement token = ( PathElement ) o ; if ( key ! = null ? ! key . equals ( token . key ) : token . key ! = null ) return false ; if ( ! name . equals ( token . name ) ) return false ; return true ; } @Override public int hashCode ( ) { int result = name . hashCode ( ) ; result = <int> * result + ( key ! = null ? key . hashCode ( ) : <int> ) ; return result ; } @Override public String toString ( ) { return fullName ; } } private final List < PathElement > pathElements ; public AggregationPath ( List < PathElement > tokens ) { this . pathElements = tokens ; if ( tokens = = null | | tokens . size ( ) = = <int> ) { throw new IllegalArgumentException ( <str> + this + <str> ) ; } } @Override public String toString ( ) { return Strings . arrayToDelimitedString ( pathElements . toArray ( ) , AGG_DELIM ) ; } public PathElement lastPathElement ( ) { return pathElements . get ( pathElements . size ( ) - <int> ) ; } public List < PathElement > getPathElements ( ) { return this . pathElements ; } public List < String > getPathElementsAsStringList ( ) { List < String > stringPathElements = new ArrayList < > ( ) ; for ( PathElement pathElement : this . pathElements ) { stringPathElements . add ( pathElement . name ) ; if ( pathElement . key ! = null ) { stringPathElements . add ( pathElement . key ) ; } } return stringPathElements ; } public AggregationPath subPath ( int offset , int length ) { List < PathElement > subTokens = new ArrayList < > ( pathElements . subList ( offset , offset + length ) ) ; return new AggregationPath ( subTokens ) ; } public double resolveValue ( HasAggregations root ) { HasAggregations parent = root ; double value = Double . NaN ; for ( int i = <int> ; i < pathElements . size ( ) ; i + + ) { AggregationPath . PathElement token = pathElements . get ( i ) ; Aggregation agg = parent . getAggregations ( ) . get ( token . name ) ; if ( agg = = null ) { throw new IllegalArgumentException ( <str> + this + <str> + token . name + <str> ) ; } if ( agg instanceof SingleBucketAggregation ) { if ( token . key ! = null & & ! token . key . equals ( <str> ) ) { throw new IllegalArgumentException ( <str> + this + <str> + token . key + <str> + token . name + <str> ) ; } parent = ( SingleBucketAggregation ) agg ; value = ( ( SingleBucketAggregation ) agg ) . getDocCount ( ) ; continue ; } if ( i ! = pathElements . size ( ) - <int> ) { throw new IllegalArgumentException ( <str> + this + <str> + token + <str> + pathElements . get ( i + <int> ) + <str> ) ; } if ( agg instanceof InternalNumericMetricsAggregation . SingleValue ) { if ( token . key ! = null & & ! token . key . equals ( <str> ) ) { throw new IllegalArgumentException ( <str> + this + <str> + token . key + <str> + token . name + <str> ) ; } parent = null ; value = ( ( InternalNumericMetricsAggregation . SingleValue ) agg ) . value ( ) ; continue ; } if ( token . key = = null ) { throw new IllegalArgumentException ( <str> + this + <str> + token + <str> ) ; } parent = null ; value = ( ( InternalNumericMetricsAggregation . MultiValue ) agg ) . value ( token . key ) ; } return value ; } public Aggregator resolveAggregator ( Aggregator root ) { Aggregator aggregator = root ; for ( int i = <int> ; i < pathElements . size ( ) ; i + + ) { AggregationPath . PathElement token = pathElements . get ( i ) ; aggregator = aggregator . subAggregator ( token . name ) ; assert ( aggregator instanceof SingleBucketAggregator & & i < = pathElements . size ( ) - <int> ) | | ( aggregator instanceof NumericMetricsAggregator & & i = = pathElements . size ( ) - <int> ) : <str> ; } return aggregator ; } public Aggregator resolveTopmostAggregator ( Aggregator root ) { AggregationPath . PathElement token = pathElements . get ( <int> ) ; Aggregator aggregator = root . subAggregator ( token . name ) ; assert ( aggregator instanceof SingleBucketAggregator ) | | ( aggregator instanceof NumericMetricsAggregator ) : <str> ; return aggregator ; } public void validate ( Aggregator root ) { Aggregator aggregator = root ; for ( int i = <int> ; i < pathElements . size ( ) ; i + + ) { aggregator = aggregator . subAggregator ( pathElements . get ( i ) . name ) ; if ( aggregator = = null ) { throw new AggregationExecutionException ( <str> + this + <str> + pathElements . get ( i ) . name + <str> ) ; } if ( i < pathElements . size ( ) - <int> ) { if ( ! ( aggregator instanceof SingleBucketAggregator ) ) { throw new AggregationExecutionException ( <str> + this + <str> + <str> + <str> + subPath ( <int> , i + <int> ) + <str> ) ; } if ( pathElements . get ( i ) . key ! = null ) { throw new AggregationExecutionException ( <str> + this + <str> + <str> + <str> + subPath ( <int> , i + <int> ) + <str> ) ; } } } boolean singleBucket = aggregator instanceof SingleBucketAggregator ; if ( ! singleBucket & & ! ( aggregator instanceof NumericMetricsAggregator ) ) { throw new AggregationExecutionException ( <str> + this + <str> + <str> + <str> ) ; } AggregationPath . PathElement lastToken = lastPathElement ( ) ; if ( singleBucket ) { if ( lastToken . key ! = null & & ! <str> . equals ( lastToken . key ) ) { throw new AggregationExecutionException ( <str> + this + <str> + <str> + lastToken . name + <str> + lastToken . name + <str> ) ; } return ; } if ( aggregator instanceof NumericMetricsAggregator . SingleValue ) { if ( lastToken . key ! = null & & ! <str> . equals ( lastToken . key ) ) { throw new AggregationExecutionException ( <str> + this + <str> + <str> + lastToken . name + <str> + lastToken . name + <str> ) ; } return ; } if ( lastToken . key = = null ) { throw new AggregationExecutionException ( <str> + this + <str> ) ; } if ( ! ( ( NumericMetricsAggregator . MultiValue ) aggregator ) . hasMetric ( lastToken . key ) ) { throw new AggregationExecutionException ( <str> + this + <str> + lastToken . key + <str> + lastToken . name + <str> ) ; } } private static String [ ] split ( String toSplit , int index , String [ ] result ) { result [ <int> ] = toSplit . substring ( <int> , index ) ; result [ <int> ] = toSplit . substring ( index + <int> ) ; return result ; } } 
