package org . elasticsearch . index . analysis . phonetic ; import org . apache . commons . codec . EncoderException ; import org . apache . commons . codec . StringEncoder ; import java . util . regex . Pattern ; public class Nysiis implements StringEncoder { private static final char [ ] CHARS_A = new char [ ] { <str> } ; private static final char [ ] CHARS_AF = new char [ ] { <str> , <str> } ; private static final char [ ] CHARS_C = new char [ ] { <str> } ; private static final char [ ] CHARS_FF = new char [ ] { <str> , <str> } ; private static final char [ ] CHARS_G = new char [ ] { <str> } ; private static final char [ ] CHARS_N = new char [ ] { <str> } ; private static final char [ ] CHARS_NN = new char [ ] { <str> , <str> } ; private static final char [ ] CHARS_S = new char [ ] { <str> } ; private static final char [ ] CHARS_SSS = new char [ ] { <str> , <str> , <str> } ; private static final Pattern PAT_MAC = Pattern . compile ( <str> ) ; private static final Pattern PAT_KN = Pattern . compile ( <str> ) ; private static final Pattern PAT_K = Pattern . compile ( <str> ) ; private static final Pattern PAT_PH_PF = Pattern . compile ( <str> ) ; private static final Pattern PAT_SCH = Pattern . compile ( <str> ) ; private static final Pattern PAT_EE_IE = Pattern . compile ( <str> ) ; private static final Pattern PAT_DT_ETC = Pattern . compile ( <str> ) ; private static final char SPACE = <str> ; private static final int TRUE_LENGTH = <int> ; private static boolean isVowel ( final char c ) { return c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> ; } private static char [ ] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr = = <str> & & next = = <str> ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; } if ( curr = = <str> ) { return CHARS_G ; } else if ( curr = = <str> ) { return CHARS_S ; } else if ( curr = = <str> ) { return CHARS_N ; } if ( curr = = <str> ) { if ( next = = <str> ) { return CHARS_NN ; } else { return CHARS_C ; } } if ( curr = = <str> & & next = = <str> & & aNext = = <str> ) { return CHARS_SSS ; } if ( curr = = <str> & & next = = <str> ) { return CHARS_FF ; } if ( curr = = <str> & & ( ! isVowel ( prev ) | | ! isVowel ( next ) ) ) { return new char [ ] { prev } ; } if ( curr = = <str> & & isVowel ( prev ) ) { return new char [ ] { prev } ; } return new char [ ] { curr } ; } private final boolean strict ; public Nysiis ( ) { this ( true ) ; } public Nysiis ( final boolean strict ) { this . strict = strict ; } @Override public Object encode ( Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( <str> ) ; } return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( String str ) { return this . nysiis ( str ) ; } public boolean isStrict ( ) { return this . strict ; } public String nysiis ( String str ) { if ( str = = null ) { return null ; } str = clean ( str ) ; if ( str . length ( ) = = <int> ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_KN . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_K . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_SCH . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( <str> ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( <str> ) ; StringBuffer key = new StringBuffer ( str . length ( ) ) ; key . append ( str . charAt ( <int> ) ) ; final char [ ] chars = str . toCharArray ( ) ; final int len = chars . length ; for ( int i = <int> ; i < len ; i + + ) { final char next = i < len - <int> ? chars [ i + <int> ] : SPACE ; final char aNext = i < len - <int> ? chars [ i + <int> ] : SPACE ; final char [ ] transcoded = transcodeRemaining ( chars [ i - <int> ] , chars [ i ] , next , aNext ) ; System . arraycopy ( transcoded , <int> , chars , i , transcoded . length ) ; if ( chars [ i ] ! = chars [ i - <int> ] ) { key . append ( chars [ i ] ) ; } } if ( key . length ( ) > <int> ) { char lastChar = key . charAt ( key . length ( ) - <int> ) ; if ( lastChar = = <str> ) { key . deleteCharAt ( key . length ( ) - <int> ) ; lastChar = key . charAt ( key . length ( ) - <int> ) ; } if ( key . length ( ) > <int> ) { final char last2Char = key . charAt ( key . length ( ) - <int> ) ; if ( last2Char = = <str> & & lastChar = = <str> ) { key . deleteCharAt ( key . length ( ) - <int> ) ; } } if ( lastChar = = <str> ) { key . deleteCharAt ( key . length ( ) - <int> ) ; } } final String string = key . toString ( ) ; return this . isStrict ( ) ? string . substring ( <int> , Math . min ( TRUE_LENGTH , string . length ( ) ) ) : string ; } static String clean ( String str ) { if ( str = = null | | str . length ( ) = = <int> ) { return str ; } int len = str . length ( ) ; char [ ] chars = new char [ len ] ; int count = <int> ; for ( int i = <int> ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . toUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , <int> , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; } } 
