package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; final class GeoPointDVAtomicFieldData extends AbstractAtomicGeoPointFieldData { private final SortedNumericDocValues values ; GeoPointDVAtomicFieldData ( SortedNumericDocValues values ) { super ( ) ; this . values = values ; } @Override public long ramBytesUsed ( ) { return <int> ; } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } @Override public void close ( ) { } @Override public MultiGeoPointValues getGeoPointValues ( ) { return new MultiGeoPointValues ( ) { GeoPoint [ ] points = new GeoPoint [ <int> ] ; private int count = <int> ; @Override public void setDocument ( int docId ) { values . setDocument ( docId ) ; count = values . count ( ) ; if ( count > points . length ) { final int previousLength = points . length ; points = Arrays . copyOf ( points , ArrayUtil . oversize ( count , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) ; for ( int i = previousLength ; i < points . length ; + + i ) { points [ i ] = new GeoPoint ( Double . NaN , Double . NaN ) ; } } for ( int i = <int> ; i < count ; + + i ) { points [ i ] . resetFromIndexHash ( values . valueAt ( i ) ) ; } } @Override public int count ( ) { return count ; } @Override public GeoPoint valueAt ( int index ) { return points [ index ] ; } } ; } } 
