package com . badlogic . gdx . backends . jglfw ; import static com . badlogic . jglfw . Glfw . * ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Cursor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GL30 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . jglfw . GlfwVideoMode ; import com . badlogic . jglfw . gl . GL ; import java . awt . Toolkit ; public class JglfwGraphics implements Graphics { static final boolean isMac = System . getProperty ( <str> ) . contains ( <str> ) ; static final boolean isWindows = System . getProperty ( <str> ) . contains ( <str> ) ; static final boolean isLinux = System . getProperty ( <str> ) . contains ( <str> ) ; static int glMajorVersion , glMinorVersion ; long window ; private boolean fullscreen ; private long fullscreenMonitor ; private String title ; private boolean resizable , undecorated ; private BufferFormat bufferFormat ; private boolean vSync ; private int x , y , width , height ; private boolean visible ; private Color initialBackgroundColor ; private volatile boolean isContinuous = true , renderRequested ; volatile boolean foreground , minimized ; private long frameId = - <int> ; private float deltaTime ; private long frameStart , lastTime = - <int> ; private int frames , fps ; private JglfwGL20 gl20 ; public JglfwGraphics ( JglfwApplicationConfiguration config ) { bufferFormat = new BufferFormat ( config . r , config . g , config . b , config . a , config . depth , config . stencil , config . samples , false ) ; title = config . title ; resizable = config . resizable ; undecorated = config . undecorated ; x = config . x ; y = config . y ; vSync = config . vSync ; initialBackgroundColor = config . initialBackgroundColor ; if ( config . fullscreenMonitorIndex ! = - <int> ) { long [ ] monitors = glfwGetMonitors ( ) ; if ( config . fullscreenMonitorIndex < monitors . length ) fullscreenMonitor = monitors [ config . fullscreenMonitorIndex ] ; } if ( ! createWindow ( config . width , config . height , config . fullscreen ) ) { throw new GdxRuntimeException ( <str> + config . width + <str> + config . height + <str> + config . fullscreen ) ; } String version = GL . glGetString ( GL20 . GL_VERSION ) ; glMajorVersion = Integer . parseInt ( <str> + version . charAt ( <int> ) ) ; glMinorVersion = Integer . parseInt ( <str> + version . charAt ( <int> ) ) ; if ( glMajorVersion < = <int> ) throw new GdxRuntimeException ( <str> + version ) ; if ( glMajorVersion = = <int> | | version . contains ( <str> ) ) { if ( ! supportsExtension ( <str> ) & & ! supportsExtension ( <str> ) ) { throw new GdxRuntimeException ( <str> + version + <str> ) ; } } gl20 = new JglfwGL20 ( ) ; Gdx . gl = gl20 ; Gdx . gl20 = gl20 ; if ( ! config . hidden ) show ( ) ; } private boolean createWindow ( int width , int height , boolean fullscreen ) { if ( fullscreen & & fullscreenMonitor = = <int> ) fullscreenMonitor = getWindowMonitor ( ) ; glfwWindowHint ( GLFW_VISIBLE , <int> ) ; glfwWindowHint ( GLFW_RESIZABLE , resizable ? <int> : <int> ) ; glfwWindowHint ( GLFW_UNDECORATED , undecorated ? <int> : <int> ) ; glfwWindowHint ( GLFW_RED_BITS , bufferFormat . r ) ; glfwWindowHint ( GLFW_GREEN_BITS , bufferFormat . g ) ; glfwWindowHint ( GLFW_BLUE_BITS , bufferFormat . b ) ; glfwWindowHint ( GLFW_ALPHA_BITS , bufferFormat . a ) ; glfwWindowHint ( GLFW_DEPTH_BITS , bufferFormat . depth ) ; glfwWindowHint ( GLFW_STENCIL_BITS , bufferFormat . stencil ) ; glfwWindowHint ( GLFW_SAMPLES , bufferFormat . samples ) ; boolean mouseCaptured = window ! = <int> & & glfwGetInputMode ( window , GLFW_CURSOR_MODE ) = = GLFW_CURSOR_CAPTURED ; long oldWindow = window ; long newWindow = glfwCreateWindow ( width , height , title , fullscreen ? fullscreenMonitor : <int> , oldWindow ) ; if ( newWindow = = <int> ) return false ; if ( oldWindow ! = <int> ) glfwDestroyWindow ( oldWindow ) ; window = newWindow ; this . width = Math . max ( <int> , width ) ; this . height = Math . max ( <int> , height ) ; this . fullscreen = fullscreen ; if ( ! fullscreen ) { if ( x = = - <int> | | y = = - <int> ) { DisplayMode mode = getDesktopDisplayMode ( ) ; x = ( mode . width - width ) / <int> ; y = ( mode . height - height ) / <int> ; } glfwSetWindowPos ( window , x , y ) ; } if ( ! mouseCaptured ) glfwSetInputMode ( window , GLFW_CURSOR_MODE , GLFW_CURSOR_NORMAL ) ; glfwMakeContextCurrent ( newWindow ) ; setVSync ( vSync ) ; if ( visible ) glfwShowWindow ( window ) ; return true ; } void frameStart ( long time ) { if ( lastTime = = - <int> ) lastTime = time ; deltaTime = ( time - lastTime ) / <float> ; lastTime = time ; if ( time - frameStart > = <int> ) { fps = frames ; frames = <int> ; frameStart = time ; } frames + + ; frameId + + ; } void sizeChanged ( int width , int height ) { if ( isMac ) { glfwShowWindow ( window ) ; } width = Math . max ( <int> , width ) ; height = Math . max ( <int> , height ) ; this . width = width ; this . height = height ; Gdx . gl . glViewport ( <int> , <int> , width , height ) ; ApplicationListener listener = Gdx . app . getApplicationListener ( ) ; if ( listener ! = null ) listener . resize ( width , height ) ; requestRendering ( ) ; } void positionChanged ( int x , int y ) { this . x = x ; this . y = y ; } public boolean isGL20Available ( ) { return gl20 ! = null ; } public GL20 getGL20 ( ) { return gl20 ; } public int getWidth ( ) { return width ; } public int getHeight ( ) { return height ; } public long getFrameId ( ) { return frameId ; } public float getDeltaTime ( ) { return deltaTime ; } public float getRawDeltaTime ( ) { return deltaTime ; } public int getFramesPerSecond ( ) { return fps ; } public GraphicsType getType ( ) { return GraphicsType . JGLFW ; } public float getPpiX ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) ; } public float getPpiY ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) ; } public float getPpcX ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <float> ; } public float getPpcY ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <float> ; } public float getDensity ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <int> f ; } public boolean supportsDisplayModeChange ( ) { return true ; } private long getWindowMonitor ( ) { if ( window ! = <int> ) { long monitor = glfwGetWindowMonitor ( window ) ; if ( monitor ! = <int> ) return monitor ; } return glfwGetPrimaryMonitor ( ) ; } public DisplayMode [ ] getDisplayModes ( ) { Array < DisplayMode > modes = new Array ( ) ; for ( GlfwVideoMode mode : glfwGetVideoModes ( getWindowMonitor ( ) ) ) modes . add ( new JglfwDisplayMode ( mode . width , mode . height , <int> , mode . redBits + mode . greenBits + mode . blueBits ) ) ; return modes . toArray ( DisplayMode . class ) ; } public DisplayMode getDesktopDisplayMode ( ) { GlfwVideoMode mode = glfwGetVideoMode ( getWindowMonitor ( ) ) ; return new JglfwDisplayMode ( mode . width , mode . height , <int> , mode . redBits + mode . greenBits + mode . blueBits ) ; } public boolean setDisplayMode ( DisplayMode displayMode ) { bufferFormat = new BufferFormat ( displayMode . bitsPerPixel = = <int> ? <int> : <int> , displayMode . bitsPerPixel = = <int> ? <int> : <int> , displayMode . bitsPerPixel = = <int> ? <int> : <int> , bufferFormat . a , bufferFormat . depth , bufferFormat . stencil , bufferFormat . samples , false ) ; boolean success = createWindow ( displayMode . width , displayMode . height , fullscreen ) ; if ( success & & fullscreen ) sizeChanged ( displayMode . width , displayMode . height ) ; return success ; } public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { if ( fullscreen | | this . fullscreen ) { boolean success = createWindow ( width , height , fullscreen ) ; if ( success & & fullscreen ) sizeChanged ( width , height ) ; return success ; } glfwSetWindowSize ( window , width , height ) ; return true ; } public void setTitle ( String title ) { if ( title = = null ) title = <str> ; glfwSetWindowTitle ( window , title ) ; this . title = title ; } public void setVSync ( boolean vsync ) { this . vSync = vsync ; glfwSwapInterval ( vsync ? <int> : <int> ) ; } public BufferFormat getBufferFormat ( ) { return bufferFormat ; } public boolean supportsExtension ( String extension ) { return glfwExtensionSupported ( extension ) ; } public void setContinuousRendering ( boolean isContinuous ) { this . isContinuous = isContinuous ; } public boolean isContinuousRendering ( ) { return isContinuous ; } public void requestRendering ( ) { renderRequested = true ; } public boolean isFullscreen ( ) { return fullscreen ; } public long getWindow ( ) { return window ; } public int getX ( ) { return x ; } public int getY ( ) { return y ; } public void setPosition ( int x , int y ) { glfwSetWindowPos ( window , x , y ) ; } public void hide ( ) { visible = false ; glfwHideWindow ( window ) ; } public void show ( ) { visible = true ; glfwShowWindow ( window ) ; Gdx . gl . glClearColor ( initialBackgroundColor . r , initialBackgroundColor . g , initialBackgroundColor . b , initialBackgroundColor . a ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; glfwSwapBuffers ( window ) ; } public boolean isHidden ( ) { return ! visible ; } public boolean isMinimized ( ) { return minimized ; } public boolean isForeground ( ) { return foreground ; } public void minimize ( ) { glfwIconifyWindow ( window ) ; } public void restore ( ) { glfwRestoreWindow ( window ) ; } boolean shouldRender ( ) { try { return renderRequested | | isContinuous ; } finally { renderRequested = false ; } } static class JglfwDisplayMode extends DisplayMode { protected JglfwDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel ) { super ( width , height , refreshRate , bitsPerPixel ) ; } } @Override public boolean isGL30Available ( ) { return false ; } @Override public GL30 getGL30 ( ) { return null ; } @Override public Cursor newCursor ( Pixmap pixmap , int xHotspot , int yHotspot ) { return null ; } @Override public void setCursor ( Cursor cursor ) { } } 
