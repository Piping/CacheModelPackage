package io . netty . util . internal . chmv8 ; import java . io . Serializable ; import java . lang . ref . ReferenceQueue ; import java . lang . ref . WeakReference ; import java . lang . reflect . Constructor ; import java . util . Collection ; import java . util . List ; import java . util . RandomAccess ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . Phaser ; import java . util . concurrent . RecursiveAction ; import java . util . concurrent . RecursiveTask ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RunnableFuture ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . locks . ReentrantLock ; @SuppressWarnings ( <str> ) public abstract class ForkJoinTask < V > implements Future < V > , Serializable { volatile int status ; static final int DONE_MASK = <hex> ; static final int NORMAL = <hex> ; static final int CANCELLED = <hex> ; static final int EXCEPTIONAL = <hex> ; static final int SIGNAL = <hex> ; static final int SMASK = <hex> ; private int setCompletion ( int completion ) { for ( int s ; ; ) { if ( ( s = status ) < <int> ) return s ; if ( U . compareAndSwapInt ( this , STATUS , s , s | completion ) ) { if ( ( s > > > <int> ) ! = <int> ) synchronized ( this ) { notifyAll ( ) ; } return completion ; } } } final int doExec ( ) { int s ; boolean completed ; if ( ( s = status ) > = <int> ) { try { completed = exec ( ) ; } catch ( Throwable rex ) { return setExceptionalCompletion ( rex ) ; } if ( completed ) s = setCompletion ( NORMAL ) ; } return s ; } final boolean trySetSignal ( ) { int s = status ; return s > = <int> & & U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ; } private int externalAwaitDone ( ) { int s ; ForkJoinPool cp = ForkJoinPool . common ; if ( ( s = status ) > = <int> ) { if ( cp ! = null ) { if ( this instanceof CountedCompleter ) s = cp . externalHelpComplete ( ( CountedCompleter < ? > ) this ) ; else if ( cp . tryExternalUnpush ( this ) ) s = doExec ( ) ; } if ( s > = <int> & & ( s = status ) > = <int> ) { boolean interrupted = false ; do { if ( U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { synchronized ( this ) { if ( status > = <int> ) { try { wait ( ) ; } catch ( InterruptedException ie ) { interrupted = true ; } } else notifyAll ( ) ; } } } while ( ( s = status ) > = <int> ) ; if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; } } return s ; } private int externalInterruptibleAwaitDone ( ) throws InterruptedException { int s ; ForkJoinPool cp = ForkJoinPool . common ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; if ( ( s = status ) > = <int> & & cp ! = null ) { if ( this instanceof CountedCompleter ) cp . externalHelpComplete ( ( CountedCompleter < ? > ) this ) ; else if ( cp . tryExternalUnpush ( this ) ) doExec ( ) ; } while ( ( s = status ) > = <int> ) { if ( U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { synchronized ( this ) { if ( status > = <int> ) wait ( ) ; else notifyAll ( ) ; } } } return s ; } private int doJoin ( ) { int s ; Thread t ; ForkJoinWorkerThread wt ; ForkJoinPool . WorkQueue w ; return ( s = status ) < <int> ? s : ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ? ( w = ( wt = ( ForkJoinWorkerThread ) t ) . workQueue ) . tryUnpush ( this ) & & ( s = doExec ( ) ) < <int> ? s : wt . pool . awaitJoin ( w , this ) : externalAwaitDone ( ) ; } private int doInvoke ( ) { int s ; Thread t ; ForkJoinWorkerThread wt ; return ( s = doExec ( ) ) < <int> ? s : ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ? ( wt = ( ForkJoinWorkerThread ) t ) . pool . awaitJoin ( wt . workQueue , this ) : externalAwaitDone ( ) ; } private static final ExceptionNode [ ] exceptionTable ; private static final ReentrantLock exceptionTableLock ; private static final ReferenceQueue < Object > exceptionTableRefQueue ; private static final int EXCEPTION_MAP_CAPACITY = <int> ; static final class ExceptionNode extends WeakReference < ForkJoinTask < ? > > { final Throwable ex ; ExceptionNode next ; final long thrower ; ExceptionNode ( ForkJoinTask < ? > task , Throwable ex , ExceptionNode next ) { super ( task , exceptionTableRefQueue ) ; this . ex = ex ; this . next = next ; this . thrower = Thread . currentThread ( ) . getId ( ) ; } } final int recordExceptionalCompletion ( Throwable ex ) { int s ; if ( ( s = status ) > = <int> ) { int h = System . identityHashCode ( this ) ; final ReentrantLock lock = exceptionTableLock ; lock . lock ( ) ; try { expungeStaleExceptions ( ) ; ExceptionNode [ ] t = exceptionTable ; int i = h & ( t . length - <int> ) ; for ( ExceptionNode e = t [ i ] ; ; e = e . next ) { if ( e = = null ) { t [ i ] = new ExceptionNode ( this , ex , t [ i ] ) ; break ; } if ( e . get ( ) = = this ) break ; } } finally { lock . unlock ( ) ; } s = setCompletion ( EXCEPTIONAL ) ; } return s ; } private int setExceptionalCompletion ( Throwable ex ) { int s = recordExceptionalCompletion ( ex ) ; if ( ( s & DONE_MASK ) = = EXCEPTIONAL ) internalPropagateException ( ex ) ; return s ; } void internalPropagateException ( Throwable ex ) { } static final void cancelIgnoringExceptions ( ForkJoinTask < ? > t ) { if ( t ! = null & & t . status > = <int> ) { try { t . cancel ( false ) ; } catch ( Throwable ignore ) { } } } private void clearExceptionalCompletion ( ) { int h = System . identityHashCode ( this ) ; final ReentrantLock lock = exceptionTableLock ; lock . lock ( ) ; try { ExceptionNode [ ] t = exceptionTable ; int i = h & ( t . length - <int> ) ; ExceptionNode e = t [ i ] ; ExceptionNode pred = null ; while ( e ! = null ) { ExceptionNode next = e . next ; if ( e . get ( ) = = this ) { if ( pred = = null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } expungeStaleExceptions ( ) ; status = <int> ; } finally { lock . unlock ( ) ; } } private Throwable getThrowableException ( ) { if ( ( status & DONE_MASK ) ! = EXCEPTIONAL ) return null ; int h = System . identityHashCode ( this ) ; ExceptionNode e ; final ReentrantLock lock = exceptionTableLock ; lock . lock ( ) ; try { expungeStaleExceptions ( ) ; ExceptionNode [ ] t = exceptionTable ; e = t [ h & ( t . length - <int> ) ] ; while ( e ! = null & & e . get ( ) ! = this ) e = e . next ; } finally { lock . unlock ( ) ; } Throwable ex ; if ( e = = null | | ( ex = e . ex ) = = null ) return null ; if ( false & & e . thrower ! = Thread . currentThread ( ) . getId ( ) ) { Class < ? extends Throwable > ec = ex . getClass ( ) ; try { Constructor < ? > noArgCtor = null ; Constructor < ? > [ ] cs = ec . getConstructors ( ) ; for ( int i = <int> ; i < cs . length ; + + i ) { Constructor < ? > c = cs [ i ] ; Class < ? > [ ] ps = c . getParameterTypes ( ) ; if ( ps . length = = <int> ) noArgCtor = c ; else if ( ps . length = = <int> & & ps [ <int> ] = = Throwable . class ) return ( Throwable ) ( c . newInstance ( ex ) ) ; } if ( noArgCtor ! = null ) { Throwable wx = ( Throwable ) ( noArgCtor . newInstance ( ) ) ; wx . initCause ( ex ) ; return wx ; } } catch ( Exception ignore ) { } } return ex ; } private static void expungeStaleExceptions ( ) { for ( Object x ; ( x = exceptionTableRefQueue . poll ( ) ) ! = null ; ) { if ( x instanceof ExceptionNode ) { ForkJoinTask < ? > key = ( ( ExceptionNode ) x ) . get ( ) ; ExceptionNode [ ] t = exceptionTable ; int i = System . identityHashCode ( key ) & ( t . length - <int> ) ; ExceptionNode e = t [ i ] ; ExceptionNode pred = null ; while ( e ! = null ) { ExceptionNode next = e . next ; if ( e = = x ) { if ( pred = = null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } } } } static final void helpExpungeStaleExceptions ( ) { final ReentrantLock lock = exceptionTableLock ; if ( lock . tryLock ( ) ) { try { expungeStaleExceptions ( ) ; } finally { lock . unlock ( ) ; } } } static void rethrow ( Throwable ex ) { if ( ex ! = null ) ForkJoinTask . < RuntimeException > uncheckedThrow ( ex ) ; } @SuppressWarnings ( <str> ) static < T extends Throwable > void uncheckedThrow ( Throwable t ) throws T { throw ( T ) t ; } private void reportException ( int s ) { if ( s = = CANCELLED ) throw new CancellationException ( ) ; if ( s = = EXCEPTIONAL ) rethrow ( getThrowableException ( ) ) ; } public final ForkJoinTask < V > fork ( ) { Thread t ; if ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ( ( ForkJoinWorkerThread ) t ) . workQueue . push ( this ) ; else ForkJoinPool . common . externalPush ( this ) ; return this ; } public final V join ( ) { int s ; if ( ( s = doJoin ( ) & DONE_MASK ) ! = NORMAL ) reportException ( s ) ; return getRawResult ( ) ; } public final V invoke ( ) { int s ; if ( ( s = doInvoke ( ) & DONE_MASK ) ! = NORMAL ) reportException ( s ) ; return getRawResult ( ) ; } public static void invokeAll ( ForkJoinTask < ? > t1 , ForkJoinTask < ? > t2 ) { int s1 , s2 ; t2 . fork ( ) ; if ( ( s1 = t1 . doInvoke ( ) & DONE_MASK ) ! = NORMAL ) t1 . reportException ( s1 ) ; if ( ( s2 = t2 . doJoin ( ) & DONE_MASK ) ! = NORMAL ) t2 . reportException ( s2 ) ; } public static void invokeAll ( ForkJoinTask < ? > . . . tasks ) { Throwable ex = null ; int last = tasks . length - <int> ; for ( int i = last ; i > = <int> ; - - i ) { ForkJoinTask < ? > t = tasks [ i ] ; if ( t = = null ) { if ( ex = = null ) ex = new NullPointerException ( ) ; } else if ( i ! = <int> ) t . fork ( ) ; else if ( t . doInvoke ( ) < NORMAL & & ex = = null ) ex = t . getException ( ) ; } for ( int i = <int> ; i < = last ; + + i ) { ForkJoinTask < ? > t = tasks [ i ] ; if ( t ! = null ) { if ( ex ! = null ) t . cancel ( false ) ; else if ( t . doJoin ( ) < NORMAL ) ex = t . getException ( ) ; } } if ( ex ! = null ) rethrow ( ex ) ; } public static < T extends ForkJoinTask < ? > > Collection < T > invokeAll ( Collection < T > tasks ) { if ( ! ( tasks instanceof RandomAccess ) | | ! ( tasks instanceof List < ? > ) ) { invokeAll ( tasks . toArray ( new ForkJoinTask < ? > [ tasks . size ( ) ] ) ) ; return tasks ; } @SuppressWarnings ( <str> ) List < ? extends ForkJoinTask < ? > > ts = ( List < ? extends ForkJoinTask < ? > > ) tasks ; Throwable ex = null ; int last = ts . size ( ) - <int> ; for ( int i = last ; i > = <int> ; - - i ) { ForkJoinTask < ? > t = ts . get ( i ) ; if ( t = = null ) { if ( ex = = null ) ex = new NullPointerException ( ) ; } else if ( i ! = <int> ) t . fork ( ) ; else if ( t . doInvoke ( ) < NORMAL & & ex = = null ) ex = t . getException ( ) ; } for ( int i = <int> ; i < = last ; + + i ) { ForkJoinTask < ? > t = ts . get ( i ) ; if ( t ! = null ) { if ( ex ! = null ) t . cancel ( false ) ; else if ( t . doJoin ( ) < NORMAL ) ex = t . getException ( ) ; } } if ( ex ! = null ) rethrow ( ex ) ; return tasks ; } public boolean cancel ( boolean mayInterruptIfRunning ) { return ( setCompletion ( CANCELLED ) & DONE_MASK ) = = CANCELLED ; } public final boolean isDone ( ) { return status < <int> ; } public final boolean isCancelled ( ) { return ( status & DONE_MASK ) = = CANCELLED ; } public final boolean isCompletedAbnormally ( ) { return status < NORMAL ; } public final boolean isCompletedNormally ( ) { return ( status & DONE_MASK ) = = NORMAL ; } public final Throwable getException ( ) { int s = status & DONE_MASK ; return ( ( s > = NORMAL ) ? null : ( s = = CANCELLED ) ? new CancellationException ( ) : getThrowableException ( ) ) ; } public void completeExceptionally ( Throwable ex ) { setExceptionalCompletion ( ( ex instanceof RuntimeException ) | | ( ex instanceof Error ) ? ex : new RuntimeException ( ex ) ) ; } public void complete ( V value ) { try { setRawResult ( value ) ; } catch ( Throwable rex ) { setExceptionalCompletion ( rex ) ; return ; } setCompletion ( NORMAL ) ; } public final void quietlyComplete ( ) { setCompletion ( NORMAL ) ; } public final V get ( ) throws InterruptedException , ExecutionException { int s = ( Thread . currentThread ( ) instanceof ForkJoinWorkerThread ) ? doJoin ( ) : externalInterruptibleAwaitDone ( ) ; Throwable ex ; if ( ( s & = DONE_MASK ) = = CANCELLED ) throw new CancellationException ( ) ; if ( s = = EXCEPTIONAL & & ( ex = getThrowableException ( ) ) ! = null ) throw new ExecutionException ( ex ) ; return getRawResult ( ) ; } public final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; int s ; long ms ; long ns = unit . toNanos ( timeout ) ; ForkJoinPool cp ; if ( ( s = status ) > = <int> & & ns > <int> L ) { long deadline = System . nanoTime ( ) + ns ; ForkJoinPool p = null ; ForkJoinPool . WorkQueue w = null ; Thread t = Thread . currentThread ( ) ; if ( t instanceof ForkJoinWorkerThread ) { ForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; p = wt . pool ; w = wt . workQueue ; p . helpJoinOnce ( w , this ) ; } else if ( ( cp = ForkJoinPool . common ) ! = null ) { if ( this instanceof CountedCompleter ) cp . externalHelpComplete ( ( CountedCompleter < ? > ) this ) ; else if ( cp . tryExternalUnpush ( this ) ) doExec ( ) ; } boolean canBlock = false ; boolean interrupted = false ; try { while ( ( s = status ) > = <int> ) { if ( w ! = null & & w . qlock < <int> ) cancelIgnoringExceptions ( this ) ; else if ( ! canBlock ) { if ( p = = null | | p . tryCompensate ( p . ctl ) ) canBlock = true ; } else { if ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > <int> L & & U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { synchronized ( this ) { if ( status > = <int> ) { try { wait ( ms ) ; } catch ( InterruptedException ie ) { if ( p = = null ) interrupted = true ; } } else notifyAll ( ) ; } } if ( ( s = status ) < <int> | | interrupted | | ( ns = deadline - System . nanoTime ( ) ) < = <int> L ) break ; } } } finally { if ( p ! = null & & canBlock ) p . incrementActiveCount ( ) ; } if ( interrupted ) throw new InterruptedException ( ) ; } if ( ( s & = DONE_MASK ) ! = NORMAL ) { Throwable ex ; if ( s = = CANCELLED ) throw new CancellationException ( ) ; if ( s ! = EXCEPTIONAL ) throw new TimeoutException ( ) ; if ( ( ex = getThrowableException ( ) ) ! = null ) throw new ExecutionException ( ex ) ; } return getRawResult ( ) ; } public final void quietlyJoin ( ) { doJoin ( ) ; } public final void quietlyInvoke ( ) { doInvoke ( ) ; } public static void helpQuiesce ( ) { Thread t ; if ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) { ForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; wt . pool . helpQuiescePool ( wt . workQueue ) ; } else ForkJoinPool . quiesceCommonPool ( ) ; } public void reinitialize ( ) { if ( ( status & DONE_MASK ) = = EXCEPTIONAL ) clearExceptionalCompletion ( ) ; else status = <int> ; } public static ForkJoinPool getPool ( ) { Thread t = Thread . currentThread ( ) ; return ( t instanceof ForkJoinWorkerThread ) ? ( ( ForkJoinWorkerThread ) t ) . pool : null ; } public static boolean inForkJoinPool ( ) { return Thread . currentThread ( ) instanceof ForkJoinWorkerThread ; } public boolean tryUnfork ( ) { Thread t ; return ( ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ? ( ( ForkJoinWorkerThread ) t ) . workQueue . tryUnpush ( this ) : ForkJoinPool . common . tryExternalUnpush ( this ) ) ; } public static int getQueuedTaskCount ( ) { Thread t ; ForkJoinPool . WorkQueue q ; if ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) q = ( ( ForkJoinWorkerThread ) t ) . workQueue ; else q = ForkJoinPool . commonSubmitterQueue ( ) ; return ( q = = null ) ? <int> : q . queueSize ( ) ; } public static int getSurplusQueuedTaskCount ( ) { return ForkJoinPool . getSurplusQueuedTaskCount ( ) ; } public abstract V getRawResult ( ) ; protected abstract void setRawResult ( V value ) ; protected abstract boolean exec ( ) ; protected static ForkJoinTask < ? > peekNextLocalTask ( ) { Thread t ; ForkJoinPool . WorkQueue q ; if ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) q = ( ( ForkJoinWorkerThread ) t ) . workQueue ; else q = ForkJoinPool . commonSubmitterQueue ( ) ; return ( q = = null ) ? null : q . peek ( ) ; } protected static ForkJoinTask < ? > pollNextLocalTask ( ) { Thread t ; return ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ? ( ( ForkJoinWorkerThread ) t ) . workQueue . nextLocalTask ( ) : null ; } protected static ForkJoinTask < ? > pollTask ( ) { Thread t ; ForkJoinWorkerThread wt ; return ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ? ( wt = ( ForkJoinWorkerThread ) t ) . pool . nextTaskFor ( wt . workQueue ) : null ; } public final short getForkJoinTaskTag ( ) { return ( short ) status ; } public final short setForkJoinTaskTag ( short tag ) { for ( int s ; ; ) { if ( U . compareAndSwapInt ( this , STATUS , s = status , ( s & ~ SMASK ) | ( tag & SMASK ) ) ) return ( short ) s ; } } public final boolean compareAndSetForkJoinTaskTag ( short e , short tag ) { for ( int s ; ; ) { if ( ( short ) ( s = status ) ! = e ) return false ; if ( U . compareAndSwapInt ( this , STATUS , s , ( s & ~ SMASK ) | ( tag & SMASK ) ) ) return true ; } } static final class AdaptedRunnable < T > extends ForkJoinTask < T > implements RunnableFuture < T > { final Runnable runnable ; T result ; AdaptedRunnable ( Runnable runnable , T result ) { if ( runnable = = null ) throw new NullPointerException ( ) ; this . runnable = runnable ; this . result = result ; } public final T getRawResult ( ) { return result ; } public final void setRawResult ( T v ) { result = v ; } public final boolean exec ( ) { runnable . run ( ) ; return true ; } public final void run ( ) { invoke ( ) ; } private static final long serialVersionUID = <int> ; } static final class AdaptedRunnableAction extends ForkJoinTask < Void > implements RunnableFuture < Void > { final Runnable runnable ; AdaptedRunnableAction ( Runnable runnable ) { if ( runnable = = null ) throw new NullPointerException ( ) ; this . runnable = runnable ; } public final Void getRawResult ( ) { return null ; } public final void setRawResult ( Void v ) { } public final boolean exec ( ) { runnable . run ( ) ; return true ; } public final void run ( ) { invoke ( ) ; } private static final long serialVersionUID = <int> ; } static final class RunnableExecuteAction extends ForkJoinTask < Void > { final Runnable runnable ; RunnableExecuteAction ( Runnable runnable ) { if ( runnable = = null ) throw new NullPointerException ( ) ; this . runnable = runnable ; } public final Void getRawResult ( ) { return null ; } public final void setRawResult ( Void v ) { } public final boolean exec ( ) { runnable . run ( ) ; return true ; } void internalPropagateException ( Throwable ex ) { rethrow ( ex ) ; } private static final long serialVersionUID = <int> ; } static final class AdaptedCallable < T > extends ForkJoinTask < T > implements RunnableFuture < T > { final Callable < ? extends T > callable ; T result ; AdaptedCallable ( Callable < ? extends T > callable ) { if ( callable = = null ) throw new NullPointerException ( ) ; this . callable = callable ; } public final T getRawResult ( ) { return result ; } public final void setRawResult ( T v ) { result = v ; } public final boolean exec ( ) { try { result = callable . call ( ) ; return true ; } catch ( Error err ) { throw err ; } catch ( RuntimeException rex ) { throw rex ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } public final void run ( ) { invoke ( ) ; } private static final long serialVersionUID = <int> ; } public static ForkJoinTask < ? > adapt ( Runnable runnable ) { return new AdaptedRunnableAction ( runnable ) ; } public static < T > ForkJoinTask < T > adapt ( Runnable runnable , T result ) { return new AdaptedRunnable < T > ( runnable , result ) ; } public static < T > ForkJoinTask < T > adapt ( Callable < ? extends T > callable ) { return new AdaptedCallable < T > ( callable ) ; } private static final long serialVersionUID = - <int> ; private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; s . writeObject ( getException ( ) ) ; } private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; Object ex = s . readObject ( ) ; if ( ex ! = null ) setExceptionalCompletion ( ( Throwable ) ex ) ; } private static final sun . misc . Unsafe U ; private static final long STATUS ; static { exceptionTableLock = new ReentrantLock ( ) ; exceptionTableRefQueue = new ReferenceQueue < Object > ( ) ; exceptionTable = new ExceptionNode [ EXCEPTION_MAP_CAPACITY ] ; try { U = getUnsafe ( ) ; Class < ? > k = ForkJoinTask . class ; STATUS = U . objectFieldOffset ( k . getDeclaredField ( <str> ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } } 
