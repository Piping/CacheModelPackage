package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . http . HttpConstants ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . multipart . HttpPostBodyUtil . SeekAheadNoBackArrayException ; import io . netty . handler . codec . http . multipart . HttpPostBodyUtil . SeekAheadOptimize ; import io . netty . handler . codec . http . multipart . HttpPostBodyUtil . TransferEncodingMechanism ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . EndOfDataDecoderException ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . ErrorDataDecoderException ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . MultiPartStatus ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . NotEnoughDataDecoderException ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . StringUtil ; import java . io . IOException ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import static io . netty . buffer . Unpooled . * ; public class HttpPostMultipartRequestDecoder implements InterfaceHttpPostRequestDecoder { private final HttpDataFactory factory ; private final HttpRequest request ; private Charset charset ; private boolean isLastChunk ; private final List < InterfaceHttpData > bodyListHttpData = new ArrayList < InterfaceHttpData > ( ) ; private final Map < String , List < InterfaceHttpData > > bodyMapHttpData = new TreeMap < String , List < InterfaceHttpData > > ( CaseIgnoringComparator . INSTANCE ) ; private ByteBuf undecodedChunk ; private int bodyListHttpDataRank ; private String multipartDataBoundary ; private String multipartMixedBoundary ; private MultiPartStatus currentStatus = MultiPartStatus . NOTSTARTED ; private Map < CharSequence , Attribute > currentFieldAttributes ; private FileUpload currentFileUpload ; private Attribute currentAttribute ; private boolean destroyed ; private int discardThreshold = HttpPostRequestDecoder . DEFAULT_DISCARD_THRESHOLD ; public HttpPostMultipartRequestDecoder ( HttpRequest request ) { this ( new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostMultipartRequestDecoder ( HttpDataFactory factory , HttpRequest request ) { this ( factory , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostMultipartRequestDecoder ( HttpDataFactory factory , HttpRequest request , Charset charset ) { if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } if ( request = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } this . request = request ; this . charset = charset ; this . factory = factory ; setMultipart ( this . request . headers ( ) . get ( HttpHeaderNames . CONTENT_TYPE ) ) ; if ( request instanceof HttpContent ) { offer ( ( HttpContent ) request ) ; } else { undecodedChunk = buffer ( ) ; parseBody ( ) ; } } private void setMultipart ( String contentType ) { String [ ] dataBoundary = HttpPostRequestDecoder . getMultipartDataBoundary ( contentType ) ; if ( dataBoundary ! = null ) { multipartDataBoundary = dataBoundary [ <int> ] ; if ( dataBoundary . length > <int> & & dataBoundary [ <int> ] ! = null ) { charset = Charset . forName ( dataBoundary [ <int> ] ) ; } } else { multipartDataBoundary = null ; } currentStatus = MultiPartStatus . HEADERDELIMITER ; } private void checkDestroyed ( ) { if ( destroyed ) { throw new IllegalStateException ( HttpPostMultipartRequestDecoder . class . getSimpleName ( ) + <str> ) ; } } @Override public boolean isMultipart ( ) { checkDestroyed ( ) ; return true ; } @Override public void setDiscardThreshold ( int discardThreshold ) { if ( discardThreshold < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . discardThreshold = discardThreshold ; } @Override public int getDiscardThreshold ( ) { return discardThreshold ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } return bodyListHttpData ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( String name ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } return bodyMapHttpData . get ( name ) ; } @Override public InterfaceHttpData getBodyHttpData ( String name ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } List < InterfaceHttpData > list = bodyMapHttpData . get ( name ) ; if ( list ! = null ) { return list . get ( <int> ) ; } return null ; } @Override public HttpPostMultipartRequestDecoder offer ( HttpContent content ) { checkDestroyed ( ) ; ByteBuf buf = content . content ( ) ; if ( undecodedChunk = = null ) { undecodedChunk = buf . copy ( ) ; } else { undecodedChunk . writeBytes ( buf ) ; } if ( content instanceof LastHttpContent ) { isLastChunk = true ; } parseBody ( ) ; if ( undecodedChunk ! = null & & undecodedChunk . writerIndex ( ) > discardThreshold ) { undecodedChunk . discardReadBytes ( ) ; } return this ; } @Override public boolean hasNext ( ) { checkDestroyed ( ) ; if ( currentStatus = = MultiPartStatus . EPILOGUE ) { if ( bodyListHttpDataRank > = bodyListHttpData . size ( ) ) { throw new EndOfDataDecoderException ( ) ; } } return ! bodyListHttpData . isEmpty ( ) & & bodyListHttpDataRank < bodyListHttpData . size ( ) ; } @Override public InterfaceHttpData next ( ) { checkDestroyed ( ) ; if ( hasNext ( ) ) { return bodyListHttpData . get ( bodyListHttpDataRank + + ) ; } return null ; } @Override public InterfaceHttpData currentPartialHttpData ( ) { if ( currentFileUpload ! = null ) { return currentFileUpload ; } else { return currentAttribute ; } } private void parseBody ( ) { if ( currentStatus = = MultiPartStatus . PREEPILOGUE | | currentStatus = = MultiPartStatus . EPILOGUE ) { if ( isLastChunk ) { currentStatus = MultiPartStatus . EPILOGUE ; } return ; } parseBodyMultipart ( ) ; } protected void addHttpData ( InterfaceHttpData data ) { if ( data = = null ) { return ; } List < InterfaceHttpData > datas = bodyMapHttpData . get ( data . getName ( ) ) ; if ( datas = = null ) { datas = new ArrayList < InterfaceHttpData > ( <int> ) ; bodyMapHttpData . put ( data . getName ( ) , datas ) ; } datas . add ( data ) ; bodyListHttpData . add ( data ) ; } private void parseBodyMultipart ( ) { if ( undecodedChunk = = null | | undecodedChunk . readableBytes ( ) = = <int> ) { return ; } InterfaceHttpData data = decodeMultipart ( currentStatus ) ; while ( data ! = null ) { addHttpData ( data ) ; if ( currentStatus = = MultiPartStatus . PREEPILOGUE | | currentStatus = = MultiPartStatus . EPILOGUE ) { break ; } data = decodeMultipart ( currentStatus ) ; } } private InterfaceHttpData decodeMultipart ( MultiPartStatus state ) { switch ( state ) { case NOTSTARTED : throw new ErrorDataDecoderException ( <str> ) ; case PREAMBLE : throw new ErrorDataDecoderException ( <str> ) ; case HEADERDELIMITER : { return findMultipartDelimiter ( multipartDataBoundary , MultiPartStatus . DISPOSITION , MultiPartStatus . PREEPILOGUE ) ; } case DISPOSITION : { return findMultipartDisposition ( ) ; } case FIELD : { Charset localCharset = null ; Attribute charsetAttribute = currentFieldAttributes . get ( HttpHeaderValues . CHARSET ) ; if ( charsetAttribute ! = null ) { try { localCharset = Charset . forName ( charsetAttribute . getValue ( ) ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } Attribute nameAttribute = currentFieldAttributes . get ( HttpHeaderValues . NAME ) ; if ( currentAttribute = = null ) { Attribute lengthAttribute = currentFieldAttributes . get ( HttpHeaderNames . CONTENT_LENGTH ) ; long size ; try { size = lengthAttribute ! = null ? Long . parseLong ( lengthAttribute . getValue ( ) ) : <int> L ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( NumberFormatException e ) { size = <int> ; } try { if ( size > <int> ) { currentAttribute = factory . createAttribute ( request , cleanString ( nameAttribute . getValue ( ) ) , size ) ; } else { currentAttribute = factory . createAttribute ( request , cleanString ( nameAttribute . getValue ( ) ) ) ; } } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } if ( localCharset ! = null ) { currentAttribute . setCharset ( localCharset ) ; } } try { loadFieldMultipart ( multipartDataBoundary ) ; } catch ( NotEnoughDataDecoderException ignored ) { return null ; } Attribute finalAttribute = currentAttribute ; currentAttribute = null ; currentFieldAttributes = null ; currentStatus = MultiPartStatus . HEADERDELIMITER ; return finalAttribute ; } case FILEUPLOAD : { return getFileUpload ( multipartDataBoundary ) ; } case MIXEDDELIMITER : { return findMultipartDelimiter ( multipartMixedBoundary , MultiPartStatus . MIXEDDISPOSITION , MultiPartStatus . HEADERDELIMITER ) ; } case MIXEDDISPOSITION : { return findMultipartDisposition ( ) ; } case MIXEDFILEUPLOAD : { return getFileUpload ( multipartMixedBoundary ) ; } case PREEPILOGUE : return null ; case EPILOGUE : return null ; default : throw new ErrorDataDecoderException ( <str> ) ; } } void skipControlCharacters ( ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { try { skipControlCharactersStandard ( ) ; } catch ( IndexOutOfBoundsException e1 ) { throw new NotEnoughDataDecoderException ( e1 ) ; } return ; } while ( sao . pos < sao . limit ) { char c = ( char ) ( sao . bytes [ sao . pos + + ] & <hex> ) ; if ( ! Character . isISOControl ( c ) & & ! Character . isWhitespace ( c ) ) { sao . setReadPosition ( <int> ) ; return ; } } throw new NotEnoughDataDecoderException ( <str> ) ; } void skipControlCharactersStandard ( ) { for ( ; ; ) { char c = ( char ) undecodedChunk . readUnsignedByte ( ) ; if ( ! Character . isISOControl ( c ) & & ! Character . isWhitespace ( c ) ) { undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; break ; } } } private InterfaceHttpData findMultipartDelimiter ( String delimiter , MultiPartStatus dispositionStatus , MultiPartStatus closeDelimiterStatus ) { int readerIndex = undecodedChunk . readerIndex ( ) ; try { skipControlCharacters ( ) ; } catch ( NotEnoughDataDecoderException ignored ) { undecodedChunk . readerIndex ( readerIndex ) ; return null ; } skipOneLine ( ) ; String newline ; try { newline = readDelimiter ( delimiter ) ; } catch ( NotEnoughDataDecoderException ignored ) { undecodedChunk . readerIndex ( readerIndex ) ; return null ; } if ( newline . equals ( delimiter ) ) { currentStatus = dispositionStatus ; return decodeMultipart ( dispositionStatus ) ; } if ( newline . equals ( delimiter + <str> ) ) { currentStatus = closeDelimiterStatus ; if ( currentStatus = = MultiPartStatus . HEADERDELIMITER ) { currentFieldAttributes = null ; return decodeMultipart ( MultiPartStatus . HEADERDELIMITER ) ; } return null ; } undecodedChunk . readerIndex ( readerIndex ) ; throw new ErrorDataDecoderException ( <str> ) ; } private InterfaceHttpData findMultipartDisposition ( ) { int readerIndex = undecodedChunk . readerIndex ( ) ; if ( currentStatus = = MultiPartStatus . DISPOSITION ) { currentFieldAttributes = new TreeMap < CharSequence , Attribute > ( CaseIgnoringComparator . INSTANCE ) ; } while ( ! skipOneLine ( ) ) { String newline ; try { skipControlCharacters ( ) ; newline = readLine ( ) ; } catch ( NotEnoughDataDecoderException ignored ) { undecodedChunk . readerIndex ( readerIndex ) ; return null ; } String [ ] contents = splitMultipartHeader ( newline ) ; if ( HttpHeaderNames . CONTENT_DISPOSITION . contentEqualsIgnoreCase ( contents [ <int> ] ) ) { boolean checkSecondArg ; if ( currentStatus = = MultiPartStatus . DISPOSITION ) { checkSecondArg = HttpHeaderValues . FORM_DATA . contentEqualsIgnoreCase ( contents [ <int> ] ) ; } else { checkSecondArg = HttpHeaderValues . ATTACHMENT . contentEqualsIgnoreCase ( contents [ <int> ] ) | | HttpHeaderValues . FILE . contentEqualsIgnoreCase ( contents [ <int> ] ) ; } if ( checkSecondArg ) { for ( int i = <int> ; i < contents . length ; i + + ) { String [ ] values = StringUtil . split ( contents [ i ] , <str> , <int> ) ; Attribute attribute ; try { String name = cleanString ( values [ <int> ] ) ; String value = values [ <int> ] ; if ( HttpHeaderValues . FILENAME . contentEquals ( name ) ) { value = value . substring ( <int> , value . length ( ) - <int> ) ; } else { value = cleanString ( value ) ; } attribute = factory . createAttribute ( request , name , value ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } currentFieldAttributes . put ( attribute . getName ( ) , attribute ) ; } } } else if ( HttpHeaderNames . CONTENT_TRANSFER_ENCODING . contentEqualsIgnoreCase ( contents [ <int> ] ) ) { Attribute attribute ; try { attribute = factory . createAttribute ( request , HttpHeaderNames . CONTENT_TRANSFER_ENCODING . toString ( ) , cleanString ( contents [ <int> ] ) ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } currentFieldAttributes . put ( HttpHeaderNames . CONTENT_TRANSFER_ENCODING , attribute ) ; } else if ( HttpHeaderNames . CONTENT_LENGTH . contentEqualsIgnoreCase ( contents [ <int> ] ) ) { Attribute attribute ; try { attribute = factory . createAttribute ( request , HttpHeaderNames . CONTENT_LENGTH . toString ( ) , cleanString ( contents [ <int> ] ) ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } currentFieldAttributes . put ( HttpHeaderNames . CONTENT_LENGTH , attribute ) ; } else if ( HttpHeaderNames . CONTENT_TYPE . contentEqualsIgnoreCase ( contents [ <int> ] ) ) { if ( HttpHeaderValues . MULTIPART_MIXED . contentEqualsIgnoreCase ( contents [ <int> ] ) ) { if ( currentStatus = = MultiPartStatus . DISPOSITION ) { String values = StringUtil . substringAfter ( contents [ <int> ] , <str> ) ; multipartMixedBoundary = <str> + values ; currentStatus = MultiPartStatus . MIXEDDELIMITER ; return decodeMultipart ( MultiPartStatus . MIXEDDELIMITER ) ; } else { throw new ErrorDataDecoderException ( <str> ) ; } } else { for ( int i = <int> ; i < contents . length ; i + + ) { if ( contents [ i ] . toLowerCase ( ) . startsWith ( HttpHeaderValues . CHARSET . toString ( ) ) ) { String values = StringUtil . substringAfter ( contents [ i ] , <str> ) ; Attribute attribute ; try { attribute = factory . createAttribute ( request , HttpHeaderValues . CHARSET . toString ( ) , cleanString ( values ) ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } currentFieldAttributes . put ( HttpHeaderValues . CHARSET , attribute ) ; } else { Attribute attribute ; try { attribute = factory . createAttribute ( request , cleanString ( contents [ <int> ] ) , contents [ i ] ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } currentFieldAttributes . put ( attribute . getName ( ) , attribute ) ; } } } } else { throw new ErrorDataDecoderException ( <str> + newline ) ; } } Attribute filenameAttribute = currentFieldAttributes . get ( HttpHeaderValues . FILENAME ) ; if ( currentStatus = = MultiPartStatus . DISPOSITION ) { if ( filenameAttribute ! = null ) { currentStatus = MultiPartStatus . FILEUPLOAD ; return decodeMultipart ( MultiPartStatus . FILEUPLOAD ) ; } else { currentStatus = MultiPartStatus . FIELD ; return decodeMultipart ( MultiPartStatus . FIELD ) ; } } else { if ( filenameAttribute ! = null ) { currentStatus = MultiPartStatus . MIXEDFILEUPLOAD ; return decodeMultipart ( MultiPartStatus . MIXEDFILEUPLOAD ) ; } else { throw new ErrorDataDecoderException ( <str> ) ; } } } protected InterfaceHttpData getFileUpload ( String delimiter ) { Attribute encoding = currentFieldAttributes . get ( HttpHeaderNames . CONTENT_TRANSFER_ENCODING ) ; Charset localCharset = charset ; TransferEncodingMechanism mechanism = TransferEncodingMechanism . BIT7 ; if ( encoding ! = null ) { String code ; try { code = encoding . getValue ( ) . toLowerCase ( ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } if ( code . equals ( HttpPostBodyUtil . TransferEncodingMechanism . BIT7 . value ( ) ) ) { localCharset = CharsetUtil . US_ASCII ; } else if ( code . equals ( HttpPostBodyUtil . TransferEncodingMechanism . BIT8 . value ( ) ) ) { localCharset = CharsetUtil . ISO_8859_1 ; mechanism = TransferEncodingMechanism . BIT8 ; } else if ( code . equals ( HttpPostBodyUtil . TransferEncodingMechanism . BINARY . value ( ) ) ) { mechanism = TransferEncodingMechanism . BINARY ; } else { throw new ErrorDataDecoderException ( <str> + code ) ; } } Attribute charsetAttribute = currentFieldAttributes . get ( HttpHeaderValues . CHARSET ) ; if ( charsetAttribute ! = null ) { try { localCharset = Charset . forName ( charsetAttribute . getValue ( ) ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } if ( currentFileUpload = = null ) { Attribute filenameAttribute = currentFieldAttributes . get ( HttpHeaderValues . FILENAME ) ; Attribute nameAttribute = currentFieldAttributes . get ( HttpHeaderValues . NAME ) ; Attribute contentTypeAttribute = currentFieldAttributes . get ( HttpHeaderNames . CONTENT_TYPE ) ; if ( contentTypeAttribute = = null ) { throw new ErrorDataDecoderException ( <str> ) ; } Attribute lengthAttribute = currentFieldAttributes . get ( HttpHeaderNames . CONTENT_LENGTH ) ; long size ; try { size = lengthAttribute ! = null ? Long . parseLong ( lengthAttribute . getValue ( ) ) : <int> L ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( NumberFormatException ignored ) { size = <int> ; } try { currentFileUpload = factory . createFileUpload ( request , cleanString ( nameAttribute . getValue ( ) ) , cleanString ( filenameAttribute . getValue ( ) ) , contentTypeAttribute . getValue ( ) , mechanism . value ( ) , localCharset , size ) ; } catch ( NullPointerException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( e ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } try { readFileUploadByteMultipart ( delimiter ) ; } catch ( NotEnoughDataDecoderException e ) { return null ; } if ( currentFileUpload . isCompleted ( ) ) { if ( currentStatus = = MultiPartStatus . FILEUPLOAD ) { currentStatus = MultiPartStatus . HEADERDELIMITER ; currentFieldAttributes = null ; } else { currentStatus = MultiPartStatus . MIXEDDELIMITER ; cleanMixedAttributes ( ) ; } FileUpload fileUpload = currentFileUpload ; currentFileUpload = null ; return fileUpload ; } return null ; } @Override public void destroy ( ) { checkDestroyed ( ) ; cleanFiles ( ) ; destroyed = true ; if ( undecodedChunk ! = null & & undecodedChunk . refCnt ( ) > <int> ) { undecodedChunk . release ( ) ; undecodedChunk = null ; } for ( int i = bodyListHttpDataRank ; i < bodyListHttpData . size ( ) ; i + + ) { bodyListHttpData . get ( i ) . release ( ) ; } } @Override public void cleanFiles ( ) { checkDestroyed ( ) ; factory . cleanRequestHttpData ( request ) ; } @Override public void removeHttpDataFromClean ( InterfaceHttpData data ) { checkDestroyed ( ) ; factory . removeHttpDataFromClean ( request , data ) ; } private void cleanMixedAttributes ( ) { currentFieldAttributes . remove ( HttpHeaderValues . CHARSET ) ; currentFieldAttributes . remove ( HttpHeaderNames . CONTENT_LENGTH ) ; currentFieldAttributes . remove ( HttpHeaderNames . CONTENT_TRANSFER_ENCODING ) ; currentFieldAttributes . remove ( HttpHeaderNames . CONTENT_TYPE ) ; currentFieldAttributes . remove ( HttpHeaderValues . FILENAME ) ; } private String readLineStandard ( ) { int readerIndex = undecodedChunk . readerIndex ( ) ; try { ByteBuf line = buffer ( <int> ) ; while ( undecodedChunk . isReadable ( ) ) { byte nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . CR ) { nextByte = undecodedChunk . getByte ( undecodedChunk . readerIndex ( ) ) ; if ( nextByte = = HttpConstants . LF ) { undecodedChunk . readByte ( ) ; return line . toString ( charset ) ; } else { line . writeByte ( HttpConstants . CR ) ; } } else if ( nextByte = = HttpConstants . LF ) { return line . toString ( charset ) ; } else { line . writeByte ( nextByte ) ; } } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } private String readLine ( ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { return readLineStandard ( ) ; } int readerIndex = undecodedChunk . readerIndex ( ) ; try { ByteBuf line = buffer ( <int> ) ; while ( sao . pos < sao . limit ) { byte nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return line . toString ( charset ) ; } else { sao . pos - - ; line . writeByte ( HttpConstants . CR ) ; } } else { line . writeByte ( nextByte ) ; } } else if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return line . toString ( charset ) ; } else { line . writeByte ( nextByte ) ; } } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } private String readDelimiterStandard ( String delimiter ) { int readerIndex = undecodedChunk . readerIndex ( ) ; try { StringBuilder sb = new StringBuilder ( <int> ) ; int delimiterPos = <int> ; int len = delimiter . length ( ) ; while ( undecodedChunk . isReadable ( ) & & delimiterPos < len ) { byte nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = delimiter . charAt ( delimiterPos ) ) { delimiterPos + + ; sb . append ( ( char ) nextByte ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } if ( undecodedChunk . isReadable ( ) ) { byte nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . CR ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { return sb . toString ( ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else if ( nextByte = = HttpConstants . LF ) { return sb . toString ( ) ; } else if ( nextByte = = <str> ) { sb . append ( <str> ) ; nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = <str> ) { sb . append ( <str> ) ; if ( undecodedChunk . isReadable ( ) ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . CR ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { return sb . toString ( ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else if ( nextByte = = HttpConstants . LF ) { return sb . toString ( ) ; } else { undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; return sb . toString ( ) ; } } return sb . toString ( ) ; } } } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } private String readDelimiter ( String delimiter ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { return readDelimiterStandard ( delimiter ) ; } int readerIndex = undecodedChunk . readerIndex ( ) ; int delimiterPos = <int> ; int len = delimiter . length ( ) ; try { StringBuilder sb = new StringBuilder ( <int> ) ; while ( sao . pos < sao . limit & & delimiterPos < len ) { byte nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = delimiter . charAt ( delimiterPos ) ) { delimiterPos + + ; sb . append ( ( char ) nextByte ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } if ( sao . pos < sao . limit ) { byte nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } else if ( nextByte = = <str> ) { sb . append ( <str> ) ; if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = <str> ) { sb . append ( <str> ) ; if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } } else if ( nextByte = = HttpConstants . LF ) { sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } else { sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } } sao . setReadPosition ( <int> ) ; return sb . toString ( ) ; } } } } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( ) ; } private void readFileUploadByteMultipartStandard ( String delimiter ) { int readerIndex = undecodedChunk . readerIndex ( ) ; boolean newLine = true ; int index = <int> ; int lastPosition = undecodedChunk . readerIndex ( ) ; boolean found = false ; while ( undecodedChunk . isReadable ( ) ) { byte nextByte = undecodedChunk . readByte ( ) ; if ( newLine ) { if ( nextByte = = delimiter . codePointAt ( index ) ) { index + + ; if ( delimiter . length ( ) = = index ) { found = true ; break ; } continue ; } else { newLine = false ; index = <int> ; if ( nextByte = = HttpConstants . CR ) { if ( undecodedChunk . isReadable ( ) ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; undecodedChunk . readerIndex ( lastPosition ) ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) ; } } } else { if ( nextByte = = HttpConstants . CR ) { if ( undecodedChunk . isReadable ( ) ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; undecodedChunk . readerIndex ( lastPosition ) ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) ; } } } ByteBuf buffer = undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) ; if ( found ) { try { currentFileUpload . addContent ( buffer , true ) ; undecodedChunk . readerIndex ( lastPosition ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } else { try { currentFileUpload . addContent ( buffer , false ) ; undecodedChunk . readerIndex ( lastPosition ) ; throw new NotEnoughDataDecoderException ( ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } } private void readFileUploadByteMultipart ( String delimiter ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { readFileUploadByteMultipartStandard ( delimiter ) ; return ; } int readerIndex = undecodedChunk . readerIndex ( ) ; boolean newLine = true ; int index = <int> ; int lastrealpos = sao . pos ; int lastPosition ; boolean found = false ; while ( sao . pos < sao . limit ) { byte nextByte = sao . bytes [ sao . pos + + ] ; if ( newLine ) { if ( nextByte = = delimiter . codePointAt ( index ) ) { index + + ; if ( delimiter . length ( ) = = index ) { found = true ; break ; } continue ; } else { newLine = false ; index = <int> ; if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { sao . pos - - ; lastrealpos = sao . pos ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { lastrealpos = sao . pos ; } } } else { if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { sao . pos - - ; lastrealpos = sao . pos ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { lastrealpos = sao . pos ; } } } lastPosition = sao . getReadPosition ( lastrealpos ) ; ByteBuf buffer = undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) ; if ( found ) { try { currentFileUpload . addContent ( buffer , true ) ; undecodedChunk . readerIndex ( lastPosition ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } else { try { currentFileUpload . addContent ( buffer , false ) ; undecodedChunk . readerIndex ( lastPosition ) ; throw new NotEnoughDataDecoderException ( ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } } } private void loadFieldMultipartStandard ( String delimiter ) { int readerIndex = undecodedChunk . readerIndex ( ) ; try { boolean newLine = true ; int index = <int> ; int lastPosition = undecodedChunk . readerIndex ( ) ; boolean found = false ; while ( undecodedChunk . isReadable ( ) ) { byte nextByte = undecodedChunk . readByte ( ) ; if ( newLine ) { if ( nextByte = = delimiter . codePointAt ( index ) ) { index + + ; if ( delimiter . length ( ) = = index ) { found = true ; break ; } continue ; } else { newLine = false ; index = <int> ; if ( nextByte = = HttpConstants . CR ) { if ( undecodedChunk . isReadable ( ) ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; undecodedChunk . readerIndex ( lastPosition ) ; } } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) ; } } } else { if ( nextByte = = HttpConstants . CR ) { if ( undecodedChunk . isReadable ( ) ) { nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; undecodedChunk . readerIndex ( lastPosition ) ; } } else { lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastPosition = undecodedChunk . readerIndex ( ) - <int> ; } else { lastPosition = undecodedChunk . readerIndex ( ) ; } } } if ( found ) { try { currentAttribute . addContent ( undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) , true ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( lastPosition ) ; } else { try { currentAttribute . addContent ( undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) , false ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( lastPosition ) ; throw new NotEnoughDataDecoderException ( ) ; } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } } private void loadFieldMultipart ( String delimiter ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { loadFieldMultipartStandard ( delimiter ) ; return ; } int readerIndex = undecodedChunk . readerIndex ( ) ; try { boolean newLine = true ; int index = <int> ; int lastPosition ; int lastrealpos = sao . pos ; boolean found = false ; while ( sao . pos < sao . limit ) { byte nextByte = sao . bytes [ sao . pos + + ] ; if ( newLine ) { if ( nextByte = = delimiter . codePointAt ( index ) ) { index + + ; if ( delimiter . length ( ) = = index ) { found = true ; break ; } continue ; } else { newLine = false ; index = <int> ; if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { sao . pos - - ; lastrealpos = sao . pos ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { lastrealpos = sao . pos ; } } } else { if ( nextByte = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { nextByte = sao . bytes [ sao . pos + + ] ; if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { sao . pos - - ; lastrealpos = sao . pos ; } } } else if ( nextByte = = HttpConstants . LF ) { newLine = true ; index = <int> ; lastrealpos = sao . pos - <int> ; } else { lastrealpos = sao . pos ; } } } lastPosition = sao . getReadPosition ( lastrealpos ) ; if ( found ) { try { currentAttribute . addContent ( undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) , true ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( lastPosition ) ; } else { try { currentAttribute . addContent ( undecodedChunk . copy ( readerIndex , lastPosition - readerIndex ) , false ) ; } catch ( IOException e ) { throw new ErrorDataDecoderException ( e ) ; } undecodedChunk . readerIndex ( lastPosition ) ; throw new NotEnoughDataDecoderException ( ) ; } } catch ( IndexOutOfBoundsException e ) { undecodedChunk . readerIndex ( readerIndex ) ; throw new NotEnoughDataDecoderException ( e ) ; } } @SuppressWarnings ( <str> ) private static String cleanString ( String field ) { StringBuilder sb = new StringBuilder ( field . length ( ) ) ; for ( int i = <int> ; i < field . length ( ) ; i + + ) { char nextChar = field . charAt ( i ) ; if ( nextChar = = HttpConstants . COLON ) { sb . append ( HttpConstants . SP_CHAR ) ; } else if ( nextChar = = HttpConstants . COMMA ) { sb . append ( HttpConstants . SP_CHAR ) ; } else if ( nextChar = = HttpConstants . EQUALS ) { sb . append ( HttpConstants . SP_CHAR ) ; } else if ( nextChar = = HttpConstants . SEMICOLON ) { sb . append ( HttpConstants . SP_CHAR ) ; } else if ( nextChar = = HttpConstants . HT ) { sb . append ( HttpConstants . SP_CHAR ) ; } else if ( nextChar = = HttpConstants . DOUBLE_QUOTE ) { } else { sb . append ( nextChar ) ; } } return sb . toString ( ) . trim ( ) ; } private boolean skipOneLine ( ) { if ( ! undecodedChunk . isReadable ( ) ) { return false ; } byte nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . CR ) { if ( ! undecodedChunk . isReadable ( ) ) { undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; return false ; } nextByte = undecodedChunk . readByte ( ) ; if ( nextByte = = HttpConstants . LF ) { return true ; } undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; return false ; } if ( nextByte = = HttpConstants . LF ) { return true ; } undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; return false ; } private static String [ ] splitMultipartHeader ( String sb ) { ArrayList < String > headers = new ArrayList < String > ( <int> ) ; int nameStart ; int nameEnd ; int colonEnd ; int valueStart ; int valueEnd ; nameStart = HttpPostBodyUtil . findNonWhitespace ( sb , <int> ) ; for ( nameEnd = nameStart ; nameEnd < sb . length ( ) ; nameEnd + + ) { char ch = sb . charAt ( nameEnd ) ; if ( ch = = <str> | | Character . isWhitespace ( ch ) ) { break ; } } for ( colonEnd = nameEnd ; colonEnd < sb . length ( ) ; colonEnd + + ) { if ( sb . charAt ( colonEnd ) = = <str> ) { colonEnd + + ; break ; } } valueStart = HttpPostBodyUtil . findNonWhitespace ( sb , colonEnd ) ; valueEnd = HttpPostBodyUtil . findEndOfString ( sb ) ; headers . add ( sb . substring ( nameStart , nameEnd ) ) ; String svalue = sb . substring ( valueStart , valueEnd ) ; String [ ] values ; if ( svalue . indexOf ( <str> ) > = <int> ) { values = splitMultipartHeaderValues ( svalue ) ; } else { values = StringUtil . split ( svalue , <str> ) ; } for ( String value : values ) { headers . add ( value . trim ( ) ) ; } String [ ] array = new String [ headers . size ( ) ] ; for ( int i = <int> ; i < headers . size ( ) ; i + + ) { array [ i ] = headers . get ( i ) ; } return array ; } private static String [ ] splitMultipartHeaderValues ( String svalue ) { List < String > values = new ArrayList < String > ( <int> ) ; boolean inQuote = false ; boolean escapeNext = false ; int start = <int> ; for ( int i = <int> ; i < svalue . length ( ) ; i + + ) { char c = svalue . charAt ( i ) ; if ( inQuote ) { if ( escapeNext ) { escapeNext = false ; } else { if ( c = = <str> ) { escapeNext = true ; } else if ( c = = <str> ) { inQuote = false ; } } } else { if ( c = = <str> ) { inQuote = true ; } else if ( c = = <str> ) { values . add ( svalue . substring ( start , i ) ) ; start = i + <int> ; } } } values . add ( svalue . substring ( start ) ) ; return values . toArray ( new String [ values . size ( ) ] ) ; } } 
