package org . gradle . jvm . tasks . api . internal ; import org . objectweb . asm . ClassReader ; import org . objectweb . asm . ClassVisitor ; import org . objectweb . asm . ClassWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Set ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . regex . Pattern ; import static org . objectweb . asm . Opcodes . ASM5 ; public class ApiClassExtractor { private static final Pattern LOCAL_CLASS_PATTERN = Pattern . compile ( <str> ) ; private final Set < String > exportedPackages ; private final boolean apiIncludesPackagePrivateMembers ; public ApiClassExtractor ( Set < String > exportedPackages ) { this . exportedPackages = exportedPackages ; this . apiIncludesPackagePrivateMembers = exportedPackages . isEmpty ( ) ; } public boolean shouldExtractApiClassFrom ( File originalClassFile ) throws IOException { if ( ! originalClassFile . getName ( ) . endsWith ( <str> ) ) { return false ; } InputStream inputStream = new FileInputStream ( originalClassFile ) ; try { return shouldExtractApiClassFrom ( new ClassReader ( inputStream ) ) ; } finally { inputStream . close ( ) ; } } boolean shouldExtractApiClassFrom ( ClassReader originalClassReader ) { final AtomicBoolean shouldExtract = new AtomicBoolean ( ) ; originalClassReader . accept ( new ClassVisitor ( ASM5 ) { @Override public void visit ( int version , int access , String name , String signature , String superName , String [ ] interfaces ) { String originalClassName = convertAsmInternalNameToClassName ( name ) ; shouldExtract . set ( isApiClassExtractionCandidate ( access , originalClassName ) ) ; } } , ClassReader . SKIP_CODE | ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; return shouldExtract . get ( ) ; } public byte [ ] extractApiClassFrom ( File originalClassFile ) throws IOException { InputStream inputStream = new FileInputStream ( originalClassFile ) ; try { ClassReader classReader = new ClassReader ( inputStream ) ; return extractApiClassFrom ( classReader ) ; } finally { inputStream . close ( ) ; } } byte [ ] extractApiClassFrom ( ClassReader originalClassReader ) { ClassWriter apiClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; originalClassReader . accept ( new ApiMemberSelector ( new MethodStubbingApiMemberAdapter ( apiClassWriter ) , apiIncludesPackagePrivateMembers ) , ClassReader . SKIP_DEBUG | ClassReader . SKIP_FRAMES ) ; return apiClassWriter . toByteArray ( ) ; } private boolean isApiClassExtractionCandidate ( int access , String candidateClassName ) { if ( isLocalClass ( candidateClassName ) ) { return false ; } if ( ! ApiMemberSelector . isCandidateApiMember ( access , apiIncludesPackagePrivateMembers ) ) { return false ; } if ( exportedPackages . isEmpty ( ) ) { return true ; } return exportedPackages . contains ( packageNameOf ( candidateClassName ) ) ; } private static String convertAsmInternalNameToClassName ( String internalName ) { return internalName . replace ( <str> , <str> ) ; } private static String packageNameOf ( String className ) { return className . indexOf ( <str> ) > <int> ? className . substring ( <int> , className . lastIndexOf ( <str> ) ) : <str> ; } private static boolean isLocalClass ( String className ) { return LOCAL_CLASS_PATTERN . matcher ( className ) . matches ( ) ; } } 
