package org . elasticsearch . http . netty ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . http . HttpServerTransport ; import org . elasticsearch . node . Node ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . jboss . netty . handler . codec . http . HttpResponse ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Locale ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . http . netty . NettyHttpClient . returnOpaqueIds ; import static org . hamcrest . Matchers . containsInAnyOrder ; import static org . hamcrest . Matchers . hasSize ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class NettyPipeliningDisabledIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( Node . HTTP_ENABLED , true ) . put ( <str> , false ) . build ( ) ; } public void testThatNettyHttpServerDoesNotSupportPipelining ( ) throws Exception { ensureGreen ( ) ; List < String > requests = Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; HttpServerTransport httpServerTransport = internalCluster ( ) . getInstance ( HttpServerTransport . class ) ; InetSocketTransportAddress inetSocketTransportAddress = ( InetSocketTransportAddress ) randomFrom ( httpServerTransport . boundAddress ( ) . boundAddresses ( ) ) ; try ( NettyHttpClient nettyHttpClient = new NettyHttpClient ( ) ) { Collection < HttpResponse > responses = nettyHttpClient . sendRequests ( inetSocketTransportAddress . address ( ) , requests . toArray ( new String [ ] { } ) ) ; assertThat ( responses , hasSize ( requests . size ( ) ) ) ; List < String > opaqueIds = new ArrayList < > ( returnOpaqueIds ( responses ) ) ; assertResponsesOutOfOrder ( opaqueIds ) ; } } private void assertResponsesOutOfOrder ( List < String > opaqueIds ) { String message = String . format ( Locale . ROOT , <str> , opaqueIds ) ; assertThat ( message , opaqueIds , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; } } 
