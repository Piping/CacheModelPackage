package org . apache . cassandra . schema ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . stream . Collectors ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . * ; import org . apache . cassandra . config . ColumnDefinition . ClusteringOrder ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . view . View ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import static java . lang . String . format ; import static java . util . stream . Collectors . toList ; import static org . apache . cassandra . cql3 . QueryProcessor . executeInternal ; import static org . apache . cassandra . cql3 . QueryProcessor . executeOnceInternal ; import static org . apache . cassandra . schema . CQLTypeParser . parse ; public final class SchemaKeyspace { private SchemaKeyspace ( ) { } private static final Logger logger = LoggerFactory . getLogger ( SchemaKeyspace . class ) ; private static final boolean FLUSH_SCHEMA_TABLES = Boolean . valueOf ( System . getProperty ( <str> , <str> ) ) ; public static final String NAME = <str> ; public static final String KEYSPACES = <str> ; public static final String TABLES = <str> ; public static final String COLUMNS = <str> ; public static final String DROPPED_COLUMNS = <str> ; public static final String TRIGGERS = <str> ; public static final String VIEWS = <str> ; public static final String TYPES = <str> ; public static final String FUNCTIONS = <str> ; public static final String AGGREGATES = <str> ; public static final String INDEXES = <str> ; public static final List < String > ALL = ImmutableList . of ( KEYSPACES , TABLES , COLUMNS , TRIGGERS , VIEWS , TYPES , FUNCTIONS , AGGREGATES , INDEXES ) ; private static final CFMetaData Keyspaces = compile ( KEYSPACES , <str> , <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Tables = compile ( TABLES , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Columns = compile ( COLUMNS , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData DroppedColumns = compile ( DROPPED_COLUMNS , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Triggers = compile ( TRIGGERS , <str> , <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Views = compile ( VIEWS , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Indexes = compile ( INDEXES , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Types = compile ( TYPES , <str> , <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Functions = compile ( FUNCTIONS , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final CFMetaData Aggregates = compile ( AGGREGATES , <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; public static final List < CFMetaData > ALL_TABLE_METADATA = ImmutableList . of ( Keyspaces , Tables , Columns , Triggers , DroppedColumns , Views , Types , Functions , Aggregates , Indexes ) ; private static CFMetaData compile ( String name , String description , String schema ) { return CFMetaData . compile ( String . format ( schema , name ) , NAME ) . comment ( description ) . gcGraceSeconds ( ( int ) TimeUnit . DAYS . toSeconds ( <int> ) ) ; } public static KeyspaceMetadata metadata ( ) { return KeyspaceMetadata . create ( NAME , KeyspaceParams . local ( ) , org . apache . cassandra . schema . Tables . of ( ALL_TABLE_METADATA ) ) ; } public static void saveSystemKeyspacesSchema ( ) { KeyspaceMetadata system = Schema . instance . getKSMetaData ( SystemKeyspace . NAME ) ; KeyspaceMetadata schema = Schema . instance . getKSMetaData ( NAME ) ; long timestamp = FBUtilities . timestampMicros ( ) ; for ( String schemaTable : ALL ) { String query = String . format ( <str> , NAME , schemaTable ) ; for ( String systemKeyspace : Schema . SYSTEM_KEYSPACE_NAMES ) executeOnceInternal ( query , timestamp , systemKeyspace ) ; } makeCreateKeyspaceMutation ( system , timestamp + <int> ) . apply ( ) ; makeCreateKeyspaceMutation ( schema , timestamp + <int> ) . apply ( ) ; } public static void truncate ( ) { ALL . forEach ( table - > getSchemaCFS ( table ) . truncateBlocking ( ) ) ; } static void flush ( ) { if ( ! Boolean . getBoolean ( <str> ) ) ALL . forEach ( table - > FBUtilities . waitOnFuture ( getSchemaCFS ( table ) . forceFlush ( ) ) ) ; } public static UUID calculateSchemaDigest ( ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str> ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } for ( String table : ALL ) { ReadCommand cmd = getReadCommandForTableSchema ( table ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; PartitionIterator schema = cmd . executeInternal ( executionController ) ) { while ( schema . hasNext ( ) ) { try ( RowIterator partition = schema . next ( ) ) { if ( ! isSystemKeyspaceSchemaPartition ( partition . partitionKey ( ) ) ) RowIterators . digest ( partition , digest ) ; } } } } return UUID . nameUUIDFromBytes ( digest . digest ( ) ) ; } private static ColumnFamilyStore getSchemaCFS ( String schemaTableName ) { return Keyspace . open ( NAME ) . getColumnFamilyStore ( schemaTableName ) ; } private static ReadCommand getReadCommandForTableSchema ( String schemaTableName ) { ColumnFamilyStore cfs = getSchemaCFS ( schemaTableName ) ; return PartitionRangeReadCommand . allDataRead ( cfs . metadata , FBUtilities . nowInSeconds ( ) ) ; } public static Collection < Mutation > convertSchemaToMutations ( ) { Map < DecoratedKey , Mutation > mutationMap = new HashMap < > ( ) ; for ( String table : ALL ) convertSchemaToMutations ( mutationMap , table ) ; return mutationMap . values ( ) ; } private static void convertSchemaToMutations ( Map < DecoratedKey , Mutation > mutationMap , String schemaTableName ) { ReadCommand cmd = getReadCommandForTableSchema ( schemaTableName ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator iter = cmd . executeLocally ( executionController ) ) { while ( iter . hasNext ( ) ) { try ( UnfilteredRowIterator partition = iter . next ( ) ) { if ( isSystemKeyspaceSchemaPartition ( partition . partitionKey ( ) ) ) continue ; DecoratedKey key = partition . partitionKey ( ) ; Mutation mutation = mutationMap . get ( key ) ; if ( mutation = = null ) { mutation = new Mutation ( NAME , key ) ; mutationMap . put ( key , mutation ) ; } mutation . add ( PartitionUpdate . fromIterator ( partition ) ) ; } } } } private static ByteBuffer getSchemaKSKey ( String ksName ) { return AsciiType . instance . fromString ( ksName ) ; } private static boolean isSystemKeyspaceSchemaPartition ( DecoratedKey partitionKey ) { return Schema . isSystemKeyspace ( UTF8Type . instance . compose ( partitionKey . getKey ( ) ) ) ; } public static Mutation makeCreateKeyspaceMutation ( String name , KeyspaceParams params , long timestamp ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Keyspaces , timestamp , name ) . clustering ( ) ; return adder . add ( KeyspaceParams . Option . DURABLE_WRITES . toString ( ) , params . durableWrites ) . frozenMap ( KeyspaceParams . Option . REPLICATION . toString ( ) , params . replication . asMap ( ) ) . build ( ) ; } public static Mutation makeCreateKeyspaceMutation ( KeyspaceMetadata keyspace , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; keyspace . tables . forEach ( table - > addTableToSchemaMutation ( table , timestamp , true , mutation ) ) ; keyspace . views . forEach ( view - > addViewToSchemaMutation ( view , timestamp , true , mutation ) ) ; keyspace . types . forEach ( type - > addTypeToSchemaMutation ( type , timestamp , mutation ) ) ; keyspace . functions . udfs ( ) . forEach ( udf - > addFunctionToSchemaMutation ( udf , timestamp , mutation ) ) ; keyspace . functions . udas ( ) . forEach ( uda - > addAggregateToSchemaMutation ( uda , timestamp , mutation ) ) ; return mutation ; } public static Mutation makeDropKeyspaceMutation ( KeyspaceMetadata keyspace , long timestamp ) { int nowInSec = FBUtilities . nowInSeconds ( ) ; Mutation mutation = new Mutation ( NAME , Keyspaces . decorateKey ( getSchemaKSKey ( keyspace . name ) ) ) ; for ( CFMetaData schemaTable : ALL_TABLE_METADATA ) mutation . add ( PartitionUpdate . fullPartitionDelete ( schemaTable , mutation . key ( ) , timestamp , nowInSec ) ) ; return mutation ; } public static Mutation makeCreateTypeMutation ( KeyspaceMetadata keyspace , UserType type , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addTypeToSchemaMutation ( type , timestamp , mutation ) ; return mutation ; } static void addTypeToSchemaMutation ( UserType type , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Types , timestamp , mutation ) . clustering ( type . getNameAsString ( ) ) . frozenList ( <str> , type . fieldNames ( ) . stream ( ) . map ( SchemaKeyspace : : bbToString ) . collect ( toList ( ) ) ) . frozenList ( <str> , type . fieldTypes ( ) . stream ( ) . map ( AbstractType : : asCQL3Type ) . map ( CQL3Type : : toString ) . collect ( toList ( ) ) ) ; adder . build ( ) ; } private static String bbToString ( ByteBuffer bb ) { try { return ByteBufferUtil . string ( bb ) ; } catch ( CharacterCodingException e ) { throw new RuntimeException ( e ) ; } } public static Mutation dropTypeFromSchemaMutation ( KeyspaceMetadata keyspace , UserType type , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; return RowUpdateBuilder . deleteRow ( Types , timestamp , mutation , type . name ) ; } public static Mutation makeCreateTableMutation ( KeyspaceMetadata keyspace , CFMetaData table , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addTableToSchemaMutation ( table , timestamp , true , mutation ) ; return mutation ; } static void addTableToSchemaMutation ( CFMetaData table , long timestamp , boolean withColumnsAndTriggers , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Tables , timestamp , mutation ) . clustering ( table . cfName ) ; addTableParamsToSchemaMutation ( table . params , adder ) ; adder . add ( <str> , table . cfId ) . frozenSet ( <str> , CFMetaData . flagsToStrings ( table . flags ( ) ) ) . build ( ) ; if ( withColumnsAndTriggers ) { for ( ColumnDefinition column : table . allColumns ( ) ) addColumnToSchemaMutation ( table , column , timestamp , mutation ) ; for ( CFMetaData . DroppedColumn column : table . getDroppedColumns ( ) . values ( ) ) addDroppedColumnToSchemaMutation ( table , column , timestamp , mutation ) ; for ( TriggerMetadata trigger : table . getTriggers ( ) ) addTriggerToSchemaMutation ( table , trigger , timestamp , mutation ) ; for ( IndexMetadata index : table . getIndexes ( ) ) addIndexToSchemaMutation ( table , index , timestamp , mutation ) ; } } private static void addTableParamsToSchemaMutation ( TableParams params , RowUpdateBuilder adder ) { adder . add ( <str> , params . bloomFilterFpChance ) . add ( <str> , params . comment ) . add ( <str> , params . dcLocalReadRepairChance ) . add ( <str> , params . defaultTimeToLive ) . add ( <str> , params . gcGraceSeconds ) . add ( <str> , params . maxIndexInterval ) . add ( <str> , params . memtableFlushPeriodInMs ) . add ( <str> , params . minIndexInterval ) . add ( <str> , params . readRepairChance ) . add ( <str> , params . speculativeRetry . toString ( ) ) . add ( <str> , params . crcCheckChance ) . frozenMap ( <str> , params . caching . asMap ( ) ) . frozenMap ( <str> , params . compaction . asMap ( ) ) . frozenMap ( <str> , params . compression . asMap ( ) ) . frozenMap ( <str> , params . extensions ) ; } public static Mutation makeUpdateTableMutation ( KeyspaceMetadata keyspace , CFMetaData oldTable , CFMetaData newTable , long timestamp , boolean fromThrift ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addTableToSchemaMutation ( newTable , timestamp , false , mutation ) ; MapDifference < ByteBuffer , ColumnDefinition > columnDiff = Maps . difference ( oldTable . getColumnMetadata ( ) , newTable . getColumnMetadata ( ) ) ; for ( ColumnDefinition column : columnDiff . entriesOnlyOnLeft ( ) . values ( ) ) { if ( ! fromThrift | | column . kind = = ColumnDefinition . Kind . REGULAR | | ( newTable . isStaticCompactTable ( ) & & column . kind = = ColumnDefinition . Kind . STATIC ) ) { dropColumnFromSchemaMutation ( oldTable , column , timestamp , mutation ) ; } } for ( ColumnDefinition column : columnDiff . entriesOnlyOnRight ( ) . values ( ) ) addColumnToSchemaMutation ( newTable , column , timestamp , mutation ) ; for ( ByteBuffer name : columnDiff . entriesDiffering ( ) . keySet ( ) ) addColumnToSchemaMutation ( newTable , newTable . getColumnDefinition ( name ) , timestamp , mutation ) ; MapDifference < ByteBuffer , CFMetaData . DroppedColumn > droppedColumnDiff = Maps . difference ( oldTable . getDroppedColumns ( ) , newTable . getDroppedColumns ( ) ) ; for ( CFMetaData . DroppedColumn column : droppedColumnDiff . entriesOnlyOnRight ( ) . values ( ) ) addDroppedColumnToSchemaMutation ( newTable , column , timestamp , mutation ) ; for ( ByteBuffer name : droppedColumnDiff . entriesDiffering ( ) . keySet ( ) ) addDroppedColumnToSchemaMutation ( newTable , newTable . getDroppedColumns ( ) . get ( name ) , timestamp , mutation ) ; MapDifference < String , TriggerMetadata > triggerDiff = triggersDiff ( oldTable . getTriggers ( ) , newTable . getTriggers ( ) ) ; for ( TriggerMetadata trigger : triggerDiff . entriesOnlyOnLeft ( ) . values ( ) ) dropTriggerFromSchemaMutation ( oldTable , trigger , timestamp , mutation ) ; for ( TriggerMetadata trigger : triggerDiff . entriesOnlyOnRight ( ) . values ( ) ) addTriggerToSchemaMutation ( newTable , trigger , timestamp , mutation ) ; MapDifference < String , IndexMetadata > indexesDiff = indexesDiff ( oldTable . getIndexes ( ) , newTable . getIndexes ( ) ) ; for ( IndexMetadata index : indexesDiff . entriesOnlyOnLeft ( ) . values ( ) ) dropIndexFromSchemaMutation ( oldTable , index , timestamp , mutation ) ; for ( IndexMetadata index : indexesDiff . entriesOnlyOnRight ( ) . values ( ) ) addIndexToSchemaMutation ( newTable , index , timestamp , mutation ) ; for ( MapDifference . ValueDifference < IndexMetadata > diff : indexesDiff . entriesDiffering ( ) . values ( ) ) addUpdatedIndexToSchemaMutation ( newTable , diff . rightValue ( ) , timestamp , mutation ) ; return mutation ; } private static MapDifference < String , IndexMetadata > indexesDiff ( Indexes before , Indexes after ) { Map < String , IndexMetadata > beforeMap = new HashMap < > ( ) ; before . forEach ( i - > beforeMap . put ( i . name , i ) ) ; Map < String , IndexMetadata > afterMap = new HashMap < > ( ) ; after . forEach ( i - > afterMap . put ( i . name , i ) ) ; return Maps . difference ( beforeMap , afterMap ) ; } private static MapDifference < String , TriggerMetadata > triggersDiff ( Triggers before , Triggers after ) { Map < String , TriggerMetadata > beforeMap = new HashMap < > ( ) ; before . forEach ( t - > beforeMap . put ( t . name , t ) ) ; Map < String , TriggerMetadata > afterMap = new HashMap < > ( ) ; after . forEach ( t - > afterMap . put ( t . name , t ) ) ; return Maps . difference ( beforeMap , afterMap ) ; } public static Mutation makeDropTableMutation ( KeyspaceMetadata keyspace , CFMetaData table , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; RowUpdateBuilder . deleteRow ( Tables , timestamp , mutation , table . cfName ) ; for ( ColumnDefinition column : table . allColumns ( ) ) dropColumnFromSchemaMutation ( table , column , timestamp , mutation ) ; for ( TriggerMetadata trigger : table . getTriggers ( ) ) dropTriggerFromSchemaMutation ( table , trigger , timestamp , mutation ) ; for ( IndexMetadata index : table . getIndexes ( ) ) dropIndexFromSchemaMutation ( table , index , timestamp , mutation ) ; return mutation ; } private static void addColumnToSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Columns , timestamp , mutation ) . clustering ( table . cfName , column . name . toString ( ) ) ; AbstractType < ? > type = column . type ; if ( type instanceof ReversedType ) type = ( ( ReversedType ) type ) . baseType ; adder . add ( <str> , column . name . bytes ) . add ( <str> , column . kind . toString ( ) . toLowerCase ( ) ) . add ( <str> , column . position ( ) ) . add ( <str> , column . clusteringOrder ( ) . toString ( ) . toLowerCase ( ) ) . add ( <str> , type . asCQL3Type ( ) . toString ( ) ) . build ( ) ; } private static void dropColumnFromSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) { RowUpdateBuilder . deleteRow ( Columns , timestamp , mutation , table . cfName , column . name . toString ( ) ) ; } private static void addDroppedColumnToSchemaMutation ( CFMetaData table , CFMetaData . DroppedColumn column , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( DroppedColumns , timestamp , mutation ) . clustering ( table . cfName , column . name ) ; adder . add ( <str> , new Date ( TimeUnit . MICROSECONDS . toMillis ( column . droppedTime ) ) ) . add ( <str> , expandUserTypes ( column . type ) . asCQL3Type ( ) . toString ( ) ) . build ( ) ; } private static void addTriggerToSchemaMutation ( CFMetaData table , TriggerMetadata trigger , long timestamp , Mutation mutation ) { new RowUpdateBuilder ( Triggers , timestamp , mutation ) . clustering ( table . cfName , trigger . name ) . frozenMap ( <str> , Collections . singletonMap ( <str> , trigger . classOption ) ) . build ( ) ; } private static void dropTriggerFromSchemaMutation ( CFMetaData table , TriggerMetadata trigger , long timestamp , Mutation mutation ) { RowUpdateBuilder . deleteRow ( Triggers , timestamp , mutation , table . cfName , trigger . name ) ; } public static Mutation makeCreateViewMutation ( KeyspaceMetadata keyspace , ViewDefinition view , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addViewToSchemaMutation ( view , timestamp , true , mutation ) ; return mutation ; } private static void addViewToSchemaMutation ( ViewDefinition view , long timestamp , boolean includeColumns , Mutation mutation ) { RowUpdateBuilder builder = new RowUpdateBuilder ( Views , timestamp , mutation ) . clustering ( view . viewName ) ; CFMetaData table = view . metadata ; builder . add ( <str> , view . includeAllColumns ) . add ( <str> , view . baseTableId ) . add ( <str> , view . baseTableMetadata ( ) . cfName ) . add ( <str> , view . whereClause ) . add ( <str> , table . cfId ) ; addTableParamsToSchemaMutation ( table . params , builder ) ; if ( includeColumns ) { for ( ColumnDefinition column : table . allColumns ( ) ) addColumnToSchemaMutation ( table , column , timestamp , mutation ) ; for ( CFMetaData . DroppedColumn column : table . getDroppedColumns ( ) . values ( ) ) addDroppedColumnToSchemaMutation ( table , column , timestamp , mutation ) ; } builder . build ( ) ; } public static Mutation makeDropViewMutation ( KeyspaceMetadata keyspace , ViewDefinition view , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; RowUpdateBuilder . deleteRow ( Views , timestamp , mutation , view . viewName ) ; CFMetaData table = view . metadata ; for ( ColumnDefinition column : table . allColumns ( ) ) dropColumnFromSchemaMutation ( table , column , timestamp , mutation ) ; for ( IndexMetadata index : table . getIndexes ( ) ) dropIndexFromSchemaMutation ( table , index , timestamp , mutation ) ; return mutation ; } public static Mutation makeUpdateViewMutation ( KeyspaceMetadata keyspace , ViewDefinition oldView , ViewDefinition newView , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addViewToSchemaMutation ( newView , timestamp , false , mutation ) ; MapDifference < ByteBuffer , ColumnDefinition > columnDiff = Maps . difference ( oldView . metadata . getColumnMetadata ( ) , newView . metadata . getColumnMetadata ( ) ) ; for ( ColumnDefinition column : columnDiff . entriesOnlyOnLeft ( ) . values ( ) ) dropColumnFromSchemaMutation ( oldView . metadata , column , timestamp , mutation ) ; for ( ColumnDefinition column : columnDiff . entriesOnlyOnRight ( ) . values ( ) ) addColumnToSchemaMutation ( newView . metadata , column , timestamp , mutation ) ; for ( ByteBuffer name : columnDiff . entriesDiffering ( ) . keySet ( ) ) addColumnToSchemaMutation ( newView . metadata , newView . metadata . getColumnDefinition ( name ) , timestamp , mutation ) ; MapDifference < ByteBuffer , CFMetaData . DroppedColumn > droppedColumnDiff = Maps . difference ( oldView . metadata . getDroppedColumns ( ) , oldView . metadata . getDroppedColumns ( ) ) ; for ( CFMetaData . DroppedColumn column : droppedColumnDiff . entriesOnlyOnRight ( ) . values ( ) ) addDroppedColumnToSchemaMutation ( oldView . metadata , column , timestamp , mutation ) ; for ( ByteBuffer name : droppedColumnDiff . entriesDiffering ( ) . keySet ( ) ) addDroppedColumnToSchemaMutation ( newView . metadata , newView . metadata . getDroppedColumns ( ) . get ( name ) , timestamp , mutation ) ; return mutation ; } private static void addIndexToSchemaMutation ( CFMetaData table , IndexMetadata index , long timestamp , Mutation mutation ) { RowUpdateBuilder builder = new RowUpdateBuilder ( Indexes , timestamp , mutation ) . clustering ( table . cfName , index . name ) ; builder . add ( <str> , index . kind . toString ( ) ) ; builder . frozenMap ( <str> , index . options ) ; builder . build ( ) ; } private static void dropIndexFromSchemaMutation ( CFMetaData table , IndexMetadata index , long timestamp , Mutation mutation ) { RowUpdateBuilder . deleteRow ( Indexes , timestamp , mutation , table . cfName , index . name ) ; } private static void addUpdatedIndexToSchemaMutation ( CFMetaData table , IndexMetadata index , long timestamp , Mutation mutation ) { addIndexToSchemaMutation ( table , index , timestamp , mutation ) ; } public static Mutation makeCreateFunctionMutation ( KeyspaceMetadata keyspace , UDFunction function , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addFunctionToSchemaMutation ( function , timestamp , mutation ) ; return mutation ; } static void addFunctionToSchemaMutation ( UDFunction function , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Functions , timestamp , mutation ) . clustering ( function . name ( ) . name , functionArgumentsList ( function ) ) ; adder . add ( <str> , function . body ( ) ) . add ( <str> , function . language ( ) ) . add ( <str> , function . returnType ( ) . asCQL3Type ( ) . toString ( ) ) . add ( <str> , function . isCalledOnNullInput ( ) ) . frozenList ( <str> , function . argNames ( ) . stream ( ) . map ( ( c ) - > bbToString ( c . bytes ) ) . collect ( toList ( ) ) ) ; adder . build ( ) ; } private static List < String > functionArgumentsList ( AbstractFunction fun ) { return fun . argTypes ( ) . stream ( ) . map ( AbstractType : : asCQL3Type ) . map ( CQL3Type : : toString ) . collect ( toList ( ) ) ; } public static Mutation makeDropFunctionMutation ( KeyspaceMetadata keyspace , UDFunction function , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; return RowUpdateBuilder . deleteRow ( Functions , timestamp , mutation , function . name ( ) . name , functionArgumentsList ( function ) ) ; } public static Mutation makeCreateAggregateMutation ( KeyspaceMetadata keyspace , UDAggregate aggregate , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; addAggregateToSchemaMutation ( aggregate , timestamp , mutation ) ; return mutation ; } static void addAggregateToSchemaMutation ( UDAggregate aggregate , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( Aggregates , timestamp , mutation ) . clustering ( aggregate . name ( ) . name , functionArgumentsList ( aggregate ) ) ; CQL3Type stateCqlType = aggregate . stateType ( ) . asCQL3Type ( ) ; adder . add ( <str> , aggregate . returnType ( ) . asCQL3Type ( ) . toString ( ) ) . add ( <str> , aggregate . stateFunction ( ) . name ( ) . name ) . add ( <str> , aggregate . stateType ( ) ! = null ? stateCqlType . toString ( ) : null ) . add ( <str> , aggregate . finalFunction ( ) ! = null ? aggregate . finalFunction ( ) . name ( ) . name : null ) . add ( <str> , aggregate . initialCondition ( ) ! = null ? stateCqlType . asCQLLiteral ( aggregate . initialCondition ( ) , Server . CURRENT_VERSION ) : null ) . build ( ) ; } public static Mutation makeDropAggregateMutation ( KeyspaceMetadata keyspace , UDAggregate aggregate , long timestamp ) { Mutation mutation = makeCreateKeyspaceMutation ( keyspace . name , keyspace . params , timestamp ) ; return RowUpdateBuilder . deleteRow ( Aggregates , timestamp , mutation , aggregate . name ( ) . name , functionArgumentsList ( aggregate ) ) ; } public static Keyspaces fetchNonSystemKeyspaces ( ) { return fetchKeyspacesWithout ( Schema . SYSTEM_KEYSPACE_NAMES ) ; } private static Keyspaces fetchKeyspacesWithout ( Set < String > excludedKeyspaceNames ) { String query = format ( <str> , NAME , KEYSPACES ) ; Keyspaces . Builder keyspaces = org . apache . cassandra . schema . Keyspaces . builder ( ) ; for ( UntypedResultSet . Row row : query ( query ) ) { String keyspaceName = row . getString ( <str> ) ; if ( ! excludedKeyspaceNames . contains ( keyspaceName ) ) keyspaces . add ( fetchKeyspace ( keyspaceName ) ) ; } return keyspaces . build ( ) ; } private static Keyspaces fetchKeyspacesOnly ( Set < String > includedKeyspaceNames ) { String query = format ( <str> , NAME , KEYSPACES ) ; Keyspaces . Builder keyspaces = org . apache . cassandra . schema . Keyspaces . builder ( ) ; for ( UntypedResultSet . Row row : query ( query , new ArrayList < > ( includedKeyspaceNames ) ) ) keyspaces . add ( fetchKeyspace ( row . getString ( <str> ) ) ) ; return keyspaces . build ( ) ; } private static KeyspaceMetadata fetchKeyspace ( String keyspaceName ) { KeyspaceParams params = fetchKeyspaceParams ( keyspaceName ) ; Types types = fetchTypes ( keyspaceName ) ; Tables tables = fetchTables ( keyspaceName , types ) ; Views views = fetchViews ( keyspaceName , types ) ; Functions functions = fetchFunctions ( keyspaceName , types ) ; return KeyspaceMetadata . create ( keyspaceName , params , tables , views , types , functions ) ; } private static KeyspaceParams fetchKeyspaceParams ( String keyspaceName ) { String query = format ( <str> , NAME , KEYSPACES ) ; UntypedResultSet . Row row = query ( query , keyspaceName ) . one ( ) ; boolean durableWrites = row . getBoolean ( KeyspaceParams . Option . DURABLE_WRITES . toString ( ) ) ; Map < String , String > replication = row . getFrozenTextMap ( KeyspaceParams . Option . REPLICATION . toString ( ) ) ; return KeyspaceParams . create ( durableWrites , replication ) ; } private static Types fetchTypes ( String keyspaceName ) { String query = format ( <str> , NAME , TYPES ) ; Types . RawBuilder types = org . apache . cassandra . schema . Types . rawBuilder ( keyspaceName ) ; for ( UntypedResultSet . Row row : query ( query , keyspaceName ) ) { String name = row . getString ( <str> ) ; List < String > fieldNames = row . getFrozenList ( <str> , UTF8Type . instance ) ; List < String > fieldTypes = row . getFrozenList ( <str> , UTF8Type . instance ) ; types . add ( name , fieldNames , fieldTypes ) ; } return types . build ( ) ; } private static Tables fetchTables ( String keyspaceName , Types types ) { String query = format ( <str> , NAME , TABLES ) ; Tables . Builder tables = org . apache . cassandra . schema . Tables . builder ( ) ; for ( UntypedResultSet . Row row : query ( query , keyspaceName ) ) tables . add ( fetchTable ( keyspaceName , row . getString ( <str> ) , types ) ) ; return tables . build ( ) ; } private static CFMetaData fetchTable ( String keyspaceName , String tableName , Types types ) { String query = String . format ( <str> , NAME , TABLES ) ; UntypedResultSet rows = query ( query , keyspaceName , tableName ) ; if ( rows . isEmpty ( ) ) throw new RuntimeException ( String . format ( <str> , keyspaceName , tableName ) ) ; UntypedResultSet . Row row = rows . one ( ) ; UUID id = row . getUUID ( <str> ) ; Set < CFMetaData . Flag > flags = CFMetaData . flagsFromStrings ( row . getFrozenSet ( <str> , UTF8Type . instance ) ) ; boolean isSuper = flags . contains ( CFMetaData . Flag . SUPER ) ; boolean isCounter = flags . contains ( CFMetaData . Flag . COUNTER ) ; boolean isDense = flags . contains ( CFMetaData . Flag . DENSE ) ; boolean isCompound = flags . contains ( CFMetaData . Flag . COMPOUND ) ; List < ColumnDefinition > columns = fetchColumns ( keyspaceName , tableName , types ) ; Map < ByteBuffer , CFMetaData . DroppedColumn > droppedColumns = fetchDroppedColumns ( keyspaceName , tableName ) ; Indexes indexes = fetchIndexes ( keyspaceName , tableName ) ; Triggers triggers = fetchTriggers ( keyspaceName , tableName ) ; return CFMetaData . create ( keyspaceName , tableName , id , isDense , isCompound , isSuper , isCounter , false , columns , DatabaseDescriptor . getPartitioner ( ) ) . params ( createTableParamsFromRow ( row ) ) . droppedColumns ( droppedColumns ) . indexes ( indexes ) . triggers ( triggers ) ; } public static TableParams createTableParamsFromRow ( UntypedResultSet . Row row ) { return TableParams . builder ( ) . bloomFilterFpChance ( row . getDouble ( <str> ) ) . caching ( CachingParams . fromMap ( row . getFrozenTextMap ( <str> ) ) ) . comment ( row . getString ( <str> ) ) . compaction ( CompactionParams . fromMap ( row . getFrozenTextMap ( <str> ) ) ) . compression ( CompressionParams . fromMap ( row . getFrozenTextMap ( <str> ) ) ) . dcLocalReadRepairChance ( row . getDouble ( <str> ) ) . defaultTimeToLive ( row . getInt ( <str> ) ) . extensions ( row . getFrozenMap ( <str> , UTF8Type . instance , BytesType . instance ) ) . gcGraceSeconds ( row . getInt ( <str> ) ) . maxIndexInterval ( row . getInt ( <str> ) ) . memtableFlushPeriodInMs ( row . getInt ( <str> ) ) . minIndexInterval ( row . getInt ( <str> ) ) . readRepairChance ( row . getDouble ( <str> ) ) . crcCheckChance ( row . getDouble ( <str> ) ) . speculativeRetry ( SpeculativeRetryParam . fromString ( row . getString ( <str> ) ) ) . build ( ) ; } private static List < ColumnDefinition > fetchColumns ( String keyspace , String table , Types types ) { String query = format ( <str> , NAME , COLUMNS ) ; List < ColumnDefinition > columns = new ArrayList < > ( ) ; query ( query , keyspace , table ) . forEach ( row - > columns . add ( createColumnFromRow ( row , types ) ) ) ; return columns ; } public static ColumnDefinition createColumnFromRow ( UntypedResultSet . Row row , Types types ) { String keyspace = row . getString ( <str> ) ; String table = row . getString ( <str> ) ; ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( <str> ) , row . getString ( <str> ) ) ; ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( <str> ) . toUpperCase ( ) ) ; int position = row . getInt ( <str> ) ; ClusteringOrder order = ClusteringOrder . valueOf ( row . getString ( <str> ) . toUpperCase ( ) ) ; AbstractType < ? > type = parse ( keyspace , row . getString ( <str> ) , types ) ; if ( order = = ClusteringOrder . DESC ) type = ReversedType . getInstance ( type ) ; return new ColumnDefinition ( keyspace , table , name , type , position , kind ) ; } private static Map < ByteBuffer , CFMetaData . DroppedColumn > fetchDroppedColumns ( String keyspace , String table ) { String query = format ( <str> , NAME , DROPPED_COLUMNS ) ; Map < ByteBuffer , CFMetaData . DroppedColumn > columns = new HashMap < > ( ) ; for ( UntypedResultSet . Row row : query ( query , keyspace , table ) ) { CFMetaData . DroppedColumn column = createDroppedColumnFromRow ( row ) ; columns . put ( UTF8Type . instance . decompose ( column . name ) , column ) ; } return columns ; } private static CFMetaData . DroppedColumn createDroppedColumnFromRow ( UntypedResultSet . Row row ) { String keyspace = row . getString ( <str> ) ; String name = row . getString ( <str> ) ; AbstractType < ? > type = parse ( keyspace , row . getString ( <str> ) , org . apache . cassandra . schema . Types . none ( ) ) ; long droppedTime = TimeUnit . MILLISECONDS . toMicros ( row . getLong ( <str> ) ) ; return new CFMetaData . DroppedColumn ( name , type , droppedTime ) ; } private static Indexes fetchIndexes ( String keyspace , String table ) { String query = String . format ( <str> , NAME , INDEXES ) ; Indexes . Builder indexes = org . apache . cassandra . schema . Indexes . builder ( ) ; query ( query , keyspace , table ) . forEach ( row - > indexes . add ( createIndexMetadataFromRow ( row ) ) ) ; return indexes . build ( ) ; } private static IndexMetadata createIndexMetadataFromRow ( UntypedResultSet . Row row ) { String name = row . getString ( <str> ) ; IndexMetadata . Kind type = IndexMetadata . Kind . valueOf ( row . getString ( <str> ) ) ; Map < String , String > options = row . getFrozenTextMap ( <str> ) ; return IndexMetadata . fromSchemaMetadata ( name , type , options ) ; } private static Triggers fetchTriggers ( String keyspace , String table ) { String query = String . format ( <str> , NAME , TRIGGERS ) ; Triggers . Builder triggers = org . apache . cassandra . schema . Triggers . builder ( ) ; query ( query , keyspace , table ) . forEach ( row - > triggers . add ( createTriggerFromRow ( row ) ) ) ; return triggers . build ( ) ; } private static TriggerMetadata createTriggerFromRow ( UntypedResultSet . Row row ) { String name = row . getString ( <str> ) ; String classOption = row . getFrozenTextMap ( <str> ) . get ( <str> ) ; return new TriggerMetadata ( name , classOption ) ; } private static Views fetchViews ( String keyspaceName , Types types ) { String query = format ( <str> , NAME , VIEWS ) ; Views . Builder views = org . apache . cassandra . schema . Views . builder ( ) ; for ( UntypedResultSet . Row row : query ( query , keyspaceName ) ) views . add ( fetchView ( keyspaceName , row . getString ( <str> ) , types ) ) ; return views . build ( ) ; } private static ViewDefinition fetchView ( String keyspaceName , String viewName , Types types ) { String query = String . format ( <str> , NAME , VIEWS ) ; UntypedResultSet rows = query ( query , keyspaceName , viewName ) ; if ( rows . isEmpty ( ) ) throw new RuntimeException ( String . format ( <str> , keyspaceName , viewName ) ) ; UntypedResultSet . Row row = rows . one ( ) ; UUID id = row . getUUID ( <str> ) ; UUID baseTableId = row . getUUID ( <str> ) ; String baseTableName = row . getString ( <str> ) ; boolean includeAll = row . getBoolean ( <str> ) ; String whereClause = row . getString ( <str> ) ; List < ColumnDefinition > columns = fetchColumns ( keyspaceName , viewName , types ) ; Map < ByteBuffer , CFMetaData . DroppedColumn > droppedColumns = fetchDroppedColumns ( keyspaceName , viewName ) ; CFMetaData cfm = CFMetaData . create ( keyspaceName , viewName , id , false , true , false , false , true , columns , DatabaseDescriptor . getPartitioner ( ) ) . params ( createTableParamsFromRow ( row ) ) . droppedColumns ( droppedColumns ) ; String rawSelect = View . buildSelectStatement ( baseTableName , columns , whereClause ) ; SelectStatement . RawStatement rawStatement = ( SelectStatement . RawStatement ) QueryProcessor . parseStatement ( rawSelect ) ; return new ViewDefinition ( keyspaceName , viewName , baseTableId , baseTableName , includeAll , rawStatement , whereClause , cfm ) ; } private static Functions fetchFunctions ( String keyspaceName , Types types ) { Functions udfs = fetchUDFs ( keyspaceName , types ) ; Functions udas = fetchUDAs ( keyspaceName , udfs , types ) ; return org . apache . cassandra . schema . Functions . builder ( ) . add ( udfs ) . add ( udas ) . build ( ) ; } private static Functions fetchUDFs ( String keyspaceName , Types types ) { String query = format ( <str> , NAME , FUNCTIONS ) ; Functions . Builder functions = org . apache . cassandra . schema . Functions . builder ( ) ; for ( UntypedResultSet . Row row : query ( query , keyspaceName ) ) functions . add ( createUDFFromRow ( row , types ) ) ; return functions . build ( ) ; } private static UDFunction createUDFFromRow ( UntypedResultSet . Row row , Types types ) { String ksName = row . getString ( <str> ) ; String functionName = row . getString ( <str> ) ; FunctionName name = new FunctionName ( ksName , functionName ) ; List < ColumnIdentifier > argNames = new ArrayList < > ( ) ; for ( String arg : row . getFrozenList ( <str> , UTF8Type . instance ) ) argNames . add ( new ColumnIdentifier ( arg , true ) ) ; List < AbstractType < ? > > argTypes = new ArrayList < > ( ) ; for ( String type : row . getFrozenList ( <str> , UTF8Type . instance ) ) argTypes . add ( parse ( ksName , type , types ) ) ; AbstractType < ? > returnType = parse ( ksName , row . getString ( <str> ) , types ) ; String language = row . getString ( <str> ) ; String body = row . getString ( <str> ) ; boolean calledOnNullInput = row . getBoolean ( <str> ) ; org . apache . cassandra . cql3 . functions . Function existing = Schema . instance . findFunction ( name , argTypes ) . orElse ( null ) ; if ( existing instanceof UDFunction ) { UDFunction udf = ( UDFunction ) existing ; if ( udf . argNames ( ) . equals ( argNames ) & & udf . returnType ( ) . equals ( returnType ) & & ! udf . isAggregate ( ) & & udf . language ( ) . equals ( language ) & & udf . body ( ) . equals ( body ) & & udf . isCalledOnNullInput ( ) = = calledOnNullInput ) { logger . trace ( <str> , name ) ; return udf ; } } try { return UDFunction . create ( name , argNames , argTypes , returnType , calledOnNullInput , language , body ) ; } catch ( InvalidRequestException e ) { logger . error ( String . format ( <str> , name ) , e ) ; return UDFunction . createBrokenFunction ( name , argNames , argTypes , returnType , calledOnNullInput , language , body , e ) ; } } private static Functions fetchUDAs ( String keyspaceName , Functions udfs , Types types ) { String query = format ( <str> , NAME , AGGREGATES ) ; Functions . Builder aggregates = org . apache . cassandra . schema . Functions . builder ( ) ; for ( UntypedResultSet . Row row : query ( query , keyspaceName ) ) aggregates . add ( createUDAFromRow ( row , udfs , types ) ) ; return aggregates . build ( ) ; } private static UDAggregate createUDAFromRow ( UntypedResultSet . Row row , Functions functions , Types types ) { String ksName = row . getString ( <str> ) ; String functionName = row . getString ( <str> ) ; FunctionName name = new FunctionName ( ksName , functionName ) ; List < AbstractType < ? > > argTypes = row . getFrozenList ( <str> , UTF8Type . instance ) . stream ( ) . map ( t - > parse ( ksName , t , types ) ) . collect ( toList ( ) ) ; AbstractType < ? > returnType = parse ( ksName , row . getString ( <str> ) , types ) ; FunctionName stateFunc = new FunctionName ( ksName , ( row . getString ( <str> ) ) ) ; FunctionName finalFunc = row . has ( <str> ) ? new FunctionName ( ksName , row . getString ( <str> ) ) : null ; AbstractType < ? > stateType = row . has ( <str> ) ? parse ( ksName , row . getString ( <str> ) , types ) : null ; ByteBuffer initcond = row . has ( <str> ) ? Terms . asBytes ( ksName , row . getString ( <str> ) , stateType ) : null ; try { return UDAggregate . create ( functions , name , argTypes , returnType , stateFunc , finalFunc , stateType , initcond ) ; } catch ( InvalidRequestException reason ) { return UDAggregate . createBroken ( name , argTypes , returnType , initcond , reason ) ; } } private static UntypedResultSet query ( String query , Object . . . variables ) { return executeInternal ( query , variables ) ; } public static synchronized void mergeSchemaAndAnnounceVersion ( Collection < Mutation > mutations ) throws ConfigurationException { mergeSchema ( mutations ) ; Schema . instance . updateVersionAndAnnounce ( ) ; } public static synchronized void mergeSchema ( Collection < Mutation > mutations ) { Set < String > affectedKeyspaces = mutations . stream ( ) . map ( m - > UTF8Type . instance . compose ( m . key ( ) . getKey ( ) ) ) . collect ( Collectors . toSet ( ) ) ; Keyspaces before = Schema . instance . getKeyspaces ( affectedKeyspaces ) ; mutations . forEach ( Mutation : : apply ) ; if ( FLUSH_SCHEMA_TABLES ) flush ( ) ; Keyspaces after = fetchKeyspacesOnly ( affectedKeyspaces ) ; MapDifference < String , KeyspaceMetadata > keyspacesDiff = before . diff ( after ) ; for ( KeyspaceMetadata keyspace : keyspacesDiff . entriesOnlyOnLeft ( ) . values ( ) ) { keyspace . functions . udas ( ) . forEach ( Schema . instance : : dropAggregate ) ; keyspace . functions . udfs ( ) . forEach ( Schema . instance : : dropFunction ) ; keyspace . views . forEach ( v - > Schema . instance . dropView ( v . ksName , v . viewName ) ) ; keyspace . tables . forEach ( t - > Schema . instance . dropTable ( t . ksName , t . cfName ) ) ; keyspace . types . forEach ( Schema . instance : : dropType ) ; Schema . instance . dropKeyspace ( keyspace . name ) ; } for ( KeyspaceMetadata keyspace : keyspacesDiff . entriesOnlyOnRight ( ) . values ( ) ) { Schema . instance . addKeyspace ( KeyspaceMetadata . create ( keyspace . name , keyspace . params ) ) ; keyspace . types . forEach ( Schema . instance : : addType ) ; keyspace . tables . forEach ( Schema . instance : : addTable ) ; keyspace . views . forEach ( Schema . instance : : addView ) ; keyspace . functions . udfs ( ) . forEach ( Schema . instance : : addFunction ) ; keyspace . functions . udas ( ) . forEach ( Schema . instance : : addAggregate ) ; } for ( Map . Entry < String , MapDifference . ValueDifference < KeyspaceMetadata > > diff : keyspacesDiff . entriesDiffering ( ) . entrySet ( ) ) updateKeyspace ( diff . getKey ( ) , diff . getValue ( ) . leftValue ( ) , diff . getValue ( ) . rightValue ( ) ) ; } private static void updateKeyspace ( String keyspaceName , KeyspaceMetadata keyspaceBefore , KeyspaceMetadata keyspaceAfter ) { MapDifference < String , CFMetaData > tablesDiff = keyspaceBefore . tables . diff ( keyspaceAfter . tables ) ; MapDifference < String , ViewDefinition > viewsDiff = keyspaceBefore . views . diff ( keyspaceAfter . views ) ; MapDifference < ByteBuffer , UserType > typesDiff = keyspaceBefore . types . diff ( keyspaceAfter . types ) ; Map < Pair < FunctionName , List < String > > , UDFunction > udfsBefore = new HashMap < > ( ) ; keyspaceBefore . functions . udfs ( ) . forEach ( f - > udfsBefore . put ( Pair . create ( f . name ( ) , functionArgumentsList ( f ) ) , f ) ) ; Map < Pair < FunctionName , List < String > > , UDFunction > udfsAfter = new HashMap < > ( ) ; keyspaceAfter . functions . udfs ( ) . forEach ( f - > udfsAfter . put ( Pair . create ( f . name ( ) , functionArgumentsList ( f ) ) , f ) ) ; MapDifference < Pair < FunctionName , List < String > > , UDFunction > udfsDiff = Maps . difference ( udfsBefore , udfsAfter ) ; Map < Pair < FunctionName , List < String > > , UDAggregate > udasBefore = new HashMap < > ( ) ; keyspaceBefore . functions . udas ( ) . forEach ( f - > udasBefore . put ( Pair . create ( f . name ( ) , functionArgumentsList ( f ) ) , f ) ) ; Map < Pair < FunctionName , List < String > > , UDAggregate > udasAfter = new HashMap < > ( ) ; keyspaceAfter . functions . udas ( ) . forEach ( f - > udasAfter . put ( Pair . create ( f . name ( ) , functionArgumentsList ( f ) ) , f ) ) ; MapDifference < Pair < FunctionName , List < String > > , UDAggregate > udasDiff = Maps . difference ( udasBefore , udasAfter ) ; if ( ! keyspaceBefore . params . equals ( keyspaceAfter . params ) ) Schema . instance . updateKeyspace ( keyspaceName , keyspaceAfter . params ) ; udasDiff . entriesOnlyOnLeft ( ) . values ( ) . forEach ( Schema . instance : : dropAggregate ) ; udfsDiff . entriesOnlyOnLeft ( ) . values ( ) . forEach ( Schema . instance : : dropFunction ) ; viewsDiff . entriesOnlyOnLeft ( ) . values ( ) . forEach ( v - > Schema . instance . dropView ( v . ksName , v . viewName ) ) ; tablesDiff . entriesOnlyOnLeft ( ) . values ( ) . forEach ( t - > Schema . instance . dropTable ( t . ksName , t . cfName ) ) ; typesDiff . entriesOnlyOnLeft ( ) . values ( ) . forEach ( Schema . instance : : dropType ) ; typesDiff . entriesOnlyOnRight ( ) . values ( ) . forEach ( Schema . instance : : addType ) ; tablesDiff . entriesOnlyOnRight ( ) . values ( ) . forEach ( Schema . instance : : addTable ) ; viewsDiff . entriesOnlyOnRight ( ) . values ( ) . forEach ( Schema . instance : : addView ) ; udfsDiff . entriesOnlyOnRight ( ) . values ( ) . forEach ( Schema . instance : : addFunction ) ; udasDiff . entriesOnlyOnRight ( ) . values ( ) . forEach ( Schema . instance : : addAggregate ) ; for ( MapDifference . ValueDifference < UserType > diff : typesDiff . entriesDiffering ( ) . values ( ) ) Schema . instance . updateType ( diff . rightValue ( ) ) ; for ( MapDifference . ValueDifference < CFMetaData > diff : tablesDiff . entriesDiffering ( ) . values ( ) ) Schema . instance . updateTable ( diff . rightValue ( ) ) ; for ( MapDifference . ValueDifference < ViewDefinition > diff : viewsDiff . entriesDiffering ( ) . values ( ) ) Schema . instance . updateView ( diff . rightValue ( ) ) ; for ( MapDifference . ValueDifference < UDFunction > diff : udfsDiff . entriesDiffering ( ) . values ( ) ) Schema . instance . updateFunction ( diff . rightValue ( ) ) ; for ( MapDifference . ValueDifference < UDAggregate > diff : udasDiff . entriesDiffering ( ) . values ( ) ) Schema . instance . updateAggregate ( diff . rightValue ( ) ) ; } private static AbstractType < ? > expandUserTypes ( AbstractType < ? > original ) { if ( original instanceof UserType ) return new TupleType ( expandUserTypes ( ( ( UserType ) original ) . fieldTypes ( ) ) ) ; if ( original instanceof TupleType ) return new TupleType ( expandUserTypes ( ( ( TupleType ) original ) . allTypes ( ) ) ) ; if ( original instanceof ListType < ? > ) return ListType . getInstance ( expandUserTypes ( ( ( ListType < ? > ) original ) . getElementsType ( ) ) , original . isMultiCell ( ) ) ; if ( original instanceof MapType < ? , ? > ) { MapType < ? , ? > mt = ( MapType < ? , ? > ) original ; return MapType . getInstance ( expandUserTypes ( mt . getKeysType ( ) ) , expandUserTypes ( mt . getValuesType ( ) ) , mt . isMultiCell ( ) ) ; } if ( original instanceof SetType < ? > ) return SetType . getInstance ( expandUserTypes ( ( ( SetType < ? > ) original ) . getElementsType ( ) ) , original . isMultiCell ( ) ) ; if ( original instanceof ReversedType < ? > ) return ReversedType . getInstance ( expandUserTypes ( ( ( ReversedType ) original ) . baseType ) ) ; if ( original instanceof CompositeType ) return CompositeType . getInstance ( expandUserTypes ( original . getComponents ( ) ) ) ; return original ; } private static List < AbstractType < ? > > expandUserTypes ( List < AbstractType < ? > > types ) { return types . stream ( ) . map ( SchemaKeyspace : : expandUserTypes ) . collect ( toList ( ) ) ; } } 
