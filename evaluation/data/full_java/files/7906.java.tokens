package org . elasticsearch . common . compress ; import org . apache . lucene . util . LineFileDocs ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . common . io . stream . ByteBufferStreamInput ; import org . elasticsearch . common . io . stream . OutputStreamStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . test . ESTestCase ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . charset . StandardCharsets ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; public abstract class AbstractCompressedStreamTestCase extends ESTestCase { private final Compressor compressor ; protected AbstractCompressedStreamTestCase ( Compressor compressor ) { this . compressor = compressor ; } public void testRandom ( ) throws IOException { Random r = getRandom ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { byte bytes [ ] = new byte [ TestUtil . nextInt ( r , <int> , <int> ) ] ; r . nextBytes ( bytes ) ; doTest ( bytes ) ; } } public void testRandomThreads ( ) throws Exception { final Random r = getRandom ( ) ; int threadCount = TestUtil . nextInt ( r , <int> , <int> ) ; Thread [ ] threads = new Thread [ threadCount ] ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; for ( int tid = <int> ; tid < threadCount ; tid + + ) { final long seed = r . nextLong ( ) ; threads [ tid ] = new Thread ( ) { @Override public void run ( ) { try { Random r = new Random ( seed ) ; startingGun . await ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { byte bytes [ ] = new byte [ TestUtil . nextInt ( r , <int> , <int> ) ] ; r . nextBytes ( bytes ) ; doTest ( bytes ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ tid ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread t : threads ) { t . join ( ) ; } } public void testLineDocs ( ) throws IOException { Random r = getRandom ( ) ; LineFileDocs lineFileDocs = new LineFileDocs ( r ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numDocs = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( int j = <int> ; j < numDocs ; j + + ) { String s = lineFileDocs . nextDoc ( ) . get ( <str> ) ; bos . write ( s . getBytes ( StandardCharsets . UTF_8 ) ) ; } doTest ( bos . toByteArray ( ) ) ; } lineFileDocs . close ( ) ; } public void testLineDocsThreads ( ) throws Exception { final Random r = getRandom ( ) ; int threadCount = TestUtil . nextInt ( r , <int> , <int> ) ; Thread [ ] threads = new Thread [ threadCount ] ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; for ( int tid = <int> ; tid < threadCount ; tid + + ) { final long seed = r . nextLong ( ) ; threads [ tid ] = new Thread ( ) { @Override public void run ( ) { try { Random r = new Random ( seed ) ; startingGun . await ( ) ; LineFileDocs lineFileDocs = new LineFileDocs ( r ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numDocs = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( int j = <int> ; j < numDocs ; j + + ) { String s = lineFileDocs . nextDoc ( ) . get ( <str> ) ; bos . write ( s . getBytes ( StandardCharsets . UTF_8 ) ) ; } doTest ( bos . toByteArray ( ) ) ; } lineFileDocs . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ tid ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread t : threads ) { t . join ( ) ; } } public void testRepetitionsL ( ) throws IOException { Random r = getRandom ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numLongs = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; long theValue = r . nextLong ( ) ; for ( int j = <int> ; j < numLongs ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = r . nextLong ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } public void testRepetitionsLThreads ( ) throws Exception { final Random r = getRandom ( ) ; int threadCount = TestUtil . nextInt ( r , <int> , <int> ) ; Thread [ ] threads = new Thread [ threadCount ] ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; for ( int tid = <int> ; tid < threadCount ; tid + + ) { final long seed = r . nextLong ( ) ; threads [ tid ] = new Thread ( ) { @Override public void run ( ) { try { Random r = new Random ( seed ) ; startingGun . await ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numLongs = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; long theValue = r . nextLong ( ) ; for ( int j = <int> ; j < numLongs ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = r . nextLong ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ tid ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread t : threads ) { t . join ( ) ; } } public void testRepetitionsI ( ) throws IOException { Random r = getRandom ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numInts = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; int theValue = r . nextInt ( ) ; for ( int j = <int> ; j < numInts ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = r . nextInt ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } public void testRepetitionsIThreads ( ) throws Exception { final Random r = getRandom ( ) ; int threadCount = TestUtil . nextInt ( r , <int> , <int> ) ; Thread [ ] threads = new Thread [ threadCount ] ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; for ( int tid = <int> ; tid < threadCount ; tid + + ) { final long seed = r . nextLong ( ) ; threads [ tid ] = new Thread ( ) { @Override public void run ( ) { try { Random r = new Random ( seed ) ; startingGun . await ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numInts = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; int theValue = r . nextInt ( ) ; for ( int j = <int> ; j < numInts ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = r . nextInt ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ tid ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread t : threads ) { t . join ( ) ; } } public void testRepetitionsS ( ) throws IOException { Random r = getRandom ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numShorts = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; short theValue = ( short ) r . nextInt ( <int> ) ; for ( int j = <int> ; j < numShorts ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = ( short ) r . nextInt ( <int> ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } public void testMixed ( ) throws IOException { Random r = getRandom ( ) ; LineFileDocs lineFileDocs = new LineFileDocs ( r ) ; for ( int i = <int> ; i < <int> ; + + i ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; int prevInt = r . nextInt ( ) ; long prevLong = r . nextLong ( ) ; while ( bos . size ( ) < <int> ) { switch ( r . nextInt ( <int> ) ) { case <int> : addInt ( r , prevInt , bos ) ; break ; case <int> : addLong ( r , prevLong , bos ) ; break ; case <int> : addString ( lineFileDocs , bos ) ; break ; case <int> : addBytes ( r , bos ) ; break ; default : throw new IllegalStateException ( <str> ) ; } } doTest ( bos . toByteArray ( ) ) ; } } private void addLong ( Random r , long prev , ByteArrayOutputStream bos ) { long theValue = prev ; if ( r . nextInt ( <int> ) ! = <int> ) { theValue = r . nextLong ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } private void addInt ( Random r , int prev , ByteArrayOutputStream bos ) { int theValue = prev ; if ( r . nextInt ( <int> ) ! = <int> ) { theValue = r . nextInt ( ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } private void addString ( LineFileDocs lineFileDocs , ByteArrayOutputStream bos ) throws IOException { String s = lineFileDocs . nextDoc ( ) . get ( <str> ) ; bos . write ( s . getBytes ( StandardCharsets . UTF_8 ) ) ; } private void addBytes ( Random r , ByteArrayOutputStream bos ) throws IOException { byte bytes [ ] = new byte [ TestUtil . nextInt ( r , <int> , <int> ) ] ; r . nextBytes ( bytes ) ; bos . write ( bytes ) ; } public void testRepetitionsSThreads ( ) throws Exception { final Random r = getRandom ( ) ; int threadCount = TestUtil . nextInt ( r , <int> , <int> ) ; Thread [ ] threads = new Thread [ threadCount ] ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; for ( int tid = <int> ; tid < threadCount ; tid + + ) { final long seed = r . nextLong ( ) ; threads [ tid ] = new Thread ( ) { @Override public void run ( ) { try { Random r = new Random ( seed ) ; startingGun . await ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { int numShorts = TestUtil . nextInt ( r , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; short theValue = ( short ) r . nextInt ( <int> ) ; for ( int j = <int> ; j < numShorts ; j + + ) { if ( r . nextInt ( <int> ) = = <int> ) { theValue = ( short ) r . nextInt ( <int> ) ; } bos . write ( ( byte ) ( theValue > > > <int> ) ) ; bos . write ( ( byte ) theValue ) ; } doTest ( bos . toByteArray ( ) ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ tid ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread t : threads ) { t . join ( ) ; } } private void doTest ( byte bytes [ ] ) throws IOException { ByteBuffer bb = ByteBuffer . wrap ( bytes ) ; StreamInput rawIn = new ByteBufferStreamInput ( bb ) ; Compressor c = compressor ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; OutputStreamStreamOutput rawOs = new OutputStreamStreamOutput ( bos ) ; StreamOutput os = c . streamOutput ( rawOs ) ; Random r = getRandom ( ) ; int bufferSize = r . nextBoolean ( ) ? <int> : TestUtil . nextInt ( getRandom ( ) , <int> , <int> ) ; int prepadding = r . nextInt ( <int> ) ; int postpadding = r . nextInt ( <int> ) ; byte buffer [ ] = new byte [ prepadding + bufferSize + postpadding ] ; r . nextBytes ( buffer ) ; int len ; while ( ( len = rawIn . read ( buffer , prepadding , bufferSize ) ) ! = - <int> ) { os . write ( buffer , prepadding , len ) ; } os . close ( ) ; rawIn . close ( ) ; byte compressed [ ] = bos . toByteArray ( ) ; ByteBuffer bb2 = ByteBuffer . wrap ( compressed ) ; StreamInput compressedIn = new ByteBufferStreamInput ( bb2 ) ; StreamInput in = c . streamInput ( compressedIn ) ; bufferSize = r . nextBoolean ( ) ? <int> : TestUtil . nextInt ( getRandom ( ) , <int> , <int> ) ; prepadding = r . nextInt ( <int> ) ; postpadding = r . nextInt ( <int> ) ; buffer = new byte [ prepadding + bufferSize + postpadding ] ; r . nextBytes ( buffer ) ; ByteArrayOutputStream uncompressedOut = new ByteArrayOutputStream ( ) ; while ( ( len = in . read ( buffer , prepadding , bufferSize ) ) ! = - <int> ) { uncompressedOut . write ( buffer , prepadding , len ) ; } uncompressedOut . close ( ) ; assertArrayEquals ( bytes , uncompressedOut . toByteArray ( ) ) ; } } 
