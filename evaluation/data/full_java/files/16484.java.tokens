package org . junit . runners . model ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Type ; import java . util . List ; import org . junit . internal . runners . model . ReflectiveCallable ; public class FrameworkMethod extends FrameworkMember < FrameworkMethod > { private final Method method ; public FrameworkMethod ( Method method ) { if ( method = = null ) { throw new NullPointerException ( <str> ) ; } this . method = method ; } public Method getMethod ( ) { return method ; } public Object invokeExplosively ( final Object target , final Object . . . params ) throws Throwable { return new ReflectiveCallable ( ) { @Override protected Object runReflectiveCall ( ) throws Throwable { return method . invoke ( target , params ) ; } } . run ( ) ; } @Override public String getName ( ) { return method . getName ( ) ; } public void validatePublicVoidNoArg ( boolean isStatic , List < Throwable > errors ) { validatePublicVoid ( isStatic , errors ) ; if ( method . getParameterTypes ( ) . length ! = <int> ) { errors . add ( new Exception ( <str> + method . getName ( ) + <str> ) ) ; } } public void validatePublicVoid ( boolean isStatic , List < Throwable > errors ) { if ( isStatic ( ) ! = isStatic ) { String state = isStatic ? <str> : <str> ; errors . add ( new Exception ( <str> + method . getName ( ) + <str> + state + <str> ) ) ; } if ( ! isPublic ( ) ) { errors . add ( new Exception ( <str> + method . getName ( ) + <str> ) ) ; } if ( method . getReturnType ( ) ! = Void . TYPE ) { errors . add ( new Exception ( <str> + method . getName ( ) + <str> ) ) ; } } @Override protected int getModifiers ( ) { return method . getModifiers ( ) ; } public Class < ? > getReturnType ( ) { return method . getReturnType ( ) ; } @Override public Class < ? > getType ( ) { return getReturnType ( ) ; } @Override public Class < ? > getDeclaringClass ( ) { return method . getDeclaringClass ( ) ; } public void validateNoTypeParametersOnArgs ( List < Throwable > errors ) { new NoGenericTypeParametersValidator ( method ) . validate ( errors ) ; } @Override public boolean isShadowedBy ( FrameworkMethod other ) { if ( ! other . getName ( ) . equals ( getName ( ) ) ) { return false ; } if ( other . getParameterTypes ( ) . length ! = getParameterTypes ( ) . length ) { return false ; } for ( int i = <int> ; i < other . getParameterTypes ( ) . length ; i + + ) { if ( ! other . getParameterTypes ( ) [ i ] . equals ( getParameterTypes ( ) [ i ] ) ) { return false ; } } return true ; } @Override public boolean equals ( Object obj ) { if ( ! FrameworkMethod . class . isInstance ( obj ) ) { return false ; } return ( ( FrameworkMethod ) obj ) . method . equals ( method ) ; } @Override public int hashCode ( ) { return method . hashCode ( ) ; } @Deprecated public boolean producesType ( Type type ) { return getParameterTypes ( ) . length = = <int> & & type instanceof Class < ? > & & ( ( Class < ? > ) type ) . isAssignableFrom ( method . getReturnType ( ) ) ; } private Class < ? > [ ] getParameterTypes ( ) { return method . getParameterTypes ( ) ; } public Annotation [ ] getAnnotations ( ) { return method . getAnnotations ( ) ; } public < T extends Annotation > T getAnnotation ( Class < T > annotationType ) { return method . getAnnotation ( annotationType ) ; } @Override public String toString ( ) { return method . toString ( ) ; } } 
