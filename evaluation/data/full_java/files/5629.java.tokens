package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . Locale ; public class EnableAllocationDecider extends AllocationDecider implements NodeSettingsService . Listener { public static final String NAME = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_ENABLE = <str> ; public static final String INDEX_ROUTING_ALLOCATION_ENABLE = <str> ; public static final String CLUSTER_ROUTING_REBALANCE_ENABLE = <str> ; public static final String INDEX_ROUTING_REBALANCE_ENABLE = <str> ; private volatile Rebalance enableRebalance ; private volatile Allocation enableAllocation ; @Inject public EnableAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . enableAllocation = Allocation . parse ( settings . get ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . ALL . name ( ) ) ) ; this . enableRebalance = Rebalance . parse ( settings . get ( CLUSTER_ROUTING_REBALANCE_ENABLE , Rebalance . ALL . name ( ) ) ) ; nodeSettingsService . addListener ( this ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( allocation . ignoreDisable ( ) ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } Settings indexSettings = allocation . routingNodes ( ) . metaData ( ) . index ( shardRouting . index ( ) ) . getSettings ( ) ; String enableIndexValue = indexSettings . get ( INDEX_ROUTING_ALLOCATION_ENABLE ) ; final Allocation enable ; if ( enableIndexValue ! = null ) { enable = Allocation . parse ( enableIndexValue ) ; } else { enable = this . enableAllocation ; } switch ( enable ) { case ALL : return allocation . decision ( Decision . YES , NAME , <str> ) ; case NONE : return allocation . decision ( Decision . NO , NAME , <str> ) ; case NEW_PRIMARIES : if ( shardRouting . primary ( ) & & shardRouting . allocatedPostIndexCreate ( ) = = false ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { return allocation . decision ( Decision . NO , NAME , <str> ) ; } case PRIMARIES : if ( shardRouting . primary ( ) ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { return allocation . decision ( Decision . NO , NAME , <str> ) ; } default : throw new IllegalStateException ( <str> ) ; } } @Override public Decision canRebalance ( ShardRouting shardRouting , RoutingAllocation allocation ) { if ( allocation . ignoreDisable ( ) ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } Settings indexSettings = allocation . routingNodes ( ) . metaData ( ) . index ( shardRouting . index ( ) ) . getSettings ( ) ; String enableIndexValue = indexSettings . get ( INDEX_ROUTING_REBALANCE_ENABLE ) ; final Rebalance enable ; if ( enableIndexValue ! = null ) { enable = Rebalance . parse ( enableIndexValue ) ; } else { enable = this . enableRebalance ; } switch ( enable ) { case ALL : return allocation . decision ( Decision . YES , NAME , <str> ) ; case NONE : return allocation . decision ( Decision . NO , NAME , <str> ) ; case PRIMARIES : if ( shardRouting . primary ( ) ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { return allocation . decision ( Decision . NO , NAME , <str> ) ; } case REPLICAS : if ( shardRouting . primary ( ) = = false ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { return allocation . decision ( Decision . NO , NAME , <str> ) ; } default : throw new IllegalStateException ( <str> ) ; } } @Override public void onRefreshSettings ( Settings settings ) { final Allocation enable = Allocation . parse ( settings . get ( CLUSTER_ROUTING_ALLOCATION_ENABLE , this . enableAllocation . name ( ) ) ) ; if ( enable ! = this . enableAllocation ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_ENABLE , this . enableAllocation , enable ) ; EnableAllocationDecider . this . enableAllocation = enable ; } final Rebalance enableRebalance = Rebalance . parse ( settings . get ( CLUSTER_ROUTING_REBALANCE_ENABLE , this . enableRebalance . name ( ) ) ) ; if ( enableRebalance ! = this . enableRebalance ) { logger . info ( <str> , CLUSTER_ROUTING_REBALANCE_ENABLE , this . enableRebalance , enableRebalance ) ; EnableAllocationDecider . this . enableRebalance = enableRebalance ; } } public enum Allocation { NONE , NEW_PRIMARIES , PRIMARIES , ALL ; public static Allocation parse ( String strValue ) { if ( strValue = = null ) { return null ; } else { strValue = strValue . toUpperCase ( Locale . ROOT ) ; try { return Allocation . valueOf ( strValue ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + strValue + <str> ) ; } } } } public enum Rebalance { NONE , PRIMARIES , REPLICAS , ALL ; public static Rebalance parse ( String strValue ) { if ( strValue = = null ) { return null ; } else { strValue = strValue . toUpperCase ( Locale . ROOT ) ; try { return Rebalance . valueOf ( strValue ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + strValue + <str> ) ; } } } } } 
