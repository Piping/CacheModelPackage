package org . elasticsearch . index . translog ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . nio . channels . FileChannel ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import static org . hamcrest . Matchers . equalTo ; public class TranslogVersionTests extends ESTestCase { public void testV0LegacyTranslogVersion ( ) throws Exception { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; try ( ImmutableTranslogReader reader = openReader ( translogFile , <int> ) ) { assertThat ( <str> , reader instanceof LegacyTranslogReader , equalTo ( true ) ) ; try ( final Translog . Snapshot snapshot = reader . newSnapshot ( ) ) { final Translog . Operation operation = snapshot . next ( ) ; assertThat ( <str> , operation . opType ( ) = = Translog . Operation . Type . INDEX , equalTo ( true ) ) ; Translog . Index op = ( Translog . Index ) operation ; assertThat ( op . id ( ) , equalTo ( <str> ) ) ; assertThat ( op . type ( ) , equalTo ( <str> ) ) ; assertThat ( op . source ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; assertThat ( op . routing ( ) , equalTo ( null ) ) ; assertThat ( op . parent ( ) , equalTo ( null ) ) ; assertThat ( op . version ( ) , equalTo ( <int> ) ) ; assertThat ( op . timestamp ( ) , equalTo ( <int> ) ) ; assertThat ( op . ttl ( ) , equalTo ( - <int> ) ) ; assertThat ( op . versionType ( ) , equalTo ( VersionType . INTERNAL ) ) ; assertNull ( snapshot . next ( ) ) ; } } } public void testV1ChecksummedTranslogVersion ( ) throws Exception { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; try ( ImmutableTranslogReader reader = openReader ( translogFile , <int> ) ) { try ( final Translog . Snapshot snapshot = reader . newSnapshot ( ) ) { assertThat ( <str> , reader instanceof ImmutableTranslogReader , equalTo ( true ) ) ; Translog . Operation operation = snapshot . next ( ) ; assertThat ( <str> , operation . opType ( ) = = Translog . Operation . Type . INDEX , equalTo ( true ) ) ; Translog . Index op = ( Translog . Index ) operation ; assertThat ( op . id ( ) , equalTo ( <str> ) ) ; assertThat ( op . type ( ) , equalTo ( <str> ) ) ; assertThat ( op . source ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; assertThat ( op . routing ( ) , equalTo ( null ) ) ; assertThat ( op . parent ( ) , equalTo ( null ) ) ; assertThat ( op . version ( ) , equalTo ( <int> ) ) ; assertThat ( op . timestamp ( ) , equalTo ( <int> ) ) ; assertThat ( op . ttl ( ) , equalTo ( - <int> ) ) ; assertThat ( op . versionType ( ) , equalTo ( VersionType . INTERNAL ) ) ; int opNum = <int> ; while ( snapshot . next ( ) ! = null ) { opNum + + ; } assertThat ( <str> , opNum , equalTo ( <int> ) ) ; } } } public void testCorruptedTranslogs ( ) throws Exception { try { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; openReader ( translogFile , <int> ) ; fail ( <str> ) ; } catch ( TranslogCorruptedException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; openReader ( translogFile , <int> ) ; fail ( <str> ) ; } catch ( TranslogCorruptedException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; try ( ImmutableTranslogReader reader = openReader ( translogFile , <int> ) ) { try ( final Translog . Snapshot snapshot = reader . newSnapshot ( ) ) { while ( snapshot . next ( ) ! = null ) { } } } fail ( <str> ) ; } catch ( TranslogCorruptedException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } public void testTruncatedTranslog ( ) throws Exception { try { Path translogFile = getDataPath ( <str> ) ; assertThat ( <str> , Files . exists ( translogFile ) , equalTo ( true ) ) ; try ( ImmutableTranslogReader reader = openReader ( translogFile , <int> ) ) { try ( final Translog . Snapshot snapshot = reader . newSnapshot ( ) ) { while ( snapshot . next ( ) ! = null ) { } } } fail ( <str> ) ; } catch ( TranslogCorruptedException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } public ImmutableTranslogReader openReader ( Path path , long id ) throws IOException { FileChannel channel = FileChannel . open ( path , StandardOpenOption . READ ) ; try { final ChannelReference raf = new ChannelReference ( path , id , channel , null ) ; ImmutableTranslogReader reader = ImmutableTranslogReader . open ( raf , new Checkpoint ( Files . size ( path ) , TranslogReader . UNKNOWN_OP_COUNT , id ) , null ) ; channel = null ; return reader ; } finally { IOUtils . close ( channel ) ; } } } 
