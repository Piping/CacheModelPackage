package org . elasticsearch . snapshots ; import com . carrotsearch . hppc . IntHashSet ; import com . carrotsearch . hppc . IntSet ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . ListenableActionFuture ; import org . elasticsearch . action . admin . cluster . repositories . put . PutRepositoryResponse ; import org . elasticsearch . action . admin . cluster . snapshots . create . CreateSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . delete . DeleteSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . get . GetSnapshotsResponse ; import org . elasticsearch . action . admin . cluster . snapshots . restore . RestoreSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . status . SnapshotStatus ; import org . elasticsearch . action . admin . cluster . snapshots . status . SnapshotsStatusResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . AbstractDiffable ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . MetaData . Custom ; import org . elasticsearch . cluster . metadata . MetaDataIndexStateService ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . index . store . IndexStore ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . indices . ttl . IndicesTTLService ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . repositories . RepositoryMissingException ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . action . admin . cluster . repositories . get . RestGetRepositoriesAction ; import org . elasticsearch . rest . action . admin . cluster . state . RestClusterStateAction ; import org . elasticsearch . snapshots . mockstore . MockRepository ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . rest . FakeRestRequest ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Collection ; import java . util . EnumSet ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBlocked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertThrows ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThan ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , transportClientRatio = <int> ) @ESIntegTestCase.SuppressLocalMode public class DedicatedClusterSnapshotRestoreIT extends AbstractSnapshotIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockRepository . Plugin . class ) ; } public void testRestorePersistentSettings ( ) throws Exception { logger . info ( <str> ) ; Settings nodeSettings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( nodeSettings ) ; Client client = client ( ) ; String secondNode = internalCluster ( ) . startNode ( nodeSettings ) ; logger . info ( <str> ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) , equalTo ( false ) ) ; int random = randomIntBetween ( <int> , <int> ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( Settings . settingsBuilder ( ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . put ( IndicesTTLService . INDICES_TTL_INTERVAL , random , TimeUnit . MINUTES ) ) . execute ( ) . actionGet ( ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) . getMetaData ( ) . persistentSettings ( ) . getAsTime ( IndicesTTLService . INDICES_TTL_INTERVAL , TimeValue . timeValueMinutes ( <int> ) ) . millis ( ) , equalTo ( TimeValue . timeValueMinutes ( random ) . millis ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) . getMetaData ( ) . persistentSettings ( ) . getAsInt ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , - <int> ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) , equalTo ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . execute ( ) . actionGet ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( Settings . settingsBuilder ( ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . put ( IndicesTTLService . INDICES_TTL_INTERVAL , TimeValue . timeValueMinutes ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) . getMetaData ( ) . persistentSettings ( ) . getAsTime ( IndicesTTLService . INDICES_TTL_INTERVAL , TimeValue . timeValueMinutes ( <int> ) ) . millis ( ) , equalTo ( TimeValue . timeValueMinutes ( <int> ) . millis ( ) ) ) ; stopNode ( secondNode ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( true ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) . getMetaData ( ) . persistentSettings ( ) . getAsTime ( IndicesTTLService . INDICES_TTL_INTERVAL , TimeValue . timeValueMinutes ( <int> ) ) . millis ( ) , equalTo ( TimeValue . timeValueMinutes ( random ) . millis ( ) ) ) ; logger . info ( <str> ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) . getMetaData ( ) . persistentSettings ( ) . getAsInt ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , - <int> ) , not ( equalTo ( <int> ) ) ) ; } public void testRestoreCustomMetadata ( ) throws Exception { Path tempDir = randomRepoPath ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( ) ; Client client = client ( ) ; createIndex ( <str> ) ; ensureYellow ( ) ; logger . info ( <str> ) ; updateClusterState ( new ClusterStateUpdater ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { ClusterState . Builder builder = ClusterState . builder ( currentState ) ; MetaData . Builder metadataBuilder = MetaData . builder ( currentState . metaData ( ) ) ; metadataBuilder . putCustom ( SnapshottableMetadata . TYPE , new SnapshottableMetadata ( <str> ) ) ; metadataBuilder . putCustom ( NonSnapshottableMetadata . TYPE , new NonSnapshottableMetadata ( <str> ) ) ; metadataBuilder . putCustom ( SnapshottableGatewayMetadata . TYPE , new SnapshottableGatewayMetadata ( <str> ) ) ; metadataBuilder . putCustom ( NonSnapshottableGatewayMetadata . TYPE , new NonSnapshottableGatewayMetadata ( <str> ) ) ; metadataBuilder . putCustom ( SnapshotableGatewayNoApiMetadata . TYPE , new SnapshotableGatewayNoApiMetadata ( <str> ) ) ; builder . metaData ( metadataBuilder ) ; return builder . build ( ) ; } } ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , tempDir ) ) . execute ( ) . actionGet ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . execute ( ) . actionGet ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; updateClusterState ( new ClusterStateUpdater ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { ClusterState . Builder builder = ClusterState . builder ( currentState ) ; MetaData . Builder metadataBuilder = MetaData . builder ( currentState . metaData ( ) ) ; if ( randomBoolean ( ) ) { metadataBuilder . putCustom ( SnapshottableMetadata . TYPE , new SnapshottableMetadata ( <str> ) ) ; } else { metadataBuilder . removeCustom ( SnapshottableMetadata . TYPE ) ; } metadataBuilder . putCustom ( NonSnapshottableMetadata . TYPE , new NonSnapshottableMetadata ( <str> ) ) ; if ( randomBoolean ( ) ) { metadataBuilder . putCustom ( SnapshottableGatewayMetadata . TYPE , new SnapshottableGatewayMetadata ( <str> ) ) ; } else { metadataBuilder . removeCustom ( SnapshottableGatewayMetadata . TYPE ) ; } metadataBuilder . putCustom ( NonSnapshottableGatewayMetadata . TYPE , new NonSnapshottableGatewayMetadata ( <str> ) ) ; metadataBuilder . removeCustom ( SnapshotableGatewayNoApiMetadata . TYPE ) ; builder . metaData ( metadataBuilder ) ; return builder . build ( ) ; } } ) ; logger . info ( <str> ) ; assertAcked ( client . admin ( ) . cluster ( ) . prepareDeleteRepository ( <str> ) ) ; logger . info ( <str> ) ; putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , tempDir ) ) . execute ( ) . actionGet ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( true ) . setIndices ( <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; assertThrows ( client . admin ( ) . cluster ( ) . prepareGetRepositories ( <str> ) , RepositoryMissingException . class ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetRepositories ( <str> ) . get ( ) . repositories ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; ClusterState clusterState = client . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; logger . info ( <str> , clusterState ) ; MetaData metaData = clusterState . getMetaData ( ) ; assertThat ( ( ( SnapshottableMetadata ) metaData . custom ( SnapshottableMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( NonSnapshottableMetadata ) metaData . custom ( NonSnapshottableMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( SnapshottableGatewayMetadata ) metaData . custom ( SnapshottableGatewayMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( NonSnapshottableGatewayMetadata ) metaData . custom ( NonSnapshottableGatewayMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; ensureYellow ( ) ; logger . info ( <str> ) ; clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; logger . info ( <str> , clusterState ) ; metaData = clusterState . getMetaData ( ) ; assertThat ( metaData . custom ( SnapshottableMetadata . TYPE ) , nullValue ( ) ) ; assertThat ( metaData . custom ( NonSnapshottableMetadata . TYPE ) , nullValue ( ) ) ; assertThat ( ( ( SnapshottableGatewayMetadata ) metaData . custom ( SnapshottableGatewayMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( NonSnapshottableGatewayMetadata ) metaData . custom ( NonSnapshottableGatewayMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; assertThat ( metaData . custom ( SnapshotableGatewayNoApiMetadata . TYPE ) , nullValue ( ) ) ; metaData = internalCluster ( ) . getInstance ( ClusterService . class ) . state ( ) . metaData ( ) ; assertThat ( ( ( SnapshotableGatewayNoApiMetadata ) metaData . custom ( SnapshotableGatewayNoApiMetadata . TYPE ) ) . getData ( ) , equalTo ( <str> ) ) ; } private void updateClusterState ( final ClusterStateUpdater updater ) throws InterruptedException { final CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; final ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { return updater . execute ( currentState ) ; } @Override public void onFailure ( String source , @Nullable Throwable t ) { countDownLatch . countDown ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { countDownLatch . countDown ( ) ; } } ) ; countDownLatch . await ( ) ; } private static interface ClusterStateUpdater { public ClusterState execute ( ClusterState currentState ) throws Exception ; } public void testSnapshotDuringNodeShutdown ( ) throws Exception { logger . info ( <str> ) ; Client client = client ( ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) . put ( <str> , randomAsciiOfLength ( <int> ) ) . put ( <str> , <int> ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; String blockedNode = blockNodeWithIndex ( <str> ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( false ) . setIndices ( <str> ) . get ( ) ; logger . info ( <str> ) ; waitForBlock ( blockedNode , <str> , TimeValue . timeValueSeconds ( <int> ) ) ; logger . info ( <str> , blockedNode ) ; unblockNode ( blockedNode ) ; logger . info ( <str> , blockedNode ) ; stopNode ( blockedNode ) ; logger . info ( <str> ) ; SnapshotInfo snapshotInfo = waitForCompletion ( <str> , <str> , TimeValue . timeValueSeconds ( <int> ) ) ; logger . info ( <str> , snapshotInfo . shardFailures ( ) . size ( ) ) ; logger . info ( <str> ) ; } public void testSnapshotWithStuckNode ( ) throws Exception { logger . info ( <str> ) ; ArrayList < String > nodes = new ArrayList < > ( ) ; nodes . add ( internalCluster ( ) . startNode ( ) ) ; nodes . add ( internalCluster ( ) . startNode ( ) ) ; Client client = client ( ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; Path repo = randomRepoPath ( ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , repo ) . put ( <str> , randomAsciiOfLength ( <int> ) ) . put ( <str> , <int> ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; String blockedNode = blockNodeWithIndex ( <str> ) ; nodes . remove ( blockedNode ) ; int numberOfFilesBeforeSnapshot = numberOfFiles ( repo ) ; logger . info ( <str> ) ; client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( false ) . setIndices ( <str> ) . get ( ) ; logger . info ( <str> ) ; waitForBlock ( blockedNode , <str> , TimeValue . timeValueSeconds ( <int> ) ) ; logger . info ( <str> , blockedNode ) ; ListenableActionFuture < DeleteSnapshotResponse > deleteSnapshotResponseFuture = internalCluster ( ) . client ( nodes . get ( <int> ) ) . admin ( ) . cluster ( ) . prepareDeleteSnapshot ( <str> , <str> ) . execute ( ) ; Thread . sleep ( <int> ) ; unblockNode ( blockedNode ) ; logger . info ( <str> , blockedNode ) ; stopNode ( blockedNode ) ; try { DeleteSnapshotResponse deleteSnapshotResponse = deleteSnapshotResponseFuture . actionGet ( ) ; assertThat ( deleteSnapshotResponse . isAcknowledged ( ) , equalTo ( true ) ) ; } catch ( SnapshotMissingException ex ) { } logger . info ( <str> ) ; assertThrows ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . execute ( ) , SnapshotMissingException . class ) ; assertThat ( <str> , numberOfFilesBeforeSnapshot , equalTo ( numberOfFiles ( repo ) - <int> ) ) ; logger . info ( <str> ) ; } public void testRestoreIndexWithMissingShards ( ) throws Exception { logger . info ( <str> ) ; internalCluster ( ) . startNode ( ) ; internalCluster ( ) . startNode ( ) ; cluster ( ) . wipeIndices ( <str> ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . stopRandomDataNode ( ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <str> ) . put ( <str> , <int> ) ) ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; assertBlocked ( client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setIndices ( <str> , <str> , <str> , <str> ) . setWaitForCompletion ( true ) , MetaDataIndexStateService . INDEX_CLOSED_BLOCK ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setIndices ( <str> , <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . state ( ) , equalTo ( SnapshotState . FAILED ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . reason ( ) , containsString ( <str> ) ) ; if ( randomBoolean ( ) ) { logger . info ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setIndices ( <str> , <str> , <str> ) . setWaitForCompletion ( false ) . setPartial ( true ) . execute ( ) . actionGet ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { SnapshotsStatusResponse snapshotsStatusResponse = client ( ) . admin ( ) . cluster ( ) . prepareSnapshotStatus ( <str> ) . setSnapshots ( <str> ) . get ( ) ; List < SnapshotStatus > snapshotStatuses = snapshotsStatusResponse . getSnapshots ( ) ; assertEquals ( snapshotStatuses . size ( ) , <int> ) ; logger . trace ( <str> , snapshotStatuses . get ( <int> ) ) ; assertTrue ( snapshotStatuses . get ( <int> ) . getState ( ) . completed ( ) ) ; } } , <int> , TimeUnit . MINUTES ) ; SnapshotsStatusResponse snapshotsStatusResponse = client ( ) . admin ( ) . cluster ( ) . prepareSnapshotStatus ( <str> ) . setSnapshots ( <str> ) . get ( ) ; List < SnapshotStatus > snapshotStatuses = snapshotsStatusResponse . getSnapshots ( ) ; assertThat ( snapshotStatuses . size ( ) , equalTo ( <int> ) ) ; SnapshotStatus snapshotStatus = snapshotStatuses . get ( <int> ) ; logger . info ( <str> , createSnapshotResponse . getSnapshotInfo ( ) . state ( ) , createSnapshotResponse . getSnapshotInfo ( ) . reason ( ) ) ; assertThat ( snapshotStatus . getShardsStats ( ) . getTotalShards ( ) , equalTo ( <int> ) ) ; assertThat ( snapshotStatus . getShardsStats ( ) . getDoneShards ( ) , lessThan ( <int> ) ) ; assertThat ( snapshotStatus . getShardsStats ( ) . getDoneShards ( ) , greaterThan ( <int> ) ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { GetSnapshotsResponse response = client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) ; assertThat ( response . getSnapshots ( ) . size ( ) , equalTo ( <int> ) ) ; SnapshotInfo snapshotInfo = response . getSnapshots ( ) . get ( <int> ) ; assertTrue ( snapshotInfo . state ( ) . completed ( ) ) ; assertEquals ( SnapshotState . PARTIAL , snapshotInfo . state ( ) ) ; } } , <int> , TimeUnit . MINUTES ) ; } else { logger . info ( <str> ) ; createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setIndices ( <str> , <str> , <str> ) . setWaitForCompletion ( true ) . setPartial ( true ) . execute ( ) . actionGet ( ) ; logger . info ( <str> , createSnapshotResponse . getSnapshotInfo ( ) . state ( ) , createSnapshotResponse . getSnapshotInfo ( ) . reason ( ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) , equalTo ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , lessThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . execute ( ) . actionGet ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . PARTIAL ) ) ; } assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> , <str> ) . execute ( ) . actionGet ( ) ) ; logger . info ( <str> ) ; assertThrows ( client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( false ) . setWaitForCompletion ( true ) . execute ( ) , SnapshotRestoreException . class ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( false ) . setIndices ( <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) , notNullValue ( ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , equalTo ( <int> ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . successfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . failedShards ( ) , equalTo ( <int> ) ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; cluster ( ) . wipeIndices ( <str> ) ; restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( false ) . setIndices ( <str> ) . setPartial ( true ) . setWaitForCompletion ( true ) . get ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) , notNullValue ( ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , equalTo ( <int> ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . successfulShards ( ) , allOf ( greaterThan ( <int> ) , lessThan ( <int> ) ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . failedShards ( ) , greaterThan ( <int> ) ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , allOf ( greaterThan ( <int> L ) , lessThan ( <int> ) ) ) ; logger . info ( <str> ) ; cluster ( ) . wipeIndices ( <str> ) ; restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( false ) . setIndices ( <str> ) . setPartial ( true ) . setWaitForCompletion ( true ) . get ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) , notNullValue ( ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , equalTo ( <int> ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . successfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . failedShards ( ) , equalTo ( <int> ) ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , allOf ( greaterThan ( <int> L ) , lessThan ( <int> ) ) ) ; } public void testRestoreIndexWithShardsMissingInLocalGateway ( ) throws Exception { logger . info ( <str> ) ; Settings nodeSettings = settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) . build ( ) ; internalCluster ( ) . startNode ( nodeSettings ) ; internalCluster ( ) . startNode ( nodeSettings ) ; cluster ( ) . wipeIndices ( <str> ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; int numberOfShards = <int> ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , numberOfShards ) . put ( <str> , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setIndices ( <str> ) . setWaitForCompletion ( true ) . get ( ) . getSnapshotInfo ( ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . restartRandomDataNode ( new InternalTestCluster . RestartCallback ( ) { @Override public boolean clearData ( String nodeName ) { return true ; } } ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setRestoreGlobalState ( false ) . setWaitForCompletion ( true ) . get ( ) . getRestoreInfo ( ) . successfulShards ( ) , equalTo ( <int> ) ) ; ensureGreen ( <str> ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; IntSet reusedShards = new IntHashSet ( ) ; for ( RecoveryState recoveryState : client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) . shardRecoveryStates ( ) . get ( <str> ) ) { if ( recoveryState . getIndex ( ) . reusedBytes ( ) > <int> ) { reusedShards . add ( recoveryState . getShardId ( ) . getId ( ) ) ; } } logger . info ( <str> , reusedShards ) ; assertThat ( reusedShards . size ( ) , greaterThanOrEqualTo ( numberOfShards / <int> ) ) ; } public void testRegistrationFailure ( ) { logger . info ( <str> ) ; internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , false ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> + i ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) . setVerify ( false ) . get ( ) ; } logger . info ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) . get ( ) ; } public void testThatSensitiveRepositorySettingsAreNotExposed ( ) throws Exception { Settings nodeSettings = settingsBuilder ( ) . put ( ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) . put ( <str> , <str> ) . put ( <str> , <str> ) ) . get ( ) ; RestGetRepositoriesAction getRepoAction = internalCluster ( ) . getInstance ( RestGetRepositoriesAction . class ) ; RestRequest getRepoRequest = new FakeRestRequest ( ) ; getRepoRequest . params ( ) . put ( <str> , <str> ) ; final CountDownLatch getRepoLatch = new CountDownLatch ( <int> ) ; final AtomicReference < AssertionError > getRepoError = new AtomicReference < > ( ) ; getRepoAction . handleRequest ( getRepoRequest , new RestChannel ( getRepoRequest , true ) { @Override public void sendResponse ( RestResponse response ) { try { assertThat ( response . content ( ) . toUtf8 ( ) , containsString ( <str> ) ) ; assertThat ( response . content ( ) . toUtf8 ( ) , not ( containsString ( <str> ) ) ) ; } catch ( AssertionError ex ) { getRepoError . set ( ex ) ; } getRepoLatch . countDown ( ) ; } } ) ; assertTrue ( getRepoLatch . await ( <int> , TimeUnit . SECONDS ) ) ; if ( getRepoError . get ( ) ! = null ) { throw getRepoError . get ( ) ; } RestClusterStateAction clusterStateAction = internalCluster ( ) . getInstance ( RestClusterStateAction . class ) ; RestRequest clusterStateRequest = new FakeRestRequest ( ) ; final CountDownLatch clusterStateLatch = new CountDownLatch ( <int> ) ; final AtomicReference < AssertionError > clusterStateError = new AtomicReference < > ( ) ; clusterStateAction . handleRequest ( clusterStateRequest , new RestChannel ( clusterStateRequest , true ) { @Override public void sendResponse ( RestResponse response ) { try { assertThat ( response . content ( ) . toUtf8 ( ) , containsString ( <str> ) ) ; assertThat ( response . content ( ) . toUtf8 ( ) , not ( containsString ( <str> ) ) ) ; } catch ( AssertionError ex ) { clusterStateError . set ( ex ) ; } clusterStateLatch . countDown ( ) ; } } ) ; assertTrue ( clusterStateLatch . await ( <int> , TimeUnit . SECONDS ) ) ; if ( clusterStateError . get ( ) ! = null ) { throw clusterStateError . get ( ) ; } } @AwaitsFix ( bugUrl = <str> ) public void testChaosSnapshot ( ) throws Exception { final List < String > indices = new CopyOnWriteArrayList < > ( ) ; Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; int initialNodes = between ( <int> , <int> ) ; logger . info ( <str> , initialNodes ) ; for ( int i = <int> ; i < initialNodes ; i + + ) { internalCluster ( ) . startNode ( settings ) ; } logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) . put ( <str> , randomBoolean ( ) ) . put ( <str> , randomIntBetween ( <int> , <int> ) , ByteSizeUnit . BYTES ) ) ) ; int initialIndices = between ( <int> , <int> ) ; logger . info ( <str> , initialIndices ) ; for ( int i = <int> ; i < initialIndices ; i + + ) { createTestIndex ( <str> + i ) ; indices . add ( <str> + i ) ; } int asyncNodes = between ( <int> , <int> ) ; logger . info ( <str> , asyncNodes ) ; InternalTestCluster . Async < List < String > > asyncNodesFuture = internalCluster ( ) . startNodesAsync ( asyncNodes , settings ) ; int asyncIndices = between ( <int> , <int> ) ; logger . info ( <str> , asyncIndices ) ; Thread [ ] asyncIndexThreads = new Thread [ asyncIndices ] ; for ( int i = <int> ; i < asyncIndices ; i + + ) { final int cur = i ; asyncIndexThreads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { createTestIndex ( <str> + cur ) ; indices . add ( <str> + cur ) ; } } ) ; asyncIndexThreads [ i ] . start ( ) ; } logger . info ( <str> ) ; ListenableActionFuture < CreateSnapshotResponse > snapshotResponseFuture = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . setPartial ( true ) . execute ( ) ; long start = System . currentTimeMillis ( ) ; int randomIndices = <int> ; while ( System . currentTimeMillis ( ) - start < <int> & & ! snapshotIsDone ( <str> , <str> ) ) { Thread . sleep ( <int> ) ; int chaosType = randomInt ( <int> ) ; if ( chaosType < <int> ) { if ( indices . size ( ) > <int> ) { String index = indices . remove ( randomInt ( indices . size ( ) - <int> ) ) ; logger . info ( <str> , index ) ; internalCluster ( ) . wipeIndices ( index ) ; } } else if ( chaosType < <int> ) { if ( cluster ( ) . size ( ) > <int> ) { logger . info ( <str> ) ; internalCluster ( ) . stopRandomDataNode ( ) ; } } else if ( chaosType < <int> ) { String index = <str> + randomIndices ; logger . info ( <str> , index ) ; createTestIndex ( index ) ; randomIndices + + ; } else { logger . info ( <str> ) ; } } logger . info ( <str> ) ; for ( int i = <int> ; i < asyncIndices ; i + + ) { asyncIndexThreads [ i ] . join ( ) ; } logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexStore . INDEX_STORE_THROTTLE_TYPE , <str> ) ) ) ; try { CreateSnapshotResponse snapshotResponse = snapshotResponseFuture . get ( ) ; SnapshotInfo snapshotInfo = snapshotResponse . getSnapshotInfo ( ) ; assertNotNull ( snapshotInfo ) ; logger . info ( <str> , snapshotInfo . state ( ) , snapshotInfo . totalShards ( ) , snapshotInfo . successfulShards ( ) ) ; } catch ( Exception ex ) { logger . info ( <str> , ex ) ; } asyncNodesFuture . get ( ) ; logger . info ( <str> ) ; } public void testMasterShutdownDuringSnapshot ( ) throws Exception { Settings masterSettings = settingsBuilder ( ) . put ( <str> , false ) . build ( ) ; Settings dataSettings = settingsBuilder ( ) . put ( <str> , false ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( masterSettings ) ; internalCluster ( ) . startNode ( masterSettings ) ; internalCluster ( ) . startNode ( dataSettings ) ; internalCluster ( ) . startNode ( dataSettings ) ; final Client client = client ( ) ; logger . info ( <str> ) ; assertAcked ( client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) . put ( <str> , randomBoolean ( ) ) . put ( <str> , randomIntBetween ( <int> , <int> ) , ByteSizeUnit . BYTES ) ) ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , between ( <int> , <int> ) ) . put ( <str> , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; final int numdocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numdocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + i ) ; } indexRandom ( true , builders ) ; flushAndRefresh ( ) ; final int numberOfShards = getNumShards ( <str> ) . numPrimaries ; logger . info ( <str> , numberOfShards ) ; final ClusterService clusterService = internalCluster ( ) . clusterService ( internalCluster ( ) . getMasterName ( ) ) ; BlockingClusterStateListener snapshotListener = new BlockingClusterStateListener ( clusterService , <str> , <str> , Priority . HIGH ) ; try { clusterService . addFirst ( snapshotListener ) ; logger . info ( <str> ) ; dataNodeClient ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( false ) . setIndices ( <str> ) . get ( ) ; assertBusyPendingTasks ( <str> , <int> ) ; logger . info ( <str> ) ; internalCluster ( ) . stopCurrentMasterNode ( ) ; logger . info ( <str> ) ; snapshotListener . unblock ( ) ; } finally { clusterService . remove ( snapshotListener ) ; } logger . info ( <str> ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { GetSnapshotsResponse snapshotsStatusResponse = client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) ; SnapshotInfo snapshotInfo = snapshotsStatusResponse . getSnapshots ( ) . get ( <int> ) ; assertTrue ( snapshotInfo . state ( ) . completed ( ) ) ; } } , <int> , TimeUnit . MINUTES ) ; logger . info ( <str> ) ; GetSnapshotsResponse snapshotsStatusResponse = client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) ; SnapshotInfo snapshotInfo = snapshotsStatusResponse . getSnapshots ( ) . get ( <int> ) ; assertEquals ( SnapshotState . SUCCESS , snapshotInfo . state ( ) ) ; assertEquals ( snapshotInfo . totalShards ( ) , snapshotInfo . successfulShards ( ) ) ; assertEquals ( <int> , snapshotInfo . failedShards ( ) ) ; } private boolean snapshotIsDone ( String repository , String snapshot ) { try { SnapshotsStatusResponse snapshotsStatusResponse = client ( ) . admin ( ) . cluster ( ) . prepareSnapshotStatus ( repository ) . setSnapshots ( snapshot ) . get ( ) ; if ( snapshotsStatusResponse . getSnapshots ( ) . isEmpty ( ) ) { return false ; } for ( SnapshotStatus snapshotStatus : snapshotsStatusResponse . getSnapshots ( ) ) { if ( snapshotStatus . getState ( ) . completed ( ) ) { return true ; } } return false ; } catch ( SnapshotMissingException ex ) { return false ; } } private void createTestIndex ( String name ) { assertAcked ( prepareCreate ( name , <int> , settingsBuilder ( ) . put ( <str> , between ( <int> , <int> ) ) . put ( <str> , between ( <int> , <int> ) ) ) ) ; ensureYellow ( name ) ; logger . info ( <str> , name ) ; for ( int i = <int> ; i < between ( <int> , <int> ) ; i + + ) { index ( name , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( name ) . setSettings ( Settings . builder ( ) . put ( IndexStore . INDEX_STORE_THROTTLE_TYPE , <str> ) . put ( IndexStore . INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC , between ( <int> , <int> ) ) ) ) ; } public static abstract class TestCustomMetaData extends AbstractDiffable < Custom > implements MetaData . Custom { private final String data ; protected TestCustomMetaData ( String data ) { this . data = data ; } public String getData ( ) { return data ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; TestCustomMetaData that = ( TestCustomMetaData ) o ; if ( ! data . equals ( that . data ) ) return false ; return true ; } @Override public int hashCode ( ) { return data . hashCode ( ) ; } protected abstract TestCustomMetaData newTestCustomMetaData ( String data ) ; @Override public Custom readFrom ( StreamInput in ) throws IOException { return newTestCustomMetaData ( in . readString ( ) ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( getData ( ) ) ; } @Override public Custom fromXContent ( XContentParser parser ) throws IOException { XContentParser . Token token ; String data = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String currentFieldName = parser . currentName ( ) ; if ( <str> . equals ( currentFieldName ) ) { if ( parser . nextToken ( ) ! = XContentParser . Token . VALUE_STRING ) { throw new ElasticsearchParseException ( <str> ) ; } data = parser . text ( ) ; } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> ) ; } } if ( data = = null ) { throw new ElasticsearchParseException ( <str> ) ; } return newTestCustomMetaData ( data ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . field ( <str> , getData ( ) ) ; return builder ; } } static { MetaData . registerPrototype ( SnapshottableMetadata . TYPE , SnapshottableMetadata . PROTO ) ; MetaData . registerPrototype ( NonSnapshottableMetadata . TYPE , NonSnapshottableMetadata . PROTO ) ; MetaData . registerPrototype ( SnapshottableGatewayMetadata . TYPE , SnapshottableGatewayMetadata . PROTO ) ; MetaData . registerPrototype ( NonSnapshottableGatewayMetadata . TYPE , NonSnapshottableGatewayMetadata . PROTO ) ; MetaData . registerPrototype ( SnapshotableGatewayNoApiMetadata . TYPE , SnapshotableGatewayNoApiMetadata . PROTO ) ; } public static class SnapshottableMetadata extends TestCustomMetaData { public static final String TYPE = <str> ; public static final SnapshottableMetadata PROTO = new SnapshottableMetadata ( <str> ) ; public SnapshottableMetadata ( String data ) { super ( data ) ; } @Override public String type ( ) { return TYPE ; } @Override protected TestCustomMetaData newTestCustomMetaData ( String data ) { return new SnapshottableMetadata ( data ) ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return MetaData . API_AND_SNAPSHOT ; } } public static class NonSnapshottableMetadata extends TestCustomMetaData { public static final String TYPE = <str> ; public static final NonSnapshottableMetadata PROTO = new NonSnapshottableMetadata ( <str> ) ; public NonSnapshottableMetadata ( String data ) { super ( data ) ; } @Override public String type ( ) { return TYPE ; } @Override protected NonSnapshottableMetadata newTestCustomMetaData ( String data ) { return new NonSnapshottableMetadata ( data ) ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return MetaData . API_ONLY ; } } public static class SnapshottableGatewayMetadata extends TestCustomMetaData { public static final String TYPE = <str> ; public static final SnapshottableGatewayMetadata PROTO = new SnapshottableGatewayMetadata ( <str> ) ; public SnapshottableGatewayMetadata ( String data ) { super ( data ) ; } @Override public String type ( ) { return TYPE ; } @Override protected TestCustomMetaData newTestCustomMetaData ( String data ) { return new SnapshottableGatewayMetadata ( data ) ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return EnumSet . of ( MetaData . XContentContext . API , MetaData . XContentContext . SNAPSHOT , MetaData . XContentContext . GATEWAY ) ; } } public static class NonSnapshottableGatewayMetadata extends TestCustomMetaData { public static final String TYPE = <str> ; public static final NonSnapshottableGatewayMetadata PROTO = new NonSnapshottableGatewayMetadata ( <str> ) ; public NonSnapshottableGatewayMetadata ( String data ) { super ( data ) ; } @Override public String type ( ) { return TYPE ; } @Override protected NonSnapshottableGatewayMetadata newTestCustomMetaData ( String data ) { return new NonSnapshottableGatewayMetadata ( data ) ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return MetaData . API_AND_GATEWAY ; } } public static class SnapshotableGatewayNoApiMetadata extends TestCustomMetaData { public static final String TYPE = <str> ; public static final SnapshotableGatewayNoApiMetadata PROTO = new SnapshotableGatewayNoApiMetadata ( <str> ) ; public SnapshotableGatewayNoApiMetadata ( String data ) { super ( data ) ; } @Override public String type ( ) { return TYPE ; } @Override protected SnapshotableGatewayNoApiMetadata newTestCustomMetaData ( String data ) { return new SnapshotableGatewayNoApiMetadata ( data ) ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return EnumSet . of ( MetaData . XContentContext . GATEWAY , MetaData . XContentContext . SNAPSHOT ) ; } } } 
