package org . apache . cassandra . cql3 ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Test ; import com . datastax . driver . core . * ; import com . datastax . driver . core . policies . LoggingRetryPolicy ; import com . datastax . driver . core . policies . Policies ; import com . datastax . driver . core . utils . Bytes ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . service . EmbeddedCassandraService ; public class CorruptionTest extends SchemaLoader { private static EmbeddedCassandraService cassandra ; private static Cluster cluster ; private static Session session ; private static PreparedStatement getStatement ; private static PreparedStatement putStatement ; private static String KEYSPACE = <str> ; private static final String TABLE = <str> ; private static final String KEY = <str> ; private static String VALUE ; private final int THREADPOOL_SIZE = <int> ; @BeforeClass ( ) public static void setup ( ) throws ConfigurationException , IOException { Schema . instance . clear ( ) ; cassandra = new EmbeddedCassandraService ( ) ; cassandra . start ( ) ; cluster = Cluster . builder ( ) . addContactPoint ( <str> ) . withRetryPolicy ( new LoggingRetryPolicy ( Policies . defaultRetryPolicy ( ) ) ) . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; session = cluster . connect ( ) ; session . execute ( <str> + KEYSPACE + <str> + <str> ) ; session . execute ( <str> + KEYSPACE ) ; session . execute ( <str> + TABLE + <str> + <str> + <str> + <str> ) ; getStatement = session . prepare ( <str> + TABLE + <str> ) ; getStatement . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; putStatement = session . prepare ( <str> + TABLE + <str> ) ; putStatement . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; StringBuilder s = new StringBuilder ( ) ; char a = <str> ; char z = <str> ; for ( int i = <int> ; i < <int> * <int> ; i + + ) { char x = ( char ) ( ( i % ( ( z - a ) + <int> ) ) + a ) ; if ( x = = <str> ) { x = <str> ; } s . append ( x ) ; } VALUE = s . toString ( ) ; } @Test public void runCorruptionTest ( ) { final CountDownLatch failure = new CountDownLatch ( <int> ) ; ExecutorService executor = Executors . newFixedThreadPool ( THREADPOOL_SIZE ) ; for ( int i = <int> ; i < THREADPOOL_SIZE ; i + + ) { executor . execute ( new Runnable ( ) { @Override public void run ( ) { for ( int i = <int> ; i < <int> ; i + + ) { put ( KEY . getBytes ( ) , VALUE . getBytes ( ) ) ; byte [ ] res = get ( KEY . getBytes ( ) ) ; if ( res = = null ) continue ; if ( ! Arrays . equals ( VALUE . getBytes ( ) , res ) ) { failure . countDown ( ) ; } } } private void dumpKeys ( byte [ ] putdata , byte [ ] getdata ) throws IOException { String basename = <str> + Thread . currentThread ( ) . getId ( ) ; File put = new File ( basename + <str> ) ; File get = new File ( basename + <str> ) ; try ( FileWriter pw = new FileWriter ( put ) ) { pw . write ( new String ( putdata ) ) ; } try ( FileWriter pw = new FileWriter ( get ) ) { pw . write ( new String ( getdata ) ) ; } } } ) ; } try { assert ! failure . await ( <int> , TimeUnit . MINUTES ) ; } catch ( InterruptedException e ) { } executor . shutdownNow ( ) ; } public static byte [ ] get ( byte [ ] key ) { BoundStatement boundStatement = new BoundStatement ( getStatement ) ; boundStatement . setBytes ( <int> , ByteBuffer . wrap ( key ) ) ; final com . datastax . driver . core . ResultSet resultSet = session . execute ( boundStatement ) ; final Row row = resultSet . one ( ) ; if ( row ! = null ) { final ByteBuffer byteBuf = row . getBytes ( <str> ) ; return Bytes . getArray ( byteBuf ) ; } return null ; } public static void put ( byte [ ] key , byte [ ] value ) { BoundStatement boundStatement = new BoundStatement ( putStatement ) ; boundStatement . setBytes ( <int> , ByteBuffer . wrap ( key ) ) ; boundStatement . setBytes ( <int> , ByteBuffer . wrap ( value ) ) ; session . execute ( boundStatement ) ; } } 
