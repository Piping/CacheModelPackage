package io . netty . handler . codec . http . websocketx ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . URI ; public class WebSocketClientHandshaker13 extends WebSocketClientHandshaker { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketClientHandshaker13 . class ) ; public static final String MAGIC_GUID = <str> ; private String expectedChallengeResponseString ; private final boolean allowExtensions ; private final boolean performMasking ; private final boolean allowMaskMismatch ; public WebSocketClientHandshaker13 ( URI webSocketURL , WebSocketVersion version , String subprotocol , boolean allowExtensions , HttpHeaders customHeaders , int maxFramePayloadLength ) { this ( webSocketURL , version , subprotocol , allowExtensions , customHeaders , maxFramePayloadLength , true , false ) ; } public WebSocketClientHandshaker13 ( URI webSocketURL , WebSocketVersion version , String subprotocol , boolean allowExtensions , HttpHeaders customHeaders , int maxFramePayloadLength , boolean performMasking , boolean allowMaskMismatch ) { super ( webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; this . allowExtensions = allowExtensions ; this . performMasking = performMasking ; this . allowMaskMismatch = allowMaskMismatch ; } @Override protected FullHttpRequest newHandshakeRequest ( ) { URI wsURL = uri ( ) ; String path = rawPath ( wsURL ) ; byte [ ] nonce = WebSocketUtil . randomBytes ( <int> ) ; String key = WebSocketUtil . base64 ( nonce ) ; String acceptSeed = key + MAGIC_GUID ; byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; expectedChallengeResponseString = WebSocketUtil . base64 ( sha1 ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , key , expectedChallengeResponseString ) ; } int wsPort = wsURL . getPort ( ) ; if ( wsPort = = - <int> ) { if ( <str> . equals ( wsURL . getScheme ( ) ) ) { wsPort = <int> ; } else { wsPort = <int> ; } } FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , path ) ; HttpHeaders headers = request . headers ( ) ; headers . add ( HttpHeaderNames . UPGRADE , HttpHeaderValues . WEBSOCKET ) . add ( HttpHeaderNames . CONNECTION , HttpHeaderValues . UPGRADE ) . add ( HttpHeaderNames . SEC_WEBSOCKET_KEY , key ) . add ( HttpHeaderNames . HOST , wsURL . getHost ( ) + <str> + wsPort ) ; String originValue = <str> + wsURL . getHost ( ) ; if ( wsPort ! = <int> & & wsPort ! = <int> ) { originValue = originValue + <str> + wsPort ; } headers . add ( HttpHeaderNames . SEC_WEBSOCKET_ORIGIN , originValue ) ; String expectedSubprotocol = expectedSubprotocol ( ) ; if ( expectedSubprotocol ! = null & & ! expectedSubprotocol . isEmpty ( ) ) { headers . add ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL , expectedSubprotocol ) ; } headers . add ( HttpHeaderNames . SEC_WEBSOCKET_VERSION , <str> ) ; if ( customHeaders ! = null ) { headers . add ( customHeaders ) ; } return request ; } @Override protected void verify ( FullHttpResponse response ) { final HttpResponseStatus status = HttpResponseStatus . SWITCHING_PROTOCOLS ; final HttpHeaders headers = response . headers ( ) ; if ( ! response . status ( ) . equals ( status ) ) { throw new WebSocketHandshakeException ( <str> + response . status ( ) ) ; } CharSequence upgrade = headers . get ( HttpHeaderNames . UPGRADE ) ; if ( ! HttpHeaderValues . WEBSOCKET . contentEqualsIgnoreCase ( upgrade ) ) { throw new WebSocketHandshakeException ( <str> + upgrade ) ; } CharSequence connection = headers . get ( HttpHeaderNames . CONNECTION ) ; if ( ! HttpHeaderValues . UPGRADE . contentEqualsIgnoreCase ( connection ) ) { throw new WebSocketHandshakeException ( <str> + connection ) ; } CharSequence accept = headers . get ( HttpHeaderNames . SEC_WEBSOCKET_ACCEPT ) ; if ( accept = = null | | ! accept . equals ( expectedChallengeResponseString ) ) { throw new WebSocketHandshakeException ( String . format ( <str> , accept , expectedChallengeResponseString ) ) ; } } @Override protected WebSocketFrameDecoder newWebsocketDecoder ( ) { return new WebSocket13FrameDecoder ( false , allowExtensions , maxFramePayloadLength ( ) , allowMaskMismatch ) ; } @Override protected WebSocketFrameEncoder newWebSocketEncoder ( ) { return new WebSocket13FrameEncoder ( performMasking ) ; } } 
