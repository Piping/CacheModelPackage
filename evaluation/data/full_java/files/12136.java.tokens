package org . gradle . internal . typeconversion ; import org . gradle . api . specs . Spec ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . util . CollectionUtils ; import org . gradle . util . GUtil ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; public class EnumFromCharSequenceNotationParser < T extends Enum > implements ValueAwareNotationParser < T > { private final Class < ? extends T > type ; public EnumFromCharSequenceNotationParser ( Class < ? extends T > enumType ) { assert enumType . isEnum ( ) : <str> ; this . type = enumType ; } public T parseNotation ( CharSequence notation ) throws UnsupportedNotationException , TypeConversionException { final String enumString = notation . toString ( ) ; List < ? extends T > enumConstants = Arrays . asList ( type . getEnumConstants ( ) ) ; T match = CollectionUtils . findFirst ( enumConstants , new Spec < T > ( ) { public boolean isSatisfiedBy ( T enumValue ) { return enumValue . name ( ) . equalsIgnoreCase ( enumString ) ; } } ) ; if ( match = = null ) { throw new TypeConversionException ( String . format ( <str> , enumString , type . getName ( ) , CollectionUtils . toStringList ( Arrays . asList ( type . getEnumConstants ( ) ) ) ) ) ; } else { return match ; } } @Override public void describe ( DiagnosticsVisitor visitor ) { List < String > values = new ArrayList < String > ( ) ; describeValues ( values ) ; visitor . candidate ( String . format ( <str> , GUtil . toString ( values ) ) ) ; } public void describeValues ( Collection < String > collector ) { final Enum [ ] enumConstants = type . getEnumConstants ( ) ; for ( Enum enumConstant : enumConstants ) { collector . add ( enumConstant . name ( ) ) ; } } } 
