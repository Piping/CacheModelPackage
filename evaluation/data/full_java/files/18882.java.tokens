package io . netty . handler . codec . compression ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; final class Bzip2HuffmanStageDecoder { private final Bzip2BitReader reader ; byte [ ] selectors ; private final int [ ] minimumLengths ; private final int [ ] [ ] codeBases ; private final int [ ] [ ] codeLimits ; private final int [ ] [ ] codeSymbols ; private int currentTable ; private int groupIndex = - <int> ; private int groupPosition = - <int> ; final int totalTables ; final int alphabetSize ; final Bzip2MoveToFrontTable tableMTF = new Bzip2MoveToFrontTable ( ) ; int currentSelector ; final byte [ ] [ ] tableCodeLengths ; int currentGroup ; int currentLength = - <int> ; int currentAlpha ; boolean modifyLength ; Bzip2HuffmanStageDecoder ( final Bzip2BitReader reader , final int totalTables , final int alphabetSize ) { this . reader = reader ; this . totalTables = totalTables ; this . alphabetSize = alphabetSize ; minimumLengths = new int [ totalTables ] ; codeBases = new int [ totalTables ] [ HUFFMAN_DECODE_MAX_CODE_LENGTH + <int> ] ; codeLimits = new int [ totalTables ] [ HUFFMAN_DECODE_MAX_CODE_LENGTH + <int> ] ; codeSymbols = new int [ totalTables ] [ HUFFMAN_MAX_ALPHABET_SIZE ] ; tableCodeLengths = new byte [ totalTables ] [ HUFFMAN_MAX_ALPHABET_SIZE ] ; } void createHuffmanDecodingTables ( ) { final int alphabetSize = this . alphabetSize ; for ( int table = <int> ; table < tableCodeLengths . length ; table + + ) { final int [ ] tableBases = codeBases [ table ] ; final int [ ] tableLimits = codeLimits [ table ] ; final int [ ] tableSymbols = codeSymbols [ table ] ; final byte [ ] codeLengths = tableCodeLengths [ table ] ; int minimumLength = HUFFMAN_DECODE_MAX_CODE_LENGTH ; int maximumLength = <int> ; for ( int i = <int> ; i < alphabetSize ; i + + ) { final byte currLength = codeLengths [ i ] ; maximumLength = Math . max ( currLength , maximumLength ) ; minimumLength = Math . min ( currLength , minimumLength ) ; } minimumLengths [ table ] = minimumLength ; for ( int i = <int> ; i < alphabetSize ; i + + ) { tableBases [ codeLengths [ i ] + <int> ] + + ; } for ( int i = <int> , b = tableBases [ <int> ] ; i < HUFFMAN_DECODE_MAX_CODE_LENGTH + <int> ; i + + ) { b + = tableBases [ i ] ; tableBases [ i ] = b ; } for ( int i = minimumLength , code = <int> ; i < = maximumLength ; i + + ) { int base = code ; code + = tableBases [ i + <int> ] - tableBases [ i ] ; tableBases [ i ] = base - tableBases [ i ] ; tableLimits [ i ] = code - <int> ; code < < = <int> ; } for ( int bitLength = minimumLength , codeIndex = <int> ; bitLength < = maximumLength ; bitLength + + ) { for ( int symbol = <int> ; symbol < alphabetSize ; symbol + + ) { if ( codeLengths [ symbol ] = = bitLength ) { tableSymbols [ codeIndex + + ] = symbol ; } } } } currentTable = selectors [ <int> ] ; } int nextSymbol ( ) { if ( + + groupPosition % HUFFMAN_GROUP_RUN_LENGTH = = <int> ) { groupIndex + + ; if ( groupIndex = = selectors . length ) { throw new DecompressionException ( <str> ) ; } currentTable = selectors [ groupIndex ] & <hex> ; } final Bzip2BitReader reader = this . reader ; final int currentTable = this . currentTable ; final int [ ] tableLimits = codeLimits [ currentTable ] ; final int [ ] tableBases = codeBases [ currentTable ] ; final int [ ] tableSymbols = codeSymbols [ currentTable ] ; int codeLength = minimumLengths [ currentTable ] ; int codeBits = reader . readBits ( codeLength ) ; for ( ; codeLength < = HUFFMAN_DECODE_MAX_CODE_LENGTH ; codeLength + + ) { if ( codeBits < = tableLimits [ codeLength ] ) { return tableSymbols [ codeBits - tableBases [ codeLength ] ] ; } codeBits = codeBits < < <int> | reader . readBits ( <int> ) ; } throw new DecompressionException ( <str> ) ; } } 
