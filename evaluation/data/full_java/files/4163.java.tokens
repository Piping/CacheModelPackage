package org . eclipse . debug . internal . ui . elements . adapters ; import java . util . Arrays ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . internal . ui . DelegatingModelPresentation ; import org . eclipse . debug . internal . ui . LazyModelPresentation ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . provisional . AsynchronousLabelAdapter ; import org . eclipse . debug . internal . ui . viewers . provisional . ILabelRequestMonitor ; import org . eclipse . debug . internal . ui . views . launch . DebugElementHelper ; import org . eclipse . debug . ui . IDebugModelPresentation ; import org . eclipse . debug . ui . IDebugView ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; public class AsynchronousDebugLabelAdapter extends AsynchronousLabelAdapter { @Override protected void computeLabels ( Object element , IPresentationContext context , ILabelRequestMonitor monitor ) { DelegatingModelPresentation presentation = DebugElementHelper . getPresentation ( ) ; if ( element instanceof IDebugElement & & context . getPart ( ) instanceof IDebugView ) { IDebugView debugView = ( IDebugView ) context . getPart ( ) ; IDebugModelPresentation pres = debugView . getPresentation ( ( ( IDebugElement ) element ) . getModelIdentifier ( ) ) ; Map < String , Object > settings = null ; synchronized ( presentation ) { if ( pres instanceof DelegatingModelPresentation ) { settings = ( ( DelegatingModelPresentation ) pres ) . getAttributes ( ) ; } else if ( pres instanceof LazyModelPresentation ) { settings = ( ( LazyModelPresentation ) pres ) . getAttributes ( ) ; } if ( settings ! = null ) { for ( Entry < String , Object > entry : settings . entrySet ( ) ) { presentation . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } super . computeLabels ( element , context , monitor ) ; return ; } } } super . computeLabels ( element , context , monitor ) ; } @Override protected String [ ] getLabels ( Object element , IPresentationContext context ) throws CoreException { return new String [ ] { DebugElementHelper . getLabel ( element ) } ; } @Override protected ImageDescriptor [ ] getImageDescriptors ( Object element , IPresentationContext context ) throws CoreException { return new ImageDescriptor [ ] { DebugElementHelper . getImageDescriptor ( element ) } ; } @Override protected FontData [ ] getFontDatas ( Object element , IPresentationContext context ) throws CoreException { FontData [ ] datas = new FontData [ getNumElements ( context ) ] ; Arrays . fill ( datas , DebugElementHelper . getFont ( element ) ) ; return datas ; } @Override protected RGB [ ] getForegrounds ( Object element , IPresentationContext context ) throws CoreException { RGB [ ] rgbs = new RGB [ getNumElements ( context ) ] ; Arrays . fill ( rgbs , DebugElementHelper . getForeground ( element ) ) ; return rgbs ; } @Override protected RGB [ ] getBackgrounds ( Object element , IPresentationContext context ) throws CoreException { RGB [ ] rgbs = new RGB [ getNumElements ( context ) ] ; Arrays . fill ( rgbs , DebugElementHelper . getBackground ( element ) ) ; return rgbs ; } protected int getNumElements ( IPresentationContext context ) { String [ ] columns = context . getColumns ( ) ; if ( columns = = null ) { return <int> ; } return columns . length ; } } 
