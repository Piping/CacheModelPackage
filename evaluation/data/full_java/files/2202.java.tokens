package org . nd4j . linalg . factory ; import java . io . IOException ; import java . util . * ; import org . nd4j . linalg . io . Resource ; import org . reflections . Reflections ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class Nd4jBackend { public static final int BACKEND_PRIORITY_CPU = <int> ; public static final int BACKEND_PRIORITY_GPU = <int> ; private static final Logger log = LoggerFactory . getLogger ( Nd4jBackend . class ) ; private Properties props ; public abstract int getPriority ( ) ; public abstract boolean isAvailable ( ) ; public abstract boolean canRun ( ) ; public abstract Resource getConfigurationResource ( ) ; public static Nd4jBackend load ( ) throws NoAvailableBackendException { List < Nd4jBackend > backends = new ArrayList < > ( <int> ) ; ServiceLoader < Nd4jBackend > loader = ServiceLoader . load ( Nd4jBackend . class ) ; try { Iterator < Nd4jBackend > backendIterator = loader . iterator ( ) ; while ( backendIterator . hasNext ( ) ) backends . add ( backendIterator . next ( ) ) ; } catch ( ServiceConfigurationError serviceError ) { throw new RuntimeException ( <str> , serviceError ) ; } Collections . sort ( backends , new Comparator < Nd4jBackend > ( ) { @Override public int compare ( Nd4jBackend o1 , Nd4jBackend o2 ) { return o2 . getPriority ( ) - o1 . getPriority ( ) ; } } ) ; for ( Nd4jBackend backend : backends ) { if ( ! backend . isAvailable ( ) ) { log . trace ( <str> , backend . getClass ( ) . getSimpleName ( ) ) ; continue ; } log . trace ( <str> , backend . getClass ( ) . getSimpleName ( ) ) ; return backend ; } log . trace ( <str> ) ; Set < Class < ? extends Nd4jBackend > > clazzes = new Reflections ( <str> ) . getSubTypesOf ( Nd4jBackend . class ) ; List < Nd4jBackend > reflectionBackends = new ArrayList < > ( ) ; for ( Class < ? extends Nd4jBackend > backend : clazzes ) { try { Nd4jBackend load = backend . newInstance ( ) ; reflectionBackends . add ( load ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } Collections . sort ( backends , new Comparator < Nd4jBackend > ( ) { @Override public int compare ( Nd4jBackend o1 , Nd4jBackend o2 ) { return o2 . getPriority ( ) - o1 . getPriority ( ) ; } } ) ; for ( Nd4jBackend backend : reflectionBackends ) { if ( ! backend . isAvailable ( ) ) { log . trace ( <str> , backend . getClass ( ) . getSimpleName ( ) ) ; continue ; } log . info ( <str> , backend . getClass ( ) . getSimpleName ( ) ) ; return backend ; } throw new NoAvailableBackendException ( ) ; } public Properties getProperties ( ) throws IOException { if ( props ! = null ) return props ; props = new Properties ( ) ; props . load ( getConfigurationResource ( ) . getInputStream ( ) ) ; return props ; } @SuppressWarnings ( <str> ) public static class NoAvailableBackendException extends Exception { } } 
