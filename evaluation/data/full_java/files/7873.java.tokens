package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterInfoService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . DiskUsage ; import org . elasticsearch . cluster . MockInternalClusterInfoService . DevNullClusterInfo ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocators ; import org . elasticsearch . cluster . routing . allocation . command . AllocationCommand ; import org . elasticsearch . cluster . routing . allocation . command . AllocationCommands ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESAllocationTestCase ; import org . elasticsearch . test . gateway . NoopGatewayAllocator ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import static org . elasticsearch . cluster . routing . ShardRoutingState . * ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . * ; public class DiskThresholdDeciderTests extends ESAllocationTestCase { private static ShardsAllocators makeShardsAllocators ( ) { return new ShardsAllocators ( NoopGatewayAllocator . INSTANCE ) ; } public void testDiskThreshold ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <float> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <float> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <float> ) . build ( ) ; deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <float> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <float> ) . build ( ) ; deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; } public void testDiskThresholdWithAbsoluteSizes ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; String nodeWithPrimary , nodeWithoutPrimary ; if ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) = = <int> ) { nodeWithPrimary = <str> ; nodeWithoutPrimary = <str> ; } else { nodeWithPrimary = <str> ; nodeWithoutPrimary = <str> ; } logger . info ( <str> , nodeWithPrimary ) ; logger . info ( <str> , nodeWithoutPrimary ) ; usagesBuilder = ImmutableOpenMap . builder ( usages ) ; usagesBuilder . put ( nodeWithoutPrimary , new DiskUsage ( nodeWithoutPrimary , <str> , <str> , <int> , <int> ) ) ; usages = usagesBuilder . build ( ) ; final ClusterInfo clusterInfo2 = new DevNullClusterInfo ( usages , usages , shardSizes ) ; cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo2 ; } @Override public void addListener ( Listener listener ) { } } ; strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( nodeWithPrimary ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( nodeWithoutPrimary ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; } public void testDiskThresholdWithShardSizes ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <float> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; } public void testUnknownDiskUsage ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <float> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <float> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; } public void testAverageUsage ( ) { RoutingNode rn = new RoutingNode ( <str> , newNode ( <str> ) ) ; DiskThresholdDecider decider = new DiskThresholdDecider ( Settings . EMPTY ) ; ImmutableOpenMap . Builder < String , DiskUsage > usages = ImmutableOpenMap . builder ( ) ; usages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; DiskUsage node1Usage = decider . averageUsage ( rn , usages . build ( ) ) ; assertThat ( node1Usage . getTotalBytes ( ) , equalTo ( <int> ) ) ; assertThat ( node1Usage . getFreeBytes ( ) , equalTo ( <int> ) ) ; } public void testFreeDiskPercentageAfterShardAssigned ( ) { RoutingNode rn = new RoutingNode ( <str> , newNode ( <str> ) ) ; DiskThresholdDecider decider = new DiskThresholdDecider ( Settings . EMPTY ) ; Map < String , DiskUsage > usages = new HashMap < > ( ) ; usages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; Double after = decider . freeDiskPercentageAfterShardAssigned ( new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) , <int> ) ; assertThat ( after , equalTo ( <float> ) ) ; } public void testShardRelocationsTakenIntoAccount ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <float> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <float> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , new DiskThresholdDecider ( diskSettings ) ) ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; AllocationCommand relocate1 = new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , <str> , <str> ) ; AllocationCommands cmds = new AllocationCommands ( relocate1 ) ; routingTable = strategy . reroute ( clusterState , cmds ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logShardStates ( clusterState ) ; AllocationCommand relocate2 = new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , <str> , <str> ) ; cmds = new AllocationCommands ( relocate2 ) ; try { strategy . reroute ( clusterState , cmds ) . routingTable ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } public void testCanRemainWithShardRelocatingAway ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizesBuilder = ImmutableOpenMap . builder ( ) ; shardSizesBuilder . put ( <str> , <int> ) ; shardSizesBuilder . put ( <str> , <int> ) ; ImmutableOpenMap < String , Long > shardSizes = shardSizesBuilder . build ( ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes ) ; DiskThresholdDecider diskThresholdDecider = new DiskThresholdDecider ( diskSettings ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; DiscoveryNode discoveryNode1 = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . CURRENT ) ; DiscoveryNode discoveryNode2 = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . CURRENT ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( ) . put ( discoveryNode1 ) . put ( discoveryNode2 ) . build ( ) ; ClusterState baseClusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( discoveryNodes ) . build ( ) ; ShardRouting firstRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; ShardRouting secondRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; RoutingNode firstRoutingNode = new RoutingNode ( <str> , discoveryNode1 , Arrays . asList ( firstRouting , secondRouting ) ) ; RoutingTable . Builder builder = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( <str> ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( firstRouting ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( secondRouting ) . build ( ) ) ) ; ClusterState clusterState = ClusterState . builder ( baseClusterState ) . routingTable ( builder . build ( ) ) . build ( ) ; RoutingAllocation routingAllocation = new RoutingAllocation ( null , new RoutingNodes ( clusterState ) , discoveryNodes , clusterInfo , System . nanoTime ( ) ) ; Decision decision = diskThresholdDecider . canRemain ( firstRouting , firstRoutingNode , routingAllocation ) ; assertThat ( decision . type ( ) , equalTo ( Decision . Type . NO ) ) ; firstRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; secondRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , <str> , null , true , ShardRoutingState . RELOCATING , <int> ) ; firstRoutingNode = new RoutingNode ( <str> , discoveryNode1 , Arrays . asList ( firstRouting , secondRouting ) ) ; builder = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( <str> ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( firstRouting ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( secondRouting ) . build ( ) ) ) ; clusterState = ClusterState . builder ( baseClusterState ) . routingTable ( builder . build ( ) ) . build ( ) ; routingAllocation = new RoutingAllocation ( null , new RoutingNodes ( clusterState ) , discoveryNodes , clusterInfo , System . nanoTime ( ) ) ; decision = diskThresholdDecider . canRemain ( firstRouting , firstRoutingNode , routingAllocation ) ; assertThat ( decision . type ( ) , equalTo ( Decision . Type . YES ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , diskThresholdDecider ) ) ) ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; RoutingAllocation . Result result = strategy . reroute ( clusterState , <str> ) ; assertThat ( result . changed ( ) , is ( false ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , nullValue ( ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( RELOCATING ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , equalTo ( <str> ) ) ; } public void testForSingleDataNode ( ) { Settings diskSettings = settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , true ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > usagesBuilder = ImmutableOpenMap . builder ( ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; usagesBuilder . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap < String , DiskUsage > usages = usagesBuilder . build ( ) ; ImmutableOpenMap . Builder < String , Long > shardSizes = ImmutableOpenMap . builder ( ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; final ClusterInfo clusterInfo = new DevNullClusterInfo ( usages , usages , shardSizes . build ( ) ) ; DiskThresholdDecider diskThresholdDecider = new DiskThresholdDecider ( diskSettings ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; logger . info ( <str> ) ; Map < String , String > masterNodeAttributes = new HashMap < > ( ) ; masterNodeAttributes . put ( <str> , <str> ) ; masterNodeAttributes . put ( <str> , <str> ) ; Map < String , String > dataNodeAttributes = new HashMap < > ( ) ; dataNodeAttributes . put ( <str> , <str> ) ; dataNodeAttributes . put ( <str> , <str> ) ; DiscoveryNode discoveryNode1 = new DiscoveryNode ( <str> , <str> , new LocalTransportAddress ( <str> ) , masterNodeAttributes , Version . CURRENT ) ; DiscoveryNode discoveryNode2 = new DiscoveryNode ( <str> , <str> , new LocalTransportAddress ( <str> ) , dataNodeAttributes , Version . CURRENT ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( ) . put ( discoveryNode1 ) . put ( discoveryNode2 ) . build ( ) ; ClusterState baseClusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( discoveryNodes ) . build ( ) ; ShardRouting firstRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; ShardRouting secondRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; RoutingNode firstRoutingNode = new RoutingNode ( <str> , discoveryNode2 , Arrays . asList ( firstRouting , secondRouting ) ) ; RoutingTable . Builder builder = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( <str> ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( firstRouting ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( secondRouting ) . build ( ) ) ) ; ClusterState clusterState = ClusterState . builder ( baseClusterState ) . routingTable ( builder . build ( ) ) . build ( ) ; RoutingAllocation routingAllocation = new RoutingAllocation ( null , new RoutingNodes ( clusterState ) , discoveryNodes , clusterInfo , System . nanoTime ( ) ) ; Decision decision = diskThresholdDecider . canRemain ( firstRouting , firstRoutingNode , routingAllocation ) ; assertThat ( decision . type ( ) , equalTo ( Decision . Type . YES ) ) ; ClusterInfoService cis = new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { logger . info ( <str> ) ; return clusterInfo ; } @Override public void addListener ( Listener listener ) { } } ; AllocationDeciders deciders = new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , diskThresholdDecider ) ) ) ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) , deciders , makeShardsAllocators ( ) , cis ) ; RoutingAllocation . Result result = strategy . reroute ( clusterState , <str> ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , nullValue ( ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , nullValue ( ) ) ; logger . info ( <str> ) ; DiscoveryNode discoveryNode3 = new DiscoveryNode ( <str> , <str> , new LocalTransportAddress ( <str> ) , dataNodeAttributes , Version . CURRENT ) ; ClusterState updateClusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( discoveryNode3 ) ) . build ( ) ; firstRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , true , ShardRoutingState . STARTED , <int> ) ; secondRouting = TestShardRouting . newShardRouting ( <str> , <int> , <str> , <str> , null , true , ShardRoutingState . RELOCATING , <int> ) ; firstRoutingNode = new RoutingNode ( <str> , discoveryNode2 , Arrays . asList ( firstRouting , secondRouting ) ) ; builder = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( <str> ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( firstRouting ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , <int> ) ) . addShard ( secondRouting ) . build ( ) ) ) ; clusterState = ClusterState . builder ( updateClusterState ) . routingTable ( builder . build ( ) ) . build ( ) ; routingAllocation = new RoutingAllocation ( null , new RoutingNodes ( clusterState ) , discoveryNodes , clusterInfo , System . nanoTime ( ) ) ; decision = diskThresholdDecider . canRemain ( firstRouting , firstRoutingNode , routingAllocation ) ; assertThat ( decision . type ( ) , equalTo ( Decision . Type . YES ) ) ; result = strategy . reroute ( clusterState , <str> ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , nullValue ( ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( RELOCATING ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( result . routingTable ( ) . index ( <str> ) . getShards ( ) . get ( <int> ) . primaryShard ( ) . relocatingNodeId ( ) , equalTo ( <str> ) ) ; } public void logShardStates ( ClusterState state ) { RoutingNodes rn = state . getRoutingNodes ( ) ; logger . info ( <str> , rn . shards ( shard - > true ) . size ( ) , rn . shardsWithState ( UNASSIGNED ) . size ( ) , rn . shardsWithState ( INITIALIZING ) . size ( ) , rn . shardsWithState ( RELOCATING ) . size ( ) , rn . shardsWithState ( STARTED ) . size ( ) ) ; logger . info ( <str> , rn . shardsWithState ( UNASSIGNED ) , rn . shardsWithState ( INITIALIZING ) , rn . shardsWithState ( RELOCATING ) , rn . shardsWithState ( STARTED ) ) ; } } 
