package org . elasticsearch . threadpool ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . Version ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . test . ESTestCase ; import org . junit . Before ; import java . io . IOException ; import java . util . Map ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . Matchers . hasKey ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . nullValue ; public class ThreadPoolSerializationTests extends ESTestCase { BytesStreamOutput output = new BytesStreamOutput ( ) ; private ThreadPool . ThreadPoolType threadPoolType ; @Before public void setUp ( ) throws Exception { super . setUp ( ) ; threadPoolType = randomFrom ( ThreadPool . ThreadPoolType . values ( ) ) ; } public void testThatQueueSizeSerializationWorks ( ) throws Exception { ThreadPool . Info info = new ThreadPool . Info ( <str> , threadPoolType , <int> , <int> , TimeValue . timeValueMillis ( <int> ) , SizeValue . parseSizeValue ( <str> ) ) ; output . setVersion ( Version . CURRENT ) ; info . writeTo ( output ) ; StreamInput input = StreamInput . wrap ( output . bytes ( ) ) ; ThreadPool . Info newInfo = new ThreadPool . Info ( ) ; newInfo . readFrom ( input ) ; assertThat ( newInfo . getQueueSize ( ) . singles ( ) , is ( <int> ) ) ; } public void testThatNegativeQueueSizesCanBeSerialized ( ) throws Exception { ThreadPool . Info info = new ThreadPool . Info ( <str> , threadPoolType , <int> , <int> , TimeValue . timeValueMillis ( <int> ) , null ) ; output . setVersion ( Version . CURRENT ) ; info . writeTo ( output ) ; StreamInput input = StreamInput . wrap ( output . bytes ( ) ) ; ThreadPool . Info newInfo = new ThreadPool . Info ( ) ; newInfo . readFrom ( input ) ; assertThat ( newInfo . getQueueSize ( ) , is ( nullValue ( ) ) ) ; } public void testThatToXContentWritesOutUnboundedCorrectly ( ) throws Exception { ThreadPool . Info info = new ThreadPool . Info ( <str> , threadPoolType , <int> , <int> , TimeValue . timeValueMillis ( <int> ) , null ) ; XContentBuilder builder = jsonBuilder ( ) ; builder . startObject ( ) ; info . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . endObject ( ) ; BytesReference bytesReference = builder . bytes ( ) ; Map < String , Object > map ; try ( XContentParser parser = XContentFactory . xContent ( bytesReference ) . createParser ( bytesReference ) ) { map = parser . map ( ) ; } assertThat ( map , hasKey ( <str> ) ) ; map = ( Map < String , Object > ) map . get ( <str> ) ; assertThat ( map , hasKey ( <str> ) ) ; assertThat ( map . get ( <str> ) . toString ( ) , is ( <str> ) ) ; } public void testThatNegativeSettingAllowsToStart ( ) throws InterruptedException { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <str> ) . build ( ) ; ThreadPool threadPool = new ThreadPool ( settings ) ; assertThat ( threadPool . info ( <str> ) . getQueueSize ( ) , is ( nullValue ( ) ) ) ; terminate ( threadPool ) ; } public void testThatToXContentWritesInteger ( ) throws Exception { ThreadPool . Info info = new ThreadPool . Info ( <str> , threadPoolType , <int> , <int> , TimeValue . timeValueMillis ( <int> ) , SizeValue . parseSizeValue ( <str> ) ) ; XContentBuilder builder = jsonBuilder ( ) ; builder . startObject ( ) ; info . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . endObject ( ) ; BytesReference bytesReference = builder . bytes ( ) ; Map < String , Object > map ; try ( XContentParser parser = XContentFactory . xContent ( bytesReference ) . createParser ( bytesReference ) ) { map = parser . map ( ) ; } assertThat ( map , hasKey ( <str> ) ) ; map = ( Map < String , Object > ) map . get ( <str> ) ; assertThat ( map , hasKey ( <str> ) ) ; assertThat ( map . get ( <str> ) . toString ( ) , is ( <str> ) ) ; } public void testThatThreadPoolTypeIsSerializedCorrectly ( ) throws IOException { ThreadPool . Info info = new ThreadPool . Info ( <str> , threadPoolType ) ; output . setVersion ( Version . CURRENT ) ; info . writeTo ( output ) ; StreamInput input = StreamInput . wrap ( output . bytes ( ) ) ; ThreadPool . Info newInfo = new ThreadPool . Info ( ) ; newInfo . readFrom ( input ) ; assertThat ( newInfo . getThreadPoolType ( ) , is ( threadPoolType ) ) ; } } 
