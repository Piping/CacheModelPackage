package com . google . common . io ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . math . IntMath . divide ; import static com . google . common . math . IntMath . log2 ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . UNNECESSARY ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Ascii ; import com . google . common . base . CharMatcher ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . util . Arrays ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta @GwtCompatible ( emulated = true ) public abstract class BaseEncoding { BaseEncoding ( ) { } public static final class DecodingException extends IOException { DecodingException ( String message ) { super ( message ) ; } DecodingException ( Throwable cause ) { super ( cause ) ; } } @CheckReturnValue public String encode ( byte [ ] bytes ) { return encode ( bytes , <int> , bytes . length ) ; } @CheckReturnValue public final String encode ( byte [ ] bytes , int off , int len ) { checkPositionIndexes ( off , off + len , bytes . length ) ; StringBuilder result = new StringBuilder ( maxEncodedSize ( len ) ) ; try { encodeTo ( result , bytes , off , len ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return result . toString ( ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public abstract OutputStream encodingStream ( Writer writer ) ; @GwtIncompatible ( <str> ) @CheckReturnValue public final ByteSink encodingSink ( final CharSink encodedSink ) { checkNotNull ( encodedSink ) ; return new ByteSink ( ) { @Override public OutputStream openStream ( ) throws IOException { return encodingStream ( encodedSink . openStream ( ) ) ; } } ; } private static byte [ ] extract ( byte [ ] result , int length ) { if ( length = = result . length ) { return result ; } else { byte [ ] trunc = new byte [ length ] ; System . arraycopy ( result , <int> , trunc , <int> , length ) ; return trunc ; } } public final byte [ ] decode ( CharSequence chars ) { try { return decodeChecked ( chars ) ; } catch ( DecodingException badInput ) { throw new IllegalArgumentException ( badInput ) ; } } final byte [ ] decodeChecked ( CharSequence chars ) throws DecodingException { chars = padding ( ) . trimTrailingFrom ( chars ) ; byte [ ] tmp = new byte [ maxDecodedSize ( chars . length ( ) ) ] ; int len = decodeTo ( tmp , chars ) ; return extract ( tmp , len ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public abstract InputStream decodingStream ( Reader reader ) ; @GwtIncompatible ( <str> ) @CheckReturnValue public final ByteSource decodingSource ( final CharSource encodedSource ) { checkNotNull ( encodedSource ) ; return new ByteSource ( ) { @Override public InputStream openStream ( ) throws IOException { return decodingStream ( encodedSource . openStream ( ) ) ; } } ; } abstract int maxEncodedSize ( int bytes ) ; abstract void encodeTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException ; abstract int maxDecodedSize ( int chars ) ; abstract int decodeTo ( byte [ ] target , CharSequence chars ) throws DecodingException ; abstract CharMatcher padding ( ) ; @CheckReturnValue public abstract BaseEncoding omitPadding ( ) ; @CheckReturnValue public abstract BaseEncoding withPadChar ( char padChar ) ; @CheckReturnValue public abstract BaseEncoding withSeparator ( String separator , int n ) ; @CheckReturnValue public abstract BaseEncoding upperCase ( ) ; @CheckReturnValue public abstract BaseEncoding lowerCase ( ) ; private static final BaseEncoding BASE64 = new Base64Encoding ( <str> , <str> , <str> ) ; @CheckReturnValue public static BaseEncoding base64 ( ) { return BASE64 ; } private static final BaseEncoding BASE64_URL = new Base64Encoding ( <str> , <str> , <str> ) ; @CheckReturnValue public static BaseEncoding base64Url ( ) { return BASE64_URL ; } private static final BaseEncoding BASE32 = new StandardBaseEncoding ( <str> , <str> , <str> ) ; @CheckReturnValue public static BaseEncoding base32 ( ) { return BASE32 ; } private static final BaseEncoding BASE32_HEX = new StandardBaseEncoding ( <str> , <str> , <str> ) ; @CheckReturnValue public static BaseEncoding base32Hex ( ) { return BASE32_HEX ; } private static final BaseEncoding BASE16 = new Base16Encoding ( <str> , <str> ) ; @CheckReturnValue public static BaseEncoding base16 ( ) { return BASE16 ; } private static final class Alphabet extends CharMatcher { private final String name ; private final char [ ] chars ; final int mask ; final int bitsPerChar ; final int charsPerChunk ; final int bytesPerChunk ; private final byte [ ] decodabet ; private final boolean [ ] validPadding ; Alphabet ( String name , char [ ] chars ) { this . name = checkNotNull ( name ) ; this . chars = checkNotNull ( chars ) ; try { this . bitsPerChar = log2 ( chars . length , UNNECESSARY ) ; } catch ( ArithmeticException e ) { throw new IllegalArgumentException ( <str> + chars . length , e ) ; } int gcd = Math . min ( <int> , Integer . lowestOneBit ( bitsPerChar ) ) ; this . charsPerChunk = <int> / gcd ; this . bytesPerChunk = bitsPerChar / gcd ; this . mask = chars . length - <int> ; byte [ ] decodabet = new byte [ Ascii . MAX + <int> ] ; Arrays . fill ( decodabet , ( byte ) - <int> ) ; for ( int i = <int> ; i < chars . length ; i + + ) { char c = chars [ i ] ; checkArgument ( CharMatcher . ASCII . matches ( c ) , <str> , c ) ; checkArgument ( decodabet [ c ] = = - <int> , <str> , c ) ; decodabet [ c ] = ( byte ) i ; } this . decodabet = decodabet ; boolean [ ] validPadding = new boolean [ charsPerChunk ] ; for ( int i = <int> ; i < bytesPerChunk ; i + + ) { validPadding [ divide ( i * <int> , bitsPerChar , CEILING ) ] = true ; } this . validPadding = validPadding ; } char encode ( int bits ) { return chars [ bits ] ; } boolean isValidPaddingStartPosition ( int index ) { return validPadding [ index % charsPerChunk ] ; } int decode ( char ch ) throws DecodingException { if ( ch > Ascii . MAX | | decodabet [ ch ] = = - <int> ) { throw new DecodingException ( <str> + ( CharMatcher . INVISIBLE . matches ( ch ) ? <str> + Integer . toHexString ( ch ) : ch ) ) ; } return decodabet [ ch ] ; } private boolean hasLowerCase ( ) { for ( char c : chars ) { if ( Ascii . isLowerCase ( c ) ) { return true ; } } return false ; } private boolean hasUpperCase ( ) { for ( char c : chars ) { if ( Ascii . isUpperCase ( c ) ) { return true ; } } return false ; } Alphabet upperCase ( ) { if ( ! hasLowerCase ( ) ) { return this ; } else { checkState ( ! hasUpperCase ( ) , <str> ) ; char [ ] upperCased = new char [ chars . length ] ; for ( int i = <int> ; i < chars . length ; i + + ) { upperCased [ i ] = Ascii . toUpperCase ( chars [ i ] ) ; } return new Alphabet ( name + <str> , upperCased ) ; } } Alphabet lowerCase ( ) { if ( ! hasUpperCase ( ) ) { return this ; } else { checkState ( ! hasLowerCase ( ) , <str> ) ; char [ ] lowerCased = new char [ chars . length ] ; for ( int i = <int> ; i < chars . length ; i + + ) { lowerCased [ i ] = Ascii . toLowerCase ( chars [ i ] ) ; } return new Alphabet ( name + <str> , lowerCased ) ; } } @Override public boolean matches ( char c ) { return CharMatcher . ASCII . matches ( c ) & & decodabet [ c ] ! = - <int> ; } @Override public String toString ( ) { return name ; } } static class StandardBaseEncoding extends BaseEncoding { final Alphabet alphabet ; @Nullable final Character paddingChar ; StandardBaseEncoding ( String name , String alphabetChars , @Nullable Character paddingChar ) { this ( new Alphabet ( name , alphabetChars . toCharArray ( ) ) , paddingChar ) ; } StandardBaseEncoding ( Alphabet alphabet , @Nullable Character paddingChar ) { this . alphabet = checkNotNull ( alphabet ) ; checkArgument ( paddingChar = = null | | ! alphabet . matches ( paddingChar ) , <str> , paddingChar ) ; this . paddingChar = paddingChar ; } @Override CharMatcher padding ( ) { return ( paddingChar = = null ) ? CharMatcher . NONE : CharMatcher . is ( paddingChar . charValue ( ) ) ; } @Override int maxEncodedSize ( int bytes ) { return alphabet . charsPerChunk * divide ( bytes , alphabet . bytesPerChunk , CEILING ) ; } @GwtIncompatible ( <str> ) @Override public OutputStream encodingStream ( final Writer out ) { checkNotNull ( out ) ; return new OutputStream ( ) { int bitBuffer = <int> ; int bitBufferLength = <int> ; int writtenChars = <int> ; @Override public void write ( int b ) throws IOException { bitBuffer < < = <int> ; bitBuffer | = b & <hex> ; bitBufferLength + = <int> ; while ( bitBufferLength > = alphabet . bitsPerChar ) { int charIndex = ( bitBuffer > > ( bitBufferLength - alphabet . bitsPerChar ) ) & alphabet . mask ; out . write ( alphabet . encode ( charIndex ) ) ; writtenChars + + ; bitBufferLength - = alphabet . bitsPerChar ; } } @Override public void flush ( ) throws IOException { out . flush ( ) ; } @Override public void close ( ) throws IOException { if ( bitBufferLength > <int> ) { int charIndex = ( bitBuffer < < ( alphabet . bitsPerChar - bitBufferLength ) ) & alphabet . mask ; out . write ( alphabet . encode ( charIndex ) ) ; writtenChars + + ; if ( paddingChar ! = null ) { while ( writtenChars % alphabet . charsPerChunk ! = <int> ) { out . write ( paddingChar . charValue ( ) ) ; writtenChars + + ; } } } out . close ( ) ; } } ; } @Override void encodeTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException { checkNotNull ( target ) ; checkPositionIndexes ( off , off + len , bytes . length ) ; for ( int i = <int> ; i < len ; i + = alphabet . bytesPerChunk ) { encodeChunkTo ( target , bytes , off + i , Math . min ( alphabet . bytesPerChunk , len - i ) ) ; } } void encodeChunkTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException { checkNotNull ( target ) ; checkPositionIndexes ( off , off + len , bytes . length ) ; checkArgument ( len < = alphabet . bytesPerChunk ) ; long bitBuffer = <int> ; for ( int i = <int> ; i < len ; + + i ) { bitBuffer | = bytes [ off + i ] & <hex> ; bitBuffer < < = <int> ; } final int bitOffset = ( len + <int> ) * <int> - alphabet . bitsPerChar ; int bitsProcessed = <int> ; while ( bitsProcessed < len * <int> ) { int charIndex = ( int ) ( bitBuffer > > > ( bitOffset - bitsProcessed ) ) & alphabet . mask ; target . append ( alphabet . encode ( charIndex ) ) ; bitsProcessed + = alphabet . bitsPerChar ; } if ( paddingChar ! = null ) { while ( bitsProcessed < alphabet . bytesPerChunk * <int> ) { target . append ( paddingChar . charValue ( ) ) ; bitsProcessed + = alphabet . bitsPerChar ; } } } @Override int maxDecodedSize ( int chars ) { return ( int ) ( ( alphabet . bitsPerChar * ( long ) chars + <int> ) / <int> ) ; } @Override int decodeTo ( byte [ ] target , CharSequence chars ) throws DecodingException { checkNotNull ( target ) ; chars = padding ( ) . trimTrailingFrom ( chars ) ; if ( ! alphabet . isValidPaddingStartPosition ( chars . length ( ) ) ) { throw new DecodingException ( <str> + chars . length ( ) ) ; } int bytesWritten = <int> ; for ( int charIdx = <int> ; charIdx < chars . length ( ) ; charIdx + = alphabet . charsPerChunk ) { long chunk = <int> ; int charsProcessed = <int> ; for ( int i = <int> ; i < alphabet . charsPerChunk ; i + + ) { chunk < < = alphabet . bitsPerChar ; if ( charIdx + i < chars . length ( ) ) { chunk | = alphabet . decode ( chars . charAt ( charIdx + charsProcessed + + ) ) ; } } final int minOffset = alphabet . bytesPerChunk * <int> - charsProcessed * alphabet . bitsPerChar ; for ( int offset = ( alphabet . bytesPerChunk - <int> ) * <int> ; offset > = minOffset ; offset - = <int> ) { target [ bytesWritten + + ] = ( byte ) ( ( chunk > > > offset ) & <hex> ) ; } } return bytesWritten ; } @GwtIncompatible ( <str> ) @Override public InputStream decodingStream ( final Reader reader ) { checkNotNull ( reader ) ; return new InputStream ( ) { int bitBuffer = <int> ; int bitBufferLength = <int> ; int readChars = <int> ; boolean hitPadding = false ; final CharMatcher paddingMatcher = padding ( ) ; @Override public int read ( ) throws IOException { while ( true ) { int readChar = reader . read ( ) ; if ( readChar = = - <int> ) { if ( ! hitPadding & & ! alphabet . isValidPaddingStartPosition ( readChars ) ) { throw new DecodingException ( <str> + readChars ) ; } return - <int> ; } readChars + + ; char ch = ( char ) readChar ; if ( paddingMatcher . matches ( ch ) ) { if ( ! hitPadding & & ( readChars = = <int> | | ! alphabet . isValidPaddingStartPosition ( readChars - <int> ) ) ) { throw new DecodingException ( <str> + readChars ) ; } hitPadding = true ; } else if ( hitPadding ) { throw new DecodingException ( <str> + ch + <str> + readChars ) ; } else { bitBuffer < < = alphabet . bitsPerChar ; bitBuffer | = alphabet . decode ( ch ) ; bitBufferLength + = alphabet . bitsPerChar ; if ( bitBufferLength > = <int> ) { bitBufferLength - = <int> ; return ( bitBuffer > > bitBufferLength ) & <hex> ; } } } } @Override public void close ( ) throws IOException { reader . close ( ) ; } } ; } @Override public BaseEncoding omitPadding ( ) { return ( paddingChar = = null ) ? this : newInstance ( alphabet , null ) ; } @Override public BaseEncoding withPadChar ( char padChar ) { if ( <int> % alphabet . bitsPerChar = = <int> | | ( paddingChar ! = null & & paddingChar . charValue ( ) = = padChar ) ) { return this ; } else { return newInstance ( alphabet , padChar ) ; } } @Override public BaseEncoding withSeparator ( String separator , int afterEveryChars ) { checkArgument ( padding ( ) . or ( alphabet ) . matchesNoneOf ( separator ) , <str> , separator ) ; return new SeparatedBaseEncoding ( this , separator , afterEveryChars ) ; } private transient BaseEncoding upperCase ; private transient BaseEncoding lowerCase ; @Override public BaseEncoding upperCase ( ) { BaseEncoding result = upperCase ; if ( result = = null ) { Alphabet upper = alphabet . upperCase ( ) ; result = upperCase = ( upper = = alphabet ) ? this : newInstance ( upper , paddingChar ) ; } return result ; } @Override public BaseEncoding lowerCase ( ) { BaseEncoding result = lowerCase ; if ( result = = null ) { Alphabet lower = alphabet . lowerCase ( ) ; result = lowerCase = ( lower = = alphabet ) ? this : newInstance ( lower , paddingChar ) ; } return result ; } BaseEncoding newInstance ( Alphabet alphabet , @Nullable Character paddingChar ) { return new StandardBaseEncoding ( alphabet , paddingChar ) ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( <str> ) ; builder . append ( alphabet . toString ( ) ) ; if ( <int> % alphabet . bitsPerChar ! = <int> ) { if ( paddingChar = = null ) { builder . append ( <str> ) ; } else { builder . append ( <str> ) . append ( paddingChar ) . append ( <str> ) ; } } return builder . toString ( ) ; } } static final class Base16Encoding extends StandardBaseEncoding { final char [ ] encoding = new char [ <int> ] ; Base16Encoding ( String name , String alphabetChars ) { this ( new Alphabet ( name , alphabetChars . toCharArray ( ) ) ) ; } private Base16Encoding ( Alphabet alphabet ) { super ( alphabet , null ) ; checkArgument ( alphabet . chars . length = = <int> ) ; for ( int i = <int> ; i < <int> ; + + i ) { encoding [ i ] = alphabet . encode ( i > > > <int> ) ; encoding [ i | <hex> ] = alphabet . encode ( i & <hex> ) ; } } @Override void encodeTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException { checkNotNull ( target ) ; checkPositionIndexes ( off , off + len , bytes . length ) ; for ( int i = <int> ; i < len ; + + i ) { int b = bytes [ off + i ] & <hex> ; target . append ( encoding [ b ] ) ; target . append ( encoding [ b | <hex> ] ) ; } } @Override int decodeTo ( byte [ ] target , CharSequence chars ) throws DecodingException { checkNotNull ( target ) ; if ( chars . length ( ) % <int> = = <int> ) { throw new DecodingException ( <str> + chars . length ( ) ) ; } int bytesWritten = <int> ; for ( int i = <int> ; i < chars . length ( ) ; i + = <int> ) { int decoded = alphabet . decode ( chars . charAt ( i ) ) < < <int> | alphabet . decode ( chars . charAt ( i + <int> ) ) ; target [ bytesWritten + + ] = ( byte ) decoded ; } return bytesWritten ; } @Override BaseEncoding newInstance ( Alphabet alphabet , @Nullable Character paddingChar ) { return new Base16Encoding ( alphabet ) ; } } static final class Base64Encoding extends StandardBaseEncoding { Base64Encoding ( String name , String alphabetChars , @Nullable Character paddingChar ) { this ( new Alphabet ( name , alphabetChars . toCharArray ( ) ) , paddingChar ) ; } private Base64Encoding ( Alphabet alphabet , @Nullable Character paddingChar ) { super ( alphabet , paddingChar ) ; checkArgument ( alphabet . chars . length = = <int> ) ; } @Override void encodeTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException { checkNotNull ( target ) ; checkPositionIndexes ( off , off + len , bytes . length ) ; int i = off ; for ( int remaining = len ; remaining > = <int> ; remaining - = <int> ) { int chunk = ( bytes [ i + + ] & <hex> ) < < <int> | ( bytes [ i + + ] & <hex> ) < < <int> | bytes [ i + + ] & <hex> ; target . append ( alphabet . encode ( chunk > > > <int> ) ) ; target . append ( alphabet . encode ( ( chunk > > > <int> ) & <hex> ) ) ; target . append ( alphabet . encode ( ( chunk > > > <int> ) & <hex> ) ) ; target . append ( alphabet . encode ( chunk & <hex> ) ) ; } if ( i < off + len ) { encodeChunkTo ( target , bytes , i , off + len - i ) ; } } @Override int decodeTo ( byte [ ] target , CharSequence chars ) throws DecodingException { checkNotNull ( target ) ; chars = padding ( ) . trimTrailingFrom ( chars ) ; if ( ! alphabet . isValidPaddingStartPosition ( chars . length ( ) ) ) { throw new DecodingException ( <str> + chars . length ( ) ) ; } int bytesWritten = <int> ; for ( int i = <int> ; i < chars . length ( ) ; ) { int chunk = alphabet . decode ( chars . charAt ( i + + ) ) < < <int> ; chunk | = alphabet . decode ( chars . charAt ( i + + ) ) < < <int> ; target [ bytesWritten + + ] = ( byte ) ( chunk > > > <int> ) ; if ( i < chars . length ( ) ) { chunk | = alphabet . decode ( chars . charAt ( i + + ) ) < < <int> ; target [ bytesWritten + + ] = ( byte ) ( ( chunk > > > <int> ) & <hex> ) ; if ( i < chars . length ( ) ) { chunk | = alphabet . decode ( chars . charAt ( i + + ) ) ; target [ bytesWritten + + ] = ( byte ) ( chunk & <hex> ) ; } } } return bytesWritten ; } @Override BaseEncoding newInstance ( Alphabet alphabet , @Nullable Character paddingChar ) { return new Base64Encoding ( alphabet , paddingChar ) ; } } @GwtIncompatible ( <str> ) static Reader ignoringReader ( final Reader delegate , final CharMatcher toIgnore ) { checkNotNull ( delegate ) ; checkNotNull ( toIgnore ) ; return new Reader ( ) { @Override public int read ( ) throws IOException { int readChar ; do { readChar = delegate . read ( ) ; } while ( readChar ! = - <int> & & toIgnore . matches ( ( char ) readChar ) ) ; return readChar ; } @Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public void close ( ) throws IOException { delegate . close ( ) ; } } ; } static Appendable separatingAppendable ( final Appendable delegate , final String separator , final int afterEveryChars ) { checkNotNull ( delegate ) ; checkNotNull ( separator ) ; checkArgument ( afterEveryChars > <int> ) ; return new Appendable ( ) { int charsUntilSeparator = afterEveryChars ; @Override public Appendable append ( char c ) throws IOException { if ( charsUntilSeparator = = <int> ) { delegate . append ( separator ) ; charsUntilSeparator = afterEveryChars ; } delegate . append ( c ) ; charsUntilSeparator - - ; return this ; } @Override public Appendable append ( CharSequence chars , int off , int len ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public Appendable append ( CharSequence chars ) throws IOException { throw new UnsupportedOperationException ( ) ; } } ; } @GwtIncompatible ( <str> ) static Writer separatingWriter ( final Writer delegate , final String separator , final int afterEveryChars ) { final Appendable seperatingAppendable = separatingAppendable ( delegate , separator , afterEveryChars ) ; return new Writer ( ) { @Override public void write ( int c ) throws IOException { seperatingAppendable . append ( ( char ) c ) ; } @Override public void write ( char [ ] chars , int off , int len ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public void flush ( ) throws IOException { delegate . flush ( ) ; } @Override public void close ( ) throws IOException { delegate . close ( ) ; } } ; } static final class SeparatedBaseEncoding extends BaseEncoding { private final BaseEncoding delegate ; private final String separator ; private final int afterEveryChars ; private final CharMatcher separatorChars ; SeparatedBaseEncoding ( BaseEncoding delegate , String separator , int afterEveryChars ) { this . delegate = checkNotNull ( delegate ) ; this . separator = checkNotNull ( separator ) ; this . afterEveryChars = afterEveryChars ; checkArgument ( afterEveryChars > <int> , <str> , afterEveryChars ) ; this . separatorChars = CharMatcher . anyOf ( separator ) . precomputed ( ) ; } @Override CharMatcher padding ( ) { return delegate . padding ( ) ; } @Override int maxEncodedSize ( int bytes ) { int unseparatedSize = delegate . maxEncodedSize ( bytes ) ; return unseparatedSize + separator . length ( ) * divide ( Math . max ( <int> , unseparatedSize - <int> ) , afterEveryChars , FLOOR ) ; } @GwtIncompatible ( <str> ) @Override public OutputStream encodingStream ( final Writer output ) { return delegate . encodingStream ( separatingWriter ( output , separator , afterEveryChars ) ) ; } @Override void encodeTo ( Appendable target , byte [ ] bytes , int off , int len ) throws IOException { delegate . encodeTo ( separatingAppendable ( target , separator , afterEveryChars ) , bytes , off , len ) ; } @Override int maxDecodedSize ( int chars ) { return delegate . maxDecodedSize ( chars ) ; } @Override int decodeTo ( byte [ ] target , CharSequence chars ) throws DecodingException { return delegate . decodeTo ( target , separatorChars . removeFrom ( chars ) ) ; } @GwtIncompatible ( <str> ) @Override public InputStream decodingStream ( final Reader reader ) { return delegate . decodingStream ( ignoringReader ( reader , separatorChars ) ) ; } @Override public BaseEncoding omitPadding ( ) { return delegate . omitPadding ( ) . withSeparator ( separator , afterEveryChars ) ; } @Override public BaseEncoding withPadChar ( char padChar ) { return delegate . withPadChar ( padChar ) . withSeparator ( separator , afterEveryChars ) ; } @Override public BaseEncoding withSeparator ( String separator , int afterEveryChars ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public BaseEncoding upperCase ( ) { return delegate . upperCase ( ) . withSeparator ( separator , afterEveryChars ) ; } @Override public BaseEncoding lowerCase ( ) { return delegate . lowerCase ( ) . withSeparator ( separator , afterEveryChars ) ; } @Override public String toString ( ) { return delegate . toString ( ) + <str> + separator + <str> + afterEveryChars + <str> ; } } } 
