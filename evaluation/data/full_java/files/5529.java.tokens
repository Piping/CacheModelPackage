package org . elasticsearch . cluster ; import com . carrotsearch . hppc . cursors . IntCursor ; import com . carrotsearch . hppc . cursors . IntObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . common . collect . ImmutableOpenIntMap ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; public final class DiffableUtils { private DiffableUtils ( ) { } public static KeySerializer < String > getStringKeySerializer ( ) { return StringKeySerializer . INSTANCE ; } public static KeySerializer < Integer > getIntKeySerializer ( ) { return IntKeySerializer . INSTANCE ; } public static KeySerializer < Integer > getVIntKeySerializer ( ) { return VIntKeySerializer . INSTANCE ; } public static < K , T extends Diffable < T > > MapDiff < K , T , ImmutableOpenMap < K , T > > diff ( ImmutableOpenMap < K , T > before , ImmutableOpenMap < K , T > after , KeySerializer < K > keySerializer ) { assert after ! = null & & before ! = null ; return new ImmutableOpenMapDiff < > ( before , after , keySerializer , DiffableValueSerializer . getWriteOnlyInstance ( ) ) ; } public static < K , T > MapDiff < K , T , ImmutableOpenMap < K , T > > diff ( ImmutableOpenMap < K , T > before , ImmutableOpenMap < K , T > after , KeySerializer < K > keySerializer , NonDiffableValueSerializer < K , T > valueSerializer ) { assert after ! = null & & before ! = null ; return new ImmutableOpenMapDiff < > ( before , after , keySerializer , valueSerializer ) ; } public static < T extends Diffable < T > > MapDiff < Integer , T , ImmutableOpenIntMap < T > > diff ( ImmutableOpenIntMap < T > before , ImmutableOpenIntMap < T > after , KeySerializer < Integer > keySerializer ) { assert after ! = null & & before ! = null ; return new ImmutableOpenIntMapDiff < > ( before , after , keySerializer , DiffableValueSerializer . getWriteOnlyInstance ( ) ) ; } public static < T > MapDiff < Integer , T , ImmutableOpenIntMap < T > > diff ( ImmutableOpenIntMap < T > before , ImmutableOpenIntMap < T > after , KeySerializer < Integer > keySerializer , NonDiffableValueSerializer < Integer , T > valueSerializer ) { assert after ! = null & & before ! = null ; return new ImmutableOpenIntMapDiff < > ( before , after , keySerializer , valueSerializer ) ; } public static < K , T extends Diffable < T > > MapDiff < K , T , Map < K , T > > diff ( Map < K , T > before , Map < K , T > after , KeySerializer < K > keySerializer ) { assert after ! = null & & before ! = null ; return new JdkMapDiff < > ( before , after , keySerializer , DiffableValueSerializer . getWriteOnlyInstance ( ) ) ; } public static < K , T > MapDiff < K , T , Map < K , T > > diff ( Map < K , T > before , Map < K , T > after , KeySerializer < K > keySerializer , NonDiffableValueSerializer < K , T > valueSerializer ) { assert after ! = null & & before ! = null ; return new JdkMapDiff < > ( before , after , keySerializer , valueSerializer ) ; } public static < K , T > MapDiff < K , T , ImmutableOpenMap < K , T > > readImmutableOpenMapDiff ( StreamInput in , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) throws IOException { return new ImmutableOpenMapDiff < > ( in , keySerializer , valueSerializer ) ; } public static < T > MapDiff < Integer , T , ImmutableOpenIntMap < T > > readImmutableOpenIntMapDiff ( StreamInput in , KeySerializer < Integer > keySerializer , ValueSerializer < Integer , T > valueSerializer ) throws IOException { return new ImmutableOpenIntMapDiff < > ( in , keySerializer , valueSerializer ) ; } public static < K , T > MapDiff < K , T , Map < K , T > > readJdkMapDiff ( StreamInput in , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) throws IOException { return new JdkMapDiff < > ( in , keySerializer , valueSerializer ) ; } public static < K , T extends Diffable < T > > MapDiff < K , T , ImmutableOpenMap < K , T > > readImmutableOpenMapDiff ( StreamInput in , KeySerializer < K > keySerializer , T proto ) throws IOException { return new ImmutableOpenMapDiff < > ( in , keySerializer , new DiffablePrototypeValueReader < > ( proto ) ) ; } public static < T extends Diffable < T > > MapDiff < Integer , T , ImmutableOpenIntMap < T > > readImmutableOpenIntMapDiff ( StreamInput in , KeySerializer < Integer > keySerializer , T proto ) throws IOException { return new ImmutableOpenIntMapDiff < > ( in , keySerializer , new DiffablePrototypeValueReader < > ( proto ) ) ; } public static < K , T extends Diffable < T > > MapDiff < K , T , Map < K , T > > readJdkMapDiff ( StreamInput in , KeySerializer < K > keySerializer , T proto ) throws IOException { return new JdkMapDiff < > ( in , keySerializer , new DiffablePrototypeValueReader < > ( proto ) ) ; } private static class JdkMapDiff < K , T > extends MapDiff < K , T , Map < K , T > > { protected JdkMapDiff ( StreamInput in , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) throws IOException { super ( in , keySerializer , valueSerializer ) ; } public JdkMapDiff ( Map < K , T > before , Map < K , T > after , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) { super ( keySerializer , valueSerializer ) ; assert after ! = null & & before ! = null ; for ( K key : before . keySet ( ) ) { if ( ! after . containsKey ( key ) ) { deletes . add ( key ) ; } } for ( Map . Entry < K , T > partIter : after . entrySet ( ) ) { T beforePart = before . get ( partIter . getKey ( ) ) ; if ( beforePart = = null ) { upserts . put ( partIter . getKey ( ) , partIter . getValue ( ) ) ; } else if ( partIter . getValue ( ) . equals ( beforePart ) = = false ) { if ( valueSerializer . supportsDiffableValues ( ) ) { diffs . put ( partIter . getKey ( ) , valueSerializer . diff ( partIter . getValue ( ) , beforePart ) ) ; } else { upserts . put ( partIter . getKey ( ) , partIter . getValue ( ) ) ; } } } } @Override public Map < K , T > apply ( Map < K , T > map ) { Map < K , T > builder = new HashMap < > ( ) ; builder . putAll ( map ) ; for ( K part : deletes ) { builder . remove ( part ) ; } for ( Map . Entry < K , Diff < T > > diff : diffs . entrySet ( ) ) { builder . put ( diff . getKey ( ) , diff . getValue ( ) . apply ( builder . get ( diff . getKey ( ) ) ) ) ; } for ( Map . Entry < K , T > upsert : upserts . entrySet ( ) ) { builder . put ( upsert . getKey ( ) , upsert . getValue ( ) ) ; } return builder ; } } private static class ImmutableOpenMapDiff < K , T > extends MapDiff < K , T , ImmutableOpenMap < K , T > > { protected ImmutableOpenMapDiff ( StreamInput in , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) throws IOException { super ( in , keySerializer , valueSerializer ) ; } public ImmutableOpenMapDiff ( ImmutableOpenMap < K , T > before , ImmutableOpenMap < K , T > after , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) { super ( keySerializer , valueSerializer ) ; assert after ! = null & & before ! = null ; for ( ObjectCursor < K > key : before . keys ( ) ) { if ( ! after . containsKey ( key . value ) ) { deletes . add ( key . value ) ; } } for ( ObjectObjectCursor < K , T > partIter : after ) { T beforePart = before . get ( partIter . key ) ; if ( beforePart = = null ) { upserts . put ( partIter . key , partIter . value ) ; } else if ( partIter . value . equals ( beforePart ) = = false ) { if ( valueSerializer . supportsDiffableValues ( ) ) { diffs . put ( partIter . key , valueSerializer . diff ( partIter . value , beforePart ) ) ; } else { upserts . put ( partIter . key , partIter . value ) ; } } } } @Override public ImmutableOpenMap < K , T > apply ( ImmutableOpenMap < K , T > map ) { ImmutableOpenMap . Builder < K , T > builder = ImmutableOpenMap . builder ( ) ; builder . putAll ( map ) ; for ( K part : deletes ) { builder . remove ( part ) ; } for ( Map . Entry < K , Diff < T > > diff : diffs . entrySet ( ) ) { builder . put ( diff . getKey ( ) , diff . getValue ( ) . apply ( builder . get ( diff . getKey ( ) ) ) ) ; } for ( Map . Entry < K , T > upsert : upserts . entrySet ( ) ) { builder . put ( upsert . getKey ( ) , upsert . getValue ( ) ) ; } return builder . build ( ) ; } } private static class ImmutableOpenIntMapDiff < T > extends MapDiff < Integer , T , ImmutableOpenIntMap < T > > { protected ImmutableOpenIntMapDiff ( StreamInput in , KeySerializer < Integer > keySerializer , ValueSerializer < Integer , T > valueSerializer ) throws IOException { super ( in , keySerializer , valueSerializer ) ; } public ImmutableOpenIntMapDiff ( ImmutableOpenIntMap < T > before , ImmutableOpenIntMap < T > after , KeySerializer < Integer > keySerializer , ValueSerializer < Integer , T > valueSerializer ) { super ( keySerializer , valueSerializer ) ; assert after ! = null & & before ! = null ; for ( IntCursor key : before . keys ( ) ) { if ( ! after . containsKey ( key . value ) ) { deletes . add ( key . value ) ; } } for ( IntObjectCursor < T > partIter : after ) { T beforePart = before . get ( partIter . key ) ; if ( beforePart = = null ) { upserts . put ( partIter . key , partIter . value ) ; } else if ( partIter . value . equals ( beforePart ) = = false ) { if ( valueSerializer . supportsDiffableValues ( ) ) { diffs . put ( partIter . key , valueSerializer . diff ( partIter . value , beforePart ) ) ; } else { upserts . put ( partIter . key , partIter . value ) ; } } } } @Override public ImmutableOpenIntMap < T > apply ( ImmutableOpenIntMap < T > map ) { ImmutableOpenIntMap . Builder < T > builder = ImmutableOpenIntMap . builder ( ) ; builder . putAll ( map ) ; for ( Integer part : deletes ) { builder . remove ( part ) ; } for ( Map . Entry < Integer , Diff < T > > diff : diffs . entrySet ( ) ) { builder . put ( diff . getKey ( ) , diff . getValue ( ) . apply ( builder . get ( diff . getKey ( ) ) ) ) ; } for ( Map . Entry < Integer , T > upsert : upserts . entrySet ( ) ) { builder . put ( upsert . getKey ( ) , upsert . getValue ( ) ) ; } return builder . build ( ) ; } } public static abstract class MapDiff < K , T , M > implements Diff < M > { protected final List < K > deletes ; protected final Map < K , Diff < T > > diffs ; protected final Map < K , T > upserts ; protected final KeySerializer < K > keySerializer ; protected final ValueSerializer < K , T > valueSerializer ; protected MapDiff ( KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) { this . keySerializer = keySerializer ; this . valueSerializer = valueSerializer ; deletes = new ArrayList < > ( ) ; diffs = new HashMap < > ( ) ; upserts = new HashMap < > ( ) ; } protected MapDiff ( StreamInput in , KeySerializer < K > keySerializer , ValueSerializer < K , T > valueSerializer ) throws IOException { this . keySerializer = keySerializer ; this . valueSerializer = valueSerializer ; deletes = new ArrayList < > ( ) ; diffs = new HashMap < > ( ) ; upserts = new HashMap < > ( ) ; int deletesCount = in . readVInt ( ) ; for ( int i = <int> ; i < deletesCount ; i + + ) { deletes . add ( keySerializer . readKey ( in ) ) ; } int diffsCount = in . readVInt ( ) ; for ( int i = <int> ; i < diffsCount ; i + + ) { K key = keySerializer . readKey ( in ) ; Diff < T > diff = valueSerializer . readDiff ( in , key ) ; diffs . put ( key , diff ) ; } int upsertsCount = in . readVInt ( ) ; for ( int i = <int> ; i < upsertsCount ; i + + ) { K key = keySerializer . readKey ( in ) ; T newValue = valueSerializer . read ( in , key ) ; upserts . put ( key , newValue ) ; } } public List < K > getDeletes ( ) { return deletes ; } public Map < K , Diff < T > > getDiffs ( ) { return diffs ; } public Map < K , T > getUpserts ( ) { return upserts ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( deletes . size ( ) ) ; for ( K delete : deletes ) { keySerializer . writeKey ( delete , out ) ; } out . writeVInt ( diffs . size ( ) ) ; for ( Map . Entry < K , Diff < T > > entry : diffs . entrySet ( ) ) { keySerializer . writeKey ( entry . getKey ( ) , out ) ; valueSerializer . writeDiff ( entry . getValue ( ) , out ) ; } out . writeVInt ( upserts . size ( ) ) ; for ( Map . Entry < K , T > entry : upserts . entrySet ( ) ) { keySerializer . writeKey ( entry . getKey ( ) , out ) ; valueSerializer . write ( entry . getValue ( ) , out ) ; } } } public interface KeySerializer < K > { void writeKey ( K key , StreamOutput out ) throws IOException ; K readKey ( StreamInput in ) throws IOException ; } private static final class StringKeySerializer implements KeySerializer < String > { private static final StringKeySerializer INSTANCE = new StringKeySerializer ( ) ; @Override public void writeKey ( String key , StreamOutput out ) throws IOException { out . writeString ( key ) ; } @Override public String readKey ( StreamInput in ) throws IOException { return in . readString ( ) ; } } private static final class IntKeySerializer implements KeySerializer < Integer > { public static final IntKeySerializer INSTANCE = new IntKeySerializer ( ) ; @Override public void writeKey ( Integer key , StreamOutput out ) throws IOException { out . writeInt ( key ) ; } @Override public Integer readKey ( StreamInput in ) throws IOException { return in . readInt ( ) ; } } private static final class VIntKeySerializer implements KeySerializer < Integer > { public static final IntKeySerializer INSTANCE = new IntKeySerializer ( ) ; @Override public void writeKey ( Integer key , StreamOutput out ) throws IOException { if ( key < <int> ) { throw new IllegalArgumentException ( <str> + key + <str> ) ; } out . writeVInt ( key ) ; } @Override public Integer readKey ( StreamInput in ) throws IOException { return in . readVInt ( ) ; } } public interface ValueSerializer < K , V > { void write ( V value , StreamOutput out ) throws IOException ; V read ( StreamInput in , K key ) throws IOException ; boolean supportsDiffableValues ( ) ; Diff < V > diff ( V value , V beforePart ) ; void writeDiff ( Diff < V > value , StreamOutput out ) throws IOException ; Diff < V > readDiff ( StreamInput in , K key ) throws IOException ; } public static abstract class DiffableValueSerializer < K , V extends Diffable < V > > implements ValueSerializer < K , V > { private static final DiffableValueSerializer WRITE_ONLY_INSTANCE = new DiffableValueSerializer ( ) { @Override public Object read ( StreamInput in , Object key ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public Diff < Object > readDiff ( StreamInput in , Object key ) throws IOException { throw new UnsupportedOperationException ( ) ; } } ; private static < K , V extends Diffable < V > > DiffableValueSerializer < K , V > getWriteOnlyInstance ( ) { return WRITE_ONLY_INSTANCE ; } @Override public boolean supportsDiffableValues ( ) { return true ; } @Override public Diff < V > diff ( V value , V beforePart ) { return value . diff ( beforePart ) ; } @Override public void write ( V value , StreamOutput out ) throws IOException { value . writeTo ( out ) ; } public void writeDiff ( Diff < V > value , StreamOutput out ) throws IOException { value . writeTo ( out ) ; } } public static abstract class NonDiffableValueSerializer < K , V > implements ValueSerializer < K , V > { @Override public boolean supportsDiffableValues ( ) { return false ; } @Override public Diff < V > diff ( V value , V beforePart ) { throw new UnsupportedOperationException ( ) ; } @Override public void writeDiff ( Diff < V > value , StreamOutput out ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public Diff < V > readDiff ( StreamInput in , K key ) throws IOException { throw new UnsupportedOperationException ( ) ; } } public static class DiffablePrototypeValueReader < K , V extends Diffable < V > > extends DiffableValueSerializer < K , V > { private final V proto ; public DiffablePrototypeValueReader ( V proto ) { this . proto = proto ; } @Override public V read ( StreamInput in , K key ) throws IOException { return proto . readFrom ( in ) ; } @Override public Diff < V > readDiff ( StreamInput in , K key ) throws IOException { return proto . readDiffFrom ( in ) ; } } public static class StringSetValueSerializer < K > extends NonDiffableValueSerializer < K , Set < String > > { private static final StringSetValueSerializer INSTANCE = new StringSetValueSerializer ( ) ; public static < K > StringSetValueSerializer < K > getInstance ( ) { return INSTANCE ; } @Override public void write ( Set < String > value , StreamOutput out ) throws IOException { out . writeStringArray ( value . toArray ( new String [ value . size ( ) ] ) ) ; } @Override public Set < String > read ( StreamInput in , K key ) throws IOException { return Collections . unmodifiableSet ( new HashSet < > ( Arrays . asList ( in . readStringArray ( ) ) ) ) ; } } } 
