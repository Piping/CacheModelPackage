package org . elasticsearch . action . percolate ; import com . carrotsearch . hppc . IntArrayList ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . UnavailableShardsException ; import org . elasticsearch . action . get . * ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . action . support . broadcast . BroadcastShardOperationFailedException ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . AtomicArray ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . engine . DocumentMissingException ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . percolator . PercolatorService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReferenceArray ; public class TransportMultiPercolateAction extends HandledTransportAction < MultiPercolateRequest , MultiPercolateResponse > { private final ClusterService clusterService ; private final PercolatorService percolatorService ; private final TransportMultiGetAction multiGetAction ; private final TransportShardMultiPercolateAction shardMultiPercolateAction ; @Inject public TransportMultiPercolateAction ( Settings settings , ThreadPool threadPool , TransportShardMultiPercolateAction shardMultiPercolateAction , ClusterService clusterService , TransportService transportService , PercolatorService percolatorService , TransportMultiGetAction multiGetAction , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , MultiPercolateAction . NAME , threadPool , transportService , actionFilters , indexNameExpressionResolver , MultiPercolateRequest : : new ) ; this . shardMultiPercolateAction = shardMultiPercolateAction ; this . clusterService = clusterService ; this . percolatorService = percolatorService ; this . multiGetAction = multiGetAction ; } @Override protected void doExecute ( final MultiPercolateRequest request , final ActionListener < MultiPercolateResponse > listener ) { final ClusterState clusterState = clusterService . state ( ) ; clusterState . blocks ( ) . globalBlockedRaiseException ( ClusterBlockLevel . READ ) ; final List < Object > percolateRequests = new ArrayList < > ( request . requests ( ) . size ( ) ) ; final IntArrayList getRequestSlots = new IntArrayList ( ) ; List < GetRequest > existingDocsRequests = new ArrayList < > ( ) ; for ( int slot = <int> ; slot < request . requests ( ) . size ( ) ; slot + + ) { PercolateRequest percolateRequest = request . requests ( ) . get ( slot ) ; percolateRequest . startTime = System . currentTimeMillis ( ) ; percolateRequests . add ( percolateRequest ) ; if ( percolateRequest . getRequest ( ) ! = null ) { existingDocsRequests . add ( percolateRequest . getRequest ( ) ) ; getRequestSlots . add ( slot ) ; } } if ( ! existingDocsRequests . isEmpty ( ) ) { final MultiGetRequest multiGetRequest = new MultiGetRequest ( request ) ; for ( GetRequest getRequest : existingDocsRequests ) { multiGetRequest . add ( new MultiGetRequest . Item ( getRequest . index ( ) , getRequest . type ( ) , getRequest . id ( ) ) . routing ( getRequest . routing ( ) ) ) ; } multiGetAction . execute ( multiGetRequest , new ActionListener < MultiGetResponse > ( ) { @Override public void onResponse ( MultiGetResponse multiGetItemResponses ) { for ( int i = <int> ; i < multiGetItemResponses . getResponses ( ) . length ; i + + ) { MultiGetItemResponse itemResponse = multiGetItemResponses . getResponses ( ) [ i ] ; int slot = getRequestSlots . get ( i ) ; if ( ! itemResponse . isFailed ( ) ) { GetResponse getResponse = itemResponse . getResponse ( ) ; if ( getResponse . isExists ( ) ) { PercolateRequest originalRequest = ( PercolateRequest ) percolateRequests . get ( slot ) ; percolateRequests . set ( slot , new PercolateRequest ( originalRequest , getResponse . getSourceAsBytesRef ( ) ) ) ; } else { logger . trace ( <str> , slot ) ; percolateRequests . set ( slot , new DocumentMissingException ( null , getResponse . getType ( ) , getResponse . getId ( ) ) ) ; } } else { logger . trace ( <str> , slot , itemResponse . getFailure ( ) ) ; percolateRequests . set ( slot , itemResponse . getFailure ( ) ) ; } } new ASyncAction ( request , percolateRequests , listener , clusterState ) . run ( ) ; } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } ) ; } else { new ASyncAction ( request , percolateRequests , listener , clusterState ) . run ( ) ; } } private final class ASyncAction { final ActionListener < MultiPercolateResponse > finalListener ; final Map < ShardId , TransportShardMultiPercolateAction . Request > requestsByShard ; final MultiPercolateRequest multiPercolateRequest ; final List < Object > percolateRequests ; final Map < ShardId , IntArrayList > shardToSlots ; final AtomicInteger expectedOperations ; final AtomicArray < Object > reducedResponses ; final AtomicReferenceArray < AtomicInteger > expectedOperationsPerItem ; final AtomicReferenceArray < AtomicReferenceArray > responsesByItemAndShard ; ASyncAction ( MultiPercolateRequest multiPercolateRequest , List < Object > percolateRequests , ActionListener < MultiPercolateResponse > finalListener , ClusterState clusterState ) { this . finalListener = finalListener ; this . multiPercolateRequest = multiPercolateRequest ; this . percolateRequests = percolateRequests ; responsesByItemAndShard = new AtomicReferenceArray < > ( percolateRequests . size ( ) ) ; expectedOperationsPerItem = new AtomicReferenceArray < > ( percolateRequests . size ( ) ) ; reducedResponses = new AtomicArray < > ( percolateRequests . size ( ) ) ; requestsByShard = new HashMap < > ( ) ; shardToSlots = new HashMap < > ( ) ; int expectedResults = <int> ; for ( int slot = <int> ; slot < percolateRequests . size ( ) ; slot + + ) { Object element = percolateRequests . get ( slot ) ; assert element ! = null ; if ( element instanceof PercolateRequest ) { PercolateRequest percolateRequest = ( PercolateRequest ) element ; String [ ] concreteIndices ; try { concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , percolateRequest ) ; } catch ( IndexNotFoundException e ) { reducedResponses . set ( slot , e ) ; responsesByItemAndShard . set ( slot , new AtomicReferenceArray ( <int> ) ) ; expectedOperationsPerItem . set ( slot , new AtomicInteger ( <int> ) ) ; continue ; } Map < String , Set < String > > routing = indexNameExpressionResolver . resolveSearchRouting ( clusterState , percolateRequest . routing ( ) , percolateRequest . indices ( ) ) ; GroupShardsIterator shards = clusterService . operationRouting ( ) . searchShards ( clusterState , concreteIndices , routing , percolateRequest . preference ( ) ) ; if ( shards . size ( ) = = <int> ) { reducedResponses . set ( slot , new UnavailableShardsException ( null , <str> ) ) ; responsesByItemAndShard . set ( slot , new AtomicReferenceArray ( <int> ) ) ; expectedOperationsPerItem . set ( slot , new AtomicInteger ( <int> ) ) ; continue ; } int numShards = clusterService . operationRouting ( ) . searchShardsCount ( clusterState , concreteIndices , null ) ; responsesByItemAndShard . set ( slot , new AtomicReferenceArray ( numShards ) ) ; expectedOperationsPerItem . set ( slot , new AtomicInteger ( shards . size ( ) ) ) ; for ( ShardIterator shard : shards ) { ShardId shardId = shard . shardId ( ) ; TransportShardMultiPercolateAction . Request requests = requestsByShard . get ( shardId ) ; if ( requests = = null ) { requestsByShard . put ( shardId , requests = new TransportShardMultiPercolateAction . Request ( multiPercolateRequest , shardId . getIndex ( ) , shardId . getId ( ) , percolateRequest . preference ( ) ) ) ; } logger . trace ( <str> , shardId , slot ) ; requests . add ( new TransportShardMultiPercolateAction . Request . Item ( slot , new PercolateShardRequest ( shardId , percolateRequest ) ) ) ; IntArrayList items = shardToSlots . get ( shardId ) ; if ( items = = null ) { shardToSlots . put ( shardId , items = new IntArrayList ( ) ) ; } items . add ( slot ) ; } expectedResults + + ; } else if ( element instanceof Throwable | | element instanceof MultiGetResponse . Failure ) { logger . trace ( <str> , slot , element ) ; reducedResponses . set ( slot , element ) ; responsesByItemAndShard . set ( slot , new AtomicReferenceArray ( <int> ) ) ; expectedOperationsPerItem . set ( slot , new AtomicInteger ( <int> ) ) ; } } expectedOperations = new AtomicInteger ( expectedResults ) ; } void run ( ) { if ( expectedOperations . get ( ) = = <int> ) { finish ( ) ; return ; } logger . trace ( <str> , requestsByShard . keySet ( ) ) ; for ( Map . Entry < ShardId , TransportShardMultiPercolateAction . Request > entry : requestsByShard . entrySet ( ) ) { final ShardId shardId = entry . getKey ( ) ; TransportShardMultiPercolateAction . Request shardRequest = entry . getValue ( ) ; shardMultiPercolateAction . execute ( shardRequest , new ActionListener < TransportShardMultiPercolateAction . Response > ( ) { @Override public void onResponse ( TransportShardMultiPercolateAction . Response response ) { onShardResponse ( shardId , response ) ; } @Override public void onFailure ( Throwable e ) { onShardFailure ( shardId , e ) ; } } ) ; } } @SuppressWarnings ( <str> ) void onShardResponse ( ShardId shardId , TransportShardMultiPercolateAction . Response response ) { logger . trace ( <str> , shardId ) ; try { for ( TransportShardMultiPercolateAction . Response . Item item : response . items ( ) ) { AtomicReferenceArray shardResults = responsesByItemAndShard . get ( item . slot ( ) ) ; if ( shardResults = = null ) { assert false : <str> ; continue ; } if ( item . failed ( ) ) { shardResults . set ( shardId . id ( ) , new BroadcastShardOperationFailedException ( shardId , item . error ( ) ) ) ; } else { shardResults . set ( shardId . id ( ) , item . response ( ) ) ; } assert expectedOperationsPerItem . get ( item . slot ( ) ) . get ( ) > = <int> : <str> + item . slot ( ) + <str> ; if ( expectedOperationsPerItem . get ( item . slot ( ) ) . decrementAndGet ( ) = = <int> ) { reduce ( item . slot ( ) ) ; } } } catch ( Throwable e ) { logger . error ( <str> , e , shardId ) ; finalListener . onFailure ( e ) ; } } @SuppressWarnings ( <str> ) void onShardFailure ( ShardId shardId , Throwable e ) { logger . debug ( <str> , e , shardId ) ; try { IntArrayList slots = shardToSlots . get ( shardId ) ; for ( int i = <int> ; i < slots . size ( ) ; i + + ) { int slot = slots . get ( i ) ; AtomicReferenceArray shardResults = responsesByItemAndShard . get ( slot ) ; if ( shardResults = = null ) { continue ; } shardResults . set ( shardId . id ( ) , new BroadcastShardOperationFailedException ( shardId , e ) ) ; assert expectedOperationsPerItem . get ( slot ) . get ( ) > = <int> : <str> + slot + <str> + e . getMessage ( ) ; if ( expectedOperationsPerItem . get ( slot ) . decrementAndGet ( ) = = <int> ) { reduce ( slot ) ; } } } catch ( Throwable t ) { logger . error ( <str> , t , shardId , e ) ; finalListener . onFailure ( t ) ; } } void reduce ( int slot ) { AtomicReferenceArray shardResponses = responsesByItemAndShard . get ( slot ) ; PercolateResponse reducedResponse = TransportPercolateAction . reduce ( ( PercolateRequest ) percolateRequests . get ( slot ) , shardResponses , percolatorService ) ; reducedResponses . set ( slot , reducedResponse ) ; assert expectedOperations . get ( ) > = <int> : <str> + slot + <str> + expectedOperations . get ( ) ; if ( expectedOperations . decrementAndGet ( ) = = <int> ) { finish ( ) ; } } void finish ( ) { MultiPercolateResponse . Item [ ] finalResponse = new MultiPercolateResponse . Item [ reducedResponses . length ( ) ] ; for ( int slot = <int> ; slot < reducedResponses . length ( ) ; slot + + ) { Object element = reducedResponses . get ( slot ) ; assert element ! = null : <str> + slot + <str> ; if ( element instanceof PercolateResponse ) { finalResponse [ slot ] = new MultiPercolateResponse . Item ( ( PercolateResponse ) element ) ; } else if ( element instanceof Throwable ) { finalResponse [ slot ] = new MultiPercolateResponse . Item ( ( Throwable ) element ) ; } else if ( element instanceof MultiGetResponse . Failure ) { finalResponse [ slot ] = new MultiPercolateResponse . Item ( ( ( MultiGetResponse . Failure ) element ) . getFailure ( ) ) ; } } finalListener . onResponse ( new MultiPercolateResponse ( finalResponse ) ) ; } } } 
