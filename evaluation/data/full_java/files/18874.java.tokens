package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; class Bzip2BitReader { private static final int MAX_COUNT_OF_READABLE_BYTES = Integer . MAX_VALUE > > > <int> ; private ByteBuf in ; private long bitBuffer ; private int bitCount ; void setByteBuf ( ByteBuf in ) { this . in = in ; } int readBits ( final int count ) { if ( count < <int> | | count > <int> ) { throw new IllegalArgumentException ( <str> + count + <str> ) ; } int bitCount = this . bitCount ; long bitBuffer = this . bitBuffer ; if ( bitCount < count ) { long readData ; int offset ; switch ( in . readableBytes ( ) ) { case <int> : { readData = in . readUnsignedByte ( ) ; offset = <int> ; break ; } case <int> : { readData = in . readUnsignedShort ( ) ; offset = <int> ; break ; } case <int> : { readData = in . readUnsignedMedium ( ) ; offset = <int> ; break ; } default : { readData = in . readUnsignedInt ( ) ; offset = <int> ; break ; } } bitBuffer = bitBuffer < < offset | readData ; bitCount + = offset ; this . bitBuffer = bitBuffer ; } this . bitCount = bitCount - = count ; return ( int ) ( bitBuffer > > > bitCount & ( count ! = <int> ? ( <int> < < count ) - <int> : <hex> ) ) ; } boolean readBoolean ( ) { return readBits ( <int> ) ! = <int> ; } int readInt ( ) { return readBits ( <int> ) ; } void refill ( ) { int readData = in . readUnsignedByte ( ) ; bitBuffer = bitBuffer < < <int> | readData ; bitCount + = <int> ; } boolean isReadable ( ) { return bitCount > <int> | | in . isReadable ( ) ; } boolean hasReadableBits ( int count ) { if ( count < <int> ) { throw new IllegalArgumentException ( <str> + count + <str> ) ; } return bitCount > = count | | ( in . readableBytes ( ) < < <int> & Integer . MAX_VALUE ) > = count - bitCount ; } boolean hasReadableBytes ( int count ) { if ( count < <int> | | count > MAX_COUNT_OF_READABLE_BYTES ) { throw new IllegalArgumentException ( <str> + count + <str> + MAX_COUNT_OF_READABLE_BYTES + <str> ) ; } return hasReadableBits ( count < < <int> ) ; } } 
