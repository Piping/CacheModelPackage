package org . apache . cassandra . db . lifecycle ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import javax . annotation . Nullable ; import com . google . common . base . Function ; import com . google . common . base . Predicate ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import org . junit . BeforeClass ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . MockSchema ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Memtable ; import org . apache . cassandra . db . commitlog . ReplayPosition ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . notifications . * ; import org . apache . cassandra . utils . concurrent . OpOrder ; import static com . google . common . collect . ImmutableSet . copyOf ; import static java . util . Collections . singleton ; public class TrackerTest { private static final class MockListener implements INotificationConsumer { final boolean throwException ; final List < INotification > received = new ArrayList < > ( ) ; final List < Object > senders = new ArrayList < > ( ) ; private MockListener ( boolean throwException ) { this . throwException = throwException ; } public void handleNotification ( INotification notification , Object sender ) { if ( throwException ) throw new RuntimeException ( ) ; received . add ( notification ) ; senders . add ( sender ) ; } } @BeforeClass public static void setUp ( ) { MockSchema . cleanup ( ) ; } @Test public void testTryModify ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; Tracker tracker = new Tracker ( cfs , false ) ; List < SSTableReader > readers = ImmutableList . of ( MockSchema . sstable ( <int> , true , cfs ) , MockSchema . sstable ( <int> , cfs ) , MockSchema . sstable ( <int> , cfs ) ) ; tracker . addInitialSSTables ( copyOf ( readers ) ) ; Assert . assertNull ( tracker . tryModify ( ImmutableList . of ( MockSchema . sstable ( <int> , cfs ) ) , OperationType . COMPACTION ) ) ; try ( LifecycleTransaction txn = tracker . tryModify ( readers . get ( <int> ) , OperationType . COMPACTION ) ; ) { Assert . assertNotNull ( txn ) ; Assert . assertNull ( tracker . tryModify ( readers . get ( <int> ) , OperationType . COMPACTION ) ) ; Assert . assertEquals ( <int> , txn . originals ( ) . size ( ) ) ; Assert . assertTrue ( txn . originals ( ) . contains ( readers . get ( <int> ) ) ) ; } try ( LifecycleTransaction txn = tracker . tryModify ( Collections . < SSTableReader > emptyList ( ) , OperationType . COMPACTION ) ; ) { Assert . assertNotNull ( txn ) ; Assert . assertEquals ( <int> , txn . originals ( ) . size ( ) ) ; } readers . get ( <int> ) . selfRef ( ) . release ( ) ; } @Test public void testApply ( ) { final ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; final Tracker tracker = new Tracker ( null , false ) ; final View resultView = ViewTest . fakeView ( <int> , <int> , cfs ) ; final AtomicInteger count = new AtomicInteger ( ) ; tracker . apply ( new Predicate < View > ( ) { public boolean apply ( View view ) { if ( count . incrementAndGet ( ) < <int> ) tracker . view . set ( ViewTest . fakeView ( <int> , <int> , cfs ) ) ; return true ; } } , new Function < View , View > ( ) { @Nullable public View apply ( View view ) { return resultView ; } } ) ; Assert . assertEquals ( <int> , count . get ( ) ) ; Assert . assertEquals ( resultView , tracker . getView ( ) ) ; count . set ( <int> ) ; Assert . assertNull ( tracker . apply ( new Predicate < View > ( ) { public boolean apply ( View view ) { count . incrementAndGet ( ) ; return false ; } } , null ) ) ; Assert . assertEquals ( <int> , count . get ( ) ) ; Assert . assertEquals ( resultView , tracker . getView ( ) ) ; } @Test public void testAddInitialSSTables ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; Tracker tracker = new Tracker ( cfs , false ) ; List < SSTableReader > readers = ImmutableList . of ( MockSchema . sstable ( <int> , <int> , cfs ) , MockSchema . sstable ( <int> , <int> , cfs ) , MockSchema . sstable ( <int> , <int> , cfs ) ) ; tracker . addInitialSSTables ( copyOf ( readers ) ) ; Assert . assertEquals ( <int> , tracker . view . get ( ) . sstables . size ( ) ) ; for ( SSTableReader reader : readers ) Assert . assertTrue ( reader . isKeyCacheSetup ( ) ) ; Assert . assertEquals ( <int> + <int> + <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; } @Test public void testAddSSTables ( ) { boolean backups = DatabaseDescriptor . isIncrementalBackupsEnabled ( ) ; DatabaseDescriptor . setIncrementalBackupsEnabled ( false ) ; ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; Tracker tracker = new Tracker ( cfs , false ) ; MockListener listener = new MockListener ( false ) ; tracker . subscribe ( listener ) ; List < SSTableReader > readers = ImmutableList . of ( MockSchema . sstable ( <int> , <int> , cfs ) , MockSchema . sstable ( <int> , <int> , cfs ) , MockSchema . sstable ( <int> , <int> , cfs ) ) ; tracker . addSSTables ( copyOf ( readers ) ) ; Assert . assertEquals ( <int> , tracker . view . get ( ) . sstables . size ( ) ) ; for ( SSTableReader reader : readers ) Assert . assertTrue ( reader . isKeyCacheSetup ( ) ) ; Assert . assertEquals ( <int> + <int> + <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; Assert . assertEquals ( <int> , listener . senders . size ( ) ) ; Assert . assertEquals ( tracker , listener . senders . get ( <int> ) ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof SSTableAddedNotification ) ; DatabaseDescriptor . setIncrementalBackupsEnabled ( backups ) ; } @Test public void testDropSSTables ( ) { testDropSSTables ( false ) ; LogTransaction . waitForDeletions ( ) ; testDropSSTables ( true ) ; LogTransaction . waitForDeletions ( ) ; } private void testDropSSTables ( boolean invalidate ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; Tracker tracker = cfs . getTracker ( ) ; MockListener listener = new MockListener ( false ) ; tracker . subscribe ( listener ) ; final List < SSTableReader > readers = ImmutableList . of ( MockSchema . sstable ( <int> , <int> , true , cfs ) , MockSchema . sstable ( <int> , <int> , true , cfs ) , MockSchema . sstable ( <int> , <int> , true , cfs ) ) ; tracker . addInitialSSTables ( copyOf ( readers ) ) ; try ( LifecycleTransaction txn = tracker . tryModify ( readers . get ( <int> ) , OperationType . COMPACTION ) ) { if ( invalidate ) { cfs . invalidate ( false ) ; } else { tracker . dropSSTables ( ) ; LogTransaction . waitForDeletions ( ) ; } Assert . assertEquals ( <int> , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; Assert . assertEquals ( <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; } if ( ! invalidate ) { Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; Assert . assertEquals ( readers . get ( <int> ) , Iterables . getFirst ( tracker . getView ( ) . sstables , null ) ) ; Assert . assertEquals ( <int> , readers . get ( <int> ) . selfRef ( ) . globalCount ( ) ) ; Assert . assertFalse ( readers . get ( <int> ) . isMarkedCompacted ( ) ) ; for ( SSTableReader reader : readers . subList ( <int> , <int> ) ) { Assert . assertEquals ( <int> , reader . selfRef ( ) . globalCount ( ) ) ; Assert . assertTrue ( reader . isMarkedCompacted ( ) ) ; } Assert . assertNull ( tracker . dropSSTables ( reader - > reader ! = readers . get ( <int> ) , OperationType . UNKNOWN , null ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; Assert . assertEquals ( <int> , listener . received . size ( ) ) ; Assert . assertEquals ( tracker , listener . senders . get ( <int> ) ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof SSTableDeletingNotification ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof SSTableDeletingNotification ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof SSTableListChangedNotification ) ; Assert . assertEquals ( readers . get ( <int> ) , ( ( SSTableDeletingNotification ) listener . received . get ( <int> ) ) . deleting ) ; Assert . assertEquals ( readers . get ( <int> ) , ( ( SSTableDeletingNotification ) listener . received . get ( <int> ) ) . deleting ) ; Assert . assertEquals ( <int> , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . removed . size ( ) ) ; Assert . assertEquals ( <int> , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . added . size ( ) ) ; Assert . assertEquals ( <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; readers . get ( <int> ) . selfRef ( ) . release ( ) ; } else { Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; Assert . assertEquals ( <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; for ( SSTableReader reader : readers ) Assert . assertTrue ( reader . isMarkedCompacted ( ) ) ; } } @Test public void testMemtableReplacement ( ) { boolean backups = DatabaseDescriptor . isIncrementalBackupsEnabled ( ) ; DatabaseDescriptor . setIncrementalBackupsEnabled ( false ) ; ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; MockListener listener = new MockListener ( false ) ; Tracker tracker = cfs . getTracker ( ) ; tracker . subscribe ( listener ) ; Memtable prev1 = tracker . switchMemtable ( true ) ; OpOrder . Group write1 = cfs . keyspace . writeOrder . getCurrent ( ) ; OpOrder . Barrier barrier1 = cfs . keyspace . writeOrder . newBarrier ( ) ; prev1 . setDiscarding ( barrier1 , new AtomicReference < ReplayPosition > ( ) ) ; barrier1 . issue ( ) ; Memtable prev2 = tracker . switchMemtable ( false ) ; OpOrder . Group write2 = cfs . keyspace . writeOrder . getCurrent ( ) ; OpOrder . Barrier barrier2 = cfs . keyspace . writeOrder . newBarrier ( ) ; prev2 . setDiscarding ( barrier2 , new AtomicReference < ReplayPosition > ( ) ) ; barrier2 . issue ( ) ; Memtable cur = tracker . getView ( ) . getCurrentMemtable ( ) ; OpOrder . Group writecur = cfs . keyspace . writeOrder . getCurrent ( ) ; Assert . assertEquals ( prev1 , tracker . getMemtableFor ( write1 , ReplayPosition . NONE ) ) ; Assert . assertEquals ( prev2 , tracker . getMemtableFor ( write2 , ReplayPosition . NONE ) ) ; Assert . assertEquals ( cur , tracker . getMemtableFor ( writecur , ReplayPosition . NONE ) ) ; Assert . assertEquals ( <int> , listener . received . size ( ) ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof MemtableRenewedNotification ) ; listener . received . clear ( ) ; tracker . markFlushing ( prev2 ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . flushingMemtables . size ( ) ) ; Assert . assertTrue ( tracker . getView ( ) . flushingMemtables . contains ( prev2 ) ) ; tracker . markFlushing ( prev1 ) ; Assert . assertTrue ( tracker . getView ( ) . flushingMemtables . contains ( prev1 ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . flushingMemtables . size ( ) ) ; tracker . replaceFlushed ( prev1 , null ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . flushingMemtables . size ( ) ) ; Assert . assertTrue ( tracker . getView ( ) . flushingMemtables . contains ( prev2 ) ) ; SSTableReader reader = MockSchema . sstable ( <int> , <int> , false , cfs ) ; tracker . replaceFlushed ( prev2 , Collections . singleton ( reader ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; Assert . assertEquals ( <int> , listener . received . size ( ) ) ; Assert . assertEquals ( singleton ( reader ) , ( ( SSTableAddedNotification ) listener . received . get ( <int> ) ) . added ) ; listener . received . clear ( ) ; Assert . assertTrue ( reader . isKeyCacheSetup ( ) ) ; Assert . assertEquals ( <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; cfs = MockSchema . newCFS ( ) ; tracker = cfs . getTracker ( ) ; listener = new MockListener ( false ) ; tracker . subscribe ( listener ) ; prev1 = tracker . switchMemtable ( false ) ; tracker . markFlushing ( prev1 ) ; reader = MockSchema . sstable ( <int> , <int> , true , cfs ) ; cfs . invalidate ( false ) ; tracker . replaceFlushed ( prev1 , Collections . singleton ( reader ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . sstables . size ( ) ) ; Assert . assertEquals ( <int> , tracker . getView ( ) . flushingMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; Assert . assertEquals ( <int> , listener . received . size ( ) ) ; Assert . assertEquals ( singleton ( reader ) , ( ( SSTableAddedNotification ) listener . received . get ( <int> ) ) . added ) ; Assert . assertTrue ( listener . received . get ( <int> ) instanceof SSTableDeletingNotification ) ; Assert . assertEquals ( <int> , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . removed . size ( ) ) ; DatabaseDescriptor . setIncrementalBackupsEnabled ( backups ) ; } @Test public void testNotifications ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; SSTableReader r1 = MockSchema . sstable ( <int> , cfs ) , r2 = MockSchema . sstable ( <int> , cfs ) ; Tracker tracker = new Tracker ( null , false ) ; MockListener listener = new MockListener ( false ) ; tracker . subscribe ( listener ) ; tracker . notifyAdded ( singleton ( r1 ) ) ; Assert . assertEquals ( singleton ( r1 ) , ( ( SSTableAddedNotification ) listener . received . get ( <int> ) ) . added ) ; listener . received . clear ( ) ; tracker . notifyDeleting ( r1 ) ; Assert . assertEquals ( r1 , ( ( SSTableDeletingNotification ) listener . received . get ( <int> ) ) . deleting ) ; listener . received . clear ( ) ; Assert . assertNull ( tracker . notifySSTablesChanged ( singleton ( r1 ) , singleton ( r2 ) , OperationType . COMPACTION , null ) ) ; Assert . assertEquals ( singleton ( r1 ) , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . removed ) ; Assert . assertEquals ( singleton ( r2 ) , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . added ) ; listener . received . clear ( ) ; tracker . notifySSTableRepairedStatusChanged ( singleton ( r1 ) ) ; Assert . assertEquals ( singleton ( r1 ) , ( ( SSTableRepairStatusChanged ) listener . received . get ( <int> ) ) . sstable ) ; listener . received . clear ( ) ; Memtable memtable = MockSchema . memtable ( cfs ) ; tracker . notifyRenewed ( memtable ) ; Assert . assertEquals ( memtable , ( ( MemtableRenewedNotification ) listener . received . get ( <int> ) ) . renewed ) ; listener . received . clear ( ) ; tracker . unsubscribe ( listener ) ; MockListener failListener = new MockListener ( true ) ; tracker . subscribe ( failListener ) ; tracker . subscribe ( listener ) ; Assert . assertNotNull ( tracker . notifyAdded ( singleton ( r1 ) , null ) ) ; Assert . assertEquals ( singleton ( r1 ) , ( ( SSTableAddedNotification ) listener . received . get ( <int> ) ) . added ) ; listener . received . clear ( ) ; Assert . assertNotNull ( tracker . notifySSTablesChanged ( singleton ( r1 ) , singleton ( r2 ) , OperationType . COMPACTION , null ) ) ; Assert . assertEquals ( singleton ( r1 ) , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . removed ) ; Assert . assertEquals ( singleton ( r2 ) , ( ( SSTableListChangedNotification ) listener . received . get ( <int> ) ) . added ) ; listener . received . clear ( ) ; } } 
