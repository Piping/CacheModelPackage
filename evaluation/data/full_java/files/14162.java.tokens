package org . gradle . messaging . remote . internal ; import org . gradle . messaging . remote . internal . protocol . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . HashSet ; import java . util . Set ; import java . util . UUID ; public class ReceiveProtocol implements Protocol < Message > { private static final Logger LOGGER = LoggerFactory . getLogger ( ReceiveProtocol . class ) ; private final UUID id ; private final String displayName ; private final String channelKey ; private final Set < Object > producers = new HashSet < Object > ( ) ; private ProtocolContext < Message > context ; private boolean stopping ; public ReceiveProtocol ( UUID id , String displayName , String channelKey ) { this . id = id ; this . displayName = displayName ; this . channelKey = channelKey ; } public void start ( ProtocolContext < Message > context ) { this . context = context ; LOGGER . debug ( <str> , id ) ; context . dispatchOutgoing ( new ConsumerAvailable ( id , displayName , channelKey ) ) ; } public void handleIncoming ( Message message ) { if ( message instanceof ProducerReady ) { LOGGER . debug ( <str> , message ) ; ProducerReady producerReady = ( ProducerReady ) message ; producers . add ( producerReady . getProducerId ( ) ) ; context . dispatchOutgoing ( new ConsumerReady ( id , producerReady . getProducerId ( ) ) ) ; } else if ( message instanceof ProducerStopped ) { LOGGER . debug ( <str> , message ) ; ProducerStopped producerStopped = ( ProducerStopped ) message ; context . dispatchOutgoing ( new ConsumerStopped ( id , producerStopped . getProducerId ( ) ) ) ; removeProducer ( producerStopped . getProducerId ( ) ) ; } else if ( message instanceof ProducerUnavailable ) { LOGGER . debug ( <str> , message ) ; ProducerUnavailable producerUnavailable = ( ProducerUnavailable ) message ; removeProducer ( producerUnavailable . getId ( ) ) ; } else if ( message instanceof ProducerAvailable ) { return ; } else if ( message instanceof Request ) { context . dispatchIncoming ( message ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } private void removeProducer ( Object producerId ) { producers . remove ( producerId ) ; if ( stopping & & producers . isEmpty ( ) ) { LOGGER . debug ( <str> ) ; allProducersFinished ( ) ; } } public void handleOutgoing ( Message message ) { if ( message instanceof WorkerStopping ) { workerStopped ( ) ; } else if ( message instanceof MessageCredits ) { LOGGER . debug ( <str> , message ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } private void workerStopped ( ) { stopping = true ; if ( producers . isEmpty ( ) ) { LOGGER . debug ( <str> ) ; allProducersFinished ( ) ; return ; } LOGGER . debug ( <str> , producers ) ; for ( Object producer : producers ) { context . dispatchOutgoing ( new ConsumerStopping ( id , producer ) ) ; } } private void allProducersFinished ( ) { context . dispatchOutgoing ( new ConsumerUnavailable ( id ) ) ; context . dispatchIncoming ( new EndOfStreamEvent ( ) ) ; } public void stopRequested ( ) { assert stopping ; context . stopped ( ) ; } } 
