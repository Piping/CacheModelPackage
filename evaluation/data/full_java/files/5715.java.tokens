package org . elasticsearch . common . compress ; import org . elasticsearch . Version ; import org . elasticsearch . common . io . stream . StreamInput ; import java . io . EOFException ; import java . io . IOException ; public abstract class CompressedStreamInput extends StreamInput { private final StreamInput in ; private boolean closed ; protected byte [ ] uncompressed ; private int position = <int> ; private int valid = <int> ; public CompressedStreamInput ( StreamInput in ) throws IOException { this . in = in ; super . setVersion ( in . getVersion ( ) ) ; readHeader ( in ) ; } @Override public void setVersion ( Version version ) { in . setVersion ( version ) ; super . setVersion ( version ) ; } @Override public int available ( ) throws IOException { if ( closed ) { return - <int> ; } int left = ( valid - position ) ; return ( left < = <int> ) ? <int> : left ; } @Override public int read ( ) throws IOException { if ( ! readyBuffer ( ) ) { return - <int> ; } return uncompressed [ position + + ] & <int> ; } @Override public byte readByte ( ) throws IOException { if ( ! readyBuffer ( ) ) { throw new EOFException ( ) ; } return uncompressed [ position + + ] ; } @Override public int read ( byte [ ] buffer , int offset , int length ) throws IOException { return read ( buffer , offset , length , false ) ; } public int read ( byte [ ] buffer , int offset , int length , boolean fullRead ) throws IOException { if ( length < <int> ) { return <int> ; } if ( ! readyBuffer ( ) ) { return - <int> ; } int chunkLength = Math . min ( valid - position , length ) ; System . arraycopy ( uncompressed , position , buffer , offset , chunkLength ) ; position + = chunkLength ; if ( chunkLength = = length | | ! fullRead ) { return chunkLength ; } int totalRead = chunkLength ; do { offset + = chunkLength ; if ( ! readyBuffer ( ) ) { break ; } chunkLength = Math . min ( valid - position , ( length - totalRead ) ) ; System . arraycopy ( uncompressed , position , buffer , offset , chunkLength ) ; position + = chunkLength ; totalRead + = chunkLength ; } while ( totalRead < length ) ; return totalRead ; } @Override public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { int result = read ( b , offset , len , true ) ; if ( result < len ) { throw new EOFException ( ) ; } } @Override public void reset ( ) throws IOException { this . position = <int> ; this . valid = <int> ; in . reset ( ) ; } @Override public void close ( ) throws IOException { position = valid = <int> ; if ( ! closed ) { closed = true ; doClose ( ) ; in . close ( ) ; } } protected abstract void doClose ( ) throws IOException ; protected boolean readyBuffer ( ) throws IOException { if ( position < valid ) { return true ; } if ( closed ) { return false ; } valid = uncompress ( in , uncompressed ) ; if ( valid < <int> ) { return false ; } position = <int> ; return ( position < valid ) ; } protected abstract void readHeader ( StreamInput in ) throws IOException ; protected abstract int uncompress ( StreamInput in , byte [ ] out ) throws IOException ; } 
