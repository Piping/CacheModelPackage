package com . badlogic . gdx . backends . android ; import android . content . res . AssetFileDescriptor ; import android . os . ParcelFileDescriptor ; import android . util . Log ; import java . io . EOFException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . MappedByteBuffer ; import java . nio . channels . FileChannel ; import java . util . Collection ; import java . util . HashMap ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class ZipResourceFile { static final String LOG_TAG = <str> ; static final boolean LOGV = false ; static private int swapEndian ( int i ) { return ( ( i & <hex> ) < < <int> ) + ( ( i & <hex> ) < < <int> ) + ( ( i & <hex> ) > > > <int> ) + ( ( i > > > <int> ) & <hex> ) ; } static private int swapEndian ( short i ) { return ( ( i & <hex> ) < < <int> | ( i & <hex> ) > > > <int> ) ; } static final int kEOCDSignature = <hex> ; static final int kEOCDLen = <int> ; static final int kEOCDNumEntries = <int> ; static final int kEOCDSize = <int> ; static final int kEOCDFileOffset = <int> ; static final int kMaxCommentLen = <int> ; static final int kMaxEOCDSearch = ( kMaxCommentLen + kEOCDLen ) ; static final int kLFHSignature = <hex> ; static final int kLFHLen = <int> ; static final int kLFHNameLen = <int> ; static final int kLFHExtraLen = <int> ; static final int kCDESignature = <hex> ; static final int kCDELen = <int> ; static final int kCDEMethod = <int> ; static final int kCDEModWhen = <int> ; static final int kCDECRC = <int> ; static final int kCDECompLen = <int> ; static final int kCDEUncompLen = <int> ; static final int kCDENameLen = <int> ; static final int kCDEExtraLen = <int> ; static final int kCDECommentLen = <int> ; static final int kCDELocalOffset = <int> ; static final int kCompressStored = <int> ; static final int kCompressDeflated = <int> ; static final int kZipEntryAdj = <int> ; static public final class ZipEntryRO { public ZipEntryRO ( final String zipFileName , final File file , final String fileName ) { mFileName = fileName ; mZipFileName = zipFileName ; mFile = file ; } public final File mFile ; public final String mFileName ; public final String mZipFileName ; public long mLocalHdrOffset ; public int mMethod ; public long mWhenModified ; public long mCRC32 ; public long mCompressedLength ; public long mUncompressedLength ; public long mOffset = - <int> ; public void setOffsetFromFile ( RandomAccessFile f , ByteBuffer buf ) throws IOException { long localHdrOffset = mLocalHdrOffset ; try { f . seek ( localHdrOffset ) ; f . readFully ( buf . array ( ) ) ; if ( buf . getInt ( <int> ) ! = kLFHSignature ) { Log . w ( LOG_TAG , <str> ) ; throw new IOException ( ) ; } int nameLen = buf . getShort ( kLFHNameLen ) & <hex> ; int extraLen = buf . getShort ( kLFHExtraLen ) & <hex> ; mOffset = localHdrOffset + kLFHLen + nameLen + extraLen ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public long getOffset ( ) { return mOffset ; } public boolean isUncompressed ( ) { return mMethod = = kCompressStored ; } public AssetFileDescriptor getAssetFileDescriptor ( ) { if ( mMethod = = kCompressStored ) { ParcelFileDescriptor pfd ; try { pfd = ParcelFileDescriptor . open ( mFile , ParcelFileDescriptor . MODE_READ_ONLY ) ; return new AssetFileDescriptor ( pfd , getOffset ( ) , mUncompressedLength ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } return null ; } public String getZipFileName ( ) { return mZipFileName ; } public File getZipFile ( ) { return mFile ; } } private HashMap < String , ZipEntryRO > mHashMap = new HashMap < String , ZipEntryRO > ( ) ; public HashMap < File , ZipFile > mZipFiles = new HashMap < File , ZipFile > ( ) ; public ZipResourceFile ( String zipFileName ) throws IOException { addPatchFile ( zipFileName ) ; } ZipEntryRO [ ] getEntriesAt ( String path ) { Vector < ZipEntryRO > zev = new Vector < ZipEntryRO > ( ) ; Collection < ZipEntryRO > values = mHashMap . values ( ) ; if ( null = = path ) path = <str> ; int length = path . length ( ) ; for ( ZipEntryRO ze : values ) { if ( ze . mFileName . startsWith ( path ) ) { if ( - <int> = = ze . mFileName . indexOf ( <str> , length ) ) { zev . add ( ze ) ; } } } ZipEntryRO [ ] entries = new ZipEntryRO [ zev . size ( ) ] ; return zev . toArray ( entries ) ; } public ZipEntryRO [ ] getAllEntries ( ) { Collection < ZipEntryRO > values = mHashMap . values ( ) ; return values . toArray ( new ZipEntryRO [ values . size ( ) ] ) ; } public AssetFileDescriptor getAssetFileDescriptor ( String assetPath ) { ZipEntryRO entry = mHashMap . get ( assetPath ) ; if ( null ! = entry ) { return entry . getAssetFileDescriptor ( ) ; } return null ; } public InputStream getInputStream ( String assetPath ) throws IOException { ZipEntryRO entry = mHashMap . get ( assetPath ) ; if ( null ! = entry ) { if ( entry . isUncompressed ( ) ) { return entry . getAssetFileDescriptor ( ) . createInputStream ( ) ; } else { ZipFile zf = mZipFiles . get ( entry . getZipFile ( ) ) ; if ( null = = zf ) { zf = new ZipFile ( entry . getZipFile ( ) , ZipFile . OPEN_READ ) ; mZipFiles . put ( entry . getZipFile ( ) , zf ) ; } ZipEntry zi = zf . getEntry ( assetPath ) ; if ( null ! = zi ) return zf . getInputStream ( zi ) ; } } return null ; } ByteBuffer mLEByteBuffer = ByteBuffer . allocate ( <int> ) ; static private int read4LE ( RandomAccessFile f ) throws EOFException , IOException { return swapEndian ( f . readInt ( ) ) ; } void addPatchFile ( String zipFileName ) throws IOException { File file = new File ( zipFileName ) ; RandomAccessFile f = new RandomAccessFile ( file , <str> ) ; long fileLength = f . length ( ) ; if ( fileLength < kEOCDLen ) { f . close ( ) ; throw new java . io . IOException ( ) ; } long readAmount = kMaxEOCDSearch ; if ( readAmount > fileLength ) readAmount = fileLength ; f . seek ( <int> ) ; int header = read4LE ( f ) ; if ( header = = kEOCDSignature ) { Log . i ( LOG_TAG , <str> ) ; throw new IOException ( ) ; } else if ( header ! = kLFHSignature ) { Log . v ( LOG_TAG , <str> ) ; throw new IOException ( ) ; } long searchStart = fileLength - readAmount ; f . seek ( searchStart ) ; ByteBuffer bbuf = ByteBuffer . allocate ( ( int ) readAmount ) ; byte [ ] buffer = bbuf . array ( ) ; f . readFully ( buffer ) ; bbuf . order ( ByteOrder . LITTLE_ENDIAN ) ; int eocdIdx ; for ( eocdIdx = buffer . length - kEOCDLen ; eocdIdx > = <int> ; eocdIdx - - ) { if ( buffer [ eocdIdx ] = = <hex> & & bbuf . getInt ( eocdIdx ) = = kEOCDSignature ) { if ( LOGV ) { Log . v ( LOG_TAG , <str> + eocdIdx ) ; } break ; } } if ( eocdIdx < <int> ) { Log . d ( LOG_TAG , <str> + zipFileName + <str> ) ; } int numEntries = bbuf . getShort ( eocdIdx + kEOCDNumEntries ) ; long dirSize = bbuf . getInt ( eocdIdx + kEOCDSize ) & <hex> ; long dirOffset = bbuf . getInt ( eocdIdx + kEOCDFileOffset ) & <hex> ; if ( dirOffset + dirSize > fileLength ) { Log . w ( LOG_TAG , <str> + dirOffset + <str> + dirSize + <str> + eocdIdx + <str> ) ; throw new IOException ( ) ; } if ( numEntries = = <int> ) { Log . w ( LOG_TAG , <str> ) ; throw new IOException ( ) ; } if ( LOGV ) { Log . v ( LOG_TAG , <str> + numEntries + <str> + dirSize + <str> + dirOffset ) ; } MappedByteBuffer directoryMap = f . getChannel ( ) . map ( FileChannel . MapMode . READ_ONLY , dirOffset , dirSize ) ; directoryMap . order ( ByteOrder . LITTLE_ENDIAN ) ; byte [ ] tempBuf = new byte [ <hex> ] ; int currentOffset = <int> ; ByteBuffer buf = ByteBuffer . allocate ( kLFHLen ) ; buf . order ( ByteOrder . LITTLE_ENDIAN ) ; for ( int i = <int> ; i < numEntries ; i + + ) { if ( directoryMap . getInt ( currentOffset ) ! = kCDESignature ) { Log . w ( LOG_TAG , <str> + currentOffset + <str> ) ; throw new IOException ( ) ; } int fileNameLen = directoryMap . getShort ( currentOffset + kCDENameLen ) & <hex> ; int extraLen = directoryMap . getShort ( currentOffset + kCDEExtraLen ) & <hex> ; int commentLen = directoryMap . getShort ( currentOffset + kCDECommentLen ) & <hex> ; directoryMap . position ( currentOffset + kCDELen ) ; directoryMap . get ( tempBuf , <int> , fileNameLen ) ; directoryMap . position ( <int> ) ; String str = new String ( tempBuf , <int> , fileNameLen ) ; if ( LOGV ) { Log . v ( LOG_TAG , <str> + str ) ; } ZipEntryRO ze = new ZipEntryRO ( zipFileName , file , str ) ; ze . mMethod = directoryMap . getShort ( currentOffset + kCDEMethod ) & <hex> ; ze . mWhenModified = directoryMap . getInt ( currentOffset + kCDEModWhen ) & <hex> ; ze . mCRC32 = directoryMap . getLong ( currentOffset + kCDECRC ) & <hex> ; ze . mCompressedLength = directoryMap . getLong ( currentOffset + kCDECompLen ) & <hex> ; ze . mUncompressedLength = directoryMap . getLong ( currentOffset + kCDEUncompLen ) & <hex> ; ze . mLocalHdrOffset = directoryMap . getInt ( currentOffset + kCDELocalOffset ) & <hex> ; buf . clear ( ) ; ze . setOffsetFromFile ( f , buf ) ; mHashMap . put ( str , ze ) ; currentOffset + = kCDELen + fileNameLen + extraLen + commentLen ; } if ( LOGV ) { Log . v ( LOG_TAG , <str> + numEntries + <str> ) ; } } } 
