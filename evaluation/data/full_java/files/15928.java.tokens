package org . gradle . tooling . internal . adapter ; import org . gradle . api . Action ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . internal . typeconversion . EnumFromCharSequenceNotationParser ; import org . gradle . internal . typeconversion . TypeConversionException ; import org . gradle . tooling . model . DomainObjectSet ; import org . gradle . tooling . model . internal . Exceptions ; import org . gradle . tooling . model . internal . ImmutableDomainObjectSet ; import java . io . IOException ; import java . io . Serializable ; import java . lang . reflect . * ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ProtocolToModelAdapter implements Serializable { private static final MethodInvoker NO_OP_HANDLER = new NoOpMethodInvoker ( ) ; private static final Action < SourceObjectMapping > NO_OP_MAPPER = new NoOpMapping ( ) ; private static final TargetTypeProvider IDENTITY_TYPE_PROVIDER = new TargetTypeProvider ( ) { public < T > Class < ? extends T > getTargetType ( Class < T > initialTargetType , Object protocolObject ) { return initialTargetType ; } } ; private static final Object [ ] EMPTY = new Object [ <int> ] ; private static final Pattern IS_SUPPORT_METHOD = Pattern . compile ( <str> ) ; private static final Pattern GETTER_METHOD = Pattern . compile ( <str> ) ; private static final Pattern IS_METHOD = Pattern . compile ( <str> ) ; private final TargetTypeProvider targetTypeProvider ; private final CollectionMapper collectionMapper = new CollectionMapper ( ) ; public ProtocolToModelAdapter ( ) { this ( IDENTITY_TYPE_PROVIDER ) ; } public ProtocolToModelAdapter ( TargetTypeProvider targetTypeProvider ) { this . targetTypeProvider = targetTypeProvider ; } public < T , S > T adapt ( Class < T > targetType , S sourceObject ) { return adapt ( targetType , sourceObject , NO_OP_MAPPER ) ; } public < T , S > T adapt ( Class < T > targetType , final S sourceObject , final Class < ? > mixInClass ) { return adapt ( targetType , sourceObject , new Action < SourceObjectMapping > ( ) { public void execute ( SourceObjectMapping mapping ) { if ( mapping . getSourceObject ( ) = = sourceObject ) { mapping . mixIn ( mixInClass ) ; } } } ) ; } public < T , S > T adapt ( Class < T > targetType , S sourceObject , Action < ? super SourceObjectMapping > mapper ) { if ( sourceObject = = null ) { return null ; } Class < ? extends T > wrapperType = targetTypeProvider . getTargetType ( targetType , sourceObject ) ; DefaultSourceObjectMapping mapping = new DefaultSourceObjectMapping ( sourceObject , targetType , wrapperType ) ; mapper . execute ( mapping ) ; wrapperType = mapping . wrapperType . asSubclass ( targetType ) ; if ( wrapperType . isInstance ( sourceObject ) ) { return wrapperType . cast ( sourceObject ) ; } MethodInvoker overrideMethodInvoker = mapping . overrideInvoker ; MixInMethodInvoker mixInMethodInvoker = null ; if ( mapping . mixInType ! = null ) { mixInMethodInvoker = new MixInMethodInvoker ( mapping . mixInType , new AdaptingMethodInvoker ( mapper , new ReflectionMethodInvoker ( ) ) ) ; overrideMethodInvoker = mixInMethodInvoker ; } if ( targetType . isEnum ( ) ) { return adaptToEnum ( targetType , sourceObject ) ; } Object proxy = Proxy . newProxyInstance ( wrapperType . getClassLoader ( ) , new Class < ? > [ ] { wrapperType } , new InvocationHandlerImpl ( sourceObject , overrideMethodInvoker , mapper ) ) ; if ( mixInMethodInvoker ! = null ) { mixInMethodInvoker . setProxy ( proxy ) ; } return wrapperType . cast ( proxy ) ; } private static < T , S > T adaptToEnum ( Class < T > targetType , S sourceObject ) { try { String literal ; if ( sourceObject instanceof Enum ) { literal = ( ( Enum < ? > ) sourceObject ) . name ( ) ; } else if ( sourceObject instanceof String ) { literal = ( String ) sourceObject ; } else { literal = sourceObject . toString ( ) ; } EnumFromCharSequenceNotationParser parser = new EnumFromCharSequenceNotationParser ( targetType ) ; Enum parsedLiteral = parser . parseNotation ( literal ) ; return targetType . cast ( parsedLiteral ) ; } catch ( TypeConversionException e ) { throw new IllegalArgumentException ( String . format ( <str> , sourceObject , targetType . getSimpleName ( ) ) ) ; } } public Object unpack ( Object viewObject ) { if ( ! Proxy . isProxyClass ( viewObject . getClass ( ) ) | | ! ( Proxy . getInvocationHandler ( viewObject ) instanceof InvocationHandlerImpl ) ) { throw new IllegalArgumentException ( <str> ) ; } InvocationHandlerImpl handler = ( InvocationHandlerImpl ) Proxy . getInvocationHandler ( viewObject ) ; return handler . delegate ; } private static class DefaultSourceObjectMapping implements SourceObjectMapping { private final Object protocolObject ; private final Class < ? > targetType ; private Class < ? > wrapperType ; private Class < ? > mixInType ; private MethodInvoker overrideInvoker = NO_OP_HANDLER ; public DefaultSourceObjectMapping ( Object protocolObject , Class < ? > targetType , Class < ? > wrapperType ) { this . protocolObject = protocolObject ; this . targetType = targetType ; this . wrapperType = wrapperType ; } public Object getSourceObject ( ) { return protocolObject ; } public Class < ? > getTargetType ( ) { return targetType ; } public void mapToType ( Class < ? > type ) { if ( ! targetType . isAssignableFrom ( type ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getSimpleName ( ) , targetType . getSimpleName ( ) ) ) ; } wrapperType = type ; } public void mixIn ( Class < ? > mixInBeanType ) { if ( mixInType ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } mixInType = mixInBeanType ; } public void mixIn ( MethodInvoker invoker ) { if ( overrideInvoker ! = NO_OP_HANDLER ) { throw new UnsupportedOperationException ( <str> ) ; } overrideInvoker = invoker ; } } private static class NoOpMapping implements Action < SourceObjectMapping > , Serializable { public void execute ( SourceObjectMapping mapping ) { } } private class InvocationHandlerImpl implements InvocationHandler , Serializable { private final Object delegate ; private final MethodInvoker overrideMethodInvoker ; private final Action < ? super SourceObjectMapping > mapper ; private transient Method equalsMethod ; private transient Method hashCodeMethod ; private transient MethodInvoker invoker ; public InvocationHandlerImpl ( Object delegate , MethodInvoker overrideMethodInvoker , Action < ? super SourceObjectMapping > mapper ) { this . delegate = delegate ; this . overrideMethodInvoker = overrideMethodInvoker ; this . mapper = mapper ; setup ( ) ; } private void readObject ( java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; setup ( ) ; } private void setup ( ) { invoker = new SupportedPropertyInvoker ( new SafeMethodInvoker ( new PropertyCachingMethodInvoker ( new AdaptingMethodInvoker ( mapper , new ChainedMethodInvoker ( overrideMethodInvoker , new ReflectionMethodInvoker ( ) ) ) ) ) ) ; try { equalsMethod = Object . class . getMethod ( <str> , Object . class ) ; hashCodeMethod = Object . class . getMethod ( <str> ) ; } catch ( NoSuchMethodException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } @Override public boolean equals ( Object o ) { if ( o = = this ) { return true ; } if ( o = = null | | o . getClass ( ) ! = getClass ( ) ) { return false ; } InvocationHandlerImpl other = ( InvocationHandlerImpl ) o ; return delegate . equals ( other . delegate ) ; } @Override public int hashCode ( ) { return delegate . hashCode ( ) ; } public Object invoke ( Object target , Method method , Object [ ] params ) throws Throwable { if ( method . equals ( equalsMethod ) ) { Object param = params [ <int> ] ; if ( param = = null | | ! Proxy . isProxyClass ( param . getClass ( ) ) ) { return false ; } InvocationHandler other = Proxy . getInvocationHandler ( param ) ; return equals ( other ) ; } else if ( method . equals ( hashCodeMethod ) ) { return hashCode ( ) ; } MethodInvocation invocation = new MethodInvocation ( method . getName ( ) , method . getReturnType ( ) , method . getGenericReturnType ( ) , method . getParameterTypes ( ) , delegate , params ) ; invoker . invoke ( invocation ) ; if ( ! invocation . found ( ) ) { String methodName = method . getDeclaringClass ( ) . getSimpleName ( ) + <str> + method . getName ( ) + <str> ; throw Exceptions . unsupportedMethod ( methodName ) ; } return invocation . getResult ( ) ; } } private static class ChainedMethodInvoker implements MethodInvoker { private final MethodInvoker [ ] invokers ; private ChainedMethodInvoker ( MethodInvoker . . . invokers ) { this . invokers = invokers ; } public void invoke ( MethodInvocation method ) throws Throwable { for ( int i = <int> ; ! method . found ( ) & & i < invokers . length ; i + + ) { MethodInvoker invoker = invokers [ i ] ; invoker . invoke ( method ) ; } } } private class AdaptingMethodInvoker implements MethodInvoker { private final Action < ? super SourceObjectMapping > mapping ; private final MethodInvoker next ; private AdaptingMethodInvoker ( Action < ? super SourceObjectMapping > mapping , MethodInvoker next ) { this . mapping = mapping ; this . next = next ; } public void invoke ( MethodInvocation invocation ) throws Throwable { next . invoke ( invocation ) ; if ( invocation . found ( ) & & invocation . getResult ( ) ! = null ) { invocation . setResult ( convert ( invocation . getResult ( ) , invocation . getGenericReturnType ( ) ) ) ; } } private Object convert ( Object value , Type targetType ) { if ( targetType instanceof ParameterizedType ) { ParameterizedType parameterizedTargetType = ( ParameterizedType ) targetType ; if ( parameterizedTargetType . getRawType ( ) instanceof Class ) { Class < ? > rawClass = ( Class < ? > ) parameterizedTargetType . getRawType ( ) ; if ( Iterable . class . isAssignableFrom ( rawClass ) ) { Type targetElementType = getElementType ( parameterizedTargetType , <int> ) ; Collection < Object > convertedElements = collectionMapper . createEmptyCollection ( rawClass ) ; for ( Object element : ( Iterable < ? > ) value ) { convertedElements . add ( convert ( element , targetElementType ) ) ; } if ( rawClass . equals ( DomainObjectSet . class ) ) { return new ImmutableDomainObjectSet ( convertedElements ) ; } else { return convertedElements ; } } if ( Map . class . isAssignableFrom ( rawClass ) ) { Type targetKeyType = getElementType ( parameterizedTargetType , <int> ) ; Type targetValueType = getElementType ( parameterizedTargetType , <int> ) ; Map < Object , Object > convertedElements = collectionMapper . createEmptyMap ( rawClass ) ; for ( Map . Entry < ? , ? > entry : ( ( Map < ? , ? > ) value ) . entrySet ( ) ) { convertedElements . put ( convert ( entry . getKey ( ) , targetKeyType ) , convert ( entry . getValue ( ) , targetValueType ) ) ; } return convertedElements ; } } } if ( targetType instanceof Class ) { if ( ( ( Class ) targetType ) . isPrimitive ( ) ) { return value ; } return adapt ( ( Class ) targetType , value , mapping ) ; } throw new UnsupportedOperationException ( String . format ( <str> , value . getClass ( ) , targetType ) ) ; } private Type getElementType ( ParameterizedType type , int index ) { Type elementType = type . getActualTypeArguments ( ) [ index ] ; if ( elementType instanceof WildcardType ) { WildcardType wildcardType = ( WildcardType ) elementType ; return wildcardType . getUpperBounds ( ) [ <int> ] ; } return elementType ; } } private class ReflectionMethodInvoker implements MethodInvoker { public void invoke ( MethodInvocation invocation ) throws Throwable { Method targetMethod = locateMethod ( invocation ) ; if ( targetMethod = = null ) { return ; } Object returnValue ; try { returnValue = targetMethod . invoke ( invocation . getDelegate ( ) , invocation . getParameters ( ) ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } invocation . setResult ( returnValue ) ; } private Method locateMethod ( MethodInvocation invocation ) { Class < ? > sourceClass = invocation . getDelegate ( ) . getClass ( ) ; Method match ; try { match = sourceClass . getMethod ( invocation . getName ( ) , invocation . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException e ) { return null ; } LinkedList < Class < ? > > queue = new LinkedList < Class < ? > > ( ) ; queue . add ( sourceClass ) ; while ( ! queue . isEmpty ( ) ) { Class < ? > c = queue . removeFirst ( ) ; try { match = c . getMethod ( invocation . getName ( ) , invocation . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException e ) { } for ( Class < ? > interfaceType : c . getInterfaces ( ) ) { queue . addFirst ( interfaceType ) ; } if ( c . getSuperclass ( ) ! = null ) { queue . addFirst ( c . getSuperclass ( ) ) ; } } match . setAccessible ( true ) ; return match ; } } private static class PropertyCachingMethodInvoker implements MethodInvoker { private final Map < String , Object > properties = new HashMap < String , Object > ( ) ; private final Set < String > unknown = new HashSet < String > ( ) ; private final MethodInvoker next ; private PropertyCachingMethodInvoker ( MethodInvoker next ) { this . next = next ; } public void invoke ( MethodInvocation method ) throws Throwable { if ( ( GETTER_METHOD . matcher ( method . getName ( ) ) . matches ( ) | | IS_METHOD . matcher ( method . getName ( ) ) . matches ( ) ) & & method . getParameterTypes ( ) . length = = <int> ) { if ( properties . containsKey ( method . getName ( ) ) ) { method . setResult ( properties . get ( method . getName ( ) ) ) ; return ; } if ( unknown . contains ( method . getName ( ) ) ) { return ; } Object value ; next . invoke ( method ) ; if ( ! method . found ( ) ) { unknown . add ( method . getName ( ) ) ; return ; } value = method . getResult ( ) ; properties . put ( method . getName ( ) , value ) ; return ; } next . invoke ( method ) ; } } private static class SafeMethodInvoker implements MethodInvoker { private final MethodInvoker next ; private SafeMethodInvoker ( MethodInvoker next ) { this . next = next ; } public void invoke ( MethodInvocation invocation ) throws Throwable { next . invoke ( invocation ) ; if ( invocation . found ( ) | | invocation . getParameterTypes ( ) . length ! = <int> ) { return ; } if ( ! GETTER_METHOD . matcher ( invocation . getName ( ) ) . matches ( ) & & ! IS_METHOD . matcher ( invocation . getName ( ) ) . matches ( ) ) { return ; } MethodInvocation getterInvocation = new MethodInvocation ( invocation . getName ( ) , invocation . getReturnType ( ) , invocation . getGenericReturnType ( ) , new Class [ <int> ] , invocation . getDelegate ( ) , EMPTY ) ; next . invoke ( getterInvocation ) ; if ( getterInvocation . found ( ) & & getterInvocation . getResult ( ) ! = null ) { invocation . setResult ( getterInvocation . getResult ( ) ) ; } else { invocation . setResult ( invocation . getParameters ( ) [ <int> ] ) ; } } } private static class SupportedPropertyInvoker implements MethodInvoker { private final MethodInvoker next ; private SupportedPropertyInvoker ( MethodInvoker next ) { this . next = next ; } public void invoke ( MethodInvocation invocation ) throws Throwable { Matcher matcher = IS_SUPPORT_METHOD . matcher ( invocation . getName ( ) ) ; if ( ! matcher . matches ( ) ) { next . invoke ( invocation ) ; return ; } String getterName = String . format ( <str> , matcher . group ( <int> ) ) ; MethodInvocation getterInvocation = new MethodInvocation ( getterName , invocation . getReturnType ( ) , invocation . getGenericReturnType ( ) , new Class [ <int> ] , invocation . getDelegate ( ) , EMPTY ) ; next . invoke ( getterInvocation ) ; invocation . setResult ( getterInvocation . found ( ) ) ; } } private static class MixInMethodInvoker implements MethodInvoker { private Object proxy ; private Object instance ; private final Class < ? > mixInClass ; private final MethodInvoker next ; private final ThreadLocal < MethodInvocation > current = new ThreadLocal < MethodInvocation > ( ) ; public MixInMethodInvoker ( Class < ? > mixInClass , MethodInvoker next ) { this . mixInClass = mixInClass ; this . next = next ; } public void invoke ( MethodInvocation invocation ) throws Throwable { if ( current . get ( ) ! = null ) { return ; } if ( instance = = null ) { instance = DirectInstantiator . INSTANCE . newInstance ( mixInClass , proxy ) ; } MethodInvocation beanInvocation = new MethodInvocation ( invocation . getName ( ) , invocation . getReturnType ( ) , invocation . getGenericReturnType ( ) , invocation . getParameterTypes ( ) , instance , invocation . getParameters ( ) ) ; current . set ( beanInvocation ) ; try { next . invoke ( beanInvocation ) ; } finally { current . set ( null ) ; } if ( beanInvocation . found ( ) ) { invocation . setResult ( beanInvocation . getResult ( ) ) ; } } public void setProxy ( Object proxy ) { this . proxy = proxy ; } public Object getProxy ( ) { return proxy ; } } } 
