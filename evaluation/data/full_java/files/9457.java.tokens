package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . math . MathPreconditions . checkNoOverflow ; import static com . google . common . math . MathPreconditions . checkNonNegative ; import static com . google . common . math . MathPreconditions . checkPositive ; import static com . google . common . math . MathPreconditions . checkRoundingUnnecessary ; import static java . lang . Math . abs ; import static java . lang . Math . min ; import static java . math . RoundingMode . HALF_EVEN ; import static java . math . RoundingMode . HALF_UP ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible ( emulated = true ) public final class IntMath { public static boolean isPowerOfTwo ( int x ) { return x > <int> & ( x & ( x - <int> ) ) = = <int> ; } @VisibleForTesting static int lessThanBranchFree ( int x , int y ) { return ~ ~ ( x - y ) > > > ( Integer . SIZE - <int> ) ; } @SuppressWarnings ( <str> ) public static int log2 ( int x , RoundingMode mode ) { checkPositive ( <str> , x ) ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; case DOWN : case FLOOR : return ( Integer . SIZE - <int> ) - Integer . numberOfLeadingZeros ( x ) ; case UP : case CEILING : return Integer . SIZE - Integer . numberOfLeadingZeros ( x - <int> ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : int leadingZeros = Integer . numberOfLeadingZeros ( x ) ; int cmp = MAX_POWER_OF_SQRT2_UNSIGNED > > > leadingZeros ; int logFloor = ( Integer . SIZE - <int> ) - leadingZeros ; return logFloor + lessThanBranchFree ( cmp , x ) ; default: throw new AssertionError ( ) ; } } @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = <hex> ; @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static int log10 ( int x , RoundingMode mode ) { checkPositive ( <str> , x ) ; int logFloor = log10Floor ( x ) ; int floorPow = powersOf10 [ logFloor ] ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( x = = floorPow ) ; case FLOOR : case DOWN : return logFloor ; case CEILING : case UP : return logFloor + lessThanBranchFree ( floorPow , x ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : return logFloor + lessThanBranchFree ( halfPowersOf10 [ logFloor ] , x ) ; default : throw new AssertionError ( ) ; } } private static int log10Floor ( int x ) { int y = maxLog10ForLeadingZeros [ Integer . numberOfLeadingZeros ( x ) ] ; return y - lessThanBranchFree ( x , powersOf10 [ y ] ) ; } @VisibleForTesting static final byte [ ] maxLog10ForLeadingZeros = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @VisibleForTesting static final int [ ] powersOf10 = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @VisibleForTesting static final int [ ] halfPowersOf10 = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , Integer . MAX_VALUE } ; @GwtIncompatible ( <str> ) public static int pow ( int b , int k ) { checkNonNegative ( <str> , k ) ; switch ( b ) { case <int> : return ( k = = <int> ) ? <int> : <int> ; case <int> : return <int> ; case ( - <int> ) : return ( ( k & <int> ) = = <int> ) ? <int> : - <int> ; case <int> : return ( k < Integer . SIZE ) ? ( <int> < < k ) : <int> ; case ( - <int> ) : if ( k < Integer . SIZE ) { return ( ( k & <int> ) = = <int> ) ? ( <int> < < k ) : - ( <int> < < k ) ; } else { return <int> ; } default : } for ( int accum = <int> ; ; k > > = <int> ) { switch ( k ) { case <int> : return accum ; case <int> : return b * accum ; default : accum * = ( ( k & <int> ) = = <int> ) ? <int> : b ; b * = b ; } } } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static int sqrt ( int x , RoundingMode mode ) { checkNonNegative ( <str> , x ) ; int sqrtFloor = sqrtFloor ( x ) ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( sqrtFloor * sqrtFloor = = x ) ; case FLOOR : case DOWN : return sqrtFloor ; case CEILING : case UP : return sqrtFloor + lessThanBranchFree ( sqrtFloor * sqrtFloor , x ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor ; return sqrtFloor + lessThanBranchFree ( halfSquare , x ) ; default : throw new AssertionError ( ) ; } } private static int sqrtFloor ( int x ) { return ( int ) Math . sqrt ( x ) ; } @SuppressWarnings ( <str> ) public static int divide ( int p , int q , RoundingMode mode ) { checkNotNull ( mode ) ; if ( q = = <int> ) { throw new ArithmeticException ( <str> ) ; } int div = p / q ; int rem = p - q * div ; if ( rem = = <int> ) { return div ; } int signum = <int> | ( ( p ^ q ) > > ( Integer . SIZE - <int> ) ) ; boolean increment ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( rem = = <int> ) ; case DOWN : increment = false ; break ; case UP : increment = true ; break ; case CEILING : increment = signum > <int> ; break ; case FLOOR : increment = signum < <int> ; break ; case HALF_EVEN : case HALF_DOWN : case HALF_UP : int absRem = abs ( rem ) ; int cmpRemToHalfDivisor = absRem - ( abs ( q ) - absRem ) ; if ( cmpRemToHalfDivisor = = <int> ) { increment = ( mode = = HALF_UP | | ( mode = = HALF_EVEN & ( div & <int> ) ! = <int> ) ) ; } else { increment = cmpRemToHalfDivisor > <int> ; } break ; default : throw new AssertionError ( ) ; } return increment ? div + signum : div ; } public static int mod ( int x , int m ) { if ( m < = <int> ) { throw new ArithmeticException ( <str> + m + <str> ) ; } int result = x % m ; return ( result > = <int> ) ? result : result + m ; } public static int gcd ( int a , int b ) { checkNonNegative ( <str> , a ) ; checkNonNegative ( <str> , b ) ; if ( a = = <int> ) { return b ; } else if ( b = = <int> ) { return a ; } int aTwos = Integer . numberOfTrailingZeros ( a ) ; a > > = aTwos ; int bTwos = Integer . numberOfTrailingZeros ( b ) ; b > > = bTwos ; while ( a ! = b ) { int delta = a - b ; int minDeltaOrZero = delta & ( delta > > ( Integer . SIZE - <int> ) ) ; a = delta - minDeltaOrZero - minDeltaOrZero ; b + = minDeltaOrZero ; a > > = Integer . numberOfTrailingZeros ( a ) ; } return a < < min ( aTwos , bTwos ) ; } public static int checkedAdd ( int a , int b ) { long result = ( long ) a + b ; checkNoOverflow ( result = = ( int ) result ) ; return ( int ) result ; } public static int checkedSubtract ( int a , int b ) { long result = ( long ) a - b ; checkNoOverflow ( result = = ( int ) result ) ; return ( int ) result ; } public static int checkedMultiply ( int a , int b ) { long result = ( long ) a * b ; checkNoOverflow ( result = = ( int ) result ) ; return ( int ) result ; } public static int checkedPow ( int b , int k ) { checkNonNegative ( <str> , k ) ; switch ( b ) { case <int> : return ( k = = <int> ) ? <int> : <int> ; case <int> : return <int> ; case ( - <int> ) : return ( ( k & <int> ) = = <int> ) ? <int> : - <int> ; case <int> : checkNoOverflow ( k < Integer . SIZE - <int> ) ; return <int> < < k ; case ( - <int> ) : checkNoOverflow ( k < Integer . SIZE ) ; return ( ( k & <int> ) = = <int> ) ? <int> < < k : - <int> < < k ; default : } int accum = <int> ; while ( true ) { switch ( k ) { case <int> : return accum ; case <int> : return checkedMultiply ( accum , b ) ; default : if ( ( k & <int> ) ! = <int> ) { accum = checkedMultiply ( accum , b ) ; } k > > = <int> ; if ( k > <int> ) { checkNoOverflow ( - FLOOR_SQRT_MAX_INT < = b & b < = FLOOR_SQRT_MAX_INT ) ; b * = b ; } } } } @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = <int> ; public static int factorial ( int n ) { checkNonNegative ( <str> , n ) ; return ( n < factorials . length ) ? factorials [ n ] : Integer . MAX_VALUE ; } private static final int [ ] factorials = { <int> , <int> , <int> * <int> , <int> * <int> * <int> , <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> } ; @GwtIncompatible ( <str> ) public static int binomial ( int n , int k ) { checkNonNegative ( <str> , n ) ; checkNonNegative ( <str> , k ) ; checkArgument ( k < = n , <str> , k , n ) ; if ( k > ( n > > <int> ) ) { k = n - k ; } if ( k > = biggestBinomials . length | | n > biggestBinomials [ k ] ) { return Integer . MAX_VALUE ; } switch ( k ) { case <int> : return <int> ; case <int> : return n ; default : long result = <int> ; for ( int i = <int> ; i < k ; i + + ) { result * = n - i ; result / = i + <int> ; } return ( int ) result ; } } @VisibleForTesting static int [ ] biggestBinomials = { Integer . MAX_VALUE , Integer . MAX_VALUE , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; public static int mean ( int x , int y ) { return ( x & y ) + ( ( x ^ y ) > > <int> ) ; } private IntMath ( ) { } } 
