package com . google . common . cache ; import static com . google . common . base . Preconditions . checkState ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . cache . LocalCache . ReferenceEntry ; import com . google . common . cache . LocalCache . Segment ; import java . util . concurrent . atomic . AtomicReferenceArray ; public class SegmentBenchmark { @Param ( { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) int capacity ; private Segment < Object , Object > segment ; @BeforeExperiment void setUp ( ) { LocalCache < Object , Object > cache = new LocalCache < Object , Object > ( CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . initialCapacity ( capacity ) , null ) ; checkState ( cache . segments . length = = <int> ) ; segment = cache . segments [ <int> ] ; checkState ( segment . table . length ( ) = = capacity ) ; for ( int i = <int> ; i < segment . threshold ; i + + ) { cache . put ( new Object ( ) , new Object ( ) ) ; } checkState ( segment . table . length ( ) = = capacity ) ; } @Benchmark int time ( int reps ) { int dummy = <int> ; AtomicReferenceArray < ReferenceEntry < Object , Object > > oldTable = segment . table ; for ( int i = <int> ; i < reps ; i + + ) { segment . expand ( ) ; segment . table = oldTable ; dummy + = segment . count ; } return dummy ; } } 
