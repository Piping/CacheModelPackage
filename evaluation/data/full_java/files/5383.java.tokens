package org . elasticsearch . action . search . type ; import org . apache . lucene . search . ScoreDoc ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . search . ReduceSearchPhaseException ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchScrollRequest ; import org . elasticsearch . action . search . ShardSearchFailure ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . AtomicArray ; import org . elasticsearch . search . action . SearchServiceTransportAction ; import org . elasticsearch . search . controller . SearchPhaseController ; import org . elasticsearch . search . fetch . QueryFetchSearchResult ; import org . elasticsearch . search . fetch . ScrollQueryFetchSearchResult ; import org . elasticsearch . search . internal . InternalScrollSearchRequest ; import org . elasticsearch . search . internal . InternalSearchResponse ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . action . search . type . TransportSearchHelper . internalScrollSearchRequest ; public class TransportSearchScrollQueryAndFetchAction extends AbstractComponent { private final ClusterService clusterService ; private final SearchServiceTransportAction searchService ; private final SearchPhaseController searchPhaseController ; @Inject public TransportSearchScrollQueryAndFetchAction ( Settings settings , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { super ( settings ) ; this . clusterService = clusterService ; this . searchService = searchService ; this . searchPhaseController = searchPhaseController ; } public void execute ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { new AsyncAction ( request , scrollId , listener ) . start ( ) ; } private class AsyncAction extends AbstractAsyncAction { private final SearchScrollRequest request ; private final ActionListener < SearchResponse > listener ; private final ParsedScrollId scrollId ; private final DiscoveryNodes nodes ; private volatile AtomicArray < ShardSearchFailure > shardFailures ; private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private final AtomicInteger successfulOps ; private final AtomicInteger counter ; private AsyncAction ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { this . request = request ; this . listener = listener ; this . scrollId = scrollId ; this . nodes = clusterService . state ( ) . nodes ( ) ; this . successfulOps = new AtomicInteger ( scrollId . getContext ( ) . length ) ; this . counter = new AtomicInteger ( scrollId . getContext ( ) . length ) ; this . queryFetchResults = new AtomicArray < > ( scrollId . getContext ( ) . length ) ; } protected final ShardSearchFailure [ ] buildShardFailures ( ) { if ( shardFailures = = null ) { return ShardSearchFailure . EMPTY_ARRAY ; } List < AtomicArray . Entry < ShardSearchFailure > > entries = shardFailures . asList ( ) ; ShardSearchFailure [ ] failures = new ShardSearchFailure [ entries . size ( ) ] ; for ( int i = <int> ; i < failures . length ; i + + ) { failures [ i ] = entries . get ( i ) . value ; } return failures ; } protected final void addShardFailure ( final int shardIndex , ShardSearchFailure failure ) { if ( shardFailures = = null ) { shardFailures = new AtomicArray < > ( scrollId . getContext ( ) . length ) ; } shardFailures . set ( shardIndex , failure ) ; } public void start ( ) { if ( scrollId . getContext ( ) . length = = <int> ) { listener . onFailure ( new SearchPhaseExecutionException ( <str> , <str> , ShardSearchFailure . EMPTY_ARRAY ) ) ; return ; } ScrollIdForNode [ ] context = scrollId . getContext ( ) ; for ( int i = <int> ; i < context . length ; i + + ) { ScrollIdForNode target = context [ i ] ; DiscoveryNode node = nodes . get ( target . getNode ( ) ) ; if ( node ! = null ) { executePhase ( i , node , target . getScrollId ( ) ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + target . getNode ( ) + <str> + scrollId . getSource ( ) + <str> ) ; } successfulOps . decrementAndGet ( ) ; if ( counter . decrementAndGet ( ) = = <int> ) { finishHim ( ) ; } } } for ( ScrollIdForNode target : scrollId . getContext ( ) ) { DiscoveryNode node = nodes . get ( target . getNode ( ) ) ; if ( node = = null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + target . getNode ( ) + <str> + scrollId . getSource ( ) + <str> ) ; } successfulOps . decrementAndGet ( ) ; if ( counter . decrementAndGet ( ) = = <int> ) { finishHim ( ) ; } } } } void executePhase ( final int shardIndex , DiscoveryNode node , final long searchId ) { InternalScrollSearchRequest internalRequest = internalScrollSearchRequest ( searchId , request ) ; searchService . sendExecuteFetch ( node , internalRequest , new ActionListener < ScrollQueryFetchSearchResult > ( ) { @Override public void onResponse ( ScrollQueryFetchSearchResult result ) { queryFetchResults . set ( shardIndex , result . result ( ) ) ; if ( counter . decrementAndGet ( ) = = <int> ) { finishHim ( ) ; } } @Override public void onFailure ( Throwable t ) { onPhaseFailure ( t , searchId , shardIndex ) ; } } ) ; } private void onPhaseFailure ( Throwable t , long searchId , int shardIndex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , t , searchId ) ; } addShardFailure ( shardIndex , new ShardSearchFailure ( t ) ) ; successfulOps . decrementAndGet ( ) ; if ( counter . decrementAndGet ( ) = = <int> ) { if ( successfulOps . get ( ) = = <int> ) { listener . onFailure ( new SearchPhaseExecutionException ( <str> , <str> , t , buildShardFailures ( ) ) ) ; } else { finishHim ( ) ; } } } private void finishHim ( ) { try { innerFinishHim ( ) ; } catch ( Throwable e ) { listener . onFailure ( new ReduceSearchPhaseException ( <str> , <str> , e , buildShardFailures ( ) ) ) ; } } private void innerFinishHim ( ) throws Exception { ScoreDoc [ ] sortedShardList = searchPhaseController . sortDocs ( true , queryFetchResults ) ; final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryFetchResults , queryFetchResults , request ) ; String scrollId = null ; if ( request . scroll ( ) ! = null ) { scrollId = request . scrollId ( ) ; } listener . onResponse ( new SearchResponse ( internalResponse , scrollId , this . scrollId . getContext ( ) . length , successfulOps . get ( ) , buildTookInMillis ( ) , buildShardFailures ( ) ) ) ; } } } 
