package org . elasticsearch . index . mapper . internal ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . IndexableField ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . MetadataFieldMapper ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . indices . IndicesModule ; import org . elasticsearch . indices . mapper . MapperRegistry ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . SortedSet ; import java . util . TreeSet ; public class FieldNamesFieldMapperTests extends ESSingleNodeTestCase { private static SortedSet < String > extract ( String path ) { SortedSet < String > set = new TreeSet < > ( ) ; for ( String fieldName : FieldNamesFieldMapper . extractFieldNames ( path ) ) { set . add ( fieldName ) ; } return set ; } private static < T > SortedSet < T > set ( T . . . values ) { return new TreeSet < > ( Arrays . asList ( values ) ) ; } void assertFieldNames ( SortedSet < String > expected , ParsedDocument doc ) { String [ ] got = doc . rootDoc ( ) . getValues ( <str> ) ; assertEquals ( expected , set ( got ) ) ; } public void testExtractFieldNames ( ) { assertEquals ( set ( <str> ) , extract ( <str> ) ) ; assertEquals ( set ( <str> , <str> ) , extract ( <str> ) ) ; assertEquals ( set ( <str> , <str> , <str> ) , extract ( <str> ) ) ; assertEquals ( set ( <str> , <str> ) , extract ( <str> ) ) ; assertEquals ( set ( <str> , <str> ) , extract ( <str> ) ) ; assertEquals ( set ( <str> , <str> , <str> ) , extract ( <str> ) ) ; } public void testFieldType ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . hasDocValues ( ) ) ; assertEquals ( IndexOptions . DOCS , fieldNamesMapper . fieldType ( ) . indexOptions ( ) ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . tokenized ( ) ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . stored ( ) ) ; assertTrue ( fieldNamesMapper . fieldType ( ) . omitNorms ( ) ) ; } public void testInjectIntoDocDuringParsing ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; assertFieldNames ( set ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , doc ) ; } public void testExplicitEnabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertTrue ( fieldNamesMapper . fieldType ( ) . isEnabled ( ) ) ; ParsedDocument doc = docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertFieldNames ( set ( <str> , <str> , <str> , <str> , <str> , <str> ) , doc ) ; } public void testDisabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . isEnabled ( ) ) ; ParsedDocument doc = docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNull ( doc . rootDoc ( ) . get ( <str> ) ) ; } public void testPre13Disabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_2_4 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . isEnabled ( ) ) ; } public void testDisablingBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertFalse ( fieldNamesMapper . fieldType ( ) . isEnabled ( ) ) ; ParsedDocument doc = docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNull ( doc . rootDoc ( ) . get ( <str> ) ) ; } public void testFieldTypeSettingsBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldNamesFieldMapper fieldNamesMapper = docMapper . metadataMapper ( FieldNamesFieldMapper . class ) ; assertTrue ( fieldNamesMapper . fieldType ( ) . stored ( ) ) ; } public void testMergingMappings ( ) throws Exception { String enabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String disabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper mapperEnabled = parser . parse ( enabledMapping ) ; DocumentMapper mapperDisabled = parser . parse ( disabledMapping ) ; mapperEnabled . merge ( mapperDisabled . mapping ( ) , false , false ) ; assertFalse ( mapperEnabled . metadataMapper ( FieldNamesFieldMapper . class ) . fieldType ( ) . isEnabled ( ) ) ; mapperEnabled = parser . parse ( enabledMapping ) ; mapperDisabled . merge ( mapperEnabled . mapping ( ) , false , false ) ; assertTrue ( mapperEnabled . metadataMapper ( FieldNamesFieldMapper . class ) . fieldType ( ) . isEnabled ( ) ) ; } private static class DummyMetadataFieldMapper extends MetadataFieldMapper { public static class TypeParser implements MetadataFieldMapper . TypeParser { @Override public Builder < ? , ? > parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { return new MetadataFieldMapper . Builder < Builder , DummyMetadataFieldMapper > ( <str> , FIELD_TYPE ) { @Override public DummyMetadataFieldMapper build ( BuilderContext context ) { return new DummyMetadataFieldMapper ( context . indexSettings ( ) ) ; } } ; } @Override public MetadataFieldMapper getDefault ( Settings indexSettings , MappedFieldType fieldType , String typeName ) { return new DummyMetadataFieldMapper ( indexSettings ) ; } } private static class DummyFieldType extends MappedFieldType { public DummyFieldType ( ) { super ( ) ; } private DummyFieldType ( MappedFieldType other ) { super ( other ) ; } @Override public MappedFieldType clone ( ) { return new DummyFieldType ( this ) ; } @Override public String typeName ( ) { return <str> ; } } private static final MappedFieldType FIELD_TYPE = new DummyFieldType ( ) ; static { FIELD_TYPE . setTokenized ( false ) ; FIELD_TYPE . setIndexOptions ( IndexOptions . DOCS ) ; FIELD_TYPE . setNames ( new MappedFieldType . Names ( <str> ) ) ; FIELD_TYPE . freeze ( ) ; } protected DummyMetadataFieldMapper ( Settings indexSettings ) { super ( <str> , FIELD_TYPE , FIELD_TYPE , indexSettings ) ; } @Override public void preParse ( ParseContext context ) throws IOException { } @Override public void postParse ( ParseContext context ) throws IOException { context . doc ( ) . add ( new Field ( <str> , <str> , FIELD_TYPE ) ) ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { } @Override protected String contentType ( ) { return <str> ; } } public void testSeesFieldsFromPlugins ( ) throws IOException { IndexService indexService = createIndex ( <str> ) ; IndicesModule indicesModule = new IndicesModule ( ) ; indicesModule . registerMetadataMapper ( <str> , new DummyMetadataFieldMapper . TypeParser ( ) ) ; final MapperRegistry mapperRegistry = indicesModule . getMapperRegistry ( ) ; MapperService mapperService = new MapperService ( indexService . getIndexSettings ( ) , indexService . analysisService ( ) , indexService . similarityService ( ) , mapperRegistry ) ; DocumentMapperParser parser = new DocumentMapperParser ( indexService . getIndexSettings ( ) , mapperService , indexService . analysisService ( ) , indexService . similarityService ( ) , mapperRegistry ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = parser . parse ( mapping ) ; ParsedDocument parsedDocument = mapper . parse ( <str> , <str> , <str> , new BytesArray ( <str> ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( FieldNamesFieldMapper . NAME ) ; boolean found = false ; for ( IndexableField f : fields ) { if ( <str> . equals ( f . stringValue ( ) ) ) { found = true ; break ; } } assertTrue ( <str> + Arrays . toString ( fields ) , found ) ; } } 
