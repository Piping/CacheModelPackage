package org . elasticsearch . index . shard ; import org . apache . lucene . codecs . DocValuesProducer ; import org . apache . lucene . index . CodecReader ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . FieldInfo ; import org . apache . lucene . index . FieldInfos ; import org . apache . lucene . index . FilterCodecReader ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . NumericDocValues ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . packed . GrowableWriter ; import org . apache . lucene . util . packed . PackedInts ; import org . elasticsearch . common . Numbers ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . mapper . internal . VersionFieldMapper ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; class VersionFieldUpgrader extends FilterCodecReader { final FieldInfos infos ; VersionFieldUpgrader ( CodecReader in ) { super ( in ) ; int fieldNumber = <int> ; for ( FieldInfo fi : in . getFieldInfos ( ) ) { fieldNumber = Math . max ( fieldNumber , fi . number + <int> ) ; } FieldInfo newInfo = new FieldInfo ( VersionFieldMapper . NAME , fieldNumber , false , false , false , IndexOptions . NONE , DocValuesType . NUMERIC , - <int> , Collections . < String , String > emptyMap ( ) ) ; newInfo . checkConsistency ( ) ; final ArrayList < FieldInfo > fieldInfoList = new ArrayList < > ( ) ; for ( FieldInfo info : in . getFieldInfos ( ) ) { if ( ! info . name . equals ( VersionFieldMapper . NAME ) ) { fieldInfoList . add ( info ) ; } } fieldInfoList . add ( newInfo ) ; infos = new FieldInfos ( fieldInfoList . toArray ( new FieldInfo [ fieldInfoList . size ( ) ] ) ) ; } static CodecReader wrap ( CodecReader reader ) throws IOException { final FieldInfos fieldInfos = reader . getFieldInfos ( ) ; final FieldInfo versionInfo = fieldInfos . fieldInfo ( VersionFieldMapper . NAME ) ; if ( versionInfo ! = null & & versionInfo . getDocValuesType ( ) ! = DocValuesType . NONE ) { return reader ; } final Terms terms = reader . terms ( UidFieldMapper . NAME ) ; if ( terms = = null | | ! terms . hasPayloads ( ) ) { return reader ; } return new VersionFieldUpgrader ( reader ) ; } @Override public FieldInfos getFieldInfos ( ) { return infos ; } @Override public DocValuesProducer getDocValuesReader ( ) { DocValuesProducer producer = in . getDocValuesReader ( ) ; if ( producer = = null ) { producer = FilterDocValuesProducer . EMPTY ; } return new UninvertedVersions ( producer , this ) ; } static class UninvertedVersions extends FilterDocValuesProducer { final CodecReader reader ; UninvertedVersions ( DocValuesProducer in , CodecReader reader ) { super ( in ) ; this . reader = reader ; } @Override public NumericDocValues getNumeric ( FieldInfo field ) throws IOException { if ( VersionFieldMapper . NAME . equals ( field . name ) ) { final Terms terms = reader . terms ( UidFieldMapper . NAME ) ; final TermsEnum uids = terms . iterator ( ) ; final GrowableWriter versions = new GrowableWriter ( <int> , reader . maxDoc ( ) , PackedInts . COMPACT ) ; PostingsEnum dpe = null ; for ( BytesRef uid = uids . next ( ) ; uid ! = null ; uid = uids . next ( ) ) { dpe = uids . postings ( dpe , PostingsEnum . PAYLOADS ) ; assert terms . hasPayloads ( ) : <str> ; final Bits liveDocs = reader . getLiveDocs ( ) ; for ( int doc = dpe . nextDoc ( ) ; doc ! = DocIdSetIterator . NO_MORE_DOCS ; doc = dpe . nextDoc ( ) ) { if ( liveDocs ! = null & & liveDocs . get ( doc ) = = false ) { continue ; } dpe . nextPosition ( ) ; final BytesRef payload = dpe . getPayload ( ) ; if ( payload ! = null & & payload . length = = <int> ) { final long version = Numbers . bytesToLong ( payload ) ; versions . set ( doc , version ) ; break ; } } } return versions ; } else { return in . getNumeric ( field ) ; } } @Override public Bits getDocsWithField ( FieldInfo field ) throws IOException { if ( VersionFieldMapper . NAME . equals ( field . name ) ) { return new Bits . MatchAllBits ( reader . maxDoc ( ) ) ; } else { return in . getDocsWithField ( field ) ; } } @Override public DocValuesProducer getMergeInstance ( ) throws IOException { return new UninvertedVersions ( in . getMergeInstance ( ) , reader ) ; } } } 
