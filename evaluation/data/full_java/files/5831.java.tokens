package org . elasticsearch . common . inject . internal ; import org . elasticsearch . common . inject . Binder ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . Scope ; import org . elasticsearch . common . inject . spi . Element ; import org . elasticsearch . common . inject . spi . InstanceBinding ; import java . lang . annotation . Annotation ; import java . util . List ; import java . util . Objects ; public abstract class AbstractBindingBuilder < T > { public static final String IMPLEMENTATION_ALREADY_SET = <str> ; public static final String SINGLE_INSTANCE_AND_SCOPE = <str> ; public static final String SCOPE_ALREADY_SET = <str> ; public static final String BINDING_TO_NULL = <str> + <str> ; public static final String CONSTANT_VALUE_ALREADY_SET = <str> ; public static final String ANNOTATION_ALREADY_SPECIFIED = <str> ; protected static final Key < ? > NULL_KEY = Key . get ( Void . class ) ; protected List < Element > elements ; protected int position ; protected final Binder binder ; private BindingImpl < T > binding ; public AbstractBindingBuilder ( Binder binder , List < Element > elements , Object source , Key < T > key ) { this . binder = binder ; this . elements = elements ; this . position = elements . size ( ) ; this . binding = new UntargettedBindingImpl < > ( source , key , Scoping . UNSCOPED ) ; elements . add ( position , this . binding ) ; } protected BindingImpl < T > getBinding ( ) { return binding ; } protected BindingImpl < T > setBinding ( BindingImpl < T > binding ) { this . binding = binding ; elements . set ( position , binding ) ; return binding ; } protected BindingImpl < T > annotatedWithInternal ( Class < ? extends Annotation > annotationType ) { Objects . requireNonNull ( annotationType , <str> ) ; checkNotAnnotated ( ) ; return setBinding ( binding . withKey ( Key . get ( this . binding . getKey ( ) . getTypeLiteral ( ) , annotationType ) ) ) ; } protected BindingImpl < T > annotatedWithInternal ( Annotation annotation ) { Objects . requireNonNull ( annotation , <str> ) ; checkNotAnnotated ( ) ; return setBinding ( binding . withKey ( Key . get ( this . binding . getKey ( ) . getTypeLiteral ( ) , annotation ) ) ) ; } public void in ( final Class < ? extends Annotation > scopeAnnotation ) { Objects . requireNonNull ( scopeAnnotation , <str> ) ; checkNotScoped ( ) ; setBinding ( getBinding ( ) . withScoping ( Scoping . forAnnotation ( scopeAnnotation ) ) ) ; } public void in ( final Scope scope ) { Objects . requireNonNull ( scope , <str> ) ; checkNotScoped ( ) ; setBinding ( getBinding ( ) . withScoping ( Scoping . forInstance ( scope ) ) ) ; } public void asEagerSingleton ( ) { checkNotScoped ( ) ; setBinding ( getBinding ( ) . withScoping ( Scoping . EAGER_SINGLETON ) ) ; } protected boolean keyTypeIsSet ( ) { return ! Void . class . equals ( binding . getKey ( ) . getTypeLiteral ( ) . getType ( ) ) ; } protected void checkNotTargetted ( ) { if ( ! ( binding instanceof UntargettedBindingImpl ) ) { binder . addError ( IMPLEMENTATION_ALREADY_SET ) ; } } protected void checkNotAnnotated ( ) { if ( binding . getKey ( ) . getAnnotationType ( ) ! = null ) { binder . addError ( ANNOTATION_ALREADY_SPECIFIED ) ; } } protected void checkNotScoped ( ) { if ( binding instanceof InstanceBinding ) { binder . addError ( SINGLE_INSTANCE_AND_SCOPE ) ; return ; } if ( binding . getScoping ( ) . isExplicitlyScoped ( ) ) { binder . addError ( SCOPE_ALREADY_SET ) ; } } } 
