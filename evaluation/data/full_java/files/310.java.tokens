package org . apache . cassandra . db ; import java . io . IOException ; import java . security . MessageDigest ; import com . google . common . base . Objects ; import org . apache . cassandra . cache . IMeasurableMemory ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . ObjectSizes ; public class DeletionTime implements Comparable < DeletionTime > , IMeasurableMemory { private static final long EMPTY_SIZE = ObjectSizes . measure ( new DeletionTime ( <int> , <int> ) ) ; public static final DeletionTime LIVE = new DeletionTime ( Long . MIN_VALUE , Integer . MAX_VALUE ) ; public static final Serializer serializer = new Serializer ( ) ; private final long markedForDeleteAt ; private final int localDeletionTime ; public DeletionTime ( long markedForDeleteAt , int localDeletionTime ) { this . markedForDeleteAt = markedForDeleteAt ; this . localDeletionTime = localDeletionTime ; } public long markedForDeleteAt ( ) { return markedForDeleteAt ; } public int localDeletionTime ( ) { return localDeletionTime ; } public boolean isLive ( ) { return markedForDeleteAt ( ) = = Long . MIN_VALUE & & localDeletionTime ( ) = = Integer . MAX_VALUE ; } public void digest ( MessageDigest digest ) { FBUtilities . updateWithLong ( digest , markedForDeleteAt ( ) ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof DeletionTime ) ) return false ; DeletionTime that = ( DeletionTime ) o ; return markedForDeleteAt ( ) = = that . markedForDeleteAt ( ) & & localDeletionTime ( ) = = that . localDeletionTime ( ) ; } @Override public final int hashCode ( ) { return Objects . hashCode ( markedForDeleteAt ( ) , localDeletionTime ( ) ) ; } @Override public String toString ( ) { return String . format ( <str> , markedForDeleteAt ( ) , localDeletionTime ( ) ) ; } public int compareTo ( DeletionTime dt ) { if ( markedForDeleteAt ( ) < dt . markedForDeleteAt ( ) ) return - <int> ; else if ( markedForDeleteAt ( ) > dt . markedForDeleteAt ( ) ) return <int> ; else if ( localDeletionTime ( ) < dt . localDeletionTime ( ) ) return - <int> ; else if ( localDeletionTime ( ) > dt . localDeletionTime ( ) ) return <int> ; else return <int> ; } public boolean supersedes ( DeletionTime dt ) { return markedForDeleteAt ( ) > dt . markedForDeleteAt ( ) | | ( markedForDeleteAt ( ) = = dt . markedForDeleteAt ( ) & & localDeletionTime ( ) > dt . localDeletionTime ( ) ) ; } public boolean deletes ( LivenessInfo info ) { return deletes ( info . timestamp ( ) ) ; } public boolean deletes ( Cell cell ) { return deletes ( cell . timestamp ( ) ) ; } public boolean deletes ( long timestamp ) { return timestamp < = markedForDeleteAt ( ) ; } public int dataSize ( ) { return <int> ; } public long unsharedHeapSize ( ) { return EMPTY_SIZE ; } public static class Serializer implements ISerializer < DeletionTime > { public void serialize ( DeletionTime delTime , DataOutputPlus out ) throws IOException { out . writeInt ( delTime . localDeletionTime ( ) ) ; out . writeLong ( delTime . markedForDeleteAt ( ) ) ; } public DeletionTime deserialize ( DataInputPlus in ) throws IOException { int ldt = in . readInt ( ) ; long mfda = in . readLong ( ) ; return mfda = = Long . MIN_VALUE & & ldt = = Integer . MAX_VALUE ? LIVE : new DeletionTime ( mfda , ldt ) ; } public void skip ( DataInputPlus in ) throws IOException { in . skipBytesFully ( <int> + <int> ) ; } public long serializedSize ( DeletionTime delTime ) { return TypeSizes . sizeof ( delTime . localDeletionTime ( ) ) + TypeSizes . sizeof ( delTime . markedForDeleteAt ( ) ) ; } } } 
