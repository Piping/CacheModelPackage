package org . gradle . internal . service ; import org . gradle . internal . Factory ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . internal . reflect . ObjectInstantiationException ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; import java . util . * ; public class ServiceLocator { private final List < ClassLoader > classLoaders ; public ServiceLocator ( ClassLoader . . . classLoaders ) { this . classLoaders = Arrays . asList ( classLoaders ) ; } public < T > T get ( Class < T > serviceType ) throws UnknownServiceException { return getFactory ( serviceType ) . create ( ) ; } public < T > List < T > getAll ( Class < T > serviceType ) throws UnknownServiceException { List < ServiceFactory < T > > factories = findFactoriesForServiceType ( serviceType ) ; ArrayList < T > services = new ArrayList < T > ( ) ; for ( ServiceFactory < T > factory : factories ) { services . add ( factory . create ( ) ) ; } return services ; } public < T > ServiceFactory < T > getFactory ( final Class < T > serviceType ) throws UnknownServiceException { ServiceFactory < T > factory = findFactory ( serviceType ) ; if ( factory = = null ) { throw new UnknownServiceException ( serviceType , String . format ( <str> , serviceType . getName ( ) , serviceType . getName ( ) ) ) ; } return factory ; } public < T > ServiceFactory < T > findFactory ( Class < T > serviceType ) { List < ServiceFactory < T > > factories = findFactoriesForServiceType ( serviceType ) ; if ( factories . isEmpty ( ) ) { return null ; } return factories . get ( <int> ) ; } private < T > List < ServiceFactory < T > > findFactoriesForServiceType ( Class < T > serviceType ) { List < Class < ? extends T > > implementationClasses ; try { implementationClasses = findServiceImplementations ( serviceType ) ; } catch ( ServiceLookupException e ) { throw e ; } catch ( Exception e ) { throw new ServiceLookupException ( String . format ( <str> , serviceType . getName ( ) ) , e ) ; } List < ServiceFactory < T > > factories = new ArrayList < ServiceFactory < T > > ( ) ; for ( Class < ? extends T > implementationClass : implementationClasses ) { factories . add ( new ServiceFactory < T > ( serviceType , implementationClass ) ) ; } return factories ; } private < T > List < Class < ? extends T > > findServiceImplementations ( Class < T > serviceType ) throws IOException { String resourceName = <str> + serviceType . getName ( ) ; Set < String > implementationClassNames = new HashSet < String > ( ) ; List < Class < ? extends T > > implementations = new ArrayList < Class < ? extends T > > ( ) ; for ( ClassLoader classLoader : classLoaders ) { Enumeration < URL > resources = classLoader . getResources ( resourceName ) ; while ( resources . hasMoreElements ( ) ) { URL resource = resources . nextElement ( ) ; List < String > implementationClassNamesFromResource ; try { implementationClassNamesFromResource = extractImplementationClassNames ( resource ) ; if ( implementationClassNamesFromResource . isEmpty ( ) ) { throw new RuntimeException ( String . format ( <str> , serviceType . getName ( ) ) ) ; } } catch ( Exception e ) { throw new ServiceLookupException ( String . format ( <str> , serviceType . getName ( ) , resource ) , e ) ; } for ( String implementationClassName : implementationClassNamesFromResource ) { if ( implementationClassNames . add ( implementationClassName ) ) { try { Class < ? > implClass = classLoader . loadClass ( implementationClassName ) ; if ( ! serviceType . isAssignableFrom ( implClass ) ) { throw new RuntimeException ( String . format ( <str> , implementationClassName , serviceType . getName ( ) ) ) ; } implementations . add ( implClass . asSubclass ( serviceType ) ) ; } catch ( Exception e ) { throw new ServiceLookupException ( String . format ( <str> , implementationClassName , serviceType . getName ( ) , resource ) , e ) ; } } } } } return implementations ; } private List < String > extractImplementationClassNames ( URL resource ) throws IOException { InputStream inputStream = resource . openStream ( ) ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream , <str> ) ) ; List < String > implemetationClassNames = new ArrayList < String > ( ) ; String line ; while ( ( line = reader . readLine ( ) ) ! = null ) { line = line . replaceAll ( <str> , <str> ) . trim ( ) ; if ( line . length ( ) > <int> ) { implemetationClassNames . add ( line ) ; } } return implemetationClassNames ; } finally { inputStream . close ( ) ; } } public static class ServiceFactory < T > implements Factory < T > { private final Class < T > serviceType ; private final Class < ? extends T > implementationClass ; public ServiceFactory ( Class < T > serviceType , Class < ? extends T > implementationClass ) { this . serviceType = serviceType ; this . implementationClass = implementationClass ; } public Class < ? extends T > getImplementationClass ( ) { return implementationClass ; } public T create ( ) { return newInstance ( ) ; } public T newInstance ( Object . . . params ) { try { return DirectInstantiator . instantiate ( implementationClass , params ) ; } catch ( ObjectInstantiationException t ) { throw new RuntimeException ( String . format ( <str> , serviceType . getName ( ) ) , t ) ; } } } } 
