package org . gradle . util ; import org . gradle . api . Action ; import org . gradle . internal . UncheckedException ; import java . io . IOException ; import java . io . InputStream ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DisconnectableInputStream extends BulkReadInputStream { private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final byte [ ] buffer ; private int readPos ; private int writePos ; private boolean closed ; private boolean inputFinished ; static class ThreadExecuter implements Action < Runnable > { public void execute ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( <str> ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } } public DisconnectableInputStream ( InputStream source ) { this ( source , <int> ) ; } public DisconnectableInputStream ( final InputStream source , int bufferLength ) { this ( source , new ThreadExecuter ( ) , bufferLength ) ; } DisconnectableInputStream ( InputStream source , Action < Runnable > executer ) { this ( source , executer , <int> ) ; } DisconnectableInputStream ( final InputStream source , Action < Runnable > executer , int bufferLength ) { buffer = new byte [ bufferLength ] ; Runnable consume = new Runnable ( ) { public void run ( ) { try { while ( true ) { int pos ; lock . lock ( ) ; try { while ( ! closed & & writePos = = buffer . length & & writePos ! = readPos ) { condition . await ( ) ; } assert writePos > = readPos ; if ( closed ) { inputFinished = true ; condition . signalAll ( ) ; return ; } if ( readPos = = writePos ) { readPos = <int> ; writePos = <int> ; } pos = writePos ; } finally { lock . unlock ( ) ; } int nread = source . read ( buffer , pos , buffer . length - pos ) ; lock . lock ( ) ; try { if ( nread > <int> ) { assert writePos > = readPos ; writePos + = nread ; assert buffer . length > = writePos ; condition . signalAll ( ) ; } if ( nread < <int> ) { inputFinished = true ; condition . signalAll ( ) ; return ; } } finally { lock . unlock ( ) ; } } } catch ( Throwable throwable ) { lock . lock ( ) ; try { inputFinished = true ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } throw UncheckedException . throwAsUncheckedException ( throwable ) ; } } } ; executer . execute ( consume ) ; } @Override public int read ( byte [ ] bytes , int pos , int count ) throws IOException { lock . lock ( ) ; try { while ( ! inputFinished & & ! closed & & readPos = = writePos ) { condition . await ( ) ; } if ( closed ) { return - <int> ; } if ( writePos > readPos ) { int nread = Math . min ( count , writePos - readPos ) ; System . arraycopy ( buffer , readPos , bytes , pos , nread ) ; readPos + = nread ; assert writePos > = readPos ; condition . signalAll ( ) ; return nread ; } assert inputFinished ; return - <int> ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { lock . unlock ( ) ; } } @Override public void close ( ) throws IOException { lock . lock ( ) ; try { closed = true ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } 
