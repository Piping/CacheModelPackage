package org . gradle . api . internal . classloading ; import org . gradle . api . GradleException ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Iterator ; public class LeakyOnJava7GroovySystemLoader implements GroovySystemLoader { private final static Logger LOG = Logging . getLogger ( LeakyOnJava7GroovySystemLoader . class ) ; private final Method removeFromGlobalClassValue ; private final Method globalClassSetIteratorMethod ; private final Object globalClassValue ; private final Object globalClassSetItems ; private final Field clazzField ; private final ClassLoader leakingLoader ; public LeakyOnJava7GroovySystemLoader ( ClassLoader leakingLoader ) throws Exception { this . leakingLoader = leakingLoader ; Class < ? > classInfoClass = leakingLoader . loadClass ( <str> ) ; Field globalClassValueField = classInfoClass . getDeclaredField ( <str> ) ; globalClassValueField . setAccessible ( true ) ; globalClassValue = globalClassValueField . get ( null ) ; removeFromGlobalClassValue = globalClassValueField . getType ( ) . getDeclaredMethod ( <str> , Class . class ) ; removeFromGlobalClassValue . setAccessible ( true ) ; Field globalClassSetField = classInfoClass . getDeclaredField ( <str> ) ; globalClassSetField . setAccessible ( true ) ; Object globalClassSet = globalClassSetField . get ( null ) ; globalClassSetField = globalClassSet . getClass ( ) . getDeclaredField ( <str> ) ; globalClassSetField . setAccessible ( true ) ; globalClassSetItems = globalClassSetField . get ( globalClassSet ) ; globalClassSetIteratorMethod = globalClassSetItems . getClass ( ) . getDeclaredMethod ( <str> ) ; clazzField = classInfoClass . getDeclaredField ( <str> ) ; clazzField . setAccessible ( true ) ; } @Override public void shutdown ( ) { if ( leakingLoader = = getClass ( ) . getClassLoader ( ) ) { throw new IllegalStateException ( <str> ) ; } try { Iterator < ? > it = globalClassSetIterator ( ) ; while ( it . hasNext ( ) ) { Object classInfo = it . next ( ) ; if ( classInfo ! = null ) { Class clazz = ( Class ) clazzField . get ( classInfo ) ; removeFromGlobalClassValue . invoke ( globalClassValue , clazz ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , clazz . getName ( ) , clazz . getClassLoader ( ) ) ) ; } } } } catch ( Exception e ) { throw new GradleException ( <str> + leakingLoader , e ) ; } } @Override public void discardTypesFrom ( ClassLoader classLoader ) { if ( classLoader = = leakingLoader ) { throw new IllegalStateException ( <str> ) ; } try { Iterator < ? > it = globalClassSetIterator ( ) ; while ( it . hasNext ( ) ) { Object classInfo = it . next ( ) ; if ( classInfo ! = null ) { Class clazz = ( Class ) clazzField . get ( classInfo ) ; if ( clazz . getClassLoader ( ) = = classLoader ) { removeFromGlobalClassValue . invoke ( globalClassValue , clazz ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , clazz . getName ( ) , clazz . getClassLoader ( ) ) ) ; } } } } } catch ( Exception e ) { throw new GradleException ( <str> + classLoader + <str> + leakingLoader , e ) ; } } private Iterator < ? > globalClassSetIterator ( ) throws IllegalAccessException , InvocationTargetException { return ( Iterator ) globalClassSetIteratorMethod . invoke ( globalClassSetItems ) ; } } 
