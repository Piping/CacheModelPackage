package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . btree . BTreeSet ; public abstract class MultiCBuilder { protected final ClusteringComparator comparator ; protected int size ; protected boolean built ; protected boolean containsNull ; protected boolean containsUnset ; protected boolean hasMissingElements ; protected MultiCBuilder ( ClusteringComparator comparator ) { this . comparator = comparator ; } public static MultiCBuilder create ( ClusteringComparator comparator , boolean forMultipleValues ) { return forMultipleValues ? new MultiClusteringBuilder ( comparator ) : new OneClusteringBuilder ( comparator ) ; } public abstract MultiCBuilder addElementToAll ( ByteBuffer value ) ; public abstract MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) ; public abstract MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) ; protected void checkUpdateable ( ) { if ( ! hasRemaining ( ) | | built ) throw new IllegalStateException ( <str> ) ; } public int remainingCount ( ) { return comparator . size ( ) - size ; } public boolean containsNull ( ) { return containsNull ; } public boolean containsUnset ( ) { return containsUnset ; } public boolean hasMissingElements ( ) { return hasMissingElements ; } public abstract NavigableSet < Clustering > build ( ) ; public abstract NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) ; public boolean hasRemaining ( ) { return remainingCount ( ) > <int> ; } private static class OneClusteringBuilder extends MultiCBuilder { private final ByteBuffer [ ] elements ; public OneClusteringBuilder ( ClusteringComparator comparator ) { super ( comparator ) ; this . elements = new ByteBuffer [ comparator . size ( ) ] ; } public MultiCBuilder addElementToAll ( ByteBuffer value ) { checkUpdateable ( ) ; if ( value = = null ) containsNull = true ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) containsUnset = true ; elements [ size + + ] = value ; return this ; } public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) { if ( values . isEmpty ( ) ) { hasMissingElements = true ; return this ; } assert values . size ( ) = = <int> ; return addElementToAll ( values . get ( <int> ) ) ; } public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) { if ( values . isEmpty ( ) ) { hasMissingElements = true ; return this ; } assert values . size ( ) = = <int> ; return addEachElementToAll ( values . get ( <int> ) ) ; } public NavigableSet < Clustering > build ( ) { built = true ; if ( hasMissingElements ) return BTreeSet . empty ( comparator ) ; return BTreeSet . of ( comparator , size = = <int> ? Clustering . EMPTY : new Clustering ( elements ) ) ; } public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) { built = true ; if ( hasMissingElements ) return BTreeSet . empty ( comparator ) ; if ( size = = <int> ) return BTreeSet . of ( comparator , isStart ? Slice . Bound . BOTTOM : Slice . Bound . TOP ) ; ByteBuffer [ ] newValues = size = = elements . length ? elements : Arrays . copyOf ( elements , size ) ; return BTreeSet . of ( comparator , Slice . Bound . create ( Slice . Bound . boundKind ( isStart , isInclusive ) , newValues ) ) ; } } private static class MultiClusteringBuilder extends MultiCBuilder { private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; public MultiClusteringBuilder ( ClusteringComparator comparator ) { super ( comparator ) ; } public MultiCBuilder addElementToAll ( ByteBuffer value ) { checkUpdateable ( ) ; if ( elementsList . isEmpty ( ) ) elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; if ( value = = null ) containsNull = true ; else if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) containsUnset = true ; for ( int i = <int> , m = elementsList . size ( ) ; i < m ; i + + ) elementsList . get ( i ) . add ( value ) ; size + + ; return this ; } public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) { checkUpdateable ( ) ; if ( elementsList . isEmpty ( ) ) elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; if ( values . isEmpty ( ) ) { hasMissingElements = true ; } else { for ( int i = <int> , m = elementsList . size ( ) ; i < m ; i + + ) { List < ByteBuffer > oldComposite = elementsList . remove ( <int> ) ; for ( int j = <int> , n = values . size ( ) ; j < n ; j + + ) { List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; elementsList . add ( newComposite ) ; ByteBuffer value = values . get ( j ) ; if ( value = = null ) containsNull = true ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) containsUnset = true ; newComposite . add ( values . get ( j ) ) ; } } } size + + ; return this ; } public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) { checkUpdateable ( ) ; if ( elementsList . isEmpty ( ) ) elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; if ( values . isEmpty ( ) ) { hasMissingElements = true ; } else { for ( int i = <int> , m = elementsList . size ( ) ; i < m ; i + + ) { List < ByteBuffer > oldComposite = elementsList . remove ( <int> ) ; for ( int j = <int> , n = values . size ( ) ; j < n ; j + + ) { List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; elementsList . add ( newComposite ) ; List < ByteBuffer > value = values . get ( j ) ; if ( value . isEmpty ( ) ) hasMissingElements = true ; if ( value . contains ( null ) ) containsNull = true ; if ( value . contains ( ByteBufferUtil . UNSET_BYTE_BUFFER ) ) containsUnset = true ; newComposite . addAll ( value ) ; } } size + = values . get ( <int> ) . size ( ) ; } return this ; } public NavigableSet < Clustering > build ( ) { built = true ; if ( hasMissingElements ) return BTreeSet . empty ( comparator ) ; CBuilder builder = CBuilder . create ( comparator ) ; if ( elementsList . isEmpty ( ) ) return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; for ( int i = <int> , m = elementsList . size ( ) ; i < m ; i + + ) { List < ByteBuffer > elements = elementsList . get ( i ) ; set . add ( builder . buildWith ( elements ) ) ; } return set . build ( ) ; } public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) { built = true ; if ( hasMissingElements ) return BTreeSet . empty ( comparator ) ; CBuilder builder = CBuilder . create ( comparator ) ; if ( elementsList . isEmpty ( ) ) return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; for ( int i = <int> , m = elementsList . size ( ) ; i < m ; i + + ) { List < ByteBuffer > elements = elementsList . get ( i ) ; set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; } return set . build ( ) ; } } } 
