package io . netty . util . concurrent ; import org . junit . Test ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; @SuppressWarnings ( <str> ) public class DefaultPromiseTest { @Test ( expected = CancellationException . class ) public void testCancellationExceptionIsThrownWhenBlockingGet ( ) throws InterruptedException , ExecutionException { final Promise < Void > promise = new DefaultPromise < Void > ( ImmediateEventExecutor . INSTANCE ) ; promise . cancel ( false ) ; promise . get ( ) ; } @Test ( expected = CancellationException . class ) public void testCancellationExceptionIsThrownWhenBlockingGetWithTimeout ( ) throws InterruptedException , ExecutionException , TimeoutException { final Promise < Void > promise = new DefaultPromise < Void > ( ImmediateEventExecutor . INSTANCE ) ; promise . cancel ( false ) ; promise . get ( <int> , TimeUnit . SECONDS ) ; } @Test public void testNoStackOverflowErrorWithImmediateEventExecutorA ( ) throws Exception { final Promise < Void > [ ] p = new DefaultPromise [ <int> ] ; for ( int i = <int> ; i < p . length ; i + + ) { final int finalI = i ; p [ i ] = new DefaultPromise < Void > ( ImmediateEventExecutor . INSTANCE ) ; p [ i ] . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { if ( finalI + <int> < p . length ) { p [ finalI + <int> ] . setSuccess ( null ) ; } } } ) ; } p [ <int> ] . setSuccess ( null ) ; for ( Promise < Void > a : p ) { assertThat ( a . isSuccess ( ) , is ( true ) ) ; } } @Test public void testNoStackOverflowErrorWithImmediateEventExecutorB ( ) throws Exception { final Promise < Void > [ ] p = new DefaultPromise [ <int> ] ; for ( int i = <int> ; i < p . length ; i + + ) { final int finalI = i ; p [ i ] = new DefaultPromise < Void > ( ImmediateEventExecutor . INSTANCE ) ; p [ i ] . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { DefaultPromise . notifyListener ( ImmediateEventExecutor . INSTANCE , future , new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { if ( finalI + <int> < p . length ) { p [ finalI + <int> ] . setSuccess ( null ) ; } } } ) ; } } ) ; } p [ <int> ] . setSuccess ( null ) ; for ( Promise < Void > a : p ) { assertThat ( a . isSuccess ( ) , is ( true ) ) ; } } @Test public void testListenerNotifyOrder ( ) throws Exception { EventExecutor executor = new TestEventExecutor ( ) ; try { final BlockingQueue < FutureListener < Void > > listeners = new LinkedBlockingQueue < FutureListener < Void > > ( ) ; int runs = <int> ; for ( int i = <int> ; i < runs ; i + + ) { final Promise < Void > promise = new DefaultPromise < Void > ( executor ) ; final FutureListener < Void > listener1 = new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { listeners . add ( this ) ; } } ; final FutureListener < Void > listener2 = new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { listeners . add ( this ) ; } } ; final FutureListener < Void > listener4 = new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { listeners . add ( this ) ; } } ; final FutureListener < Void > listener3 = new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { listeners . add ( this ) ; future . addListener ( listener4 ) ; } } ; GlobalEventExecutor . INSTANCE . execute ( new Runnable ( ) { @Override public void run ( ) { promise . setSuccess ( null ) ; } } ) ; promise . addListener ( listener1 ) . addListener ( listener2 ) . addListener ( listener3 ) ; assertSame ( <str> + i + <str> + runs , listener1 , listeners . take ( ) ) ; assertSame ( <str> + i + <str> + runs , listener2 , listeners . take ( ) ) ; assertSame ( <str> + i + <str> + runs , listener3 , listeners . take ( ) ) ; assertSame ( <str> + i + <str> + runs , listener4 , listeners . take ( ) ) ; assertTrue ( <str> + i + <str> + runs , listeners . isEmpty ( ) ) ; } } finally { executor . shutdownGracefully ( <int> , <int> , TimeUnit . SECONDS ) . sync ( ) ; } } @Test public void testListenerNotifyLater ( ) throws Exception { testListenerNotifyLater ( <int> ) ; testListenerNotifyLater ( <int> ) ; } @Test ( timeout = <int> ) public void testPromiseListenerAddWhenCompleteFailure ( ) throws Exception { testPromiseListenerAddWhenComplete ( fakeException ( ) ) ; } @Test ( timeout = <int> ) public void testPromiseListenerAddWhenCompleteSuccess ( ) throws Exception { testPromiseListenerAddWhenComplete ( null ) ; } @Test ( timeout = <int> ) public void testLateListenerIsOrderedCorrectlySuccess ( ) throws InterruptedException { testLateListenerIsOrderedCorrectly ( null ) ; } @Test ( timeout = <int> ) public void testLateListenerIsOrderedCorrectlyFailure ( ) throws InterruptedException { testLateListenerIsOrderedCorrectly ( fakeException ( ) ) ; } private static void testLateListenerIsOrderedCorrectly ( Throwable cause ) throws InterruptedException { final EventExecutor executor = new TestEventExecutor ( ) ; try { final AtomicInteger state = new AtomicInteger ( ) ; final CountDownLatch latch1 = new CountDownLatch ( <int> ) ; final CountDownLatch latch2 = new CountDownLatch ( <int> ) ; final Promise < Void > promise = new DefaultPromise < Void > ( executor ) ; promise . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { assertTrue ( state . compareAndSet ( <int> , <int> ) ) ; } } ) ; if ( cause = = null ) { promise . setSuccess ( null ) ; } else { promise . setFailure ( cause ) ; } promise . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { assertTrue ( state . compareAndSet ( <int> , <int> ) ) ; latch1 . countDown ( ) ; } } ) ; latch1 . await ( ) ; assertEquals ( <int> , state . get ( ) ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { promise . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { assertTrue ( state . compareAndSet ( <int> , <int> ) ) ; latch2 . countDown ( ) ; } } ) ; } } ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { assertEquals ( <int> , state . get ( ) ) ; latch2 . countDown ( ) ; } } ) ; latch2 . await ( ) ; } finally { executor . shutdownGracefully ( <int> , <int> , TimeUnit . SECONDS ) . sync ( ) ; } } private static void testPromiseListenerAddWhenComplete ( Throwable cause ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Promise < Void > promise = new DefaultPromise < Void > ( ImmediateEventExecutor . INSTANCE ) ; promise . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { promise . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { latch . countDown ( ) ; } } ) ; } } ) ; if ( cause = = null ) { promise . setSuccess ( null ) ; } else { promise . setFailure ( cause ) ; } latch . await ( ) ; } private static void testListenerNotifyLater ( final int numListenersBefore ) throws Exception { EventExecutor executor = new TestEventExecutor ( ) ; int expectedCount = numListenersBefore + <int> ; final CountDownLatch latch = new CountDownLatch ( expectedCount ) ; final FutureListener < Void > listener = new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { latch . countDown ( ) ; } } ; final Promise < Void > promise = new DefaultPromise < Void > ( executor ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { for ( int i = <int> ; i < numListenersBefore ; i + + ) { promise . addListener ( listener ) ; } promise . setSuccess ( null ) ; GlobalEventExecutor . INSTANCE . execute ( new Runnable ( ) { @Override public void run ( ) { promise . addListener ( listener ) ; } } ) ; promise . addListener ( listener ) ; } } ) ; assertTrue ( <str> + expectedCount + <str> , latch . await ( <int> , TimeUnit . SECONDS ) ) ; executor . shutdownGracefully ( ) . sync ( ) ; } private static final class TestEventExecutor extends SingleThreadEventExecutor { TestEventExecutor ( ) { super ( null , Executors . defaultThreadFactory ( ) , true ) ; } @Override protected void run ( ) { for ( ; ; ) { Runnable task = takeTask ( ) ; if ( task ! = null ) { task . run ( ) ; updateLastExecutionTime ( ) ; } if ( confirmShutdown ( ) ) { break ; } } } } private static RuntimeException fakeException ( ) { return new RuntimeException ( <str> ) ; } } 
