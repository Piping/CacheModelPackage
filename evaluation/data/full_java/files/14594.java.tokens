package org . gradle . performance . fixture ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; class GCEventParser { private final Pattern pattern ; private final Pattern ignorePattern ; GCEventParser ( char decimalSeparator ) { pattern = Pattern . compile ( String . format ( <str> , decimalSeparator ) ) ; ignorePattern = Pattern . compile ( String . format ( <str> ) ) ; } GCEvent parseLine ( String line ) { if ( line . trim ( ) . isEmpty ( ) ) { return GCEvent . IGNORED ; } Matcher matcher = pattern . matcher ( line ) ; if ( ! matcher . lookingAt ( ) ) { if ( ignorePattern . matcher ( line ) . matches ( ) ) { return GCEvent . IGNORED ; } else { throw new IllegalArgumentException ( <str> + line ) ; } } DateTime timestamp = DateTime . parse ( matcher . group ( <int> ) ) ; timestamp = timestamp . toLocalDateTime ( ) . toDateTime ( DateTimeZone . getDefault ( ) ) ; long start = Long . parseLong ( matcher . group ( <int> ) ) ; long end = Long . parseLong ( matcher . group ( <int> ) ) ; long committed = Long . parseLong ( matcher . group ( <int> ) ) ; return new GCEvent ( start , end , committed , timestamp ) ; } static class GCEvent { final long start ; final long end ; final long committed ; final DateTime timestamp ; final static GCEvent IGNORED = new GCEvent ( - <int> , - <int> , - <int> , null ) ; GCEvent ( long start , long end , long committed , DateTime timestamp ) { this . start = start ; this . end = end ; this . committed = committed ; this . timestamp = timestamp ; } } } 
