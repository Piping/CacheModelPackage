package org . apache . cassandra . cql3 . functions ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . invoke . MethodHandle ; import java . lang . invoke . MethodHandles ; import java . lang . invoke . MethodType ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . * ; import java . nio . ByteBuffer ; import java . security . * ; import java . security . cert . Certificate ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . io . ByteStreams ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . datastax . driver . core . DataType ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . FBUtilities ; import org . eclipse . jdt . core . compiler . IProblem ; import org . eclipse . jdt . internal . compiler . * ; import org . eclipse . jdt . internal . compiler . Compiler ; import org . eclipse . jdt . internal . compiler . classfmt . ClassFileReader ; import org . eclipse . jdt . internal . compiler . classfmt . ClassFormatException ; import org . eclipse . jdt . internal . compiler . env . ICompilationUnit ; import org . eclipse . jdt . internal . compiler . env . INameEnvironment ; import org . eclipse . jdt . internal . compiler . env . NameEnvironmentAnswer ; import org . eclipse . jdt . internal . compiler . impl . CompilerOptions ; import org . eclipse . jdt . internal . compiler . problem . DefaultProblemFactory ; final class JavaBasedUDFunction extends UDFunction { private static final String BASE_PACKAGE = <str> ; static final Logger logger = LoggerFactory . getLogger ( JavaBasedUDFunction . class ) ; private static final AtomicInteger classSequence = new AtomicInteger ( ) ; private static final UDFExecutorService executor = new UDFExecutorService ( new NamedThreadFactory ( <str> , Thread . MIN_PRIORITY , udfClassLoader , new SecurityThreadGroup ( <str> , null , UDFunction : : initializeThread ) ) , <str> ) ; private static final EcjTargetClassLoader targetClassLoader = new EcjTargetClassLoader ( ) ; private static final UDFByteCodeVerifier udfByteCodeVerifier = new UDFByteCodeVerifier ( ) ; private static final ProtectionDomain protectionDomain ; private static final IErrorHandlingPolicy errorHandlingPolicy = DefaultErrorHandlingPolicies . proceedWithAllProblems ( ) ; private static final IProblemFactory problemFactory = new DefaultProblemFactory ( Locale . ENGLISH ) ; private static final CompilerOptions compilerOptions ; private static final String [ ] javaSourceTemplate ; static { udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( <str> , <str> ) ; for ( String ia : new String [ ] { <str> , <str> , <str> } ) { udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; udfByteCodeVerifier . addDisallowedMethodCall ( ia , <str> ) ; } udfByteCodeVerifier . addDisallowedClass ( <str> ) ; udfByteCodeVerifier . addDisallowedClass ( <str> ) ; Map < String , String > settings = new HashMap < > ( ) ; settings . put ( CompilerOptions . OPTION_LineNumberAttribute , CompilerOptions . GENERATE ) ; settings . put ( CompilerOptions . OPTION_SourceFileAttribute , CompilerOptions . DISABLED ) ; settings . put ( CompilerOptions . OPTION_ReportDeprecation , CompilerOptions . IGNORE ) ; settings . put ( CompilerOptions . OPTION_Source , CompilerOptions . VERSION_1_8 ) ; settings . put ( CompilerOptions . OPTION_TargetPlatform , CompilerOptions . VERSION_1_8 ) ; compilerOptions = new CompilerOptions ( settings ) ; compilerOptions . parseLiteralExpressionsAsConstants = true ; try ( InputStream input = JavaBasedUDFunction . class . getResource ( <str> ) . openConnection ( ) . getInputStream ( ) ) { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; FBUtilities . copy ( input , output , Long . MAX_VALUE ) ; String template = output . toString ( ) ; StringTokenizer st = new StringTokenizer ( template , <str> ) ; javaSourceTemplate = new String [ st . countTokens ( ) ] ; for ( int i = <int> ; st . hasMoreElements ( ) ; i + + ) javaSourceTemplate [ i ] = st . nextToken ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } CodeSource codeSource ; try { codeSource = new CodeSource ( new URL ( <str> , <str> , <int> , <str> , new URLStreamHandler ( ) { protected URLConnection openConnection ( URL u ) { return null ; } } ) , ( Certificate [ ] ) null ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } protectionDomain = new ProtectionDomain ( codeSource , ThreadAwareSecurityManager . noPermissions , targetClassLoader , null ) ; } private final JavaUDF javaUDF ; JavaBasedUDFunction ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , AbstractType < ? > returnType , boolean calledOnNullInput , String body ) { super ( name , argNames , argTypes , UDHelper . driverTypes ( argTypes ) , returnType , UDHelper . driverType ( returnType ) , calledOnNullInput , <str> , body ) ; Class < ? > [ ] javaParamTypes = UDHelper . javaTypes ( argDataTypes , calledOnNullInput ) ; Class < ? > javaReturnType = UDHelper . asJavaClass ( returnDataType ) ; String pkgName = BASE_PACKAGE + <str> + generateClassName ( name , <str> ) ; String clsName = generateClassName ( name , <str> ) ; String executeInternalName = generateClassName ( name , <str> ) ; StringBuilder javaSourceBuilder = new StringBuilder ( ) ; int lineOffset = <int> ; for ( int i = <int> ; i < javaSourceTemplate . length ; i + + ) { String s = javaSourceTemplate [ i ] ; if ( ( i & <int> ) = = <int> ) { switch ( s ) { case <str> : s = pkgName ; break ; case <str> : s = clsName ; break ; case <str> : lineOffset = countNewlines ( javaSourceBuilder ) ; s = body ; break ; case <str> : s = generateArguments ( javaParamTypes , argNames ) ; break ; case <str> : s = generateArgumentList ( javaParamTypes , argNames ) ; break ; case <str> : s = javaSourceName ( javaReturnType ) ; break ; case <str> : s = executeInternalName ; break ; } } javaSourceBuilder . append ( s ) ; } String targetClassName = pkgName + <str> + clsName ; String javaSource = javaSourceBuilder . toString ( ) ; logger . trace ( <str> , name , targetClassName , javaSource ) ; try { EcjCompilationUnit compilationUnit = new EcjCompilationUnit ( javaSource , targetClassName ) ; org . eclipse . jdt . internal . compiler . Compiler compiler = new Compiler ( compilationUnit , errorHandlingPolicy , compilerOptions , compilationUnit , problemFactory ) ; compiler . compile ( new ICompilationUnit [ ] { compilationUnit } ) ; if ( compilationUnit . problemList ! = null & & ! compilationUnit . problemList . isEmpty ( ) ) { boolean fullSource = false ; StringBuilder problems = new StringBuilder ( ) ; for ( IProblem problem : compilationUnit . problemList ) { long ln = problem . getSourceLineNumber ( ) - lineOffset ; if ( ln < <int> ) { if ( problem . isError ( ) ) { problems . append ( <str> ) . append ( problem . getSourceLineNumber ( ) ) . append ( <str> ) . append ( problem . getMessage ( ) ) . append ( <str> ) ; fullSource = true ; } } else { problems . append ( <str> ) . append ( Long . toString ( ln ) ) . append ( <str> ) . append ( problem . getMessage ( ) ) . append ( <str> ) ; } } if ( fullSource ) throw new InvalidRequestException ( <str> + problems + <str> + javaSource ) ; else throw new InvalidRequestException ( <str> + problems ) ; } Set < String > errors = udfByteCodeVerifier . verify ( targetClassLoader . classData ( targetClassName ) ) ; String validDeclare = <str> + executeInternalName + <str> ; String validCall = <str> + targetClassName . replace ( <str> , <str> ) + <str> + executeInternalName + <str> ; for ( Iterator < String > i = errors . iterator ( ) ; i . hasNext ( ) ; ) { String error = i . next ( ) ; if ( error . startsWith ( validDeclare ) | | error . equals ( validCall ) ) { i . remove ( ) ; } } if ( ! errors . isEmpty ( ) ) throw new InvalidRequestException ( <str> + errors ) ; Thread thread = Thread . currentThread ( ) ; ClassLoader orig = thread . getContextClassLoader ( ) ; try { thread . setContextClassLoader ( UDFunction . udfClassLoader ) ; Class cls = Class . forName ( targetClassName , false , targetClassLoader ) ; int nonSyntheticMethodCount = <int> ; for ( Method m : cls . getDeclaredMethods ( ) ) { if ( ! m . isSynthetic ( ) ) { nonSyntheticMethodCount + = <int> ; } } if ( nonSyntheticMethodCount ! = <int> | | cls . getDeclaredConstructors ( ) . length ! = <int> ) throw new InvalidRequestException ( <str> ) ; MethodType methodType = MethodType . methodType ( void . class ) . appendParameterTypes ( DataType . class , DataType [ ] . class ) ; MethodHandle ctor = MethodHandles . lookup ( ) . findConstructor ( cls , methodType ) ; this . javaUDF = ( JavaUDF ) ctor . invokeWithArguments ( returnDataType , argDataTypes ) ; } finally { thread . setContextClassLoader ( orig ) ; } } catch ( InvocationTargetException e ) { throw new InvalidRequestException ( String . format ( <str> , name , e . getCause ( ) ) ) ; } catch ( VirtualMachineError e ) { throw e ; } catch ( Throwable e ) { throw new InvalidRequestException ( String . format ( <str> , name , e ) ) ; } } protected ExecutorService executor ( ) { return executor ; } protected ByteBuffer executeUserDefined ( int protocolVersion , List < ByteBuffer > params ) { return javaUDF . executeImpl ( protocolVersion , params ) ; } private static int countNewlines ( StringBuilder javaSource ) { int ln = <int> ; for ( int i = <int> ; i < javaSource . length ( ) ; i + + ) if ( javaSource . charAt ( i ) = = <str> ) ln + + ; return ln ; } private static String generateClassName ( FunctionName name , char prefix ) { String qualifiedName = name . toString ( ) ; StringBuilder sb = new StringBuilder ( qualifiedName . length ( ) + <int> ) ; sb . append ( prefix ) ; for ( int i = <int> ; i < qualifiedName . length ( ) ; i + + ) { char c = qualifiedName . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( c ) ) sb . append ( c ) ; else sb . append ( Integer . toHexString ( ( ( short ) c ) & <hex> ) ) ; } sb . append ( <str> ) . append ( ThreadLocalRandom . current ( ) . nextInt ( ) & <hex> ) . append ( <str> ) . append ( classSequence . incrementAndGet ( ) ) ; return sb . toString ( ) ; } private static String javaSourceName ( Class < ? > type ) { String n = type . getName ( ) ; return n . startsWith ( <str> ) ? type . getSimpleName ( ) : n ; } private static String generateArgumentList ( Class < ? > [ ] paramTypes , List < ColumnIdentifier > argNames ) { StringBuilder code = new StringBuilder ( <int> * paramTypes . length ) ; for ( int i = <int> ; i < paramTypes . length ; i + + ) { if ( i > <int> ) code . append ( <str> ) ; code . append ( javaSourceName ( paramTypes [ i ] ) ) . append ( <str> ) . append ( argNames . get ( i ) ) ; } return code . toString ( ) ; } private static String generateArguments ( Class < ? > [ ] paramTypes , List < ColumnIdentifier > argNames ) { StringBuilder code = new StringBuilder ( <int> * paramTypes . length ) ; for ( int i = <int> ; i < paramTypes . length ; i + + ) { if ( i > <int> ) code . append ( <str> ) ; if ( logger . isTraceEnabled ( ) ) code . append ( <str> ) . append ( argNames . get ( i ) ) . append ( <str> ) ; code . append ( <str> ) . append ( javaSourceName ( paramTypes [ i ] ) ) . append ( <str> ) . append ( composeMethod ( paramTypes [ i ] ) ) . append ( <str> ) . append ( i ) . append ( <str> ) . append ( i ) . append ( <str> ) ; } return code . toString ( ) ; } private static String composeMethod ( Class < ? > type ) { return ( type . isPrimitive ( ) ) ? ( <str> + type . getName ( ) ) : <str> ; } static final class EcjCompilationUnit implements ICompilationUnit , ICompilerRequestor , INameEnvironment { List < IProblem > problemList ; private final String className ; private final char [ ] sourceCode ; EcjCompilationUnit ( String sourceCode , String className ) { this . className = className ; this . sourceCode = sourceCode . toCharArray ( ) ; } @Override public char [ ] getFileName ( ) { return sourceCode ; } @Override public char [ ] getContents ( ) { return sourceCode ; } @Override public char [ ] getMainTypeName ( ) { int dot = className . lastIndexOf ( <str> ) ; return ( ( dot > <int> ) ? className . substring ( dot + <int> ) : className ) . toCharArray ( ) ; } @Override public char [ ] [ ] getPackageName ( ) { StringTokenizer izer = new StringTokenizer ( className , <str> ) ; char [ ] [ ] result = new char [ izer . countTokens ( ) - <int> ] [ ] ; for ( int i = <int> ; i < result . length ; i + + ) result [ i ] = izer . nextToken ( ) . toCharArray ( ) ; return result ; } @Override public boolean ignoreOptionalProblems ( ) { return false ; } @Override public void acceptResult ( CompilationResult result ) { if ( result . hasErrors ( ) ) { IProblem [ ] problems = result . getProblems ( ) ; if ( problemList = = null ) problemList = new ArrayList < > ( problems . length ) ; Collections . addAll ( problemList , problems ) ; } else { ClassFile [ ] classFiles = result . getClassFiles ( ) ; for ( ClassFile classFile : classFiles ) targetClassLoader . addClass ( className , classFile . getBytes ( ) ) ; } } @Override public NameEnvironmentAnswer findType ( char [ ] [ ] compoundTypeName ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = <int> ; i < compoundTypeName . length ; i + + ) { if ( i > <int> ) result . append ( <str> ) ; result . append ( compoundTypeName [ i ] ) ; } return findType ( result . toString ( ) ) ; } @Override public NameEnvironmentAnswer findType ( char [ ] typeName , char [ ] [ ] packageName ) { StringBuilder result = new StringBuilder ( ) ; int i = <int> ; for ( ; i < packageName . length ; i + + ) { if ( i > <int> ) result . append ( <str> ) ; result . append ( packageName [ i ] ) ; } if ( i > <int> ) result . append ( <str> ) ; result . append ( typeName ) ; return findType ( result . toString ( ) ) ; } private NameEnvironmentAnswer findType ( String className ) { if ( className . equals ( this . className ) ) { return new NameEnvironmentAnswer ( this , null ) ; } String resourceName = className . replace ( <str> , <str> ) + <str> ; try ( InputStream is = UDFunction . udfClassLoader . getResourceAsStream ( resourceName ) ) { if ( is ! = null ) { byte [ ] classBytes = ByteStreams . toByteArray ( is ) ; char [ ] fileName = className . toCharArray ( ) ; ClassFileReader classFileReader = new ClassFileReader ( classBytes , fileName , true ) ; return new NameEnvironmentAnswer ( classFileReader , null ) ; } } catch ( IOException | ClassFormatException exc ) { throw new RuntimeException ( exc ) ; } return null ; } private boolean isPackage ( String result ) { if ( result . equals ( this . className ) ) return false ; String resourceName = result . replace ( <str> , <str> ) + <str> ; try ( InputStream is = UDFunction . udfClassLoader . getResourceAsStream ( resourceName ) ) { return is = = null ; } catch ( IOException e ) { return false ; } } @Override public boolean isPackage ( char [ ] [ ] parentPackageName , char [ ] packageName ) { StringBuilder result = new StringBuilder ( ) ; int i = <int> ; if ( parentPackageName ! = null ) for ( ; i < parentPackageName . length ; i + + ) { if ( i > <int> ) result . append ( <str> ) ; result . append ( parentPackageName [ i ] ) ; } if ( Character . isUpperCase ( packageName [ <int> ] ) & & ! isPackage ( result . toString ( ) ) ) return false ; if ( i > <int> ) result . append ( <str> ) ; result . append ( packageName ) ; return isPackage ( result . toString ( ) ) ; } @Override public void cleanup ( ) { } } static final class EcjTargetClassLoader extends SecureClassLoader { EcjTargetClassLoader ( ) { super ( UDFunction . udfClassLoader ) ; } private final Map < String , byte [ ] > classes = new ConcurrentHashMap < > ( ) ; void addClass ( String className , byte [ ] classData ) { classes . put ( className , classData ) ; } byte [ ] classData ( String className ) { return classes . get ( className ) ; } protected Class < ? > findClass ( String name ) throws ClassNotFoundException { byte [ ] classData = classes . remove ( name ) ; if ( classData ! = null ) return defineClass ( name , classData , <int> , classData . length , protectionDomain ) ; return getParent ( ) . loadClass ( name ) ; } protected PermissionCollection getPermissions ( CodeSource codesource ) { return ThreadAwareSecurityManager . noPermissions ; } } } 
