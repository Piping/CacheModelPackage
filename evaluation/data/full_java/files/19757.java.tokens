package io . netty . util ; import org . junit . Test ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executors ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class HashedWheelTimerTest { @Test public void testScheduleTimeoutShouldNotRunBeforeDelay ( ) throws InterruptedException { final Timer timer = new HashedWheelTimer ( ) ; final CountDownLatch barrier = new CountDownLatch ( <int> ) ; final Timeout timeout = timer . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { fail ( <str> ) ; barrier . countDown ( ) ; } } , <int> , TimeUnit . SECONDS ) ; assertFalse ( barrier . await ( <int> , TimeUnit . SECONDS ) ) ; assertFalse ( <str> , timeout . isExpired ( ) ) ; timer . stop ( ) ; } @Test public void testScheduleTimeoutShouldRunAfterDelay ( ) throws InterruptedException { final Timer timer = new HashedWheelTimer ( ) ; final CountDownLatch barrier = new CountDownLatch ( <int> ) ; final Timeout timeout = timer . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { barrier . countDown ( ) ; } } , <int> , TimeUnit . SECONDS ) ; assertTrue ( barrier . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( <str> , timeout . isExpired ( ) ) ; timer . stop ( ) ; } @Test public void testStopTimer ( ) throws InterruptedException { final Timer timerProcessed = new HashedWheelTimer ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { timerProcessed . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { } } , <int> , TimeUnit . MILLISECONDS ) ; } Thread . sleep ( <int> ) ; assertEquals ( <str> , <int> , timerProcessed . stop ( ) . size ( ) ) ; final Timer timerUnprocessed = new HashedWheelTimer ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { timerUnprocessed . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { } } , <int> , TimeUnit . SECONDS ) ; } Thread . sleep ( <int> ) ; assertFalse ( <str> , timerUnprocessed . stop ( ) . isEmpty ( ) ) ; } @Test ( expected = IllegalStateException . class ) public void testTimerShouldThrowExceptionAfterShutdownForNewTimeouts ( ) throws InterruptedException { final Timer timer = new HashedWheelTimer ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { timer . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { } } , <int> , TimeUnit . MILLISECONDS ) ; } timer . stop ( ) ; Thread . sleep ( <int> ) ; timer . newTimeout ( new TimerTask ( ) { @Override public void run ( Timeout timeout ) throws Exception { fail ( <str> ) ; } } , <int> , TimeUnit . SECONDS ) ; } @Test public void testTimerOverflowWheelLength ( ) throws InterruptedException { final HashedWheelTimer timer = new HashedWheelTimer ( Executors . defaultThreadFactory ( ) , <int> , TimeUnit . MILLISECONDS , <int> ) ; final AtomicInteger counter = new AtomicInteger ( ) ; timer . newTimeout ( new TimerTask ( ) { @Override public void run ( final Timeout timeout ) throws Exception { counter . incrementAndGet ( ) ; timer . newTimeout ( this , <int> , TimeUnit . SECONDS ) ; } } , <int> , TimeUnit . SECONDS ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , counter . get ( ) ) ; timer . stop ( ) ; } @Test public void testExecutionOnTime ( ) throws InterruptedException { int tickDuration = <int> ; int timeout = <int> ; int maxTimeout = <int> * ( tickDuration + timeout ) ; final HashedWheelTimer timer = new HashedWheelTimer ( tickDuration , TimeUnit . MILLISECONDS ) ; final BlockingQueue < Long > queue = new LinkedBlockingQueue < Long > ( ) ; int scheduledTasks = <int> ; for ( int i = <int> ; i < scheduledTasks ; i + + ) { final long start = System . nanoTime ( ) ; timer . newTimeout ( new TimerTask ( ) { @Override public void run ( final Timeout timeout ) throws Exception { queue . add ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; } } , timeout , TimeUnit . MILLISECONDS ) ; } for ( int i = <int> ; i < scheduledTasks ; i + + ) { long delay = queue . take ( ) ; assertTrue ( <str> + scheduledTasks + <str> + delay + <str> + timeout + <str> + maxTimeout , delay > = timeout & & delay < maxTimeout ) ; } timer . stop ( ) ; } } 
