package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . TimeUtils ; public class MatrixJNITest extends GdxTest { @Override public void create ( ) { Matrix4 mat1 = new Matrix4 ( ) ; Matrix4 mat2 = new Matrix4 ( ) ; Matrix4 mat3 = new Matrix4 ( ) ; Vector3 vec = new Vector3 ( <int> , <int> , <int> ) ; float [ ] fvec = { <int> , <int> , <int> } ; float [ ] fvecs = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; mat1 . setToRotation ( <int> , <int> , <int> , <int> ) ; mat2 . setToRotation ( <int> , <int> , <int> , <int> ) ; vec . mul ( mat1 ) ; Matrix4 . mulVec ( mat1 . val , fvec ) ; Matrix4 . mulVec ( mat1 . val , fvecs , <int> , <int> , <int> ) ; check ( vec , fvec ) ; check ( vec , fvecs , <int> , <int> ) ; vec . prj ( mat1 ) ; Matrix4 . prj ( mat1 . val , fvec ) ; Matrix4 . prj ( mat1 . val , fvecs , <int> , <int> , <int> ) ; check ( vec , fvec ) ; check ( vec , fvecs , <int> , <int> ) ; vec . rot ( mat1 ) ; Matrix4 . rot ( mat1 . val , fvec ) ; Matrix4 . rot ( mat1 . val , fvecs , <int> , <int> , <int> ) ; check ( vec , fvec ) ; check ( vec , fvecs , <int> , <int> ) ; if ( mat1 . det ( ) ! = Matrix4 . det ( mat1 . val ) ) throw new GdxRuntimeException ( <str> ) ; mat2 . set ( mat1 ) ; mat1 . inv ( ) ; Matrix4 . inv ( mat2 . val ) ; check ( mat1 , mat2 ) ; mat3 . set ( mat1 ) ; mat1 . mul ( mat2 ) ; Matrix4 . mul ( mat3 . val , mat2 . val ) ; check ( mat1 , mat3 ) ; bench ( ) ; System . out . println ( <str> ) ; } private void bench ( ) { Matrix4 mata = new Matrix4 ( ) ; Matrix4 matb = new Matrix4 ( ) ; long start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { mata . mul ( matb ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { Matrix4 . mul ( mata . val , matb . val ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; Vector3 vec = new Vector3 ( ) ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { vec . mul ( mata ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; float [ ] fvec = new float [ <int> ] ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { Matrix4 . mulVec ( mata . val , fvec ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; float [ ] fvecs = new float [ <int> * <int> ] ; start = TimeUtils . nanoTime ( ) ; Matrix4 . mulVec ( mata . val , fvecs , <int> , <int> , <int> ) ; Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { mata . inv ( ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { Matrix4 . inv ( mata . val ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void check ( Vector3 vec , float [ ] fvec ) { if ( vec . x ! = fvec [ <int> ] | | vec . y ! = fvec [ <int> ] | | vec . z ! = fvec [ <int> ] ) throw new GdxRuntimeException ( <str> ) ; } private void check ( Vector3 vec , float [ ] fvec , int numVecs , int stride ) { int offset = <int> ; for ( int i = <int> ; i < numVecs ; i + + ) { if ( vec . x ! = fvec [ <int> ] | | vec . y ! = fvec [ <int> ] | | vec . z ! = fvec [ <int> ] ) throw new GdxRuntimeException ( <str> ) ; } } private void check ( Matrix4 mat1 , Matrix4 mat2 ) { for ( int i = <int> ; i < <int> ; i + + ) { if ( mat1 . val [ i ] ! = mat2 . val [ i ] ) throw new GdxRuntimeException ( <str> ) ; } } } 
