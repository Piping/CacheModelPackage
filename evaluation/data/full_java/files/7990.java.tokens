package org . elasticsearch . common . util . concurrent ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matcher ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . lessThan ; public class EsExecutorsTests extends ESTestCase { private TimeUnit randomTimeUnit ( ) { return TimeUnit . values ( ) [ between ( <int> , TimeUnit . values ( ) . length - <int> ) ] ; } public void testFixedForcedExecution ( ) throws Exception { EsThreadPoolExecutor executor = EsExecutors . newFixed ( getTestName ( ) , <int> , <int> , EsExecutors . daemonThreadFactory ( <str> ) ) ; final CountDownLatch wait = new CountDownLatch ( <int> ) ; final CountDownLatch exec1Wait = new CountDownLatch ( <int> ) ; final AtomicBoolean executed1 = new AtomicBoolean ( ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { try { wait . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } executed1 . set ( true ) ; exec1Wait . countDown ( ) ; } } ) ; final CountDownLatch exec2Wait = new CountDownLatch ( <int> ) ; final AtomicBoolean executed2 = new AtomicBoolean ( ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { executed2 . set ( true ) ; exec2Wait . countDown ( ) ; } } ) ; final AtomicBoolean executed3 = new AtomicBoolean ( ) ; final CountDownLatch exec3Wait = new CountDownLatch ( <int> ) ; executor . execute ( new AbstractRunnable ( ) { @Override protected void doRun ( ) { executed3 . set ( true ) ; exec3Wait . countDown ( ) ; } @Override public boolean isForceExecution ( ) { return true ; } @Override public void onFailure ( Throwable t ) { throw new AssertionError ( t ) ; } } ) ; wait . countDown ( ) ; exec1Wait . await ( ) ; exec2Wait . await ( ) ; exec3Wait . await ( ) ; assertThat ( executed1 . get ( ) , equalTo ( true ) ) ; assertThat ( executed2 . get ( ) , equalTo ( true ) ) ; assertThat ( executed3 . get ( ) , equalTo ( true ) ) ; executor . shutdownNow ( ) ; } public void testFixedRejected ( ) throws Exception { EsThreadPoolExecutor executor = EsExecutors . newFixed ( getTestName ( ) , <int> , <int> , EsExecutors . daemonThreadFactory ( <str> ) ) ; final CountDownLatch wait = new CountDownLatch ( <int> ) ; final CountDownLatch exec1Wait = new CountDownLatch ( <int> ) ; final AtomicBoolean executed1 = new AtomicBoolean ( ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { try { wait . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } executed1 . set ( true ) ; exec1Wait . countDown ( ) ; } } ) ; final CountDownLatch exec2Wait = new CountDownLatch ( <int> ) ; final AtomicBoolean executed2 = new AtomicBoolean ( ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { executed2 . set ( true ) ; exec2Wait . countDown ( ) ; } } ) ; final AtomicBoolean executed3 = new AtomicBoolean ( ) ; try { executor . execute ( new Runnable ( ) { @Override public void run ( ) { executed3 . set ( true ) ; } } ) ; fail ( <str> ) ; } catch ( EsRejectedExecutionException e ) { } wait . countDown ( ) ; exec1Wait . await ( ) ; exec2Wait . await ( ) ; assertThat ( executed1 . get ( ) , equalTo ( true ) ) ; assertThat ( executed2 . get ( ) , equalTo ( true ) ) ; assertThat ( executed3 . get ( ) , equalTo ( false ) ) ; terminate ( executor ) ; } public void testScaleUp ( ) throws Exception { final int min = between ( <int> , <int> ) ; final int max = between ( min + <int> , <int> ) ; final ThreadBarrier barrier = new ThreadBarrier ( max + <int> ) ; ThreadPoolExecutor pool = EsExecutors . newScaling ( getTestName ( ) , min , max , between ( <int> , <int> ) , randomTimeUnit ( ) , EsExecutors . daemonThreadFactory ( <str> ) ) ; assertThat ( <str> , pool . getCorePoolSize ( ) , equalTo ( min ) ) ; assertThat ( <str> , pool . getMaximumPoolSize ( ) , equalTo ( max ) ) ; for ( int i = <int> ; i < max ; + + i ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; pool . execute ( new Runnable ( ) { @Override public void run ( ) { latch . countDown ( ) ; try { barrier . await ( ) ; barrier . await ( ) ; } catch ( Throwable e ) { barrier . reset ( e ) ; } } } ) ; latch . await ( ) ; } barrier . await ( ) ; assertThat ( <str> , pool . getPoolSize ( ) , equalTo ( max ) ) ; assertThat ( <str> , pool . getActiveCount ( ) , equalTo ( max ) ) ; barrier . await ( ) ; terminate ( pool ) ; } public void testScaleDown ( ) throws Exception { final int min = between ( <int> , <int> ) ; final int max = between ( min + <int> , <int> ) ; final ThreadBarrier barrier = new ThreadBarrier ( max + <int> ) ; final ThreadPoolExecutor pool = EsExecutors . newScaling ( getTestName ( ) , min , max , between ( <int> , <int> ) , TimeUnit . MILLISECONDS , EsExecutors . daemonThreadFactory ( <str> ) ) ; assertThat ( <str> , pool . getCorePoolSize ( ) , equalTo ( min ) ) ; assertThat ( <str> , pool . getMaximumPoolSize ( ) , equalTo ( max ) ) ; for ( int i = <int> ; i < max ; + + i ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; pool . execute ( new Runnable ( ) { @Override public void run ( ) { latch . countDown ( ) ; try { barrier . await ( ) ; barrier . await ( ) ; } catch ( Throwable e ) { barrier . reset ( e ) ; } } } ) ; latch . await ( ) ; } barrier . await ( ) ; assertThat ( <str> , pool . getPoolSize ( ) , equalTo ( max ) ) ; assertThat ( <str> , pool . getActiveCount ( ) , equalTo ( max ) ) ; barrier . await ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( <str> , pool . getActiveCount ( ) , equalTo ( <int> ) ) ; assertThat ( <str> + pool . getPoolSize ( ) + <str> , pool . getPoolSize ( ) , lessThan ( max ) ) ; } } ) ; terminate ( pool ) ; } public void testRejectionMessageAndShuttingDownFlag ( ) throws InterruptedException { int pool = between ( <int> , <int> ) ; int queue = between ( <int> , <int> ) ; int actions = queue + pool ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; EsThreadPoolExecutor executor = EsExecutors . newFixed ( getTestName ( ) , pool , queue , EsExecutors . daemonThreadFactory ( <str> ) ) ; try { for ( int i = <int> ; i < actions ; i + + ) { executor . execute ( new Runnable ( ) { @Override public void run ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } ) ; } try { executor . execute ( new Runnable ( ) { @Override public void run ( ) { } @Override public String toString ( ) { return <str> ; } } ) ; fail ( <str> ) ; } catch ( EsRejectedExecutionException e ) { assertFalse ( <str> , e . isExecutorShutdown ( ) ) ; String message = ExceptionsHelper . detailedMessage ( e ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> + queue ) ) ; assertThat ( message , containsString ( <str> ) ) ; @SuppressWarnings ( <str> ) Matcher < String > [ ] activeThreads = new Matcher [ pool + <int> ] ; for ( int p = <int> ; p < = pool ; p + + ) { activeThreads [ p ] = containsString ( <str> + p ) ; } assertThat ( message , anyOf ( activeThreads ) ) ; assertThat ( message , containsString ( <str> + queue ) ) ; assertThat ( message , containsString ( <str> ) ) ; } } finally { latch . countDown ( ) ; terminate ( executor ) ; } try { executor . execute ( new Runnable ( ) { @Override public void run ( ) { } @Override public String toString ( ) { return <str> ; } } ) ; fail ( <str> ) ; } catch ( EsRejectedExecutionException e ) { assertTrue ( <str> , e . isExecutorShutdown ( ) ) ; String message = ExceptionsHelper . detailedMessage ( e ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> + getTestName ( ) ) ) ; assertThat ( message , containsString ( <str> + queue ) ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> ) ) ; assertThat ( message , containsString ( <str> + actions ) ) ; } } } 
