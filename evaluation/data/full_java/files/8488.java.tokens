package org . elasticsearch . search . aggregations . support ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . apache . lucene . index . RandomAccessOrds ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . index . fielddata . AbstractRandomAccessOrds ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class MissingValuesTests extends ESTestCase { public void testMissingBytes ( ) { final int numDocs = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final BytesRef [ ] [ ] values = new BytesRef [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { values [ i ] = new BytesRef [ random ( ) . nextInt ( <int> ) ] ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { values [ i ] [ j ] = new BytesRef ( RandomStrings . randomAsciiOfLength ( random ( ) , <int> ) ) ; } Arrays . sort ( values [ i ] ) ; } SortedBinaryDocValues asBinaryValues = new SortedBinaryDocValues ( ) { int i = - <int> ; @Override public BytesRef valueAt ( int index ) { return values [ i ] [ index ] ; } @Override public void setDocument ( int docId ) { i = docId ; } @Override public int count ( ) { return values [ i ] . length ; } } ; final BytesRef missing = new BytesRef ( RandomStrings . randomAsciiOfLength ( random ( ) , <int> ) ) ; SortedBinaryDocValues withMissingReplaced = MissingValues . replaceMissing ( asBinaryValues , missing ) ; for ( int i = <int> ; i < numDocs ; + + i ) { withMissingReplaced . setDocument ( i ) ; if ( values [ i ] . length > <int> ) { assertEquals ( values [ i ] . length , withMissingReplaced . count ( ) ) ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { assertEquals ( values [ i ] [ j ] , withMissingReplaced . valueAt ( j ) ) ; } } else { assertEquals ( <int> , withMissingReplaced . count ( ) ) ; assertEquals ( missing , withMissingReplaced . valueAt ( <int> ) ) ; } } } public void testMissingOrds ( ) { final int numDocs = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final int numOrds = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final Set < BytesRef > valueSet = new HashSet < > ( ) ; while ( valueSet . size ( ) < numOrds ) { valueSet . add ( new BytesRef ( RandomStrings . randomAsciiOfLength ( random ( ) , <int> ) ) ) ; } final BytesRef [ ] values = valueSet . toArray ( new BytesRef [ numOrds ] ) ; Arrays . sort ( values ) ; final int [ ] [ ] ords = new int [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { ords [ i ] = new int [ random ( ) . nextInt ( numOrds ) ] ; for ( int j = <int> ; j < ords [ i ] . length ; + + j ) { ords [ i ] [ j ] = j ; } for ( int j = ords [ i ] . length - <int> ; j > = <int> ; - - j ) { final int maxOrd = j = = ords [ i ] . length - <int> ? numOrds : ords [ i ] [ j + <int> ] ; ords [ i ] [ j ] = TestUtil . nextInt ( random ( ) , ords [ i ] [ j ] , maxOrd - <int> ) ; } } RandomAccessOrds asRandomAccessOrds = new AbstractRandomAccessOrds ( ) { int i = - <int> ; @Override public void doSetDocument ( int docID ) { i = docID ; } @Override public BytesRef lookupOrd ( long ord ) { return values [ ( int ) ord ] ; } @Override public long getValueCount ( ) { return values . length ; } @Override public long ordAt ( int index ) { return ords [ i ] [ index ] ; } @Override public int cardinality ( ) { return ords [ i ] . length ; } } ; final BytesRef existingMissing = RandomPicks . randomFrom ( random ( ) , values ) ; final BytesRef missingMissing = new BytesRef ( RandomStrings . randomAsciiOfLength ( random ( ) , <int> ) ) ; for ( BytesRef missing : Arrays . asList ( existingMissing , missingMissing ) ) { RandomAccessOrds withMissingReplaced = MissingValues . replaceMissing ( asRandomAccessOrds , missing ) ; if ( valueSet . contains ( missing ) ) { assertEquals ( values . length , withMissingReplaced . getValueCount ( ) ) ; } else { assertEquals ( values . length + <int> , withMissingReplaced . getValueCount ( ) ) ; } for ( int i = <int> ; i < numDocs ; + + i ) { withMissingReplaced . setDocument ( i ) ; if ( ords [ i ] . length > <int> ) { assertEquals ( ords [ i ] . length , withMissingReplaced . cardinality ( ) ) ; for ( int j = <int> ; j < ords [ i ] . length ; + + j ) { assertEquals ( values [ ords [ i ] [ j ] ] , withMissingReplaced . lookupOrd ( withMissingReplaced . ordAt ( j ) ) ) ; } } else { assertEquals ( <int> , withMissingReplaced . cardinality ( ) ) ; assertEquals ( missing , withMissingReplaced . lookupOrd ( withMissingReplaced . ordAt ( <int> ) ) ) ; } } } } public void testMissingLongs ( ) { final int numDocs = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final int [ ] [ ] values = new int [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { values [ i ] = new int [ random ( ) . nextInt ( <int> ) ] ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { values [ i ] [ j ] = randomInt ( ) ; } Arrays . sort ( values [ i ] ) ; } SortedNumericDocValues asNumericValues = new SortedNumericDocValues ( ) { int i = - <int> ; @Override public long valueAt ( int index ) { return values [ i ] [ index ] ; } @Override public void setDocument ( int docId ) { i = docId ; } @Override public int count ( ) { return values [ i ] . length ; } } ; final long missing = randomInt ( ) ; SortedNumericDocValues withMissingReplaced = MissingValues . replaceMissing ( asNumericValues , missing ) ; for ( int i = <int> ; i < numDocs ; + + i ) { withMissingReplaced . setDocument ( i ) ; if ( values [ i ] . length > <int> ) { assertEquals ( values [ i ] . length , withMissingReplaced . count ( ) ) ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { assertEquals ( values [ i ] [ j ] , withMissingReplaced . valueAt ( j ) ) ; } } else { assertEquals ( <int> , withMissingReplaced . count ( ) ) ; assertEquals ( missing , withMissingReplaced . valueAt ( <int> ) ) ; } } } public void testMissingDoubles ( ) { final int numDocs = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final double [ ] [ ] values = new double [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { values [ i ] = new double [ random ( ) . nextInt ( <int> ) ] ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { values [ i ] [ j ] = randomDouble ( ) ; } Arrays . sort ( values [ i ] ) ; } SortedNumericDoubleValues asNumericValues = new SortedNumericDoubleValues ( ) { int i = - <int> ; @Override public double valueAt ( int index ) { return values [ i ] [ index ] ; } @Override public void setDocument ( int docId ) { i = docId ; } @Override public int count ( ) { return values [ i ] . length ; } } ; final long missing = randomInt ( ) ; SortedNumericDoubleValues withMissingReplaced = MissingValues . replaceMissing ( asNumericValues , missing ) ; for ( int i = <int> ; i < numDocs ; + + i ) { withMissingReplaced . setDocument ( i ) ; if ( values [ i ] . length > <int> ) { assertEquals ( values [ i ] . length , withMissingReplaced . count ( ) ) ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { assertEquals ( values [ i ] [ j ] , withMissingReplaced . valueAt ( j ) , <int> ) ; } } else { assertEquals ( <int> , withMissingReplaced . count ( ) ) ; assertEquals ( missing , withMissingReplaced . valueAt ( <int> ) , <int> ) ; } } } public void testMissingGeoPoints ( ) { final int numDocs = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final GeoPoint [ ] [ ] values = new GeoPoint [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { values [ i ] = new GeoPoint [ random ( ) . nextInt ( <int> ) ] ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { values [ i ] [ j ] = new GeoPoint ( randomDouble ( ) * <int> , randomDouble ( ) * <int> ) ; } } MultiGeoPointValues asGeoValues = new MultiGeoPointValues ( ) { int i = - <int> ; @Override public GeoPoint valueAt ( int index ) { return values [ i ] [ index ] ; } @Override public void setDocument ( int docId ) { i = docId ; } @Override public int count ( ) { return values [ i ] . length ; } } ; final GeoPoint missing = new GeoPoint ( randomDouble ( ) * <int> , randomDouble ( ) * <int> ) ; MultiGeoPointValues withMissingReplaced = MissingValues . replaceMissing ( asGeoValues , missing ) ; for ( int i = <int> ; i < numDocs ; + + i ) { withMissingReplaced . setDocument ( i ) ; if ( values [ i ] . length > <int> ) { assertEquals ( values [ i ] . length , withMissingReplaced . count ( ) ) ; for ( int j = <int> ; j < values [ i ] . length ; + + j ) { assertEquals ( values [ i ] [ j ] , withMissingReplaced . valueAt ( j ) ) ; } } else { assertEquals ( <int> , withMissingReplaced . count ( ) ) ; assertEquals ( missing , withMissingReplaced . valueAt ( <int> ) ) ; } } } } 
