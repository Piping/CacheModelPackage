package io . netty . handler . codec . dns ; import io . netty . util . collection . IntObjectHashMap ; import java . util . HashMap ; import java . util . Map ; public class DnsRecordType implements Comparable < DnsRecordType > { public static final DnsRecordType A = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType NS = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType CNAME = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType SOA = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType PTR = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType MX = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType TXT = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType RP = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType AFSDB = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType SIG = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType KEY = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType AAAA = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType LOC = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType SRV = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType NAPTR = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType KX = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType CERT = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType DNAME = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType OPT = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType APL = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType DS = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType SSHFP = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType IPSECKEY = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType RRSIG = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType NSEC = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType DNSKEY = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType DHCID = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType NSEC3 = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType NSEC3PARAM = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType TLSA = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType HIP = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType SPF = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType TKEY = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType TSIG = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType IXFR = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType AXFR = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType ANY = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType CAA = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType TA = new DnsRecordType ( <hex> , <str> ) ; public static final DnsRecordType DLV = new DnsRecordType ( <hex> , <str> ) ; private static final Map < String , DnsRecordType > BY_NAME = new HashMap < String , DnsRecordType > ( ) ; private static final IntObjectHashMap < DnsRecordType > BY_TYPE = new IntObjectHashMap < DnsRecordType > ( ) ; private static final String EXPECTED ; static { DnsRecordType [ ] all = { A , NS , CNAME , SOA , PTR , MX , TXT , RP , AFSDB , SIG , KEY , AAAA , LOC , SRV , NAPTR , KX , CERT , DNAME , OPT , APL , DS , SSHFP , IPSECKEY , RRSIG , NSEC , DNSKEY , DHCID , NSEC3 , NSEC3PARAM , TLSA , HIP , SPF , TKEY , TSIG , IXFR , AXFR , ANY , CAA , TA , DLV } ; final StringBuilder expected = new StringBuilder ( <int> ) ; expected . append ( <str> ) ; for ( DnsRecordType type : all ) { BY_NAME . put ( type . name ( ) , type ) ; BY_TYPE . put ( type . intValue ( ) , type ) ; expected . append ( type . name ( ) ) . append ( <str> ) . append ( type . intValue ( ) ) . append ( <str> ) ; } expected . setLength ( expected . length ( ) - <int> ) ; expected . append ( <str> ) ; EXPECTED = expected . toString ( ) ; } public static DnsRecordType valueOf ( int intValue ) { DnsRecordType result = BY_TYPE . get ( intValue ) ; if ( result = = null ) { return new DnsRecordType ( intValue ) ; } return result ; } public static DnsRecordType valueOf ( String name ) { DnsRecordType result = BY_NAME . get ( name ) ; if ( result = = null ) { throw new IllegalArgumentException ( <str> + name + EXPECTED ) ; } return result ; } private final int intValue ; private final String name ; private String text ; private DnsRecordType ( int intValue ) { this ( intValue , <str> ) ; } public DnsRecordType ( int intValue , String name ) { if ( ( intValue & <hex> ) ! = intValue ) { throw new IllegalArgumentException ( <str> + intValue + <str> ) ; } this . intValue = intValue ; this . name = name ; } public String name ( ) { return name ; } public int intValue ( ) { return intValue ; } @Override public int hashCode ( ) { return intValue ; } @Override public boolean equals ( Object o ) { return o instanceof DnsRecordType & & ( ( DnsRecordType ) o ) . intValue = = intValue ; } @Override public int compareTo ( DnsRecordType o ) { return intValue ( ) - o . intValue ( ) ; } @Override public String toString ( ) { String text = this . text ; if ( text = = null ) { this . text = text = name + <str> + intValue ( ) + <str> ; } return text ; } } 
