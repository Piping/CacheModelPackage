package com . badlogic . gdx . graphics . g3d . particles . batches ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . g3d . particles . ParticleSorter ; import com . badlogic . gdx . graphics . g3d . particles . renderers . ParticleControllerRenderData ; import com . badlogic . gdx . utils . Array ; public abstract class BufferedParticleBatch < T extends ParticleControllerRenderData > implements ParticleBatch < T > { protected Array < T > renderData ; protected int bufferedParticlesCount , currentCapacity = <int> ; protected ParticleSorter sorter ; protected Camera camera ; protected BufferedParticleBatch ( Class < T > type ) { this . sorter = new ParticleSorter . Distance ( ) ; renderData = new com . badlogic . gdx . utils . Array < T > ( false , <int> , type ) ; } public void begin ( ) { renderData . clear ( ) ; bufferedParticlesCount = <int> ; } @Override public void draw ( T data ) { if ( data . controller . particles . size > <int> ) { renderData . add ( data ) ; bufferedParticlesCount + = data . controller . particles . size ; } } public void end ( ) { if ( bufferedParticlesCount > <int> ) { ensureCapacity ( bufferedParticlesCount ) ; flush ( sorter . sort ( renderData ) ) ; } } public void ensureCapacity ( int capacity ) { if ( currentCapacity > = capacity ) return ; sorter . ensureCapacity ( capacity ) ; allocParticlesData ( capacity ) ; currentCapacity = capacity ; } public void resetCapacity ( ) { currentCapacity = bufferedParticlesCount = <int> ; } protected abstract void allocParticlesData ( int capacity ) ; public void setCamera ( Camera camera ) { this . camera = camera ; sorter . setCamera ( camera ) ; } public ParticleSorter getSorter ( ) { return sorter ; } public void setSorter ( ParticleSorter sorter ) { this . sorter = sorter ; sorter . setCamera ( camera ) ; sorter . ensureCapacity ( currentCapacity ) ; } protected abstract void flush ( int [ ] offsets ) ; public int getBufferedCount ( ) { return bufferedParticlesCount ; } } 
