package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public class Slice { public static final Serializer serializer = new Serializer ( ) ; public static final Slice ALL = new Slice ( Bound . BOTTOM , Bound . TOP ) { @Override public boolean selects ( ClusteringComparator comparator , Clustering clustering ) { return true ; } @Override public boolean intersects ( ClusteringComparator comparator , List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) { return true ; } @Override public String toString ( ClusteringComparator comparator ) { return <str> ; } } ; private final Bound start ; private final Bound end ; private Slice ( Bound start , Bound end ) { assert start . isStart ( ) & & end . isEnd ( ) ; this . start = start ; this . end = end ; } public static Slice make ( Bound start , Bound end ) { if ( start = = Bound . BOTTOM & & end = = Bound . TOP ) return ALL ; return new Slice ( start , end ) ; } public static Slice make ( ClusteringComparator comparator , Object . . . values ) { CBuilder builder = CBuilder . create ( comparator ) ; for ( Object val : values ) { if ( val instanceof ByteBuffer ) builder . add ( ( ByteBuffer ) val ) ; else builder . add ( val ) ; } return new Slice ( builder . buildBound ( true , true ) , builder . buildBound ( false , true ) ) ; } public static Slice make ( Clustering clustering ) { assert clustering ! = Clustering . STATIC_CLUSTERING ; ByteBuffer [ ] values = extractValues ( clustering ) ; return new Slice ( Bound . inclusiveStartOf ( values ) , Bound . inclusiveEndOf ( values ) ) ; } public static Slice make ( Clustering start , Clustering end ) { assert start ! = Clustering . STATIC_CLUSTERING & & end ! = Clustering . STATIC_CLUSTERING ; ByteBuffer [ ] startValues = extractValues ( start ) ; ByteBuffer [ ] endValues = extractValues ( end ) ; return new Slice ( Bound . inclusiveStartOf ( startValues ) , Bound . inclusiveEndOf ( endValues ) ) ; } private static ByteBuffer [ ] extractValues ( ClusteringPrefix clustering ) { ByteBuffer [ ] values = new ByteBuffer [ clustering . size ( ) ] ; for ( int i = <int> ; i < clustering . size ( ) ; i + + ) values [ i ] = clustering . get ( i ) ; return values ; } public Bound start ( ) { return start ; } public Bound end ( ) { return end ; } public Bound open ( boolean reversed ) { return reversed ? end : start ; } public Bound close ( boolean reversed ) { return reversed ? start : end ; } public boolean isEmpty ( ClusteringComparator comparator ) { return isEmpty ( comparator , start ( ) , end ( ) ) ; } public static boolean isEmpty ( ClusteringComparator comparator , Slice . Bound start , Slice . Bound end ) { assert start . isStart ( ) & & end . isEnd ( ) ; return comparator . compare ( end , start ) < <int> ; } public boolean selects ( ClusteringComparator comparator , Clustering clustering ) { return comparator . compare ( start , clustering ) < = <int> & & comparator . compare ( clustering , end ) < = <int> ; } public boolean includes ( ClusteringComparator comparator , Bound bound ) { return comparator . compare ( start , bound ) < = <int> & & comparator . compare ( bound , end ) < = <int> ; } public Slice forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive , boolean reversed ) { if ( lastReturned = = null ) return this ; if ( reversed ) { int cmp = comparator . compare ( lastReturned , start ) ; if ( cmp < <int> | | ( ! inclusive & & cmp = = <int> ) ) return null ; cmp = comparator . compare ( end , lastReturned ) ; if ( cmp < <int> | | ( inclusive & & cmp = = <int> ) ) return this ; ByteBuffer [ ] values = extractValues ( lastReturned ) ; return new Slice ( start , inclusive ? Bound . inclusiveEndOf ( values ) : Bound . exclusiveEndOf ( values ) ) ; } else { int cmp = comparator . compare ( end , lastReturned ) ; if ( cmp < <int> | | ( ! inclusive & & cmp = = <int> ) ) return null ; cmp = comparator . compare ( lastReturned , start ) ; if ( cmp < <int> | | ( inclusive & & cmp = = <int> ) ) return this ; ByteBuffer [ ] values = extractValues ( lastReturned ) ; return new Slice ( inclusive ? Bound . inclusiveStartOf ( values ) : Bound . exclusiveStartOf ( values ) , end ) ; } } public boolean intersects ( ClusteringComparator comparator , List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) { if ( start . compareTo ( comparator , maxClusteringValues ) > <int> | | end . compareTo ( comparator , minClusteringValues ) < <int> ) return false ; for ( int j = <int> ; j < minClusteringValues . size ( ) & & j < maxClusteringValues . size ( ) ; j + + ) { ByteBuffer s = j < start . size ( ) ? start . get ( j ) : null ; ByteBuffer f = j < end . size ( ) ? end . get ( j ) : null ; if ( j > <int> & & ( j < end . size ( ) & & comparator . compareComponent ( j , f , minClusteringValues . get ( j ) ) < <int> | | j < start . size ( ) & & comparator . compareComponent ( j , s , maxClusteringValues . get ( j ) ) > <int> ) ) return false ; if ( j > = start . size ( ) | | j > = end . size ( ) | | comparator . compareComponent ( j , s , f ) ! = <int> ) break ; } return true ; } public String toString ( CFMetaData metadata ) { return toString ( metadata . comparator ) ; } public String toString ( ClusteringComparator comparator ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( start . isInclusive ( ) ? <str> : <str> ) ; for ( int i = <int> ; i < start . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( comparator . subtype ( i ) . getString ( start . get ( i ) ) ) ; } sb . append ( <str> ) ; for ( int i = <int> ; i < end . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( comparator . subtype ( i ) . getString ( end . get ( i ) ) ) ; } sb . append ( end . isInclusive ( ) ? <str> : <str> ) ; return sb . toString ( ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof Slice ) ) return false ; Slice that = ( Slice ) other ; return this . start ( ) . equals ( that . start ( ) ) & & this . end ( ) . equals ( that . end ( ) ) ; } @Override public int hashCode ( ) { return Objects . hash ( start ( ) , end ( ) ) ; } public static class Serializer { public void serialize ( Slice slice , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { Bound . serializer . serialize ( slice . start , out , version , types ) ; Bound . serializer . serialize ( slice . end , out , version , types ) ; } public long serializedSize ( Slice slice , int version , List < AbstractType < ? > > types ) { return Bound . serializer . serializedSize ( slice . start , version , types ) + Bound . serializer . serializedSize ( slice . end , version , types ) ; } public Slice deserialize ( DataInputPlus in , int version , List < AbstractType < ? > > types ) throws IOException { Bound start = Bound . serializer . deserialize ( in , version , types ) ; Bound end = Bound . serializer . deserialize ( in , version , types ) ; return new Slice ( start , end ) ; } } public static class Bound extends AbstractClusteringPrefix { public static final Serializer serializer = new Serializer ( ) ; public static final Bound BOTTOM = RangeTombstone . Bound . BOTTOM ; public static final Bound TOP = RangeTombstone . Bound . TOP ; protected Bound ( Kind kind , ByteBuffer [ ] values ) { super ( kind , values ) ; } public static Bound create ( Kind kind , ByteBuffer [ ] values ) { assert ! kind . isBoundary ( ) ; return new Bound ( kind , values ) ; } public static Kind boundKind ( boolean isStart , boolean isInclusive ) { return isStart ? ( isInclusive ? Kind . INCL_START_BOUND : Kind . EXCL_START_BOUND ) : ( isInclusive ? Kind . INCL_END_BOUND : Kind . EXCL_END_BOUND ) ; } public static Bound inclusiveStartOf ( ByteBuffer . . . values ) { return create ( Kind . INCL_START_BOUND , values ) ; } public static Bound inclusiveEndOf ( ByteBuffer . . . values ) { return create ( Kind . INCL_END_BOUND , values ) ; } public static Bound exclusiveStartOf ( ByteBuffer . . . values ) { return create ( Kind . EXCL_START_BOUND , values ) ; } public static Bound exclusiveEndOf ( ByteBuffer . . . values ) { return create ( Kind . EXCL_END_BOUND , values ) ; } public static Bound inclusiveStartOf ( ClusteringPrefix prefix ) { ByteBuffer [ ] values = new ByteBuffer [ prefix . size ( ) ] ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) values [ i ] = prefix . get ( i ) ; return inclusiveStartOf ( values ) ; } public static Bound exclusiveStartOf ( ClusteringPrefix prefix ) { ByteBuffer [ ] values = new ByteBuffer [ prefix . size ( ) ] ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) values [ i ] = prefix . get ( i ) ; return exclusiveStartOf ( values ) ; } public static Bound inclusiveEndOf ( ClusteringPrefix prefix ) { ByteBuffer [ ] values = new ByteBuffer [ prefix . size ( ) ] ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) values [ i ] = prefix . get ( i ) ; return inclusiveEndOf ( values ) ; } public static Bound create ( ClusteringComparator comparator , boolean isStart , boolean isInclusive , Object . . . values ) { CBuilder builder = CBuilder . create ( comparator ) ; for ( Object val : values ) { if ( val instanceof ByteBuffer ) builder . add ( ( ByteBuffer ) val ) ; else builder . add ( val ) ; } return builder . buildBound ( isStart , isInclusive ) ; } public Bound withNewKind ( Kind kind ) { assert ! kind . isBoundary ( ) ; return new Bound ( kind , values ) ; } public boolean isStart ( ) { return kind ( ) . isStart ( ) ; } public boolean isEnd ( ) { return ! isStart ( ) ; } public boolean isInclusive ( ) { return kind = = Kind . INCL_START_BOUND | | kind = = Kind . INCL_END_BOUND ; } public boolean isExclusive ( ) { return kind = = Kind . EXCL_START_BOUND | | kind = = Kind . EXCL_END_BOUND ; } public Slice . Bound invert ( ) { return withNewKind ( kind ( ) . invert ( ) ) ; } private int compareTo ( ClusteringComparator comparator , List < ByteBuffer > sstableBound ) { for ( int i = <int> ; i < sstableBound . size ( ) ; i + + ) { if ( i > = size ( ) ) return isStart ( ) ? - <int> : <int> ; int cmp = comparator . compareComponent ( i , get ( i ) , sstableBound . get ( i ) ) ; if ( cmp ! = <int> ) return cmp ; } if ( size ( ) > sstableBound . size ( ) ) return isStart ( ) ? - <int> : <int> ; return isInclusive ( ) ? <int> : ( isStart ( ) ? <int> : - <int> ) ; } public String toString ( CFMetaData metadata ) { return toString ( metadata . comparator ) ; } public String toString ( ClusteringComparator comparator ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( kind ( ) ) . append ( <str> ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( comparator . subtype ( i ) . getString ( get ( i ) ) ) ; } return sb . append ( <str> ) . toString ( ) ; } public static class Serializer { public void serialize ( Slice . Bound bound , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { out . writeByte ( bound . kind ( ) . ordinal ( ) ) ; out . writeShort ( bound . size ( ) ) ; ClusteringPrefix . serializer . serializeValuesWithoutSize ( bound , out , version , types ) ; } public long serializedSize ( Slice . Bound bound , int version , List < AbstractType < ? > > types ) { return <int> + TypeSizes . sizeof ( ( short ) bound . size ( ) ) + ClusteringPrefix . serializer . valuesWithoutSizeSerializedSize ( bound , version , types ) ; } public Slice . Bound deserialize ( DataInputPlus in , int version , List < AbstractType < ? > > types ) throws IOException { Kind kind = Kind . values ( ) [ in . readByte ( ) ] ; return deserializeValues ( in , kind , version , types ) ; } public Slice . Bound deserializeValues ( DataInputPlus in , Kind kind , int version , List < AbstractType < ? > > types ) throws IOException { int size = in . readUnsignedShort ( ) ; if ( size = = <int> ) return kind . isStart ( ) ? BOTTOM : TOP ; ByteBuffer [ ] values = ClusteringPrefix . serializer . deserializeValuesWithoutSize ( in , size , version , types ) ; return Slice . Bound . create ( kind , values ) ; } } } } 
