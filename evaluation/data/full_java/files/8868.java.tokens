package org . elasticsearch . repositories . azure ; import com . microsoft . azure . storage . StorageException ; import com . microsoft . azure . storage . LocationMode ; import org . elasticsearch . cloud . azure . blobstore . AzureBlobStore ; import org . elasticsearch . cloud . azure . storage . AzureStorageService . Storage ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . BlobStore ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . repositories . RepositoryName ; import org . elasticsearch . repositories . RepositorySettings ; import org . elasticsearch . repositories . RepositoryVerificationException ; import org . elasticsearch . repositories . blobstore . BlobStoreRepository ; import org . elasticsearch . snapshots . SnapshotCreationException ; import java . io . IOException ; import java . net . URISyntaxException ; import java . util . List ; import java . util . Locale ; public class AzureRepository extends BlobStoreRepository { public final static String TYPE = <str> ; public final static String CONTAINER_DEFAULT = <str> ; static public final class Repository { public static final String ACCOUNT = <str> ; public static final String LOCATION_MODE = <str> ; public static final String CONTAINER = <str> ; public static final String CHUNK_SIZE = <str> ; public static final String COMPRESS = <str> ; public static final String BASE_PATH = <str> ; } private final AzureBlobStore blobStore ; private final BlobPath basePath ; private ByteSizeValue chunkSize ; private boolean compress ; private final boolean readonly ; @Inject public AzureRepository ( RepositoryName name , RepositorySettings repositorySettings , IndexShardRepository indexShardRepository , AzureBlobStore azureBlobStore ) throws IOException , URISyntaxException , StorageException { super ( name . getName ( ) , repositorySettings , indexShardRepository ) ; String container = repositorySettings . settings ( ) . get ( Repository . CONTAINER , settings . get ( Storage . CONTAINER , CONTAINER_DEFAULT ) ) ; this . blobStore = azureBlobStore ; this . chunkSize = repositorySettings . settings ( ) . getAsBytesSize ( Repository . CHUNK_SIZE , settings . getAsBytesSize ( Storage . CHUNK_SIZE , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ) ; if ( this . chunkSize . getMb ( ) > <int> ) { logger . warn ( <str> ) ; this . chunkSize = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ; } this . compress = repositorySettings . settings ( ) . getAsBoolean ( Repository . COMPRESS , settings . getAsBoolean ( Storage . COMPRESS , false ) ) ; String modeStr = repositorySettings . settings ( ) . get ( Repository . LOCATION_MODE , null ) ; if ( modeStr ! = null ) { LocationMode locationMode = LocationMode . valueOf ( modeStr . toUpperCase ( Locale . ROOT ) ) ; if ( locationMode = = LocationMode . SECONDARY_ONLY ) { readonly = true ; } else { readonly = false ; } } else { readonly = false ; } String basePath = repositorySettings . settings ( ) . get ( Repository . BASE_PATH , null ) ; if ( Strings . hasLength ( basePath ) ) { basePath = Strings . trimLeadingCharacter ( basePath , <str> ) ; BlobPath path = new BlobPath ( ) ; for ( String elem : Strings . splitStringToArray ( basePath , <str> ) ) { path = path . add ( elem ) ; } this . basePath = path ; } else { this . basePath = BlobPath . cleanPath ( ) ; } logger . debug ( <str> , container , chunkSize , compress , basePath ) ; } @Override protected BlobStore blobStore ( ) { return blobStore ; } @Override protected BlobPath basePath ( ) { return basePath ; } @Override protected boolean isCompress ( ) { return compress ; } @Override protected ByteSizeValue chunkSize ( ) { return chunkSize ; } @Override public void initializeSnapshot ( SnapshotId snapshotId , List < String > indices , MetaData metaData ) { try { if ( ! blobStore . doesContainerExist ( blobStore . container ( ) ) ) { logger . debug ( <str> , blobStore . container ( ) ) ; blobStore . createContainer ( blobStore . container ( ) ) ; } super . initializeSnapshot ( snapshotId , indices , metaData ) ; } catch ( StorageException | URISyntaxException e ) { logger . warn ( <str> , blobStore . container ( ) , e . getMessage ( ) ) ; throw new SnapshotCreationException ( snapshotId , e ) ; } } @Override public String startVerification ( ) { if ( readonly = = false ) { try { if ( ! blobStore . doesContainerExist ( blobStore . container ( ) ) ) { logger . debug ( <str> , blobStore . container ( ) ) ; blobStore . createContainer ( blobStore . container ( ) ) ; } } catch ( StorageException | URISyntaxException e ) { logger . warn ( <str> , blobStore . container ( ) , e . getMessage ( ) ) ; throw new RepositoryVerificationException ( repositoryName , <str> + blobStore . container ( ) , e ) ; } } return super . startVerification ( ) ; } @Override public boolean readOnly ( ) { return readonly ; } } 
