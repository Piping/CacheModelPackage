package org . gradle . sonar . runner . plugins ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import org . gradle . api . * ; import org . gradle . api . artifacts . Configuration ; import org . gradle . api . artifacts . Dependency ; import org . gradle . api . artifacts . DependencySet ; import org . gradle . api . artifacts . dsl . DependencyHandler ; import org . gradle . api . internal . ConventionMapping ; import org . gradle . api . internal . plugins . DslObject ; import org . gradle . api . plugins . JavaBasePlugin ; import org . gradle . api . plugins . JavaPlugin ; import org . gradle . api . plugins . JavaPluginConvention ; import org . gradle . api . tasks . SourceSet ; import org . gradle . api . tasks . testing . Test ; import org . gradle . internal . jvm . Jvm ; import org . gradle . listener . ActionBroadcast ; import org . gradle . sonar . runner . SonarProperties ; import org . gradle . sonar . runner . SonarRunnerExtension ; import org . gradle . sonar . runner . SonarRunnerRootExtension ; import org . gradle . sonar . runner . tasks . SonarRunner ; import org . gradle . testing . jacoco . plugins . JacocoPlugin ; import org . gradle . testing . jacoco . plugins . JacocoTaskExtension ; import org . gradle . util . SingleMessageLogger ; import java . io . File ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import static org . gradle . util . CollectionUtils . nonEmptyOrNull ; @Deprecated public class SonarRunnerPlugin implements Plugin < Project > { private static final Predicate < File > FILE_EXISTS = new Predicate < File > ( ) { public boolean apply ( File input ) { return input . exists ( ) ; } } ; private static final Predicate < File > IS_DIRECTORY = new Predicate < File > ( ) { public boolean apply ( File input ) { return input . isDirectory ( ) ; } } ; private static final Predicate < File > IS_FILE = new Predicate < File > ( ) { public boolean apply ( File input ) { return input . isFile ( ) ; } } ; private static final Joiner COMMA_JOINER = Joiner . on ( <str> ) ; private Project targetProject ; public void apply ( Project project ) { SingleMessageLogger . nagUserOfDeprecated ( <str> , <str> ) ; targetProject = project ; final Map < Project , ActionBroadcast < SonarProperties > > actionBroadcastMap = Maps . newHashMap ( ) ; SonarRunner sonarRunnerTask = createTask ( project , actionBroadcastMap ) ; ActionBroadcast < SonarProperties > actionBroadcast = addBroadcaster ( actionBroadcastMap , project ) ; project . subprojects ( new Action < Project > ( ) { public void execute ( Project project ) { ActionBroadcast < SonarProperties > actionBroadcast = addBroadcaster ( actionBroadcastMap , project ) ; project . getExtensions ( ) . create ( SonarRunnerExtension . SONAR_RUNNER_EXTENSION_NAME , SonarRunnerExtension . class , actionBroadcast ) ; } } ) ; SonarRunnerRootExtension rootExtension = project . getExtensions ( ) . create ( SonarRunnerExtension . SONAR_RUNNER_EXTENSION_NAME , SonarRunnerRootExtension . class , actionBroadcast ) ; addConfiguration ( project , rootExtension ) ; rootExtension . setForkOptions ( sonarRunnerTask . getForkOptions ( ) ) ; } private ActionBroadcast < SonarProperties > addBroadcaster ( Map < Project , ActionBroadcast < SonarProperties > > actionBroadcastMap , Project project ) { ActionBroadcast < SonarProperties > actionBroadcast = new ActionBroadcast < SonarProperties > ( ) ; actionBroadcastMap . put ( project , actionBroadcast ) ; return actionBroadcast ; } private SonarRunner createTask ( final Project project , final Map < Project , ActionBroadcast < SonarProperties > > actionBroadcastMap ) { SonarRunner sonarRunnerTask = project . getTasks ( ) . create ( SonarRunnerExtension . SONAR_RUNNER_TASK_NAME , SonarRunner . class ) ; sonarRunnerTask . setDescription ( <str> + project + <str> ) ; ConventionMapping conventionMapping = new DslObject ( sonarRunnerTask ) . getConventionMapping ( ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { Map < String , Object > properties = Maps . newLinkedHashMap ( ) ; computeSonarProperties ( project , properties , actionBroadcastMap ) ; return properties ; } } ) ; sonarRunnerTask . dependsOn ( new Callable < Iterable < ? extends Task > > ( ) { public Iterable < ? extends Task > call ( ) throws Exception { Iterable < Project > applicableProjects = Iterables . filter ( project . getAllprojects ( ) , new Predicate < Project > ( ) { public boolean apply ( Project input ) { return input . getPlugins ( ) . hasPlugin ( JavaPlugin . class ) & & ! input . getExtensions ( ) . getByType ( SonarRunnerExtension . class ) . isSkipProject ( ) ; } } ) ; return Iterables . transform ( applicableProjects , new Function < Project , Task > ( ) { @Nullable public Task apply ( Project input ) { return input . getTasks ( ) . getByName ( JavaPlugin . TEST_TASK_NAME ) ; } } ) ; } } ) ; return sonarRunnerTask ; } public void computeSonarProperties ( Project project , Map < String , Object > properties , Map < Project , ActionBroadcast < SonarProperties > > sonarPropertiesActionBroadcastMap ) { SonarRunnerExtension extension = project . getExtensions ( ) . getByType ( SonarRunnerExtension . class ) ; if ( extension . isSkipProject ( ) ) { return ; } Map < String , Object > rawProperties = Maps . newLinkedHashMap ( ) ; addGradleDefaults ( project , rawProperties ) ; evaluateSonarPropertiesBlocks ( sonarPropertiesActionBroadcastMap . get ( project ) , rawProperties ) ; if ( project . equals ( targetProject ) ) { addSystemProperties ( rawProperties ) ; } String projectPrefix = project . getPath ( ) . substring ( targetProject . getPath ( ) . length ( ) ) . replace ( <str> , <str> ) ; if ( projectPrefix . startsWith ( <str> ) ) { projectPrefix = projectPrefix . substring ( <int> ) ; } convertProperties ( rawProperties , projectPrefix , properties ) ; List < Project > enabledChildProjects = Lists . newLinkedList ( Iterables . filter ( project . getChildProjects ( ) . values ( ) , new Predicate < Project > ( ) { public boolean apply ( Project input ) { return ! input . getExtensions ( ) . getByType ( SonarRunnerExtension . class ) . isSkipProject ( ) ; } } ) ) ; if ( enabledChildProjects . isEmpty ( ) ) { return ; } Collections . sort ( enabledChildProjects ) ; String modules = COMMA_JOINER . join ( Iterables . transform ( enabledChildProjects , new Function < Project , String > ( ) { public String apply ( Project input ) { return input . getName ( ) ; } } ) ) ; properties . put ( convertKey ( <str> , projectPrefix ) , modules ) ; for ( Project childProject : enabledChildProjects ) { computeSonarProperties ( childProject , properties , sonarPropertiesActionBroadcastMap ) ; } } private void addGradleDefaults ( final Project project , final Map < String , Object > properties ) { properties . put ( <str> , project . getName ( ) ) ; properties . put ( <str> , project . getDescription ( ) ) ; properties . put ( <str> , project . getVersion ( ) ) ; properties . put ( <str> , project . getProjectDir ( ) ) ; properties . put ( <str> , <str> ) ; if ( project . equals ( targetProject ) ) { properties . put ( <str> , getProjectKey ( project ) ) ; properties . put ( <str> , <str> ) ; properties . put ( <str> , project . getGradle ( ) . getGradleVersion ( ) ) ; properties . put ( <str> , new File ( project . getBuildDir ( ) , <str> ) ) ; } project . getPlugins ( ) . withType ( JavaBasePlugin . class , new Action < JavaBasePlugin > ( ) { public void execute ( JavaBasePlugin javaBasePlugin ) { JavaPluginConvention javaPluginConvention = new DslObject ( project ) . getConvention ( ) . getPlugin ( JavaPluginConvention . class ) ; properties . put ( <str> , javaPluginConvention . getSourceCompatibility ( ) ) ; properties . put ( <str> , javaPluginConvention . getTargetCompatibility ( ) ) ; } } ) ; project . getPlugins ( ) . withType ( JavaPlugin . class , new Action < JavaPlugin > ( ) { public void execute ( JavaPlugin javaPlugin ) { JavaPluginConvention javaPluginConvention = new DslObject ( project ) . getConvention ( ) . getPlugin ( JavaPluginConvention . class ) ; SourceSet main = javaPluginConvention . getSourceSets ( ) . getAt ( <str> ) ; List < File > sourceDirectories = nonEmptyOrNull ( Iterables . filter ( main . getAllSource ( ) . getSrcDirs ( ) , FILE_EXISTS ) ) ; properties . put ( <str> , sourceDirectories ) ; SourceSet test = javaPluginConvention . getSourceSets ( ) . getAt ( <str> ) ; List < File > testDirectories = nonEmptyOrNull ( Iterables . filter ( test . getAllSource ( ) . getSrcDirs ( ) , FILE_EXISTS ) ) ; properties . put ( <str> , testDirectories ) ; properties . put ( <str> , nonEmptyOrNull ( Iterables . filter ( main . getRuntimeClasspath ( ) , IS_DIRECTORY ) ) ) ; properties . put ( <str> , getLibraries ( main ) ) ; final Test testTask = ( Test ) project . getTasks ( ) . getByName ( JavaPlugin . TEST_TASK_NAME ) ; if ( sourceDirectories ! = null | | testDirectories ! = null ) { File testResultsDir = testTask . getReports ( ) . getJunitXml ( ) . getDestination ( ) ; testResultsDir . mkdirs ( ) ; properties . put ( <str> , testResultsDir ) ; properties . put ( <str> , testResultsDir ) ; } project . getPlugins ( ) . withType ( JacocoPlugin . class , new Action < JacocoPlugin > ( ) { public void execute ( JacocoPlugin jacocoPlugin ) { JacocoTaskExtension jacocoTaskExtension = testTask . getExtensions ( ) . getByType ( JacocoTaskExtension . class ) ; File destinationFile = jacocoTaskExtension . getDestinationFile ( ) ; if ( destinationFile . exists ( ) ) { properties . put ( <str> , destinationFile ) ; } } } ) ; } } ) ; if ( properties . get ( <str> ) = = null ) { properties . put ( <str> , <str> ) ; } } private String getProjectKey ( Project project ) { String name = project . getName ( ) ; String group = project . getGroup ( ) . toString ( ) ; return group . isEmpty ( ) ? name : group + <str> + name ; } private void addSystemProperties ( Map < String , Object > properties ) { for ( Map . Entry < Object , Object > entry : System . getProperties ( ) . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) ; if ( key . startsWith ( <str> ) ) { properties . put ( key , entry . getValue ( ) ) ; } } } private Collection < File > getLibraries ( SourceSet main ) { List < File > libraries = Lists . newLinkedList ( Iterables . filter ( main . getRuntimeClasspath ( ) , IS_FILE ) ) ; File runtimeJar = Jvm . current ( ) . getRuntimeJar ( ) ; if ( runtimeJar ! = null ) { libraries . add ( runtimeJar ) ; } return libraries ; } private void convertProperties ( Map < String , Object > rawProperties , final String projectPrefix , final Map < String , Object > properties ) { for ( Map . Entry < String , Object > entry : rawProperties . entrySet ( ) ) { String value = convertValue ( entry . getValue ( ) ) ; if ( value ! = null ) { properties . put ( convertKey ( entry . getKey ( ) , projectPrefix ) , value ) ; } } } private String convertKey ( String key , final String projectPrefix ) { return projectPrefix . isEmpty ( ) ? key : projectPrefix + <str> + key ; } private String convertValue ( Object value ) { if ( value = = null ) { return null ; } if ( value instanceof Iterable < ? > ) { Iterable < String > flattened = Iterables . transform ( ( Iterable < ? > ) value , new Function < Object , String > ( ) { public String apply ( Object input ) { return convertValue ( input ) ; } } ) ; Iterable < String > filtered = Iterables . filter ( flattened , Predicates . notNull ( ) ) ; String joined = COMMA_JOINER . join ( filtered ) ; return joined . isEmpty ( ) ? null : joined ; } else { return value . toString ( ) ; } } private void addConfiguration ( final Project project , final SonarRunnerRootExtension rootExtension ) { final Configuration configuration = project . getConfigurations ( ) . create ( SonarRunnerExtension . SONAR_RUNNER_CONFIGURATION_NAME ) ; configuration . setVisible ( false ) . setTransitive ( false ) . setDescription ( <str> ) . defaultDependencies ( new Action < DependencySet > ( ) { @Override public void execute ( DependencySet dependencies ) { String toolVersion = rootExtension . getToolVersion ( ) ; DependencyHandler dependencyHandler = project . getDependencies ( ) ; Dependency dependency = dependencyHandler . create ( <str> + toolVersion ) ; dependencies . add ( dependency ) ; } } ) ; } private static void evaluateSonarPropertiesBlocks ( ActionBroadcast < ? super SonarProperties > propertiesActions , Map < String , Object > properties ) { SonarProperties sonarProperties = new SonarProperties ( properties ) ; propertiesActions . execute ( sonarProperties ) ; } } 
