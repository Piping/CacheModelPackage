package org . apache . cassandra . locator ; import java . io . InputStream ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . ResourceWatcher ; import org . apache . cassandra . utils . WrappedRunnable ; import org . apache . commons . lang3 . StringUtils ; public class PropertyFileSnitch extends AbstractNetworkTopologySnitch { private static final Logger logger = LoggerFactory . getLogger ( PropertyFileSnitch . class ) ; public static final String SNITCH_PROPERTIES_FILENAME = <str> ; private static final int DEFAULT_REFRESH_PERIOD_IN_SECONDS = <int> ; private static volatile Map < InetAddress , String [ ] > endpointMap ; private static volatile String [ ] defaultDCRack ; private volatile boolean gossipStarted ; public PropertyFileSnitch ( ) throws ConfigurationException { this ( DEFAULT_REFRESH_PERIOD_IN_SECONDS ) ; } public PropertyFileSnitch ( int refreshPeriodInSeconds ) throws ConfigurationException { reloadConfiguration ( false ) ; try { FBUtilities . resourceToFile ( SNITCH_PROPERTIES_FILENAME ) ; Runnable runnable = new WrappedRunnable ( ) { protected void runMayThrow ( ) throws ConfigurationException { reloadConfiguration ( true ) ; } } ; ResourceWatcher . watch ( SNITCH_PROPERTIES_FILENAME , runnable , refreshPeriodInSeconds * <int> ) ; } catch ( ConfigurationException ex ) { logger . error ( <str> , SNITCH_PROPERTIES_FILENAME ) ; } } public static String [ ] getEndpointInfo ( InetAddress endpoint ) { String [ ] rawEndpointInfo = getRawEndpointInfo ( endpoint ) ; if ( rawEndpointInfo = = null ) throw new RuntimeException ( <str> + endpoint + <str> ) ; return rawEndpointInfo ; } private static String [ ] getRawEndpointInfo ( InetAddress endpoint ) { String [ ] value = endpointMap . get ( endpoint ) ; if ( value = = null ) { logger . trace ( <str> , endpoint ) ; return defaultDCRack ; } return value ; } public String getDatacenter ( InetAddress endpoint ) { String [ ] info = getEndpointInfo ( endpoint ) ; assert info ! = null : <str> + endpoint ; return info [ <int> ] ; } public String getRack ( InetAddress endpoint ) { String [ ] info = getEndpointInfo ( endpoint ) ; assert info ! = null : <str> + endpoint ; return info [ <int> ] ; } public void reloadConfiguration ( boolean isUpdate ) throws ConfigurationException { HashMap < InetAddress , String [ ] > reloadedMap = new HashMap < > ( ) ; String [ ] reloadedDefaultDCRack = null ; Properties properties = new Properties ( ) ; try ( InputStream stream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( SNITCH_PROPERTIES_FILENAME ) ) { properties . load ( stream ) ; } catch ( Exception e ) { throw new ConfigurationException ( <str> + SNITCH_PROPERTIES_FILENAME , e ) ; } for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { String key = ( String ) entry . getKey ( ) ; String value = ( String ) entry . getValue ( ) ; if ( <str> . equals ( key ) ) { String [ ] newDefault = value . split ( <str> ) ; if ( newDefault . length < <int> ) reloadedDefaultDCRack = new String [ ] { <str> , <str> } ; else reloadedDefaultDCRack = new String [ ] { newDefault [ <int> ] . trim ( ) , newDefault [ <int> ] . trim ( ) } ; } else { InetAddress host ; String hostString = StringUtils . remove ( key , <str> ) ; try { host = InetAddress . getByName ( hostString ) ; } catch ( UnknownHostException e ) { throw new ConfigurationException ( <str> + hostString , e ) ; } String [ ] token = value . split ( <str> ) ; if ( token . length < <int> ) token = new String [ ] { <str> , <str> } ; else token = new String [ ] { token [ <int> ] . trim ( ) , token [ <int> ] . trim ( ) } ; reloadedMap . put ( host , token ) ; } } if ( reloadedDefaultDCRack = = null & & ! reloadedMap . containsKey ( FBUtilities . getBroadcastAddress ( ) ) ) throw new ConfigurationException ( String . format ( <str> + <str> , SNITCH_PROPERTIES_FILENAME , FBUtilities . getBroadcastAddress ( ) ) ) ; if ( isUpdate & & ! livenessCheck ( reloadedMap , reloadedDefaultDCRack ) ) return ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < InetAddress , String [ ] > entry : reloadedMap . entrySet ( ) ) sb . append ( entry . getKey ( ) ) . append ( <str> ) . append ( Arrays . toString ( entry . getValue ( ) ) ) . append ( <str> ) ; logger . trace ( <str> , StringUtils . removeEnd ( sb . toString ( ) , <str> ) ) ; } defaultDCRack = reloadedDefaultDCRack ; endpointMap = reloadedMap ; if ( StorageService . instance ! = null ) { if ( isUpdate ) StorageService . instance . updateTopology ( ) ; else StorageService . instance . getTokenMetadata ( ) . invalidateCachedRings ( ) ; } if ( gossipStarted ) StorageService . instance . gossipSnitchInfo ( ) ; } private static boolean livenessCheck ( HashMap < InetAddress , String [ ] > reloadedMap , String [ ] reloadedDefaultDCRack ) { Set < InetAddress > hosts = Arrays . equals ( defaultDCRack , reloadedDefaultDCRack ) ? Sets . intersection ( StorageService . instance . getLiveRingMembers ( ) , Sets . union ( endpointMap . keySet ( ) , reloadedMap . keySet ( ) ) ) : StorageService . instance . getLiveRingMembers ( ) ; for ( InetAddress host : hosts ) { String [ ] origValue = endpointMap . containsKey ( host ) ? endpointMap . get ( host ) : defaultDCRack ; String [ ] updateValue = reloadedMap . containsKey ( host ) ? reloadedMap . get ( host ) : reloadedDefaultDCRack ; if ( ! Arrays . equals ( origValue , updateValue ) ) { logger . error ( <str> , origValue , updateValue , host ) ; return false ; } } return true ; } @Override public void gossiperStarting ( ) { gossipStarted = true ; } } 
