package org . gradle . util ; import groovy . lang . Closure ; import groovy . lang . MissingMethodException ; import org . gradle . api . internal . ClosureBackedAction ; import org . gradle . api . internal . DynamicObject ; import org . gradle . api . internal . DynamicObjectUtil ; import java . util . Collection ; import java . util . Map ; import static org . gradle . util . CollectionUtils . toStringList ; public class ConfigureUtil { public static < T > T configureByMap ( Map < ? , ? > properties , T delegate ) { DynamicObject dynamicObject = DynamicObjectUtil . asDynamicObject ( delegate ) ; for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { String name = entry . getKey ( ) . toString ( ) ; Object value = entry . getValue ( ) ; if ( dynamicObject . hasProperty ( name ) ) { dynamicObject . setProperty ( name , value ) ; } else { try { dynamicObject . invokeMethod ( name , value ) ; } catch ( MissingMethodException e ) { dynamicObject . setProperty ( name , value ) ; } } } return delegate ; } public static < T > T configureByMap ( Map < ? , ? > properties , T delegate , Collection < ? > mandatoryKeys ) { if ( ! mandatoryKeys . isEmpty ( ) ) { Collection < String > missingKeys = toStringList ( mandatoryKeys ) ; missingKeys . removeAll ( toStringList ( properties . keySet ( ) ) ) ; if ( ! missingKeys . isEmpty ( ) ) { throw new IncompleteInputException ( <str> + missingKeys , missingKeys ) ; } } return configureByMap ( properties , delegate ) ; } public static class IncompleteInputException extends RuntimeException { private final Collection missingKeys ; public IncompleteInputException ( String message , Collection missingKeys ) { super ( message ) ; this . missingKeys = missingKeys ; } public Collection getMissingKeys ( ) { return missingKeys ; } } public static < T > T configure ( Closure configureClosure , T delegate ) { return configure ( configureClosure , delegate , Closure . DELEGATE_FIRST , true ) ; } public static < T > T configure ( Closure configureClosure , T delegate , boolean configureableAware ) { return configure ( configureClosure , delegate , Closure . DELEGATE_FIRST , configureableAware ) ; } public static < T > T configure ( Closure configureClosure , T delegate , int resolveStrategy ) { return configure ( configureClosure , delegate , resolveStrategy , false ) ; } private static < T > T configure ( Closure configureClosure , T delegate , int resolveStrategy , boolean configureableAware ) { ClosureBackedAction < T > action = new ClosureBackedAction < T > ( configureClosure , resolveStrategy , configureableAware ) ; action . execute ( delegate ) ; return delegate ; } } 
