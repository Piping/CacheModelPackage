package org . apache . cassandra . stress . util ; import java . util . * ; import java . util . concurrent . ThreadLocalRandom ; public final class TimingInterval { private final long start ; private final long end ; public final long maxLatency ; public final long pauseLength ; public final long pauseStart ; public final long totalLatency ; public final long partitionCount ; public final long rowCount ; public final long operationCount ; public final long errorCount ; final SampleOfLongs sample ; public String toString ( ) { return String . format ( <str> + <str> , start , end , maxLatency , pauseLength , pauseStart , totalLatency , partitionCount , rowCount , operationCount , errorCount ) ; } TimingInterval ( long time ) { start = end = time ; maxLatency = totalLatency = <int> ; partitionCount = rowCount = operationCount = errorCount = <int> ; pauseStart = pauseLength = <int> ; sample = new SampleOfLongs ( new long [ <int> ] , <float> ) ; } TimingInterval ( long start , long end , long maxLatency , long pauseStart , long pauseLength , long partitionCount , long rowCount , long totalLatency , long operationCount , long errorCount , SampleOfLongs sample ) { this . start = start ; this . end = Math . max ( end , start ) ; this . maxLatency = maxLatency ; this . partitionCount = partitionCount ; this . rowCount = rowCount ; this . totalLatency = totalLatency ; this . errorCount = errorCount ; this . operationCount = operationCount ; this . pauseStart = pauseStart ; this . pauseLength = pauseLength ; this . sample = sample ; } static TimingInterval merge ( Iterable < TimingInterval > intervals , int maxSamples , long start ) { ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; long operationCount = <int> , partitionCount = <int> , rowCount = <int> , errorCount = <int> ; long maxLatency = <int> , totalLatency = <int> ; List < SampleOfLongs > latencies = new ArrayList < > ( ) ; long end = <int> ; long pauseStart = <int> , pauseEnd = Long . MAX_VALUE ; for ( TimingInterval interval : intervals ) { if ( interval ! = null ) { end = Math . max ( end , interval . end ) ; operationCount + = interval . operationCount ; maxLatency = Math . max ( interval . maxLatency , maxLatency ) ; totalLatency + = interval . totalLatency ; partitionCount + = interval . partitionCount ; rowCount + = interval . rowCount ; errorCount + = interval . errorCount ; latencies . addAll ( Arrays . asList ( interval . sample ) ) ; if ( interval . pauseLength > <int> ) { pauseStart = Math . max ( pauseStart , interval . pauseStart ) ; pauseEnd = Math . min ( pauseEnd , interval . pauseStart + interval . pauseLength ) ; } } } if ( pauseEnd < pauseStart | | pauseStart < = <int> ) { pauseEnd = pauseStart = <int> ; } return new TimingInterval ( start , end , maxLatency , pauseStart , pauseEnd - pauseStart , partitionCount , rowCount , totalLatency , operationCount , errorCount , SampleOfLongs . merge ( rnd , latencies , maxSamples ) ) ; } public double opRate ( ) { return operationCount / ( ( end - start ) * <float> ) ; } public double adjustedRowRate ( ) { return rowCount / ( ( end - ( start + pauseLength ) ) * <float> ) ; } public double partitionRate ( ) { return partitionCount / ( ( end - start ) * <float> ) ; } public double rowRate ( ) { return rowCount / ( ( end - start ) * <float> ) ; } public double meanLatency ( ) { return ( totalLatency / ( double ) operationCount ) * <float> ; } public double maxLatency ( ) { return maxLatency * <float> ; } public double medianLatency ( ) { return sample . medianLatency ( ) ; } public double rankLatency ( float rank ) { return sample . rankLatency ( rank ) ; } public long runTime ( ) { return ( end - start ) / <int> ; } public final long endNanos ( ) { return end ; } public long startNanos ( ) { return start ; } public static enum TimingParameter { OPRATE , ROWRATE , ADJROWRATE , PARTITIONRATE , MEANLATENCY , MAXLATENCY , MEDIANLATENCY , RANKLATENCY , ERRORCOUNT , PARTITIONCOUNT } String getStringValue ( TimingParameter value ) { return getStringValue ( value , Float . NaN ) ; } String getStringValue ( TimingParameter value , float rank ) { switch ( value ) { case OPRATE : return String . format ( <str> , opRate ( ) ) ; case ROWRATE : return String . format ( <str> , rowRate ( ) ) ; case ADJROWRATE : return String . format ( <str> , adjustedRowRate ( ) ) ; case PARTITIONRATE : return String . format ( <str> , partitionRate ( ) ) ; case MEANLATENCY : return String . format ( <str> , meanLatency ( ) ) ; case MAXLATENCY : return String . format ( <str> , maxLatency ( ) ) ; case MEDIANLATENCY : return String . format ( <str> , medianLatency ( ) ) ; case RANKLATENCY : return String . format ( <str> , rankLatency ( rank ) ) ; case ERRORCOUNT : return String . format ( <str> , errorCount ) ; case PARTITIONCOUNT : return String . format ( <str> , partitionCount ) ; default : throw new IllegalStateException ( ) ; } } } 
