package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . test . ESIntegTestCase ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class BooleanTermsIT extends ESIntegTestCase { private static final String SINGLE_VALUED_FIELD_NAME = <str> ; private static final String MULTI_VALUED_FIELD_NAME = <str> ; static int numSingleTrues , numSingleFalses , numMultiTrues , numMultiFalses ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; ensureSearchable ( ) ; final int numDocs = randomInt ( <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { final boolean singleValue = randomBoolean ( ) ; if ( singleValue ) { numSingleTrues + + ; } else { numSingleFalses + + ; } final boolean [ ] multiValue ; switch ( randomInt ( <int> ) ) { case <int> : multiValue = new boolean [ <int> ] ; break ; case <int> : numMultiFalses + + ; multiValue = new boolean [ ] { false } ; break ; case <int> : numMultiTrues + + ; multiValue = new boolean [ ] { true } ; break ; case <int> : numMultiFalses + + ; numMultiTrues + + ; multiValue = new boolean [ ] { false , true } ; break ; default : throw new AssertionError ( ) ; } builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , singleValue ) . field ( MULTI_VALUED_FIELD_NAME , multiValue ) . endObject ( ) ) ; } indexRandom ( true , builders ) ; } public void testSingleValueField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . collectMode ( randomFrom ( SubAggCollectionMode . values ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; final int bucketCount = numSingleFalses > <int> & & numSingleTrues > <int> ? <int> : numSingleFalses + numSingleTrues > <int> ? <int> : <int> ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( bucketCount ) ) ; Terms . Bucket bucket = terms . getBucketByKey ( <str> ) ; if ( numSingleFalses = = <int> ) { assertNull ( bucket ) ; } else { assertNotNull ( bucket ) ; assertEquals ( numSingleFalses , bucket . getDocCount ( ) ) ; } bucket = terms . getBucketByKey ( <str> ) ; if ( numSingleTrues = = <int> ) { assertNull ( bucket ) ; } else { assertNotNull ( bucket ) ; assertEquals ( numSingleTrues , bucket . getDocCount ( ) ) ; } } public void testMultiValueField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . field ( MULTI_VALUED_FIELD_NAME ) . collectMode ( randomFrom ( SubAggCollectionMode . values ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; final int bucketCount = numMultiFalses > <int> & & numMultiTrues > <int> ? <int> : numMultiFalses + numMultiTrues > <int> ? <int> : <int> ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( bucketCount ) ) ; Terms . Bucket bucket = terms . getBucketByKey ( <str> ) ; if ( numMultiFalses = = <int> ) { assertNull ( bucket ) ; } else { assertNotNull ( bucket ) ; assertEquals ( numMultiFalses , bucket . getDocCount ( ) ) ; } bucket = terms . getBucketByKey ( <str> ) ; if ( numMultiTrues = = <int> ) { assertNull ( bucket ) ; } else { assertNotNull ( bucket ) ; assertEquals ( numMultiTrues , bucket . getDocCount ( ) ) ; } } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . size ( randomInt ( <int> ) ) . collectMode ( randomFrom ( SubAggCollectionMode . values ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } } 
