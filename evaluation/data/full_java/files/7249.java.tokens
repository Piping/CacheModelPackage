package org . elasticsearch . search . aggregations . bucket . significant . heuristics ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public abstract class NXYSignificanceHeuristic extends SignificanceHeuristic { protected static final ParseField BACKGROUND_IS_SUPERSET = new ParseField ( <str> ) ; protected static final ParseField INCLUDE_NEGATIVES_FIELD = new ParseField ( <str> ) ; protected static final String SCORE_ERROR_MESSAGE = <str> + BACKGROUND_IS_SUPERSET . getPreferredName ( ) + <str> ; protected final boolean backgroundIsSuperset ; protected final boolean includeNegatives ; public NXYSignificanceHeuristic ( boolean includeNegatives , boolean backgroundIsSuperset ) { this . includeNegatives = includeNegatives ; this . backgroundIsSuperset = backgroundIsSuperset ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeBoolean ( includeNegatives ) ; out . writeBoolean ( backgroundIsSuperset ) ; } @Override public boolean equals ( Object other ) { return ( ( NXYSignificanceHeuristic ) other ) . includeNegatives = = includeNegatives & & ( ( NXYSignificanceHeuristic ) other ) . backgroundIsSuperset = = backgroundIsSuperset ; } @Override public int hashCode ( ) { int result = ( includeNegatives ? <int> : <int> ) ; result = <int> * result + ( backgroundIsSuperset ? <int> : <int> ) ; return result ; } protected static class Frequencies { double N00 , N01 , N10 , N11 , N0_ , N1_ , N_0 , N_1 , N ; } protected Frequencies computeNxys ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize , String scoreFunctionName ) { checkFrequencies ( subsetFreq , subsetSize , supersetFreq , supersetSize , scoreFunctionName ) ; Frequencies frequencies = new Frequencies ( ) ; if ( backgroundIsSuperset ) { frequencies . N00 = supersetSize - supersetFreq - ( subsetSize - subsetFreq ) ; frequencies . N01 = ( subsetSize - subsetFreq ) ; frequencies . N10 = supersetFreq - subsetFreq ; frequencies . N11 = subsetFreq ; frequencies . N0_ = supersetSize - supersetFreq ; frequencies . N1_ = supersetFreq ; frequencies . N_0 = supersetSize - subsetSize ; frequencies . N_1 = subsetSize ; frequencies . N = supersetSize ; } else { frequencies . N00 = supersetSize - supersetFreq ; frequencies . N01 = subsetSize - subsetFreq ; frequencies . N10 = supersetFreq ; frequencies . N11 = subsetFreq ; frequencies . N0_ = supersetSize - supersetFreq + subsetSize - subsetFreq ; frequencies . N1_ = supersetFreq + subsetFreq ; frequencies . N_0 = supersetSize ; frequencies . N_1 = subsetSize ; frequencies . N = supersetSize + subsetSize ; } return frequencies ; } protected void checkFrequencies ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize , String scoreFunctionName ) { checkFrequencyValidity ( subsetFreq , subsetSize , supersetFreq , supersetSize , scoreFunctionName ) ; if ( backgroundIsSuperset ) { if ( subsetFreq > supersetFreq ) { throw new IllegalArgumentException ( <str> + SCORE_ERROR_MESSAGE ) ; } if ( subsetSize > supersetSize ) { throw new IllegalArgumentException ( <str> + SCORE_ERROR_MESSAGE ) ; } if ( supersetFreq - subsetFreq > supersetSize - subsetSize ) { throw new IllegalArgumentException ( <str> + SCORE_ERROR_MESSAGE ) ; } } } public static abstract class NXYParser implements SignificanceHeuristicParser { @Override public SignificanceHeuristic parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher , SearchContext context ) throws IOException , QueryShardException { String givenName = parser . currentName ( ) ; boolean includeNegatives = false ; boolean backgroundIsSuperset = true ; XContentParser . Token token = parser . nextToken ( ) ; while ( ! token . equals ( XContentParser . Token . END_OBJECT ) ) { if ( parseFieldMatcher . match ( parser . currentName ( ) , INCLUDE_NEGATIVES_FIELD ) ) { parser . nextToken ( ) ; includeNegatives = parser . booleanValue ( ) ; } else if ( parseFieldMatcher . match ( parser . currentName ( ) , BACKGROUND_IS_SUPERSET ) ) { parser . nextToken ( ) ; backgroundIsSuperset = parser . booleanValue ( ) ; } else { throw new ElasticsearchParseException ( <str> , givenName , parser . currentName ( ) ) ; } token = parser . nextToken ( ) ; } return newHeuristic ( includeNegatives , backgroundIsSuperset ) ; } protected abstract SignificanceHeuristic newHeuristic ( boolean includeNegatives , boolean backgroundIsSuperset ) ; } protected abstract static class NXYBuilder implements SignificanceHeuristicBuilder { protected boolean includeNegatives = true ; protected boolean backgroundIsSuperset = true ; public NXYBuilder ( boolean includeNegatives , boolean backgroundIsSuperset ) { this . includeNegatives = includeNegatives ; this . backgroundIsSuperset = backgroundIsSuperset ; } protected void build ( XContentBuilder builder ) throws IOException { builder . field ( INCLUDE_NEGATIVES_FIELD . getPreferredName ( ) , includeNegatives ) . field ( BACKGROUND_IS_SUPERSET . getPreferredName ( ) , backgroundIsSuperset ) ; } } } 
