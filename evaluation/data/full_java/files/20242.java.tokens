package io . netty . channel ; import io . netty . util . Recycler ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; public final class PendingWriteQueue { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PendingWriteQueue . class ) ; private final ChannelHandlerContext ctx ; private final ChannelOutboundBuffer buffer ; private final MessageSizeEstimator . Handle estimatorHandle ; private PendingWrite head ; private PendingWrite tail ; private int size ; public PendingWriteQueue ( ChannelHandlerContext ctx ) { if ( ctx = = null ) { throw new NullPointerException ( <str> ) ; } this . ctx = ctx ; buffer = ctx . channel ( ) . unsafe ( ) . outboundBuffer ( ) ; estimatorHandle = ctx . channel ( ) . config ( ) . getMessageSizeEstimator ( ) . newHandle ( ) ; } public boolean isEmpty ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; return head = = null ; } public int size ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; return size ; } public void add ( Object msg , ChannelPromise promise ) { assert ctx . executor ( ) . inEventLoop ( ) ; if ( msg = = null ) { throw new NullPointerException ( <str> ) ; } if ( promise = = null ) { throw new NullPointerException ( <str> ) ; } int messageSize = estimatorHandle . size ( msg ) ; if ( messageSize < <int> ) { messageSize = <int> ; } PendingWrite write = PendingWrite . newInstance ( msg , messageSize , promise ) ; PendingWrite currentTail = tail ; if ( currentTail = = null ) { tail = head = write ; } else { currentTail . next = write ; tail = write ; } size + + ; if ( buffer ! = null ) { buffer . incrementPendingOutboundBytes ( write . size ) ; } } public void removeAndFailAll ( Throwable cause ) { assert ctx . executor ( ) . inEventLoop ( ) ; if ( cause = = null ) { throw new NullPointerException ( <str> ) ; } PendingWrite write = head ; head = tail = null ; size = <int> ; while ( write ! = null ) { PendingWrite next = write . next ; ReferenceCountUtil . safeRelease ( write . msg ) ; ChannelPromise promise = write . promise ; recycle ( write , false ) ; safeFail ( promise , cause ) ; write = next ; } assertEmpty ( ) ; } public void removeAndFail ( Throwable cause ) { assert ctx . executor ( ) . inEventLoop ( ) ; if ( cause = = null ) { throw new NullPointerException ( <str> ) ; } PendingWrite write = head ; if ( write = = null ) { return ; } ReferenceCountUtil . safeRelease ( write . msg ) ; ChannelPromise promise = write . promise ; safeFail ( promise , cause ) ; recycle ( write , true ) ; } public ChannelFuture removeAndWriteAll ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; if ( size = = <int> ) { return removeAndWrite ( ) ; } PendingWrite write = head ; if ( write = = null ) { return null ; } head = tail = null ; size = <int> ; ChannelPromise p = ctx . newPromise ( ) ; ChannelPromiseAggregator aggregator = new ChannelPromiseAggregator ( p ) ; while ( write ! = null ) { PendingWrite next = write . next ; Object msg = write . msg ; ChannelPromise promise = write . promise ; recycle ( write , false ) ; ctx . write ( msg , promise ) ; aggregator . add ( promise ) ; write = next ; } assertEmpty ( ) ; return p ; } private void assertEmpty ( ) { assert tail = = null & & head = = null & & size = = <int> ; } public ChannelFuture removeAndWrite ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; PendingWrite write = head ; if ( write = = null ) { return null ; } Object msg = write . msg ; ChannelPromise promise = write . promise ; recycle ( write , true ) ; return ctx . write ( msg , promise ) ; } public ChannelPromise remove ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; PendingWrite write = head ; if ( write = = null ) { return null ; } ChannelPromise promise = write . promise ; ReferenceCountUtil . safeRelease ( write . msg ) ; recycle ( write , true ) ; return promise ; } public Object current ( ) { assert ctx . executor ( ) . inEventLoop ( ) ; PendingWrite write = head ; if ( write = = null ) { return null ; } return write . msg ; } private void recycle ( PendingWrite write , boolean update ) { final PendingWrite next = write . next ; final long writeSize = write . size ; if ( update ) { if ( next = = null ) { head = tail = null ; size = <int> ; } else { head = next ; size - - ; assert size > <int> ; } } write . recycle ( ) ; if ( buffer ! = null ) { buffer . decrementPendingOutboundBytes ( writeSize ) ; } } private static void safeFail ( ChannelPromise promise , Throwable cause ) { if ( ! ( promise instanceof VoidChannelPromise ) & & ! promise . tryFailure ( cause ) ) { logger . warn ( <str> , promise , cause ) ; } } static final class PendingWrite { private static final Recycler < PendingWrite > RECYCLER = new Recycler < PendingWrite > ( ) { @Override protected PendingWrite newObject ( Handle handle ) { return new PendingWrite ( handle ) ; } } ; private final Recycler . Handle handle ; private PendingWrite next ; private long size ; private ChannelPromise promise ; private Object msg ; private PendingWrite ( Recycler . Handle handle ) { this . handle = handle ; } static PendingWrite newInstance ( Object msg , int size , ChannelPromise promise ) { PendingWrite write = RECYCLER . get ( ) ; write . size = size ; write . msg = msg ; write . promise = promise ; return write ; } private void recycle ( ) { size = <int> ; next = null ; msg = null ; promise = null ; RECYCLER . recycle ( this , handle ) ; } } } 
