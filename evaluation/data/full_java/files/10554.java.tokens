package com . google . common . math ; import static com . google . common . math . MathTesting . ALL_DOUBLE_CANDIDATES ; import static com . google . common . math . MathTesting . ALL_ROUNDING_MODES ; import static com . google . common . math . MathTesting . ALL_SAFE_ROUNDING_MODES ; import static com . google . common . math . MathTesting . DOUBLE_CANDIDATES_EXCEPT_NAN ; import static com . google . common . math . MathTesting . FINITE_DOUBLE_CANDIDATES ; import static com . google . common . math . MathTesting . FRACTIONAL_DOUBLE_CANDIDATES ; import static com . google . common . math . MathTesting . INFINITIES ; import static com . google . common . math . MathTesting . INTEGRAL_DOUBLE_CANDIDATES ; import static com . google . common . math . MathTesting . NEGATIVE_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . POSITIVE_FINITE_DOUBLE_CANDIDATES ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . DOWN ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . HALF_DOWN ; import static java . math . RoundingMode . HALF_EVEN ; import static java . math . RoundingMode . HALF_UP ; import static java . math . RoundingMode . UNNECESSARY ; import static java . math . RoundingMode . UP ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . primitives . Doubles ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; import java . util . Arrays ; import java . util . List ; @GwtCompatible ( emulated = true ) public class DoubleMathTest extends TestCase { private static final BigDecimal MAX_INT_AS_BIG_DECIMAL = BigDecimal . valueOf ( Integer . MAX_VALUE ) ; private static final BigDecimal MIN_INT_AS_BIG_DECIMAL = BigDecimal . valueOf ( Integer . MIN_VALUE ) ; private static final BigDecimal MAX_LONG_AS_BIG_DECIMAL = BigDecimal . valueOf ( Long . MAX_VALUE ) ; private static final BigDecimal MIN_LONG_AS_BIG_DECIMAL = BigDecimal . valueOf ( Long . MIN_VALUE ) ; public void testConstantsMaxFactorial ( ) { BigInteger maxDoubleValue = BigDecimal . valueOf ( Double . MAX_VALUE ) . toBigInteger ( ) ; assertTrue ( BigIntegerMath . factorial ( DoubleMath . MAX_FACTORIAL ) . compareTo ( maxDoubleValue ) < = <int> ) ; assertTrue ( BigIntegerMath . factorial ( DoubleMath . MAX_FACTORIAL + <int> ) . compareTo ( maxDoubleValue ) > <int> ) ; } public void testConstantsEverySixteenthFactorial ( ) { for ( int i = <int> , n = <int> ; n < = DoubleMath . MAX_FACTORIAL ; i + + , n + = <int> ) { assertEquals ( BigIntegerMath . factorial ( n ) . doubleValue ( ) , DoubleMath . everySixteenthFactorial [ i ] ) ; } } @GwtIncompatible ( <str> ) public void testRoundIntegralDoubleToInt ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; boolean isInBounds = expected . compareTo ( MAX_INT_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_INT_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . intValue ( ) , DoubleMath . roundToInt ( d , mode ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } } @GwtIncompatible ( <str> ) public void testRoundFractionalDoubleToInt ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; boolean isInBounds = expected . compareTo ( MAX_INT_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_INT_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . intValue ( ) , DoubleMath . roundToInt ( d , mode ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } } @GwtIncompatible ( <str> ) public void testRoundExactIntegralDoubleToInt ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , UNNECESSARY ) ; boolean isInBounds = expected . compareTo ( MAX_INT_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_INT_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . intValue ( ) , DoubleMath . roundToInt ( d , UNNECESSARY ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } @GwtIncompatible ( <str> ) public void testRoundExactFractionalDoubleToIntFails ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { try { DoubleMath . roundToInt ( d , UNNECESSARY ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundNaNToIntAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToInt ( Double . NaN , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundInfiniteToIntAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToInt ( Double . POSITIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { DoubleMath . roundToInt ( Double . NEGATIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundIntegralDoubleToLong ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; boolean isInBounds = expected . compareTo ( MAX_LONG_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_LONG_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . longValue ( ) , DoubleMath . roundToLong ( d , mode ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } } @GwtIncompatible ( <str> ) public void testRoundFractionalDoubleToLong ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; boolean isInBounds = expected . compareTo ( MAX_LONG_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_LONG_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . longValue ( ) , DoubleMath . roundToLong ( d , mode ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } } @GwtIncompatible ( <str> ) public void testRoundExactIntegralDoubleToLong ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , UNNECESSARY ) ; boolean isInBounds = expected . compareTo ( MAX_LONG_AS_BIG_DECIMAL ) < = <int> & expected . compareTo ( MIN_LONG_AS_BIG_DECIMAL ) > = <int> ; try { assertEquals ( expected . longValue ( ) , DoubleMath . roundToLong ( d , UNNECESSARY ) ) ; assertTrue ( isInBounds ) ; } catch ( ArithmeticException e ) { assertFalse ( isInBounds ) ; } } } @GwtIncompatible ( <str> ) public void testRoundExactFractionalDoubleToLongFails ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { try { DoubleMath . roundToLong ( d , UNNECESSARY ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundNaNToLongAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToLong ( Double . NaN , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundInfiniteToLongAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToLong ( Double . POSITIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { DoubleMath . roundToLong ( Double . NEGATIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundIntegralDoubleToBigInteger ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; assertEquals ( expected . toBigInteger ( ) , DoubleMath . roundToBigInteger ( d , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testRoundFractionalDoubleToBigInteger ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , mode ) ; assertEquals ( expected . toBigInteger ( ) , DoubleMath . roundToBigInteger ( d , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testRoundExactIntegralDoubleToBigInteger ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { BigDecimal expected = new BigDecimal ( d ) . setScale ( <int> , UNNECESSARY ) ; assertEquals ( expected . toBigInteger ( ) , DoubleMath . roundToBigInteger ( d , UNNECESSARY ) ) ; } } @GwtIncompatible ( <str> ) public void testRoundExactFractionalDoubleToBigIntegerFails ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { try { DoubleMath . roundToBigInteger ( d , UNNECESSARY ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundNaNToBigIntegerAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToBigInteger ( Double . NaN , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundInfiniteToBigIntegerAlwaysFails ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { DoubleMath . roundToBigInteger ( Double . POSITIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { DoubleMath . roundToBigInteger ( Double . NEGATIVE_INFINITY , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @GwtIncompatible ( <str> ) public void testRoundLog2Floor ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , FLOOR ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) < = d ) ; assertTrue ( StrictMath . pow ( <float> , log2 + <int> ) > d ) ; } } @GwtIncompatible ( <str> ) public void testRoundLog2Ceiling ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , CEILING ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) > = d ) ; double z = StrictMath . pow ( <float> , log2 - <int> ) ; assertTrue ( z < d ) ; } } @GwtIncompatible ( <str> ) public void testRoundLog2Down ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , DOWN ) ; if ( d > = <float> ) { assertTrue ( log2 > = <int> ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) < = d ) ; assertTrue ( StrictMath . pow ( <float> , log2 + <int> ) > d ) ; } else { assertTrue ( log2 < = <int> ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) > = d ) ; assertTrue ( StrictMath . pow ( <float> , log2 - <int> ) < d ) ; } } } @GwtIncompatible ( <str> ) public void testRoundLog2Up ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { int log2 = DoubleMath . log2 ( d , UP ) ; if ( d > = <float> ) { assertTrue ( log2 > = <int> ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) > = d ) ; assertTrue ( StrictMath . pow ( <float> , log2 - <int> ) < d ) ; } else { assertTrue ( log2 < = <int> ) ; assertTrue ( StrictMath . pow ( <float> , log2 ) < = d ) ; assertTrue ( StrictMath . pow ( <float> , log2 + <int> ) > d ) ; } } } @GwtIncompatible ( <str> ) public void testRoundLog2Half ( ) { for ( int exp : asList ( - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) { for ( RoundingMode mode : asList ( HALF_EVEN , HALF_UP , HALF_DOWN ) ) { double x = Math . scalb ( Math . sqrt ( <int> ) + <float> , exp ) ; double y = Math . scalb ( Math . sqrt ( <int> ) - <float> , exp ) ; if ( exp < <int> ) { assertEquals ( exp + <int> , DoubleMath . log2 ( x , mode ) ) ; assertEquals ( exp , DoubleMath . log2 ( y , mode ) ) ; } else { assertEquals ( exp + <int> , DoubleMath . log2 ( x , mode ) ) ; assertEquals ( exp , DoubleMath . log2 ( y , mode ) ) ; } } } } @GwtIncompatible ( <str> ) public void testRoundLog2Exact ( ) { for ( double x : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { boolean isPowerOfTwo = StrictMath . pow ( <float> , DoubleMath . log2 ( x , FLOOR ) ) = = x ; try { int log2 = DoubleMath . log2 ( x , UNNECESSARY ) ; assertEquals ( x , Math . scalb ( <float> , log2 ) ) ; assertTrue ( isPowerOfTwo ) ; } catch ( ArithmeticException e ) { assertFalse ( isPowerOfTwo ) ; } } } @GwtIncompatible ( <str> ) public void testRoundLog2ThrowsOnZerosInfinitiesAndNaN ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { for ( double d : asList ( <float> , - <float> , Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY , Double . NaN ) ) { try { DoubleMath . log2 ( d , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testRoundLog2ThrowsOnNegative ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { try { DoubleMath . log2 ( - d , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testIsPowerOfTwoYes ( ) { for ( int i = - <int> ; i < = <int> ; i + + ) { assertTrue ( DoubleMath . isPowerOfTwo ( StrictMath . pow ( <float> , i ) ) ) ; } } @GwtIncompatible ( <str> ) public void testIsPowerOfTwo ( ) { for ( double x : ALL_DOUBLE_CANDIDATES ) { boolean expected = x > <int> & & ! Double . isInfinite ( x ) & & ! Double . isNaN ( x ) & & StrictMath . pow ( <float> , DoubleMath . log2 ( x , FLOOR ) ) = = x ; assertEquals ( expected , DoubleMath . isPowerOfTwo ( x ) ) ; } } @GwtIncompatible ( <str> ) public void testLog2Accuracy ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { double dmLog2 = DoubleMath . log2 ( d ) ; double trueLog2 = trueLog2 ( d ) ; assertTrue ( Math . abs ( dmLog2 - trueLog2 ) < = Math . ulp ( trueLog2 ) ) ; } } public void testLog2SemiMonotonic ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { assertTrue ( DoubleMath . log2 ( d + <float> ) > = DoubleMath . log2 ( d ) ) ; } } public void testLog2Negative ( ) { for ( double d : POSITIVE_FINITE_DOUBLE_CANDIDATES ) { assertTrue ( Double . isNaN ( DoubleMath . log2 ( - d ) ) ) ; } } public void testLog2Zero ( ) { assertEquals ( Double . NEGATIVE_INFINITY , DoubleMath . log2 ( <float> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , DoubleMath . log2 ( - <float> ) ) ; } public void testLog2NaNInfinity ( ) { assertEquals ( Double . POSITIVE_INFINITY , DoubleMath . log2 ( Double . POSITIVE_INFINITY ) ) ; assertTrue ( Double . isNaN ( DoubleMath . log2 ( Double . NEGATIVE_INFINITY ) ) ) ; assertTrue ( Double . isNaN ( DoubleMath . log2 ( Double . NaN ) ) ) ; } @GwtIncompatible ( <str> ) private strictfp double trueLog2 ( double d ) { double trueLog2 = StrictMath . log ( d ) / StrictMath . log ( <int> ) ; while ( StrictMath . pow ( <float> , trueLog2 ) < d ) { trueLog2 = StrictMath . nextUp ( trueLog2 ) ; } while ( StrictMath . pow ( <float> , trueLog2 ) > d ) { trueLog2 = StrictMath . nextAfter ( trueLog2 , Double . NEGATIVE_INFINITY ) ; } if ( StrictMath . abs ( StrictMath . pow ( <float> , trueLog2 ) - d ) > StrictMath . abs ( StrictMath . pow ( <float> , StrictMath . nextUp ( trueLog2 ) ) - d ) ) { trueLog2 = StrictMath . nextUp ( trueLog2 ) ; } return trueLog2 ; } @GwtIncompatible ( <str> ) public void testIsMathematicalIntegerIntegral ( ) { for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { assertTrue ( DoubleMath . isMathematicalInteger ( d ) ) ; } } @GwtIncompatible ( <str> ) public void testIsMathematicalIntegerFractional ( ) { for ( double d : FRACTIONAL_DOUBLE_CANDIDATES ) { assertFalse ( DoubleMath . isMathematicalInteger ( d ) ) ; } } @GwtIncompatible ( <str> ) public void testIsMathematicalIntegerNotFinite ( ) { for ( double d : Arrays . asList ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY , Double . NaN ) ) { assertFalse ( DoubleMath . isMathematicalInteger ( d ) ) ; } } @GwtIncompatible ( <str> ) public void testFactorial ( ) { for ( int i = <int> ; i < = DoubleMath . MAX_FACTORIAL ; i + + ) { double actual = BigIntegerMath . factorial ( i ) . doubleValue ( ) ; double result = DoubleMath . factorial ( i ) ; assertEquals ( actual , result , Math . ulp ( actual ) ) ; } } public void testFactorialTooHigh ( ) { assertEquals ( Double . POSITIVE_INFINITY , DoubleMath . factorial ( DoubleMath . MAX_FACTORIAL + <int> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , DoubleMath . factorial ( DoubleMath . MAX_FACTORIAL + <int> ) ) ; } public void testFactorialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { try { DoubleMath . factorial ( n ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } private static final ImmutableList < Double > FINITE_TOLERANCE_CANDIDATES = ImmutableList . of ( - <float> , <float> , <float> , <float> , <float> , Double . MAX_VALUE ) ; private static final Iterable < Double > TOLERANCE_CANDIDATES = Iterables . concat ( FINITE_TOLERANCE_CANDIDATES , ImmutableList . of ( Double . POSITIVE_INFINITY ) ) ; private static final List < Double > BAD_TOLERANCE_CANDIDATES = Doubles . asList ( - Double . MIN_VALUE , - Double . MIN_NORMAL , - <int> , - <int> , Double . NaN , Double . NEGATIVE_INFINITY , - <float> ) ; public void testFuzzyEqualsFinite ( ) { for ( double a : FINITE_DOUBLE_CANDIDATES ) { for ( double b : FINITE_DOUBLE_CANDIDATES ) { for ( double tolerance : FINITE_TOLERANCE_CANDIDATES ) { assertEquals ( Math . abs ( a - b ) < = tolerance , DoubleMath . fuzzyEquals ( a , b , tolerance ) ) ; } } } } public void testFuzzyInfiniteVersusFiniteWithFiniteTolerance ( ) { for ( double inf : INFINITIES ) { for ( double a : FINITE_DOUBLE_CANDIDATES ) { for ( double tolerance : FINITE_TOLERANCE_CANDIDATES ) { assertFalse ( DoubleMath . fuzzyEquals ( a , inf , tolerance ) ) ; assertFalse ( DoubleMath . fuzzyEquals ( inf , a , tolerance ) ) ; } } } } public void testFuzzyInfiniteVersusInfiniteWithFiniteTolerance ( ) { for ( double inf : INFINITIES ) { for ( double tolerance : FINITE_TOLERANCE_CANDIDATES ) { assertTrue ( DoubleMath . fuzzyEquals ( inf , inf , tolerance ) ) ; assertFalse ( DoubleMath . fuzzyEquals ( inf , - inf , tolerance ) ) ; } } } public void testFuzzyEqualsInfiniteTolerance ( ) { for ( double a : DOUBLE_CANDIDATES_EXCEPT_NAN ) { for ( double b : DOUBLE_CANDIDATES_EXCEPT_NAN ) { assertTrue ( DoubleMath . fuzzyEquals ( a , b , Double . POSITIVE_INFINITY ) ) ; } } } public void testFuzzyEqualsOneNaN ( ) { for ( double a : DOUBLE_CANDIDATES_EXCEPT_NAN ) { for ( double tolerance : TOLERANCE_CANDIDATES ) { assertFalse ( DoubleMath . fuzzyEquals ( a , Double . NaN , tolerance ) ) ; assertFalse ( DoubleMath . fuzzyEquals ( Double . NaN , a , tolerance ) ) ; } } } public void testFuzzyEqualsTwoNaNs ( ) { for ( double tolerance : TOLERANCE_CANDIDATES ) { assertTrue ( DoubleMath . fuzzyEquals ( Double . NaN , Double . NaN , tolerance ) ) ; } } public void testFuzzyEqualsZeroTolerance ( ) { for ( double zero : Doubles . asList ( <float> , - <float> ) ) { for ( double a : ALL_DOUBLE_CANDIDATES ) { for ( double b : ALL_DOUBLE_CANDIDATES ) { assertEquals ( a = = b | | ( Double . isNaN ( a ) & & Double . isNaN ( b ) ) , DoubleMath . fuzzyEquals ( a , b , zero ) ) ; } } } } public void testFuzzyEqualsBadTolerance ( ) { for ( double tolerance : BAD_TOLERANCE_CANDIDATES ) { try { DoubleMath . fuzzyEquals ( <int> , <int> , tolerance ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testFuzzyCompare ( ) { for ( double a : ALL_DOUBLE_CANDIDATES ) { for ( double b : ALL_DOUBLE_CANDIDATES ) { for ( double tolerance : TOLERANCE_CANDIDATES ) { int expected = DoubleMath . fuzzyEquals ( a , b , tolerance ) ? <int> : Double . compare ( a , b ) ; int actual = DoubleMath . fuzzyCompare ( a , b , tolerance ) ; assertEquals ( Integer . signum ( expected ) , Integer . signum ( actual ) ) ; } } } } public void testFuzzyCompareBadTolerance ( ) { for ( double tolerance : BAD_TOLERANCE_CANDIDATES ) { try { DoubleMath . fuzzyCompare ( <int> , <int> , tolerance ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testMean_doubleVarargs ( ) { assertEquals ( - <float> , DoubleMath . mean ( <float> , - <float> , <float> , - <float> ) , <float> ) ; assertEquals ( <float> , DoubleMath . mean ( <float> ) , <float> ) ; try { DoubleMath . mean ( Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { DoubleMath . mean ( Double . POSITIVE_INFINITY ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_intVarargs ( ) { assertEquals ( - <float> , DoubleMath . mean ( <int> , - <int> , <int> , - <int> ) , <float> ) ; assertEquals ( <float> , DoubleMath . mean ( <int> ) , <float> ) ; } @GwtIncompatible ( <str> ) public void testMean_longVarargs ( ) { assertEquals ( - <float> , DoubleMath . mean ( <int> , - <int> , <int> , - <int> ) , <float> ) ; assertEquals ( <float> , DoubleMath . mean ( <int> ) , <float> ) ; } @GwtIncompatible ( <str> ) public void testMean_emptyVarargs ( ) { try { DoubleMath . mean ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_doubleIterable ( ) { assertEquals ( - <float> , DoubleMath . mean ( ImmutableList . of ( <float> , - <float> , <float> , - <float> ) ) , <float> ) ; assertEquals ( <float> , DoubleMath . mean ( ImmutableList . of ( <float> ) ) , <float> ) ; try { DoubleMath . mean ( ImmutableList . < Double > of ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { DoubleMath . mean ( ImmutableList . of ( Double . NaN ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { DoubleMath . mean ( ImmutableList . of ( Double . POSITIVE_INFINITY ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_intIterable ( ) { assertEquals ( - <float> , DoubleMath . mean ( ImmutableList . of ( <int> , - <int> , <int> , - <int> ) ) , <float> ) ; assertEquals ( <int> , DoubleMath . mean ( ImmutableList . of ( <int> ) ) , <float> ) ; try { DoubleMath . mean ( ImmutableList . < Integer > of ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_longIterable ( ) { assertEquals ( - <float> , DoubleMath . mean ( ImmutableList . of ( <int> , - <int> , <int> , - <int> ) ) , <float> ) ; assertEquals ( <int> , DoubleMath . mean ( ImmutableList . of ( <int> ) ) , <float> ) ; try { DoubleMath . mean ( ImmutableList . < Long > of ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_intIterator ( ) { assertEquals ( - <float> , DoubleMath . mean ( ImmutableList . of ( <int> , - <int> , <int> , - <int> ) . iterator ( ) ) , <float> ) ; assertEquals ( <int> , DoubleMath . mean ( ImmutableList . of ( <int> ) . iterator ( ) ) , <float> ) ; try { DoubleMath . mean ( ImmutableList . < Integer > of ( ) . iterator ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMean_longIterator ( ) { assertEquals ( - <float> , DoubleMath . mean ( ImmutableList . of ( <int> , - <int> , <int> , - <int> ) . iterator ( ) ) , <float> ) ; assertEquals ( <int> , DoubleMath . mean ( ImmutableList . of ( <int> ) . iterator ( ) ) , <float> ) ; try { DoubleMath . mean ( ImmutableList . < Long > of ( ) . iterator ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . setDefault ( double . class , <float> ) ; tester . testAllPublicStaticMethods ( DoubleMath . class ) ; } } 
