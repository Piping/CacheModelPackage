package org . nd4j . linalg . jcublas . util ; import jcuda . Pointer ; import jcuda . Sizeof ; import jcuda . cuComplex ; import jcuda . cuDoubleComplex ; import jcuda . driver . CUdeviceptr ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . ScalarOp ; import org . nd4j . linalg . jcublas . CublasPointer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . jcublas . context . CudaContext ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import static jcuda . driver . JCudaDriver . cuMemAlloc ; public class PointerUtil { public static double [ ] toDoubles ( Object [ ] extraArgs ) { double [ ] ret = new double [ extraArgs . length ] ; for ( int i = <int> ; i < extraArgs . length ; i + + ) { ret [ i ] = Double . valueOf ( extraArgs [ i ] . toString ( ) ) ; } return ret ; } public static int [ ] toShapeInfoBuffer ( INDArray arr , int . . . dimension ) { if ( dimension = = null ) return toShapeInfoBuffer ( arr ) ; int [ ] ret = new int [ arr . rank ( ) * <int> + <int> ] ; ret [ <int> ] = arr . rank ( ) ; int count = <int> ; for ( int i = <int> ; i < arr . rank ( ) ; i + + ) { ret [ count + + ] = arr . size ( i ) ; } for ( int i = <int> ; i < arr . rank ( ) ; i + + ) { ret [ count + + ] = arr . stride ( i ) ; } ret [ ret . length - <int> ] = <int> ; ret [ ret . length - <int> ] = arr . tensorAlongDimension ( <int> , dimension ) . elementWiseStride ( ) ; ret [ ret . length - <int> ] = arr . ordering ( ) ; return ret ; } public static void printDeviceBuffer ( JCudaBuffer buffer , CudaContext ctx ) { CublasPointer pointer = new CublasPointer ( buffer , ctx ) ; } public static int [ ] toShapeInfoBuffer ( INDArray arr ) { int [ ] ret = new int [ arr . rank ( ) * <int> + <int> ] ; ret [ <int> ] = arr . rank ( ) ; int count = <int> ; for ( int i = <int> ; i < arr . rank ( ) ; i + + ) { ret [ count + + ] = arr . size ( i ) ; } for ( int i = <int> ; i < arr . rank ( ) ; i + + ) { ret [ count + + ] = arr . stride ( i ) ; } ret [ ret . length - <int> ] = <int> ; ret [ ret . length - <int> ] = arr . elementWiseStride ( ) ; ret [ ret . length - <int> ] = arr . ordering ( ) ; return ret ; } public static Pointer getPointer ( IComplexDouble x ) { return getPointer ( cuDoubleComplex . cuCmplx ( x . realComponent ( ) . doubleValue ( ) , x . imaginaryComponent ( ) . doubleValue ( ) ) ) ; } public static Pointer getPointer ( IComplexFloat x ) { return getPointer ( cuComplex . cuCmplx ( x . realComponent ( ) . floatValue ( ) , x . imaginaryComponent ( ) . floatValue ( ) ) ) ; } public static Pointer getPointer ( cuDoubleComplex x ) { ByteBuffer byteBufferx = ByteBuffer . allocateDirect ( <int> * <int> ) ; byteBufferx . order ( ByteOrder . nativeOrder ( ) ) ; java . nio . DoubleBuffer floatBufferx = byteBufferx . asDoubleBuffer ( ) ; floatBufferx . put ( <int> , x . x ) ; floatBufferx . put ( <int> , x . y ) ; return Pointer . to ( floatBufferx ) ; } public static Pointer getPointer ( cuComplex x ) { ByteBuffer byteBufferx = ByteBuffer . allocateDirect ( <int> * <int> ) ; byteBufferx . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer floatBufferx = byteBufferx . asFloatBuffer ( ) ; floatBufferx . put ( <int> , x . x ) ; floatBufferx . put ( <int> , x . y ) ; return Pointer . to ( floatBufferx ) ; } public static float [ ] toFloats ( Object [ ] extraArgs ) { float [ ] ret = new float [ extraArgs . length ] ; for ( int i = <int> ; i < extraArgs . length ; i + + ) { ret [ i ] = Float . valueOf ( extraArgs [ i ] . toString ( ) ) ; } return ret ; } public static int getNumBlocks ( int n , int maxBlocks , int maxThreads ) { int blocks ; int threads = getNumThreads ( n , maxThreads ) ; blocks = ( n + ( threads * <int> - <int> ) ) / ( threads * <int> ) ; blocks = Math . min ( maxBlocks , blocks ) ; return blocks ; } public static int getNumThreads ( int n , int maxThreads ) { return ( n < maxThreads * <int> ) ? nextPow2 ( ( n + <int> ) / <int> ) : maxThreads ; } public static int nextPow2 ( int x ) { - - x ; x | = x > > <int> ; x | = x > > <int> ; x | = x > > <int> ; x | = x > > <int> ; x | = x > > <int> ; return + + x ; } public static Pointer getHostPointer ( DataBuffer buffer ) { if ( buffer . allocationMode ( ) = = DataBuffer . AllocationMode . DIRECT ) { JCudaBuffer buf = ( JCudaBuffer ) buffer ; return Pointer . to ( buf . asNio ( ) ) ; } else if ( buffer . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( buffer . dataType ( ) = = DataBuffer . Type . DOUBLE ) { double [ ] arr = buffer . asDouble ( ) ; return Pointer . to ( arr ) ; } else if ( buffer . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] arr = buffer . asFloat ( ) ; return Pointer . to ( arr ) ; } else if ( buffer . dataType ( ) = = DataBuffer . Type . INT ) { int [ ] arr = buffer . asInt ( ) ; return Pointer . to ( arr ) ; } } throw new IllegalStateException ( <str> ) ; } public static CUdeviceptr constructAndAlloc ( int length , DataBuffer . Type dType ) { CUdeviceptr deviceOutput = new CUdeviceptr ( ) ; cuMemAlloc ( deviceOutput , length * ( dType = = DataBuffer . Type . FLOAT ? Sizeof . FLOAT : Sizeof . DOUBLE ) ) ; return deviceOutput ; } public static int sizeFor ( DataBuffer . Type dataType ) { return dataType = = DataBuffer . Type . DOUBLE ? Sizeof . DOUBLE : Sizeof . FLOAT ; } public static Object getPointer ( ScalarOp scalarOp ) { if ( scalarOp . scalar ( ) ! = null ) { if ( scalarOp . x ( ) . data ( ) . dataType ( ) = = DataBuffer . Type . FLOAT ) return new float [ ] { scalarOp . scalar ( ) . floatValue ( ) } ; else if ( scalarOp . x ( ) . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) return new double [ ] { scalarOp . scalar ( ) . doubleValue ( ) } ; else if ( scalarOp . x ( ) . data ( ) . dataType ( ) = = DataBuffer . Type . INT ) return new int [ ] { scalarOp . scalar ( ) . intValue ( ) } ; } throw new IllegalStateException ( <str> + scalarOp ) ; } public static Pointer getPointer ( double alpha ) { return Pointer . to ( new double [ ] { alpha } ) ; } public static Pointer getPointer ( float alpha ) { return Pointer . to ( new float [ ] { alpha } ) ; } } 
