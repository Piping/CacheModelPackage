package org . elasticsearch . index . mapper . routing ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . Version ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . SourceToParse ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . Map ; import static org . hamcrest . Matchers . * ; public class RoutingTypeMapperTests extends ESSingleNodeTestCase { public void testRoutingMapper ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = docMapper . parse ( SourceToParse . source ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) . type ( <str> ) . id ( <str> ) . routing ( <str> ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } public void testFieldTypeSettingsBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; assertThat ( docMapper . routingFieldMapper ( ) . fieldType ( ) . stored ( ) , equalTo ( false ) ) ; assertEquals ( IndexOptions . NONE , docMapper . routingFieldMapper ( ) . fieldType ( ) . indexOptions ( ) ) ; } public void testFieldTypeSettingsSerializationBackcompat ( ) throws Exception { String enabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper enabledMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( enabledMapping ) ; XContentBuilder builder = JsonXContent . contentBuilder ( ) . startObject ( ) ; enabledMapper . routingFieldMapper ( ) . toXContent ( builder , ToXContent . EMPTY_PARAMS ) . endObject ( ) ; builder . close ( ) ; Map < String , Object > serializedMap ; try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( builder . bytes ( ) ) ) { serializedMap = parser . map ( ) ; } assertThat ( serializedMap , hasKey ( <str> ) ) ; assertThat ( serializedMap . get ( <str> ) , instanceOf ( Map . class ) ) ; Map < String , Object > routingConfiguration = ( Map < String , Object > ) serializedMap . get ( <str> ) ; assertThat ( routingConfiguration , hasKey ( <str> ) ) ; assertThat ( routingConfiguration . get ( <str> ) . toString ( ) , is ( <str> ) ) ; assertThat ( routingConfiguration , hasKey ( <str> ) ) ; assertThat ( routingConfiguration . get ( <str> ) . toString ( ) , is ( <str> ) ) ; } public void testPathBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( MetaData . builder ( ) . build ( ) , mappingMetaData , true , <str> ) ; assertEquals ( request . routing ( ) , <str> ) ; } public void testIncludeInObjectBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( MetaData . builder ( ) . build ( ) , mappingMetaData , true , <str> ) ; assertNull ( request . routing ( ) ) ; assertNull ( docMapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) . rootDoc ( ) . get ( <str> ) ) ; } public void testIncludeInObjectNotAllowed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; try { docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } } 
