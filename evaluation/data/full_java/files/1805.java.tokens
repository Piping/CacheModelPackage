package clojure . asm ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Type { public static final int VOID = <int> ; public static final int BOOLEAN = <int> ; public static final int CHAR = <int> ; public static final int BYTE = <int> ; public static final int SHORT = <int> ; public static final int INT = <int> ; public static final int FLOAT = <int> ; public static final int LONG = <int> ; public static final int DOUBLE = <int> ; public static final int ARRAY = <int> ; public static final int OBJECT = <int> ; public static final int METHOD = <int> ; public static final Type VOID_TYPE = new Type ( VOID , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type BOOLEAN_TYPE = new Type ( BOOLEAN , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type CHAR_TYPE = new Type ( CHAR , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type BYTE_TYPE = new Type ( BYTE , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type SHORT_TYPE = new Type ( SHORT , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type INT_TYPE = new Type ( INT , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type FLOAT_TYPE = new Type ( FLOAT , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type LONG_TYPE = new Type ( LONG , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; public static final Type DOUBLE_TYPE = new Type ( DOUBLE , null , ( <str> < < <int> ) | ( <int> < < <int> ) | ( <int> < < <int> ) | <int> , <int> ) ; private final int sort ; private final char [ ] buf ; private final int off ; private final int len ; private Type ( final int sort , final char [ ] buf , final int off , final int len ) { this . sort = sort ; this . buf = buf ; this . off = off ; this . len = len ; } public static Type getType ( final String typeDescriptor ) { return getType ( typeDescriptor . toCharArray ( ) , <int> ) ; } public static Type getObjectType ( final String internalName ) { char [ ] buf = internalName . toCharArray ( ) ; return new Type ( buf [ <int> ] = = <str> ? ARRAY : OBJECT , buf , <int> , buf . length ) ; } public static Type getMethodType ( final String methodDescriptor ) { return getType ( methodDescriptor . toCharArray ( ) , <int> ) ; } public static Type getMethodType ( final Type returnType , final Type . . . argumentTypes ) { return getType ( getMethodDescriptor ( returnType , argumentTypes ) ) ; } public static Type getType ( final Class < ? > c ) { if ( c . isPrimitive ( ) ) { if ( c = = Integer . TYPE ) { return INT_TYPE ; } else if ( c = = Void . TYPE ) { return VOID_TYPE ; } else if ( c = = Boolean . TYPE ) { return BOOLEAN_TYPE ; } else if ( c = = Byte . TYPE ) { return BYTE_TYPE ; } else if ( c = = Character . TYPE ) { return CHAR_TYPE ; } else if ( c = = Short . TYPE ) { return SHORT_TYPE ; } else if ( c = = Double . TYPE ) { return DOUBLE_TYPE ; } else if ( c = = Float . TYPE ) { return FLOAT_TYPE ; } else { return LONG_TYPE ; } } else { return getType ( getDescriptor ( c ) ) ; } } public static Type getType ( final Constructor < ? > c ) { return getType ( getConstructorDescriptor ( c ) ) ; } public static Type getType ( final Method m ) { return getType ( getMethodDescriptor ( m ) ) ; } public static Type [ ] getArgumentTypes ( final String methodDescriptor ) { char [ ] buf = methodDescriptor . toCharArray ( ) ; int off = <int> ; int size = <int> ; while ( true ) { char car = buf [ off + + ] ; if ( car = = <str> ) { break ; } else if ( car = = <str> ) { while ( buf [ off + + ] ! = <str> ) { } + + size ; } else if ( car ! = <str> ) { + + size ; } } Type [ ] args = new Type [ size ] ; off = <int> ; size = <int> ; while ( buf [ off ] ! = <str> ) { args [ size ] = getType ( buf , off ) ; off + = args [ size ] . len + ( args [ size ] . sort = = OBJECT ? <int> : <int> ) ; size + = <int> ; } return args ; } public static Type [ ] getArgumentTypes ( final Method method ) { Class < ? > [ ] classes = method . getParameterTypes ( ) ; Type [ ] types = new Type [ classes . length ] ; for ( int i = classes . length - <int> ; i > = <int> ; - - i ) { types [ i ] = getType ( classes [ i ] ) ; } return types ; } public static Type getReturnType ( final String methodDescriptor ) { char [ ] buf = methodDescriptor . toCharArray ( ) ; return getType ( buf , methodDescriptor . indexOf ( <str> ) + <int> ) ; } public static Type getReturnType ( final Method method ) { return getType ( method . getReturnType ( ) ) ; } public static int getArgumentsAndReturnSizes ( final String desc ) { int n = <int> ; int c = <int> ; while ( true ) { char car = desc . charAt ( c + + ) ; if ( car = = <str> ) { car = desc . charAt ( c ) ; return n < < <int> | ( car = = <str> ? <int> : ( car = = <str> | | car = = <str> ? <int> : <int> ) ) ; } else if ( car = = <str> ) { while ( desc . charAt ( c + + ) ! = <str> ) { } n + = <int> ; } else if ( car = = <str> ) { while ( ( car = desc . charAt ( c ) ) = = <str> ) { + + c ; } if ( car = = <str> | | car = = <str> ) { n - = <int> ; } } else if ( car = = <str> | | car = = <str> ) { n + = <int> ; } else { n + = <int> ; } } } private static Type getType ( final char [ ] buf , final int off ) { int len ; switch ( buf [ off ] ) { case <str> : return VOID_TYPE ; case <str> : return BOOLEAN_TYPE ; case <str> : return CHAR_TYPE ; case <str> : return BYTE_TYPE ; case <str> : return SHORT_TYPE ; case <str> : return INT_TYPE ; case <str> : return FLOAT_TYPE ; case <str> : return LONG_TYPE ; case <str> : return DOUBLE_TYPE ; case <str> : len = <int> ; while ( buf [ off + len ] = = <str> ) { + + len ; } if ( buf [ off + len ] = = <str> ) { + + len ; while ( buf [ off + len ] ! = <str> ) { + + len ; } } return new Type ( ARRAY , buf , off , len + <int> ) ; case <str> : len = <int> ; while ( buf [ off + len ] ! = <str> ) { + + len ; } return new Type ( OBJECT , buf , off + <int> , len - <int> ) ; default : return new Type ( METHOD , buf , off , buf . length - off ) ; } } public int getSort ( ) { return sort ; } public int getDimensions ( ) { int i = <int> ; while ( buf [ off + i ] = = <str> ) { + + i ; } return i ; } public Type getElementType ( ) { return getType ( buf , off + getDimensions ( ) ) ; } public String getClassName ( ) { switch ( sort ) { case VOID : return <str> ; case BOOLEAN : return <str> ; case CHAR : return <str> ; case BYTE : return <str> ; case SHORT : return <str> ; case INT : return <str> ; case FLOAT : return <str> ; case LONG : return <str> ; case DOUBLE : return <str> ; case ARRAY : StringBuffer b = new StringBuffer ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > <int> ; - - i ) { b . append ( <str> ) ; } return b . toString ( ) ; case OBJECT : return new String ( buf , off , len ) . replace ( <str> , <str> ) ; default : return null ; } } public String getInternalName ( ) { return new String ( buf , off , len ) ; } public Type [ ] getArgumentTypes ( ) { return getArgumentTypes ( getDescriptor ( ) ) ; } public Type getReturnType ( ) { return getReturnType ( getDescriptor ( ) ) ; } public int getArgumentsAndReturnSizes ( ) { return getArgumentsAndReturnSizes ( getDescriptor ( ) ) ; } public String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; } public static String getMethodDescriptor ( final Type returnType , final Type . . . argumentTypes ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; for ( int i = <int> ; i < argumentTypes . length ; + + i ) { argumentTypes [ i ] . getDescriptor ( buf ) ; } buf . append ( <str> ) ; returnType . getDescriptor ( buf ) ; return buf . toString ( ) ; } private void getDescriptor ( final StringBuffer buf ) { if ( this . buf = = null ) { buf . append ( ( char ) ( ( off & <hex> ) > > > <int> ) ) ; } else if ( sort = = OBJECT ) { buf . append ( <str> ) ; buf . append ( this . buf , off , len ) ; buf . append ( <str> ) ; } else { buf . append ( this . buf , off , len ) ; } } public static String getInternalName ( final Class < ? > c ) { return c . getName ( ) . replace ( <str> , <str> ) ; } public static String getDescriptor ( final Class < ? > c ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf , c ) ; return buf . toString ( ) ; } public static String getConstructorDescriptor ( final Constructor < ? > c ) { Class < ? > [ ] parameters = c . getParameterTypes ( ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; for ( int i = <int> ; i < parameters . length ; + + i ) { getDescriptor ( buf , parameters [ i ] ) ; } return buf . append ( <str> ) . toString ( ) ; } public static String getMethodDescriptor ( final Method m ) { Class < ? > [ ] parameters = m . getParameterTypes ( ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; for ( int i = <int> ; i < parameters . length ; + + i ) { getDescriptor ( buf , parameters [ i ] ) ; } buf . append ( <str> ) ; getDescriptor ( buf , m . getReturnType ( ) ) ; return buf . toString ( ) ; } private static void getDescriptor ( final StringBuffer buf , final Class < ? > c ) { Class < ? > d = c ; while ( true ) { if ( d . isPrimitive ( ) ) { char car ; if ( d = = Integer . TYPE ) { car = <str> ; } else if ( d = = Void . TYPE ) { car = <str> ; } else if ( d = = Boolean . TYPE ) { car = <str> ; } else if ( d = = Byte . TYPE ) { car = <str> ; } else if ( d = = Character . TYPE ) { car = <str> ; } else if ( d = = Short . TYPE ) { car = <str> ; } else if ( d = = Double . TYPE ) { car = <str> ; } else if ( d = = Float . TYPE ) { car = <str> ; } else { car = <str> ; } buf . append ( car ) ; return ; } else if ( d . isArray ( ) ) { buf . append ( <str> ) ; d = d . getComponentType ( ) ; } else { buf . append ( <str> ) ; String name = d . getName ( ) ; int len = name . length ( ) ; for ( int i = <int> ; i < len ; + + i ) { char car = name . charAt ( i ) ; buf . append ( car = = <str> ? <str> : car ) ; } buf . append ( <str> ) ; return ; } } } public int getSize ( ) { return buf = = null ? ( off & <hex> ) : <int> ; } public int getOpcode ( final int opcode ) { if ( opcode = = Opcodes . IALOAD | | opcode = = Opcodes . IASTORE ) { return opcode + ( buf = = null ? ( off & <hex> ) > > <int> : <int> ) ; } else { return opcode + ( buf = = null ? ( off & <hex> ) > > <int> : <int> ) ; } } @Override public boolean equals ( final Object o ) { if ( this = = o ) { return true ; } if ( ! ( o instanceof Type ) ) { return false ; } Type t = ( Type ) o ; if ( sort ! = t . sort ) { return false ; } if ( sort > = ARRAY ) { if ( len ! = t . len ) { return false ; } for ( int i = off , j = t . off , end = i + len ; i < end ; i + + , j + + ) { if ( buf [ i ] ! = t . buf [ j ] ) { return false ; } } } return true ; } @Override public int hashCode ( ) { int hc = <int> * sort ; if ( sort > = ARRAY ) { for ( int i = off , end = i + len ; i < end ; i + + ) { hc = <int> * ( hc + buf [ i ] ) ; } } return hc ; } @Override public String toString ( ) { return getDescriptor ( ) ; } } 
