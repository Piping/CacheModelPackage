package com . google . common . collect ; import static com . google . common . collect . Lists . newArrayList ; import static com . google . common . collect . Sets . newHashSet ; import static com . google . common . collect . Sets . newLinkedHashSet ; import static com . google . common . collect . testing . IteratorFeature . MODIFIABLE ; import static com . google . common . collect . testing . IteratorFeature . SUPPORTS_REMOVE ; import static com . google . common . collect . testing . IteratorFeature . SUPPORTS_SET ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . collect . testing . ListIteratorTester ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . ListMultimapTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringListMultimapGenerator ; import com . google . common . testing . EqualsTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . RandomAccess ; import java . util . Set ; @GwtCompatible ( emulated = true ) public class LinkedListMultimapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( ListMultimapTestSuiteBuilder . using ( new TestStringListMultimapGenerator ( ) { @Override protected ListMultimap < String , String > create ( Entry < String , String > [ ] entries ) { ListMultimap < String , String > multimap = LinkedListMultimap . create ( ) ; for ( Entry < String , String > entry : entries ) { multimap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return multimap ; } } ) . named ( <str> ) . withFeatures ( MapFeature . ALLOWS_NULL_KEYS , MapFeature . ALLOWS_NULL_VALUES , MapFeature . ALLOWS_ANY_NULL_QUERIES , MapFeature . GENERAL_PURPOSE , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionFeature . SERIALIZABLE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTestSuite ( LinkedListMultimapTest . class ) ; return suite ; } protected LinkedListMultimap < String , Integer > create ( ) { return LinkedListMultimap . create ( ) ; } public void testGetRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; } public void testRemoveAllRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertTrue ( multimap . removeAll ( <str> ) instanceof RandomAccess ) ; assertTrue ( multimap . removeAll ( <str> ) instanceof RandomAccess ) ; } public void testReplaceValuesRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertTrue ( multimap . replaceValues ( <str> , Arrays . asList ( <int> , <int> ) ) instanceof RandomAccess ) ; assertTrue ( multimap . replaceValues ( <str> , Arrays . asList ( <int> , <int> ) ) instanceof RandomAccess ) ; } public void testCreateFromMultimap ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; LinkedListMultimap < String , Integer > copy = LinkedListMultimap . create ( multimap ) ; assertEquals ( multimap , copy ) ; assertThat ( copy . entries ( ) ) . containsExactlyElementsIn ( multimap . entries ( ) ) . inOrder ( ) ; } public void testCreateFromSize ( ) { LinkedListMultimap < String , Integer > multimap = LinkedListMultimap . create ( <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertEquals ( ImmutableList . of ( <int> , <int> ) , multimap . get ( <str> ) ) ; } public void testCreateFromIllegalSize ( ) { try { LinkedListMultimap . create ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testLinkedGetAdd ( ) { LinkedListMultimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; Collection < Integer > foos = map . get ( <str> ) ; foos . add ( <int> ) ; foos . add ( <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; } public void testLinkedGetInsert ( ) { ListMultimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; List < Integer > foos = map . get ( <str> ) ; foos . add ( <int> ) ; foos . add ( <int> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; } public void testLinkedPutInOrder ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; } public void testLinkedPutOutOfOrder ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; } public void testLinkedPutAllMultimap ( ) { Multimap < String , Integer > src = create ( ) ; src . put ( <str> , <int> ) ; src . put ( <str> , <int> ) ; src . put ( <str> , <int> ) ; Multimap < String , Integer > dst = create ( ) ; dst . putAll ( src ) ; assertEquals ( <str> , dst . toString ( ) ) ; assertEquals ( <str> , src . entries ( ) . toString ( ) ) ; } public void testLinkedReplaceValues ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; map . replaceValues ( <str> , asList ( <int> , <int> ) ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedClear ( ) { ListMultimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; List < Integer > foos = map . get ( <str> ) ; Collection < Integer > values = map . values ( ) ; assertEquals ( asList ( <int> , <int> ) , foos ) ; assertThat ( values ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; map . clear ( ) ; assertEquals ( Collections . emptyList ( ) , foos ) ; assertThat ( values ) . isEmpty ( ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedKeySet ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . keySet ( ) . toString ( ) ) ; map . keySet ( ) . remove ( <str> ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedKeys ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . entries ( ) . toString ( ) ) ; assertThat ( map . keys ( ) ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; map . keys ( ) . remove ( <str> ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedValues ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; assertEquals ( <str> , map . values ( ) . toString ( ) ) ; map . values ( ) . remove ( <int> ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedEntries ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Iterator < Map . Entry < String , Integer > > entries = map . entries ( ) . iterator ( ) ; Map . Entry < String , Integer > entry = entries . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertEquals ( <int> , ( int ) entry . getValue ( ) ) ; entry = entries . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertEquals ( <int> , ( int ) entry . getValue ( ) ) ; entry . setValue ( <int> ) ; entry = entries . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertEquals ( <int> , ( int ) entry . getValue ( ) ) ; assertFalse ( entries . hasNext ( ) ) ; entries . remove ( ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testLinkedAsMapEntries ( ) { Multimap < String , Integer > map = create ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Iterator < Map . Entry < String , Collection < Integer > > > entries = map . asMap ( ) . entrySet ( ) . iterator ( ) ; Map . Entry < String , Collection < Integer > > entry = entries . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; try { entry . setValue ( Arrays . < Integer > asList ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entries . remove ( ) ; entry = entries . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . contains ( <int> ) ; assertFalse ( entries . hasNext ( ) ) ; assertEquals ( <str> , map . toString ( ) ) ; } public void testEntriesAfterMultimapUpdate ( ) { ListMultimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; Collection < Map . Entry < String , Integer > > entries = multimap . entries ( ) ; Iterator < Map . Entry < String , Integer > > iterator = entries . iterator ( ) ; Map . Entry < String , Integer > entrya = iterator . next ( ) ; Map . Entry < String , Integer > entryb = iterator . next ( ) ; assertEquals ( <int> , ( int ) multimap . get ( <str> ) . set ( <int> , <int> ) ) ; assertFalse ( multimap . containsEntry ( <str> , <int> ) ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; assertEquals ( <int> , ( int ) entrya . getValue ( ) ) ; assertEquals ( <int> , ( int ) entryb . getValue ( ) ) ; assertTrue ( multimap . put ( <str> , <int> ) ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; assertEquals ( <int> , ( int ) entrya . getValue ( ) ) ; assertEquals ( <int> , ( int ) entryb . getValue ( ) ) ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) public void testEntriesIteration ( ) { List < Entry < String , Integer > > addItems = ImmutableList . of ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) ; for ( final int startIndex : new int [ ] { <int> , <int> , <int> } ) { List < Entry < String , Integer > > list = Lists . newArrayList ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) ; new ListIteratorTester < Entry < String , Integer > > ( <int> , addItems , ImmutableList . of ( SUPPORTS_REMOVE ) , list , startIndex ) { private LinkedListMultimap < String , Integer > multimap ; @Override protected ListIterator < Entry < String , Integer > > newTargetIterator ( ) { multimap = create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . put ( <str> , <int> ) ; return multimap . entries ( ) . listIterator ( startIndex ) ; } @Override protected void verify ( List < Entry < String , Integer > > elements ) { assertEquals ( elements , multimap . entries ( ) ) ; } } . test ( ) ; } } @GwtIncompatible ( <str> ) public void testKeysIteration ( ) { new IteratorTester < String > ( <int> , MODIFIABLE , newArrayList ( <str> , <str> , <str> , <str> , <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < String > newTargetIterator ( ) { multimap = create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; return multimap . keys ( ) . iterator ( ) ; } @Override protected void verify ( List < String > elements ) { assertEquals ( elements , Lists . newArrayList ( multimap . keys ( ) ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testValuesIteration ( ) { List < Integer > addItems = ImmutableList . of ( <int> , <int> , <int> ) ; for ( final int startIndex : new int [ ] { <int> , <int> , <int> } ) { new ListIteratorTester < Integer > ( <int> , addItems , ImmutableList . of ( SUPPORTS_REMOVE , SUPPORTS_SET ) , Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> ) , startIndex ) { private LinkedListMultimap < String , Integer > multimap ; @Override protected ListIterator < Integer > newTargetIterator ( ) { multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> ) ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; return multimap . values ( ) . listIterator ( startIndex ) ; } @Override protected void verify ( List < Integer > elements ) { assertEquals ( elements , multimap . values ( ) ) ; } } . test ( ) ; } } @GwtIncompatible ( <str> ) public void testKeySetIteration ( ) { new IteratorTester < String > ( <int> , MODIFIABLE , newLinkedHashSet ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < String > newTargetIterator ( ) { multimap = create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> ) ) ; return multimap . keySet ( ) . iterator ( ) ; } @Override protected void verify ( List < String > elements ) { assertEquals ( newHashSet ( elements ) , multimap . keySet ( ) ) ; } } . test ( ) ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) public void testAsSetIteration ( ) { Set < Entry < String , Collection < Integer > > > set = Sets . newLinkedHashSet ( asList ( Maps . immutableEntry ( <str> , ( Collection < Integer > ) asList ( <int> , <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) asList ( <int> , <int> , <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) asList ( <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) asList ( <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) asList ( <int> , <int> , <int> ) ) ) ) ; new IteratorTester < Entry < String , Collection < Integer > > > ( <int> , MODIFIABLE , set , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Entry < String , Collection < Integer > > > newTargetIterator ( ) { multimap = create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> ) ) ; return multimap . asMap ( ) . entrySet ( ) . iterator ( ) ; } @Override protected void verify ( List < Entry < String , Collection < Integer > > > elements ) { assertEquals ( newHashSet ( elements ) , multimap . asMap ( ) . entrySet ( ) ) ; } } . test ( ) ; } public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( LinkedListMultimap . create ( ) , LinkedListMultimap . create ( ) , LinkedListMultimap . create ( <int> ) ) . testEquals ( ) ; } } 
