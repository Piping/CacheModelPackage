package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Group ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener . ChangeEvent ; import com . badlogic . gdx . scenes . scene2d . utils . ClickListener ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . Layout ; import com . badlogic . gdx . scenes . scene2d . utils . Selection ; import com . badlogic . gdx . scenes . scene2d . utils . UIUtils ; import com . badlogic . gdx . utils . Array ; public class Tree extends WidgetGroup { TreeStyle style ; final Array < Node > rootNodes = new Array ( ) ; final Selection < Node > selection ; float ySpacing = <int> , iconSpacingLeft = <int> , iconSpacingRight = <int> , padding = <int> , indentSpacing ; private float leftColumnWidth , prefWidth , prefHeight ; private boolean sizeInvalid = true ; private Node foundNode ; Node overNode ; private ClickListener clickListener ; public Tree ( Skin skin ) { this ( skin . get ( TreeStyle . class ) ) ; } public Tree ( Skin skin , String styleName ) { this ( skin . get ( styleName , TreeStyle . class ) ) ; } public Tree ( TreeStyle style ) { selection = new Selection ( ) ; selection . setActor ( this ) ; selection . setMultiple ( true ) ; setStyle ( style ) ; initialize ( ) ; } private void initialize ( ) { addListener ( clickListener = new ClickListener ( ) { public void clicked ( InputEvent event , float x , float y ) { Node node = getNodeAt ( y ) ; if ( node = = null ) return ; if ( node ! = getNodeAt ( getTouchDownY ( ) ) ) return ; if ( selection . getMultiple ( ) & & selection . hasItems ( ) & & UIUtils . shift ( ) ) { float low = selection . getLastSelected ( ) . actor . getY ( ) ; float high = node . actor . getY ( ) ; if ( ! UIUtils . ctrl ( ) ) selection . clear ( ) ; if ( low > high ) selectNodes ( rootNodes , high , low ) ; else selectNodes ( rootNodes , low , high ) ; selection . fireChangeEvent ( ) ; return ; } if ( node . children . size > <int> & & ( ! selection . getMultiple ( ) | | ! UIUtils . ctrl ( ) ) ) { float rowX = node . actor . getX ( ) ; if ( node . icon ! = null ) rowX - = iconSpacingRight + node . icon . getMinWidth ( ) ; if ( x < rowX ) { node . setExpanded ( ! node . expanded ) ; return ; } } if ( ! node . isSelectable ( ) ) return ; selection . choose ( node ) ; } public boolean mouseMoved ( InputEvent event , float x , float y ) { setOverNode ( getNodeAt ( y ) ) ; return false ; } public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { super . exit ( event , x , y , pointer , toActor ) ; if ( toActor = = null | | ! toActor . isDescendantOf ( Tree . this ) ) setOverNode ( null ) ; } } ) ; } public void setStyle ( TreeStyle style ) { this . style = style ; indentSpacing = Math . max ( style . plus . getMinWidth ( ) , style . minus . getMinWidth ( ) ) + iconSpacingLeft ; } public void add ( Node node ) { insert ( rootNodes . size , node ) ; } public void insert ( int index , Node node ) { remove ( node ) ; node . parent = null ; rootNodes . insert ( index , node ) ; node . addToTree ( this ) ; invalidateHierarchy ( ) ; } public void remove ( Node node ) { if ( node . parent ! = null ) { node . parent . remove ( node ) ; return ; } rootNodes . removeValue ( node , true ) ; node . removeFromTree ( this ) ; invalidateHierarchy ( ) ; } public void clearChildren ( ) { super . clearChildren ( ) ; setOverNode ( null ) ; rootNodes . clear ( ) ; selection . clear ( ) ; } public Array < Node > getNodes ( ) { return rootNodes ; } public void invalidate ( ) { super . invalidate ( ) ; sizeInvalid = true ; } private void computeSize ( ) { sizeInvalid = false ; prefWidth = style . plus . getMinWidth ( ) ; prefWidth = Math . max ( prefWidth , style . minus . getMinWidth ( ) ) ; prefHeight = getHeight ( ) ; leftColumnWidth = <int> ; computeSize ( rootNodes , indentSpacing ) ; leftColumnWidth + = iconSpacingLeft + padding ; prefWidth + = leftColumnWidth + padding ; prefHeight = getHeight ( ) - prefHeight ; } private void computeSize ( Array < Node > nodes , float indent ) { float ySpacing = this . ySpacing ; float spacing = iconSpacingLeft + iconSpacingRight ; for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; float rowWidth = indent + iconSpacingRight ; Actor actor = node . actor ; if ( actor instanceof Layout ) { Layout layout = ( Layout ) actor ; rowWidth + = layout . getPrefWidth ( ) ; node . height = layout . getPrefHeight ( ) ; layout . pack ( ) ; } else { rowWidth + = actor . getWidth ( ) ; node . height = actor . getHeight ( ) ; } if ( node . icon ! = null ) { rowWidth + = spacing + node . icon . getMinWidth ( ) ; node . height = Math . max ( node . height , node . icon . getMinHeight ( ) ) ; } prefWidth = Math . max ( prefWidth , rowWidth ) ; prefHeight - = node . height + ySpacing ; if ( node . expanded ) computeSize ( node . children , indent + indentSpacing ) ; } } public void layout ( ) { if ( sizeInvalid ) computeSize ( ) ; layout ( rootNodes , leftColumnWidth + indentSpacing + iconSpacingRight , getHeight ( ) - ySpacing / <int> ) ; } private float layout ( Array < Node > nodes , float indent , float y ) { float ySpacing = this . ySpacing ; for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; Actor actor = node . actor ; float x = indent ; if ( node . icon ! = null ) x + = node . icon . getMinWidth ( ) ; y - = node . height ; node . actor . setPosition ( x , y ) ; y - = ySpacing ; if ( node . expanded ) y = layout ( node . children , indent + indentSpacing , y ) ; } return y ; } public void draw ( Batch batch , float parentAlpha ) { Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , color . a * parentAlpha ) ; if ( style . background ! = null ) style . background . draw ( batch , getX ( ) , getY ( ) , getWidth ( ) , getHeight ( ) ) ; draw ( batch , rootNodes , leftColumnWidth ) ; super . draw ( batch , parentAlpha ) ; } private void draw ( Batch batch , Array < Node > nodes , float indent ) { Drawable plus = style . plus , minus = style . minus ; float x = getX ( ) , y = getY ( ) ; for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; Actor actor = node . actor ; if ( selection . contains ( node ) & & style . selection ! = null ) { style . selection . draw ( batch , x , y + actor . getY ( ) - ySpacing / <int> , getWidth ( ) , node . height + ySpacing ) ; } else if ( node = = overNode & & style . over ! = null ) { style . over . draw ( batch , x , y + actor . getY ( ) - ySpacing / <int> , getWidth ( ) , node . height + ySpacing ) ; } if ( node . icon ! = null ) { float iconY = actor . getY ( ) + Math . round ( ( node . height - node . icon . getMinHeight ( ) ) / <int> ) ; batch . setColor ( actor . getColor ( ) ) ; node . icon . draw ( batch , x + node . actor . getX ( ) - iconSpacingRight - node . icon . getMinWidth ( ) , y + iconY , node . icon . getMinWidth ( ) , node . icon . getMinHeight ( ) ) ; batch . setColor ( Color . WHITE ) ; } if ( node . children . size = = <int> ) continue ; Drawable expandIcon = node . expanded ? minus : plus ; float iconY = actor . getY ( ) + Math . round ( ( node . height - expandIcon . getMinHeight ( ) ) / <int> ) ; expandIcon . draw ( batch , x + indent - iconSpacingLeft , y + iconY , expandIcon . getMinWidth ( ) , expandIcon . getMinHeight ( ) ) ; if ( node . expanded ) draw ( batch , node . children , indent + indentSpacing ) ; } } public Node getNodeAt ( float y ) { foundNode = null ; getNodeAt ( rootNodes , y , getHeight ( ) ) ; return foundNode ; } private float getNodeAt ( Array < Node > nodes , float y , float rowY ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; if ( y > = rowY - node . height - ySpacing & & y < rowY ) { foundNode = node ; return - <int> ; } rowY - = node . height + ySpacing ; if ( node . expanded ) { rowY = getNodeAt ( node . children , y , rowY ) ; if ( rowY = = - <int> ) return - <int> ; } } return rowY ; } void selectNodes ( Array < Node > nodes , float low , float high ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; if ( node . actor . getY ( ) < low ) break ; if ( ! node . isSelectable ( ) ) continue ; if ( node . actor . getY ( ) < = high ) selection . add ( node ) ; if ( node . expanded ) selectNodes ( node . children , low , high ) ; } } public Selection < Node > getSelection ( ) { return selection ; } public TreeStyle getStyle ( ) { return style ; } public Array < Node > getRootNodes ( ) { return rootNodes ; } public Node getOverNode ( ) { return overNode ; } public void setOverNode ( Node overNode ) { this . overNode = overNode ; } public void setPadding ( float padding ) { this . padding = padding ; } public float getIndentSpacing ( ) { return indentSpacing ; } public void setYSpacing ( float ySpacing ) { this . ySpacing = ySpacing ; } public float getYSpacing ( ) { return ySpacing ; } public void setIconSpacing ( float left , float right ) { this . iconSpacingLeft = left ; this . iconSpacingRight = right ; } public float getPrefWidth ( ) { if ( sizeInvalid ) computeSize ( ) ; return prefWidth ; } public float getPrefHeight ( ) { if ( sizeInvalid ) computeSize ( ) ; return prefHeight ; } public void findExpandedObjects ( Array objects ) { findExpandedObjects ( rootNodes , objects ) ; } public void restoreExpandedObjects ( Array objects ) { for ( int i = <int> , n = objects . size ; i < n ; i + + ) { Node node = findNode ( objects . get ( i ) ) ; if ( node ! = null ) { node . setExpanded ( true ) ; node . expandTo ( ) ; } } } static boolean findExpandedObjects ( Array < Node > nodes , Array objects ) { boolean expanded = false ; for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; if ( node . expanded & & ! findExpandedObjects ( node . children , objects ) ) objects . add ( node . object ) ; } return expanded ; } public Node findNode ( Object object ) { if ( object = = null ) throw new IllegalArgumentException ( <str> ) ; return findNode ( rootNodes , object ) ; } static Node findNode ( Array < Node > nodes , Object object ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; if ( object . equals ( node . object ) ) return node ; } for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; Node found = findNode ( node . children , object ) ; if ( found ! = null ) return found ; } return null ; } public void collapseAll ( ) { collapseAll ( rootNodes ) ; } static void collapseAll ( Array < Node > nodes ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) { Node node = nodes . get ( i ) ; node . setExpanded ( false ) ; collapseAll ( node . children ) ; } } public void expandAll ( ) { expandAll ( rootNodes ) ; } static void expandAll ( Array < Node > nodes ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) nodes . get ( i ) . expandAll ( ) ; } public ClickListener getClickListener ( ) { return clickListener ; } static public class Node { Actor actor ; Node parent ; final Array < Node > children = new Array ( <int> ) ; boolean selectable = true ; boolean expanded ; Drawable icon ; float height ; Object object ; public Node ( Actor actor ) { if ( actor = = null ) throw new IllegalArgumentException ( <str> ) ; this . actor = actor ; } public void setExpanded ( boolean expanded ) { if ( expanded = = this . expanded ) return ; this . expanded = expanded ; if ( children . size = = <int> ) return ; Tree tree = getTree ( ) ; if ( tree = = null ) return ; if ( expanded ) { for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . addToTree ( tree ) ; } else { for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . removeFromTree ( tree ) ; } tree . invalidateHierarchy ( ) ; } protected void addToTree ( Tree tree ) { tree . addActor ( actor ) ; if ( ! expanded ) return ; for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . addToTree ( tree ) ; } protected void removeFromTree ( Tree tree ) { tree . removeActor ( actor ) ; if ( ! expanded ) return ; for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . removeFromTree ( tree ) ; } public void add ( Node node ) { insert ( children . size , node ) ; } public void addAll ( Array < Node > nodes ) { for ( int i = <int> , n = nodes . size ; i < n ; i + + ) insert ( children . size , nodes . get ( i ) ) ; } public void insert ( int index , Node node ) { node . parent = this ; children . insert ( index , node ) ; updateChildren ( ) ; } public void remove ( ) { Tree tree = getTree ( ) ; if ( tree ! = null ) tree . remove ( this ) ; else if ( parent ! = null ) parent . remove ( this ) ; } public void remove ( Node node ) { children . removeValue ( node , true ) ; if ( ! expanded ) return ; Tree tree = getTree ( ) ; if ( tree = = null ) return ; node . removeFromTree ( tree ) ; if ( children . size = = <int> ) expanded = false ; } public void removeAll ( ) { Tree tree = getTree ( ) ; if ( tree ! = null ) { for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . removeFromTree ( tree ) ; } children . clear ( ) ; } public Tree getTree ( ) { Group parent = actor . getParent ( ) ; if ( ! ( parent instanceof Tree ) ) return null ; return ( Tree ) parent ; } public Actor getActor ( ) { return actor ; } public boolean isExpanded ( ) { return expanded ; } public Array < Node > getChildren ( ) { return children ; } public void updateChildren ( ) { if ( ! expanded ) return ; Tree tree = getTree ( ) ; if ( tree = = null ) return ; for ( int i = <int> , n = children . size ; i < n ; i + + ) children . get ( i ) . addToTree ( tree ) ; } public Node getParent ( ) { return parent ; } public void setIcon ( Drawable icon ) { this . icon = icon ; } public Object getObject ( ) { return object ; } public void setObject ( Object object ) { this . object = object ; } public Drawable getIcon ( ) { return icon ; } public int getLevel ( ) { int level = <int> ; Node current = this ; do { level + + ; current = current . getParent ( ) ; } while ( current ! = null ) ; return level ; } public Node findNode ( Object object ) { if ( object = = null ) throw new IllegalArgumentException ( <str> ) ; if ( object . equals ( this . object ) ) return this ; return Tree . findNode ( children , object ) ; } public void collapseAll ( ) { setExpanded ( false ) ; Tree . collapseAll ( children ) ; } public void expandAll ( ) { setExpanded ( true ) ; if ( children . size > <int> ) Tree . expandAll ( children ) ; } public void expandTo ( ) { Node node = parent ; while ( node ! = null ) { node . setExpanded ( true ) ; node = node . parent ; } } public boolean isSelectable ( ) { return selectable ; } public void setSelectable ( boolean selectable ) { this . selectable = selectable ; } public void findExpandedObjects ( Array objects ) { if ( expanded & & ! Tree . findExpandedObjects ( children , objects ) ) objects . add ( object ) ; } public void restoreExpandedObjects ( Array objects ) { for ( int i = <int> , n = objects . size ; i < n ; i + + ) { Node node = findNode ( objects . get ( i ) ) ; if ( node ! = null ) { node . setExpanded ( true ) ; node . expandTo ( ) ; } } } } static public class TreeStyle { public Drawable plus , minus ; public Drawable over , selection , background ; public TreeStyle ( ) { } public TreeStyle ( Drawable plus , Drawable minus , Drawable selection ) { this . plus = plus ; this . minus = minus ; this . selection = selection ; } public TreeStyle ( TreeStyle style ) { this . plus = style . plus ; this . minus = style . minus ; this . selection = style . selection ; } } } 
