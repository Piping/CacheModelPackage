package io . netty . channel ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandler . Sharable ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalServerChannel ; import io . netty . util . AbstractReferenceCounted ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . ReferenceCounted ; import io . netty . util . concurrent . AbstractEventExecutor ; import io . netty . util . concurrent . EventExecutorGroup ; import io . netty . util . concurrent . Future ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Test ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . * ; public class DefaultChannelPipelineTest { private static final EventLoopGroup group = new DefaultEventLoopGroup ( <int> ) ; private Channel self ; private Channel peer ; @AfterClass public static void afterClass ( ) throws Exception { group . shutdownGracefully ( ) . sync ( ) ; } private void setUp ( final ChannelHandler . . . handlers ) throws Exception { final AtomicReference < Channel > peerRef = new AtomicReference < Channel > ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( LocalServerChannel . class ) ; sb . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { peerRef . set ( ctx . channel ( ) ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ReferenceCountUtil . release ( msg ) ; } } ) ; ChannelFuture bindFuture = sb . bind ( LocalAddress . ANY ) . sync ( ) ; Bootstrap b = new Bootstrap ( ) ; b . group ( group ) . channel ( LocalChannel . class ) ; b . handler ( new ChannelInitializer < LocalChannel > ( ) { @Override protected void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( handlers ) ; } } ) ; self = b . connect ( bindFuture . channel ( ) . localAddress ( ) ) . sync ( ) . channel ( ) ; peer = peerRef . get ( ) ; bindFuture . channel ( ) . close ( ) . sync ( ) ; } @After public void tearDown ( ) throws Exception { if ( peer ! = null ) { peer . close ( ) ; peer = null ; } if ( self ! = null ) { self = null ; } } @Test public void testFreeCalled ( ) throws Exception { final CountDownLatch free = new CountDownLatch ( <int> ) ; final ReferenceCounted holder = new AbstractReferenceCounted ( ) { @Override protected void deallocate ( ) { free . countDown ( ) ; } @Override public ReferenceCounted touch ( Object hint ) { return this ; } } ; StringInboundHandler handler = new StringInboundHandler ( ) ; setUp ( handler ) ; peer . writeAndFlush ( holder ) . sync ( ) ; assertTrue ( free . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( handler . called ) ; } private static final class StringInboundHandler extends ChannelInboundHandlerAdapter { boolean called ; @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { called = true ; if ( ! ( msg instanceof String ) ) { ctx . fireChannelRead ( msg ) ; } } } @Test public void testRemoveChannelHandler ( ) { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; ChannelHandler handler1 = newHandler ( ) ; ChannelHandler handler2 = newHandler ( ) ; ChannelHandler handler3 = newHandler ( ) ; pipeline . addLast ( <str> , handler1 ) ; pipeline . addLast ( <str> , handler2 ) ; pipeline . addLast ( <str> , handler3 ) ; assertSame ( pipeline . get ( <str> ) , handler1 ) ; assertSame ( pipeline . get ( <str> ) , handler2 ) ; assertSame ( pipeline . get ( <str> ) , handler3 ) ; pipeline . remove ( handler1 ) ; assertNull ( pipeline . get ( <str> ) ) ; pipeline . remove ( handler2 ) ; assertNull ( pipeline . get ( <str> ) ) ; pipeline . remove ( handler3 ) ; assertNull ( pipeline . get ( <str> ) ) ; } @Test public void testReplaceChannelHandler ( ) { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; ChannelHandler handler1 = newHandler ( ) ; pipeline . addLast ( <str> , handler1 ) ; pipeline . addLast ( <str> , handler1 ) ; pipeline . addLast ( <str> , handler1 ) ; assertSame ( pipeline . get ( <str> ) , handler1 ) ; assertSame ( pipeline . get ( <str> ) , handler1 ) ; assertSame ( pipeline . get ( <str> ) , handler1 ) ; ChannelHandler newHandler1 = newHandler ( ) ; pipeline . replace ( <str> , <str> , newHandler1 ) ; assertSame ( pipeline . get ( <str> ) , newHandler1 ) ; ChannelHandler newHandler3 = newHandler ( ) ; pipeline . replace ( <str> , <str> , newHandler3 ) ; assertSame ( pipeline . get ( <str> ) , newHandler3 ) ; ChannelHandler newHandler2 = newHandler ( ) ; pipeline . replace ( <str> , <str> , newHandler2 ) ; assertSame ( pipeline . get ( <str> ) , newHandler2 ) ; } @Test public void testChannelHandlerContextNavigation ( ) { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; final int HANDLER_ARRAY_LEN = <int> ; ChannelHandler [ ] firstHandlers = newHandlers ( HANDLER_ARRAY_LEN ) ; ChannelHandler [ ] lastHandlers = newHandlers ( HANDLER_ARRAY_LEN ) ; pipeline . addFirst ( firstHandlers ) ; pipeline . addLast ( lastHandlers ) ; verifyContextNumber ( pipeline , HANDLER_ARRAY_LEN * <int> ) ; } @Test public void testFireChannelRegistered ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( <int> ) ; ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; pipeline . addLast ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { latch . countDown ( ) ; } } ) ; } } ) ; group . register ( pipeline . channel ( ) ) ; assertTrue ( latch . await ( <int> , TimeUnit . SECONDS ) ) ; } @Test public void testPipelineOperation ( ) { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; final int handlerNum = <int> ; ChannelHandler [ ] handlers1 = newHandlers ( handlerNum ) ; ChannelHandler [ ] handlers2 = newHandlers ( handlerNum ) ; final String prefixX = <str> ; for ( int i = <int> ; i < handlerNum ; i + + ) { if ( i % <int> = = <int> ) { pipeline . addFirst ( prefixX + i , handlers1 [ i ] ) ; } else { pipeline . addLast ( prefixX + i , handlers1 [ i ] ) ; } } for ( int i = <int> ; i < handlerNum ; i + + ) { if ( i % <int> ! = <int> ) { pipeline . addBefore ( prefixX + i , String . valueOf ( i ) , handlers2 [ i ] ) ; } else { pipeline . addAfter ( prefixX + i , String . valueOf ( i ) , handlers2 [ i ] ) ; } } verifyContextNumber ( pipeline , handlerNum * <int> ) ; } @Test public void testChannelHandlerContextOrder ( ) { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; pipeline . addFirst ( <str> , newHandler ( ) ) ; pipeline . addLast ( <str> , newHandler ( ) ) ; pipeline . addBefore ( <str> , <str> , newHandler ( ) ) ; pipeline . addAfter ( <str> , <str> , newHandler ( ) ) ; pipeline . addBefore ( <str> , <str> , newHandler ( ) ) ; pipeline . addAfter ( <str> , <str> , newHandler ( ) ) ; pipeline . addBefore ( <str> , <str> , newHandler ( ) ) ; pipeline . addAfter ( <str> , <str> , newHandler ( ) ) ; AbstractChannelHandlerContext ctx = ( AbstractChannelHandlerContext ) pipeline . firstContext ( ) ; assertNotNull ( ctx ) ; while ( ctx ! = null ) { int i = toInt ( ctx . name ( ) ) ; int j = next ( ctx ) ; if ( j ! = - <int> ) { assertTrue ( i < j ) ; } else { assertNull ( ctx . next . next ) ; } ctx = ctx . next ; } verifyContextNumber ( pipeline , <int> ) ; } @Test ( timeout = <int> ) public void testLifeCycleAwareness ( ) throws Exception { setUp ( ) ; ChannelPipeline p = self . pipeline ( ) ; final List < LifeCycleAwareTestHandler > handlers = new ArrayList < LifeCycleAwareTestHandler > ( ) ; final int COUNT = <int> ; final CountDownLatch addLatch = new CountDownLatch ( COUNT ) ; for ( int i = <int> ; i < COUNT ; i + + ) { final LifeCycleAwareTestHandler handler = new LifeCycleAwareTestHandler ( <str> + i ) ; p . addFirst ( handler . name , handler ) ; self . eventLoop ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { handler . validate ( true , false ) ; handlers . add ( handler ) ; addLatch . countDown ( ) ; } } ) ; } addLatch . await ( ) ; Collections . shuffle ( handlers ) ; final CountDownLatch removeLatch = new CountDownLatch ( COUNT ) ; for ( final LifeCycleAwareTestHandler handler : handlers ) { assertSame ( handler , p . remove ( handler . name ) ) ; self . eventLoop ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { handler . validate ( true , true ) ; removeLatch . countDown ( ) ; } } ) ; } removeLatch . await ( ) ; } @Test ( timeout = <int> ) public void testRemoveAndForwardInbound ( ) throws Exception { final BufferedTestHandler handler1 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler2 = new BufferedTestHandler ( ) ; setUp ( handler1 , handler2 ) ; self . eventLoop ( ) . submit ( new Runnable ( ) { @Override public void run ( ) { ChannelPipeline p = self . pipeline ( ) ; handler1 . inboundBuffer . add ( <int> ) ; assertEquals ( <int> , handler1 . inboundBuffer . peek ( ) ) ; assertTrue ( handler2 . inboundBuffer . isEmpty ( ) ) ; p . remove ( handler1 ) ; assertEquals ( <int> , handler2 . inboundBuffer . size ( ) ) ; assertEquals ( <int> , handler2 . inboundBuffer . peek ( ) ) ; } } ) . sync ( ) ; } @Test ( timeout = <int> ) public void testRemoveAndForwardOutbound ( ) throws Exception { final BufferedTestHandler handler1 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler2 = new BufferedTestHandler ( ) ; setUp ( handler1 , handler2 ) ; self . eventLoop ( ) . submit ( new Runnable ( ) { @Override public void run ( ) { ChannelPipeline p = self . pipeline ( ) ; handler2 . outboundBuffer . add ( <int> ) ; assertEquals ( <int> , handler2 . outboundBuffer . peek ( ) ) ; assertTrue ( handler1 . outboundBuffer . isEmpty ( ) ) ; p . remove ( handler2 ) ; assertEquals ( <int> , handler1 . outboundBuffer . size ( ) ) ; assertEquals ( <int> , handler1 . outboundBuffer . peek ( ) ) ; } } ) . sync ( ) ; } @Test ( timeout = <int> ) public void testReplaceAndForwardOutbound ( ) throws Exception { final BufferedTestHandler handler1 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler2 = new BufferedTestHandler ( ) ; setUp ( handler1 ) ; self . eventLoop ( ) . submit ( new Runnable ( ) { @Override public void run ( ) { ChannelPipeline p = self . pipeline ( ) ; handler1 . outboundBuffer . add ( <int> ) ; assertEquals ( <int> , handler1 . outboundBuffer . peek ( ) ) ; assertTrue ( handler2 . outboundBuffer . isEmpty ( ) ) ; p . replace ( handler1 , <str> , handler2 ) ; assertEquals ( <int> , handler2 . outboundBuffer . peek ( ) ) ; } } ) . sync ( ) ; } @Test ( timeout = <int> ) public void testReplaceAndForwardInboundAndOutbound ( ) throws Exception { final BufferedTestHandler handler1 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler2 = new BufferedTestHandler ( ) ; setUp ( handler1 ) ; self . eventLoop ( ) . submit ( new Runnable ( ) { @Override public void run ( ) { ChannelPipeline p = self . pipeline ( ) ; handler1 . inboundBuffer . add ( <int> ) ; handler1 . outboundBuffer . add ( <int> ) ; assertEquals ( <int> , handler1 . inboundBuffer . peek ( ) ) ; assertEquals ( <int> , handler1 . outboundBuffer . peek ( ) ) ; assertTrue ( handler2 . inboundBuffer . isEmpty ( ) ) ; assertTrue ( handler2 . outboundBuffer . isEmpty ( ) ) ; p . replace ( handler1 , <str> , handler2 ) ; assertEquals ( <int> , handler2 . outboundBuffer . peek ( ) ) ; assertEquals ( <int> , handler2 . inboundBuffer . peek ( ) ) ; } } ) . sync ( ) ; } @Test ( timeout = <int> ) public void testRemoveAndForwardInboundOutbound ( ) throws Exception { final BufferedTestHandler handler1 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler2 = new BufferedTestHandler ( ) ; final BufferedTestHandler handler3 = new BufferedTestHandler ( ) ; setUp ( handler1 , handler2 , handler3 ) ; self . eventLoop ( ) . submit ( new Runnable ( ) { @Override public void run ( ) { ChannelPipeline p = self . pipeline ( ) ; handler2 . inboundBuffer . add ( <int> ) ; handler2 . outboundBuffer . add ( <int> ) ; assertEquals ( <int> , handler2 . inboundBuffer . peek ( ) ) ; assertEquals ( <int> , handler2 . outboundBuffer . peek ( ) ) ; assertEquals ( <int> , handler1 . outboundBuffer . size ( ) ) ; assertEquals ( <int> , handler3 . inboundBuffer . size ( ) ) ; p . remove ( handler2 ) ; assertEquals ( <int> , handler3 . inboundBuffer . peek ( ) ) ; assertEquals ( <int> , handler1 . outboundBuffer . peek ( ) ) ; } } ) . sync ( ) ; } @Test public void testCancelBind ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ChannelFuture future = pipeline . bind ( new LocalAddress ( <str> ) , promise ) ; assertTrue ( future . isCancelled ( ) ) ; } @Test public void testCancelConnect ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ChannelFuture future = pipeline . connect ( new LocalAddress ( <str> ) , promise ) ; assertTrue ( future . isCancelled ( ) ) ; } @Test public void testCancelDisconnect ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ChannelFuture future = pipeline . disconnect ( promise ) ; assertTrue ( future . isCancelled ( ) ) ; } @Test public void testCancelClose ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ChannelFuture future = pipeline . close ( promise ) ; assertTrue ( future . isCancelled ( ) ) ; } @Test public void testCancelDeregister ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ChannelFuture future = pipeline . deregister ( promise ) ; assertTrue ( future . isCancelled ( ) ) ; } @Test public void testCancelWrite ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ByteBuf buffer = Unpooled . buffer ( ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; ChannelFuture future = pipeline . write ( buffer , promise ) ; assertTrue ( future . isCancelled ( ) ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; } @Test public void testCancelWriteAndFlush ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; group . register ( pipeline . channel ( ) ) ; ChannelPromise promise = pipeline . channel ( ) . newPromise ( ) ; assertTrue ( promise . cancel ( false ) ) ; ByteBuf buffer = Unpooled . buffer ( ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; ChannelFuture future = pipeline . writeAndFlush ( buffer , promise ) ; assertTrue ( future . isCancelled ( ) ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; } @Test public void testFirstContextEmptyPipeline ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; assertNull ( pipeline . firstContext ( ) ) ; } @Test public void testLastContextEmptyPipeline ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; assertNull ( pipeline . lastContext ( ) ) ; } @Test public void testFirstHandlerEmptyPipeline ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; assertNull ( pipeline . first ( ) ) ; } @Test public void testLastHandlerEmptyPipeline ( ) throws Exception { ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; assertNull ( pipeline . last ( ) ) ; } @Test ( timeout = <int> ) public void testChannelInitializerException ( ) throws Exception { final IllegalStateException exception = new IllegalStateException ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { throw exception ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { super . exceptionCaught ( ctx , cause ) ; error . set ( cause ) ; latch . countDown ( ) ; } } ) ; latch . await ( ) ; assertFalse ( channel . isActive ( ) ) ; assertSame ( exception , error . get ( ) ) ; } @Test public void testChannelUnregistrationWithCustomExecutor ( ) throws Exception { final CountDownLatch channelLatch = new CountDownLatch ( <int> ) ; final CountDownLatch handlerLatch = new CountDownLatch ( <int> ) ; ChannelPipeline pipeline = new LocalChannel ( ) . pipeline ( ) ; pipeline . addLast ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ch . pipeline ( ) . addLast ( new WrapperExecutor ( ) , new ChannelInboundHandlerAdapter ( ) { @Override public void channelUnregistered ( ChannelHandlerContext ctx ) throws Exception { channelLatch . countDown ( ) ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { handlerLatch . countDown ( ) ; } } ) ; } } ) ; Channel channel = pipeline . channel ( ) ; group . register ( channel ) ; channel . close ( ) ; channel . deregister ( ) ; assertTrue ( channelLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( handlerLatch . await ( <int> , TimeUnit . SECONDS ) ) ; } private static int next ( AbstractChannelHandlerContext ctx ) { AbstractChannelHandlerContext next = ctx . next ; if ( next = = null ) { return Integer . MAX_VALUE ; } return toInt ( next . name ( ) ) ; } private static int toInt ( String name ) { try { return Integer . parseInt ( name ) ; } catch ( NumberFormatException e ) { return - <int> ; } } private static void verifyContextNumber ( ChannelPipeline pipeline , int expectedNumber ) { AbstractChannelHandlerContext ctx = ( AbstractChannelHandlerContext ) pipeline . firstContext ( ) ; int handlerNumber = <int> ; while ( ctx ! = ( ( DefaultChannelPipeline ) pipeline ) . tail ) { handlerNumber + + ; ctx = ctx . next ; } assertEquals ( expectedNumber , handlerNumber ) ; } private static ChannelHandler [ ] newHandlers ( int num ) { assert num > <int> ; ChannelHandler [ ] handlers = new ChannelHandler [ num ] ; for ( int i = <int> ; i < num ; i + + ) { handlers [ i ] = newHandler ( ) ; } return handlers ; } private static ChannelHandler newHandler ( ) { return new TestHandler ( ) ; } @Sharable private static class TestHandler extends ChannelDuplexHandler { } private static class BufferedTestHandler extends ChannelDuplexHandler { final Queue < Object > inboundBuffer = new ArrayDeque < Object > ( ) ; final Queue < Object > outboundBuffer = new ArrayDeque < Object > ( ) ; @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { outboundBuffer . add ( msg ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { inboundBuffer . add ( msg ) ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { if ( ! inboundBuffer . isEmpty ( ) ) { for ( Object o : inboundBuffer ) { ctx . fireChannelRead ( o ) ; } ctx . fireChannelReadComplete ( ) ; } if ( ! outboundBuffer . isEmpty ( ) ) { for ( Object o : outboundBuffer ) { ctx . write ( o ) ; } ctx . flush ( ) ; } } } private static final class LifeCycleAwareTestHandler extends ChannelHandlerAdapter { private final String name ; private boolean afterAdd ; private boolean afterRemove ; private LifeCycleAwareTestHandler ( String name ) { this . name = name ; } public void validate ( boolean afterAdd , boolean afterRemove ) { assertEquals ( name , afterAdd , this . afterAdd ) ; assertEquals ( name , afterRemove , this . afterRemove ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) { validate ( false , false ) ; afterAdd = true ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) { validate ( true , false ) ; afterRemove = true ; } } private static final class WrapperExecutor extends AbstractEventExecutor { private final ExecutorService wrapped = Executors . newSingleThreadExecutor ( ) ; @Override public boolean isShuttingDown ( ) { return wrapped . isShutdown ( ) ; } @Override public Future < ? > shutdownGracefully ( long l , long l2 , TimeUnit timeUnit ) { throw new IllegalStateException ( ) ; } @Override public Future < ? > terminationFuture ( ) { throw new IllegalStateException ( ) ; } @Override public void shutdown ( ) { wrapped . shutdown ( ) ; } @Override public List < Runnable > shutdownNow ( ) { return wrapped . shutdownNow ( ) ; } @Override public boolean isShutdown ( ) { return wrapped . isShutdown ( ) ; } @Override public boolean isTerminated ( ) { return wrapped . isTerminated ( ) ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { return wrapped . awaitTermination ( timeout , unit ) ; } @Override public EventExecutorGroup parent ( ) { return null ; } @Override public boolean inEventLoop ( Thread thread ) { return false ; } @Override public void execute ( Runnable command ) { wrapped . execute ( command ) ; } } } 
