package org . apache . cassandra . io . util ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . Arrays ; import java . util . concurrent . ThreadLocalRandom ; import org . junit . Test ; import static org . junit . Assert . * ; import org . apache . cassandra . io . util . ChecksummedRandomAccessReader ; import org . apache . cassandra . io . util . ChecksummedSequentialWriter ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . io . util . SequentialWriter ; public class ChecksummedRandomAccessReaderTest { @Test public void readFully ( ) throws IOException { final File data = File . createTempFile ( <str> , <str> ) ; final File crc = File . createTempFile ( <str> , <str> ) ; final byte [ ] expected = new byte [ <int> * <int> ] ; ThreadLocalRandom . current ( ) . nextBytes ( expected ) ; SequentialWriter writer = ChecksummedSequentialWriter . open ( data , crc ) ; writer . write ( expected ) ; writer . finish ( ) ; assert data . exists ( ) ; RandomAccessReader reader = new ChecksummedRandomAccessReader . Builder ( data , crc ) . build ( ) ; byte [ ] b = new byte [ expected . length ] ; reader . readFully ( b ) ; assertArrayEquals ( expected , b ) ; assertTrue ( reader . isEOF ( ) ) ; reader . close ( ) ; } @Test public void seek ( ) throws IOException { final File data = File . createTempFile ( <str> , <str> ) ; final File crc = File . createTempFile ( <str> , <str> ) ; final byte [ ] dataBytes = new byte [ <int> * <int> ] ; ThreadLocalRandom . current ( ) . nextBytes ( dataBytes ) ; SequentialWriter writer = ChecksummedSequentialWriter . open ( data , crc ) ; writer . write ( dataBytes ) ; writer . finish ( ) ; assert data . exists ( ) ; RandomAccessReader reader = new ChecksummedRandomAccessReader . Builder ( data , crc ) . build ( ) ; final int seekPosition = <int> ; reader . seek ( seekPosition ) ; byte [ ] b = new byte [ dataBytes . length - seekPosition ] ; reader . readFully ( b ) ; byte [ ] expected = Arrays . copyOfRange ( dataBytes , seekPosition , dataBytes . length ) ; assertArrayEquals ( expected , b ) ; assertTrue ( reader . isEOF ( ) ) ; reader . close ( ) ; } @Test ( expected = ChecksummedRandomAccessReader . CorruptFileException . class ) public void corruptionDetection ( ) throws IOException { final File data = File . createTempFile ( <str> , <str> ) ; final File crc = File . createTempFile ( <str> , <str> ) ; final byte [ ] expected = new byte [ <int> * <int> ] ; Arrays . fill ( expected , ( byte ) <int> ) ; SequentialWriter writer = ChecksummedSequentialWriter . open ( data , crc ) ; writer . write ( expected ) ; writer . finish ( ) ; assert data . exists ( ) ; try ( RandomAccessFile dataFile = new RandomAccessFile ( data , <str> ) ) { dataFile . seek ( <int> ) ; dataFile . write ( ( byte ) <int> ) ; } RandomAccessReader reader = new ChecksummedRandomAccessReader . Builder ( data , crc ) . build ( ) ; byte [ ] b = new byte [ expected . length ] ; reader . readFully ( b ) ; assertArrayEquals ( expected , b ) ; assertTrue ( reader . isEOF ( ) ) ; reader . close ( ) ; } } 
