package io . netty . channel ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . concurrent . MultithreadEventExecutorGroup ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadFactory ; public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( MultithreadEventLoopGroup . class ) ; private static final int DEFAULT_EVENT_LOOP_THREADS ; static { DEFAULT_EVENT_LOOP_THREADS = Math . max ( <int> , SystemPropertyUtil . getInt ( <str> , Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , DEFAULT_EVENT_LOOP_THREADS ) ; } } protected MultithreadEventLoopGroup ( int nThreads , Executor executor , Object . . . args ) { super ( nThreads = = <int> ? DEFAULT_EVENT_LOOP_THREADS : nThreads , executor , args ) ; } protected MultithreadEventLoopGroup ( int nThreads , ThreadFactory threadFactory , Object . . . args ) { super ( nThreads = = <int> ? DEFAULT_EVENT_LOOP_THREADS : nThreads , threadFactory , args ) ; } @Override protected ThreadFactory newDefaultThreadFactory ( ) { return new DefaultThreadFactory ( getClass ( ) , Thread . MAX_PRIORITY ) ; } @Override public EventLoop next ( ) { return ( EventLoop ) super . next ( ) ; } @Override protected abstract EventLoop newChild ( Executor executor , Object . . . args ) throws Exception ; @Override public ChannelFuture register ( Channel channel ) { return next ( ) . register ( channel ) ; } @Override public ChannelFuture register ( Channel channel , ChannelPromise promise ) { return next ( ) . register ( channel , promise ) ; } } 
