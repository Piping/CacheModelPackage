package org . gradle . foundation . common ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import javax . swing . * ; import java . awt . * ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class ObserverLord < E > { private List < E > regularObservers = new ArrayList < E > ( ) ; private List < E > eventQueueObservers = new ArrayList < E > ( ) ; private final Logger logger = Logging . getLogger ( ObserverLord . class ) ; public interface ObserverNotification < E > { public void notify ( E observer ) ; } public void addObserver ( E observer , boolean inEventQueue ) { if ( ! inEventQueue ) { addIfNew ( observer , regularObservers ) ; } else { addIfNew ( observer , eventQueueObservers ) ; } } private void addIfNew ( E observer , List < E > destinationList ) { if ( ! destinationList . contains ( observer ) ) { destinationList . add ( observer ) ; } } public void removeObserver ( E observer ) { regularObservers . remove ( observer ) ; eventQueueObservers . remove ( observer ) ; } public void removeAllObservers ( ) { regularObservers . clear ( ) ; eventQueueObservers . clear ( ) ; } public void notifyObservers ( ObserverNotification < E > notification ) { notifyObserversInternal ( regularObservers , notification ) ; notifyObserversInEventQueueThread ( notification ) ; } private void notifyObserversInEventQueueThread ( final ObserverNotification < E > notification ) { if ( eventQueueObservers . size ( ) = = <int> ) { return ; } if ( EventQueue . isDispatchThread ( ) ) { notifyObserversInternal ( eventQueueObservers , notification ) ; } else { try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { notifyObserversInternal ( eventQueueObservers , notification ) ; } } ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; } } } private void notifyObserversInternal ( List < E > observers , ObserverNotification < E > notification ) { Iterator < E > iterator = observers . iterator ( ) ; while ( iterator . hasNext ( ) ) { E observer = iterator . next ( ) ; try { notification . notify ( observer ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; } } } public String toString ( ) { return regularObservers . size ( ) + <str> + eventQueueObservers . size ( ) + <str> ; } } 
