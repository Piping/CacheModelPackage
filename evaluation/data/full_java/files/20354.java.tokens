package io . netty . channel . pool ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalEventLoopGroup ; import org . junit . Test ; import static org . junit . Assert . * ; public class AbstractChannelPoolMapTest { private static final String LOCAL_ADDR_ID = <str> ; @Test ( expected = ChannelException . class ) public void testMap ( ) throws Exception { EventLoopGroup group = new LocalEventLoopGroup ( ) ; LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; final Bootstrap cb = new Bootstrap ( ) ; cb . remoteAddress ( addr ) ; cb . group ( group ) . channel ( LocalChannel . class ) ; AbstractChannelPoolMap < EventLoop , SimpleChannelPool > poolMap = new AbstractChannelPoolMap < EventLoop , SimpleChannelPool > ( ) { @Override protected SimpleChannelPool newPool ( EventLoop key ) { return new SimpleChannelPool ( cb . clone ( key ) , new TestChannelPoolHandler ( ) ) ; } } ; EventLoop loop = group . next ( ) ; assertFalse ( poolMap . iterator ( ) . hasNext ( ) ) ; assertEquals ( <int> , poolMap . size ( ) ) ; SimpleChannelPool pool = poolMap . get ( loop ) ; assertEquals ( <int> , poolMap . size ( ) ) ; assertTrue ( poolMap . iterator ( ) . hasNext ( ) ) ; assertSame ( pool , poolMap . get ( loop ) ) ; assertTrue ( poolMap . remove ( loop ) ) ; assertFalse ( poolMap . remove ( loop ) ) ; assertFalse ( poolMap . iterator ( ) . hasNext ( ) ) ; assertEquals ( <int> , poolMap . size ( ) ) ; pool . acquire ( ) . syncUninterruptibly ( ) ; } private static final class TestChannelPoolHandler extends AbstractChannelPoolHandler { @Override public void channelCreated ( Channel ch ) throws Exception { } } } 
