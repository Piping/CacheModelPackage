package clojure . asm ; public class ClassWriter extends ClassVisitor { public static final int COMPUTE_MAXS = <int> ; public static final int COMPUTE_FRAMES = <int> ; static final int ACC_SYNTHETIC_ATTRIBUTE = <hex> ; static final int TO_ACC_SYNTHETIC = ACC_SYNTHETIC_ATTRIBUTE / Opcodes . ACC_SYNTHETIC ; static final int NOARG_INSN = <int> ; static final int SBYTE_INSN = <int> ; static final int SHORT_INSN = <int> ; static final int VAR_INSN = <int> ; static final int IMPLVAR_INSN = <int> ; static final int TYPE_INSN = <int> ; static final int FIELDORMETH_INSN = <int> ; static final int ITFMETH_INSN = <int> ; static final int INDYMETH_INSN = <int> ; static final int LABEL_INSN = <int> ; static final int LABELW_INSN = <int> ; static final int LDC_INSN = <int> ; static final int LDCW_INSN = <int> ; static final int IINC_INSN = <int> ; static final int TABL_INSN = <int> ; static final int LOOK_INSN = <int> ; static final int MANA_INSN = <int> ; static final int WIDE_INSN = <int> ; static final byte [ ] TYPE ; static final int CLASS = <int> ; static final int FIELD = <int> ; static final int METH = <int> ; static final int IMETH = <int> ; static final int STR = <int> ; static final int INT = <int> ; static final int FLOAT = <int> ; static final int LONG = <int> ; static final int DOUBLE = <int> ; static final int NAME_TYPE = <int> ; static final int UTF8 = <int> ; static final int MTYPE = <int> ; static final int HANDLE = <int> ; static final int INDY = <int> ; static final int HANDLE_BASE = <int> ; static final int TYPE_NORMAL = <int> ; static final int TYPE_UNINIT = <int> ; static final int TYPE_MERGED = <int> ; static final int BSM = <int> ; ClassReader cr ; int version ; int index ; final ByteVector pool ; Item [ ] items ; int threshold ; final Item key ; final Item key2 ; final Item key3 ; final Item key4 ; Item [ ] typeTable ; private short typeCount ; private int access ; private int name ; String thisName ; private int signature ; private int superName ; private int interfaceCount ; private int [ ] interfaces ; private int sourceFile ; private ByteVector sourceDebug ; private int enclosingMethodOwner ; private int enclosingMethod ; private AnnotationWriter anns ; private AnnotationWriter ianns ; private Attribute attrs ; private int innerClassesCount ; private ByteVector innerClasses ; int bootstrapMethodsCount ; ByteVector bootstrapMethods ; FieldWriter firstField ; FieldWriter lastField ; MethodWriter firstMethod ; MethodWriter lastMethod ; private final boolean computeMaxs ; private final boolean computeFrames ; boolean invalidFrames ; static { int i ; byte [ ] b = new byte [ <int> ] ; String s = <str> + <str> + <str> + <str> ; for ( i = <int> ; i < b . length ; + + i ) { b [ i ] = ( byte ) ( s . charAt ( i ) - <str> ) ; } TYPE = b ; } public ClassWriter ( final int flags ) { super ( Opcodes . ASM4 ) ; index = <int> ; pool = new ByteVector ( ) ; items = new Item [ <int> ] ; threshold = ( int ) ( <float> * items . length ) ; key = new Item ( ) ; key2 = new Item ( ) ; key3 = new Item ( ) ; key4 = new Item ( ) ; this . computeMaxs = ( flags & COMPUTE_MAXS ) ! = <int> ; this . computeFrames = ( flags & COMPUTE_FRAMES ) ! = <int> ; } public ClassWriter ( final ClassReader classReader , final int flags ) { this ( flags ) ; classReader . copyPool ( this ) ; this . cr = classReader ; } @Override public final void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { this . version = version ; this . access = access ; this . name = newClass ( name ) ; thisName = name ; if ( ClassReader . SIGNATURES & & signature ! = null ) { this . signature = newUTF8 ( signature ) ; } this . superName = superName = = null ? <int> : newClass ( superName ) ; if ( interfaces ! = null & & interfaces . length > <int> ) { interfaceCount = interfaces . length ; this . interfaces = new int [ interfaceCount ] ; for ( int i = <int> ; i < interfaceCount ; + + i ) { this . interfaces [ i ] = newClass ( interfaces [ i ] ) ; } } } @Override public final void visitSource ( final String file , final String debug ) { if ( file ! = null ) { sourceFile = newUTF8 ( file ) ; } if ( debug ! = null ) { sourceDebug = new ByteVector ( ) . putUTF8 ( debug ) ; } } @Override public final void visitOuterClass ( final String owner , final String name , final String desc ) { enclosingMethodOwner = newClass ( owner ) ; if ( name ! = null & & desc ! = null ) { enclosingMethod = newNameType ( name , desc ) ; } } @Override public final AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { if ( ! ClassReader . ANNOTATIONS ) { return null ; } ByteVector bv = new ByteVector ( ) ; bv . putShort ( newUTF8 ( desc ) ) . putShort ( <int> ) ; AnnotationWriter aw = new AnnotationWriter ( this , true , bv , bv , <int> ) ; if ( visible ) { aw . next = anns ; anns = aw ; } else { aw . next = ianns ; ianns = aw ; } return aw ; } @Override public final void visitAttribute ( final Attribute attr ) { attr . next = attrs ; attrs = attr ; } @Override public final void visitInnerClass ( final String name , final String outerName , final String innerName , final int access ) { if ( innerClasses = = null ) { innerClasses = new ByteVector ( ) ; } + + innerClassesCount ; innerClasses . putShort ( name = = null ? <int> : newClass ( name ) ) ; innerClasses . putShort ( outerName = = null ? <int> : newClass ( outerName ) ) ; innerClasses . putShort ( innerName = = null ? <int> : newUTF8 ( innerName ) ) ; innerClasses . putShort ( access ) ; } @Override public final FieldVisitor visitField ( final int access , final String name , final String desc , final String signature , final Object value ) { return new FieldWriter ( this , access , name , desc , signature , value ) ; } @Override public final MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { return new MethodWriter ( this , access , name , desc , signature , exceptions , computeMaxs , computeFrames ) ; } @Override public final void visitEnd ( ) { } public byte [ ] toByteArray ( ) { if ( index > <hex> ) { throw new RuntimeException ( <str> ) ; } int size = <int> + <int> * interfaceCount ; int nbFields = <int> ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = ( FieldWriter ) fb . fv ; } int nbMethods = <int> ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = ( MethodWriter ) mb . mv ; } int attributeCount = <int> ; if ( bootstrapMethods ! = null ) { + + attributeCount ; size + = <int> + bootstrapMethods . length ; newUTF8 ( <str> ) ; } if ( ClassReader . SIGNATURES & & signature ! = <int> ) { + + attributeCount ; size + = <int> ; newUTF8 ( <str> ) ; } if ( sourceFile ! = <int> ) { + + attributeCount ; size + = <int> ; newUTF8 ( <str> ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + <int> ; newUTF8 ( <str> ) ; } if ( enclosingMethodOwner ! = <int> ) { + + attributeCount ; size + = <int> ; newUTF8 ( <str> ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = <int> ) { + + attributeCount ; size + = <int> ; newUTF8 ( <str> ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = <int> ) { if ( ( version & <hex> ) < Opcodes . V1_5 | | ( access & ACC_SYNTHETIC_ATTRIBUTE ) ! = <int> ) { + + attributeCount ; size + = <int> ; newUTF8 ( <str> ) ; } } if ( innerClasses ! = null ) { + + attributeCount ; size + = <int> + innerClasses . length ; newUTF8 ( <str> ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = <int> + anns . getSize ( ) ; newUTF8 ( <str> ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = <int> + ianns . getSize ( ) ; newUTF8 ( <str> ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , <int> , - <int> , - <int> ) ; } size + = pool . length ; ByteVector out = new ByteVector ( size ) ; out . putInt ( <hex> ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , <int> , pool . length ) ; int mask = Opcodes . ACC_DEPRECATED | ACC_SYNTHETIC_ATTRIBUTE | ( ( access & ACC_SYNTHETIC_ATTRIBUTE ) / TO_ACC_SYNTHETIC ) ; out . putShort ( access & ~ mask ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = <int> ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = ( FieldWriter ) fb . fv ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = ( MethodWriter ) mb . mv ; } out . putShort ( attributeCount ) ; if ( bootstrapMethods ! = null ) { out . putShort ( newUTF8 ( <str> ) ) ; out . putInt ( bootstrapMethods . length + <int> ) . putShort ( bootstrapMethodsCount ) ; out . putByteArray ( bootstrapMethods . data , <int> , bootstrapMethods . length ) ; } if ( ClassReader . SIGNATURES & & signature ! = <int> ) { out . putShort ( newUTF8 ( <str> ) ) . putInt ( <int> ) . putShort ( signature ) ; } if ( sourceFile ! = <int> ) { out . putShort ( newUTF8 ( <str> ) ) . putInt ( <int> ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - <int> ; out . putShort ( newUTF8 ( <str> ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , <int> , len ) ; } if ( enclosingMethodOwner ! = <int> ) { out . putShort ( newUTF8 ( <str> ) ) . putInt ( <int> ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = <int> ) { out . putShort ( newUTF8 ( <str> ) ) . putInt ( <int> ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = <int> ) { if ( ( version & <hex> ) < Opcodes . V1_5 | | ( access & ACC_SYNTHETIC_ATTRIBUTE ) ! = <int> ) { out . putShort ( newUTF8 ( <str> ) ) . putInt ( <int> ) ; } } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( <str> ) ) ; out . putInt ( innerClasses . length + <int> ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , <int> , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( <str> ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( <str> ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , <int> , - <int> , - <int> , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; } Item newConstItem ( final Object cst ) { if ( cst instanceof Integer ) { int val = ( ( Integer ) cst ) . intValue ( ) ; return newInteger ( val ) ; } else if ( cst instanceof Byte ) { int val = ( ( Byte ) cst ) . intValue ( ) ; return newInteger ( val ) ; } else if ( cst instanceof Character ) { int val = ( ( Character ) cst ) . charValue ( ) ; return newInteger ( val ) ; } else if ( cst instanceof Short ) { int val = ( ( Short ) cst ) . intValue ( ) ; return newInteger ( val ) ; } else if ( cst instanceof Boolean ) { int val = ( ( Boolean ) cst ) . booleanValue ( ) ? <int> : <int> ; return newInteger ( val ) ; } else if ( cst instanceof Float ) { float val = ( ( Float ) cst ) . floatValue ( ) ; return newFloat ( val ) ; } else if ( cst instanceof Long ) { long val = ( ( Long ) cst ) . longValue ( ) ; return newLong ( val ) ; } else if ( cst instanceof Double ) { double val = ( ( Double ) cst ) . doubleValue ( ) ; return newDouble ( val ) ; } else if ( cst instanceof String ) { return newString ( ( String ) cst ) ; } else if ( cst instanceof Type ) { Type t = ( Type ) cst ; int s = t . getSort ( ) ; if ( s = = Type . OBJECT ) { return newClassItem ( t . getInternalName ( ) ) ; } else if ( s = = Type . METHOD ) { return newMethodTypeItem ( t . getDescriptor ( ) ) ; } else { return newClassItem ( t . getDescriptor ( ) ) ; } } else if ( cst instanceof Handle ) { Handle h = ( Handle ) cst ; return newHandleItem ( h . tag , h . owner , h . name , h . desc ) ; } else { throw new IllegalArgumentException ( <str> + cst ) ; } } public int newConst ( final Object cst ) { return newConstItem ( cst ) . index ; } public int newUTF8 ( final String value ) { key . set ( UTF8 , value , null , null ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( UTF8 ) . putUTF8 ( value ) ; result = new Item ( index + + , key ) ; put ( result ) ; } return result . index ; } Item newClassItem ( final String value ) { key2 . set ( CLASS , value , null , null ) ; Item result = get ( key2 ) ; if ( result = = null ) { pool . put12 ( CLASS , newUTF8 ( value ) ) ; result = new Item ( index + + , key2 ) ; put ( result ) ; } return result ; } public int newClass ( final String value ) { return newClassItem ( value ) . index ; } Item newMethodTypeItem ( final String methodDesc ) { key2 . set ( MTYPE , methodDesc , null , null ) ; Item result = get ( key2 ) ; if ( result = = null ) { pool . put12 ( MTYPE , newUTF8 ( methodDesc ) ) ; result = new Item ( index + + , key2 ) ; put ( result ) ; } return result ; } public int newMethodType ( final String methodDesc ) { return newMethodTypeItem ( methodDesc ) . index ; } Item newHandleItem ( final int tag , final String owner , final String name , final String desc ) { key4 . set ( HANDLE_BASE + tag , owner , name , desc ) ; Item result = get ( key4 ) ; if ( result = = null ) { if ( tag < = Opcodes . H_PUTSTATIC ) { put112 ( HANDLE , tag , newField ( owner , name , desc ) ) ; } else { put112 ( HANDLE , tag , newMethod ( owner , name , desc , tag = = Opcodes . H_INVOKEINTERFACE ) ) ; } result = new Item ( index + + , key4 ) ; put ( result ) ; } return result ; } public int newHandle ( final int tag , final String owner , final String name , final String desc ) { return newHandleItem ( tag , owner , name , desc ) . index ; } Item newInvokeDynamicItem ( final String name , final String desc , final Handle bsm , final Object . . . bsmArgs ) { ByteVector bootstrapMethods = this . bootstrapMethods ; if ( bootstrapMethods = = null ) { bootstrapMethods = this . bootstrapMethods = new ByteVector ( ) ; } int position = bootstrapMethods . length ; int hashCode = bsm . hashCode ( ) ; bootstrapMethods . putShort ( newHandle ( bsm . tag , bsm . owner , bsm . name , bsm . desc ) ) ; int argsLength = bsmArgs . length ; bootstrapMethods . putShort ( argsLength ) ; for ( int i = <int> ; i < argsLength ; i + + ) { Object bsmArg = bsmArgs [ i ] ; hashCode ^ = bsmArg . hashCode ( ) ; bootstrapMethods . putShort ( newConst ( bsmArg ) ) ; } byte [ ] data = bootstrapMethods . data ; int length = ( <int> + <int> + argsLength ) < < <int> ; hashCode & = <hex> ; Item result = items [ hashCode % items . length ] ; loop : while ( result ! = null ) { if ( result . type ! = BSM | | result . hashCode ! = hashCode ) { result = result . next ; continue ; } int resultPosition = result . intVal ; for ( int p = <int> ; p < length ; p + + ) { if ( data [ position + p ] ! = data [ resultPosition + p ] ) { result = result . next ; continue loop ; } } break ; } int bootstrapMethodIndex ; if ( result ! = null ) { bootstrapMethodIndex = result . index ; bootstrapMethods . length = position ; } else { bootstrapMethodIndex = bootstrapMethodsCount + + ; result = new Item ( bootstrapMethodIndex ) ; result . set ( position , hashCode ) ; put ( result ) ; } key3 . set ( name , desc , bootstrapMethodIndex ) ; result = get ( key3 ) ; if ( result = = null ) { put122 ( INDY , bootstrapMethodIndex , newNameType ( name , desc ) ) ; result = new Item ( index + + , key3 ) ; put ( result ) ; } return result ; } public int newInvokeDynamic ( final String name , final String desc , final Handle bsm , final Object . . . bsmArgs ) { return newInvokeDynamicItem ( name , desc , bsm , bsmArgs ) . index ; } Item newFieldItem ( final String owner , final String name , final String desc ) { key3 . set ( FIELD , owner , name , desc ) ; Item result = get ( key3 ) ; if ( result = = null ) { put122 ( FIELD , newClass ( owner ) , newNameType ( name , desc ) ) ; result = new Item ( index + + , key3 ) ; put ( result ) ; } return result ; } public int newField ( final String owner , final String name , final String desc ) { return newFieldItem ( owner , name , desc ) . index ; } Item newMethodItem ( final String owner , final String name , final String desc , final boolean itf ) { int type = itf ? IMETH : METH ; key3 . set ( type , owner , name , desc ) ; Item result = get ( key3 ) ; if ( result = = null ) { put122 ( type , newClass ( owner ) , newNameType ( name , desc ) ) ; result = new Item ( index + + , key3 ) ; put ( result ) ; } return result ; } public int newMethod ( final String owner , final String name , final String desc , final boolean itf ) { return newMethodItem ( owner , name , desc , itf ) . index ; } Item newInteger ( final int value ) { key . set ( value ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( INT ) . putInt ( value ) ; result = new Item ( index + + , key ) ; put ( result ) ; } return result ; } Item newFloat ( final float value ) { key . set ( value ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( FLOAT ) . putInt ( key . intVal ) ; result = new Item ( index + + , key ) ; put ( result ) ; } return result ; } Item newLong ( final long value ) { key . set ( value ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( LONG ) . putLong ( value ) ; result = new Item ( index , key ) ; index + = <int> ; put ( result ) ; } return result ; } Item newDouble ( final double value ) { key . set ( value ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( DOUBLE ) . putLong ( key . longVal ) ; result = new Item ( index , key ) ; index + = <int> ; put ( result ) ; } return result ; } private Item newString ( final String value ) { key2 . set ( STR , value , null , null ) ; Item result = get ( key2 ) ; if ( result = = null ) { pool . put12 ( STR , newUTF8 ( value ) ) ; result = new Item ( index + + , key2 ) ; put ( result ) ; } return result ; } public int newNameType ( final String name , final String desc ) { return newNameTypeItem ( name , desc ) . index ; } Item newNameTypeItem ( final String name , final String desc ) { key2 . set ( NAME_TYPE , name , desc , null ) ; Item result = get ( key2 ) ; if ( result = = null ) { put122 ( NAME_TYPE , newUTF8 ( name ) , newUTF8 ( desc ) ) ; result = new Item ( index + + , key2 ) ; put ( result ) ; } return result ; } int addType ( final String type ) { key . set ( TYPE_NORMAL , type , null , null ) ; Item result = get ( key ) ; if ( result = = null ) { result = addType ( key ) ; } return result . index ; } int addUninitializedType ( final String type , final int offset ) { key . type = TYPE_UNINIT ; key . intVal = offset ; key . strVal1 = type ; key . hashCode = <hex> & ( TYPE_UNINIT + type . hashCode ( ) + offset ) ; Item result = get ( key ) ; if ( result = = null ) { result = addType ( key ) ; } return result . index ; } private Item addType ( final Item item ) { + + typeCount ; Item result = new Item ( typeCount , key ) ; put ( result ) ; if ( typeTable = = null ) { typeTable = new Item [ <int> ] ; } if ( typeCount = = typeTable . length ) { Item [ ] newTable = new Item [ <int> * typeTable . length ] ; System . arraycopy ( typeTable , <int> , newTable , <int> , typeTable . length ) ; typeTable = newTable ; } typeTable [ typeCount ] = result ; return result ; } int getMergedType ( final int type1 , final int type2 ) { key2 . type = TYPE_MERGED ; key2 . longVal = type1 | ( ( ( long ) type2 ) < < <int> ) ; key2 . hashCode = <hex> & ( TYPE_MERGED + type1 + type2 ) ; Item result = get ( key2 ) ; if ( result = = null ) { String t = typeTable [ type1 ] . strVal1 ; String u = typeTable [ type2 ] . strVal1 ; key2 . intVal = addType ( getCommonSuperClass ( t , u ) ) ; result = new Item ( ( short ) <int> , key2 ) ; put ( result ) ; } return result . intVal ; } protected String getCommonSuperClass ( final String type1 , final String type2 ) { Class < ? > c , d ; ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; try { c = Class . forName ( type1 . replace ( <str> , <str> ) , false , classLoader ) ; d = Class . forName ( type2 . replace ( <str> , <str> ) , false , classLoader ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } if ( c . isAssignableFrom ( d ) ) { return type1 ; } if ( d . isAssignableFrom ( c ) ) { return type2 ; } if ( c . isInterface ( ) | | d . isInterface ( ) ) { return <str> ; } else { do { c = c . getSuperclass ( ) ; } while ( ! c . isAssignableFrom ( d ) ) ; return c . getName ( ) . replace ( <str> , <str> ) ; } } private Item get ( final Item key ) { Item i = items [ key . hashCode % items . length ] ; while ( i ! = null & & ( i . type ! = key . type | | ! key . isEqualTo ( i ) ) ) { i = i . next ; } return i ; } private void put ( final Item i ) { if ( index + typeCount > threshold ) { int ll = items . length ; int nl = ll * <int> + <int> ; Item [ ] newItems = new Item [ nl ] ; for ( int l = ll - <int> ; l > = <int> ; - - l ) { Item j = items [ l ] ; while ( j ! = null ) { int index = j . hashCode % newItems . length ; Item k = j . next ; j . next = newItems [ index ] ; newItems [ index ] = j ; j = k ; } } items = newItems ; threshold = ( int ) ( nl * <float> ) ; } int index = i . hashCode % items . length ; i . next = items [ index ] ; items [ index ] = i ; } private void put122 ( final int b , final int s1 , final int s2 ) { pool . put12 ( b , s1 ) . putShort ( s2 ) ; } private void put112 ( final int b1 , final int b2 , final int s ) { pool . put11 ( b1 , b2 ) . putShort ( s ) ; } } 
