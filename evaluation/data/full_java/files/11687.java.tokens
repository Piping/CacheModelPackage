package org . gradle . api . internal . tasks ; import org . gradle . api . Project ; import org . gradle . api . Task ; import org . gradle . api . Transformer ; import org . gradle . api . internal . project . taskfactory . ITaskFactory ; import org . gradle . api . tasks . TaskContainer ; import org . gradle . initialization . ProjectAccessListener ; import org . gradle . internal . BiAction ; import org . gradle . internal . Factory ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . model . collection . internal . BridgedCollections ; import org . gradle . model . collection . internal . ChildNodeInitializerStrategyAccessors ; import org . gradle . model . collection . internal . ModelMapModelProjection ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . model . internal . type . ModelType ; import static org . gradle . model . internal . core . NodePredicate . allLinks ; public class DefaultTaskContainerFactory implements Factory < TaskContainerInternal > { private final ModelRegistry modelRegistry ; private final Instantiator instantiator ; private final ITaskFactory taskFactory ; private Project project ; public ProjectAccessListener projectAccessListener ; public DefaultTaskContainerFactory ( ModelRegistry modelRegistry , Instantiator instantiator , ITaskFactory taskFactory , Project project , ProjectAccessListener projectAccessListener ) { this . modelRegistry = modelRegistry ; this . instantiator = instantiator ; this . taskFactory = taskFactory ; this . project = project ; this . projectAccessListener = projectAccessListener ; } public TaskContainerInternal create ( ) { ModelReference < DefaultTaskContainer > containerReference = ModelReference . of ( TaskContainerInternal . MODEL_PATH , DefaultTaskContainer . class ) ; ModelRegistrations . Builder registrationBuilder = BridgedCollections . registration ( containerReference , new Transformer < DefaultTaskContainer , MutableModelNode > ( ) { @Override public DefaultTaskContainer transform ( MutableModelNode mutableModelNode ) { return instantiator . newInstance ( DefaultTaskContainer . class , mutableModelNode , project , instantiator , taskFactory , projectAccessListener ) ; } } , new Task . Namer ( ) , <str> , new Namer ( ) ) ; modelRegistry . register ( registrationBuilder . withProjection ( ModelMapModelProjection . unmanaged ( Task . class , ChildNodeInitializerStrategyAccessors . of ( NodeBackedModelMap . createUsingParentNode ( new Transformer < NamedEntityInstantiator < Task > , MutableModelNode > ( ) { @Override public NamedEntityInstantiator < Task > transform ( MutableModelNode modelNode ) { return modelNode . getPrivateData ( ModelType . of ( DefaultTaskContainer . class ) ) . getEntityInstantiator ( ) ; } } ) ) ) ) . withProjection ( UnmanagedModelProjection . of ( TaskContainer . class ) ) . build ( ) ) ; ModelNode modelNode = modelRegistry . atStateOrLater ( TaskContainerInternal . MODEL_PATH , ModelNode . State . Created ) ; MutableModelNode mutableModelNode = ( MutableModelNode ) modelNode ; mutableModelNode . applyTo ( allLinks ( ) , ModelActionRole . Initialize , DirectNodeNoInputsModelAction . of ( ModelReference . of ( Task . class ) , new SimpleModelRuleDescriptor ( <str> ) , new BiAction < MutableModelNode , Task > ( ) { @Override public void execute ( MutableModelNode modelNode , Task task ) { TaskContainerInternal taskContainer = modelNode . getParent ( ) . getPrivateData ( TaskContainerInternal . MODEL_TYPE ) ; taskContainer . add ( task ) ; } } ) ) ; return mutableModelNode . getPrivateData ( TaskContainerInternal . MODEL_TYPE ) ; } private static class Namer implements Transformer < String , String > { public String transform ( String s ) { return <str> + s + <str> ; } } } 
