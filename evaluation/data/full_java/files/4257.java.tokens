package org . eclipse . debug . internal . ui . model . elements ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import org . eclipse . core . resources . IMarkerDelta ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IBreakpointManager ; import org . eclipse . debug . core . IBreakpointsListener ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointUIConstants ; import org . eclipse . debug . internal . ui . elements . adapters . DefaultBreakpointsViewInput ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . update . BreakpointManagerProxy ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointContainer ; import org . eclipse . debug . internal . ui . views . breakpoints . ElementComparator ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . debug . ui . contexts . IDebugContextService ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . ui . IWorkbenchWindow ; public class BreakpointManagerContentProvider extends ElementContentProvider implements IBreakpointsListener { private class InputData { final private DefaultBreakpointsViewInput fInput ; final private List < BreakpointManagerProxy > fProxies = new ArrayList < BreakpointManagerProxy > ( <int> ) ; private ElementComparator fComparator ; final private BreakpointContainer fContainer ; private IBreakpointOrganizer [ ] fOrganizers ; private IStructuredSelection fDebugContext = StructuredSelection . EMPTY ; private IPropertyChangeListener fOrganizersListener = new IPropertyChangeListener ( ) { @Override public void propertyChange ( PropertyChangeEvent event ) { updateContainers ( ) ; } } ; private IPropertyChangeListener fPresentationContextListener = new IPropertyChangeListener ( ) { @Override public void propertyChange ( PropertyChangeEvent event ) { presentationPropertyChanged ( event ) ; } } ; private IDebugContextListener fDebugContextListener = new IDebugContextListener ( ) { @Override public void debugContextChanged ( DebugContextEvent event ) { InputData . this . debugContextChanged ( event ) ; } } ; InputData ( DefaultBreakpointsViewInput input ) { fInput = input ; fComparator = ( ElementComparator ) input . getContext ( ) . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_ELEMENT_COMPARATOR ) ; fOrganizers = ( IBreakpointOrganizer [ ] ) input . getContext ( ) . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_ORGANIZERS ) ; ModelDelta initialDelta = new ModelDelta ( fInput , <int> , IModelDelta . NO_CHANGE , - <int> ) ; IBreakpoint [ ] breakpoints = filterBreakpoints ( fInput , getSelectionFilter ( fInput , getDebugContext ( ) ) , fBpManager . getBreakpoints ( ) ) ; fContainer = createRootContainer ( initialDelta , fInput , fOrganizers , breakpoints ) ; registerOrganizersListener ( null , fOrganizers ) ; input . getContext ( ) . addPropertyChangeListener ( fPresentationContextListener ) ; IWorkbenchWindow window = fInput . getContext ( ) . getWindow ( ) ; if ( window ! = null ) { IDebugContextService debugContextService = DebugUITools . getDebugContextManager ( ) . getContextService ( window ) ; ISelection debugContext = debugContextService . getActiveContext ( ) ; if ( debugContext instanceof IStructuredSelection ) { synchronized ( this ) { fDebugContext = ( IStructuredSelection ) debugContext ; } } debugContextService . addDebugContextListener ( fDebugContextListener ) ; } } void dispose ( ) { IBreakpointOrganizer [ ] organizers ; synchronized ( this ) { organizers = fOrganizers ; fOrganizers = null ; } registerOrganizersListener ( organizers , null ) ; fInput . getContext ( ) . removePropertyChangeListener ( fPresentationContextListener ) ; IWorkbenchWindow window = fInput . getContext ( ) . getWindow ( ) ; if ( window ! = null ) { IDebugContextService debugContextService = DebugUITools . getDebugContextManager ( ) . getContextService ( window ) ; debugContextService . removeDebugContextListener ( fDebugContextListener ) ; } } void proxyInstalled ( BreakpointManagerProxy proxy ) { ModelDelta rootDelta = null ; synchronized ( this ) { fProxies . add ( proxy ) ; rootDelta = new ModelDelta ( fInput , <int> , IModelDelta . NO_CHANGE , - <int> ) ; buildInstallDelta ( rootDelta , fContainer ) ; if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> + proxy + <str> ) ; } proxy . postModelChanged ( rootDelta , false ) ; } } synchronized void proxyDisposed ( BreakpointManagerProxy proxy ) { fProxies . remove ( proxy ) ; if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> + proxy + <str> ) ; } } synchronized BreakpointManagerProxy [ ] getProxies ( ) { return fProxies . toArray ( new BreakpointManagerProxy [ fProxies . size ( ) ] ) ; } void setOrganizers ( IBreakpointOrganizer [ ] organizers ) { IBreakpointOrganizer [ ] oldOrganizers = null ; synchronized ( this ) { oldOrganizers = fOrganizers ; fOrganizers = organizers ; } registerOrganizersListener ( oldOrganizers , organizers ) ; updateContainers ( ) ; } private void registerOrganizersListener ( IBreakpointOrganizer [ ] oldOrganizers , IBreakpointOrganizer [ ] newOrganizers ) { if ( oldOrganizers ! = null ) { for ( int i = <int> ; i < oldOrganizers . length ; i + + ) { oldOrganizers [ i ] . removePropertyChangeListener ( fOrganizersListener ) ; } } if ( newOrganizers ! = null ) { for ( int i = <int> ; i < newOrganizers . length ; i + + ) { newOrganizers [ i ] . addPropertyChangeListener ( fOrganizersListener ) ; } } } void updateContainers ( ) { IBreakpoint [ ] breakpoints = filterBreakpoints ( fInput , getSelectionFilter ( fInput , getDebugContext ( ) ) , fBpManager . getBreakpoints ( ) ) ; synchronized ( this ) { ModelDelta delta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; ModelDelta dummyDelta = new ModelDelta ( null , IModelDelta . NO_CHANGE ) ; BreakpointContainer refContainer = createRootContainer ( dummyDelta , fInput , fOrganizers , breakpoints ) ; deleteRemovedElements ( fContainer , refContainer , delta ) ; BreakpointContainer . copyOrganizers ( fContainer , refContainer ) ; IBreakpoint newBreakpoint = insertAddedElements ( fContainer , refContainer , delta ) ; delta . setChildCount ( fContainer . getChildren ( ) . length ) ; if ( newBreakpoint ! = null ) { appendModelDeltaToElement ( delta , newBreakpoint , IModelDelta . SELECT ) ; } if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } postModelChanged ( delta , false ) ; } } private synchronized IStructuredSelection getDebugContext ( ) { return fDebugContext ; } private void presentationPropertyChanged ( PropertyChangeEvent event ) { if ( IPresentationContext . PROPERTY_DISPOSED . equals ( event . getProperty ( ) ) ) { contextDisposed ( fInput . getContext ( ) ) ; } if ( IBreakpointUIConstants . PROP_BREAKPOINTS_ORGANIZERS . equals ( event . getProperty ( ) ) ) { IBreakpointOrganizer [ ] organizers = ( IBreakpointOrganizer [ ] ) event . getNewValue ( ) ; setOrganizers ( organizers ) ; } else if ( IBreakpointUIConstants . PROP_BREAKPOINTS_FILTER_SELECTION . equals ( event . getProperty ( ) ) ) { IStructuredSelection selection = null ; if ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) { selection = getDebugContext ( ) ; } setFilterSelection ( selection ) ; } else if ( IBreakpointUIConstants . PROP_BREAKPOINTS_TRACK_SELECTION . equals ( event . getProperty ( ) ) ) { IStructuredSelection selection = null ; if ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) { selection = getDebugContext ( ) ; } trackSelection ( selection ) ; } } private void debugContextChanged ( DebugContextEvent event ) { IStructuredSelection newContext ; if ( event . getContext ( ) instanceof IStructuredSelection ) { newContext = ( IStructuredSelection ) event . getContext ( ) ; } else { newContext = StructuredSelection . EMPTY ; } synchronized ( this ) { fDebugContext = newContext ; } if ( Boolean . TRUE . equals ( fInput . getContext ( ) . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_FILTER_SELECTION ) ) ) { setFilterSelection ( newContext ) ; } if ( Boolean . TRUE . equals ( fInput . getContext ( ) . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_TRACK_SELECTION ) ) ) { trackSelection ( newContext ) ; } } private void setFilterSelection ( IStructuredSelection ss ) { ModelDelta delta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; boolean changed = false ; IBreakpoint [ ] allBreakpoints = fBpManager . getBreakpoints ( ) ; boolean [ ] supportedBreakpoints = new boolean [ allBreakpoints . length ] ; for ( int i = <int> ; i < allBreakpoints . length ; + + i ) { supportedBreakpoints [ i ] = supportsBreakpoint ( ss , allBreakpoints [ i ] ) ; } synchronized ( this ) { Set < IBreakpoint > existingBreakpoints = new HashSet < IBreakpoint > ( Arrays . asList ( fContainer . getBreakpoints ( ) ) ) ; for ( int i = <int> ; i < allBreakpoints . length ; + + i ) { if ( ! supportedBreakpoints [ i ] & & existingBreakpoints . contains ( allBreakpoints [ i ] ) ) { fContainer . removeBreakpoint ( allBreakpoints [ i ] , delta ) ; changed = true ; } } for ( int i = <int> ; i < allBreakpoints . length ; + + i ) { if ( supportedBreakpoints [ i ] & & ! existingBreakpoints . contains ( allBreakpoints [ i ] ) ) { fContainer . addBreakpoint ( allBreakpoints [ i ] , delta ) ; changed = true ; } } if ( changed ) { if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } postModelChanged ( delta , false ) ; } } } private void trackSelection ( IStructuredSelection selection ) { if ( selection = = null | | selection . size ( ) ! = <int> ) { return ; } Iterator < ? > iter = selection . iterator ( ) ; Object firstElement = iter . next ( ) ; if ( firstElement = = null | | iter . hasNext ( ) ) { return ; } IThread thread = null ; if ( firstElement instanceof IStackFrame ) { thread = ( ( IStackFrame ) firstElement ) . getThread ( ) ; } else if ( firstElement instanceof IThread ) { thread = ( IThread ) firstElement ; } else { return ; } IBreakpoint [ ] breakpoints = thread . getBreakpoints ( ) ; Set < IBreakpoint > bpsSet = new HashSet < IBreakpoint > ( breakpoints . length * <int> / <int> ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { bpsSet . add ( breakpoints [ i ] ) ; } ModelDelta delta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; synchronized ( this ) { if ( buildTrackSelectionDelta ( delta , fContainer , bpsSet ) ) { if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } BreakpointManagerProxy [ ] proxies = getProxies ( ) ; for ( int i = <int> ; i < proxies . length ; i + + ) { proxies [ i ] . postModelChanged ( delta , true ) ; } } } } private boolean buildTrackSelectionDelta ( ModelDelta delta , BreakpointContainer container , Set < IBreakpoint > breakpoints ) { Object [ ] children = container . getChildren ( ) ; delta . setChildCount ( children . length ) ; for ( int i = <int> ; i < children . length ; i + + ) { ModelDelta childDelta = delta . addNode ( children [ i ] , i , IModelDelta . NO_CHANGE ) ; if ( children [ i ] instanceof BreakpointContainer ) { BreakpointContainer childContainer = ( BreakpointContainer ) children [ i ] ; boolean containsBP = false ; IBreakpoint [ ] containerBPs = childContainer . getBreakpoints ( ) ; for ( int j = <int> ; j < containerBPs . length ; j + + ) { if ( breakpoints . contains ( containerBPs [ j ] ) ) { containsBP = true ; break ; } } if ( containsBP & & buildTrackSelectionDelta ( childDelta , childContainer , breakpoints ) ) { return true ; } } else if ( children [ i ] instanceof IBreakpoint & & breakpoints . contains ( children [ i ] ) ) { childDelta . setFlags ( IModelDelta . SELECT | IModelDelta . EXPAND ) ; return true ; } } return false ; } void breakpointsAdded ( IBreakpoint [ ] breakpoints ) { IBreakpoint [ ] filteredBreakpoints = filterBreakpoints ( fInput , getSelectionFilter ( fInput , getDebugContext ( ) ) , breakpoints ) ; if ( filteredBreakpoints . length > <int> ) { synchronized ( this ) { ModelDelta delta = new ModelDelta ( fInput , <int> , IModelDelta . NO_CHANGE , - <int> ) ; for ( int i = <int> ; i < filteredBreakpoints . length ; + + i ) { if ( DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoint ( filteredBreakpoints [ i ] . getMarker ( ) ) ! = null ) { fContainer . addBreakpoint ( filteredBreakpoints [ i ] , delta ) ; } } delta . setChildCount ( fContainer . getChildren ( ) . length ) ; if ( filteredBreakpoints . length > <int> ) { appendModelDeltaToElement ( delta , filteredBreakpoints [ <int> ] , IModelDelta . SELECT ) ; } if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } postModelChanged ( delta , false ) ; } } } void breakpointsRemoved ( IBreakpoint [ ] breakpoints ) { synchronized ( this ) { boolean removed = false ; ModelDelta delta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; for ( int i = <int> ; i < breakpoints . length ; + + i ) { removed = fContainer . removeBreakpoint ( breakpoints [ i ] , delta ) | | removed ; } if ( removed ) { if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } postModelChanged ( delta , false ) ; } } } void breakpointsChanged ( IBreakpoint [ ] breakpoints ) { IBreakpoint [ ] filteredBreakpoints = filterBreakpoints ( fInput , getSelectionFilter ( fInput , getDebugContext ( ) ) , breakpoints ) ; synchronized ( this ) { ModelDelta delta = new ModelDelta ( fInput , IModelDelta . NO_CHANGE ) ; List < IBreakpoint > removed = new ArrayList < IBreakpoint > ( ) ; List < IBreakpoint > added = new ArrayList < IBreakpoint > ( ) ; List < IBreakpoint > filteredAsList = Arrays . asList ( filteredBreakpoints ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { IBreakpoint bp = breakpoints [ i ] ; boolean oldContainedBp = fContainer . contains ( bp ) ; boolean newContained = filteredAsList . contains ( bp ) ; if ( oldContainedBp & & ! newContained ) { removed . add ( bp ) ; } else if ( ! oldContainedBp & & newContained ) { added . add ( bp ) ; } } if ( ! added . isEmpty ( ) ) { breakpointsAdded ( added . toArray ( new IBreakpoint [ added . size ( ) ] ) ) ; } if ( ! removed . isEmpty ( ) ) { breakpointsRemoved ( removed . toArray ( new IBreakpoint [ removed . size ( ) ] ) ) ; } for ( int i = <int> ; i < filteredBreakpoints . length ; + + i ) { appendModelDelta ( fContainer , delta , IModelDelta . STATE | IModelDelta . CONTENT , filteredBreakpoints [ i ] ) ; } if ( DebugUIPlugin . DEBUG_BREAKPOINT_DELTAS ) { DebugUIPlugin . trace ( <str> ) ; } postModelChanged ( delta , false ) ; } } private void buildInstallDelta ( ModelDelta delta , BreakpointContainer container ) { Object [ ] children = container . getChildren ( ) ; delta . setChildCount ( children . length ) ; for ( int i = <int> ; i < children . length ; i + + ) { ModelDelta childDelta = delta . addNode ( children [ i ] , i , IModelDelta . NO_CHANGE ) ; if ( children [ i ] instanceof BreakpointContainer ) { childDelta . setFlags ( IModelDelta . INSTALL ) ; buildInstallDelta ( childDelta , ( BreakpointContainer ) children [ i ] ) ; } else if ( children [ i ] instanceof IBreakpoint ) { childDelta . setFlags ( IModelDelta . INSTALL ) ; } } } private IBreakpoint insertAddedElements ( BreakpointContainer container , BreakpointContainer refContainer , ModelDelta containerDelta ) { IBreakpoint newBreakpoint = null ; Object [ ] children = container . getChildren ( ) ; Object [ ] refChildren = refContainer . getChildren ( ) ; for ( int i = <int> ; i < refChildren . length ; + + i ) { Object element = getElement ( children , refChildren [ i ] ) ; if ( element = = null ) { if ( refChildren [ i ] instanceof BreakpointContainer ) { BreakpointContainer . addChildContainer ( container , ( BreakpointContainer ) refChildren [ i ] , containerDelta ) ; } else if ( refChildren [ i ] instanceof IBreakpoint ) { BreakpointContainer . addBreakpoint ( container , ( IBreakpoint ) refChildren [ i ] , containerDelta ) ; if ( newBreakpoint = = null ) { newBreakpoint = ( IBreakpoint ) refChildren [ i ] ; } } } else if ( element instanceof BreakpointContainer ) { ModelDelta childDelta = containerDelta . addNode ( element , container . getChildIndex ( element ) , IModelDelta . STATE , - <int> ) ; BreakpointContainer . copyOrganizers ( ( BreakpointContainer ) element , ( BreakpointContainer ) refChildren [ i ] ) ; newBreakpoint = insertAddedElements ( ( BreakpointContainer ) element , ( BreakpointContainer ) refChildren [ i ] , childDelta ) ; childDelta . setChildCount ( ( ( BreakpointContainer ) element ) . getChildren ( ) . length ) ; } } return newBreakpoint ; } private void deleteRemovedElements ( BreakpointContainer container , BreakpointContainer refContainer , ModelDelta containerDelta ) { Object [ ] children = container . getChildren ( ) ; Object [ ] refChildren = refContainer . getChildren ( ) ; for ( int i = <int> ; i < children . length ; + + i ) { Object element = getElement ( refChildren , children [ i ] ) ; if ( element = = null ) { if ( children [ i ] instanceof BreakpointContainer ) { BreakpointContainer . removeAll ( ( BreakpointContainer ) children [ i ] , containerDelta ) ; } else { BreakpointContainer . removeBreakpoint ( container , ( IBreakpoint ) children [ i ] , containerDelta ) ; } } else if ( element instanceof BreakpointContainer ) { ModelDelta childDelta = containerDelta . addNode ( children [ i ] , IModelDelta . STATE ) ; deleteRemovedElements ( ( BreakpointContainer ) children [ i ] , ( BreakpointContainer ) element , childDelta ) ; } } } private Object getElement ( Object [ ] collection , Object element ) { for ( int i = <int> ; i < collection . length ; + + i ) { if ( collection [ i ] instanceof BreakpointContainer & & element instanceof BreakpointContainer ) { if ( collection [ i ] . equals ( element ) ) { return collection [ i ] ; } } else { if ( collection [ i ] . equals ( element ) ) { return collection [ i ] ; } } } return null ; } private BreakpointContainer createRootContainer ( ModelDelta rootDelta , DefaultBreakpointsViewInput input , IBreakpointOrganizer [ ] organizers , IBreakpoint [ ] breakpoints ) { BreakpointContainer container = new BreakpointContainer ( organizers , fComparator ) ; container . initDefaultContainers ( rootDelta ) ; for ( int i = <int> ; i < breakpoints . length ; + + i ) { container . addBreakpoint ( breakpoints [ i ] , rootDelta ) ; } return container ; } synchronized private void postModelChanged ( final IModelDelta delta , boolean select ) { for ( int i = <int> ; fProxies ! = null & & i < fProxies . size ( ) ; i + + ) { fProxies . get ( i ) . postModelChanged ( delta , select ) ; } } } private class InputDataMap < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = <int> ; public InputDataMap ( ) { super ( <int> , ( float ) <float> , true ) ; } @Override protected boolean removeEldestEntry ( java . util . Map . Entry < K , V > arg0 ) { InputData data = ( InputData ) arg0 . getValue ( ) ; if ( size ( ) > getMaxInputsCache ( ) & & data . fProxies . isEmpty ( ) ) { data . dispose ( ) ; return true ; } return false ; } } private ISchedulingRule fBreakpointsListenerSchedulingRule = new ISchedulingRule ( ) { @Override public boolean isConflicting ( ISchedulingRule rule ) { return rule = = this ; } @Override public boolean contains ( ISchedulingRule rule ) { return rule = = this ; } } ; final private Map < DefaultBreakpointsViewInput , InputData > fInputToData = Collections . synchronizedMap ( new InputDataMap < DefaultBreakpointsViewInput , InputData > ( ) ) ; private boolean fIsBreakpointListener = false ; final private IBreakpointManager fBpManager = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) ; protected IBreakpoint [ ] filterBreakpoints ( DefaultBreakpointsViewInput input , IStructuredSelection selectionFilter , IBreakpoint [ ] breakpoints ) { if ( selectionFilter ! = null & & ! selectionFilter . isEmpty ( ) ) { List < IDebugTarget > targets = getDebugTargets ( selectionFilter ) ; ArrayList < IBreakpoint > retVal = new ArrayList < IBreakpoint > ( ) ; if ( targets ! = null ) { for ( int i = <int> ; i < breakpoints . length ; + + i ) { if ( supportsBreakpoint ( targets , breakpoints [ i ] ) ) { retVal . add ( breakpoints [ i ] ) ; } } } return retVal . toArray ( new IBreakpoint [ retVal . size ( ) ] ) ; } else { return breakpoints ; } } protected boolean supportsBreakpoint ( IStructuredSelection ss , IBreakpoint breakpoint ) { return supportsBreakpoint ( getDebugTargets ( ss ) , breakpoint ) ; } protected boolean supportsBreakpoint ( List < IDebugTarget > targets , IBreakpoint breakpoint ) { boolean exist = targets . size ( ) = = <int> ? true : false ; for ( int i = <int> ; ! exist & & i < targets . size ( ) ; + + i ) { IDebugTarget target = targets . get ( i ) ; exist | = target . supportsBreakpoint ( breakpoint ) ; } return exist ; } protected List < IDebugTarget > getDebugTargets ( IStructuredSelection ss ) { List < IDebugTarget > debugTargets = new ArrayList < IDebugTarget > ( <int> ) ; if ( ss ! = null ) { Iterator < ? > i = ss . iterator ( ) ; while ( i . hasNext ( ) ) { Object next = i . next ( ) ; if ( next instanceof IDebugElement ) { debugTargets . add ( ( ( IDebugElement ) next ) . getDebugTarget ( ) ) ; } else if ( next instanceof ILaunch ) { IDebugTarget [ ] targets = ( ( ILaunch ) next ) . getDebugTargets ( ) ; for ( int j = <int> ; j < targets . length ; j + + ) { debugTargets . add ( targets [ j ] ) ; } } else if ( next instanceof IProcess ) { IDebugTarget target = ( ( IProcess ) next ) . getAdapter ( IDebugTarget . class ) ; if ( target ! = null ) { debugTargets . add ( target ) ; } } else if ( next instanceof IAdaptable ) { IDebugTarget target = ( ( IAdaptable ) next ) . getAdapter ( IDebugTarget . class ) ; if ( target ! = null ) { debugTargets . add ( target ) ; } } } } return debugTargets ; } protected int getMaxInputsCache ( ) { return <int> ; } protected void contextDisposed ( IPresentationContext context ) { List < InputData > removed = new ArrayList < InputData > ( <int> ) ; synchronized ( fInputToData ) { for ( Iterator < Entry < DefaultBreakpointsViewInput , InputData > > itr = fInputToData . entrySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Map . Entry < DefaultBreakpointsViewInput , InputData > entry = itr . next ( ) ; IPresentationContext entryContext = entry . getKey ( ) . getContext ( ) ; if ( context . equals ( entryContext ) ) { removed . add ( entry . getValue ( ) ) ; itr . remove ( ) ; } } } for ( int i = <int> ; i < removed . size ( ) ; i + + ) { removed . get ( i ) . dispose ( ) ; } } public void registerModelProxy ( DefaultBreakpointsViewInput input , BreakpointManagerProxy proxy ) { synchronized ( this ) { if ( ! fIsBreakpointListener ) { fBpManager . addBreakpointListener ( this ) ; fIsBreakpointListener = true ; } } InputData inputData = getInputData ( input ) ; if ( inputData ! = null ) { inputData . proxyInstalled ( proxy ) ; } } public void unregisterModelProxy ( DefaultBreakpointsViewInput input , BreakpointManagerProxy proxy ) { InputData inputData = fInputToData . get ( input ) ; if ( inputData ! = null ) { inputData . proxyDisposed ( proxy ) ; if ( fInputToData . isEmpty ( ) ) { synchronized ( this ) { if ( fIsBreakpointListener ) { fBpManager . removeBreakpointListener ( this ) ; fIsBreakpointListener = false ; } } } } } private InputData getInputData ( DefaultBreakpointsViewInput input ) { if ( Boolean . TRUE . equals ( input . getContext ( ) . getProperty ( IPresentationContext . PROPERTY_DISPOSED ) ) ) { return null ; } InputData data = null ; synchronized ( fInputToData ) { data = fInputToData . get ( input ) ; if ( data = = null ) { data = new InputData ( input ) ; fInputToData . put ( input , data ) ; } } return data ; } protected IStructuredSelection getSelectionFilter ( Object input , IStructuredSelection debugContext ) { if ( input instanceof DefaultBreakpointsViewInput ) { IPresentationContext presentation = ( ( DefaultBreakpointsViewInput ) input ) . getContext ( ) ; if ( Boolean . TRUE . equals ( presentation . getProperty ( IBreakpointUIConstants . PROP_BREAKPOINTS_FILTER_SELECTION ) ) ) { return debugContext ; } } return null ; } @Override protected boolean supportsContextId ( String id ) { return id . equals ( IDebugUIConstants . ID_BREAKPOINT_VIEW ) ; } @Override protected int getChildCount ( Object element , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { Object input = monitor . getViewerInput ( ) ; if ( input instanceof DefaultBreakpointsViewInput ) { DefaultBreakpointsViewInput bpManagerInput = ( DefaultBreakpointsViewInput ) input ; InputData inputData = getInputData ( bpManagerInput ) ; if ( inputData ! = null ) { return inputData . fContainer . getChildren ( ) . length ; } } return <int> ; } @Override protected Object [ ] getChildren ( Object parent , int index , int length , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { Object input = monitor . getViewerInput ( ) ; if ( input instanceof DefaultBreakpointsViewInput ) { DefaultBreakpointsViewInput bpManagerInput = ( DefaultBreakpointsViewInput ) input ; InputData inputData = getInputData ( bpManagerInput ) ; if ( inputData ! = null ) { Object [ ] children = inputData . fContainer . getChildren ( ) ; return getElements ( children , index , length ) ; } } return EMPTY ; } @Override public void breakpointsAdded ( final IBreakpoint [ ] breakpoints ) { new Job ( <str> ) { { setSystem ( true ) ; setRule ( fBreakpointsListenerSchedulingRule ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { InputData [ ] datas = fInputToData . values ( ) . toArray ( new InputData [ <int> ] ) ; for ( int i = <int> ; i < datas . length ; i + + ) { datas [ i ] . breakpointsAdded ( breakpoints ) ; } return Status . OK_STATUS ; } } . schedule ( ) ; } @Override public void breakpointsRemoved ( final IBreakpoint [ ] breakpoints , IMarkerDelta [ ] deltas ) { new Job ( <str> ) { { setSystem ( true ) ; setRule ( fBreakpointsListenerSchedulingRule ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { InputData [ ] datas = fInputToData . values ( ) . toArray ( new InputData [ <int> ] ) ; for ( int i = <int> ; i < datas . length ; i + + ) { datas [ i ] . breakpointsRemoved ( breakpoints ) ; } return Status . OK_STATUS ; } } . schedule ( ) ; } @Override public void breakpointsChanged ( final IBreakpoint [ ] breakpoints , IMarkerDelta [ ] deltas ) { new Job ( <str> ) { { setSystem ( true ) ; setRule ( fBreakpointsListenerSchedulingRule ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { InputData [ ] datas = fInputToData . values ( ) . toArray ( new InputData [ <int> ] ) ; for ( int i = <int> ; i < datas . length ; i + + ) { datas [ i ] . breakpointsChanged ( breakpoints ) ; } return Status . OK_STATUS ; } } . schedule ( ) ; } private void appendModelDelta ( BreakpointContainer parent , ModelDelta parentDelta , int flags , IBreakpoint breakpoint ) { BreakpointContainer [ ] containers = parent . getContainers ( ) ; if ( parent . contains ( breakpoint ) ) { if ( ( containers . length ! = <int> ) ) { for ( int i = <int> ; i < containers . length ; + + i ) { ModelDelta nodeDelta = parentDelta . addNode ( containers [ i ] , IModelDelta . STATE ) ; appendModelDelta ( containers [ i ] , nodeDelta , flags , breakpoint ) ; } } else { parentDelta . addNode ( breakpoint , flags ) ; } } } private void appendModelDeltaToElement ( IModelDelta parentDelta , Object element , int flags ) { if ( element . equals ( parentDelta . getElement ( ) ) ) { ( ( ModelDelta ) parentDelta ) . setFlags ( parentDelta . getFlags ( ) | flags ) ; return ; } IModelDelta [ ] childDeltas = parentDelta . getChildDeltas ( ) ; for ( int i = <int> ; i < childDeltas . length ; + + i ) { if ( element . equals ( childDeltas [ i ] . getElement ( ) ) ) { ( ( ModelDelta ) childDeltas [ i ] ) . setFlags ( childDeltas [ i ] . getFlags ( ) | flags ) ; return ; } appendModelDeltaToElement ( childDeltas [ i ] , element , flags ) ; } } } 
