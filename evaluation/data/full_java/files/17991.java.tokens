package com . badlogic . gdx . graphics . g3d . attributes ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . g3d . Attribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . NumberUtils ; public class BlendingAttribute extends Attribute { public final static String Alias = <str> ; public final static long Type = register ( Alias ) ; public final static boolean is ( final long mask ) { return ( mask & Type ) = = mask ; } public boolean blended ; public int sourceFunction ; public int destFunction ; public float opacity = <float> ; public BlendingAttribute ( ) { this ( null ) ; } public BlendingAttribute ( final boolean blended , final int sourceFunc , final int destFunc , final float opacity ) { super ( Type ) ; this . blended = blended ; this . sourceFunction = sourceFunc ; this . destFunction = destFunc ; this . opacity = opacity ; } public BlendingAttribute ( final int sourceFunc , final int destFunc , final float opacity ) { this ( true , sourceFunc , destFunc , opacity ) ; } public BlendingAttribute ( final int sourceFunc , final int destFunc ) { this ( sourceFunc , destFunc , <float> ) ; } public BlendingAttribute ( final boolean blended , final float opacity ) { this ( blended , GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA , opacity ) ; } public BlendingAttribute ( final float opacity ) { this ( true , opacity ) ; } public BlendingAttribute ( final BlendingAttribute copyFrom ) { this ( copyFrom = = null ? true : copyFrom . blended , copyFrom = = null ? GL20 . GL_SRC_ALPHA : copyFrom . sourceFunction , copyFrom = = null ? GL20 . GL_ONE_MINUS_SRC_ALPHA : copyFrom . destFunction , copyFrom = = null ? <float> : copyFrom . opacity ) ; } @Override public BlendingAttribute copy ( ) { return new BlendingAttribute ( this ) ; } @Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = <int> * result + ( blended ? <int> : <int> ) ; result = <int> * result + sourceFunction ; result = <int> * result + destFunction ; result = <int> * result + NumberUtils . floatToRawIntBits ( opacity ) ; return result ; } @Override public int compareTo ( Attribute o ) { if ( type ! = o . type ) return ( int ) ( type - o . type ) ; BlendingAttribute other = ( BlendingAttribute ) o ; if ( blended ! = other . blended ) return blended ? <int> : - <int> ; if ( sourceFunction ! = other . sourceFunction ) return sourceFunction - other . sourceFunction ; if ( destFunction ! = other . destFunction ) return destFunction - other . destFunction ; return ( MathUtils . isEqual ( opacity , other . opacity ) ) ? <int> : ( opacity < other . opacity ? <int> : - <int> ) ; } } 
