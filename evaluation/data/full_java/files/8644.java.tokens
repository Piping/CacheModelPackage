package org . elasticsearch . messy . tests ; import org . elasticsearch . action . Action ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionModule ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestBuilder ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . action . admin . indices . refresh . RefreshRequest ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . indexedscripts . put . PutIndexedScriptRequest ; import org . elasticsearch . action . indexedscripts . put . PutIndexedScriptResponse ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . FilterClient ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . script . Template ; import org . elasticsearch . script . mustache . MustachePlugin ; import org . elasticsearch . script . mustache . MustacheScriptEngineService ; import org . elasticsearch . search . suggest . Suggest ; import org . elasticsearch . search . suggest . SuggestBuilder ; import org . elasticsearch . search . suggest . phrase . PhraseSuggestionBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . junit . After ; import org . junit . Before ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . concurrent . CopyOnWriteArrayList ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . node . Node . HTTP_ENABLED ; import static org . elasticsearch . search . suggest . SuggestBuilders . phraseSuggestion ; import static org . elasticsearch . test . ESIntegTestCase . Scope . SUITE ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSuggestionSize ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; @ClusterScope ( scope = SUITE ) public class ContextAndHeaderTransportTests extends ESIntegTestCase { private static final List < ActionRequest > requests = new CopyOnWriteArrayList < > ( ) ; private String randomHeaderKey = randomAsciiOfLength ( <int> ) ; private String randomHeaderValue = randomAsciiOfLength ( <int> ) ; private String queryIndex = <str> + randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . ROOT ) ; private String lookupIndex = <str> + randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . ROOT ) ; @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , <str> ) . put ( HTTP_ENABLED , true ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( ActionLoggingPlugin . class , MustachePlugin . class ) ; } @Before public void createIndices ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . build ( ) ; assertAcked ( transportClient ( ) . admin ( ) . indices ( ) . prepareCreate ( lookupIndex ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ) ; assertAcked ( transportClient ( ) . admin ( ) . indices ( ) . prepareCreate ( queryIndex ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ) ; ensureGreen ( queryIndex , lookupIndex ) ; requests . clear ( ) ; } @After public void checkAllRequestsContainHeaders ( ) { assertRequestsContainHeader ( IndexRequest . class ) ; assertRequestsContainHeader ( RefreshRequest . class ) ; } public void testThatIndexedScriptGetRequestInTemplateQueryContainsContextAndHeaders ( ) throws Exception { PutIndexedScriptResponse scriptResponse = transportClient ( ) . preparePutIndexedScript ( MustacheScriptEngineService . NAME , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . string ( ) ) . get ( ) ; assertThat ( scriptResponse . isCreated ( ) , is ( true ) ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( queryIndex ) . get ( ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setQuery ( QueryBuilders . templateQuery ( new Template ( <str> , ScriptType . INDEXED , MustacheScriptEngineService . NAME , null , null ) ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertGetRequestsContainHeaders ( <str> ) ; assertRequestsContainHeader ( PutIndexedScriptRequest . class ) ; } public void testThatSearchTemplatesWithIndexedTemplatesGetRequestContainsContextAndHeaders ( ) throws Exception { PutIndexedScriptResponse scriptResponse = transportClient ( ) . preparePutIndexedScript ( MustacheScriptEngineService . NAME , <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ) . get ( ) ; assertThat ( scriptResponse . isCreated ( ) , is ( true ) ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( queryIndex ) . get ( ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( <str> , <str> ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setTemplate ( new Template ( <str> , ScriptType . INDEXED , MustacheScriptEngineService . NAME , null , params ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertGetRequestsContainHeaders ( <str> ) ; assertRequestsContainHeader ( PutIndexedScriptRequest . class ) ; } public void testThatIndexedScriptGetRequestInPhraseSuggestContainsContextAndHeaders ( ) throws Exception { CreateIndexRequestBuilder builder = transportClient ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( <str> , <str> ) . putArray ( <str> , <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , true ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ; XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( builder . addMapping ( <str> , mapping ) ) ; ensureGreen ( ) ; List < String > titles = new ArrayList < > ( ) ; titles . add ( <str> ) ; titles . add ( <str> ) ; titles . add ( <str> ) ; titles . add ( <str> ) ; titles . add ( <str> ) ; titles . add ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( String title : titles ) { transportClient ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , title ) . get ( ) ; } transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . get ( ) ; String filterStringAsFilter = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . string ( ) ; PutIndexedScriptResponse scriptResponse = transportClient ( ) . preparePutIndexedScript ( MustacheScriptEngineService . NAME , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , filterStringAsFilter ) . endObject ( ) . string ( ) ) . get ( ) ; assertThat ( scriptResponse . isCreated ( ) , is ( true ) ) ; PhraseSuggestionBuilder suggest = phraseSuggestion ( <str> ) . field ( <str> ) . addCandidateGenerator ( PhraseSuggestionBuilder . candidateGenerator ( <str> ) . suggestMode ( <str> ) . maxTermFreq ( <float> ) . size ( <int> ) . maxInspections ( <int> ) ) . confidence ( <float> ) . maxErrors ( <float> ) . shardSize ( <int> ) . size ( <int> ) ; PhraseSuggestionBuilder filteredFilterSuggest = suggest . collateQuery ( new Template ( <str> , ScriptType . INDEXED , MustacheScriptEngineService . NAME , null , null ) ) ; SearchRequestBuilder searchRequestBuilder = transportClient ( ) . prepareSearch ( <str> ) . setSize ( <int> ) ; SuggestBuilder suggestBuilder = new SuggestBuilder ( ) ; String suggestText = <str> ; if ( suggestText ! = null ) { suggestBuilder . setText ( suggestText ) ; } suggestBuilder . addSuggestion ( filteredFilterSuggest ) ; searchRequestBuilder . suggest ( suggestBuilder ) ; SearchResponse actionGet = searchRequestBuilder . execute ( ) . actionGet ( ) ; assertThat ( Arrays . toString ( actionGet . getShardFailures ( ) ) , actionGet . getFailedShards ( ) , equalTo ( <int> ) ) ; Suggest searchSuggest = actionGet . getSuggest ( ) ; assertSuggestionSize ( searchSuggest , <int> , <int> , <str> ) ; assertGetRequestsContainHeaders ( <str> ) ; assertRequestsContainHeader ( PutIndexedScriptRequest . class ) ; } private < T > List < T > getRequests ( Class < T > clazz ) { List < T > results = new ArrayList < > ( ) ; for ( ActionRequest request : requests ) { if ( request . getClass ( ) . equals ( clazz ) ) { results . add ( ( T ) request ) ; } } return results ; } private void assertRequestsContainHeader ( Class < ? extends ActionRequest > clazz ) { List < ? extends ActionRequest > classRequests = getRequests ( clazz ) ; for ( ActionRequest request : classRequests ) { assertRequestContainsHeader ( request ) ; } } private void assertGetRequestsContainHeaders ( ) { assertGetRequestsContainHeaders ( this . lookupIndex ) ; } private void assertGetRequestsContainHeaders ( String index ) { List < GetRequest > getRequests = getRequests ( GetRequest . class ) ; assertThat ( getRequests , hasSize ( greaterThan ( <int> ) ) ) ; for ( GetRequest request : getRequests ) { if ( ! request . index ( ) . equals ( index ) ) { continue ; } assertRequestContainsHeader ( request ) ; } } private void assertRequestContainsHeader ( ActionRequest request ) { String msg = String . format ( Locale . ROOT , <str> , randomHeaderKey , request . getClass ( ) . getName ( ) ) ; if ( request instanceof IndexRequest ) { IndexRequest indexRequest = ( IndexRequest ) request ; msg = String . format ( Locale . ROOT , <str> , randomHeaderKey , indexRequest . index ( ) , indexRequest . type ( ) , indexRequest . id ( ) ) ; } assertThat ( msg , request . hasHeader ( randomHeaderKey ) , is ( true ) ) ; assertThat ( request . getHeader ( randomHeaderKey ) . toString ( ) , is ( randomHeaderValue ) ) ; } private Client transportClient ( ) { Client transportClient = internalCluster ( ) . transportClient ( ) ; FilterClient filterClient = new FilterClient ( transportClient ) { @Override protected < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > void doExecute ( Action < Request , Response , RequestBuilder > action , Request request , ActionListener < Response > listener ) { request . putHeader ( randomHeaderKey , randomHeaderValue ) ; super . doExecute ( action , request , listener ) ; } } ; return filterClient ; } public static class ActionLoggingPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } @Override public Collection < Module > nodeModules ( ) { return Collections . < Module > singletonList ( new ActionLoggingModule ( ) ) ; } public void onModule ( ActionModule module ) { module . registerFilter ( LoggingFilter . class ) ; } } public static class ActionLoggingModule extends AbstractModule { @Override protected void configure ( ) { bind ( LoggingFilter . class ) . asEagerSingleton ( ) ; } } public static class LoggingFilter extends ActionFilter . Simple { @Inject public LoggingFilter ( Settings settings ) { super ( settings ) ; } @Override public int order ( ) { return <int> ; } @Override protected boolean apply ( String action , ActionRequest request , ActionListener listener ) { requests . add ( request ) ; return true ; } @Override protected boolean apply ( String action , ActionResponse response , ActionListener listener ) { return true ; } } } 
