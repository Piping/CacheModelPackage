package org . gradle . wrapper ; import java . io . Closeable ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import java . util . concurrent . Callable ; public class ExclusiveFileAccessManager { public static final String LOCK_FILE_SUFFIX = <str> ; private final int timeoutMs ; private final int pollIntervalMs ; public ExclusiveFileAccessManager ( int timeoutMs , int pollIntervalMs ) { this . timeoutMs = timeoutMs ; this . pollIntervalMs = pollIntervalMs ; } public < T > T access ( File exclusiveFile , Callable < T > task ) throws Exception { final File lockFile = new File ( exclusiveFile . getParentFile ( ) , exclusiveFile . getName ( ) + LOCK_FILE_SUFFIX ) ; lockFile . getParentFile ( ) . mkdirs ( ) ; RandomAccessFile randomAccessFile = null ; FileChannel channel = null ; try { long startAt = System . currentTimeMillis ( ) ; FileLock lock = null ; while ( lock = = null & & System . currentTimeMillis ( ) < startAt + timeoutMs ) { randomAccessFile = new RandomAccessFile ( lockFile , <str> ) ; channel = randomAccessFile . getChannel ( ) ; lock = channel . tryLock ( ) ; if ( lock = = null ) { maybeCloseQuietly ( channel ) ; maybeCloseQuietly ( randomAccessFile ) ; Thread . sleep ( pollIntervalMs ) ; } } if ( lock = = null ) { throw new RuntimeException ( <str> + timeoutMs + <str> + exclusiveFile . getAbsolutePath ( ) ) ; } try { return task . call ( ) ; } finally { lock . release ( ) ; maybeCloseQuietly ( channel ) ; channel = null ; maybeCloseQuietly ( randomAccessFile ) ; randomAccessFile = null ; } } finally { maybeCloseQuietly ( channel ) ; maybeCloseQuietly ( randomAccessFile ) ; } } private static void maybeCloseQuietly ( Closeable closeable ) { if ( closeable ! = null ) { try { closeable . close ( ) ; } catch ( Exception ignore ) { } } } } 
