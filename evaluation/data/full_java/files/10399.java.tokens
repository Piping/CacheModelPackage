package com . google . common . collect ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Objects ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . google . MultisetTestSuiteBuilder ; import com . google . common . collect . testing . google . SortedMultisetTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringMultisetGenerator ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; @GwtIncompatible ( <str> ) public class MultisetsCollectionTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( unmodifiableMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( SortedMultisetTestSuiteBuilder . using ( unmodifiableSortedMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( unionGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( intersectionGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . KNOWN_ORDER ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( sumGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( differenceGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . KNOWN_ORDER ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( filteredGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . KNOWN_ORDER , CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE ) . named ( <str> ) . createTestSuite ( ) ) ; return suite ; } private static TestStringMultisetGenerator unmodifiableMultisetGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { return Multisets . unmodifiableMultiset ( LinkedHashMultiset . create ( asList ( elements ) ) ) ; } @Override public List < String > order ( List < String > insertionOrder ) { List < String > order = new ArrayList < String > ( ) ; for ( String s : insertionOrder ) { int index = order . indexOf ( s ) ; if ( index = = - <int> ) { order . add ( s ) ; } else { order . add ( index , s ) ; } } return order ; } } ; } private static TestStringMultisetGenerator unmodifiableSortedMultisetGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { return Multisets . unmodifiableSortedMultiset ( TreeMultiset . create ( asList ( elements ) ) ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ; } private static TestStringMultisetGenerator unionGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset1 = LinkedHashMultiset . create ( ) ; Multiset < String > multiset2 = LinkedHashMultiset . create ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { String element = elements [ i ] ; if ( multiset1 . contains ( element ) | | multiset2 . contains ( element ) ) { multiset1 . add ( element ) ; multiset2 . add ( element ) ; } else if ( i % <int> = = <int> ) { multiset1 . add ( elements [ i ] ) ; } else { multiset2 . add ( elements [ i ] ) ; } } return Multisets . union ( multiset1 , multiset2 ) ; } } ; } private static TestStringMultisetGenerator intersectionGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset1 = LinkedHashMultiset . create ( ) ; Multiset < String > multiset2 = LinkedHashMultiset . create ( ) ; multiset1 . add ( <str> ) ; multiset2 . add ( <str> ) ; for ( int i = <int> ; i < elements . length ; i + + ) { multiset1 . add ( elements [ i ] ) ; multiset2 . add ( elements [ elements . length - <int> - i ] ) ; } if ( elements . length > <int> ) { multiset1 . add ( elements [ <int> ] ) ; } if ( elements . length > <int> ) { if ( ! Objects . equal ( elements [ <int> ] , elements [ <int> ] ) ) { multiset2 . add ( elements [ <int> ] , <int> ) ; } } return Multisets . intersection ( multiset1 , multiset2 ) ; } } ; } private static TestStringMultisetGenerator sumGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset1 = LinkedHashMultiset . create ( ) ; Multiset < String > multiset2 = LinkedHashMultiset . create ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { if ( i % <int> = = <int> ) { multiset1 . add ( elements [ i ] ) ; } else { multiset2 . add ( elements [ i ] ) ; } } return Multisets . sum ( multiset1 , multiset2 ) ; } } ; } private static TestStringMultisetGenerator differenceGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset1 = LinkedHashMultiset . create ( ) ; Multiset < String > multiset2 = LinkedHashMultiset . create ( ) ; multiset1 . add ( <str> ) ; multiset1 . add ( <str> ) ; multiset2 . add ( <str> ) ; multiset2 . add ( <str> , <int> ) ; multiset2 . add ( <str> , <int> ) ; for ( int i = <int> ; i < elements . length ; i + + ) { multiset1 . add ( elements [ i ] , i + <int> ) ; multiset2 . add ( elements [ i ] , i + <int> ) ; } return Multisets . difference ( multiset1 , multiset2 ) ; } } ; } private static final Multiset < String > ELEMENTS_TO_FILTER_OUT = ImmutableMultiset . of ( <str> , <str> , <str> , <str> ) ; private static final Predicate < String > PREDICATE = Predicates . not ( Predicates . in ( ELEMENTS_TO_FILTER_OUT ) ) ; private static TestStringMultisetGenerator filteredGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset = LinkedHashMultiset . create ( ) ; Collections . addAll ( multiset , elements ) ; multiset . addAll ( ELEMENTS_TO_FILTER_OUT ) ; return Multisets . filter ( multiset , PREDICATE ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Lists . newArrayList ( LinkedHashMultiset . create ( insertionOrder ) ) ; } } ; } } 
