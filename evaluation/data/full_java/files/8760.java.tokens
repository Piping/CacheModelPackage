package org . elasticsearch . plugin . discovery . multicast ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . settings . Settings ; import java . io . Closeable ; import java . net . DatagramPacket ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . MulticastSocket ; import java . net . SocketAddress ; import java . net . SocketTimeoutException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; abstract class MulticastChannel implements Closeable { public static MulticastChannel getChannel ( String name , boolean shared , Config config , Listener listener ) throws Exception { if ( ! shared ) { return new Plain ( listener , name , config ) ; } return Shared . getSharedChannel ( listener , config ) ; } public static final class Config { public final int port ; public final String group ; public final int bufferSize ; public final int ttl ; public final InetAddress multicastInterface ; public final boolean deferToInterface ; public Config ( int port , String group , int bufferSize , int ttl , InetAddress multicastInterface , boolean deferToInterface ) { this . port = port ; this . group = group ; this . bufferSize = bufferSize ; this . ttl = ttl ; this . multicastInterface = multicastInterface ; this . deferToInterface = deferToInterface ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Config config = ( Config ) o ; if ( bufferSize ! = config . bufferSize ) return false ; if ( port ! = config . port ) return false ; if ( ttl ! = config . ttl ) return false ; if ( group ! = null ? ! group . equals ( config . group ) : config . group ! = null ) return false ; if ( multicastInterface ! = null ? ! multicastInterface . equals ( config . multicastInterface ) : config . multicastInterface ! = null ) return false ; return true ; } @Override public int hashCode ( ) { int result = port ; result = <int> * result + ( group ! = null ? group . hashCode ( ) : <int> ) ; result = <int> * result + bufferSize ; result = <int> * result + ttl ; result = <int> * result + ( multicastInterface ! = null ? multicastInterface . hashCode ( ) : <int> ) ; return result ; } } public static interface Listener { void onMessage ( BytesReference data , SocketAddress address ) ; } public static class MultiListener implements Listener { private final CopyOnWriteArrayList < Listener > listeners = new CopyOnWriteArrayList < > ( ) ; public void add ( Listener listener ) { this . listeners . add ( listener ) ; } public boolean remove ( Listener listener ) { return this . listeners . remove ( listener ) ; } @Override public void onMessage ( BytesReference data , SocketAddress address ) { for ( Listener listener : listeners ) { listener . onMessage ( data , address ) ; } } } protected final Listener listener ; private AtomicBoolean closed = new AtomicBoolean ( ) ; protected MulticastChannel ( Listener listener ) { this . listener = listener ; } public abstract void send ( BytesReference data ) throws Exception ; @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { close ( listener ) ; } } protected abstract void close ( Listener listener ) ; public static final String SHARED_CHANNEL_NAME = <str> ; private final static class Shared extends MulticastChannel { private static final Map < Config , Shared > sharedChannels = new HashMap < > ( ) ; private static final Object mutex = new Object ( ) ; static MulticastChannel getSharedChannel ( Listener listener , Config config ) throws Exception { synchronized ( mutex ) { Shared shared = sharedChannels . get ( config ) ; if ( shared ! = null ) { shared . incRef ( ) ; ( ( MultiListener ) shared . listener ) . add ( listener ) ; } else { MultiListener multiListener = new MultiListener ( ) ; multiListener . add ( listener ) ; shared = new Shared ( multiListener , new Plain ( multiListener , SHARED_CHANNEL_NAME , config ) ) ; sharedChannels . put ( config , shared ) ; } return new Delegate ( listener , shared ) ; } } static void close ( Shared shared , Listener listener ) { synchronized ( mutex ) { boolean removed = ( ( MultiListener ) shared . listener ) . remove ( listener ) ; assert removed : <str> ; if ( shared . decRef ( ) = = <int> ) { assert ( ( MultiListener ) shared . listener ) . listeners . isEmpty ( ) ; sharedChannels . remove ( shared . channel . getConfig ( ) ) ; shared . channel . close ( ) ; } } } final Plain channel ; private int refCount = <int> ; Shared ( MultiListener listener , Plain channel ) { super ( listener ) ; this . channel = channel ; } private void incRef ( ) { refCount + + ; } private int decRef ( ) { - - refCount ; assert refCount > = <int> : <str> ; return refCount ; } @Override public void send ( BytesReference data ) throws Exception { channel . send ( data ) ; } @Override public void close ( ) { assert false : <str> ; } @Override protected void close ( Listener listener ) { close ( this , listener ) ; } } private final static class Delegate extends MulticastChannel { private final MulticastChannel channel ; Delegate ( Listener listener , MulticastChannel channel ) { super ( listener ) ; this . channel = channel ; } @Override public void send ( BytesReference data ) throws Exception { channel . send ( data ) ; } @Override protected void close ( Listener listener ) { channel . close ( listener ) ; } } @SuppressForbidden ( reason = <str> ) private static class Plain extends MulticastChannel { private final ESLogger logger ; private final Config config ; private volatile MulticastSocket multicastSocket ; private final DatagramPacket datagramPacketSend ; private final DatagramPacket datagramPacketReceive ; private final Object sendMutex = new Object ( ) ; private final Object receiveMutex = new Object ( ) ; private final Receiver receiver ; private final Thread receiverThread ; Plain ( Listener listener , String name , Config config ) throws Exception { super ( listener ) ; this . logger = ESLoggerFactory . getLogger ( name ) ; this . config = config ; this . datagramPacketReceive = new DatagramPacket ( new byte [ config . bufferSize ] , config . bufferSize ) ; this . datagramPacketSend = new DatagramPacket ( new byte [ config . bufferSize ] , config . bufferSize , InetAddress . getByName ( config . group ) , config . port ) ; this . multicastSocket = buildMulticastSocket ( config ) ; this . receiver = new Receiver ( ) ; this . receiverThread = daemonThreadFactory ( Settings . builder ( ) . put ( <str> , name ) . build ( ) , <str> ) . newThread ( receiver ) ; this . receiverThread . start ( ) ; } private MulticastSocket buildMulticastSocket ( Config config ) throws Exception { SocketAddress addr = new InetSocketAddress ( InetAddress . getByName ( config . group ) , config . port ) ; MulticastSocket multicastSocket = new MulticastSocket ( config . port ) ; try { multicastSocket . setTimeToLive ( config . ttl ) ; if ( config . deferToInterface ) { multicastSocket . joinGroup ( addr , null ) ; multicastSocket . setInterface ( config . multicastInterface ) ; } else { multicastSocket . setInterface ( config . multicastInterface ) ; multicastSocket . joinGroup ( InetAddress . getByName ( config . group ) ) ; } multicastSocket . setReceiveBufferSize ( config . bufferSize ) ; multicastSocket . setSendBufferSize ( config . bufferSize ) ; multicastSocket . setSoTimeout ( <int> ) ; } catch ( Throwable e ) { IOUtils . closeWhileHandlingException ( multicastSocket ) ; throw e ; } return multicastSocket ; } public Config getConfig ( ) { return this . config ; } @Override public void send ( BytesReference data ) throws Exception { synchronized ( sendMutex ) { datagramPacketSend . setData ( data . toBytes ( ) ) ; multicastSocket . send ( datagramPacketSend ) ; } } @Override protected void close ( Listener listener ) { receiver . stop ( ) ; receiverThread . interrupt ( ) ; if ( multicastSocket ! = null ) { IOUtils . closeWhileHandlingException ( multicastSocket ) ; multicastSocket = null ; } try { receiverThread . join ( <int> ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } private class Receiver implements Runnable { private volatile boolean running = true ; public void stop ( ) { running = false ; } @Override public void run ( ) { while ( running ) { try { synchronized ( receiveMutex ) { try { multicastSocket . receive ( datagramPacketReceive ) ; } catch ( SocketTimeoutException ignore ) { continue ; } catch ( Exception e ) { if ( running ) { if ( multicastSocket . isClosed ( ) ) { logger . warn ( <str> ) ; multicastSocket = buildMulticastSocket ( config ) ; } else { logger . warn ( <str> , e ) ; Thread . sleep ( <int> ) ; } } continue ; } } if ( datagramPacketReceive . getData ( ) . length > <int> ) { listener . onMessage ( new BytesArray ( datagramPacketReceive . getData ( ) ) , datagramPacketReceive . getSocketAddress ( ) ) ; } } catch ( Throwable e ) { if ( running ) { logger . warn ( <str> , e ) ; } } } } } } } 
