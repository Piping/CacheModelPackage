package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndex ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . math . IntMath ; import com . google . j2objc . annotations . Weak ; import com . google . j2objc . annotations . WeakOuter ; import java . util . AbstractQueue ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . PriorityQueue ; import java . util . Queue ; @Beta public final class MinMaxPriorityQueue < E > extends AbstractQueue < E > { public static < E extends Comparable < E > > MinMaxPriorityQueue < E > create ( ) { return new Builder < Comparable > ( Ordering . natural ( ) ) . create ( ) ; } public static < E extends Comparable < E > > MinMaxPriorityQueue < E > create ( Iterable < ? extends E > initialContents ) { return new Builder < E > ( Ordering . < E > natural ( ) ) . create ( initialContents ) ; } public static < B > Builder < B > orderedBy ( Comparator < B > comparator ) { return new Builder < B > ( comparator ) ; } public static Builder < Comparable > expectedSize ( int expectedSize ) { return new Builder < Comparable > ( Ordering . natural ( ) ) . expectedSize ( expectedSize ) ; } public static Builder < Comparable > maximumSize ( int maximumSize ) { return new Builder < Comparable > ( Ordering . natural ( ) ) . maximumSize ( maximumSize ) ; } @Beta public static final class Builder < B > { private static final int UNSET_EXPECTED_SIZE = - <int> ; private final Comparator < B > comparator ; private int expectedSize = UNSET_EXPECTED_SIZE ; private int maximumSize = Integer . MAX_VALUE ; private Builder ( Comparator < B > comparator ) { this . comparator = checkNotNull ( comparator ) ; } public Builder < B > expectedSize ( int expectedSize ) { checkArgument ( expectedSize > = <int> ) ; this . expectedSize = expectedSize ; return this ; } public Builder < B > maximumSize ( int maximumSize ) { checkArgument ( maximumSize > <int> ) ; this . maximumSize = maximumSize ; return this ; } public < T extends B > MinMaxPriorityQueue < T > create ( ) { return create ( Collections . < T > emptySet ( ) ) ; } public < T extends B > MinMaxPriorityQueue < T > create ( Iterable < ? extends T > initialContents ) { MinMaxPriorityQueue < T > queue = new MinMaxPriorityQueue < T > ( this , initialQueueSize ( expectedSize , maximumSize , initialContents ) ) ; for ( T element : initialContents ) { queue . offer ( element ) ; } return queue ; } @SuppressWarnings ( <str> ) private < T extends B > Ordering < T > ordering ( ) { return Ordering . from ( ( Comparator < T > ) comparator ) ; } } private final Heap minHeap ; private final Heap maxHeap ; @VisibleForTesting final int maximumSize ; private Object [ ] queue ; private int size ; private int modCount ; private MinMaxPriorityQueue ( Builder < ? super E > builder , int queueSize ) { Ordering < E > ordering = builder . ordering ( ) ; this . minHeap = new Heap ( ordering ) ; this . maxHeap = new Heap ( ordering . reverse ( ) ) ; minHeap . otherHeap = maxHeap ; maxHeap . otherHeap = minHeap ; this . maximumSize = builder . maximumSize ; this . queue = new Object [ queueSize ] ; } @Override public int size ( ) { return size ; } @Override public boolean add ( E element ) { offer ( element ) ; return true ; } @Override public boolean addAll ( Collection < ? extends E > newElements ) { boolean modified = false ; for ( E element : newElements ) { offer ( element ) ; modified = true ; } return modified ; } @Override public boolean offer ( E element ) { checkNotNull ( element ) ; modCount + + ; int insertIndex = size + + ; growIfNeeded ( ) ; heapForIndex ( insertIndex ) . bubbleUp ( insertIndex , element ) ; return size < = maximumSize | | pollLast ( ) ! = element ; } @Override public E poll ( ) { return isEmpty ( ) ? null : removeAndGet ( <int> ) ; } @SuppressWarnings ( <str> ) E elementData ( int index ) { return ( E ) queue [ index ] ; } @Override public E peek ( ) { return isEmpty ( ) ? null : elementData ( <int> ) ; } private int getMaxElementIndex ( ) { switch ( size ) { case <int> : return <int> ; case <int> : return <int> ; default : return ( maxHeap . compareElements ( <int> , <int> ) < = <int> ) ? <int> : <int> ; } } public E pollFirst ( ) { return poll ( ) ; } public E removeFirst ( ) { return remove ( ) ; } public E peekFirst ( ) { return peek ( ) ; } public E pollLast ( ) { return isEmpty ( ) ? null : removeAndGet ( getMaxElementIndex ( ) ) ; } public E removeLast ( ) { if ( isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } return removeAndGet ( getMaxElementIndex ( ) ) ; } public E peekLast ( ) { return isEmpty ( ) ? null : elementData ( getMaxElementIndex ( ) ) ; } @VisibleForTesting MoveDesc < E > removeAt ( int index ) { checkPositionIndex ( index , size ) ; modCount + + ; size - - ; if ( size = = index ) { queue [ size ] = null ; return null ; } E actualLastElement = elementData ( size ) ; int lastElementAt = heapForIndex ( size ) . getCorrectLastElement ( actualLastElement ) ; E toTrickle = elementData ( size ) ; queue [ size ] = null ; MoveDesc < E > changes = fillHole ( index , toTrickle ) ; if ( lastElementAt < index ) { if ( changes = = null ) { return new MoveDesc < E > ( actualLastElement , toTrickle ) ; } else { return new MoveDesc < E > ( actualLastElement , changes . replaced ) ; } } return changes ; } private MoveDesc < E > fillHole ( int index , E toTrickle ) { Heap heap = heapForIndex ( index ) ; int vacated = heap . fillHoleAt ( index ) ; int bubbledTo = heap . bubbleUpAlternatingLevels ( vacated , toTrickle ) ; if ( bubbledTo = = vacated ) { return heap . tryCrossOverAndBubbleUp ( index , vacated , toTrickle ) ; } else { return ( bubbledTo < index ) ? new MoveDesc < E > ( toTrickle , elementData ( index ) ) : null ; } } static class MoveDesc < E > { final E toTrickle ; final E replaced ; MoveDesc ( E toTrickle , E replaced ) { this . toTrickle = toTrickle ; this . replaced = replaced ; } } private E removeAndGet ( int index ) { E value = elementData ( index ) ; removeAt ( index ) ; return value ; } private Heap heapForIndex ( int i ) { return isEvenLevel ( i ) ? minHeap : maxHeap ; } private static final int EVEN_POWERS_OF_TWO = <hex> ; private static final int ODD_POWERS_OF_TWO = <hex> ; @VisibleForTesting static boolean isEvenLevel ( int index ) { int oneBased = index + <int> ; checkState ( oneBased > <int> , <str> ) ; return ( oneBased & EVEN_POWERS_OF_TWO ) > ( oneBased & ODD_POWERS_OF_TWO ) ; } @VisibleForTesting boolean isIntact ( ) { for ( int i = <int> ; i < size ; i + + ) { if ( ! heapForIndex ( i ) . verifyIndex ( i ) ) { return false ; } } return true ; } @WeakOuter private class Heap { final Ordering < E > ordering ; @Weak Heap otherHeap ; Heap ( Ordering < E > ordering ) { this . ordering = ordering ; } int compareElements ( int a , int b ) { return ordering . compare ( elementData ( a ) , elementData ( b ) ) ; } MoveDesc < E > tryCrossOverAndBubbleUp ( int removeIndex , int vacated , E toTrickle ) { int crossOver = crossOver ( vacated , toTrickle ) ; if ( crossOver = = vacated ) { return null ; } E parent ; if ( crossOver < removeIndex ) { parent = elementData ( removeIndex ) ; } else { parent = elementData ( getParentIndex ( removeIndex ) ) ; } if ( otherHeap . bubbleUpAlternatingLevels ( crossOver , toTrickle ) < removeIndex ) { return new MoveDesc < E > ( toTrickle , parent ) ; } else { return null ; } } void bubbleUp ( int index , E x ) { int crossOver = crossOverUp ( index , x ) ; Heap heap ; if ( crossOver = = index ) { heap = this ; } else { index = crossOver ; heap = otherHeap ; } heap . bubbleUpAlternatingLevels ( index , x ) ; } int bubbleUpAlternatingLevels ( int index , E x ) { while ( index > <int> ) { int grandParentIndex = getGrandparentIndex ( index ) ; E e = elementData ( grandParentIndex ) ; if ( ordering . compare ( e , x ) < = <int> ) { break ; } queue [ index ] = e ; index = grandParentIndex ; } queue [ index ] = x ; return index ; } int findMin ( int index , int len ) { if ( index > = size ) { return - <int> ; } checkState ( index > <int> ) ; int limit = Math . min ( index , size - len ) + len ; int minIndex = index ; for ( int i = index + <int> ; i < limit ; i + + ) { if ( compareElements ( i , minIndex ) < <int> ) { minIndex = i ; } } return minIndex ; } int findMinChild ( int index ) { return findMin ( getLeftChildIndex ( index ) , <int> ) ; } int findMinGrandChild ( int index ) { int leftChildIndex = getLeftChildIndex ( index ) ; if ( leftChildIndex < <int> ) { return - <int> ; } return findMin ( getLeftChildIndex ( leftChildIndex ) , <int> ) ; } int crossOverUp ( int index , E x ) { if ( index = = <int> ) { queue [ <int> ] = x ; return <int> ; } int parentIndex = getParentIndex ( index ) ; E parentElement = elementData ( parentIndex ) ; if ( parentIndex ! = <int> ) { int grandparentIndex = getParentIndex ( parentIndex ) ; int uncleIndex = getRightChildIndex ( grandparentIndex ) ; if ( uncleIndex ! = parentIndex & & getLeftChildIndex ( uncleIndex ) > = size ) { E uncleElement = elementData ( uncleIndex ) ; if ( ordering . compare ( uncleElement , parentElement ) < <int> ) { parentIndex = uncleIndex ; parentElement = uncleElement ; } } } if ( ordering . compare ( parentElement , x ) < <int> ) { queue [ index ] = parentElement ; queue [ parentIndex ] = x ; return parentIndex ; } queue [ index ] = x ; return index ; } int getCorrectLastElement ( E actualLastElement ) { int parentIndex = getParentIndex ( size ) ; if ( parentIndex ! = <int> ) { int grandparentIndex = getParentIndex ( parentIndex ) ; int uncleIndex = getRightChildIndex ( grandparentIndex ) ; if ( uncleIndex ! = parentIndex & & getLeftChildIndex ( uncleIndex ) > = size ) { E uncleElement = elementData ( uncleIndex ) ; if ( ordering . compare ( uncleElement , actualLastElement ) < <int> ) { queue [ uncleIndex ] = actualLastElement ; queue [ size ] = uncleElement ; return uncleIndex ; } } } return size ; } int crossOver ( int index , E x ) { int minChildIndex = findMinChild ( index ) ; if ( ( minChildIndex > <int> ) & & ( ordering . compare ( elementData ( minChildIndex ) , x ) < <int> ) ) { queue [ index ] = elementData ( minChildIndex ) ; queue [ minChildIndex ] = x ; return minChildIndex ; } return crossOverUp ( index , x ) ; } int fillHoleAt ( int index ) { int minGrandchildIndex ; while ( ( minGrandchildIndex = findMinGrandChild ( index ) ) > <int> ) { queue [ index ] = elementData ( minGrandchildIndex ) ; index = minGrandchildIndex ; } return index ; } private boolean verifyIndex ( int i ) { if ( ( getLeftChildIndex ( i ) < size ) & & ( compareElements ( i , getLeftChildIndex ( i ) ) > <int> ) ) { return false ; } if ( ( getRightChildIndex ( i ) < size ) & & ( compareElements ( i , getRightChildIndex ( i ) ) > <int> ) ) { return false ; } if ( ( i > <int> ) & & ( compareElements ( i , getParentIndex ( i ) ) > <int> ) ) { return false ; } if ( ( i > <int> ) & & ( compareElements ( getGrandparentIndex ( i ) , i ) > <int> ) ) { return false ; } return true ; } private int getLeftChildIndex ( int i ) { return i * <int> + <int> ; } private int getRightChildIndex ( int i ) { return i * <int> + <int> ; } private int getParentIndex ( int i ) { return ( i - <int> ) / <int> ; } private int getGrandparentIndex ( int i ) { return getParentIndex ( getParentIndex ( i ) ) ; } } private class QueueIterator implements Iterator < E > { private int cursor = - <int> ; private int expectedModCount = modCount ; private Queue < E > forgetMeNot ; private List < E > skipMe ; private E lastFromForgetMeNot ; private boolean canRemove ; @Override public boolean hasNext ( ) { checkModCount ( ) ; return ( nextNotInSkipMe ( cursor + <int> ) < size ( ) ) | | ( ( forgetMeNot ! = null ) & & ! forgetMeNot . isEmpty ( ) ) ; } @Override public E next ( ) { checkModCount ( ) ; int tempCursor = nextNotInSkipMe ( cursor + <int> ) ; if ( tempCursor < size ( ) ) { cursor = tempCursor ; canRemove = true ; return elementData ( cursor ) ; } else if ( forgetMeNot ! = null ) { cursor = size ( ) ; lastFromForgetMeNot = forgetMeNot . poll ( ) ; if ( lastFromForgetMeNot ! = null ) { canRemove = true ; return lastFromForgetMeNot ; } } throw new NoSuchElementException ( <str> ) ; } @Override public void remove ( ) { checkRemove ( canRemove ) ; checkModCount ( ) ; canRemove = false ; expectedModCount + + ; if ( cursor < size ( ) ) { MoveDesc < E > moved = removeAt ( cursor ) ; if ( moved ! = null ) { if ( forgetMeNot = = null ) { forgetMeNot = new ArrayDeque < E > ( ) ; skipMe = new ArrayList < E > ( <int> ) ; } forgetMeNot . add ( moved . toTrickle ) ; skipMe . add ( moved . replaced ) ; } cursor - - ; } else { checkState ( removeExact ( lastFromForgetMeNot ) ) ; lastFromForgetMeNot = null ; } } private boolean containsExact ( Iterable < E > elements , E target ) { for ( E element : elements ) { if ( element = = target ) { return true ; } } return false ; } boolean removeExact ( Object target ) { for ( int i = <int> ; i < size ; i + + ) { if ( queue [ i ] = = target ) { removeAt ( i ) ; return true ; } } return false ; } void checkModCount ( ) { if ( modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } } private int nextNotInSkipMe ( int c ) { if ( skipMe ! = null ) { while ( c < size ( ) & & containsExact ( skipMe , elementData ( c ) ) ) { c + + ; } } return c ; } } @Override public Iterator < E > iterator ( ) { return new QueueIterator ( ) ; } @Override public void clear ( ) { for ( int i = <int> ; i < size ; i + + ) { queue [ i ] = null ; } size = <int> ; } @Override public Object [ ] toArray ( ) { Object [ ] copyTo = new Object [ size ] ; System . arraycopy ( queue , <int> , copyTo , <int> , size ) ; return copyTo ; } public Comparator < ? super E > comparator ( ) { return minHeap . ordering ; } @VisibleForTesting int capacity ( ) { return queue . length ; } private static final int DEFAULT_CAPACITY = <int> ; @VisibleForTesting static int initialQueueSize ( int configuredExpectedSize , int maximumSize , Iterable < ? > initialContents ) { int result = ( configuredExpectedSize = = Builder . UNSET_EXPECTED_SIZE ) ? DEFAULT_CAPACITY : configuredExpectedSize ; if ( initialContents instanceof Collection ) { int initialSize = ( ( Collection < ? > ) initialContents ) . size ( ) ; result = Math . max ( result , initialSize ) ; } return capAtMaximumSize ( result , maximumSize ) ; } private void growIfNeeded ( ) { if ( size > queue . length ) { int newCapacity = calculateNewCapacity ( ) ; Object [ ] newQueue = new Object [ newCapacity ] ; System . arraycopy ( queue , <int> , newQueue , <int> , queue . length ) ; queue = newQueue ; } } private int calculateNewCapacity ( ) { int oldCapacity = queue . length ; int newCapacity = ( oldCapacity < <int> ) ? ( oldCapacity + <int> ) * <int> : IntMath . checkedMultiply ( oldCapacity / <int> , <int> ) ; return capAtMaximumSize ( newCapacity , maximumSize ) ; } private static int capAtMaximumSize ( int queueSize , int maximumSize ) { return Math . min ( queueSize - <int> , maximumSize ) + <int> ; } } 
