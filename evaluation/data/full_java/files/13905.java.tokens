package org . gradle . tooling . internal . provider ; import org . gradle . internal . classloader . ClassLoaderSpec ; import org . gradle . internal . classloader . MutableURLClassLoader ; import org . gradle . internal . classloader . TransformingClassLoader ; import org . gradle . tooling . provider . model . internal . LegacyConsumerInterface ; import org . objectweb . asm . * ; import java . net . URL ; import java . util . Arrays ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; public class ClientSidePayloadClassLoaderFactory implements PayloadClassLoaderFactory { private final PayloadClassLoaderFactory classLoaderFactory ; public ClientSidePayloadClassLoaderFactory ( PayloadClassLoaderFactory classLoaderFactory ) { this . classLoaderFactory = classLoaderFactory ; } public ClassLoader getClassLoaderFor ( ClassLoaderSpec spec , List < ? extends ClassLoader > parents ) { if ( spec instanceof MutableURLClassLoader . Spec ) { MutableURLClassLoader . Spec clSpec = ( MutableURLClassLoader . Spec ) spec ; if ( parents . size ( ) ! = <int> ) { throw new IllegalStateException ( <str> ) ; } return new MixInClassLoader ( parents . get ( <int> ) , clSpec . getClasspath ( ) ) ; } return classLoaderFactory . getClassLoaderFor ( spec , parents ) ; } private static class MixInClassLoader extends TransformingClassLoader { public MixInClassLoader ( ClassLoader parent , List < URL > classPath ) { super ( parent , classPath ) ; } @Override protected byte [ ] transform ( byte [ ] bytes ) { ClassReader classReader = new ClassReader ( bytes ) ; AnnotationDetector detector = new AnnotationDetector ( ) ; classReader . accept ( detector , ClassReader . SKIP_DEBUG | ClassReader . SKIP_CODE ) ; if ( ! detector . found ) { return bytes ; } if ( findLoadedClass ( detector . interfaceName ) = = null ) { ClassWriter emptyWriter = new ClassWriter ( <int> ) ; emptyWriter . visit ( Opcodes . V1_5 , Opcodes . ACC_PUBLIC | Opcodes . ACC_INTERFACE , detector . interfaceName . replace ( <str> , <str> ) , null , Type . getType ( Object . class ) . getInternalName ( ) , null ) ; emptyWriter . visitEnd ( ) ; byte [ ] emptyBytecode = emptyWriter . toByteArray ( ) ; defineClass ( detector . interfaceName , emptyBytecode , <int> , emptyBytecode . length ) ; } ClassWriter classWriter = new ClassWriter ( <int> ) ; classReader . accept ( new TransformingAdapter ( classWriter , detector . interfaceName ) , <int> ) ; bytes = classWriter . toByteArray ( ) ; return bytes ; } private static class AnnotationDetector extends ClassVisitor { private static final String ANNOTATION_DESCRIPTOR = Type . getType ( LegacyConsumerInterface . class ) . getDescriptor ( ) ; String interfaceName ; private boolean found ; private AnnotationDetector ( ) { super ( Opcodes . ASM5 ) ; } public AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { if ( desc . equals ( ANNOTATION_DESCRIPTOR ) ) { found = true ; } return new AnnotationVisitor ( Opcodes . ASM5 ) { @Override public void visit ( String name , Object value ) { if ( name . equals ( <str> ) ) { interfaceName = value . toString ( ) ; } } } ; } } private static class TransformingAdapter extends ClassVisitor { private final String mixInInterface ; public TransformingAdapter ( ClassWriter classWriter , String mixInInterface ) { super ( Opcodes . ASM5 , classWriter ) ; this . mixInInterface = mixInInterface ; } @Override public void visit ( int version , int access , String name , String signature , String superName , String [ ] interfaces ) { Set < String > allInterfaces = new LinkedHashSet < String > ( Arrays . asList ( interfaces ) ) ; allInterfaces . add ( mixInInterface . replace ( <str> , <str> ) ) ; super . visit ( version , access , name , signature , superName , allInterfaces . toArray ( new String [ allInterfaces . size ( ) ] ) ) ; } } } } 
