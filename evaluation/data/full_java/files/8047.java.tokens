package org . elasticsearch . gateway ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . store . * ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . URISyntaxException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import java . util . * ; import java . util . stream . StreamSupport ; import static org . hamcrest . Matchers . * ; @LuceneTestCase.SuppressFileSystems ( <str> ) public class MetaDataStateFormatTests extends ESTestCase { public void testReadClusterState ( ) throws URISyntaxException , IOException { final MetaDataStateFormat < MetaData > format = new MetaDataStateFormat < MetaData > ( randomFrom ( XContentType . values ( ) ) , <str> ) { @Override public void toXContent ( XContentBuilder builder , MetaData state ) throws IOException { fail ( <str> ) ; } @Override public MetaData fromXContent ( XContentParser parser ) throws IOException { return MetaData . Builder . fromXContent ( parser ) ; } } ; Path tmp = createTempDir ( ) ; final InputStream resource = this . getClass ( ) . getResourceAsStream ( <str> ) ; assertThat ( resource , notNullValue ( ) ) ; Path dst = tmp . resolve ( <str> ) ; Files . copy ( resource , dst ) ; MetaData read = format . read ( dst ) ; assertThat ( read , notNullValue ( ) ) ; assertThat ( read . clusterUUID ( ) , equalTo ( <str> ) ) ; } public void testReadWriteState ( ) throws IOException { Path [ ] dirs = new Path [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < dirs . length ; i + + ) { dirs [ i ] = createTempDir ( ) ; } final long id = addDummyFiles ( <str> , dirs ) ; Format format = new Format ( randomFrom ( XContentType . values ( ) ) , <str> ) ; DummyState state = new DummyState ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) , randomInt ( ) , randomLong ( ) , randomDouble ( ) , randomBoolean ( ) ) ; int version = between ( <int> , Integer . MAX_VALUE / <int> ) ; format . write ( state , version , dirs ) ; for ( Path file : dirs ) { Path [ ] list = content ( <str> , file ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; Path stateDir = list [ <int> ] ; assertThat ( Files . isDirectory ( stateDir ) , is ( true ) ) ; list = content ( <str> , stateDir ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( <str> + id + <str> ) ) ; DummyState read = format . read ( list [ <int> ] ) ; assertThat ( read , equalTo ( state ) ) ; } final int version2 = between ( version , Integer . MAX_VALUE ) ; DummyState state2 = new DummyState ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) , randomInt ( ) , randomLong ( ) , randomDouble ( ) , randomBoolean ( ) ) ; format . write ( state2 , version2 , dirs ) ; for ( Path file : dirs ) { Path [ ] list = content ( <str> , file ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; Path stateDir = list [ <int> ] ; assertThat ( Files . isDirectory ( stateDir ) , is ( true ) ) ; list = content ( <str> , stateDir ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( <str> + ( id + <int> ) + <str> ) ) ; DummyState read = format . read ( list [ <int> ] ) ; assertThat ( read , equalTo ( state2 ) ) ; } } public void testVersionMismatch ( ) throws IOException { Path [ ] dirs = new Path [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < dirs . length ; i + + ) { dirs [ i ] = createTempDir ( ) ; } final long id = addDummyFiles ( <str> , dirs ) ; Format format = new Format ( randomFrom ( XContentType . values ( ) ) , <str> ) ; DummyState state = new DummyState ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) , randomInt ( ) , randomLong ( ) , randomDouble ( ) , randomBoolean ( ) ) ; int version = between ( <int> , Integer . MAX_VALUE / <int> ) ; format . write ( state , version , dirs ) ; for ( Path file : dirs ) { Path [ ] list = content ( <str> , file ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; Path stateDir = list [ <int> ] ; assertThat ( Files . isDirectory ( stateDir ) , is ( true ) ) ; list = content ( <str> , stateDir ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( <str> + id + <str> ) ) ; DummyState read = format . read ( list [ <int> ] ) ; assertThat ( read , equalTo ( state ) ) ; } } public void testCorruption ( ) throws IOException { Path [ ] dirs = new Path [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < dirs . length ; i + + ) { dirs [ i ] = createTempDir ( ) ; } final long id = addDummyFiles ( <str> , dirs ) ; Format format = new Format ( randomFrom ( XContentType . values ( ) ) , <str> ) ; DummyState state = new DummyState ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) , randomInt ( ) , randomLong ( ) , randomDouble ( ) , randomBoolean ( ) ) ; int version = between ( <int> , Integer . MAX_VALUE / <int> ) ; format . write ( state , version , dirs ) ; for ( Path file : dirs ) { Path [ ] list = content ( <str> , file ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; Path stateDir = list [ <int> ] ; assertThat ( Files . isDirectory ( stateDir ) , is ( true ) ) ; list = content ( <str> , stateDir ) ; assertEquals ( list . length , <int> ) ; assertThat ( list [ <int> ] . getFileName ( ) . toString ( ) , equalTo ( <str> + id + <str> ) ) ; DummyState read = format . read ( list [ <int> ] ) ; assertThat ( read , equalTo ( state ) ) ; corruptFile ( list [ <int> ] , logger ) ; try { format . read ( list [ <int> ] ) ; fail ( <str> ) ; } catch ( CorruptStateException ex ) { } } } public static void corruptFile ( Path file , ESLogger logger ) throws IOException { Path fileToCorrupt = file ; try ( final SimpleFSDirectory dir = new SimpleFSDirectory ( fileToCorrupt . getParent ( ) ) ) { long checksumBeforeCorruption ; try ( IndexInput input = dir . openInput ( fileToCorrupt . getFileName ( ) . toString ( ) , IOContext . DEFAULT ) ) { checksumBeforeCorruption = CodecUtil . retrieveChecksum ( input ) ; } try ( FileChannel raf = FileChannel . open ( fileToCorrupt , StandardOpenOption . READ , StandardOpenOption . WRITE ) ) { raf . position ( randomIntBetween ( <int> , ( int ) Math . min ( Integer . MAX_VALUE , raf . size ( ) - <int> ) ) ) ; long filePointer = raf . position ( ) ; ByteBuffer bb = ByteBuffer . wrap ( new byte [ <int> ] ) ; raf . read ( bb ) ; bb . flip ( ) ; byte oldValue = bb . get ( <int> ) ; byte newValue = ( byte ) ~ oldValue ; bb . put ( <int> , newValue ) ; raf . write ( bb , filePointer ) ; logger . debug ( <str> , fileToCorrupt . getFileName ( ) . toString ( ) , filePointer , Integer . toHexString ( oldValue ) , Integer . toHexString ( newValue ) ) ; } long checksumAfterCorruption ; long actualChecksumAfterCorruption ; try ( ChecksumIndexInput input = dir . openChecksumInput ( fileToCorrupt . getFileName ( ) . toString ( ) , IOContext . DEFAULT ) ) { assertThat ( input . getFilePointer ( ) , is ( <int> l ) ) ; input . seek ( input . length ( ) - <int> ) ; checksumAfterCorruption = input . getChecksum ( ) ; actualChecksumAfterCorruption = input . readLong ( ) ; } StringBuilder msg = new StringBuilder ( ) ; msg . append ( <str> ) . append ( checksumBeforeCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( checksumAfterCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( actualChecksumAfterCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( fileToCorrupt . getFileName ( ) . toString ( ) ) . append ( <str> ) . append ( dir . fileLength ( fileToCorrupt . getFileName ( ) . toString ( ) ) ) ; logger . debug ( msg . toString ( ) ) ; assumeTrue ( <str> + msg . toString ( ) , checksumAfterCorruption ! = checksumBeforeCorruption | | actualChecksumAfterCorruption ! = checksumBeforeCorruption ) ; } } public void testLatestVersionDoesNotUseLegacy ( ) throws IOException { final ToXContent . Params params = ToXContent . EMPTY_PARAMS ; MetaDataStateFormat < MetaData > format = MetaStateService . globalStateFormat ( randomFrom ( XContentType . values ( ) ) , params ) ; final Path [ ] dirs = new Path [ <int> ] ; dirs [ <int> ] = createTempDir ( ) ; dirs [ <int> ] = createTempDir ( ) ; for ( Path dir : dirs ) { Files . createDirectories ( dir . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; } final Path dir1 = randomFrom ( dirs ) ; final int v1 = randomInt ( <int> ) ; format . write ( randomMeta ( ) , v1 , dir1 ) ; final int numLegacyFiles = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numLegacyFiles ; + + i ) { final Path dir2 = randomFrom ( dirs ) ; final int v2 = v1 + <int> + randomInt ( <int> ) ; try ( XContentBuilder xcontentBuilder = XContentFactory . contentBuilder ( format . format ( ) , Files . newOutputStream ( dir2 . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( MetaStateService . GLOBAL_STATE_FILE_PREFIX + v2 ) ) ) ) { xcontentBuilder . startObject ( ) ; MetaData . Builder . toXContent ( randomMeta ( ) , xcontentBuilder , params ) ; xcontentBuilder . endObject ( ) ; } } try { format . loadLatestState ( logger , dirs ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertThat ( ex . getMessage ( ) , startsWith ( <str> ) ) ; } final MetaData meta = randomMeta ( ) ; format . write ( meta , v1 , dirs ) ; final MetaData metaData = format . loadLatestState ( logger , dirs ) ; assertEquals ( meta . clusterUUID ( ) , metaData . clusterUUID ( ) ) ; final Path path = randomFrom ( dirs ) ; final Path [ ] files = FileSystemUtils . files ( path . resolve ( <str> ) ) ; assertEquals ( <int> , files . length ) ; assertEquals ( <str> + format . findMaxStateId ( <str> , dirs ) + <str> , files [ <int> ] . getFileName ( ) . toString ( ) ) ; } public void testPrefersNewerFormat ( ) throws IOException { final ToXContent . Params params = ToXContent . EMPTY_PARAMS ; MetaDataStateFormat < MetaData > format = MetaStateService . globalStateFormat ( randomFrom ( XContentType . values ( ) ) , params ) ; final Path [ ] dirs = new Path [ <int> ] ; dirs [ <int> ] = createTempDir ( ) ; dirs [ <int> ] = createTempDir ( ) ; for ( Path dir : dirs ) { Files . createDirectories ( dir . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; } final long v = randomInt ( <int> ) ; MetaData meta = randomMeta ( ) ; String uuid = meta . clusterUUID ( ) ; final Path dir2 = randomFrom ( dirs ) ; MetaData meta2 = randomMeta ( ) ; assertFalse ( meta2 . clusterUUID ( ) . equals ( uuid ) ) ; try ( XContentBuilder xcontentBuilder = XContentFactory . contentBuilder ( format . format ( ) , Files . newOutputStream ( dir2 . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( MetaStateService . GLOBAL_STATE_FILE_PREFIX + v ) ) ) ) { xcontentBuilder . startObject ( ) ; MetaData . Builder . toXContent ( randomMeta ( ) , xcontentBuilder , params ) ; xcontentBuilder . endObject ( ) ; } format . write ( meta , v , dirs ) ; MetaData state = format . loadLatestState ( logger , dirs ) ; final Path path = randomFrom ( dirs ) ; assertTrue ( Files . exists ( path . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( <str> + ( v + <int> ) + <str> ) ) ) ; assertEquals ( state . clusterUUID ( ) , uuid ) ; } public void testLoadState ( ) throws IOException { final ToXContent . Params params = ToXContent . EMPTY_PARAMS ; final Path [ ] dirs = new Path [ randomIntBetween ( <int> , <int> ) ] ; int numStates = randomIntBetween ( <int> , <int> ) ; int numLegacy = randomIntBetween ( <int> , numStates ) ; List < MetaData > meta = new ArrayList < > ( ) ; for ( int i = <int> ; i < numStates ; i + + ) { meta . add ( randomMeta ( ) ) ; } Set < Path > corruptedFiles = new HashSet < > ( ) ; MetaDataStateFormat < MetaData > format = MetaStateService . globalStateFormat ( randomFrom ( XContentType . values ( ) ) , params ) ; for ( int i = <int> ; i < dirs . length ; i + + ) { dirs [ i ] = createTempDir ( ) ; Files . createDirectories ( dirs [ i ] . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ) ; for ( int j = <int> ; j < numLegacy ; j + + ) { XContentType type = format . format ( ) ; if ( randomBoolean ( ) & & ( j < numStates - <int> | | dirs . length > <int> & & i ! = <int> ) ) { Path file = dirs [ i ] . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( <str> + j ) ; Files . createFile ( file ) ; } else { try ( XContentBuilder xcontentBuilder = XContentFactory . contentBuilder ( type , Files . newOutputStream ( dirs [ i ] . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( <str> + j ) ) ) ) { xcontentBuilder . startObject ( ) ; MetaData . Builder . toXContent ( meta . get ( j ) , xcontentBuilder , params ) ; xcontentBuilder . endObject ( ) ; } } } for ( int j = numLegacy ; j < numStates ; j + + ) { format . write ( meta . get ( j ) , j , dirs [ i ] ) ; if ( randomBoolean ( ) & & ( j < numStates - <int> | | dirs . length > <int> & & i ! = <int> ) ) { Path file = dirs [ i ] . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( <str> + j + <str> ) ; corruptedFiles . add ( file ) ; MetaDataStateFormatTests . corruptFile ( file , logger ) ; } } } List < Path > dirList = Arrays . asList ( dirs ) ; Collections . shuffle ( dirList , random ( ) ) ; MetaData loadedMetaData = format . loadLatestState ( logger , dirList . toArray ( new Path [ <int> ] ) ) ; MetaData latestMetaData = meta . get ( numStates - <int> ) ; assertThat ( loadedMetaData . clusterUUID ( ) , not ( equalTo ( <str> ) ) ) ; assertThat ( loadedMetaData . clusterUUID ( ) , equalTo ( latestMetaData . clusterUUID ( ) ) ) ; ImmutableOpenMap < String , IndexMetaData > indices = loadedMetaData . indices ( ) ; assertThat ( indices . size ( ) , equalTo ( latestMetaData . indices ( ) . size ( ) ) ) ; for ( IndexMetaData original : latestMetaData ) { IndexMetaData deserialized = indices . get ( original . getIndex ( ) ) ; assertThat ( deserialized , notNullValue ( ) ) ; assertThat ( deserialized . getVersion ( ) , equalTo ( original . getVersion ( ) ) ) ; assertThat ( deserialized . getNumberOfReplicas ( ) , equalTo ( original . getNumberOfReplicas ( ) ) ) ; assertThat ( deserialized . getNumberOfShards ( ) , equalTo ( original . getNumberOfShards ( ) ) ) ; } if ( numStates > numLegacy ) { for ( int i = <int> ; i < dirs . length ; i + + ) { Path file = dirs [ i ] . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) . resolve ( <str> + ( numStates - <int> ) + <str> ) ; if ( corruptedFiles . contains ( file ) ) { continue ; } MetaDataStateFormatTests . corruptFile ( file , logger ) ; } try { format . loadLatestState ( logger , dirList . toArray ( new Path [ <int> ] ) ) ; fail ( <str> ) ; } catch ( ElasticsearchException ex ) { assertThat ( ex . getCause ( ) , instanceOf ( CorruptStateException . class ) ) ; } } } private MetaData randomMeta ( ) throws IOException { int numIndices = randomIntBetween ( <int> , <int> ) ; MetaData . Builder mdBuilder = MetaData . builder ( ) ; mdBuilder . generateClusterUuidIfNeeded ( ) ; for ( int i = <int> ; i < numIndices ; i + + ) { mdBuilder . put ( indexBuilder ( randomAsciiOfLength ( <int> ) + <str> + i ) ) ; } return mdBuilder . build ( ) ; } private IndexMetaData . Builder indexBuilder ( String index ) throws IOException { return IndexMetaData . builder ( index ) . settings ( settings ( Version . CURRENT ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , randomIntBetween ( <int> , <int> ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomIntBetween ( <int> , <int> ) ) ) ; } private class Format extends MetaDataStateFormat < DummyState > { Format ( XContentType format , String prefix ) { super ( format , prefix ) ; } @Override public void toXContent ( XContentBuilder builder , DummyState state ) throws IOException { state . toXContent ( builder , null ) ; } @Override public DummyState fromXContent ( XContentParser parser ) throws IOException { return new DummyState ( ) . parse ( parser ) ; } @Override protected Directory newDirectory ( Path dir ) throws IOException { MockDirectoryWrapper mock = new MockDirectoryWrapper ( getRandom ( ) , super . newDirectory ( dir ) ) ; closeAfterSuite ( mock ) ; return mock ; } } private static class DummyState implements ToXContent { String string ; int aInt ; long aLong ; double aDouble ; boolean aBoolean ; @Override public String toString ( ) { return <str> + <str> + string + <str> + <str> + aInt + <str> + aLong + <str> + aDouble + <str> + aBoolean + <str> ; } public DummyState ( String string , int aInt , long aLong , double aDouble , boolean aBoolean ) { this . string = string ; this . aInt = aInt ; this . aLong = aLong ; this . aDouble = aDouble ; this . aBoolean = aBoolean ; } public DummyState ( ) { } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( <str> , string ) ; builder . field ( <str> , aInt ) ; builder . field ( <str> , aLong ) ; builder . field ( <str> , aDouble ) ; builder . field ( <str> , aBoolean ) ; return builder ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; DummyState that = ( DummyState ) o ; if ( aBoolean ! = that . aBoolean ) return false ; if ( Double . compare ( that . aDouble , aDouble ) ! = <int> ) return false ; if ( aInt ! = that . aInt ) return false ; if ( aLong ! = that . aLong ) return false ; return string . equals ( that . string ) ; } @Override public int hashCode ( ) { int result ; long temp ; result = string . hashCode ( ) ; result = <int> * result + aInt ; result = <int> * result + Long . hashCode ( aLong ) ; temp = Double . doubleToLongBits ( aDouble ) ; result = <int> * result + Long . hashCode ( temp ) ; result = <int> * result + ( aBoolean ? <int> : <int> ) ; return result ; } public DummyState parse ( XContentParser parser ) throws IOException { String fieldName = null ; parser . nextToken ( ) ; while ( parser . nextToken ( ) ! = XContentParser . Token . END_OBJECT ) { XContentParser . Token token = parser . currentToken ( ) ; if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { assertTrue ( <str> . equals ( fieldName ) ) ; string = parser . text ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { switch ( fieldName ) { case <str> : aDouble = parser . doubleValue ( ) ; break ; case <str> : aInt = parser . intValue ( ) ; break ; case <str> : aLong = parser . longValue ( ) ; break ; default : fail ( <str> + token ) ; break ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { assertTrue ( <str> . equals ( fieldName ) ) ; aBoolean = parser . booleanValue ( ) ; } else { fail ( <str> + token ) ; } } return this ; } } public Path [ ] content ( String glob , Path dir ) throws IOException { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( dir , glob ) ) { return StreamSupport . stream ( stream . spliterator ( ) , false ) . toArray ( length - > new Path [ length ] ) ; } } public long addDummyFiles ( String prefix , Path . . . paths ) throws IOException { int realId = - <int> ; for ( Path path : paths ) { if ( randomBoolean ( ) ) { Path stateDir = path . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ; Files . createDirectories ( stateDir ) ; String actualPrefix = prefix ; int id = randomIntBetween ( <int> , <int> ) ; if ( randomBoolean ( ) ) { actualPrefix = <str> ; } else { realId = Math . max ( realId , id ) ; } try ( OutputStream stream = Files . newOutputStream ( stateDir . resolve ( actualPrefix + id + MetaDataStateFormat . STATE_FILE_EXTENSION ) ) ) { stream . write ( <int> ) ; } } } return realId + <int> ; } } 
