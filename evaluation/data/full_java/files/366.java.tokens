package org . apache . cassandra . db . commitlog ; import java . io . * ; import java . lang . management . ManagementFactory ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . zip . CRC32 ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . commons . lang3 . StringUtils ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . ParameterizedClass ; import org . apache . cassandra . db . * ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . io . compress . ICompressor ; import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; import org . apache . cassandra . io . util . DataOutputBufferFixed ; import org . apache . cassandra . metrics . CommitLogMetrics ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . JVMStabilityInspector ; import static org . apache . cassandra . db . commitlog . CommitLogSegment . * ; import static org . apache . cassandra . utils . FBUtilities . updateChecksum ; import static org . apache . cassandra . utils . FBUtilities . updateChecksumInt ; public class CommitLog implements CommitLogMBean { private static final Logger logger = LoggerFactory . getLogger ( CommitLog . class ) ; public static final CommitLog instance = CommitLog . construct ( ) ; private final long MAX_MUTATION_SIZE = DatabaseDescriptor . getMaxMutationSize ( ) ; public final CommitLogSegmentManager allocator ; public final CommitLogArchiver archiver ; final CommitLogMetrics metrics ; final AbstractCommitLogService executor ; final ICompressor compressor ; public ParameterizedClass compressorClass ; final public String location ; private static CommitLog construct ( ) { CommitLog log = new CommitLog ( DatabaseDescriptor . getCommitLogLocation ( ) , CommitLogArchiver . construct ( ) ) ; MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( log , new ObjectName ( <str> ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return log . start ( ) ; } @VisibleForTesting CommitLog ( String location , CommitLogArchiver archiver ) { compressorClass = DatabaseDescriptor . getCommitLogCompression ( ) ; this . location = location ; ICompressor compressor = compressorClass ! = null ? CompressionParams . createCompressor ( compressorClass ) : null ; DatabaseDescriptor . createAllDirectories ( ) ; this . compressor = compressor ; this . archiver = archiver ; metrics = new CommitLogMetrics ( ) ; executor = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch ? new BatchCommitLogService ( this ) : new PeriodicCommitLogService ( this ) ; allocator = new CommitLogSegmentManager ( this ) ; metrics . attach ( executor , allocator ) ; } CommitLog start ( ) { executor . start ( ) ; allocator . start ( ) ; return this ; } public int recover ( ) throws IOException { if ( allocator . createReserveSegments ) return <int> ; allocator . allocatingFrom ( ) ; FilenameFilter unmanagedFilesFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return CommitLogDescriptor . isValid ( name ) & & ! allocator . manages ( name ) ; } } ; for ( File file : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ) { archiver . maybeArchive ( file . getPath ( ) , file . getName ( ) ) ; archiver . maybeWaitForArchiving ( file . getName ( ) ) ; } assert archiver . archivePending . isEmpty ( ) : <str> ; archiver . maybeRestoreArchive ( ) ; File [ ] files = new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ; int replayed = <int> ; if ( files . length = = <int> ) { logger . info ( <str> ) ; } else { Arrays . sort ( files , new CommitLogSegmentFileComparator ( ) ) ; logger . info ( <str> , StringUtils . join ( files , <str> ) ) ; replayed = recover ( files ) ; logger . info ( <str> , replayed ) ; for ( File f : files ) allocator . recycleSegment ( f ) ; } allocator . enableReserveSegmentCreation ( ) ; return replayed ; } public int recover ( File . . . clogs ) throws IOException { CommitLogReplayer recovery = CommitLogReplayer . construct ( this ) ; recovery . recover ( clogs ) ; return recovery . blockForWrites ( ) ; } public void recover ( String path ) throws IOException { CommitLogReplayer recovery = CommitLogReplayer . construct ( this ) ; recovery . recover ( new File ( path ) , false ) ; recovery . blockForWrites ( ) ; } public ReplayPosition getContext ( ) { return allocator . allocatingFrom ( ) . getContext ( ) ; } public void forceRecycleAllSegments ( Iterable < UUID > droppedCfs ) { allocator . forceRecycleAll ( droppedCfs ) ; } public void forceRecycleAllSegments ( ) { allocator . forceRecycleAll ( Collections . < UUID > emptyList ( ) ) ; } public void sync ( boolean syncAllSegments ) { CommitLogSegment current = allocator . allocatingFrom ( ) ; for ( CommitLogSegment segment : allocator . getActiveSegments ( ) ) { if ( ! syncAllSegments & & segment . id > current . id ) return ; segment . sync ( ) ; } } public void requestExtraSync ( ) { executor . requestExtraSync ( ) ; } public ReplayPosition add ( Mutation mutation ) { assert mutation ! = null ; int size = ( int ) Mutation . serializer . serializedSize ( mutation , MessagingService . current_version ) ; int totalSize = size + ENTRY_OVERHEAD_SIZE ; if ( totalSize > MAX_MUTATION_SIZE ) { throw new IllegalArgumentException ( String . format ( <str> , totalSize , MAX_MUTATION_SIZE ) ) ; } Allocation alloc = allocator . allocate ( mutation , ( int ) totalSize ) ; CRC32 checksum = new CRC32 ( ) ; final ByteBuffer buffer = alloc . getBuffer ( ) ; try ( BufferedDataOutputStreamPlus dos = new DataOutputBufferFixed ( buffer ) ) { dos . writeInt ( size ) ; updateChecksumInt ( checksum , size ) ; buffer . putInt ( ( int ) checksum . getValue ( ) ) ; Mutation . serializer . serialize ( mutation , dos , MessagingService . current_version ) ; updateChecksum ( checksum , buffer , buffer . position ( ) - size , size ) ; buffer . putInt ( ( int ) checksum . getValue ( ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , alloc . getSegment ( ) . getPath ( ) ) ; } finally { alloc . markWritten ( ) ; } executor . finishWriteFor ( alloc ) ; return alloc . getReplayPosition ( ) ; } public void discardCompletedSegments ( final UUID cfId , final ReplayPosition context ) { logger . trace ( <str> , context , cfId ) ; for ( Iterator < CommitLogSegment > iter = allocator . getActiveSegments ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { CommitLogSegment segment = iter . next ( ) ; segment . markClean ( cfId , context ) ; if ( segment . isUnused ( ) ) { logger . trace ( <str> , segment ) ; allocator . recycleSegment ( segment ) ; } else { logger . trace ( <str> , ( iter . hasNext ( ) ? <str> : <str> ) , segment , segment . dirtyString ( ) ) ; } if ( segment . contains ( context ) ) break ; } } @Override public String getArchiveCommand ( ) { return archiver . archiveCommand ; } @Override public String getRestoreCommand ( ) { return archiver . restoreCommand ; } @Override public String getRestoreDirectories ( ) { return archiver . restoreDirectories ; } @Override public long getRestorePointInTime ( ) { return archiver . restorePointInTime ; } @Override public String getRestorePrecision ( ) { return archiver . precision . toString ( ) ; } public List < String > getActiveSegmentNames ( ) { List < String > segmentNames = new ArrayList < > ( ) ; for ( CommitLogSegment segment : allocator . getActiveSegments ( ) ) segmentNames . add ( segment . getName ( ) ) ; return segmentNames ; } public List < String > getArchivingSegmentNames ( ) { return new ArrayList < > ( archiver . archivePending . keySet ( ) ) ; } @Override public long getActiveContentSize ( ) { long size = <int> ; for ( CommitLogSegment segment : allocator . getActiveSegments ( ) ) size + = segment . contentSize ( ) ; return size ; } @Override public long getActiveOnDiskSize ( ) { return allocator . onDiskSize ( ) ; } @Override public Map < String , Double > getActiveSegmentCompressionRatios ( ) { Map < String , Double > segmentRatios = new TreeMap < > ( ) ; for ( CommitLogSegment segment : allocator . getActiveSegments ( ) ) segmentRatios . put ( segment . getName ( ) , <float> * segment . onDiskSize ( ) / segment . contentSize ( ) ) ; return segmentRatios ; } public void shutdownBlocking ( ) throws InterruptedException { executor . shutdown ( ) ; executor . awaitTermination ( ) ; allocator . shutdown ( ) ; allocator . awaitTermination ( ) ; } public int resetUnsafe ( boolean deleteSegments ) throws IOException { stopUnsafe ( deleteSegments ) ; return restartUnsafe ( ) ; } public void stopUnsafe ( boolean deleteSegments ) { executor . shutdown ( ) ; try { executor . awaitTermination ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } allocator . stopUnsafe ( deleteSegments ) ; } public int restartUnsafe ( ) throws IOException { allocator . start ( ) ; executor . restartUnsafe ( ) ; try { return recover ( ) ; } catch ( FSWriteError e ) { return <int> ; } } public int activeSegments ( ) { return allocator . getActiveSegments ( ) . size ( ) ; } @VisibleForTesting public static boolean handleCommitError ( String message , Throwable t ) { JVMStabilityInspector . inspectCommitLogThrowable ( t ) ; switch ( DatabaseDescriptor . getCommitFailurePolicy ( ) ) { case die : case stop : StorageService . instance . stopTransports ( ) ; case stop_commit : logger . error ( String . format ( <str> , message , DatabaseDescriptor . getCommitFailurePolicy ( ) ) , t ) ; return false ; case ignore : logger . error ( message , t ) ; return true ; default : throw new AssertionError ( DatabaseDescriptor . getCommitFailurePolicy ( ) ) ; } } } 
