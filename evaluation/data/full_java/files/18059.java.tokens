package com . badlogic . gdx . graphics . g3d . particles . influencers ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . FloatChannel ; import com . badlogic . gdx . graphics . g3d . particles . ParticleChannels ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonValue ; public abstract class RegionInfluencer extends Influencer { public static class Single extends RegionInfluencer { public Single ( ) { } public Single ( Single regionInfluencer ) { super ( regionInfluencer ) ; } public Single ( TextureRegion textureRegion ) { super ( textureRegion ) ; } public Single ( Texture texture ) { super ( texture ) ; } @Override public void init ( ) { AspectTextureRegion region = regions . items [ <int> ] ; for ( int i = <int> , c = controller . emitter . maxParticleCount * regionChannel . strideSize ; i < c ; i + = regionChannel . strideSize ) { regionChannel . data [ i + ParticleChannels . UOffset ] = region . u ; regionChannel . data [ i + ParticleChannels . VOffset ] = region . v ; regionChannel . data [ i + ParticleChannels . U2Offset ] = region . u2 ; regionChannel . data [ i + ParticleChannels . V2Offset ] = region . v2 ; regionChannel . data [ i + ParticleChannels . HalfWidthOffset ] = <float> ; regionChannel . data [ i + ParticleChannels . HalfHeightOffset ] = region . halfInvAspectRatio ; } } @Override public Single copy ( ) { return new Single ( this ) ; } } public static class Random extends RegionInfluencer { public Random ( ) { } public Random ( Random regionInfluencer ) { super ( regionInfluencer ) ; } public Random ( TextureRegion textureRegion ) { super ( textureRegion ) ; } public Random ( Texture texture ) { super ( texture ) ; } @Override public void activateParticles ( int startIndex , int count ) { for ( int i = startIndex * regionChannel . strideSize , c = i + count * regionChannel . strideSize ; i < c ; i + = regionChannel . strideSize ) { AspectTextureRegion region = regions . random ( ) ; regionChannel . data [ i + ParticleChannels . UOffset ] = region . u ; regionChannel . data [ i + ParticleChannels . VOffset ] = region . v ; regionChannel . data [ i + ParticleChannels . U2Offset ] = region . u2 ; regionChannel . data [ i + ParticleChannels . V2Offset ] = region . v2 ; regionChannel . data [ i + ParticleChannels . HalfWidthOffset ] = <float> ; regionChannel . data [ i + ParticleChannels . HalfHeightOffset ] = region . halfInvAspectRatio ; } } @Override public Random copy ( ) { return new Random ( this ) ; } } public static class Animated extends RegionInfluencer { FloatChannel lifeChannel ; public Animated ( ) { } public Animated ( Animated regionInfluencer ) { super ( regionInfluencer ) ; } public Animated ( TextureRegion textureRegion ) { super ( textureRegion ) ; } public Animated ( Texture texture ) { super ( texture ) ; } @Override public void allocateChannels ( ) { super . allocateChannels ( ) ; lifeChannel = controller . particles . addChannel ( ParticleChannels . Life ) ; } @Override public void update ( ) { for ( int i = <int> , l = ParticleChannels . LifePercentOffset , c = controller . particles . size * regionChannel . strideSize ; i < c ; i + = regionChannel . strideSize , l + = lifeChannel . strideSize ) { AspectTextureRegion region = regions . get ( ( int ) ( lifeChannel . data [ l ] * ( regions . size - <int> ) ) ) ; regionChannel . data [ i + ParticleChannels . UOffset ] = region . u ; regionChannel . data [ i + ParticleChannels . VOffset ] = region . v ; regionChannel . data [ i + ParticleChannels . U2Offset ] = region . u2 ; regionChannel . data [ i + ParticleChannels . V2Offset ] = region . v2 ; regionChannel . data [ i + ParticleChannels . HalfWidthOffset ] = <float> ; regionChannel . data [ i + ParticleChannels . HalfHeightOffset ] = region . halfInvAspectRatio ; } } @Override public Animated copy ( ) { return new Animated ( this ) ; } } public static class AspectTextureRegion { public float u , v , u2 , v2 ; public float halfInvAspectRatio ; public AspectTextureRegion ( ) { } public AspectTextureRegion ( AspectTextureRegion aspectTextureRegion ) { set ( aspectTextureRegion ) ; } public AspectTextureRegion ( TextureRegion region ) { set ( region ) ; } public void set ( TextureRegion region ) { this . u = region . getU ( ) ; this . v = region . getV ( ) ; this . u2 = region . getU2 ( ) ; this . v2 = region . getV2 ( ) ; this . halfInvAspectRatio = <float> * ( ( float ) region . getRegionHeight ( ) / region . getRegionWidth ( ) ) ; } public void set ( AspectTextureRegion aspectTextureRegion ) { u = aspectTextureRegion . u ; v = aspectTextureRegion . v ; u2 = aspectTextureRegion . u2 ; v2 = aspectTextureRegion . v2 ; halfInvAspectRatio = aspectTextureRegion . halfInvAspectRatio ; } } public Array < AspectTextureRegion > regions ; FloatChannel regionChannel ; public RegionInfluencer ( int regionsCount ) { this . regions = new Array < AspectTextureRegion > ( false , regionsCount , AspectTextureRegion . class ) ; } public RegionInfluencer ( ) { this ( <int> ) ; AspectTextureRegion aspectRegion = new AspectTextureRegion ( ) ; aspectRegion . u = aspectRegion . v = <int> ; aspectRegion . u2 = aspectRegion . v2 = <int> ; aspectRegion . halfInvAspectRatio = <float> ; regions . add ( aspectRegion ) ; } public RegionInfluencer ( TextureRegion . . . regions ) { this . regions = new Array < AspectTextureRegion > ( false , regions . length , AspectTextureRegion . class ) ; add ( regions ) ; } public RegionInfluencer ( Texture texture ) { this ( new TextureRegion ( texture ) ) ; } public RegionInfluencer ( RegionInfluencer regionInfluencer ) { this ( regionInfluencer . regions . size ) ; regions . ensureCapacity ( regionInfluencer . regions . size ) ; for ( int i = <int> ; i < regionInfluencer . regions . size ; + + i ) { regions . add ( new AspectTextureRegion ( ( AspectTextureRegion ) regionInfluencer . regions . get ( i ) ) ) ; } } public void add ( TextureRegion . . . regions ) { this . regions . ensureCapacity ( regions . length ) ; for ( TextureRegion region : regions ) { this . regions . add ( new AspectTextureRegion ( region ) ) ; } } public void clear ( ) { regions . clear ( ) ; } @Override public void allocateChannels ( ) { regionChannel = controller . particles . addChannel ( ParticleChannels . TextureRegion ) ; } @Override public void write ( Json json ) { json . writeValue ( <str> , regions , Array . class , AspectTextureRegion . class ) ; } @Override public void read ( Json json , JsonValue jsonData ) { regions . clear ( ) ; regions . addAll ( json . readValue ( <str> , Array . class , AspectTextureRegion . class , jsonData ) ) ; } } 
