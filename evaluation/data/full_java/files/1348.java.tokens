package org . apache . cassandra . cql3 ; import com . datastax . driver . core . BatchStatement ; import com . datastax . driver . core . Cluster ; import com . datastax . driver . core . PreparedStatement ; import com . datastax . driver . core . Session ; import com . datastax . driver . core . exceptions . InvalidQueryException ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . service . EmbeddedCassandraService ; import org . junit . BeforeClass ; import org . junit . Test ; import java . io . IOException ; public class BatchTests { private static EmbeddedCassandraService cassandra ; private static Cluster cluster ; private static Session session ; private static PreparedStatement counter ; private static PreparedStatement noncounter ; @BeforeClass ( ) public static void setup ( ) throws ConfigurationException , IOException { cassandra = new EmbeddedCassandraService ( ) ; cassandra . start ( ) ; cluster = Cluster . builder ( ) . addContactPoint ( <str> ) . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; session = cluster . connect ( ) ; session . execute ( <str> ) ; session . execute ( <str> ) ; session . execute ( <str> + <str> + <str> + <str> ) ; session . execute ( <str> + <str> + <str> + <str> ) ; noncounter = session . prepare ( <str> ) ; counter = session . prepare ( <str> ) ; } @Test ( expected = InvalidQueryException . class ) public void testMixedInCounterBatch ( ) { sendBatch ( BatchStatement . Type . COUNTER , true , true ) ; } @Test ( expected = InvalidQueryException . class ) public void testMixedInLoggedBatch ( ) { sendBatch ( BatchStatement . Type . LOGGED , true , true ) ; } @Test ( expected = InvalidQueryException . class ) public void testMixedInUnLoggedBatch ( ) { sendBatch ( BatchStatement . Type . UNLOGGED , true , true ) ; } @Test ( expected = InvalidQueryException . class ) public void testNonCounterInCounterBatch ( ) { sendBatch ( BatchStatement . Type . COUNTER , false , true ) ; } @Test public void testNonCounterInLoggedBatch ( ) { sendBatch ( BatchStatement . Type . LOGGED , false , true ) ; } @Test public void testNonCounterInUnLoggedBatch ( ) { sendBatch ( BatchStatement . Type . UNLOGGED , false , true ) ; } @Test public void testCounterInCounterBatch ( ) { sendBatch ( BatchStatement . Type . COUNTER , true , false ) ; } @Test public void testCounterInUnLoggedBatch ( ) { sendBatch ( BatchStatement . Type . UNLOGGED , true , false ) ; } @Test ( expected = InvalidQueryException . class ) public void testCounterInLoggedBatch ( ) { sendBatch ( BatchStatement . Type . LOGGED , true , false ) ; } @Test ( expected = InvalidQueryException . class ) public void testOversizedBatch ( ) { int SIZE_FOR_FAILURE = <int> ; BatchStatement b = new BatchStatement ( BatchStatement . Type . UNLOGGED ) ; for ( int i = <int> ; i < SIZE_FOR_FAILURE ; i + + ) { b . add ( noncounter . bind ( i , <str> ) ) ; } session . execute ( b ) ; } public void sendBatch ( BatchStatement . Type type , boolean addCounter , boolean addNonCounter ) { assert addCounter | | addNonCounter ; BatchStatement b = new BatchStatement ( type ) ; for ( int i = <int> ; i < <int> ; i + + ) { if ( addNonCounter ) b . add ( noncounter . bind ( i , <str> ) ) ; if ( addCounter ) b . add ( counter . bind ( ( long ) i , i ) ) ; } session . execute ( b ) ; } } 
