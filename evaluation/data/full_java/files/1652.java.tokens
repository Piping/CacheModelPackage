package org . apache . cassandra . utils ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . BufferDecoratedKey ; import org . apache . cassandra . db . CachedHashDecoratedKey ; import org . apache . cassandra . dht . Murmur3Partitioner . LongToken ; import org . apache . cassandra . utils . IFilter . FilterKey ; public class FilterTestHelper { static final double MAX_FAILURE_RATE = <float> ; public static final BloomCalculations . BloomSpecification spec = BloomCalculations . computeBloomSpec ( <int> , MAX_FAILURE_RATE ) ; static final int ELEMENTS = <int> ; static final FilterKey bytes ( String s ) { return new BufferDecoratedKey ( new LongToken ( <int> L ) , ByteBufferUtil . bytes ( s ) ) ; } static final FilterKey wrap ( ByteBuffer buf ) { return new BufferDecoratedKey ( new LongToken ( <int> L ) , buf ) ; } static final FilterKey wrapCached ( ByteBuffer buf ) { return new CachedHashDecoratedKey ( new LongToken ( <int> L ) , buf ) ; } static final ResetableIterator < ByteBuffer > intKeys ( ) { return new KeyGenerator . IntGenerator ( ELEMENTS ) ; } static final ResetableIterator < ByteBuffer > randomKeys ( ) { return new KeyGenerator . RandomStringGenerator ( <int> , ELEMENTS ) ; } static final ResetableIterator < ByteBuffer > randomKeys2 ( ) { return new KeyGenerator . RandomStringGenerator ( <int> , ELEMENTS ) ; } public static double testFalsePositives ( IFilter f , ResetableIterator < ByteBuffer > keys , ResetableIterator < ByteBuffer > otherkeys ) { assert keys . size ( ) = = otherkeys . size ( ) ; while ( keys . hasNext ( ) ) { f . add ( wrap ( keys . next ( ) ) ) ; } int fp = <int> ; while ( otherkeys . hasNext ( ) ) { if ( f . isPresent ( wrap ( otherkeys . next ( ) ) ) ) { fp + + ; } } double fp_ratio = fp / ( keys . size ( ) * BloomCalculations . probs [ spec . bucketsPerElement ] [ spec . K ] ) ; assert fp_ratio < <float> : fp_ratio ; return fp_ratio ; } public void testTrue ( ) { assert true ; } } 
