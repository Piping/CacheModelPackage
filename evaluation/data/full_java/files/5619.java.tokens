package org . elasticsearch . cluster . routing . allocation . command ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingExplanations ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class AllocationCommands { private static Map < String , AllocationCommand . Factory > factories = new HashMap < > ( ) ; public static void registerFactory ( String type , AllocationCommand . Factory factory ) { factories . put ( type , factory ) ; } @SuppressWarnings ( <str> ) @Nullable public static < T extends AllocationCommand > AllocationCommand . Factory < T > lookupFactory ( String name ) { return factories . get ( name ) ; } @SuppressWarnings ( <str> ) public static < T extends AllocationCommand > AllocationCommand . Factory < T > lookupFactorySafe ( String name ) { AllocationCommand . Factory < T > factory = factories . get ( name ) ; if ( factory = = null ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } return factory ; } static { registerFactory ( AllocateAllocationCommand . NAME , new AllocateAllocationCommand . Factory ( ) ) ; registerFactory ( CancelAllocationCommand . NAME , new CancelAllocationCommand . Factory ( ) ) ; registerFactory ( MoveAllocationCommand . NAME , new MoveAllocationCommand . Factory ( ) ) ; } private final List < AllocationCommand > commands = new ArrayList < > ( ) ; public AllocationCommands ( AllocationCommand . . . commands ) { if ( commands ! = null ) { this . commands . addAll ( Arrays . asList ( commands ) ) ; } } public AllocationCommands add ( AllocationCommand . . . commands ) { if ( commands ! = null ) { this . commands . addAll ( Arrays . asList ( commands ) ) ; } return this ; } public List < AllocationCommand > commands ( ) { return this . commands ; } public RoutingExplanations execute ( RoutingAllocation allocation , boolean explain ) { RoutingExplanations explanations = new RoutingExplanations ( ) ; for ( AllocationCommand command : commands ) { explanations . add ( command . execute ( allocation , explain ) ) ; } return explanations ; } public static AllocationCommands readFrom ( StreamInput in ) throws IOException { AllocationCommands commands = new AllocationCommands ( ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { String name = in . readString ( ) ; commands . add ( lookupFactorySafe ( name ) . readFrom ( in ) ) ; } return commands ; } public static void writeTo ( AllocationCommands commands , StreamOutput out ) throws IOException { out . writeVInt ( commands . commands . size ( ) ) ; for ( AllocationCommand command : commands . commands ) { out . writeString ( command . name ( ) ) ; lookupFactorySafe ( command . name ( ) ) . writeTo ( command , out ) ; } } public static AllocationCommands fromXContent ( XContentParser parser ) throws IOException { AllocationCommands commands = new AllocationCommands ( ) ; XContentParser . Token token = parser . currentToken ( ) ; if ( token = = null ) { throw new ElasticsearchParseException ( <str> ) ; } if ( token = = XContentParser . Token . FIELD_NAME ) { if ( ! parser . currentName ( ) . equals ( <str> ) ) { throw new ElasticsearchParseException ( <str> , parser . currentName ( ) ) ; } if ( ! parser . currentName ( ) . equals ( <str> ) ) { throw new ElasticsearchParseException ( <str> , parser . currentName ( ) ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_ARRAY ) { throw new ElasticsearchParseException ( <str> ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { } else { throw new ElasticsearchParseException ( <str> , token ) ; } while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . START_OBJECT ) { token = parser . nextToken ( ) ; String commandName = parser . currentName ( ) ; token = parser . nextToken ( ) ; commands . add ( AllocationCommands . lookupFactorySafe ( commandName ) . fromXContent ( parser ) ) ; if ( parser . nextToken ( ) ! = XContentParser . Token . END_OBJECT ) { throw new ElasticsearchParseException ( <str> , token ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } return commands ; } public static void toXContent ( AllocationCommands commands , XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startArray ( <str> ) ; for ( AllocationCommand command : commands . commands ) { builder . startObject ( ) ; builder . field ( command . name ( ) ) ; AllocationCommands . lookupFactorySafe ( command . name ( ) ) . toXContent ( command , builder , params , null ) ; builder . endObject ( ) ; } builder . endArray ( ) ; } } 
