package org . gradle . execution ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import org . gradle . api . Nullable ; import org . gradle . api . Project ; import org . gradle . api . ProjectConfigurationException ; import org . gradle . api . Task ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . internal . tasks . TaskContainerInternal ; import org . gradle . api . tasks . TaskContainer ; import org . gradle . model . internal . core . ModelNode ; import org . gradle . model . internal . core . ModelPath ; import org . gradle . model . internal . registry . ModelRegistry ; import java . util . Collection ; import java . util . Map ; import java . util . Set ; import static org . gradle . api . internal . tasks . TaskContainerInternal . TASK_MODEL_TYPE ; public class TaskNameResolver { public boolean tryFindUnqualifiedTaskCheaply ( String name , ProjectInternal project ) { for ( Project project1 : project . getAllprojects ( ) ) { if ( project1 . getTasks ( ) . getNames ( ) . contains ( name ) ) { return true ; } } return false ; } @Nullable public TaskSelectionResult selectWithName ( final String taskName , final ProjectInternal project , boolean includeSubProjects ) { if ( includeSubProjects ) { Set < Task > tasks = Sets . newLinkedHashSet ( ) ; new MultiProjectTaskSelectionResult ( taskName , project ) . collectTasks ( tasks ) ; if ( ! tasks . isEmpty ( ) ) { return new FixedTaskSelectionResult ( tasks ) ; } } else { if ( hasTask ( taskName , project ) ) { return new TaskSelectionResult ( ) { @Override public void collectTasks ( Collection < ? super Task > tasks ) { tasks . add ( getExistingTask ( project , taskName ) ) ; } } ; } } return null ; } public Map < String , TaskSelectionResult > selectAll ( ProjectInternal project , boolean includeSubProjects ) { Map < String , TaskSelectionResult > selected = Maps . newLinkedHashMap ( ) ; if ( includeSubProjects ) { Set < String > taskNames = Sets . newLinkedHashSet ( ) ; collectTaskNames ( project , taskNames ) ; for ( String taskName : taskNames ) { selected . put ( taskName , new MultiProjectTaskSelectionResult ( taskName , project ) ) ; } } else { for ( String taskName : getTaskNames ( project ) ) { selected . put ( taskName , new SingleProjectTaskSelectionResult ( taskName , project . getTasks ( ) ) ) ; } } return selected ; } private static ModelNode selfClose ( ModelRegistry modelRegistry , ModelPath modelPath ) { return modelRegistry . atStateOrLater ( modelPath , ModelNode . State . SelfClosed ) ; } private static ModelNode selfClosedTasksNode ( ProjectInternal project ) { ModelRegistry modelRegistry = project . getModelRegistry ( ) ; ModelNode modelNode ; try { project . fireDeferredConfiguration ( ) ; modelNode = selfClose ( modelRegistry , TaskContainerInternal . MODEL_PATH ) ; } catch ( Throwable e ) { throw new ProjectConfigurationException ( String . format ( <str> , project ) , e ) ; } return modelNode ; } private static Set < String > getTaskNames ( ProjectInternal project ) { return selfClosedTasksNode ( project ) . getLinkNames ( TASK_MODEL_TYPE ) ; } private static boolean hasTask ( String taskName , ProjectInternal project ) { return selfClosedTasksNode ( project ) . hasLink ( taskName , TASK_MODEL_TYPE ) | | project . getTasks ( ) . findByName ( taskName ) ! = null ; } private static TaskInternal getExistingTask ( ProjectInternal project , String taskName ) { ModelRegistry modelRegistry = project . getModelRegistry ( ) ; ModelPath path = TaskContainerInternal . MODEL_PATH . child ( taskName ) ; try { if ( modelRegistry . state ( path ) = = null ) { return ( TaskInternal ) project . getTasks ( ) . getByName ( taskName ) ; } else { return ( TaskInternal ) modelRegistry . realize ( path , TASK_MODEL_TYPE ) ; } } catch ( Throwable e ) { throw new ProjectConfigurationException ( String . format ( <str> , project ) , e ) ; } } private void collectTaskNames ( ProjectInternal project , Set < String > result ) { result . addAll ( getTaskNames ( project ) ) ; for ( Project subProject : project . getChildProjects ( ) . values ( ) ) { collectTaskNames ( ( ProjectInternal ) subProject , result ) ; } } private static class FixedTaskSelectionResult implements TaskSelectionResult { private final Collection < Task > tasks ; FixedTaskSelectionResult ( Collection < Task > tasks ) { this . tasks = tasks ; } public void collectTasks ( Collection < ? super Task > tasks ) { tasks . addAll ( this . tasks ) ; } } private static class SingleProjectTaskSelectionResult implements TaskSelectionResult { private final TaskContainer taskContainer ; private final String taskName ; SingleProjectTaskSelectionResult ( String taskName , TaskContainer tasksContainer ) { this . taskContainer = tasksContainer ; this . taskName = taskName ; } public void collectTasks ( Collection < ? super Task > tasks ) { tasks . add ( taskContainer . getByName ( taskName ) ) ; } } private static class MultiProjectTaskSelectionResult implements TaskSelectionResult { private final ProjectInternal project ; private final String taskName ; MultiProjectTaskSelectionResult ( String taskName , ProjectInternal project ) { this . project = project ; this . taskName = taskName ; } public void collectTasks ( Collection < ? super Task > tasks ) { collect ( project , tasks ) ; } private void collect ( ProjectInternal project , Collection < ? super Task > tasks ) { if ( hasTask ( taskName , project ) ) { TaskInternal task = getExistingTask ( project , taskName ) ; tasks . add ( task ) ; if ( task . getImpliesSubProjects ( ) ) { return ; } } for ( Project subProject : project . getChildProjects ( ) . values ( ) ) { collect ( ( ProjectInternal ) subProject , tasks ) ; } } } } 
