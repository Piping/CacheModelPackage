package org . apache . cassandra . config ; import java . io . File ; import java . io . IOException ; import java . net . * ; import java . nio . file . FileStore ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . ImmutableSet ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . Config . CommitLogSync ; import org . apache . cassandra . config . Config . RequestSchedulerId ; import org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; import org . apache . cassandra . config . EncryptionOptions . ServerEncryptionOptions ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . locator . * ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . scheduler . IRequestScheduler ; import org . apache . cassandra . scheduler . NoScheduler ; import org . apache . cassandra . security . EncryptionContext ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . thrift . ThriftServer ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . memory . * ; public class DatabaseDescriptor { private static final Logger logger = LoggerFactory . getLogger ( DatabaseDescriptor . class ) ; private static final int MAX_NUM_TOKENS = <int> ; private static IEndpointSnitch snitch ; private static InetAddress listenAddress ; private static InetAddress broadcastAddress ; private static InetAddress rpcAddress ; private static InetAddress broadcastRpcAddress ; private static SeedProvider seedProvider ; private static IInternodeAuthenticator internodeAuthenticator ; private static IPartitioner partitioner ; private static String paritionerName ; private static Config . DiskAccessMode indexAccessMode ; private static Config conf ; private static SSTableFormat . Type sstable_format = SSTableFormat . Type . BIG ; private static IAuthenticator authenticator = new AllowAllAuthenticator ( ) ; private static IAuthorizer authorizer = new AllowAllAuthorizer ( ) ; private static IRoleManager roleManager ; private static IRequestScheduler requestScheduler ; private static RequestSchedulerId requestSchedulerId ; private static RequestSchedulerOptions requestSchedulerOptions ; private static long keyCacheSizeInMB ; private static long counterCacheSizeInMB ; private static long indexSummaryCapacityInMB ; private static String localDC ; private static Comparator < InetAddress > localComparator ; private static EncryptionContext encryptionContext ; public static void forceStaticInitialization ( ) { } static { try { if ( Config . isClientMode ( ) ) { conf = new Config ( ) ; } else { applyConfig ( loadConfig ( ) ) ; } } catch ( Exception e ) { throw new ExceptionInInitializerError ( e ) ; } } @VisibleForTesting public static Config loadConfig ( ) throws ConfigurationException { String loaderClass = System . getProperty ( <str> ) ; ConfigurationLoader loader = loaderClass = = null ? new YamlConfigurationLoader ( ) : FBUtilities . < ConfigurationLoader > construct ( loaderClass , <str> ) ; return loader . loadConfig ( ) ; } private static InetAddress getNetworkInterfaceAddress ( String intf , String configName , boolean preferIPv6 ) throws ConfigurationException { try { NetworkInterface ni = NetworkInterface . getByName ( intf ) ; if ( ni = = null ) throw new ConfigurationException ( <str> + configName + <str> + intf + <str> , false ) ; Enumeration < InetAddress > addrs = ni . getInetAddresses ( ) ; if ( ! addrs . hasMoreElements ( ) ) throw new ConfigurationException ( <str> + configName + <str> + intf + <str> , false ) ; InetAddress retval = null ; while ( addrs . hasMoreElements ( ) ) { InetAddress temp = addrs . nextElement ( ) ; if ( preferIPv6 & & temp instanceof Inet6Address ) return temp ; if ( ! preferIPv6 & & temp instanceof Inet4Address ) return temp ; if ( retval = = null ) retval = temp ; } return retval ; } catch ( SocketException e ) { throw new ConfigurationException ( <str> + configName + <str> + intf + <str> , e ) ; } } @VisibleForTesting static void applyAddressConfig ( Config config ) throws ConfigurationException { listenAddress = null ; rpcAddress = null ; broadcastAddress = null ; broadcastRpcAddress = null ; if ( config . listen_address ! = null & & config . listen_interface ! = null ) { throw new ConfigurationException ( <str> , false ) ; } else if ( config . listen_address ! = null ) { try { listenAddress = InetAddress . getByName ( config . listen_address ) ; } catch ( UnknownHostException e ) { throw new ConfigurationException ( <str> + config . listen_address + <str> , false ) ; } if ( listenAddress . isAnyLocalAddress ( ) ) throw new ConfigurationException ( <str> + config . listen_address + <str> , false ) ; } else if ( config . listen_interface ! = null ) { listenAddress = getNetworkInterfaceAddress ( config . listen_interface , <str> , config . listen_interface_prefer_ipv6 ) ; } if ( config . broadcast_address ! = null ) { try { broadcastAddress = InetAddress . getByName ( config . broadcast_address ) ; } catch ( UnknownHostException e ) { throw new ConfigurationException ( <str> + config . broadcast_address + <str> , false ) ; } if ( broadcastAddress . isAnyLocalAddress ( ) ) throw new ConfigurationException ( <str> + config . broadcast_address + <str> , false ) ; } if ( config . rpc_address ! = null & & config . rpc_interface ! = null ) { throw new ConfigurationException ( <str> , false ) ; } else if ( config . rpc_address ! = null ) { try { rpcAddress = InetAddress . getByName ( config . rpc_address ) ; } catch ( UnknownHostException e ) { throw new ConfigurationException ( <str> + config . rpc_address , false ) ; } } else if ( config . rpc_interface ! = null ) { rpcAddress = getNetworkInterfaceAddress ( config . rpc_interface , <str> , config . rpc_interface_prefer_ipv6 ) ; } else { rpcAddress = FBUtilities . getLocalAddress ( ) ; } if ( config . broadcast_rpc_address ! = null ) { try { broadcastRpcAddress = InetAddress . getByName ( config . broadcast_rpc_address ) ; } catch ( UnknownHostException e ) { throw new ConfigurationException ( <str> + config . broadcast_rpc_address + <str> , false ) ; } if ( broadcastRpcAddress . isAnyLocalAddress ( ) ) throw new ConfigurationException ( <str> + config . broadcast_rpc_address + <str> , false ) ; } else { if ( rpcAddress . isAnyLocalAddress ( ) ) throw new ConfigurationException ( <str> + config . rpc_address + <str> + <str> + config . rpc_address , false ) ; broadcastRpcAddress = rpcAddress ; } } public static void applyConfig ( Config config ) throws ConfigurationException { conf = config ; if ( conf . commitlog_sync = = null ) { throw new ConfigurationException ( <str> , false ) ; } if ( conf . commitlog_sync = = Config . CommitLogSync . batch ) { if ( conf . commitlog_sync_batch_window_in_ms = = null ) { throw new ConfigurationException ( <str> , false ) ; } else if ( conf . commitlog_sync_period_in_ms ! = null ) { throw new ConfigurationException ( <str> , false ) ; } logger . debug ( <str> , conf . commitlog_sync_batch_window_in_ms ) ; } else { if ( conf . commitlog_sync_period_in_ms = = null ) { throw new ConfigurationException ( <str> , false ) ; } else if ( conf . commitlog_sync_batch_window_in_ms ! = null ) { throw new ConfigurationException ( <str> , false ) ; } logger . debug ( <str> , conf . commitlog_sync_period_in_ms ) ; } if ( conf . disk_access_mode = = Config . DiskAccessMode . auto ) { conf . disk_access_mode = hasLargeAddressSpace ( ) ? Config . DiskAccessMode . mmap : Config . DiskAccessMode . standard ; indexAccessMode = conf . disk_access_mode ; logger . info ( <str> , conf . disk_access_mode , indexAccessMode ) ; } else if ( conf . disk_access_mode = = Config . DiskAccessMode . mmap_index_only ) { conf . disk_access_mode = Config . DiskAccessMode . standard ; indexAccessMode = Config . DiskAccessMode . mmap ; logger . info ( <str> , conf . disk_access_mode , indexAccessMode ) ; } else { indexAccessMode = conf . disk_access_mode ; logger . info ( <str> , conf . disk_access_mode , indexAccessMode ) ; } if ( conf . authenticator ! = null ) authenticator = FBUtilities . newAuthenticator ( conf . authenticator ) ; if ( conf . authorizer ! = null ) authorizer = FBUtilities . newAuthorizer ( conf . authorizer ) ; if ( authenticator instanceof AllowAllAuthenticator & & ! ( authorizer instanceof AllowAllAuthorizer ) ) throw new ConfigurationException ( <str> + conf . authorizer , false ) ; if ( conf . role_manager ! = null ) roleManager = FBUtilities . newRoleManager ( conf . role_manager ) ; else roleManager = new CassandraRoleManager ( ) ; if ( authenticator instanceof PasswordAuthenticator & & ! ( roleManager instanceof CassandraRoleManager ) ) throw new ConfigurationException ( <str> , false ) ; if ( conf . internode_authenticator ! = null ) internodeAuthenticator = FBUtilities . construct ( conf . internode_authenticator , <str> ) ; else internodeAuthenticator = new AllowAllInternodeAuthenticator ( ) ; authenticator . validateConfiguration ( ) ; authorizer . validateConfiguration ( ) ; roleManager . validateConfiguration ( ) ; internodeAuthenticator . validateConfiguration ( ) ; if ( conf . partitioner = = null ) { throw new ConfigurationException ( <str> , false ) ; } try { partitioner = FBUtilities . newPartitioner ( System . getProperty ( <str> , conf . partitioner ) ) ; } catch ( Exception e ) { throw new ConfigurationException ( <str> + conf . partitioner , false ) ; } paritionerName = partitioner . getClass ( ) . getCanonicalName ( ) ; if ( conf . gc_warn_threshold_in_ms < <int> ) { throw new ConfigurationException ( <str> ) ; } if ( conf . max_hint_window_in_ms = = null ) { throw new ConfigurationException ( <str> , false ) ; } if ( conf . phi_convict_threshold < <int> | | conf . phi_convict_threshold > <int> ) { throw new ConfigurationException ( <str> + conf . phi_convict_threshold , false ) ; } if ( conf . concurrent_reads ! = null & & conf . concurrent_reads < <int> ) { throw new ConfigurationException ( <str> + conf . concurrent_reads , false ) ; } if ( conf . concurrent_writes ! = null & & conf . concurrent_writes < <int> ) { throw new ConfigurationException ( <str> + conf . concurrent_writes , false ) ; } if ( conf . concurrent_counter_writes ! = null & & conf . concurrent_counter_writes < <int> ) throw new ConfigurationException ( <str> + conf . concurrent_counter_writes , false ) ; if ( conf . concurrent_replicates ! = null ) logger . warn ( <str> ) ; if ( conf . file_cache_size_in_mb = = null ) conf . file_cache_size_in_mb = Math . min ( <int> , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( <int> * <int> ) ) ) ; if ( conf . memtable_offheap_space_in_mb = = null ) conf . memtable_offheap_space_in_mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( <int> * <int> ) ) ; if ( conf . memtable_offheap_space_in_mb < <int> ) throw new ConfigurationException ( <str> + conf . memtable_offheap_space_in_mb , false ) ; if ( conf . memtable_heap_space_in_mb = = null ) conf . memtable_heap_space_in_mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( <int> * <int> ) ) ; if ( conf . memtable_heap_space_in_mb < = <int> ) throw new ConfigurationException ( <str> + conf . memtable_heap_space_in_mb , false ) ; logger . info ( <str> , conf . memtable_heap_space_in_mb ) ; if ( conf . memtable_offheap_space_in_mb = = <int> ) logger . info ( <str> ) ; else logger . info ( <str> , conf . memtable_offheap_space_in_mb ) ; applyAddressConfig ( config ) ; if ( conf . thrift_framed_transport_size_in_mb < = <int> ) throw new ConfigurationException ( <str> + conf . thrift_framed_transport_size_in_mb , false ) ; if ( conf . native_transport_max_frame_size_in_mb < = <int> ) throw new ConfigurationException ( <str> + conf . native_transport_max_frame_size_in_mb , false ) ; if ( ThriftServer . HSHA . equals ( conf . rpc_server_type ) & & conf . rpc_max_threads = = Integer . MAX_VALUE ) throw new ConfigurationException ( <str> + <str> + <str> , false ) ; if ( ThriftServer . HSHA . equals ( conf . rpc_server_type ) & & conf . rpc_max_threads > ( FBUtilities . getAvailableProcessors ( ) * <int> + <int> ) ) logger . warn ( <str> , conf . rpc_max_threads ) ; if ( conf . endpoint_snitch = = null ) { throw new ConfigurationException ( <str> , false ) ; } snitch = createEndpointSnitch ( conf . endpoint_snitch ) ; EndpointSnitchInfo . create ( ) ; localDC = snitch . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ; localComparator = new Comparator < InetAddress > ( ) { public int compare ( InetAddress endpoint1 , InetAddress endpoint2 ) { boolean local1 = localDC . equals ( snitch . getDatacenter ( endpoint1 ) ) ; boolean local2 = localDC . equals ( snitch . getDatacenter ( endpoint2 ) ) ; if ( local1 & & ! local2 ) return - <int> ; if ( local2 & & ! local1 ) return <int> ; return <int> ; } } ; requestSchedulerOptions = conf . request_scheduler_options ; if ( conf . request_scheduler ! = null ) { try { if ( requestSchedulerOptions = = null ) { requestSchedulerOptions = new RequestSchedulerOptions ( ) ; } Class < ? > cls = Class . forName ( conf . request_scheduler ) ; requestScheduler = ( IRequestScheduler ) cls . getConstructor ( RequestSchedulerOptions . class ) . newInstance ( requestSchedulerOptions ) ; } catch ( ClassNotFoundException e ) { throw new ConfigurationException ( <str> + conf . request_scheduler , false ) ; } catch ( Exception e ) { throw new ConfigurationException ( <str> , e ) ; } } else { requestScheduler = new NoScheduler ( ) ; } if ( conf . request_scheduler_id = = RequestSchedulerId . keyspace ) { requestSchedulerId = conf . request_scheduler_id ; } else { requestSchedulerId = RequestSchedulerId . keyspace ; } if ( conf . commitlog_directory = = null ) { conf . commitlog_directory = System . getProperty ( <str> , null ) ; if ( conf . commitlog_directory = = null ) throw new ConfigurationException ( <str> , false ) ; conf . commitlog_directory + = File . separator + <str> ; } if ( conf . hints_directory = = null ) { conf . hints_directory = System . getProperty ( <str> , null ) ; if ( conf . hints_directory = = null ) throw new ConfigurationException ( <str> , false ) ; conf . hints_directory + = File . separator + <str> ; } if ( conf . commitlog_total_space_in_mb = = null ) { int preferredSize = <int> ; int minSize = <int> ; try { minSize = Ints . checkedCast ( ( guessFileStore ( conf . commitlog_directory ) . getTotalSpace ( ) / <int> ) / <int> ) ; } catch ( IOException e ) { logger . debug ( <str> , e ) ; throw new ConfigurationException ( String . format ( <str> , conf . commitlog_directory ) , e ) ; } if ( minSize < preferredSize ) { logger . warn ( <str> , conf . commitlog_directory , minSize ) ; conf . commitlog_total_space_in_mb = minSize ; } else { conf . commitlog_total_space_in_mb = preferredSize ; } } if ( conf . saved_caches_directory = = null ) { conf . saved_caches_directory = System . getProperty ( <str> , null ) ; if ( conf . saved_caches_directory = = null ) throw new ConfigurationException ( <str> , false ) ; conf . saved_caches_directory + = File . separator + <str> ; } if ( conf . data_file_directories = = null | | conf . data_file_directories . length = = <int> ) { String defaultDataDir = System . getProperty ( <str> , null ) ; if ( defaultDataDir = = null ) throw new ConfigurationException ( <str> , false ) ; conf . data_file_directories = new String [ ] { defaultDataDir + File . separator + <str> } ; } long dataFreeBytes = <int> ; for ( String datadir : conf . data_file_directories ) { if ( datadir . equals ( conf . commitlog_directory ) ) throw new ConfigurationException ( <str> , false ) ; if ( datadir . equals ( conf . hints_directory ) ) throw new ConfigurationException ( <str> , false ) ; if ( datadir . equals ( conf . saved_caches_directory ) ) throw new ConfigurationException ( <str> , false ) ; try { dataFreeBytes + = guessFileStore ( datadir ) . getUnallocatedSpace ( ) ; } catch ( IOException e ) { logger . debug ( <str> , e ) ; throw new ConfigurationException ( String . format ( <str> , datadir ) , e ) ; } } if ( dataFreeBytes < <int> * <int> * <int> ) logger . warn ( <str> , dataFreeBytes / <int> ) ; if ( conf . commitlog_directory . equals ( conf . saved_caches_directory ) ) throw new ConfigurationException ( <str> , false ) ; if ( conf . commitlog_directory . equals ( conf . hints_directory ) ) throw new ConfigurationException ( <str> , false ) ; if ( conf . hints_directory . equals ( conf . saved_caches_directory ) ) throw new ConfigurationException ( <str> , false ) ; if ( conf . memtable_flush_writers = = null ) conf . memtable_flush_writers = Math . min ( <int> , Math . max ( <int> , Math . min ( FBUtilities . getAvailableProcessors ( ) , conf . data_file_directories . length ) ) ) ; if ( conf . memtable_flush_writers < <int> ) throw new ConfigurationException ( <str> + conf . memtable_flush_writers , false ) ; if ( conf . memtable_cleanup_threshold = = null ) conf . memtable_cleanup_threshold = ( float ) ( <float> / ( <int> + conf . memtable_flush_writers ) ) ; if ( conf . memtable_cleanup_threshold < <float> ) throw new ConfigurationException ( <str> + conf . memtable_cleanup_threshold , false ) ; if ( conf . memtable_cleanup_threshold > <float> ) throw new ConfigurationException ( <str> + conf . memtable_cleanup_threshold , false ) ; if ( conf . memtable_cleanup_threshold < <float> ) logger . warn ( <str> , conf . memtable_cleanup_threshold ) ; if ( conf . concurrent_compactors = = null ) conf . concurrent_compactors = Math . min ( <int> , Math . max ( <int> , Math . min ( FBUtilities . getAvailableProcessors ( ) , conf . data_file_directories . length ) ) ) ; if ( conf . concurrent_compactors < = <int> ) throw new ConfigurationException ( <str> + conf . concurrent_compactors , false ) ; if ( conf . initial_token ! = null ) for ( String token : tokensFromString ( conf . initial_token ) ) partitioner . getTokenFactory ( ) . validate ( token ) ; if ( conf . num_tokens = = null ) conf . num_tokens = <int> ; else if ( conf . num_tokens > MAX_NUM_TOKENS ) throw new ConfigurationException ( String . format ( <str> , MAX_NUM_TOKENS ) , false ) ; try { keyCacheSizeInMB = ( conf . key_cache_size_in_mb = = null ) ? Math . min ( Math . max ( <int> , ( int ) ( Runtime . getRuntime ( ) . totalMemory ( ) * <float> / <int> / <int> ) ) , <int> ) : conf . key_cache_size_in_mb ; if ( keyCacheSizeInMB < <int> ) throw new NumberFormatException ( ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( <str> + conf . key_cache_size_in_mb + <str> , false ) ; } try { counterCacheSizeInMB = ( conf . counter_cache_size_in_mb = = null ) ? Math . min ( Math . max ( <int> , ( int ) ( Runtime . getRuntime ( ) . totalMemory ( ) * <float> / <int> / <int> ) ) , <int> ) : conf . counter_cache_size_in_mb ; if ( counterCacheSizeInMB < <int> ) throw new NumberFormatException ( ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( <str> + conf . counter_cache_size_in_mb + <str> , false ) ; } indexSummaryCapacityInMB = ( conf . index_summary_capacity_in_mb = = null ) ? Math . max ( <int> , ( int ) ( Runtime . getRuntime ( ) . totalMemory ( ) * <float> / <int> / <int> ) ) : conf . index_summary_capacity_in_mb ; if ( indexSummaryCapacityInMB < <int> ) throw new ConfigurationException ( <str> + conf . index_summary_capacity_in_mb + <str> , false ) ; if ( conf . encryption_options ! = null ) { logger . warn ( <str> ) ; conf . server_encryption_options = conf . encryption_options ; } if ( conf . seed_provider = = null ) { throw new ConfigurationException ( <str> , false ) ; } try { Class < ? > seedProviderClass = Class . forName ( conf . seed_provider . class_name ) ; seedProvider = ( SeedProvider ) seedProviderClass . getConstructor ( Map . class ) . newInstance ( conf . seed_provider . parameters ) ; } catch ( Exception e ) { throw new ConfigurationException ( e . getMessage ( ) + <str> , false ) ; } if ( seedProvider . getSeeds ( ) . size ( ) = = <int> ) throw new ConfigurationException ( <str> , false ) ; if ( conf . user_defined_function_fail_timeout < <int> ) throw new ConfigurationException ( <str> , false ) ; if ( conf . user_defined_function_warn_timeout < <int> ) throw new ConfigurationException ( <str> , false ) ; if ( conf . user_defined_function_fail_timeout < conf . user_defined_function_warn_timeout ) throw new ConfigurationException ( <str> , false ) ; encryptionContext = new EncryptionContext ( config . transparent_data_encryption_options ) ; if ( conf . max_mutation_size_in_kb = = null ) conf . max_mutation_size_in_kb = conf . commitlog_segment_size_in_mb * <int> / <int> ; else if ( conf . commitlog_segment_size_in_mb * <int> < <int> * conf . max_mutation_size_in_kb ) throw new ConfigurationException ( <str> , false ) ; if ( conf . native_transport_port_ssl ! = null & & conf . native_transport_port_ssl . intValue ( ) ! = conf . native_transport_port . intValue ( ) & & ! conf . client_encryption_options . enabled ) { throw new ConfigurationException ( <str> , false ) ; } } private static FileStore guessFileStore ( String dir ) throws IOException { Path path = Paths . get ( dir ) ; while ( true ) { try { return Files . getFileStore ( path ) ; } catch ( IOException e ) { if ( e instanceof NoSuchFileException ) path = path . getParent ( ) ; else throw e ; } } } private static IEndpointSnitch createEndpointSnitch ( String snitchClassName ) throws ConfigurationException { if ( ! snitchClassName . contains ( <str> ) ) snitchClassName = <str> + snitchClassName ; IEndpointSnitch snitch = FBUtilities . construct ( snitchClassName , <str> ) ; return conf . dynamic_snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; } public static IAuthenticator getAuthenticator ( ) { return authenticator ; } public static IAuthorizer getAuthorizer ( ) { return authorizer ; } public static IRoleManager getRoleManager ( ) { return roleManager ; } public static int getPermissionsValidity ( ) { return conf . permissions_validity_in_ms ; } public static void setPermissionsValidity ( int timeout ) { conf . permissions_validity_in_ms = timeout ; } public static int getPermissionsCacheMaxEntries ( ) { return conf . permissions_cache_max_entries ; } public static int getPermissionsUpdateInterval ( ) { return conf . permissions_update_interval_in_ms = = - <int> ? conf . permissions_validity_in_ms : conf . permissions_update_interval_in_ms ; } public static int getRolesValidity ( ) { return conf . roles_validity_in_ms ; } public static void setRolesValidity ( int validity ) { conf . roles_validity_in_ms = validity ; } public static int getRolesCacheMaxEntries ( ) { return conf . roles_cache_max_entries ; } public static int getRolesUpdateInterval ( ) { return conf . roles_update_interval_in_ms = = - <int> ? conf . roles_validity_in_ms : conf . roles_update_interval_in_ms ; } public static void setRolesUpdateInterval ( int interval ) { conf . roles_update_interval_in_ms = interval ; } public static void setPermissionsUpdateInterval ( int updateInterval ) { conf . permissions_update_interval_in_ms = updateInterval ; } public static int getThriftFramedTransportSize ( ) { return conf . thrift_framed_transport_size_in_mb * <int> * <int> ; } public static void createAllDirectories ( ) { try { if ( conf . data_file_directories . length = = <int> ) throw new ConfigurationException ( <str> , false ) ; for ( String dataFileDirectory : conf . data_file_directories ) FileUtils . createDirectory ( dataFileDirectory ) ; if ( conf . commitlog_directory = = null ) throw new ConfigurationException ( <str> , false ) ; FileUtils . createDirectory ( conf . commitlog_directory ) ; if ( conf . hints_directory = = null ) throw new ConfigurationException ( <str> , false ) ; FileUtils . createDirectory ( conf . hints_directory ) ; if ( conf . saved_caches_directory = = null ) throw new ConfigurationException ( <str> , false ) ; FileUtils . createDirectory ( conf . saved_caches_directory ) ; } catch ( ConfigurationException e ) { throw new IllegalArgumentException ( <str> + e . getMessage ( ) ) ; } catch ( FSWriteError e ) { throw new IllegalStateException ( e . getCause ( ) . getMessage ( ) + <str> ) ; } } public static IPartitioner getPartitioner ( ) { return partitioner ; } public static String getPartitionerName ( ) { return paritionerName ; } public static IPartitioner setPartitionerUnsafe ( IPartitioner newPartitioner ) { IPartitioner old = partitioner ; partitioner = newPartitioner ; return old ; } public static IEndpointSnitch getEndpointSnitch ( ) { return snitch ; } public static void setEndpointSnitch ( IEndpointSnitch eps ) { snitch = eps ; } public static IRequestScheduler getRequestScheduler ( ) { return requestScheduler ; } public static RequestSchedulerOptions getRequestSchedulerOptions ( ) { return requestSchedulerOptions ; } public static RequestSchedulerId getRequestSchedulerId ( ) { return requestSchedulerId ; } public static int getColumnIndexSize ( ) { return conf . column_index_size_in_kb * <int> ; } public static int getBatchSizeWarnThreshold ( ) { return conf . batch_size_warn_threshold_in_kb * <int> ; } public static long getBatchSizeFailThreshold ( ) { return conf . batch_size_fail_threshold_in_kb * <int> ; } public static int getBatchSizeFailThresholdInKB ( ) { return conf . batch_size_fail_threshold_in_kb ; } public static void setBatchSizeWarnThresholdInKB ( int threshold ) { conf . batch_size_warn_threshold_in_kb = threshold ; } public static void setBatchSizeFailThresholdInKB ( int threshold ) { conf . batch_size_fail_threshold_in_kb = threshold ; } public static Collection < String > getInitialTokens ( ) { return tokensFromString ( System . getProperty ( <str> , conf . initial_token ) ) ; } public static String getAllocateTokensForKeyspace ( ) { return System . getProperty ( <str> , conf . allocate_tokens_for_keyspace ) ; } public static Collection < String > tokensFromString ( String tokenString ) { List < String > tokens = new ArrayList < String > ( ) ; if ( tokenString ! = null ) for ( String token : tokenString . split ( <str> ) ) tokens . add ( token . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) ) ; return tokens ; } public static Integer getNumTokens ( ) { return conf . num_tokens ; } public static InetAddress getReplaceAddress ( ) { try { if ( System . getProperty ( <str> , null ) ! = null ) return InetAddress . getByName ( System . getProperty ( <str> , null ) ) ; else if ( System . getProperty ( <str> , null ) ! = null ) return InetAddress . getByName ( System . getProperty ( <str> , null ) ) ; return null ; } catch ( UnknownHostException e ) { return null ; } } public static Collection < String > getReplaceTokens ( ) { return tokensFromString ( System . getProperty ( <str> , null ) ) ; } public static UUID getReplaceNode ( ) { try { return UUID . fromString ( System . getProperty ( <str> , null ) ) ; } catch ( NullPointerException e ) { return null ; } } public static boolean isReplacing ( ) { if ( System . getProperty ( <str> , null ) ! = null & & SystemKeyspace . bootstrapComplete ( ) ) { logger . info ( <str> ) ; return false ; } return getReplaceAddress ( ) ! = null ; } public static String getClusterName ( ) { return conf . cluster_name ; } public static int getMaxStreamingRetries ( ) { return conf . max_streaming_retries ; } public static int getStoragePort ( ) { return Integer . parseInt ( System . getProperty ( <str> , conf . storage_port . toString ( ) ) ) ; } public static int getSSLStoragePort ( ) { return Integer . parseInt ( System . getProperty ( <str> , conf . ssl_storage_port . toString ( ) ) ) ; } public static int getRpcPort ( ) { return Integer . parseInt ( System . getProperty ( <str> , conf . rpc_port . toString ( ) ) ) ; } public static int getRpcListenBacklog ( ) { return conf . rpc_listen_backlog ; } public static long getRpcTimeout ( ) { return conf . request_timeout_in_ms ; } public static void setRpcTimeout ( Long timeOutInMillis ) { conf . request_timeout_in_ms = timeOutInMillis ; } public static long getReadRpcTimeout ( ) { return conf . read_request_timeout_in_ms ; } public static void setReadRpcTimeout ( Long timeOutInMillis ) { conf . read_request_timeout_in_ms = timeOutInMillis ; } public static long getRangeRpcTimeout ( ) { return conf . range_request_timeout_in_ms ; } public static void setRangeRpcTimeout ( Long timeOutInMillis ) { conf . range_request_timeout_in_ms = timeOutInMillis ; } public static long getWriteRpcTimeout ( ) { return conf . write_request_timeout_in_ms ; } public static void setWriteRpcTimeout ( Long timeOutInMillis ) { conf . write_request_timeout_in_ms = timeOutInMillis ; } public static long getCounterWriteRpcTimeout ( ) { return conf . counter_write_request_timeout_in_ms ; } public static void setCounterWriteRpcTimeout ( Long timeOutInMillis ) { conf . counter_write_request_timeout_in_ms = timeOutInMillis ; } public static long getCasContentionTimeout ( ) { return conf . cas_contention_timeout_in_ms ; } public static void setCasContentionTimeout ( Long timeOutInMillis ) { conf . cas_contention_timeout_in_ms = timeOutInMillis ; } public static long getTruncateRpcTimeout ( ) { return conf . truncate_request_timeout_in_ms ; } public static void setTruncateRpcTimeout ( Long timeOutInMillis ) { conf . truncate_request_timeout_in_ms = timeOutInMillis ; } public static boolean hasCrossNodeTimeout ( ) { return conf . cross_node_timeout ; } public static long getTimeout ( MessagingService . Verb verb ) { switch ( verb ) { case READ : return getReadRpcTimeout ( ) ; case RANGE_SLICE : return getRangeRpcTimeout ( ) ; case TRUNCATE : return getTruncateRpcTimeout ( ) ; case READ_REPAIR : case MUTATION : case PAXOS_COMMIT : case PAXOS_PREPARE : case PAXOS_PROPOSE : case HINT : case BATCH_STORE : case BATCH_REMOVE : return getWriteRpcTimeout ( ) ; case COUNTER_MUTATION : return getCounterWriteRpcTimeout ( ) ; default : return getRpcTimeout ( ) ; } } public static long getMinRpcTimeout ( ) { return Longs . min ( getRpcTimeout ( ) , getReadRpcTimeout ( ) , getRangeRpcTimeout ( ) , getWriteRpcTimeout ( ) , getCounterWriteRpcTimeout ( ) , getTruncateRpcTimeout ( ) ) ; } public static double getPhiConvictThreshold ( ) { return conf . phi_convict_threshold ; } public static void setPhiConvictThreshold ( double phiConvictThreshold ) { conf . phi_convict_threshold = phiConvictThreshold ; } public static int getConcurrentReaders ( ) { return conf . concurrent_reads ; } public static int getConcurrentWriters ( ) { return conf . concurrent_writes ; } public static int getConcurrentCounterWriters ( ) { return conf . concurrent_counter_writes ; } public static int getConcurrentViewWriters ( ) { return conf . concurrent_materialized_view_writes ; } public static int getFlushWriters ( ) { return conf . memtable_flush_writers ; } public static int getConcurrentCompactors ( ) { return conf . concurrent_compactors ; } public static int getCompactionThroughputMbPerSec ( ) { return conf . compaction_throughput_mb_per_sec ; } public static void setCompactionThroughputMbPerSec ( int value ) { conf . compaction_throughput_mb_per_sec = value ; } public static int getCompactionLargePartitionWarningThreshold ( ) { return conf . compaction_large_partition_warning_threshold_mb * <int> * <int> ; } public static boolean getDisableSTCSInL0 ( ) { return Boolean . getBoolean ( <str> ) ; } public static int getStreamThroughputOutboundMegabitsPerSec ( ) { return conf . stream_throughput_outbound_megabits_per_sec ; } public static void setStreamThroughputOutboundMegabitsPerSec ( int value ) { conf . stream_throughput_outbound_megabits_per_sec = value ; } public static int getInterDCStreamThroughputOutboundMegabitsPerSec ( ) { return conf . inter_dc_stream_throughput_outbound_megabits_per_sec ; } public static void setInterDCStreamThroughputOutboundMegabitsPerSec ( int value ) { conf . inter_dc_stream_throughput_outbound_megabits_per_sec = value ; } public static String [ ] getAllDataFileLocations ( ) { return conf . data_file_directories ; } public static String getCommitLogLocation ( ) { return conf . commitlog_directory ; } public static ParameterizedClass getCommitLogCompression ( ) { return conf . commitlog_compression ; } public static void setCommitLogCompression ( ParameterizedClass compressor ) { conf . commitlog_compression = compressor ; } public static int getCommitLogMaxCompressionBuffersInPool ( ) { return conf . commitlog_max_compression_buffers_in_pool ; } public static int getMaxMutationSize ( ) { return conf . max_mutation_size_in_kb * <int> ; } public static int getTombstoneWarnThreshold ( ) { return conf . tombstone_warn_threshold ; } public static void setTombstoneWarnThreshold ( int threshold ) { conf . tombstone_warn_threshold = threshold ; } public static int getTombstoneFailureThreshold ( ) { return conf . tombstone_failure_threshold ; } public static void setTombstoneFailureThreshold ( int threshold ) { conf . tombstone_failure_threshold = threshold ; } public static int getCommitLogSegmentSize ( ) { return conf . commitlog_segment_size_in_mb * <int> * <int> ; } public static void setCommitLogSegmentSize ( int sizeMegabytes ) { conf . commitlog_segment_size_in_mb = sizeMegabytes ; } public static String getSavedCachesLocation ( ) { return conf . saved_caches_directory ; } public static Set < InetAddress > getSeeds ( ) { return ImmutableSet . < InetAddress > builder ( ) . addAll ( seedProvider . getSeeds ( ) ) . build ( ) ; } public static InetAddress getListenAddress ( ) { return listenAddress ; } public static InetAddress getBroadcastAddress ( ) { return broadcastAddress ; } public static Boolean shouldListenOnBroadcastAddress ( ) { return conf . listen_on_broadcast_address ; } public static IInternodeAuthenticator getInternodeAuthenticator ( ) { return internodeAuthenticator ; } public static void setBroadcastAddress ( InetAddress broadcastAdd ) { broadcastAddress = broadcastAdd ; } public static boolean startRpc ( ) { return conf . start_rpc ; } public static InetAddress getRpcAddress ( ) { return rpcAddress ; } public static void setBroadcastRpcAddress ( InetAddress broadcastRPCAddr ) { broadcastRpcAddress = broadcastRPCAddr ; } public static InetAddress getBroadcastRpcAddress ( ) { return broadcastRpcAddress ; } public static String getRpcServerType ( ) { return conf . rpc_server_type ; } public static boolean getRpcKeepAlive ( ) { return conf . rpc_keepalive ; } public static Integer getRpcMinThreads ( ) { return conf . rpc_min_threads ; } public static Integer getRpcMaxThreads ( ) { return conf . rpc_max_threads ; } public static Integer getRpcSendBufferSize ( ) { return conf . rpc_send_buff_size_in_bytes ; } public static Integer getRpcRecvBufferSize ( ) { return conf . rpc_recv_buff_size_in_bytes ; } public static Integer getInternodeSendBufferSize ( ) { return conf . internode_send_buff_size_in_bytes ; } public static Integer getInternodeRecvBufferSize ( ) { return conf . internode_recv_buff_size_in_bytes ; } public static boolean startNativeTransport ( ) { return conf . start_native_transport ; } public static int getNativeTransportPort ( ) { return Integer . parseInt ( System . getProperty ( <str> , conf . native_transport_port . toString ( ) ) ) ; } @VisibleForTesting public static void setNativeTransportPort ( int port ) { conf . native_transport_port = port ; } public static int getNativeTransportPortSSL ( ) { return conf . native_transport_port_ssl = = null ? getNativeTransportPort ( ) : conf . native_transport_port_ssl ; } @VisibleForTesting public static void setNativeTransportPortSSL ( Integer port ) { conf . native_transport_port_ssl = port ; } public static Integer getNativeTransportMaxThreads ( ) { return conf . native_transport_max_threads ; } public static int getNativeTransportMaxFrameSize ( ) { return conf . native_transport_max_frame_size_in_mb * <int> * <int> ; } public static Long getNativeTransportMaxConcurrentConnections ( ) { return conf . native_transport_max_concurrent_connections ; } public static void setNativeTransportMaxConcurrentConnections ( long nativeTransportMaxConcurrentConnections ) { conf . native_transport_max_concurrent_connections = nativeTransportMaxConcurrentConnections ; } public static Long getNativeTransportMaxConcurrentConnectionsPerIp ( ) { return conf . native_transport_max_concurrent_connections_per_ip ; } public static void setNativeTransportMaxConcurrentConnectionsPerIp ( long native_transport_max_concurrent_connections_per_ip ) { conf . native_transport_max_concurrent_connections_per_ip = native_transport_max_concurrent_connections_per_ip ; } public static double getCommitLogSyncBatchWindow ( ) { return conf . commitlog_sync_batch_window_in_ms ; } public static void setCommitLogSyncBatchWindow ( double windowMillis ) { conf . commitlog_sync_batch_window_in_ms = windowMillis ; } public static int getCommitLogSyncPeriod ( ) { return conf . commitlog_sync_period_in_ms ; } public static void setCommitLogSyncPeriod ( int periodMillis ) { conf . commitlog_sync_period_in_ms = periodMillis ; } public static Config . CommitLogSync getCommitLogSync ( ) { return conf . commitlog_sync ; } public static void setCommitLogSync ( CommitLogSync sync ) { conf . commitlog_sync = sync ; } public static Config . DiskAccessMode getDiskAccessMode ( ) { return conf . disk_access_mode ; } @VisibleForTesting public static void setDiskAccessMode ( Config . DiskAccessMode mode ) { conf . disk_access_mode = mode ; } public static Config . DiskAccessMode getIndexAccessMode ( ) { return indexAccessMode ; } @VisibleForTesting public static void setIndexAccessMode ( Config . DiskAccessMode mode ) { indexAccessMode = mode ; } public static void setDiskFailurePolicy ( Config . DiskFailurePolicy policy ) { conf . disk_failure_policy = policy ; } public static Config . DiskFailurePolicy getDiskFailurePolicy ( ) { return conf . disk_failure_policy ; } public static void setCommitFailurePolicy ( Config . CommitFailurePolicy policy ) { conf . commit_failure_policy = policy ; } public static Config . CommitFailurePolicy getCommitFailurePolicy ( ) { return conf . commit_failure_policy ; } public static boolean isSnapshotBeforeCompaction ( ) { return conf . snapshot_before_compaction ; } public static boolean isAutoSnapshot ( ) { return conf . auto_snapshot ; } @VisibleForTesting public static void setAutoSnapshot ( boolean autoSnapshot ) { conf . auto_snapshot = autoSnapshot ; } @VisibleForTesting public static boolean getAutoSnapshot ( ) { return conf . auto_snapshot ; } public static boolean isAutoBootstrap ( ) { return Boolean . parseBoolean ( System . getProperty ( <str> , conf . auto_bootstrap . toString ( ) ) ) ; } public static void setHintedHandoffEnabled ( boolean hintedHandoffEnabled ) { conf . hinted_handoff_enabled = hintedHandoffEnabled ; } public static boolean hintedHandoffEnabled ( ) { return conf . hinted_handoff_enabled ; } public static Set < String > hintedHandoffDisabledDCs ( ) { return conf . hinted_handoff_disabled_datacenters ; } public static void enableHintsForDC ( String dc ) { conf . hinted_handoff_disabled_datacenters . remove ( dc ) ; } public static void disableHintsForDC ( String dc ) { conf . hinted_handoff_disabled_datacenters . add ( dc ) ; } public static void setMaxHintWindow ( int ms ) { conf . max_hint_window_in_ms = ms ; } public static int getMaxHintWindow ( ) { return conf . max_hint_window_in_ms ; } public static File getHintsDirectory ( ) { return new File ( conf . hints_directory ) ; } public static File getSerializedCachePath ( CacheService . CacheType cacheType , String version , String extension ) { String name = cacheType . toString ( ) + ( version = = null ? <str> : <str> + version + <str> + extension ) ; return new File ( conf . saved_caches_directory , name ) ; } public static int getDynamicUpdateInterval ( ) { return conf . dynamic_snitch_update_interval_in_ms ; } public static void setDynamicUpdateInterval ( Integer dynamicUpdateInterval ) { conf . dynamic_snitch_update_interval_in_ms = dynamicUpdateInterval ; } public static int getDynamicResetInterval ( ) { return conf . dynamic_snitch_reset_interval_in_ms ; } public static void setDynamicResetInterval ( Integer dynamicResetInterval ) { conf . dynamic_snitch_reset_interval_in_ms = dynamicResetInterval ; } public static double getDynamicBadnessThreshold ( ) { return conf . dynamic_snitch_badness_threshold ; } public static void setDynamicBadnessThreshold ( Double dynamicBadnessThreshold ) { conf . dynamic_snitch_badness_threshold = dynamicBadnessThreshold ; } public static ServerEncryptionOptions getServerEncryptionOptions ( ) { return conf . server_encryption_options ; } public static ClientEncryptionOptions getClientEncryptionOptions ( ) { return conf . client_encryption_options ; } public static int getHintedHandoffThrottleInKB ( ) { return conf . hinted_handoff_throttle_in_kb ; } public static int getBatchlogReplayThrottleInKB ( ) { return conf . batchlog_replay_throttle_in_kb ; } public static void setHintedHandoffThrottleInKB ( Integer throttleInKB ) { conf . hinted_handoff_throttle_in_kb = throttleInKB ; } public static int getMaxHintsDeliveryThreads ( ) { return conf . max_hints_delivery_threads ; } public static int getHintsFlushPeriodInMS ( ) { return conf . hints_flush_period_in_ms ; } public static long getMaxHintsFileSize ( ) { return conf . max_hints_file_size_in_mb * <int> * <int> ; } public static boolean isIncrementalBackupsEnabled ( ) { return conf . incremental_backups ; } public static void setIncrementalBackupsEnabled ( boolean value ) { conf . incremental_backups = value ; } public static int getFileCacheSizeInMB ( ) { return conf . file_cache_size_in_mb ; } public static boolean getBufferPoolUseHeapIfExhausted ( ) { return conf . buffer_pool_use_heap_if_exhausted ; } public static Config . DiskOptimizationStrategy getDiskOptimizationStrategy ( ) { return conf . disk_optimization_strategy ; } @VisibleForTesting public static void setDiskOptimizationStrategy ( Config . DiskOptimizationStrategy strategy ) { conf . disk_optimization_strategy = strategy ; } public static double getDiskOptimizationEstimatePercentile ( ) { return conf . disk_optimization_estimate_percentile ; } public static double getDiskOptimizationPageCrossChance ( ) { return conf . disk_optimization_page_cross_chance ; } @VisibleForTesting public static void setDiskOptimizationPageCrossChance ( double chance ) { conf . disk_optimization_page_cross_chance = chance ; } public static long getTotalCommitlogSpaceInMB ( ) { return conf . commitlog_total_space_in_mb ; } public static int getSSTablePreempiveOpenIntervalInMB ( ) { return FBUtilities . isWindows ( ) ? - <int> : conf . sstable_preemptive_open_interval_in_mb ; } public static boolean getTrickleFsync ( ) { return conf . trickle_fsync ; } public static int getTrickleFsyncIntervalInKb ( ) { return conf . trickle_fsync_interval_in_kb ; } public static long getKeyCacheSizeInMB ( ) { return keyCacheSizeInMB ; } public static long getIndexSummaryCapacityInMB ( ) { return indexSummaryCapacityInMB ; } public static int getKeyCacheSavePeriod ( ) { return conf . key_cache_save_period ; } public static void setKeyCacheSavePeriod ( int keyCacheSavePeriod ) { conf . key_cache_save_period = keyCacheSavePeriod ; } public static int getKeyCacheKeysToSave ( ) { return conf . key_cache_keys_to_save ; } public static void setKeyCacheKeysToSave ( int keyCacheKeysToSave ) { conf . key_cache_keys_to_save = keyCacheKeysToSave ; } public static String getRowCacheClassName ( ) { return conf . row_cache_class_name ; } public static long getRowCacheSizeInMB ( ) { return conf . row_cache_size_in_mb ; } @VisibleForTesting public static void setRowCacheSizeInMB ( long val ) { conf . row_cache_size_in_mb = val ; } public static int getRowCacheSavePeriod ( ) { return conf . row_cache_save_period ; } public static void setRowCacheSavePeriod ( int rowCacheSavePeriod ) { conf . row_cache_save_period = rowCacheSavePeriod ; } public static int getRowCacheKeysToSave ( ) { return conf . row_cache_keys_to_save ; } public static long getCounterCacheSizeInMB ( ) { return counterCacheSizeInMB ; } public static void setRowCacheKeysToSave ( int rowCacheKeysToSave ) { conf . row_cache_keys_to_save = rowCacheKeysToSave ; } public static int getCounterCacheSavePeriod ( ) { return conf . counter_cache_save_period ; } public static void setCounterCacheSavePeriod ( int counterCacheSavePeriod ) { conf . counter_cache_save_period = counterCacheSavePeriod ; } public static int getCounterCacheKeysToSave ( ) { return conf . counter_cache_keys_to_save ; } public static void setCounterCacheKeysToSave ( int counterCacheKeysToSave ) { conf . counter_cache_keys_to_save = counterCacheKeysToSave ; } public static int getStreamingSocketTimeout ( ) { return conf . streaming_socket_timeout_in_ms ; } public static String getLocalDataCenter ( ) { return localDC ; } public static Comparator < InetAddress > getLocalComparator ( ) { return localComparator ; } public static Config . InternodeCompression internodeCompression ( ) { return conf . internode_compression ; } public static boolean getInterDCTcpNoDelay ( ) { return conf . inter_dc_tcp_nodelay ; } public static SSTableFormat . Type getSSTableFormat ( ) { return sstable_format ; } public static MemtablePool getMemtableAllocatorPool ( ) { long heapLimit = ( ( long ) conf . memtable_heap_space_in_mb ) < < <int> ; long offHeapLimit = ( ( long ) conf . memtable_offheap_space_in_mb ) < < <int> ; switch ( conf . memtable_allocation_type ) { case unslabbed_heap_buffers : return new HeapPool ( heapLimit , conf . memtable_cleanup_threshold , new ColumnFamilyStore . FlushLargestColumnFamily ( ) ) ; case heap_buffers : return new SlabPool ( heapLimit , <int> , conf . memtable_cleanup_threshold , new ColumnFamilyStore . FlushLargestColumnFamily ( ) ) ; case offheap_buffers : if ( ! FileUtils . isCleanerAvailable ( ) ) { throw new IllegalStateException ( <str> ) ; } return new SlabPool ( heapLimit , offHeapLimit , conf . memtable_cleanup_threshold , new ColumnFamilyStore . FlushLargestColumnFamily ( ) ) ; case offheap_objects : throw new ConfigurationException ( <str> ) ; default : throw new AssertionError ( ) ; } } public static int getIndexSummaryResizeIntervalInMinutes ( ) { return conf . index_summary_resize_interval_in_minutes ; } public static boolean hasLargeAddressSpace ( ) { String datamodel = System . getProperty ( <str> ) ; if ( datamodel ! = null ) { switch ( datamodel ) { case <str> : return true ; case <str> : return false ; } } String arch = System . getProperty ( <str> ) ; return arch . contains ( <str> ) | | arch . contains ( <str> ) ; } public static int getTracetypeRepairTTL ( ) { return conf . tracetype_repair_ttl ; } public static int getTracetypeQueryTTL ( ) { return conf . tracetype_query_ttl ; } public static String getOtcCoalescingStrategy ( ) { return conf . otc_coalescing_strategy ; } public static int getOtcCoalescingWindow ( ) { return conf . otc_coalescing_window_us ; } public static int getWindowsTimerInterval ( ) { return conf . windows_timer_interval ; } public static boolean enableUserDefinedFunctions ( ) { return conf . enable_user_defined_functions ; } public static boolean enableScriptedUserDefinedFunctions ( ) { return conf . enable_scripted_user_defined_functions ; } public static void enableScriptedUserDefinedFunctions ( boolean enableScriptedUserDefinedFunctions ) { conf . enable_scripted_user_defined_functions = enableScriptedUserDefinedFunctions ; } public static boolean enableUserDefinedFunctionsThreads ( ) { return conf . enable_user_defined_functions_threads ; } public static long getUserDefinedFunctionWarnTimeout ( ) { return conf . user_defined_function_warn_timeout ; } public static void setUserDefinedFunctionWarnTimeout ( long userDefinedFunctionWarnTimeout ) { conf . user_defined_function_warn_timeout = userDefinedFunctionWarnTimeout ; } public static long getUserDefinedFunctionFailTimeout ( ) { return conf . user_defined_function_fail_timeout ; } public static void setUserDefinedFunctionFailTimeout ( long userDefinedFunctionFailTimeout ) { conf . user_defined_function_fail_timeout = userDefinedFunctionFailTimeout ; } public static Config . UserFunctionTimeoutPolicy getUserFunctionTimeoutPolicy ( ) { return conf . user_function_timeout_policy ; } public static void setUserFunctionTimeoutPolicy ( Config . UserFunctionTimeoutPolicy userFunctionTimeoutPolicy ) { conf . user_function_timeout_policy = userFunctionTimeoutPolicy ; } public static EncryptionContext getEncryptionContext ( ) { return encryptionContext ; } public static long getGCWarnThreshold ( ) { return conf . gc_warn_threshold_in_ms ; } @VisibleForTesting public static void setEncryptionContext ( EncryptionContext ec ) { encryptionContext = ec ; } } 
