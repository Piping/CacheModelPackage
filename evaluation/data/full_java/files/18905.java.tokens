package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; class Snappy { private static final int MAX_HT_SIZE = <int> < < <int> ; private static final int MIN_COMPRESSIBLE_BYTES = <int> ; private static final int PREAMBLE_NOT_FULL = - <int> ; private static final int NOT_ENOUGH_INPUT = - <int> ; private static final int LITERAL = <int> ; private static final int COPY_1_BYTE_OFFSET = <int> ; private static final int COPY_2_BYTE_OFFSET = <int> ; private static final int COPY_4_BYTE_OFFSET = <int> ; private State state = State . READY ; private byte tag ; private int written ; private enum State { READY , READING_PREAMBLE , READING_TAG , READING_LITERAL , READING_COPY } public void reset ( ) { state = State . READY ; tag = <int> ; written = <int> ; } public void encode ( final ByteBuf in , final ByteBuf out , final int length ) { for ( int i = <int> ; ; i + + ) { int b = length > > > i * <int> ; if ( ( b & <hex> ) ! = <int> ) { out . writeByte ( b & <hex> | <hex> ) ; } else { out . writeByte ( b ) ; break ; } } int inIndex = in . readerIndex ( ) ; final int baseIndex = inIndex ; final short [ ] table = getHashTable ( length ) ; final int shift = <int> - ( int ) Math . floor ( Math . log ( table . length ) / Math . log ( <int> ) ) ; int nextEmit = inIndex ; if ( length - inIndex > = MIN_COMPRESSIBLE_BYTES ) { int nextHash = hash ( in , + + inIndex , shift ) ; outer : while ( true ) { int skip = <int> ; int candidate ; int nextIndex = inIndex ; do { inIndex = nextIndex ; int hash = nextHash ; int bytesBetweenHashLookups = skip + + > > <int> ; nextIndex = inIndex + bytesBetweenHashLookups ; if ( nextIndex > length - <int> ) { break outer ; } nextHash = hash ( in , nextIndex , shift ) ; candidate = baseIndex + table [ hash ] ; table [ hash ] = ( short ) ( inIndex - baseIndex ) ; } while ( in . getInt ( inIndex ) ! = in . getInt ( candidate ) ) ; encodeLiteral ( in , out , inIndex - nextEmit ) ; int insertTail ; do { int base = inIndex ; int matched = <int> + findMatchingLength ( in , candidate + <int> , inIndex + <int> , length ) ; inIndex + = matched ; int offset = base - candidate ; encodeCopy ( out , offset , matched ) ; in . readerIndex ( in . readerIndex ( ) + matched ) ; insertTail = inIndex - <int> ; nextEmit = inIndex ; if ( inIndex > = length - <int> ) { break outer ; } int prevHash = hash ( in , insertTail , shift ) ; table [ prevHash ] = ( short ) ( inIndex - baseIndex - <int> ) ; int currentHash = hash ( in , insertTail + <int> , shift ) ; candidate = baseIndex + table [ currentHash ] ; table [ currentHash ] = ( short ) ( inIndex - baseIndex ) ; } while ( in . getInt ( insertTail + <int> ) = = in . getInt ( candidate ) ) ; nextHash = hash ( in , insertTail + <int> , shift ) ; + + inIndex ; } } if ( nextEmit < length ) { encodeLiteral ( in , out , length - nextEmit ) ; } } private static int hash ( ByteBuf in , int index , int shift ) { return in . getInt ( index ) + <hex> > > > shift ; } private static short [ ] getHashTable ( int inputSize ) { int htSize = <int> ; while ( htSize < MAX_HT_SIZE & & htSize < inputSize ) { htSize < < = <int> ; } short [ ] table ; if ( htSize < = <int> ) { table = new short [ <int> ] ; } else { table = new short [ MAX_HT_SIZE ] ; } return table ; } private static int findMatchingLength ( ByteBuf in , int minIndex , int inIndex , int maxIndex ) { int matched = <int> ; while ( inIndex < = maxIndex - <int> & & in . getInt ( inIndex ) = = in . getInt ( minIndex + matched ) ) { inIndex + = <int> ; matched + = <int> ; } while ( inIndex < maxIndex & & in . getByte ( minIndex + matched ) = = in . getByte ( inIndex ) ) { + + inIndex ; + + matched ; } return matched ; } private static int bitsToEncode ( int value ) { int highestOneBit = Integer . highestOneBit ( value ) ; int bitLength = <int> ; while ( ( highestOneBit > > = <int> ) ! = <int> ) { bitLength + + ; } return bitLength ; } private static void encodeLiteral ( ByteBuf in , ByteBuf out , int length ) { if ( length < <int> ) { out . writeByte ( length - <int> < < <int> ) ; } else { int bitLength = bitsToEncode ( length - <int> ) ; int bytesToEncode = <int> + bitLength / <int> ; out . writeByte ( <int> + bytesToEncode < < <int> ) ; for ( int i = <int> ; i < bytesToEncode ; i + + ) { out . writeByte ( length - <int> > > i * <int> & <hex> ) ; } } out . writeBytes ( in , length ) ; } private static void encodeCopyWithOffset ( ByteBuf out , int offset , int length ) { if ( length < <int> & & offset < <int> ) { out . writeByte ( COPY_1_BYTE_OFFSET | length - <int> < < <int> | offset > > <int> < < <int> ) ; out . writeByte ( offset & <hex> ) ; } else { out . writeByte ( COPY_2_BYTE_OFFSET | length - <int> < < <int> ) ; out . writeByte ( offset & <hex> ) ; out . writeByte ( offset > > <int> & <hex> ) ; } } private static void encodeCopy ( ByteBuf out , int offset , int length ) { while ( length > = <int> ) { encodeCopyWithOffset ( out , offset , <int> ) ; length - = <int> ; } if ( length > <int> ) { encodeCopyWithOffset ( out , offset , <int> ) ; length - = <int> ; } encodeCopyWithOffset ( out , offset , length ) ; } public void decode ( ByteBuf in , ByteBuf out ) { while ( in . isReadable ( ) ) { switch ( state ) { case READY : state = State . READING_PREAMBLE ; case READING_PREAMBLE : int uncompressedLength = readPreamble ( in ) ; if ( uncompressedLength = = PREAMBLE_NOT_FULL ) { return ; } if ( uncompressedLength = = <int> ) { state = State . READY ; return ; } out . ensureWritable ( uncompressedLength ) ; state = State . READING_TAG ; case READING_TAG : if ( ! in . isReadable ( ) ) { return ; } tag = in . readByte ( ) ; switch ( tag & <hex> ) { case LITERAL : state = State . READING_LITERAL ; break ; case COPY_1_BYTE_OFFSET : case COPY_2_BYTE_OFFSET : case COPY_4_BYTE_OFFSET : state = State . READING_COPY ; break ; } break ; case READING_LITERAL : int literalWritten = decodeLiteral ( tag , in , out ) ; if ( literalWritten ! = NOT_ENOUGH_INPUT ) { state = State . READING_TAG ; written + = literalWritten ; } else { return ; } break ; case READING_COPY : int decodeWritten ; switch ( tag & <hex> ) { case COPY_1_BYTE_OFFSET : decodeWritten = decodeCopyWith1ByteOffset ( tag , in , out , written ) ; if ( decodeWritten ! = NOT_ENOUGH_INPUT ) { state = State . READING_TAG ; written + = decodeWritten ; } else { return ; } break ; case COPY_2_BYTE_OFFSET : decodeWritten = decodeCopyWith2ByteOffset ( tag , in , out , written ) ; if ( decodeWritten ! = NOT_ENOUGH_INPUT ) { state = State . READING_TAG ; written + = decodeWritten ; } else { return ; } break ; case COPY_4_BYTE_OFFSET : decodeWritten = decodeCopyWith4ByteOffset ( tag , in , out , written ) ; if ( decodeWritten ! = NOT_ENOUGH_INPUT ) { state = State . READING_TAG ; written + = decodeWritten ; } else { return ; } break ; } } } } private static int readPreamble ( ByteBuf in ) { int length = <int> ; int byteIndex = <int> ; while ( in . isReadable ( ) ) { int current = in . readUnsignedByte ( ) ; length | = ( current & <hex> ) < < byteIndex + + * <int> ; if ( ( current & <hex> ) = = <int> ) { return length ; } if ( byteIndex > = <int> ) { throw new DecompressionException ( <str> ) ; } } return <int> ; } private static int decodeLiteral ( byte tag , ByteBuf in , ByteBuf out ) { in . markReaderIndex ( ) ; int length ; switch ( tag > > <int> & <hex> ) { case <int> : if ( ! in . isReadable ( ) ) { return NOT_ENOUGH_INPUT ; } length = in . readUnsignedByte ( ) ; break ; case <int> : if ( in . readableBytes ( ) < <int> ) { return NOT_ENOUGH_INPUT ; } length = in . readShortLE ( ) ; break ; case <int> : if ( in . readableBytes ( ) < <int> ) { return NOT_ENOUGH_INPUT ; } length = in . readUnsignedMediumLE ( ) ; break ; case <int> : if ( in . readableBytes ( ) < <int> ) { return NOT_ENOUGH_INPUT ; } length = in . readIntLE ( ) ; break ; default : length = tag > > <int> & <hex> ; } length + = <int> ; if ( in . readableBytes ( ) < length ) { in . resetReaderIndex ( ) ; return NOT_ENOUGH_INPUT ; } out . writeBytes ( in , length ) ; return length ; } private static int decodeCopyWith1ByteOffset ( byte tag , ByteBuf in , ByteBuf out , int writtenSoFar ) { if ( ! in . isReadable ( ) ) { return NOT_ENOUGH_INPUT ; } int initialIndex = out . writerIndex ( ) ; int length = <int> + ( ( tag & <hex> ) > > <int> ) ; int offset = ( tag & <hex> ) < < <int> > > <int> | in . readUnsignedByte ( ) ; validateOffset ( offset , writtenSoFar ) ; out . markReaderIndex ( ) ; if ( offset < length ) { int copies = length / offset ; for ( ; copies > <int> ; copies - - ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , offset ) ; } if ( length % offset ! = <int> ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length % offset ) ; } } else { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length ) ; } out . resetReaderIndex ( ) ; return length ; } private static int decodeCopyWith2ByteOffset ( byte tag , ByteBuf in , ByteBuf out , int writtenSoFar ) { if ( in . readableBytes ( ) < <int> ) { return NOT_ENOUGH_INPUT ; } int initialIndex = out . writerIndex ( ) ; int length = <int> + ( tag > > <int> & <hex> ) ; int offset = in . readShortLE ( ) ; validateOffset ( offset , writtenSoFar ) ; out . markReaderIndex ( ) ; if ( offset < length ) { int copies = length / offset ; for ( ; copies > <int> ; copies - - ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , offset ) ; } if ( length % offset ! = <int> ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length % offset ) ; } } else { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length ) ; } out . resetReaderIndex ( ) ; return length ; } private static int decodeCopyWith4ByteOffset ( byte tag , ByteBuf in , ByteBuf out , int writtenSoFar ) { if ( in . readableBytes ( ) < <int> ) { return NOT_ENOUGH_INPUT ; } int initialIndex = out . writerIndex ( ) ; int length = <int> + ( tag > > <int> & <hex> ) ; int offset = in . readIntLE ( ) ; validateOffset ( offset , writtenSoFar ) ; out . markReaderIndex ( ) ; if ( offset < length ) { int copies = length / offset ; for ( ; copies > <int> ; copies - - ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , offset ) ; } if ( length % offset ! = <int> ) { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length % offset ) ; } } else { out . readerIndex ( initialIndex - offset ) ; out . readBytes ( out , length ) ; } out . resetReaderIndex ( ) ; return length ; } private static void validateOffset ( int offset , int chunkSizeSoFar ) { if ( offset > Short . MAX_VALUE ) { throw new DecompressionException ( <str> ) ; } if ( offset < = <int> ) { throw new DecompressionException ( <str> ) ; } if ( offset > chunkSizeSoFar ) { throw new DecompressionException ( <str> ) ; } } public static int calculateChecksum ( ByteBuf data ) { return calculateChecksum ( data , data . readerIndex ( ) , data . readableBytes ( ) ) ; } public static int calculateChecksum ( ByteBuf data , int offset , int length ) { Crc32c crc32 = new Crc32c ( ) ; try { if ( data . hasArray ( ) ) { crc32 . update ( data . array ( ) , data . arrayOffset ( ) + offset , length ) ; } else { byte [ ] array = new byte [ length ] ; data . getBytes ( offset , array ) ; crc32 . update ( array , <int> , length ) ; } return maskChecksum ( ( int ) crc32 . getValue ( ) ) ; } finally { crc32 . reset ( ) ; } } static void validateChecksum ( int expectedChecksum , ByteBuf data ) { validateChecksum ( expectedChecksum , data , data . readerIndex ( ) , data . readableBytes ( ) ) ; } static void validateChecksum ( int expectedChecksum , ByteBuf data , int offset , int length ) { final int actualChecksum = calculateChecksum ( data , offset , length ) ; if ( actualChecksum ! = expectedChecksum ) { throw new DecompressionException ( <str> + Integer . toHexString ( actualChecksum ) + <str> + Integer . toHexString ( expectedChecksum ) + <str> ) ; } } static int maskChecksum ( int checksum ) { return ( checksum > > <int> | checksum < < <int> ) + <hex> ; } } 
