package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . util . AsciiString ; import java . net . URI ; import java . nio . ByteBuffer ; public class WebSocketClientHandshaker00 extends WebSocketClientHandshaker { private static final AsciiString WEBSOCKET = new AsciiString ( <str> ) ; private ByteBuf expectedChallengeResponseBytes ; public WebSocketClientHandshaker00 ( URI webSocketURL , WebSocketVersion version , String subprotocol , HttpHeaders customHeaders , int maxFramePayloadLength ) { super ( webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; } @Override protected FullHttpRequest newHandshakeRequest ( ) { int spaces1 = WebSocketUtil . randomNumber ( <int> , <int> ) ; int spaces2 = WebSocketUtil . randomNumber ( <int> , <int> ) ; int max1 = Integer . MAX_VALUE / spaces1 ; int max2 = Integer . MAX_VALUE / spaces2 ; int number1 = WebSocketUtil . randomNumber ( <int> , max1 ) ; int number2 = WebSocketUtil . randomNumber ( <int> , max2 ) ; int product1 = number1 * spaces1 ; int product2 = number2 * spaces2 ; String key1 = Integer . toString ( product1 ) ; String key2 = Integer . toString ( product2 ) ; key1 = insertRandomCharacters ( key1 ) ; key2 = insertRandomCharacters ( key2 ) ; key1 = insertSpaces ( key1 , spaces1 ) ; key2 = insertSpaces ( key2 , spaces2 ) ; byte [ ] key3 = WebSocketUtil . randomBytes ( <int> ) ; ByteBuffer buffer = ByteBuffer . allocate ( <int> ) ; buffer . putInt ( number1 ) ; byte [ ] number1Array = buffer . array ( ) ; buffer = ByteBuffer . allocate ( <int> ) ; buffer . putInt ( number2 ) ; byte [ ] number2Array = buffer . array ( ) ; byte [ ] challenge = new byte [ <int> ] ; System . arraycopy ( number1Array , <int> , challenge , <int> , <int> ) ; System . arraycopy ( number2Array , <int> , challenge , <int> , <int> ) ; System . arraycopy ( key3 , <int> , challenge , <int> , <int> ) ; expectedChallengeResponseBytes = Unpooled . wrappedBuffer ( WebSocketUtil . md5 ( challenge ) ) ; URI wsURL = uri ( ) ; String path = rawPath ( wsURL ) ; FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , path ) ; HttpHeaders headers = request . headers ( ) ; headers . add ( HttpHeaderNames . UPGRADE , WEBSOCKET ) . add ( HttpHeaderNames . CONNECTION , HttpHeaderValues . UPGRADE ) . add ( HttpHeaderNames . HOST , wsURL . getHost ( ) ) ; int wsPort = wsURL . getPort ( ) ; String originValue = <str> + wsURL . getHost ( ) ; if ( wsPort ! = <int> & & wsPort ! = <int> ) { originValue = originValue + <str> + wsPort ; } headers . add ( HttpHeaderNames . ORIGIN , originValue ) . add ( HttpHeaderNames . SEC_WEBSOCKET_KEY1 , key1 ) . add ( HttpHeaderNames . SEC_WEBSOCKET_KEY2 , key2 ) ; String expectedSubprotocol = expectedSubprotocol ( ) ; if ( expectedSubprotocol ! = null & & ! expectedSubprotocol . isEmpty ( ) ) { headers . add ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL , expectedSubprotocol ) ; } if ( customHeaders ! = null ) { headers . add ( customHeaders ) ; } headers . set ( HttpHeaderNames . CONTENT_LENGTH , key3 . length ) ; request . content ( ) . writeBytes ( key3 ) ; return request ; } @Override protected void verify ( FullHttpResponse response ) { final HttpResponseStatus status = new HttpResponseStatus ( <int> , <str> ) ; if ( ! response . status ( ) . equals ( status ) ) { throw new WebSocketHandshakeException ( <str> + response . status ( ) ) ; } HttpHeaders headers = response . headers ( ) ; CharSequence upgrade = headers . get ( HttpHeaderNames . UPGRADE ) ; if ( ! WEBSOCKET . contentEqualsIgnoreCase ( upgrade ) ) { throw new WebSocketHandshakeException ( <str> + upgrade ) ; } CharSequence connection = headers . get ( HttpHeaderNames . CONNECTION ) ; if ( ! HttpHeaderValues . UPGRADE . contentEqualsIgnoreCase ( connection ) ) { throw new WebSocketHandshakeException ( <str> + connection ) ; } ByteBuf challenge = response . content ( ) ; if ( ! challenge . equals ( expectedChallengeResponseBytes ) ) { throw new WebSocketHandshakeException ( <str> ) ; } } private static String insertRandomCharacters ( String key ) { int count = WebSocketUtil . randomNumber ( <int> , <int> ) ; char [ ] randomChars = new char [ count ] ; int randCount = <int> ; while ( randCount < count ) { int rand = ( int ) ( Math . random ( ) * <hex> + <hex> ) ; if ( <hex> < rand & & rand < <hex> | | <hex> < rand & & rand < <hex> ) { randomChars [ randCount ] = ( char ) rand ; randCount + = <int> ; } } for ( int i = <int> ; i < count ; i + + ) { int split = WebSocketUtil . randomNumber ( <int> , key . length ( ) ) ; String part1 = key . substring ( <int> , split ) ; String part2 = key . substring ( split ) ; key = part1 + randomChars [ i ] + part2 ; } return key ; } private static String insertSpaces ( String key , int spaces ) { for ( int i = <int> ; i < spaces ; i + + ) { int split = WebSocketUtil . randomNumber ( <int> , key . length ( ) - <int> ) ; String part1 = key . substring ( <int> , split ) ; String part2 = key . substring ( split ) ; key = part1 + <str> + part2 ; } return key ; } @Override protected WebSocketFrameDecoder newWebsocketDecoder ( ) { return new WebSocket00FrameDecoder ( maxFramePayloadLength ( ) ) ; } @Override protected WebSocketFrameEncoder newWebSocketEncoder ( ) { return new WebSocket00FrameEncoder ( ) ; } } 
