package org . elasticsearch . action . fieldstats ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . ValidateActions ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class FieldStatsRequest extends BroadcastRequest < FieldStatsRequest > { public final static String DEFAULT_LEVEL = <str> ; private String [ ] fields = Strings . EMPTY_ARRAY ; private String level = DEFAULT_LEVEL ; private IndexConstraint [ ] indexConstraints = new IndexConstraint [ <int> ] ; public String [ ] getFields ( ) { return fields ; } public void setFields ( String [ ] fields ) { if ( fields = = null ) { throw new NullPointerException ( <str> ) ; } this . fields = fields ; } public IndexConstraint [ ] getIndexConstraints ( ) { return indexConstraints ; } public void setIndexConstraints ( IndexConstraint [ ] indexConstraints ) { if ( indexConstraints = = null ) { throw new NullPointerException ( <str> ) ; } this . indexConstraints = indexConstraints ; } public void source ( BytesReference content ) throws IOException { List < IndexConstraint > indexConstraints = new ArrayList < > ( ) ; List < String > fields = new ArrayList < > ( ) ; try ( XContentParser parser = XContentHelper . createParser ( content ) ) { String fieldName = null ; Token token = parser . nextToken ( ) ; assert token = = Token . START_OBJECT ; for ( token = parser . nextToken ( ) ; token ! = Token . END_OBJECT ; token = parser . nextToken ( ) ) { switch ( token ) { case FIELD_NAME : fieldName = parser . currentName ( ) ; break ; case START_OBJECT : if ( <str> . equals ( fieldName ) ) { parseIndexContraints ( indexConstraints , parser ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } break ; case START_ARRAY : if ( <str> . equals ( fieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token . isValue ( ) ) { fields . add ( parser . text ( ) ) ; } else { throw new IllegalArgumentException ( <str> + token + <str> ) ; } } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } break ; default : throw new IllegalArgumentException ( <str> + token + <str> ) ; } } } this . fields = fields . toArray ( new String [ fields . size ( ) ] ) ; this . indexConstraints = indexConstraints . toArray ( new IndexConstraint [ indexConstraints . size ( ) ] ) ; } private void parseIndexContraints ( List < IndexConstraint > indexConstraints , XContentParser parser ) throws IOException { Token token = parser . currentToken ( ) ; assert token = = Token . START_OBJECT ; String field = null ; String currentName = null ; for ( token = parser . nextToken ( ) ; token ! = Token . END_OBJECT ; token = parser . nextToken ( ) ) { if ( token = = Token . FIELD_NAME ) { field = currentName = parser . currentName ( ) ; } else if ( token = = Token . START_OBJECT ) { for ( Token fieldToken = parser . nextToken ( ) ; fieldToken ! = Token . END_OBJECT ; fieldToken = parser . nextToken ( ) ) { if ( fieldToken = = Token . FIELD_NAME ) { currentName = parser . currentName ( ) ; } else if ( fieldToken = = Token . START_OBJECT ) { IndexConstraint . Property property = IndexConstraint . Property . parse ( currentName ) ; String value = null ; String optionalFormat = null ; IndexConstraint . Comparison comparison = null ; for ( Token propertyToken = parser . nextToken ( ) ; propertyToken ! = Token . END_OBJECT ; propertyToken = parser . nextToken ( ) ) { if ( propertyToken . isValue ( ) ) { if ( <str> . equals ( parser . currentName ( ) ) ) { optionalFormat = parser . text ( ) ; } else { comparison = IndexConstraint . Comparison . parse ( parser . currentName ( ) ) ; value = parser . text ( ) ; } } else { if ( propertyToken ! = Token . FIELD_NAME ) { throw new IllegalArgumentException ( <str> + propertyToken + <str> ) ; } } } indexConstraints . add ( new IndexConstraint ( field , property , comparison , value , optionalFormat ) ) ; } else { throw new IllegalArgumentException ( <str> + fieldToken + <str> ) ; } } } else { throw new IllegalArgumentException ( <str> + token + <str> ) ; } } } public String level ( ) { return level ; } public void level ( String level ) { this . level = level ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = super . validate ( ) ; if ( <str> . equals ( level ) = = false & & <str> . equals ( level ) = = false ) { validationException = ValidateActions . addValidationError ( <str> + level + <str> , validationException ) ; } if ( fields = = null | | fields . length = = <int> ) { validationException = ValidateActions . addValidationError ( <str> , validationException ) ; } return validationException ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; fields = in . readStringArray ( ) ; int size = in . readVInt ( ) ; indexConstraints = new IndexConstraint [ size ] ; for ( int i = <int> ; i < size ; i + + ) { indexConstraints [ i ] = new IndexConstraint ( in ) ; } level = in . readString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeStringArrayNullable ( fields ) ; out . writeVInt ( indexConstraints . length ) ; for ( IndexConstraint indexConstraint : indexConstraints ) { out . writeString ( indexConstraint . getField ( ) ) ; out . writeByte ( indexConstraint . getProperty ( ) . getId ( ) ) ; out . writeByte ( indexConstraint . getComparison ( ) . getId ( ) ) ; out . writeString ( indexConstraint . getValue ( ) ) ; if ( out . getVersion ( ) . onOrAfter ( Version . V_2_0_1 ) ) { out . writeOptionalString ( indexConstraint . getOptionalFormat ( ) ) ; } } out . writeString ( level ) ; } } 
