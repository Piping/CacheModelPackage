package org . apache . cassandra . stress . settings ; import java . io . Serializable ; import java . util . * ; import com . datastax . driver . core . Metadata ; import com . google . common . collect . ImmutableMap ; import org . apache . cassandra . config . EncryptionOptions ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . stress . util . SimpleThriftClient ; import org . apache . cassandra . stress . util . SmartThriftClient ; import org . apache . cassandra . stress . util . ThriftClient ; import org . apache . cassandra . thrift . AuthenticationRequest ; import org . apache . cassandra . thrift . Cassandra ; import org . apache . cassandra . thrift . InvalidRequestException ; import org . apache . cassandra . transport . SimpleClient ; import org . apache . thrift . protocol . TBinaryProtocol ; import org . apache . thrift . transport . TTransport ; public class StressSettings implements Serializable { public final SettingsCommand command ; public final SettingsRate rate ; public final SettingsPopulation generate ; public final SettingsInsert insert ; public final SettingsColumn columns ; public final SettingsSamples samples ; public final SettingsErrors errors ; public final SettingsLog log ; public final SettingsMode mode ; public final SettingsNode node ; public final SettingsSchema schema ; public final SettingsTransport transport ; public final SettingsPort port ; public final String sendToDaemon ; public final SettingsGraph graph ; public StressSettings ( SettingsCommand command , SettingsRate rate , SettingsPopulation generate , SettingsInsert insert , SettingsColumn columns , SettingsSamples samples , SettingsErrors errors , SettingsLog log , SettingsMode mode , SettingsNode node , SettingsSchema schema , SettingsTransport transport , SettingsPort port , String sendToDaemon , SettingsGraph graph ) { this . command = command ; this . rate = rate ; this . insert = insert ; this . generate = generate ; this . columns = columns ; this . samples = samples ; this . errors = errors ; this . log = log ; this . mode = mode ; this . node = node ; this . schema = schema ; this . transport = transport ; this . port = port ; this . sendToDaemon = sendToDaemon ; this . graph = graph ; } private SmartThriftClient tclient ; public synchronized ThriftClient getThriftClient ( ) { if ( mode . api ! = ConnectionAPI . THRIFT_SMART ) return getSimpleThriftClient ( ) ; if ( tclient = = null ) tclient = getSmartThriftClient ( ) ; return tclient ; } private SmartThriftClient getSmartThriftClient ( ) { Metadata metadata = getJavaDriverClient ( ) . getCluster ( ) . getMetadata ( ) ; return new SmartThriftClient ( this , schema . keyspace , metadata ) ; } private SimpleThriftClient getSimpleThriftClient ( ) { return new SimpleThriftClient ( getRawThriftClient ( node . randomNode ( ) , true ) ) ; } public Cassandra . Client getRawThriftClient ( boolean setKeyspace ) { return getRawThriftClient ( node . randomNode ( ) , setKeyspace ) ; } public Cassandra . Client getRawThriftClient ( String host ) { return getRawThriftClient ( host , true ) ; } public Cassandra . Client getRawThriftClient ( String host , boolean setKeyspace ) { Cassandra . Client client ; try { TTransport transport = this . transport . getFactory ( ) . openTransport ( host , port . thriftPort ) ; client = new Cassandra . Client ( new TBinaryProtocol ( transport ) ) ; if ( mode . cqlVersion . isCql ( ) ) client . set_cql_version ( mode . cqlVersion . connectVersion ) ; if ( setKeyspace ) client . set_keyspace ( schema . keyspace ) ; if ( mode . username ! = null ) client . login ( new AuthenticationRequest ( ImmutableMap . of ( <str> , mode . username , <str> , mode . password ) ) ) ; } catch ( InvalidRequestException e ) { throw new RuntimeException ( e . getWhy ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return client ; } public SimpleClient getSimpleNativeClient ( ) { try { String currentNode = node . randomNode ( ) ; SimpleClient client = new SimpleClient ( currentNode , port . nativePort ) ; client . connect ( false ) ; client . execute ( <str> + schema . keyspace + <str> , org . apache . cassandra . db . ConsistencyLevel . ONE ) ; return client ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } private static volatile JavaDriverClient client ; public JavaDriverClient getJavaDriverClient ( ) { return getJavaDriverClient ( true ) ; } public JavaDriverClient getJavaDriverClient ( boolean setKeyspace ) { if ( client ! = null ) return client ; try { synchronized ( this ) { String currentNode = node . randomNode ( ) ; if ( client ! = null ) return client ; EncryptionOptions . ClientEncryptionOptions encOptions = transport . getEncryptionOptions ( ) ; JavaDriverClient c = new JavaDriverClient ( this , currentNode , port . nativePort , encOptions ) ; c . connect ( mode . compression ( ) ) ; if ( setKeyspace ) c . execute ( <str> + schema . keyspace + <str> , org . apache . cassandra . db . ConsistencyLevel . ONE ) ; return client = c ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public void maybeCreateKeyspaces ( ) { if ( command . type = = Command . WRITE | | command . type = = Command . COUNTER_WRITE ) schema . createKeySpaces ( this ) ; else if ( command . type = = Command . USER ) ( ( SettingsCommandUser ) command ) . profile . maybeCreateSchema ( this ) ; } public static StressSettings parse ( String [ ] args ) { try { args = repairParams ( args ) ; final Map < String , String [ ] > clArgs = parseMap ( args ) ; if ( clArgs . containsKey ( <str> ) ) return Legacy . build ( Arrays . copyOfRange ( args , <int> , args . length ) ) ; if ( SettingsMisc . maybeDoSpecial ( clArgs ) ) System . exit ( <int> ) ; return get ( clArgs ) ; } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ( ) ) ; System . exit ( <int> ) ; throw new AssertionError ( ) ; } } private static String [ ] repairParams ( String [ ] args ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String arg : args ) { if ( ! first ) sb . append ( <str> ) ; sb . append ( arg ) ; first = false ; } return sb . toString ( ) . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) . split ( <str> ) ; } public static StressSettings get ( Map < String , String [ ] > clArgs ) { SettingsCommand command = SettingsCommand . get ( clArgs ) ; if ( command = = null ) throw new IllegalArgumentException ( <str> ) ; String sendToDaemon = SettingsMisc . getSendToDaemon ( clArgs ) ; SettingsPort port = SettingsPort . get ( clArgs ) ; SettingsRate rate = SettingsRate . get ( clArgs , command ) ; SettingsPopulation generate = SettingsPopulation . get ( clArgs , command ) ; SettingsInsert insert = SettingsInsert . get ( clArgs ) ; SettingsColumn columns = SettingsColumn . get ( clArgs ) ; SettingsSamples samples = SettingsSamples . get ( clArgs ) ; SettingsErrors errors = SettingsErrors . get ( clArgs ) ; SettingsLog log = SettingsLog . get ( clArgs ) ; SettingsMode mode = SettingsMode . get ( clArgs ) ; SettingsNode node = SettingsNode . get ( clArgs ) ; SettingsSchema schema = SettingsSchema . get ( clArgs , command ) ; SettingsTransport transport = SettingsTransport . get ( clArgs ) ; SettingsGraph graph = SettingsGraph . get ( clArgs , command ) ; if ( ! clArgs . isEmpty ( ) ) { printHelp ( ) ; System . out . println ( <str> ) ; for ( Map . Entry < String , String [ ] > e : clArgs . entrySet ( ) ) { System . out . print ( e . getKey ( ) ) ; for ( String v : e . getValue ( ) ) { System . out . print ( <str> ) ; System . out . print ( v ) ; } System . out . println ( ) ; } System . exit ( <int> ) ; } return new StressSettings ( command , rate , generate , insert , columns , samples , errors , log , mode , node , schema , transport , port , sendToDaemon , graph ) ; } private static Map < String , String [ ] > parseMap ( String [ ] args ) { if ( args . length = = <int> ) { System . out . println ( <str> ) ; printHelp ( ) ; System . exit ( <int> ) ; } final LinkedHashMap < String , String [ ] > r = new LinkedHashMap < > ( ) ; String key = null ; List < String > params = new ArrayList < > ( ) ; for ( int i = <int> ; i < args . length ; i + + ) { if ( i = = <int> | | args [ i ] . startsWith ( <str> ) ) { if ( i > <int> ) putParam ( key , params . toArray ( new String [ <int> ] ) , r ) ; key = args [ i ] . toLowerCase ( ) ; params . clear ( ) ; } else params . add ( args [ i ] ) ; } putParam ( key , params . toArray ( new String [ <int> ] ) , r ) ; return r ; } private static void putParam ( String key , String [ ] args , Map < String , String [ ] > clArgs ) { String [ ] prev = clArgs . put ( key , args ) ; if ( prev ! = null ) throw new IllegalArgumentException ( key + <str> ) ; } public static void printHelp ( ) { SettingsMisc . printHelp ( ) ; } public synchronized void disconnect ( ) { if ( client = = null ) return ; client . disconnect ( ) ; client = null ; } } 
