package org . apache . cassandra . utils . btree ; import java . util . * ; import com . google . common . base . Function ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import org . apache . cassandra . utils . ObjectSizes ; import static com . google . common . collect . Iterables . concat ; import static com . google . common . collect . Iterables . filter ; import static com . google . common . collect . Iterables . transform ; import static java . lang . Math . max ; import static java . lang . Math . min ; public class BTree { static final int FAN_SHIFT ; static { int fanfactor = <int> ; if ( System . getProperty ( <str> ) ! = null ) fanfactor = Integer . parseInt ( System . getProperty ( <str> ) ) ; int shift = <int> ; while ( <int> < < shift < fanfactor ) shift + = <int> ; FAN_SHIFT = shift ; } static final int FAN_FACTOR = <int> < < FAN_SHIFT ; static final Object [ ] EMPTY_LEAF = new Object [ <int> ] ; static final Object [ ] EMPTY_BRANCH = new Object [ ] { null , new int [ <int> ] } ; public static enum Dir { ASC , DESC ; public Dir invert ( ) { return this = = ASC ? DESC : ASC ; } public static Dir asc ( boolean asc ) { return asc ? ASC : DESC ; } public static Dir desc ( boolean desc ) { return desc ? DESC : ASC ; } } public static Object [ ] empty ( ) { return EMPTY_LEAF ; } public static Object [ ] singleton ( Object value ) { return new Object [ ] { value } ; } public static < C , K extends C , V extends C > Object [ ] build ( Collection < K > source , UpdateFunction < K , V > updateF ) { return buildInternal ( source , source . size ( ) , updateF ) ; } public static < C , K extends C , V extends C > Object [ ] build ( Iterable < K > source , UpdateFunction < K , V > updateF ) { return buildInternal ( source , - <int> , updateF ) ; } public static < C , K extends C , V extends C > Object [ ] build ( Iterable < K > source , int size , UpdateFunction < K , V > updateF ) { if ( size < <int> ) throw new IllegalArgumentException ( Integer . toString ( size ) ) ; return buildInternal ( source , size , updateF ) ; } private static < C , K extends C , V extends C > Object [ ] buildInternal ( Iterable < K > source , int size , UpdateFunction < K , V > updateF ) { if ( ( size > = <int> ) & ( size < FAN_FACTOR ) ) { if ( size = = <int> ) return EMPTY_LEAF ; V [ ] values = ( V [ ] ) new Object [ size | <int> ] ; { int i = <int> ; for ( K k : source ) values [ i + + ] = updateF . apply ( k ) ; } updateF . allocated ( ObjectSizes . sizeOfArray ( values ) ) ; return values ; } Queue < TreeBuilder > queue = modifier . get ( ) ; TreeBuilder builder = queue . poll ( ) ; if ( builder = = null ) builder = new TreeBuilder ( ) ; Object [ ] btree = builder . build ( source , updateF , size ) ; queue . add ( builder ) ; return btree ; } public static < C , K extends C , V extends C > Object [ ] update ( Object [ ] btree , Comparator < C > comparator , Collection < K > updateWith , UpdateFunction < K , V > updateF ) { return update ( btree , comparator , updateWith , updateWith . size ( ) , updateF ) ; } public static < C , K extends C , V extends C > Object [ ] update ( Object [ ] btree , Comparator < C > comparator , Iterable < K > updateWith , int updateWithLength , UpdateFunction < K , V > updateF ) { if ( isEmpty ( btree ) ) return build ( updateWith , updateWithLength , updateF ) ; Queue < TreeBuilder > queue = modifier . get ( ) ; TreeBuilder builder = queue . poll ( ) ; if ( builder = = null ) builder = new TreeBuilder ( ) ; btree = builder . update ( btree , comparator , updateWith , updateF ) ; queue . add ( builder ) ; return btree ; } public static < K > Object [ ] merge ( Object [ ] tree1 , Object [ ] tree2 , Comparator < ? super K > comparator , UpdateFunction < K , K > updateF ) { if ( size ( tree1 ) < size ( tree2 ) ) { Object [ ] tmp = tree1 ; tree1 = tree2 ; tree2 = tmp ; } return update ( tree1 , comparator , new BTreeSet < K > ( tree2 , comparator ) , updateF ) ; } public static < V > Iterator < V > iterator ( Object [ ] btree ) { return iterator ( btree , Dir . ASC ) ; } public static < V > Iterator < V > iterator ( Object [ ] btree , Dir dir ) { return new BTreeSearchIterator < V , V > ( btree , null , dir ) ; } public static < V > Iterator < V > iterator ( Object [ ] btree , int lb , int ub , Dir dir ) { return new BTreeSearchIterator < V , V > ( btree , null , dir , lb , ub ) ; } public static < V > Iterable < V > iterable ( Object [ ] btree ) { return iterable ( btree , Dir . ASC ) ; } public static < V > Iterable < V > iterable ( Object [ ] btree , Dir dir ) { return ( ) - > iterator ( btree , dir ) ; } public static < V > Iterable < V > iterable ( Object [ ] btree , int lb , int ub , Dir dir ) { return ( ) - > iterator ( btree , lb , ub , dir ) ; } public static < K , V > BTreeSearchIterator < K , V > slice ( Object [ ] btree , Comparator < ? super K > comparator , Dir dir ) { return new BTreeSearchIterator < > ( btree , comparator , dir ) ; } public static < K , V extends K > BTreeSearchIterator < K , V > slice ( Object [ ] btree , Comparator < ? super K > comparator , K start , K end , Dir dir ) { return slice ( btree , comparator , start , true , end , false , dir ) ; } public static < K , V extends K > BTreeSearchIterator < K , V > slice ( Object [ ] btree , Comparator < ? super K > comparator , K start , boolean startInclusive , K end , boolean endInclusive , Dir dir ) { int inclusiveLowerBound = max ( <int> , start = = null ? Integer . MIN_VALUE : startInclusive ? ceilIndex ( btree , comparator , start ) : higherIndex ( btree , comparator , start ) ) ; int inclusiveUpperBound = min ( size ( btree ) - <int> , end = = null ? Integer . MAX_VALUE : endInclusive ? floorIndex ( btree , comparator , end ) : lowerIndex ( btree , comparator , end ) ) ; return new BTreeSearchIterator < > ( btree , comparator , dir , inclusiveLowerBound , inclusiveUpperBound ) ; } public static < V > V find ( Object [ ] node , Comparator < ? super V > comparator , V find ) { while ( true ) { int keyEnd = getKeyEnd ( node ) ; int i = Arrays . binarySearch ( ( V [ ] ) node , <int> , keyEnd , find , comparator ) ; if ( i > = <int> ) return ( V ) node [ i ] ; if ( isLeaf ( node ) ) return null ; i = - <int> - i ; node = ( Object [ ] ) node [ keyEnd + i ] ; } } public static < V > void replaceInSitu ( Object [ ] node , Comparator < ? super V > comparator , V find , V replace ) { while ( true ) { int keyEnd = getKeyEnd ( node ) ; int i = Arrays . binarySearch ( ( V [ ] ) node , <int> , keyEnd , find , comparator ) ; if ( i > = <int> ) { assert find = = node [ i ] ; node [ i ] = replace ; return ; } if ( isLeaf ( node ) ) throw new NoSuchElementException ( ) ; i = - <int> - i ; node = ( Object [ ] ) node [ keyEnd + i ] ; } } public static < V > int findIndex ( Object [ ] node , Comparator < ? super V > comparator , V find ) { int lb = <int> ; while ( true ) { int keyEnd = getKeyEnd ( node ) ; int i = Arrays . binarySearch ( ( V [ ] ) node , <int> , keyEnd , find , comparator ) ; boolean exact = i > = <int> ; if ( isLeaf ( node ) ) return exact ? lb + i : i - lb ; if ( ! exact ) i = - <int> - i ; int [ ] sizeMap = getSizeMap ( node ) ; if ( exact ) return lb + sizeMap [ i ] ; else if ( i > <int> ) lb + = sizeMap [ i - <int> ] + <int> ; node = ( Object [ ] ) node [ keyEnd + i ] ; } } public static < V > V findByIndex ( Object [ ] tree , int index ) { if ( ( index < <int> ) | ( index > = size ( tree ) ) ) throw new IndexOutOfBoundsException ( index + <str> + size ( tree ) + <str> ) ; Object [ ] node = tree ; while ( true ) { if ( isLeaf ( node ) ) { int keyEnd = getLeafKeyEnd ( node ) ; assert index < keyEnd ; return ( V ) node [ index ] ; } int [ ] sizeMap = getSizeMap ( node ) ; int boundary = Arrays . binarySearch ( sizeMap , index ) ; if ( boundary > = <int> ) { assert boundary < sizeMap . length - <int> ; return ( V ) node [ boundary ] ; } boundary = - <int> - boundary ; if ( boundary > <int> ) { assert boundary < sizeMap . length ; index - = ( <int> + sizeMap [ boundary - <int> ] ) ; } node = ( Object [ ] ) node [ getChildStart ( node ) + boundary ] ; } } public static < V > int lowerIndex ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = findIndex ( btree , comparator , find ) ; if ( i < <int> ) i = - <int> - i ; return i - <int> ; } public static < V > V lower ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = lowerIndex ( btree , comparator , find ) ; return i > = <int> ? findByIndex ( btree , i ) : null ; } public static < V > int floorIndex ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = findIndex ( btree , comparator , find ) ; if ( i < <int> ) i = - <int> - i ; return i ; } public static < V > V floor ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = floorIndex ( btree , comparator , find ) ; return i > = <int> ? findByIndex ( btree , i ) : null ; } public static < V > int higherIndex ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = findIndex ( btree , comparator , find ) ; if ( i < <int> ) i = - <int> - i ; else i + + ; return i ; } public static < V > V higher ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = higherIndex ( btree , comparator , find ) ; return i < size ( btree ) ? findByIndex ( btree , i ) : null ; } public static < V > int ceilIndex ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = findIndex ( btree , comparator , find ) ; if ( i < <int> ) i = - <int> - i ; return i ; } public static < V > V ceil ( Object [ ] btree , Comparator < ? super V > comparator , V find ) { int i = ceilIndex ( btree , comparator , find ) ; return i < size ( btree ) ? findByIndex ( btree , i ) : null ; } static int getKeyEnd ( Object [ ] node ) { if ( isLeaf ( node ) ) return getLeafKeyEnd ( node ) ; else return getBranchKeyEnd ( node ) ; } static int getLeafKeyEnd ( Object [ ] node ) { int len = node . length ; return node [ len - <int> ] = = null ? len - <int> : len ; } static int getBranchKeyEnd ( Object [ ] branchNode ) { return ( branchNode . length / <int> ) - <int> ; } static int getChildStart ( Object [ ] branchNode ) { return getBranchKeyEnd ( branchNode ) ; } static int getChildEnd ( Object [ ] branchNode ) { return branchNode . length - <int> ; } static int getChildCount ( Object [ ] branchNode ) { return branchNode . length / <int> ; } static int [ ] getSizeMap ( Object [ ] branchNode ) { return ( int [ ] ) branchNode [ getChildEnd ( branchNode ) ] ; } static int lookupSizeMap ( Object [ ] branchNode , int index ) { return getSizeMap ( branchNode ) [ index ] ; } public static int size ( Object [ ] tree ) { if ( isLeaf ( tree ) ) return getLeafKeyEnd ( tree ) ; int length = tree . length ; return ( ( int [ ] ) tree [ length - <int> ] ) [ ( length / <int> ) - <int> ] ; } public static long sizeOfStructureOnHeap ( Object [ ] tree ) { long size = ObjectSizes . sizeOfArray ( tree ) ; if ( isLeaf ( tree ) ) return size ; for ( int i = getChildStart ( tree ) ; i < getChildEnd ( tree ) ; i + + ) size + = sizeOfStructureOnHeap ( ( Object [ ] ) tree [ i ] ) ; return size ; } static boolean isLeaf ( Object [ ] node ) { return ( node . length & <int> ) = = <int> ; } public static boolean isEmpty ( Object [ ] tree ) { return tree = = EMPTY_LEAF ; } public static int depth ( Object [ ] tree ) { int depth = <int> ; while ( ! isLeaf ( tree ) ) { depth + + ; tree = ( Object [ ] ) tree [ getKeyEnd ( tree ) ] ; } return depth ; } public static int toArray ( Object [ ] tree , Object [ ] target , int targetOffset ) { return toArray ( tree , <int> , size ( tree ) , target , targetOffset ) ; } public static int toArray ( Object [ ] tree , int treeStart , int treeEnd , Object [ ] target , int targetOffset ) { if ( isLeaf ( tree ) ) { int count = treeEnd - treeStart ; System . arraycopy ( tree , treeStart , target , targetOffset , count ) ; return count ; } int newTargetOffset = targetOffset ; int childCount = getChildCount ( tree ) ; int childOffset = getChildStart ( tree ) ; for ( int i = <int> ; i < childCount ; i + + ) { int childStart = treeIndexOffsetOfChild ( tree , i ) ; int childEnd = treeIndexOfBranchKey ( tree , i ) ; if ( childStart < = treeEnd & & childEnd > = treeStart ) { newTargetOffset + = toArray ( ( Object [ ] ) tree [ childOffset + i ] , max ( <int> , treeStart - childStart ) , min ( childEnd , treeEnd ) - childStart , target , newTargetOffset ) ; if ( treeStart < = childEnd & & treeEnd > childEnd ) target [ newTargetOffset + + ] = tree [ i ] ; } } return newTargetOffset - targetOffset ; } private static class FiltrationTracker < V > implements Function < V , V > { final Function < ? super V , ? extends V > wrapped ; int index ; boolean failed ; private FiltrationTracker ( Function < ? super V , ? extends V > wrapped ) { this . wrapped = wrapped ; } public V apply ( V i ) { V o = wrapped . apply ( i ) ; if ( o ! = null ) index + + ; else failed = true ; return o ; } } public static < V > Object [ ] transformAndFilter ( Object [ ] btree , Function < ? super V , ? extends V > function ) { if ( isEmpty ( btree ) ) return btree ; FiltrationTracker < V > wrapped = new FiltrationTracker < > ( function ) ; Object [ ] result = transformAndFilter ( btree , wrapped ) ; if ( ! wrapped . failed ) return result ; Iterable < V > head = iterable ( result , <int> , wrapped . index - <int> , Dir . ASC ) ; Iterable < V > remainder = iterable ( btree , wrapped . index + <int> , size ( btree ) - <int> , Dir . ASC ) ; remainder = filter ( transform ( remainder , function ) , ( x ) - > x ! = null ) ; Iterable < V > build = concat ( head , remainder ) ; return buildInternal ( build , - <int> , UpdateFunction . < V > noOp ( ) ) ; } private static < V > Object [ ] transformAndFilter ( Object [ ] btree , FiltrationTracker < V > function ) { Object [ ] result = btree ; boolean isLeaf = isLeaf ( btree ) ; int childOffset = isLeaf ? Integer . MAX_VALUE : getChildStart ( btree ) ; int limit = isLeaf ? getLeafKeyEnd ( btree ) : btree . length - <int> ; for ( int i = <int> ; i < limit ; i + + ) { int idx = isLeaf ? i : ( i / <int> ) + ( i % <int> = = <int> ? childOffset : <int> ) ; Object current = btree [ idx ] ; Object updated = idx < childOffset ? function . apply ( ( V ) current ) : transformAndFilter ( ( Object [ ] ) current , function ) ; if ( updated ! = current ) { if ( result = = btree ) result = btree . clone ( ) ; result [ idx ] = updated ; } if ( function . failed ) return result ; } return result ; } public static boolean equals ( Object [ ] a , Object [ ] b ) { return size ( a ) = = size ( b ) & & Iterators . elementsEqual ( iterator ( a ) , iterator ( b ) ) ; } public static int hashCode ( Object [ ] btree ) { int result = <int> ; for ( Object v : iterable ( btree ) ) result = <int> * result + Objects . hashCode ( v ) ; return result ; } public static int treeIndexOfKey ( Object [ ] root , int keyIndex ) { if ( isLeaf ( root ) ) return keyIndex ; int [ ] sizeMap = getSizeMap ( root ) ; if ( ( keyIndex > = <int> ) & ( keyIndex < sizeMap . length ) ) return sizeMap [ keyIndex ] ; if ( keyIndex < <int> ) return - <int> ; return sizeMap [ keyIndex - <int> ] + <int> ; } public static int treeIndexOfLeafKey ( int keyIndex ) { return keyIndex ; } public static int treeIndexOfBranchKey ( Object [ ] root , int keyIndex ) { return lookupSizeMap ( root , keyIndex ) ; } public static int treeIndexOffsetOfChild ( Object [ ] root , int childIndex ) { if ( childIndex = = <int> ) return <int> ; return <int> + lookupSizeMap ( root , childIndex - <int> ) ; } private static final ThreadLocal < Queue < TreeBuilder > > modifier = new ThreadLocal < Queue < TreeBuilder > > ( ) { @Override protected Queue < TreeBuilder > initialValue ( ) { return new ArrayDeque < > ( ) ; } } ; public static < V > Builder < V > builder ( Comparator < ? super V > comparator ) { return new Builder < > ( comparator ) ; } public static < V > Builder < V > builder ( Comparator < ? super V > comparator , int initialCapacity ) { return new Builder < > ( comparator ) ; } public static class Builder < V > { public static interface Resolver { Object resolve ( Object [ ] array , int lb , int ub ) ; } public static interface QuickResolver < V > { V resolve ( V a , V b ) ; } Comparator < ? super V > comparator ; Object [ ] values ; int count ; boolean detected = true ; boolean auto = true ; QuickResolver < V > quickResolver ; protected Builder ( Comparator < ? super V > comparator ) { this ( comparator , <int> ) ; } protected Builder ( Comparator < ? super V > comparator , int initialCapacity ) { this . comparator = comparator ; this . values = new Object [ initialCapacity ] ; } public Builder < V > setQuickResolver ( QuickResolver < V > quickResolver ) { this . quickResolver = quickResolver ; return this ; } public void reuse ( ) { reuse ( comparator ) ; } public void reuse ( Comparator < ? super V > comparator ) { this . comparator = comparator ; count = <int> ; detected = true ; } public Builder < V > auto ( boolean auto ) { this . auto = auto ; return this ; } public Builder < V > add ( V v ) { if ( count = = values . length ) values = Arrays . copyOf ( values , count * <int> ) ; Object [ ] values = this . values ; int prevCount = this . count + + ; values [ prevCount ] = v ; if ( auto & & detected & & prevCount > <int> ) { V prev = ( V ) values [ prevCount - <int> ] ; int c = comparator . compare ( prev , v ) ; if ( c = = <int> & & auto ) { count = prevCount ; if ( quickResolver ! = null ) values [ prevCount - <int> ] = quickResolver . resolve ( prev , v ) ; } else if ( c > <int> ) { detected = false ; } } return this ; } public Builder < V > addAll ( Collection < V > add ) { if ( auto & & add instanceof SortedSet & & equalComparators ( comparator , ( ( SortedSet ) add ) . comparator ( ) ) ) { return mergeAll ( add , add . size ( ) ) ; } detected = false ; if ( values . length < count + add . size ( ) ) values = Arrays . copyOf ( values , max ( count + add . size ( ) , count * <int> ) ) ; for ( V v : add ) values [ count + + ] = v ; return this ; } private static boolean equalComparators ( Comparator < ? > a , Comparator < ? > b ) { return a = = b | | ( isNaturalComparator ( a ) & & isNaturalComparator ( b ) ) ; } private static boolean isNaturalComparator ( Comparator < ? > a ) { return a = = null | | a = = Comparator . naturalOrder ( ) | | a = = Ordering . natural ( ) ; } private Builder < V > mergeAll ( Iterable < V > add , int addCount ) { assert auto ; autoEnforce ( ) ; int curCount = count ; if ( values . length < curCount * <int> + addCount ) values = Arrays . copyOf ( values , max ( curCount * <int> + addCount , curCount * <int> ) ) ; if ( add instanceof BTreeSet ) { ( ( BTreeSet ) add ) . toArray ( values , curCount ) ; } else { int i = curCount ; for ( V v : add ) values [ i + + ] = v ; } return mergeAll ( addCount ) ; } private Builder < V > mergeAll ( int addCount ) { Object [ ] a = values ; int addOffset = count ; int i = <int> , j = addOffset ; int curEnd = addOffset , addEnd = addOffset + addCount ; while ( i < curEnd & & j < addEnd ) { V ai = ( V ) a [ i ] , aj = ( V ) a [ j ] ; int c = ai = = aj ? <int> : comparator . compare ( ai , aj ) ; if ( c > <int> ) break ; else if ( c = = <int> ) { if ( quickResolver ! = null ) a [ i ] = quickResolver . resolve ( ai , aj ) ; j + + ; } i + + ; } if ( j = = addEnd ) return this ; int newCount = i ; System . arraycopy ( a , i , a , addEnd , count - i ) ; curEnd = addEnd + ( count - i ) ; i = addEnd ; while ( i < curEnd & & j < addEnd ) { V ai = ( V ) a [ i ] ; V aj = ( V ) a [ j ] ; int c = comparator . compare ( ai , aj ) ; if ( c = = <int> ) { Object newValue = quickResolver = = null ? ai : quickResolver . resolve ( ai , aj ) ; a [ newCount + + ] = newValue ; i + + ; j + + ; } else { a [ newCount + + ] = c < <int> ? a [ i + + ] : a [ j + + ] ; } } if ( i < curEnd ) { System . arraycopy ( a , i , a , newCount , curEnd - i ) ; newCount + = curEnd - i ; } else if ( j < addEnd ) { if ( j ! = newCount ) System . arraycopy ( a , j , a , newCount , addEnd - j ) ; newCount + = addEnd - j ; } count = newCount ; return this ; } public boolean isEmpty ( ) { return count = = <int> ; } public Builder < V > reverse ( ) { assert ! auto ; int mid = count / <int> ; for ( int i = <int> ; i < mid ; i + + ) { Object t = values [ i ] ; values [ i ] = values [ count - ( <int> + i ) ] ; values [ count - ( <int> + i ) ] = t ; } return this ; } public Builder < V > sort ( ) { Arrays . sort ( ( V [ ] ) values , <int> , count , comparator ) ; return this ; } private void autoEnforce ( ) { if ( ! detected & & count > <int> ) { sort ( ) ; int prevIdx = <int> ; V prev = ( V ) values [ <int> ] ; for ( int i = <int> ; i < count ; i + + ) { V next = ( V ) values [ i ] ; if ( comparator . compare ( prev , next ) ! = <int> ) values [ + + prevIdx ] = prev = next ; else if ( quickResolver ! = null ) values [ prevIdx ] = prev = quickResolver . resolve ( prev , next ) ; } count = prevIdx + <int> ; } detected = true ; } public Builder < V > resolve ( Resolver resolver ) { if ( count > <int> ) { int c = <int> ; int prev = <int> ; for ( int i = <int> ; i < count ; i + + ) { if ( comparator . compare ( ( V ) values [ i ] , ( V ) values [ prev ] ) ! = <int> ) { values [ c + + ] = resolver . resolve ( ( V [ ] ) values , prev , i ) ; prev = i ; } } values [ c + + ] = resolver . resolve ( ( V [ ] ) values , prev , count ) ; count = c ; } return this ; } public Object [ ] build ( ) { if ( auto ) autoEnforce ( ) ; return BTree . build ( Arrays . asList ( values ) . subList ( <int> , count ) , UpdateFunction . noOp ( ) ) ; } } static < V > int compare ( Comparator < V > cmp , Object a , Object b ) { if ( a = = b ) return <int> ; if ( a = = NEGATIVE_INFINITY | b = = POSITIVE_INFINITY ) return - <int> ; if ( b = = NEGATIVE_INFINITY | a = = POSITIVE_INFINITY ) return <int> ; return cmp . compare ( ( V ) a , ( V ) b ) ; } static Object POSITIVE_INFINITY = new Object ( ) ; static Object NEGATIVE_INFINITY = new Object ( ) ; public static boolean isWellFormed ( Object [ ] btree , Comparator < ? extends Object > cmp ) { return isWellFormed ( cmp , btree , true , NEGATIVE_INFINITY , POSITIVE_INFINITY ) ; } private static boolean isWellFormed ( Comparator < ? > cmp , Object [ ] node , boolean isRoot , Object min , Object max ) { if ( cmp ! = null & & ! isNodeWellFormed ( cmp , node , min , max ) ) return false ; if ( isLeaf ( node ) ) { if ( isRoot ) return node . length < = FAN_FACTOR + <int> ; return node . length > = FAN_FACTOR / <int> & & node . length < = FAN_FACTOR + <int> ; } int type = <int> ; for ( int i = getChildStart ( node ) ; i < getChildEnd ( node ) ; i + + ) { Object [ ] child = ( Object [ ] ) node [ i ] ; Object localmax = i < node . length - <int> ? node [ i - getChildStart ( node ) ] : max ; if ( ! isWellFormed ( cmp , child , false , min , localmax ) ) return false ; type | = isLeaf ( child ) ? <int> : <int> ; min = localmax ; } return type < <int> ; } private static boolean isNodeWellFormed ( Comparator < ? > cmp , Object [ ] node , Object min , Object max ) { Object previous = min ; int end = getKeyEnd ( node ) ; for ( int i = <int> ; i < end ; i + + ) { Object current = node [ i ] ; if ( compare ( cmp , previous , current ) > = <int> ) return false ; previous = current ; } return compare ( cmp , previous , max ) < <int> ; } } 
