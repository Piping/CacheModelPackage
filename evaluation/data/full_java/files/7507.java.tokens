package org . elasticsearch . search . highlight ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . highlight . Encoder ; import org . apache . lucene . search . postingshighlight . CustomPassageFormatter ; import org . apache . lucene . search . postingshighlight . CustomPostingsHighlighter ; import org . apache . lucene . search . postingshighlight . CustomSeparatorBreakIterator ; import org . apache . lucene . search . postingshighlight . Snippet ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . search . fetch . FetchPhaseExecutionException ; import org . elasticsearch . search . fetch . FetchSubPhase ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . text . BreakIterator ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; public class PostingsHighlighter implements Highlighter { private static final String CACHE_KEY = <str> ; @Override public HighlightField highlight ( HighlighterContext highlighterContext ) { FieldMapper fieldMapper = highlighterContext . mapper ; SearchContextHighlight . Field field = highlighterContext . field ; if ( canHighlight ( fieldMapper ) = = false ) { throw new IllegalArgumentException ( <str> + highlighterContext . fieldName + <str> ) ; } SearchContext context = highlighterContext . context ; FetchSubPhase . HitContext hitContext = highlighterContext . hitContext ; if ( ! hitContext . cache ( ) . containsKey ( CACHE_KEY ) ) { hitContext . cache ( ) . put ( CACHE_KEY , new HighlighterEntry ( ) ) ; } HighlighterEntry highlighterEntry = ( HighlighterEntry ) hitContext . cache ( ) . get ( CACHE_KEY ) ; MapperHighlighterEntry mapperHighlighterEntry = highlighterEntry . mappers . get ( fieldMapper ) ; if ( mapperHighlighterEntry = = null ) { Encoder encoder = field . fieldOptions ( ) . encoder ( ) . equals ( <str> ) ? HighlightUtils . Encoders . HTML : HighlightUtils . Encoders . DEFAULT ; CustomPassageFormatter passageFormatter = new CustomPassageFormatter ( field . fieldOptions ( ) . preTags ( ) [ <int> ] , field . fieldOptions ( ) . postTags ( ) [ <int> ] , encoder ) ; mapperHighlighterEntry = new MapperHighlighterEntry ( passageFormatter ) ; } List < Snippet > snippets = new ArrayList < > ( ) ; int numberOfFragments ; try { Analyzer analyzer = context . mapperService ( ) . documentMapper ( hitContext . hit ( ) . type ( ) ) . mappers ( ) . indexAnalyzer ( ) ; List < Object > fieldValues = HighlightUtils . loadFieldValues ( field , fieldMapper , context , hitContext ) ; CustomPostingsHighlighter highlighter ; if ( field . fieldOptions ( ) . numberOfFragments ( ) = = <int> ) { String fieldValue = mergeFieldValues ( fieldValues , HighlightUtils . NULL_SEPARATOR ) ; CustomSeparatorBreakIterator breakIterator = new CustomSeparatorBreakIterator ( HighlightUtils . NULL_SEPARATOR ) ; highlighter = new CustomPostingsHighlighter ( analyzer , mapperHighlighterEntry . passageFormatter , breakIterator , fieldValue , field . fieldOptions ( ) . noMatchSize ( ) > <int> ) ; numberOfFragments = fieldValues . size ( ) ; } else { String fieldValue = mergeFieldValues ( fieldValues , HighlightUtils . PARAGRAPH_SEPARATOR ) ; highlighter = new CustomPostingsHighlighter ( analyzer , mapperHighlighterEntry . passageFormatter , fieldValue , field . fieldOptions ( ) . noMatchSize ( ) > <int> ) ; numberOfFragments = field . fieldOptions ( ) . numberOfFragments ( ) ; } IndexSearcher searcher = new IndexSearcher ( hitContext . reader ( ) ) ; Snippet [ ] fieldSnippets = highlighter . highlightField ( fieldMapper . fieldType ( ) . names ( ) . indexName ( ) , highlighterContext . query , searcher , hitContext . docId ( ) , numberOfFragments ) ; for ( Snippet fieldSnippet : fieldSnippets ) { if ( Strings . hasText ( fieldSnippet . getText ( ) ) ) { snippets . add ( fieldSnippet ) ; } } } catch ( IOException e ) { throw new FetchPhaseExecutionException ( context , <str> + highlighterContext . fieldName + <str> , e ) ; } snippets = filterSnippets ( snippets , field . fieldOptions ( ) . numberOfFragments ( ) ) ; if ( field . fieldOptions ( ) . scoreOrdered ( ) ) { CollectionUtil . introSort ( snippets , new Comparator < Snippet > ( ) { @Override public int compare ( Snippet o1 , Snippet o2 ) { return ( int ) Math . signum ( o2 . getScore ( ) - o1 . getScore ( ) ) ; } } ) ; } String [ ] fragments = new String [ snippets . size ( ) ] ; for ( int i = <int> ; i < fragments . length ; i + + ) { fragments [ i ] = snippets . get ( i ) . getText ( ) ; } if ( fragments . length > <int> ) { return new HighlightField ( highlighterContext . fieldName , StringText . convertFromStringArray ( fragments ) ) ; } return null ; } @Override public boolean canHighlight ( FieldMapper fieldMapper ) { return fieldMapper . fieldType ( ) . indexOptions ( ) = = IndexOptions . DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS ; } private static String mergeFieldValues ( List < Object > fieldValues , char valuesSeparator ) { String rawValue = Strings . collectionToDelimitedString ( fieldValues , String . valueOf ( valuesSeparator ) ) ; return rawValue . substring ( <int> , Math . min ( rawValue . length ( ) , Integer . MAX_VALUE - <int> ) ) ; } private static List < Snippet > filterSnippets ( List < Snippet > snippets , int numberOfFragments ) { List < Snippet > filteredSnippets = new ArrayList < > ( snippets . size ( ) ) ; for ( Snippet snippet : snippets ) { if ( snippet . isHighlighted ( ) ) { filteredSnippets . add ( snippet ) ; } } if ( filteredSnippets . size ( ) = = <int> ) { if ( snippets . size ( ) > <int> ) { Snippet snippet = snippets . get ( <int> ) ; if ( numberOfFragments = = <int> ) { BreakIterator bi = BreakIterator . getSentenceInstance ( Locale . ROOT ) ; String text = snippet . getText ( ) ; bi . setText ( text ) ; int next = bi . next ( ) ; if ( next ! = BreakIterator . DONE ) { String newText = text . substring ( <int> , next ) . trim ( ) ; snippet = new Snippet ( newText , snippet . getScore ( ) , snippet . isHighlighted ( ) ) ; } } filteredSnippets . add ( snippet ) ; } } return filteredSnippets ; } private static class HighlighterEntry { Map < FieldMapper , MapperHighlighterEntry > mappers = new HashMap < > ( ) ; } private static class MapperHighlighterEntry { final CustomPassageFormatter passageFormatter ; private MapperHighlighterEntry ( CustomPassageFormatter passageFormatter ) { this . passageFormatter = passageFormatter ; } } } 
