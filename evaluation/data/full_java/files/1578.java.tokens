package org . apache . cassandra . io . util ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Random ; import com . google . common . primitives . Ints ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ClusteringComparator ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . io . compress . CompressedSequentialWriter ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . utils . ChecksumType ; import static junit . framework . Assert . assertNull ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class MmappedRegionsTest { private static final Logger logger = LoggerFactory . getLogger ( MmappedRegionsTest . class ) ; private static ByteBuffer allocateBuffer ( int size ) { ByteBuffer ret = ByteBuffer . allocate ( Ints . checkedCast ( size ) ) ; long seed = System . nanoTime ( ) ; logger . info ( <str> , seed ) ; new Random ( seed ) . nextBytes ( ret . array ( ) ) ; return ret ; } private static File writeFile ( String fileName , ByteBuffer buffer ) throws IOException { File ret = File . createTempFile ( fileName , <str> ) ; ret . deleteOnExit ( ) ; try ( SequentialWriter writer = SequentialWriter . open ( ret ) ) { writer . write ( buffer ) ; writer . finish ( ) ; } assert ret . exists ( ) ; assert ret . length ( ) > = buffer . capacity ( ) ; return ret ; } @Test public void testEmpty ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { assertTrue ( regions . isEmpty ( ) ) ; assertTrue ( regions . isValid ( channel ) ) ; } } @Test public void testTwoSegments ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { MmappedRegions . Region region = regions . floor ( i ) ; assertNotNull ( region ) ; assertEquals ( <int> , region . bottom ( ) ) ; assertEquals ( <int> , region . top ( ) ) ; } regions . extend ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { MmappedRegions . Region region = regions . floor ( i ) ; assertNotNull ( region ) ; if ( i < <int> ) { assertEquals ( <int> , region . bottom ( ) ) ; assertEquals ( <int> , region . top ( ) ) ; } else { assertEquals ( <int> , region . bottom ( ) ) ; assertEquals ( <int> , region . top ( ) ) ; } } } } @Test public void testSmallSegmentSize ( ) throws Exception { int OLD_MAX_SEGMENT_SIZE = MmappedRegions . MAX_SEGMENT_SIZE ; MmappedRegions . MAX_SEGMENT_SIZE = <int> ; ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( <int> ) ; regions . extend ( <int> ) ; regions . extend ( <int> ) ; final int SIZE = MmappedRegions . MAX_SEGMENT_SIZE ; for ( int i = <int> ; i < buffer . capacity ( ) ; i + + ) { MmappedRegions . Region region = regions . floor ( i ) ; assertNotNull ( region ) ; assertEquals ( SIZE * ( i / SIZE ) , region . bottom ( ) ) ; assertEquals ( SIZE + ( SIZE * ( i / SIZE ) ) , region . top ( ) ) ; } } finally { MmappedRegions . MAX_SEGMENT_SIZE = OLD_MAX_SEGMENT_SIZE ; } } @Test public void testAllocRegions ( ) throws Exception { int OLD_MAX_SEGMENT_SIZE = MmappedRegions . MAX_SEGMENT_SIZE ; MmappedRegions . MAX_SEGMENT_SIZE = <int> ; ByteBuffer buffer = allocateBuffer ( MmappedRegions . MAX_SEGMENT_SIZE * MmappedRegions . REGION_ALLOC_SIZE * <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( buffer . capacity ( ) ) ; final int SIZE = MmappedRegions . MAX_SEGMENT_SIZE ; for ( int i = <int> ; i < buffer . capacity ( ) ; i + + ) { MmappedRegions . Region region = regions . floor ( i ) ; assertNotNull ( region ) ; assertEquals ( SIZE * ( i / SIZE ) , region . bottom ( ) ) ; assertEquals ( SIZE + ( SIZE * ( i / SIZE ) ) , region . top ( ) ) ; } } finally { MmappedRegions . MAX_SEGMENT_SIZE = OLD_MAX_SEGMENT_SIZE ; } } @Test public void testCopy ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> * <int> ) ; MmappedRegions snapshot ; ChannelProxy channelCopy ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . map ( channel , buffer . capacity ( ) / <int> ) ) { regions . extend ( buffer . capacity ( ) / <int> ) ; regions . extend ( <int> * buffer . capacity ( ) / <int> ) ; regions . extend ( buffer . capacity ( ) ) ; snapshot = regions . sharedCopy ( ) ; channelCopy = channel . sharedCopy ( ) ; } assertFalse ( snapshot . isCleanedUp ( ) ) ; final int SIZE = buffer . capacity ( ) / <int> ; for ( int i = <int> ; i < buffer . capacity ( ) ; i + + ) { MmappedRegions . Region region = snapshot . floor ( i ) ; assertNotNull ( region ) ; assertEquals ( SIZE * ( i / SIZE ) , region . bottom ( ) ) ; assertEquals ( SIZE + ( SIZE * ( i / SIZE ) ) , region . top ( ) ) ; assertNotNull ( region . buffer . duplicate ( ) . getInt ( ) ) ; } assertNull ( snapshot . close ( null ) ) ; assertNull ( channelCopy . close ( null ) ) ; assertTrue ( snapshot . isCleanedUp ( ) ) ; } @Test ( expected = AssertionError . class ) public void testCopyCannotExtend ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> * <int> ) ; MmappedRegions snapshot ; ChannelProxy channelCopy ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( buffer . capacity ( ) / <int> ) ; snapshot = regions . sharedCopy ( ) ; channelCopy = channel . sharedCopy ( ) ; } try { snapshot . extend ( buffer . capacity ( ) ) ; } finally { assertNull ( snapshot . close ( null ) ) ; assertNull ( channelCopy . close ( null ) ) ; } } @Test public void testExtendOutOfOrder ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( <int> ) ; regions . extend ( <int> ) ; regions . extend ( <int> ) ; for ( int i = <int> ; i < buffer . capacity ( ) ; i + + ) { MmappedRegions . Region region = regions . floor ( i ) ; assertNotNull ( region ) ; assertEquals ( <int> , region . bottom ( ) ) ; assertEquals ( <int> , region . top ( ) ) ; } } } @Test ( expected = IllegalArgumentException . class ) public void testNegativeExtend ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . empty ( channel ) ) { regions . extend ( - <int> ) ; } } @Test public void testMapForCompressionMetadata ( ) throws Exception { int OLD_MAX_SEGMENT_SIZE = MmappedRegions . MAX_SEGMENT_SIZE ; MmappedRegions . MAX_SEGMENT_SIZE = <int> ; ByteBuffer buffer = allocateBuffer ( <int> * <int> ) ; File f = File . createTempFile ( <str> , <str> ) ; f . deleteOnExit ( ) ; File cf = File . createTempFile ( f . getName ( ) + <str> , <str> ) ; cf . deleteOnExit ( ) ; MetadataCollector sstableMetadataCollector = new MetadataCollector ( new ClusteringComparator ( BytesType . instance ) ) . replayPosition ( null ) ; try ( SequentialWriter writer = new CompressedSequentialWriter ( f , cf . getAbsolutePath ( ) , CompressionParams . snappy ( ) , sstableMetadataCollector ) ) { writer . write ( buffer ) ; writer . finish ( ) ; } CompressionMetadata metadata = new CompressionMetadata ( cf . getAbsolutePath ( ) , f . length ( ) , ChecksumType . CRC32 ) ; try ( ChannelProxy channel = new ChannelProxy ( f ) ; MmappedRegions regions = MmappedRegions . map ( channel , metadata ) ) { assertFalse ( regions . isEmpty ( ) ) ; int i = <int> ; while ( i < buffer . capacity ( ) ) { CompressionMetadata . Chunk chunk = metadata . chunkFor ( i ) ; MmappedRegions . Region region = regions . floor ( chunk . offset ) ; assertNotNull ( region ) ; ByteBuffer compressedChunk = region . buffer . duplicate ( ) ; assertNotNull ( compressedChunk ) ; assertEquals ( chunk . length + <int> , compressedChunk . capacity ( ) ) ; assertEquals ( chunk . offset , region . bottom ( ) ) ; assertEquals ( chunk . offset + chunk . length + <int> , region . top ( ) ) ; i + = metadata . chunkLength ( ) ; } } finally { MmappedRegions . MAX_SEGMENT_SIZE = OLD_MAX_SEGMENT_SIZE ; metadata . close ( ) ; } } @Test ( expected = IllegalArgumentException . class ) public void testIllegalArgForMap1 ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . map ( channel , <int> ) ) { assertTrue ( regions . isEmpty ( ) ) ; } } @Test ( expected = IllegalArgumentException . class ) public void testIllegalArgForMap2 ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . map ( channel , - <int> ) ) { assertTrue ( regions . isEmpty ( ) ) ; } } @Test ( expected = IllegalArgumentException . class ) public void testIllegalArgForMap3 ( ) throws Exception { ByteBuffer buffer = allocateBuffer ( <int> ) ; try ( ChannelProxy channel = new ChannelProxy ( writeFile ( <str> , buffer ) ) ; MmappedRegions regions = MmappedRegions . map ( channel , null ) ) { assertTrue ( regions . isEmpty ( ) ) ; } } } 
