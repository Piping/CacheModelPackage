package org . apache . cassandra . tracing ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . List ; import java . util . UUID ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . base . Stopwatch ; import org . slf4j . helpers . MessageFormatter ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . exceptions . OverloadedException ; import org . apache . cassandra . service . StorageProxy ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . WrappedRunnable ; import org . apache . cassandra . utils . progress . ProgressEvent ; import org . apache . cassandra . utils . progress . ProgressEventNotifier ; import org . apache . cassandra . utils . progress . ProgressListener ; public class TraceState implements ProgressEventNotifier { public final UUID sessionId ; public final InetAddress coordinator ; public final Stopwatch watch ; public final ByteBuffer sessionIdBytes ; public final Tracing . TraceType traceType ; public final int ttl ; private boolean notify ; private final List < ProgressListener > listeners = new CopyOnWriteArrayList < > ( ) ; private String tag ; public enum Status { IDLE , ACTIVE , STOPPED } private volatile Status status ; private final AtomicInteger references = new AtomicInteger ( <int> ) ; public TraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) { assert coordinator ! = null ; assert sessionId ! = null ; this . coordinator = coordinator ; this . sessionId = sessionId ; sessionIdBytes = ByteBufferUtil . bytes ( sessionId ) ; this . traceType = traceType ; this . ttl = traceType . getTTL ( ) ; watch = Stopwatch . createStarted ( ) ; this . status = Status . IDLE ; } public void enableActivityNotification ( String tag ) { assert traceType = = Tracing . TraceType . REPAIR ; notify = true ; this . tag = tag ; } @Override public void addProgressListener ( ProgressListener listener ) { assert traceType = = Tracing . TraceType . REPAIR ; listeners . add ( listener ) ; } @Override public void removeProgressListener ( ProgressListener listener ) { assert traceType = = Tracing . TraceType . REPAIR ; listeners . remove ( listener ) ; } public int elapsed ( ) { long elapsed = watch . elapsed ( TimeUnit . MICROSECONDS ) ; return elapsed < Integer . MAX_VALUE ? ( int ) elapsed : Integer . MAX_VALUE ; } public synchronized void stop ( ) { status = Status . STOPPED ; notifyAll ( ) ; } public synchronized Status waitActivity ( long timeout ) { if ( status = = Status . IDLE ) { try { wait ( timeout ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( ) ; } } if ( status = = Status . ACTIVE ) { status = Status . IDLE ; return Status . ACTIVE ; } return status ; } private synchronized void notifyActivity ( ) { status = Status . ACTIVE ; notifyAll ( ) ; } public void trace ( String format , Object arg ) { trace ( MessageFormatter . format ( format , arg ) . getMessage ( ) ) ; } public void trace ( String format , Object arg1 , Object arg2 ) { trace ( MessageFormatter . format ( format , arg1 , arg2 ) . getMessage ( ) ) ; } public void trace ( String format , Object [ ] args ) { trace ( MessageFormatter . arrayFormat ( format , args ) . getMessage ( ) ) ; } public void trace ( String message ) { if ( notify ) notifyActivity ( ) ; final String threadName = Thread . currentThread ( ) . getName ( ) ; final int elapsed = elapsed ( ) ; executeMutation ( TraceKeyspace . makeEventMutation ( sessionIdBytes , message , elapsed , threadName , ttl ) ) ; for ( ProgressListener listener : listeners ) { listener . progress ( tag , ProgressEvent . createNotification ( message ) ) ; } } static void executeMutation ( final Mutation mutation ) { StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) { protected void runMayThrow ( ) throws Exception { mutateWithCatch ( mutation ) ; } } ) ; } public static void mutateWithTracing ( final ByteBuffer sessionId , final String message , final int elapsed , final int ttl ) { final String threadName = Thread . currentThread ( ) . getName ( ) ; StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) { public void runMayThrow ( ) { mutateWithCatch ( TraceKeyspace . makeEventMutation ( sessionId , message , elapsed , threadName , ttl ) ) ; } } ) ; } static void mutateWithCatch ( Mutation mutation ) { try { StorageProxy . mutate ( Collections . singletonList ( mutation ) , ConsistencyLevel . ANY ) ; } catch ( OverloadedException e ) { Tracing . logger . warn ( <str> ) ; } } public boolean acquireReference ( ) { while ( true ) { int n = references . get ( ) ; if ( n < = <int> ) return false ; if ( references . compareAndSet ( n , n + <int> ) ) return true ; } } public int releaseReference ( ) { return references . decrementAndGet ( ) ; } } 
