package org . eclipse . debug . internal . ui . viewers . model ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenCountUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . jface . viewers . TreePath ; class ChildrenCountUpdate extends ViewerUpdateMonitor implements IChildrenCountUpdate { private int fCount = <int> ; private List < ViewerUpdateMonitor > fBatchedRequests = null ; private boolean fShouldFilter = false ; private int [ ] fFilteredChildren = null ; private ChildrenUpdate fChildrenUpdate ; public ChildrenCountUpdate ( TreeModelContentProvider provider , Object viewerInput , TreePath elementPath , Object element , IElementContentProvider elementContentProvider ) { super ( provider , viewerInput , elementPath , element , elementContentProvider , provider . getPresentationContext ( ) ) ; fShouldFilter = provider . areTreeModelViewerFiltersApplicable ( element ) ; fFilteredChildren = provider . getFilteredChildren ( elementPath ) ; } @Override public synchronized void cancel ( ) { if ( fChildrenUpdate ! = null ) { fChildrenUpdate . cancel ( ) ; } super . cancel ( ) ; } @Override protected synchronized void scheduleViewerUpdate ( ) { if ( fShouldFilter | | fFilteredChildren ! = null ) { if ( fChildrenUpdate = = null ) { int startIdx ; int count ; if ( fShouldFilter ) { startIdx = <int> ; count = getCount ( ) ; } else { startIdx = fFilteredChildren [ <int> ] ; int endIdx = fFilteredChildren [ fFilteredChildren . length - <int> ] ; count = endIdx - startIdx + <int> ; } fChildrenUpdate = new ChildrenUpdate ( getContentProvider ( ) , getViewerInput ( ) , getElementPath ( ) , getElement ( ) , startIdx , count , getElementContentProvider ( ) ) { @Override protected void performUpdate ( ) { performUpdate ( true ) ; ChildrenCountUpdate . super . scheduleViewerUpdate ( ) ; } @Override protected void scheduleViewerUpdate ( ) { execInDisplayThread ( new Runnable ( ) { @Override public void run ( ) { if ( ! getContentProvider ( ) . isDisposed ( ) & & ! isCanceled ( ) ) { performUpdate ( ) ; } } } ) ; } } ; execInDisplayThread ( new Runnable ( ) { @Override public void run ( ) { fChildrenUpdate . startRequest ( ) ; } } ) ; return ; } } else { super . scheduleViewerUpdate ( ) ; } } @Override protected void performUpdate ( ) { int viewCount = fCount ; TreePath elementPath = getElementPath ( ) ; if ( viewCount = = <int> ) { getContentProvider ( ) . clearFilters ( elementPath ) ; } else { getContentProvider ( ) . setModelChildCount ( elementPath , fCount ) ; viewCount = getContentProvider ( ) . modelToViewChildCount ( elementPath , fCount ) ; } if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( ) + <str> + fCount + <str> + viewCount + <str> ) ; } if ( fShouldFilter & & getContentProvider ( ) . isFiltered ( elementPath , <int> ) ) { getContentProvider ( ) . updateElement ( elementPath , <int> ) ; } getContentProvider ( ) . getViewer ( ) . setChildCount ( elementPath , viewCount ) ; getContentProvider ( ) . getStateTracker ( ) . restorePendingStateOnUpdate ( getElementPath ( ) , - <int> , true , true , false ) ; } @Override public void setChildCount ( int numChildren ) { fCount = numChildren ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; buf . append ( getElement ( ) ) ; return buf . toString ( ) ; } @Override boolean coalesce ( ViewerUpdateMonitor request ) { if ( request instanceof ChildrenCountUpdate ) { if ( getElementPath ( ) . equals ( request . getElementPath ( ) ) ) { return true ; } else if ( getElementContentProvider ( ) . equals ( request . getElementContentProvider ( ) ) ) { if ( fBatchedRequests = = null ) { fBatchedRequests = new ArrayList < ViewerUpdateMonitor > ( <int> ) ; fBatchedRequests . add ( this ) ; } fBatchedRequests . add ( request ) ; return true ; } } return false ; } @Override void startRequest ( ) { if ( fBatchedRequests = = null ) { getElementContentProvider ( ) . update ( new IChildrenCountUpdate [ ] { this } ) ; } else { IChildrenCountUpdate [ ] updates = fBatchedRequests . toArray ( new IChildrenCountUpdate [ fBatchedRequests . size ( ) ] ) ; for ( int i = <int> ; i < updates . length ; i + + ) { getContentProvider ( ) . updateStarted ( ( ViewerUpdateMonitor ) updates [ i ] ) ; } getElementContentProvider ( ) . update ( updates ) ; } } @Override boolean containsUpdate ( TreePath path ) { if ( getElementPath ( ) . equals ( path ) ) { return true ; } else if ( fBatchedRequests ! = null ) { for ( int i = <int> ; i < fBatchedRequests . size ( ) ; i + + ) { if ( fBatchedRequests . get ( i ) . getElementPath ( ) . equals ( path ) ) { return true ; } } } return false ; } @Override int getPriority ( ) { return <int> ; } @Override TreePath getSchedulingPath ( ) { TreePath path = getElementPath ( ) ; if ( path . getSegmentCount ( ) > <int> ) { return path . getParentPath ( ) ; } return path ; } int getCount ( ) { return fCount ; } @Override protected boolean doEquals ( ViewerUpdateMonitor update ) { return update instanceof ChildrenCountUpdate & & getViewerInput ( ) . equals ( update . getViewerInput ( ) ) & & getElementPath ( ) . equals ( update . getElementPath ( ) ) ; } @Override protected int doHashCode ( ) { return getClass ( ) . hashCode ( ) + getViewerInput ( ) . hashCode ( ) + getElementPath ( ) . hashCode ( ) ; } } 
