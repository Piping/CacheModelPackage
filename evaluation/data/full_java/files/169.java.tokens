package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . db . marshal . UserType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class UserTypes { private UserTypes ( ) { } public static ColumnSpecification fieldSpecOf ( ColumnSpecification column , int field ) { UserType ut = ( UserType ) column . type ; return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( column . name + <str> + UTF8Type . instance . compose ( ut . fieldName ( field ) ) , true ) , ut . fieldType ( field ) ) ; } public static class Literal extends Term . Raw { public final Map < ColumnIdentifier , Term . Raw > entries ; public Literal ( Map < ColumnIdentifier , Term . Raw > entries ) { this . entries = entries ; } public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { validateAssignableTo ( keyspace , receiver ) ; UserType ut = ( UserType ) receiver . type ; boolean allTerminal = true ; List < Term > values = new ArrayList < > ( entries . size ( ) ) ; int foundValues = <int> ; for ( int i = <int> ; i < ut . size ( ) ; i + + ) { ColumnIdentifier field = new ColumnIdentifier ( ut . fieldName ( i ) , UTF8Type . instance ) ; Term . Raw raw = entries . get ( field ) ; if ( raw = = null ) raw = Constants . NULL_LITERAL ; else + + foundValues ; Term value = raw . prepare ( keyspace , fieldSpecOf ( receiver , i ) ) ; if ( value instanceof Term . NonTerminal ) allTerminal = false ; values . add ( value ) ; } if ( foundValues ! = entries . size ( ) ) { for ( ColumnIdentifier id : entries . keySet ( ) ) if ( ! ut . fieldNames ( ) . contains ( id . bytes ) ) throw new InvalidRequestException ( String . format ( <str> , id , ut . getNameAsString ( ) ) ) ; } DelayedValue value = new DelayedValue ( ( ( UserType ) receiver . type ) , values ) ; return allTerminal ? value . bind ( QueryOptions . DEFAULT ) : value ; } private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof UserType ) ) throw new InvalidRequestException ( String . format ( <str> , receiver , receiver . type . asCQL3Type ( ) ) ) ; UserType ut = ( UserType ) receiver . type ; for ( int i = <int> ; i < ut . size ( ) ; i + + ) { ColumnIdentifier field = new ColumnIdentifier ( ut . fieldName ( i ) , UTF8Type . instance ) ; Term . Raw value = entries . get ( field ) ; if ( value = = null ) continue ; ColumnSpecification fieldSpec = fieldSpecOf ( receiver , i ) ; if ( ! value . testAssignment ( keyspace , fieldSpec ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver , field , fieldSpec . type . asCQL3Type ( ) ) ) ; } } public AssignmentTestable . TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { try { validateAssignableTo ( keyspace , receiver ) ; return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; } catch ( InvalidRequestException e ) { return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; } } public String getText ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; Iterator < Map . Entry < ColumnIdentifier , Term . Raw > > iter = entries . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < ColumnIdentifier , Term . Raw > entry = iter . next ( ) ; sb . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) . getText ( ) ) ; if ( iter . hasNext ( ) ) sb . append ( <str> ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } } public static class DelayedValue extends Term . NonTerminal { private final UserType type ; private final List < Term > values ; public DelayedValue ( UserType type , List < Term > values ) { this . type = type ; this . values = values ; } public Iterable < Function > getFunctions ( ) { return Terms . getFunctions ( values ) ; } public boolean containsBindMarker ( ) { for ( Term t : values ) if ( t . containsBindMarker ( ) ) return true ; return false ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { for ( int i = <int> ; i < type . size ( ) ; i + + ) values . get ( i ) . collectMarkerSpecification ( boundNames ) ; } private ByteBuffer [ ] bindInternal ( QueryOptions options ) throws InvalidRequestException { ByteBuffer [ ] buffers = new ByteBuffer [ values . size ( ) ] ; for ( int i = <int> ; i < type . size ( ) ; i + + ) { buffers [ i ] = values . get ( i ) . bindAndGet ( options ) ; if ( buffers [ i ] = = ByteBufferUtil . UNSET_BYTE_BUFFER ) throw new InvalidRequestException ( String . format ( <str> , type . fieldNameAsString ( i ) , type . getNameAsString ( ) ) ) ; } return buffers ; } public Constants . Value bind ( QueryOptions options ) throws InvalidRequestException { return new Constants . Value ( bindAndGet ( options ) ) ; } @Override public ByteBuffer bindAndGet ( QueryOptions options ) throws InvalidRequestException { return UserType . buildValue ( bindInternal ( options ) ) ; } } } 
