package io . netty . buffer ; import io . netty . util . ResourceLeak ; import io . netty . util . ResourceLeakDetector ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; public abstract class AbstractByteBufAllocator implements ByteBufAllocator { private static final int DEFAULT_INITIAL_CAPACITY = <int> ; private static final int DEFAULT_MAX_COMPONENTS = <int> ; protected static ByteBuf toLeakAwareBuffer ( ByteBuf buf ) { ResourceLeak leak ; switch ( ResourceLeakDetector . getLevel ( ) ) { case SIMPLE : leak = AbstractByteBuf . leakDetector . open ( buf ) ; if ( leak ! = null ) { buf = new SimpleLeakAwareByteBuf ( buf , leak ) ; } break ; case ADVANCED : case PARANOID : leak = AbstractByteBuf . leakDetector . open ( buf ) ; if ( leak ! = null ) { buf = new AdvancedLeakAwareByteBuf ( buf , leak ) ; } break ; default : break ; } return buf ; } private final boolean directByDefault ; private final ByteBuf emptyBuf ; protected AbstractByteBufAllocator ( ) { this ( false ) ; } protected AbstractByteBufAllocator ( boolean preferDirect ) { directByDefault = preferDirect & & PlatformDependent . hasUnsafe ( ) ; emptyBuf = new EmptyByteBuf ( this ) ; } @Override public ByteBuf buffer ( ) { if ( directByDefault ) { return directBuffer ( ) ; } return heapBuffer ( ) ; } @Override public ByteBuf buffer ( int initialCapacity ) { if ( directByDefault ) { return directBuffer ( initialCapacity ) ; } return heapBuffer ( initialCapacity ) ; } @Override public ByteBuf buffer ( int initialCapacity , int maxCapacity ) { if ( directByDefault ) { return directBuffer ( initialCapacity , maxCapacity ) ; } return heapBuffer ( initialCapacity , maxCapacity ) ; } @Override public ByteBuf ioBuffer ( ) { if ( PlatformDependent . hasUnsafe ( ) ) { return directBuffer ( DEFAULT_INITIAL_CAPACITY ) ; } return heapBuffer ( DEFAULT_INITIAL_CAPACITY ) ; } @Override public ByteBuf ioBuffer ( int initialCapacity ) { if ( PlatformDependent . hasUnsafe ( ) ) { return directBuffer ( initialCapacity ) ; } return heapBuffer ( initialCapacity ) ; } @Override public ByteBuf ioBuffer ( int initialCapacity , int maxCapacity ) { if ( PlatformDependent . hasUnsafe ( ) ) { return directBuffer ( initialCapacity , maxCapacity ) ; } return heapBuffer ( initialCapacity , maxCapacity ) ; } @Override public ByteBuf heapBuffer ( ) { return heapBuffer ( DEFAULT_INITIAL_CAPACITY , Integer . MAX_VALUE ) ; } @Override public ByteBuf heapBuffer ( int initialCapacity ) { return heapBuffer ( initialCapacity , Integer . MAX_VALUE ) ; } @Override public ByteBuf heapBuffer ( int initialCapacity , int maxCapacity ) { if ( initialCapacity = = <int> & & maxCapacity = = <int> ) { return emptyBuf ; } validate ( initialCapacity , maxCapacity ) ; return newHeapBuffer ( initialCapacity , maxCapacity ) ; } @Override public ByteBuf directBuffer ( ) { return directBuffer ( DEFAULT_INITIAL_CAPACITY , Integer . MAX_VALUE ) ; } @Override public ByteBuf directBuffer ( int initialCapacity ) { return directBuffer ( initialCapacity , Integer . MAX_VALUE ) ; } @Override public ByteBuf directBuffer ( int initialCapacity , int maxCapacity ) { if ( initialCapacity = = <int> & & maxCapacity = = <int> ) { return emptyBuf ; } validate ( initialCapacity , maxCapacity ) ; return newDirectBuffer ( initialCapacity , maxCapacity ) ; } @Override public CompositeByteBuf compositeBuffer ( ) { if ( directByDefault ) { return compositeDirectBuffer ( ) ; } return compositeHeapBuffer ( ) ; } @Override public CompositeByteBuf compositeBuffer ( int maxNumComponents ) { if ( directByDefault ) { return compositeDirectBuffer ( maxNumComponents ) ; } return compositeHeapBuffer ( maxNumComponents ) ; } @Override public CompositeByteBuf compositeHeapBuffer ( ) { return compositeHeapBuffer ( DEFAULT_MAX_COMPONENTS ) ; } @Override public CompositeByteBuf compositeHeapBuffer ( int maxNumComponents ) { return new CompositeByteBuf ( this , false , maxNumComponents ) ; } @Override public CompositeByteBuf compositeDirectBuffer ( ) { return compositeDirectBuffer ( DEFAULT_MAX_COMPONENTS ) ; } @Override public CompositeByteBuf compositeDirectBuffer ( int maxNumComponents ) { return new CompositeByteBuf ( this , true , maxNumComponents ) ; } private static void validate ( int initialCapacity , int maxCapacity ) { if ( initialCapacity < <int> ) { throw new IllegalArgumentException ( <str> + initialCapacity + <str> ) ; } if ( initialCapacity > maxCapacity ) { throw new IllegalArgumentException ( String . format ( <str> , initialCapacity , maxCapacity ) ) ; } } protected abstract ByteBuf newHeapBuffer ( int initialCapacity , int maxCapacity ) ; protected abstract ByteBuf newDirectBuffer ( int initialCapacity , int maxCapacity ) ; @Override public String toString ( ) { return StringUtil . simpleClassName ( this ) + <str> + directByDefault + <str> ; } @Override public int calculateNewCapacity ( int minNewCapacity , int maxCapacity ) { if ( minNewCapacity < <int> ) { throw new IllegalArgumentException ( <str> + minNewCapacity + <str> ) ; } if ( minNewCapacity > maxCapacity ) { throw new IllegalArgumentException ( String . format ( <str> , minNewCapacity , maxCapacity ) ) ; } final int threshold = <int> * <int> ; if ( minNewCapacity = = threshold ) { return threshold ; } if ( minNewCapacity > threshold ) { int newCapacity = minNewCapacity / threshold * threshold ; if ( newCapacity > maxCapacity - threshold ) { newCapacity = maxCapacity ; } else { newCapacity + = threshold ; } return newCapacity ; } int newCapacity = <int> ; while ( newCapacity < minNewCapacity ) { newCapacity < < = <int> ; } return Math . min ( newCapacity , maxCapacity ) ; } } 
