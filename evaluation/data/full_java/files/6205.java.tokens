package org . elasticsearch . gateway ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . DiscoveryService ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . concurrent . atomic . AtomicBoolean ; public class GatewayService extends AbstractLifecycleComponent < GatewayService > implements ClusterStateListener { public static final ClusterBlock STATE_NOT_RECOVERED_BLOCK = new ClusterBlock ( <int> , <str> , true , true , RestStatus . SERVICE_UNAVAILABLE , ClusterBlockLevel . ALL ) ; public static final TimeValue DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET = TimeValue . timeValueMinutes ( <int> ) ; private final Gateway gateway ; private final ThreadPool threadPool ; private final AllocationService allocationService ; private final ClusterService clusterService ; private final DiscoveryService discoveryService ; private final TimeValue recoverAfterTime ; private final int recoverAfterNodes ; private final int expectedNodes ; private final int recoverAfterDataNodes ; private final int expectedDataNodes ; private final int recoverAfterMasterNodes ; private final int expectedMasterNodes ; private final AtomicBoolean recovered = new AtomicBoolean ( ) ; private final AtomicBoolean scheduledRecovery = new AtomicBoolean ( ) ; @Inject public GatewayService ( Settings settings , Gateway gateway , AllocationService allocationService , ClusterService clusterService , DiscoveryService discoveryService , ThreadPool threadPool ) { super ( settings ) ; this . gateway = gateway ; this . allocationService = allocationService ; this . clusterService = clusterService ; this . discoveryService = discoveryService ; this . threadPool = threadPool ; this . expectedNodes = this . settings . getAsInt ( <str> , - <int> ) ; this . expectedDataNodes = this . settings . getAsInt ( <str> , - <int> ) ; this . expectedMasterNodes = this . settings . getAsInt ( <str> , - <int> ) ; TimeValue defaultRecoverAfterTime = null ; if ( expectedNodes > = <int> | | expectedDataNodes > = <int> | | expectedMasterNodes > = <int> ) { defaultRecoverAfterTime = DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET ; } this . recoverAfterTime = this . settings . getAsTime ( <str> , defaultRecoverAfterTime ) ; this . recoverAfterNodes = this . settings . getAsInt ( <str> , - <int> ) ; this . recoverAfterDataNodes = this . settings . getAsInt ( <str> , - <int> ) ; this . recoverAfterMasterNodes = this . settings . getAsInt ( <str> , settings . getAsInt ( <str> , - <int> ) ) ; this . clusterService . addInitialStateBlock ( STATE_NOT_RECOVERED_BLOCK ) ; } @Override protected void doStart ( ) { clusterService . addLast ( this ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { checkStateMeetsSettingsAndMaybeRecover ( currentState ) ; return currentState ; } @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t ) ; } } ) ; } @Override protected void doStop ( ) { clusterService . remove ( this ) ; } @Override protected void doClose ( ) { } @Override public void clusterChanged ( final ClusterChangedEvent event ) { if ( lifecycle . stoppedOrClosed ( ) ) { return ; } checkStateMeetsSettingsAndMaybeRecover ( event . state ( ) ) ; } protected void checkStateMeetsSettingsAndMaybeRecover ( ClusterState state ) { if ( state . nodes ( ) . localNodeMaster ( ) = = false ) { return ; } if ( state . blocks ( ) . hasGlobalBlock ( STATE_NOT_RECOVERED_BLOCK ) = = false ) { return ; } DiscoveryNodes nodes = state . nodes ( ) ; if ( state . blocks ( ) . hasGlobalBlock ( discoveryService . getNoMasterBlock ( ) ) ) { logger . debug ( <str> ) ; } else if ( recoverAfterNodes ! = - <int> & & ( nodes . masterAndDataNodes ( ) . size ( ) ) < recoverAfterNodes ) { logger . debug ( <str> + nodes . masterAndDataNodes ( ) . size ( ) + <str> + recoverAfterNodes + <str> ) ; } else if ( recoverAfterDataNodes ! = - <int> & & nodes . dataNodes ( ) . size ( ) < recoverAfterDataNodes ) { logger . debug ( <str> + nodes . dataNodes ( ) . size ( ) + <str> + recoverAfterDataNodes + <str> ) ; } else if ( recoverAfterMasterNodes ! = - <int> & & nodes . masterNodes ( ) . size ( ) < recoverAfterMasterNodes ) { logger . debug ( <str> + nodes . masterNodes ( ) . size ( ) + <str> + recoverAfterMasterNodes + <str> ) ; } else { boolean enforceRecoverAfterTime ; String reason ; if ( expectedNodes = = - <int> & & expectedMasterNodes = = - <int> & & expectedDataNodes = = - <int> ) { enforceRecoverAfterTime = true ; reason = <str> + recoverAfterTime + <str> ; } else { enforceRecoverAfterTime = false ; reason = <str> ; if ( expectedNodes ! = - <int> & & ( nodes . masterAndDataNodes ( ) . size ( ) < expectedNodes ) ) { enforceRecoverAfterTime = true ; reason = <str> + expectedNodes + <str> + nodes . masterAndDataNodes ( ) . size ( ) + <str> ; } else if ( expectedDataNodes ! = - <int> & & ( nodes . dataNodes ( ) . size ( ) < expectedDataNodes ) ) { enforceRecoverAfterTime = true ; reason = <str> + expectedDataNodes + <str> + nodes . dataNodes ( ) . size ( ) + <str> ; } else if ( expectedMasterNodes ! = - <int> & & ( nodes . masterNodes ( ) . size ( ) < expectedMasterNodes ) ) { enforceRecoverAfterTime = true ; reason = <str> + expectedMasterNodes + <str> + nodes . masterNodes ( ) . size ( ) + <str> ; } } performStateRecovery ( enforceRecoverAfterTime , reason ) ; } } private void performStateRecovery ( boolean enforceRecoverAfterTime , String reason ) { final Gateway . GatewayStateRecoveredListener recoveryListener = new GatewayRecoveryListener ( ) ; if ( enforceRecoverAfterTime & & recoverAfterTime ! = null ) { if ( scheduledRecovery . compareAndSet ( false , true ) ) { logger . info ( <str> , recoverAfterTime , reason ) ; threadPool . schedule ( recoverAfterTime , ThreadPool . Names . GENERIC , ( ) - > { if ( recovered . compareAndSet ( false , true ) ) { logger . info ( <str> , recoverAfterTime ) ; gateway . performStateRecovery ( recoveryListener ) ; } } ) ; } } else { if ( recovered . compareAndSet ( false , true ) ) { threadPool . generic ( ) . execute ( ( ) - > gateway . performStateRecovery ( recoveryListener ) ) ; } } } class GatewayRecoveryListener implements Gateway . GatewayStateRecoveredListener { @Override public void onSuccess ( final ClusterState recoveredState ) { logger . trace ( <str> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { assert currentState . metaData ( ) . indices ( ) . isEmpty ( ) ; ClusterBlocks . Builder blocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) . blocks ( recoveredState . blocks ( ) ) . removeGlobalBlock ( STATE_NOT_RECOVERED_BLOCK ) ; MetaData . Builder metaDataBuilder = MetaData . builder ( recoveredState . metaData ( ) ) ; metaDataBuilder . generateClusterUuidIfNeeded ( ) ; if ( recoveredState . metaData ( ) . settings ( ) . getAsBoolean ( MetaData . SETTING_READ_ONLY , false ) | | currentState . metaData ( ) . settings ( ) . getAsBoolean ( MetaData . SETTING_READ_ONLY , false ) ) { blocks . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ; } for ( IndexMetaData indexMetaData : recoveredState . metaData ( ) ) { metaDataBuilder . put ( indexMetaData , false ) ; blocks . addBlocks ( indexMetaData ) ; } ClusterState updatedState = ClusterState . builder ( currentState ) . blocks ( blocks ) . metaData ( metaDataBuilder ) . build ( ) ; RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( updatedState . routingTable ( ) ) ; for ( ObjectCursor < IndexMetaData > cursor : updatedState . metaData ( ) . indices ( ) . values ( ) ) { routingTableBuilder . addAsRecovery ( cursor . value ) ; } routingTableBuilder . version ( <int> ) ; RoutingAllocation . Result routingResult = allocationService . reroute ( ClusterState . builder ( updatedState ) . routingTable ( routingTableBuilder . build ( ) ) . build ( ) , <str> ) ; return ClusterState . builder ( updatedState ) . routingResult ( routingResult ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; GatewayRecoveryListener . this . onFailure ( <str> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { logger . info ( <str> , newState . metaData ( ) . indices ( ) . size ( ) ) ; } } ) ; } @Override public void onFailure ( String message ) { recovered . set ( false ) ; scheduledRecovery . set ( false ) ; logger . info ( <str> , message ) ; } } public TimeValue recoverAfterTime ( ) { return recoverAfterTime ; } } 
