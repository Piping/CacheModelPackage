package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . stream . Collectors ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . cql3 . Term . MultiColumnRaw ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; public class Tuples { private static final Logger logger = LoggerFactory . getLogger ( Tuples . class ) ; private Tuples ( ) { } public static ColumnSpecification componentSpecOf ( ColumnSpecification column , int component ) { return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( String . format ( <str> , column . name , component ) , true ) , ( ( TupleType ) column . type ) . type ( component ) ) ; } public static class Literal extends Term . MultiColumnRaw { private final List < Term . Raw > elements ; public Literal ( List < Term . Raw > elements ) { this . elements = elements ; } public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { validateAssignableTo ( keyspace , receiver ) ; List < Term > values = new ArrayList < > ( elements . size ( ) ) ; boolean allTerminal = true ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { Term value = elements . get ( i ) . prepare ( keyspace , componentSpecOf ( receiver , i ) ) ; if ( value instanceof Term . NonTerminal ) allTerminal = false ; values . add ( value ) ; } DelayedValue value = new DelayedValue ( ( TupleType ) receiver . type , values ) ; return allTerminal ? value . bind ( QueryOptions . DEFAULT ) : value ; } public Term prepare ( String keyspace , List < ? extends ColumnSpecification > receivers ) throws InvalidRequestException { if ( elements . size ( ) ! = receivers . size ( ) ) throw new InvalidRequestException ( String . format ( <str> , receivers . size ( ) , elements . size ( ) , this ) ) ; List < Term > values = new ArrayList < > ( elements . size ( ) ) ; List < AbstractType < ? > > types = new ArrayList < > ( elements . size ( ) ) ; boolean allTerminal = true ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { Term t = elements . get ( i ) . prepare ( keyspace , receivers . get ( i ) ) ; if ( t instanceof Term . NonTerminal ) allTerminal = false ; values . add ( t ) ; types . add ( receivers . get ( i ) . type ) ; } DelayedValue value = new DelayedValue ( new TupleType ( types ) , values ) ; return allTerminal ? value . bind ( QueryOptions . DEFAULT ) : value ; } private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof TupleType ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; TupleType tt = ( TupleType ) receiver . type ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { if ( i > = tt . size ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , tt . asCQL3Type ( ) , tt . size ( ) , elements . size ( ) ) ) ; Term . Raw value = elements . get ( i ) ; ColumnSpecification spec = componentSpecOf ( receiver , i ) ; if ( ! value . testAssignment ( keyspace , spec ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , i , spec . type . asCQL3Type ( ) ) ) ; } } public AssignmentTestable . TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { try { validateAssignableTo ( keyspace , receiver ) ; return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; } catch ( InvalidRequestException e ) { return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; } } public String getText ( ) { return elements . stream ( ) . map ( Term . Raw : : getText ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } } public static class Value extends Term . MultiItemTerminal { public final ByteBuffer [ ] elements ; public Value ( ByteBuffer [ ] elements ) { this . elements = elements ; } public static Value fromSerialized ( ByteBuffer bytes , TupleType type ) { return new Value ( type . split ( bytes ) ) ; } public ByteBuffer get ( int protocolVersion ) { return TupleType . buildValue ( elements ) ; } public List < ByteBuffer > getElements ( ) { return Arrays . asList ( elements ) ; } } public static class DelayedValue extends Term . NonTerminal { public final TupleType type ; public final List < Term > elements ; public DelayedValue ( TupleType type , List < Term > elements ) { this . type = type ; this . elements = elements ; } public boolean containsBindMarker ( ) { for ( Term term : elements ) if ( term . containsBindMarker ( ) ) return true ; return false ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { for ( Term term : elements ) term . collectMarkerSpecification ( boundNames ) ; } private ByteBuffer [ ] bindInternal ( QueryOptions options ) throws InvalidRequestException { ByteBuffer [ ] buffers = new ByteBuffer [ elements . size ( ) ] ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { buffers [ i ] = elements . get ( i ) . bindAndGet ( options ) ; if ( buffers [ i ] = = ByteBufferUtil . UNSET_BYTE_BUFFER ) throw new InvalidRequestException ( String . format ( <str> , i ) ) ; } return buffers ; } public Value bind ( QueryOptions options ) throws InvalidRequestException { return new Value ( bindInternal ( options ) ) ; } @Override public ByteBuffer bindAndGet ( QueryOptions options ) throws InvalidRequestException { return TupleType . buildValue ( bindInternal ( options ) ) ; } @Override public String toString ( ) { return tupleToString ( elements ) ; } public Iterable < Function > getFunctions ( ) { return Terms . getFunctions ( elements ) ; } } public static class InValue extends Term . Terminal { List < List < ByteBuffer > > elements ; public InValue ( List < List < ByteBuffer > > items ) { this . elements = items ; } public static InValue fromSerialized ( ByteBuffer value , ListType type , QueryOptions options ) throws InvalidRequestException { try { List < ? > l = type . getSerializer ( ) . deserializeForNativeProtocol ( value , options . getProtocolVersion ( ) ) ; assert type . getElementsType ( ) instanceof TupleType ; TupleType tupleType = ( TupleType ) type . getElementsType ( ) ; List < List < ByteBuffer > > elements = new ArrayList < > ( l . size ( ) ) ; for ( Object element : l ) elements . add ( Arrays . asList ( tupleType . split ( type . getElementsType ( ) . decompose ( element ) ) ) ) ; return new InValue ( elements ) ; } catch ( MarshalException e ) { throw new InvalidRequestException ( e . getMessage ( ) ) ; } } public ByteBuffer get ( int protocolVersion ) { throw new UnsupportedOperationException ( ) ; } public List < List < ByteBuffer > > getSplitValues ( ) { return elements ; } } public static class Raw extends AbstractMarker . MultiColumnRaw { public Raw ( int bindIndex ) { super ( bindIndex ) ; } private static ColumnSpecification makeReceiver ( List < ? extends ColumnSpecification > receivers ) { List < AbstractType < ? > > types = new ArrayList < > ( receivers . size ( ) ) ; StringBuilder inName = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < receivers . size ( ) ; i + + ) { ColumnSpecification receiver = receivers . get ( i ) ; inName . append ( receiver . name ) ; if ( i < receivers . size ( ) - <int> ) inName . append ( <str> ) ; types . add ( receiver . type ) ; } inName . append ( <str> ) ; ColumnIdentifier identifier = new ColumnIdentifier ( inName . toString ( ) , true ) ; TupleType type = new TupleType ( types ) ; return new ColumnSpecification ( receivers . get ( <int> ) . ksName , receivers . get ( <int> ) . cfName , identifier , type ) ; } public AbstractMarker prepare ( String keyspace , List < ? extends ColumnSpecification > receivers ) throws InvalidRequestException { return new Tuples . Marker ( bindIndex , makeReceiver ( receivers ) ) ; } } public static class INRaw extends AbstractMarker . MultiColumnRaw { public INRaw ( int bindIndex ) { super ( bindIndex ) ; } private static ColumnSpecification makeInReceiver ( List < ? extends ColumnSpecification > receivers ) throws InvalidRequestException { List < AbstractType < ? > > types = new ArrayList < > ( receivers . size ( ) ) ; StringBuilder inName = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < receivers . size ( ) ; i + + ) { ColumnSpecification receiver = receivers . get ( i ) ; inName . append ( receiver . name ) ; if ( i < receivers . size ( ) - <int> ) inName . append ( <str> ) ; if ( receiver . type . isCollection ( ) & & receiver . type . isMultiCell ( ) ) throw new InvalidRequestException ( <str> ) ; types . add ( receiver . type ) ; } inName . append ( <str> ) ; ColumnIdentifier identifier = new ColumnIdentifier ( inName . toString ( ) , true ) ; TupleType type = new TupleType ( types ) ; return new ColumnSpecification ( receivers . get ( <int> ) . ksName , receivers . get ( <int> ) . cfName , identifier , ListType . getInstance ( type , false ) ) ; } public AbstractMarker prepare ( String keyspace , List < ? extends ColumnSpecification > receivers ) throws InvalidRequestException { return new InMarker ( bindIndex , makeInReceiver ( receivers ) ) ; } } public static class Marker extends AbstractMarker { public Marker ( int bindIndex , ColumnSpecification receiver ) { super ( bindIndex , receiver ) ; } public Value bind ( QueryOptions options ) throws InvalidRequestException { ByteBuffer value = options . getValues ( ) . get ( bindIndex ) ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; return value = = null ? null : Value . fromSerialized ( value , ( TupleType ) receiver . type ) ; } } public static class InMarker extends AbstractMarker { protected InMarker ( int bindIndex , ColumnSpecification receiver ) { super ( bindIndex , receiver ) ; assert receiver . type instanceof ListType ; } public InValue bind ( QueryOptions options ) throws InvalidRequestException { ByteBuffer value = options . getValues ( ) . get ( bindIndex ) ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; return value = = null ? null : InValue . fromSerialized ( value , ( ListType ) receiver . type , options ) ; } } public static String tupleToString ( List < ? > items ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < items . size ( ) ; i + + ) { sb . append ( items . get ( i ) ) ; if ( i < items . size ( ) - <int> ) sb . append ( <str> ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } } 
