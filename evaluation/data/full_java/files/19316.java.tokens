package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseAggregator ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . compression . ZlibCodecFactory ; import io . netty . handler . codec . compression . ZlibWrapper ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_ENCODING ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_LENGTH ; import static io . netty . handler . codec . http . HttpHeaderValues . DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . GZIP ; import static io . netty . handler . codec . http . HttpHeaderValues . IDENTITY ; import static io . netty . handler . codec . http . HttpHeaderValues . X_DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . X_GZIP ; public class CompressorHttp2ConnectionEncoder extends DecoratingHttp2ConnectionEncoder { public static final int DEFAULT_COMPRESSION_LEVEL = <int> ; public static final int DEFAULT_WINDOW_BITS = <int> ; public static final int DEFAULT_MEM_LEVEL = <int> ; private final int compressionLevel ; private final int windowBits ; private final int memLevel ; private final Http2Connection . PropertyKey propertyKey ; public CompressorHttp2ConnectionEncoder ( Http2ConnectionEncoder delegate ) { this ( delegate , DEFAULT_COMPRESSION_LEVEL , DEFAULT_WINDOW_BITS , DEFAULT_MEM_LEVEL ) ; } public CompressorHttp2ConnectionEncoder ( Http2ConnectionEncoder delegate , int compressionLevel , int windowBits , int memLevel ) { super ( delegate ) ; if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( windowBits < <int> | | windowBits > <int> ) { throw new IllegalArgumentException ( <str> + windowBits + <str> ) ; } if ( memLevel < <int> | | memLevel > <int> ) { throw new IllegalArgumentException ( <str> + memLevel + <str> ) ; } this . compressionLevel = compressionLevel ; this . windowBits = windowBits ; this . memLevel = memLevel ; propertyKey = connection ( ) . newKey ( ) ; connection ( ) . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamRemoved ( Http2Stream stream ) { final EmbeddedChannel compressor = stream . getProperty ( propertyKey ) ; if ( compressor ! = null ) { cleanup ( stream , compressor ) ; } } } ) ; } @Override public ChannelFuture writeData ( final ChannelHandlerContext ctx , final int streamId , ByteBuf data , int padding , final boolean endOfStream , ChannelPromise promise ) { final Http2Stream stream = connection ( ) . stream ( streamId ) ; final EmbeddedChannel channel = stream = = null ? null : ( EmbeddedChannel ) stream . getProperty ( propertyKey ) ; if ( channel = = null ) { return super . writeData ( ctx , streamId , data , padding , endOfStream , promise ) ; } try { channel . writeOutbound ( data ) ; ByteBuf buf = nextReadableBuf ( channel ) ; if ( buf = = null ) { if ( endOfStream ) { if ( channel . finish ( ) ) { buf = nextReadableBuf ( channel ) ; } return super . writeData ( ctx , streamId , buf = = null ? Unpooled . EMPTY_BUFFER : buf , padding , true , promise ) ; } promise . setSuccess ( ) ; return promise ; } ChannelPromiseAggregator aggregator = new ChannelPromiseAggregator ( promise ) ; ChannelPromise bufPromise = ctx . newPromise ( ) ; aggregator . add ( bufPromise ) ; for ( ; ; ) { ByteBuf nextBuf = nextReadableBuf ( channel ) ; boolean compressedEndOfStream = nextBuf = = null & & endOfStream ; if ( compressedEndOfStream & & channel . finish ( ) ) { nextBuf = nextReadableBuf ( channel ) ; compressedEndOfStream = nextBuf = = null ; } final ChannelPromise nextPromise ; if ( nextBuf ! = null ) { nextPromise = ctx . newPromise ( ) ; aggregator . add ( nextPromise ) ; } else { nextPromise = null ; } super . writeData ( ctx , streamId , buf , padding , compressedEndOfStream , bufPromise ) ; if ( nextBuf = = null ) { break ; } padding = <int> ; buf = nextBuf ; bufPromise = nextPromise ; } return promise ; } finally { if ( endOfStream ) { cleanup ( stream , channel ) ; } } } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream , ChannelPromise promise ) { try { EmbeddedChannel compressor = newCompressor ( headers , endStream ) ; ChannelFuture future = super . writeHeaders ( ctx , streamId , headers , padding , endStream , promise ) ; bindCompressorToStream ( compressor , streamId ) ; return future ; } catch ( Throwable e ) { promise . tryFailure ( e ) ; } return promise ; } @Override public ChannelFuture writeHeaders ( final ChannelHandlerContext ctx , final int streamId , final Http2Headers headers , final int streamDependency , final short weight , final boolean exclusive , final int padding , final boolean endOfStream , final ChannelPromise promise ) { try { EmbeddedChannel compressor = newCompressor ( headers , endOfStream ) ; ChannelFuture future = super . writeHeaders ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ; bindCompressorToStream ( compressor , streamId ) ; return future ; } catch ( Throwable e ) { promise . tryFailure ( e ) ; } return promise ; } protected EmbeddedChannel newContentCompressor ( CharSequence contentEncoding ) throws Http2Exception { if ( GZIP . contentEqualsIgnoreCase ( contentEncoding ) | | X_GZIP . contentEqualsIgnoreCase ( contentEncoding ) ) { return newCompressionChannel ( ZlibWrapper . GZIP ) ; } if ( DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) | | X_DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) ) { return newCompressionChannel ( ZlibWrapper . ZLIB ) ; } return null ; } protected CharSequence getTargetContentEncoding ( CharSequence contentEncoding ) throws Http2Exception { return contentEncoding ; } private EmbeddedChannel newCompressionChannel ( ZlibWrapper wrapper ) { return new EmbeddedChannel ( ZlibCodecFactory . newZlibEncoder ( wrapper , compressionLevel , windowBits , memLevel ) ) ; } private EmbeddedChannel newCompressor ( Http2Headers headers , boolean endOfStream ) throws Http2Exception { if ( endOfStream ) { return null ; } CharSequence encoding = headers . get ( CONTENT_ENCODING ) ; if ( encoding = = null ) { encoding = IDENTITY ; } final EmbeddedChannel compressor = newContentCompressor ( encoding ) ; if ( compressor ! = null ) { CharSequence targetContentEncoding = getTargetContentEncoding ( encoding ) ; if ( IDENTITY . contentEqualsIgnoreCase ( targetContentEncoding ) ) { headers . remove ( CONTENT_ENCODING ) ; } else { headers . set ( CONTENT_ENCODING , targetContentEncoding ) ; } headers . remove ( CONTENT_LENGTH ) ; } return compressor ; } private void bindCompressorToStream ( EmbeddedChannel compressor , int streamId ) { if ( compressor ! = null ) { Http2Stream stream = connection ( ) . stream ( streamId ) ; if ( stream ! = null ) { stream . setProperty ( propertyKey , compressor ) ; } } } void cleanup ( Http2Stream stream , EmbeddedChannel compressor ) { if ( compressor . finish ( ) ) { for ( ; ; ) { final ByteBuf buf = compressor . readOutbound ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; } } stream . removeProperty ( propertyKey ) ; } private static ByteBuf nextReadableBuf ( EmbeddedChannel compressor ) { for ( ; ; ) { final ByteBuf buf = compressor . readOutbound ( ) ; if ( buf = = null ) { return null ; } if ( ! buf . isReadable ( ) ) { buf . release ( ) ; continue ; } return buf ; } } } 
