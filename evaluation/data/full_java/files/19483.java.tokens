package io . netty . handler . codec . mqtt ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . util . CharsetUtil ; import org . easymock . Mock ; import org . junit . Before ; import org . junit . Test ; import org . mockito . MockitoAnnotations ; import java . util . LinkedList ; import java . util . List ; import static org . junit . Assert . * ; import static org . mockito . Mockito . * ; public class MqttCodecTest { private static final String CLIENT_ID = <str> ; private static final String WILL_TOPIC = <str> ; private static final String WILL_MESSAGE = <str> ; private static final String USER_NAME = <str> ; private static final String PASSWORD = <str> ; private static final int KEEP_ALIVE_SECONDS = <int> ; private static final ByteBufAllocator ALLOCATOR = new UnpooledByteBufAllocator ( false ) ; @Mock private final ChannelHandlerContext ctx = mock ( ChannelHandlerContext . class ) ; @Mock private final Channel channel = mock ( Channel . class ) ; private final MqttDecoder mqttDecoder = new MqttDecoder ( ) ; @Before public void setup ( ) { MockitoAnnotations . initMocks ( this ) ; when ( ctx . channel ( ) ) . thenReturn ( channel ) ; } @Test public void testConnectMessageForMqtt31 ( ) throws Exception { final MqttConnectMessage message = createConnectMessage ( MqttVersion . MQTT_3_1 ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttConnectMessage decodedMessage = ( MqttConnectMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; vlidateConnectVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validateConnectPayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testConnectMessageForMqtt311 ( ) throws Exception { final MqttConnectMessage message = createConnectMessage ( MqttVersion . MQTT_3_1_1 ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttConnectMessage decodedMessage = ( MqttConnectMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; vlidateConnectVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validateConnectPayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testConnAckMessage ( ) throws Exception { final MqttConnAckMessage message = createConnAckMessage ( ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttConnAckMessage decodedMessage = ( MqttConnAckMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validateConnAckVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; } @Test public void testPublishMessage ( ) throws Exception { final MqttPublishMessage message = createPublishMessage ( ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttPublishMessage decodedMessage = ( MqttPublishMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validatePublishVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validatePublishPayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testPubAckMessage ( ) throws Exception { testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType . PUBACK ) ; } @Test public void testPubRecMessage ( ) throws Exception { testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType . PUBREC ) ; } @Test public void testPubRelMessage ( ) throws Exception { testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType . PUBREL ) ; } @Test public void testPubCompMessage ( ) throws Exception { testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType . PUBCOMP ) ; } @Test public void testSubscribeMessage ( ) throws Exception { final MqttSubscribeMessage message = createSubscribeMessage ( ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttSubscribeMessage decodedMessage = ( MqttSubscribeMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validateMessageIdVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validateSubscribePayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testSubAckMessage ( ) throws Exception { final MqttSubAckMessage message = createSubAckMessage ( ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttSubAckMessage decodedMessage = ( MqttSubAckMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validateMessageIdVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validateSubAckPayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testUnSubscribeMessage ( ) throws Exception { final MqttUnsubscribeMessage message = createUnsubscribeMessage ( ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttUnsubscribeMessage decodedMessage = ( MqttUnsubscribeMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validateMessageIdVariableHeader ( message . variableHeader ( ) , decodedMessage . variableHeader ( ) ) ; validateUnsubscribePayload ( message . payload ( ) , decodedMessage . payload ( ) ) ; } @Test public void testUnsubAckMessage ( ) throws Exception { testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType . UNSUBACK ) ; } @Test public void testPingReqMessage ( ) throws Exception { testMessageWithOnlyFixedHeader ( MqttMessageType . PINGREQ ) ; } @Test public void testPingRespMessage ( ) throws Exception { testMessageWithOnlyFixedHeader ( MqttMessageType . PINGRESP ) ; } @Test public void testDisconnectMessage ( ) throws Exception { testMessageWithOnlyFixedHeader ( MqttMessageType . DISCONNECT ) ; } private void testMessageWithOnlyFixedHeader ( MqttMessageType messageType ) throws Exception { MqttMessage message = createMessageWithFixedHeader ( messageType ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttMessage decodedMessage = ( MqttMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; } private void testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader ( MqttMessageType messageType ) throws Exception { MqttMessage message = createMessageWithFixedHeaderAndMessageIdVariableHeader ( messageType ) ; ByteBuf byteBuf = MqttEncoder . doEncode ( ALLOCATOR , message ) ; final List < Object > out = new LinkedList < Object > ( ) ; mqttDecoder . decode ( ctx , byteBuf , out ) ; assertEquals ( <str> + out . size ( ) , <int> , out . size ( ) ) ; final MqttMessage decodedMessage = ( MqttMessage ) out . get ( <int> ) ; validateFixedHeaders ( message . fixedHeader ( ) , decodedMessage . fixedHeader ( ) ) ; validateMessageIdVariableHeader ( ( MqttMessageIdVariableHeader ) message . variableHeader ( ) , ( MqttMessageIdVariableHeader ) decodedMessage . variableHeader ( ) ) ; } private static MqttMessage createMessageWithFixedHeader ( MqttMessageType messageType ) { return new MqttMessage ( new MqttFixedHeader ( messageType , false , MqttQoS . AT_MOST_ONCE , false , <int> ) ) ; } private static MqttMessage createMessageWithFixedHeaderAndMessageIdVariableHeader ( MqttMessageType messageType ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( messageType , false , messageType = = MqttMessageType . PUBREL ? MqttQoS . AT_LEAST_ONCE : MqttQoS . AT_MOST_ONCE , false , <int> ) ; MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader . from ( <int> ) ; return new MqttMessage ( mqttFixedHeader , mqttMessageIdVariableHeader ) ; } private static MqttConnectMessage createConnectMessage ( MqttVersion mqttVersion ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . CONNECT , false , MqttQoS . AT_MOST_ONCE , false , <int> ) ; MqttConnectVariableHeader mqttConnectVariableHeader = new MqttConnectVariableHeader ( mqttVersion . protocolName ( ) , mqttVersion . protocolLevel ( ) , true , true , true , <int> , true , true , KEEP_ALIVE_SECONDS ) ; MqttConnectPayload mqttConnectPayload = new MqttConnectPayload ( CLIENT_ID , WILL_TOPIC , WILL_MESSAGE , USER_NAME , PASSWORD ) ; return new MqttConnectMessage ( mqttFixedHeader , mqttConnectVariableHeader , mqttConnectPayload ) ; } private static MqttConnAckMessage createConnAckMessage ( ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . CONNACK , false , MqttQoS . AT_MOST_ONCE , false , <int> ) ; MqttConnAckVariableHeader mqttConnAckVariableHeader = new MqttConnAckVariableHeader ( MqttConnectReturnCode . CONNECTION_ACCEPTED , true ) ; return new MqttConnAckMessage ( mqttFixedHeader , mqttConnAckVariableHeader ) ; } private static MqttPublishMessage createPublishMessage ( ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . PUBLISH , false , MqttQoS . AT_LEAST_ONCE , true , <int> ) ; MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader ( <str> , <int> ) ; ByteBuf payload = ALLOCATOR . buffer ( ) ; payload . writeBytes ( <str> . getBytes ( CharsetUtil . UTF_8 ) ) ; return new MqttPublishMessage ( mqttFixedHeader , mqttPublishVariableHeader , payload ) ; } private static MqttSubscribeMessage createSubscribeMessage ( ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . SUBSCRIBE , false , MqttQoS . AT_LEAST_ONCE , true , <int> ) ; MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader . from ( <int> ) ; List < MqttTopicSubscription > topicSubscriptions = new LinkedList < MqttTopicSubscription > ( ) ; topicSubscriptions . add ( new MqttTopicSubscription ( <str> , MqttQoS . AT_LEAST_ONCE ) ) ; topicSubscriptions . add ( new MqttTopicSubscription ( <str> , MqttQoS . AT_LEAST_ONCE ) ) ; topicSubscriptions . add ( new MqttTopicSubscription ( <str> , MqttQoS . EXACTLY_ONCE ) ) ; MqttSubscribePayload mqttSubscribePayload = new MqttSubscribePayload ( topicSubscriptions ) ; return new MqttSubscribeMessage ( mqttFixedHeader , mqttMessageIdVariableHeader , mqttSubscribePayload ) ; } private static MqttSubAckMessage createSubAckMessage ( ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . SUBACK , false , MqttQoS . AT_MOST_ONCE , false , <int> ) ; MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader . from ( <int> ) ; MqttSubAckPayload mqttSubAckPayload = new MqttSubAckPayload ( <int> , <int> , <int> ) ; return new MqttSubAckMessage ( mqttFixedHeader , mqttMessageIdVariableHeader , mqttSubAckPayload ) ; } private static MqttUnsubscribeMessage createUnsubscribeMessage ( ) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader ( MqttMessageType . UNSUBSCRIBE , false , MqttQoS . AT_LEAST_ONCE , true , <int> ) ; MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader . from ( <int> ) ; List < String > topics = new LinkedList < String > ( ) ; topics . add ( <str> ) ; topics . add ( <str> ) ; topics . add ( <str> ) ; MqttUnsubscribePayload mqttUnsubscribePayload = new MqttUnsubscribePayload ( topics ) ; return new MqttUnsubscribeMessage ( mqttFixedHeader , mqttMessageIdVariableHeader , mqttUnsubscribePayload ) ; } private static void validateFixedHeaders ( MqttFixedHeader expected , MqttFixedHeader actual ) { assertEquals ( <str> , expected . messageType ( ) , actual . messageType ( ) ) ; assertEquals ( <str> , expected . qosLevel ( ) , actual . qosLevel ( ) ) ; } private static void vlidateConnectVariableHeader ( MqttConnectVariableHeader expected , MqttConnectVariableHeader actual ) { assertEquals ( <str> , expected . name ( ) , actual . name ( ) ) ; assertEquals ( <str> , expected . keepAliveTimeSeconds ( ) , actual . keepAliveTimeSeconds ( ) ) ; assertEquals ( <str> , expected . version ( ) , actual . version ( ) ) ; assertEquals ( <str> , expected . willQos ( ) , actual . willQos ( ) ) ; assertEquals ( <str> , expected . hasUserName ( ) , actual . hasUserName ( ) ) ; assertEquals ( <str> , expected . hasPassword ( ) , actual . hasPassword ( ) ) ; assertEquals ( <str> , expected . isCleanSession ( ) , actual . isCleanSession ( ) ) ; assertEquals ( <str> , expected . isWillFlag ( ) , actual . isWillFlag ( ) ) ; assertEquals ( <str> , expected . isWillRetain ( ) , actual . isWillRetain ( ) ) ; } private static void validateConnectPayload ( MqttConnectPayload expected , MqttConnectPayload actual ) { assertEquals ( <str> , expected . clientIdentifier ( ) , actual . clientIdentifier ( ) ) ; assertEquals ( <str> , expected . userName ( ) , actual . userName ( ) ) ; assertEquals ( <str> , expected . password ( ) , actual . password ( ) ) ; assertEquals ( <str> , expected . willMessage ( ) , actual . willMessage ( ) ) ; assertEquals ( <str> , expected . willTopic ( ) , actual . willTopic ( ) ) ; } private static void validateConnAckVariableHeader ( MqttConnAckVariableHeader expected , MqttConnAckVariableHeader actual ) { assertEquals ( <str> , expected . connectReturnCode ( ) , actual . connectReturnCode ( ) ) ; } private static void validatePublishVariableHeader ( MqttPublishVariableHeader expected , MqttPublishVariableHeader actual ) { assertEquals ( <str> , expected . topicName ( ) , actual . topicName ( ) ) ; assertEquals ( <str> , expected . messageId ( ) , actual . messageId ( ) ) ; } private static void validatePublishPayload ( ByteBuf expected , ByteBuf actual ) { assertEquals ( <str> , <int> , expected . compareTo ( actual ) ) ; } private static void validateMessageIdVariableHeader ( MqttMessageIdVariableHeader expected , MqttMessageIdVariableHeader actual ) { assertEquals ( <str> , expected . messageId ( ) , actual . messageId ( ) ) ; } private static void validateSubscribePayload ( MqttSubscribePayload expected , MqttSubscribePayload actual ) { List < MqttTopicSubscription > expectedTopicSubscriptions = expected . topicSubscriptions ( ) ; List < MqttTopicSubscription > actualTopicSubscriptions = actual . topicSubscriptions ( ) ; assertEquals ( <str> , expectedTopicSubscriptions . size ( ) , actualTopicSubscriptions . size ( ) ) ; for ( int i = <int> ; i < expectedTopicSubscriptions . size ( ) ; i + + ) { validateTopicSubscription ( expectedTopicSubscriptions . get ( i ) , actualTopicSubscriptions . get ( i ) ) ; } } private static void validateTopicSubscription ( MqttTopicSubscription expected , MqttTopicSubscription actual ) { assertEquals ( <str> , expected . topicName ( ) , actual . topicName ( ) ) ; assertEquals ( <str> , expected . qualityOfService ( ) , actual . qualityOfService ( ) ) ; } private static void validateSubAckPayload ( MqttSubAckPayload expected , MqttSubAckPayload actual ) { assertArrayEquals ( <str> , expected . grantedQoSLevels ( ) . toArray ( ) , actual . grantedQoSLevels ( ) . toArray ( ) ) ; } private static void validateUnsubscribePayload ( MqttUnsubscribePayload expected , MqttUnsubscribePayload actual ) { assertArrayEquals ( <str> , expected . topics ( ) . toArray ( ) , actual . topics ( ) . toArray ( ) ) ; } } 
