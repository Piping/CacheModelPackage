package org . nd4j . linalg . jcublas . buffer ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import jcuda . Pointer ; import jcuda . Sizeof ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . util . ArrayUtil ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; public class CudaDoubleDataBuffer extends BaseCudaDataBuffer { public CudaDoubleDataBuffer ( int length ) { super ( length , Sizeof . DOUBLE ) ; } public CudaDoubleDataBuffer ( double [ ] data ) { this ( data . length ) ; setData ( data ) ; } public CudaDoubleDataBuffer ( float [ ] data ) { super ( data ) ; } public CudaDoubleDataBuffer ( int [ ] data ) { super ( data ) ; } public CudaDoubleDataBuffer ( ByteBuf buf , int length ) { super ( buf , length ) ; } public CudaDoubleDataBuffer ( byte [ ] data , int length ) { super ( data , length ) ; } public CudaDoubleDataBuffer ( ByteBuffer buffer , int length ) { super ( buffer , length ) ; } @Override public void assign ( int [ ] indices , float [ ] data , boolean contiguous , int inc ) { modified . set ( true ) ; if ( indices . length ! = data . length ) throw new IllegalArgumentException ( <str> ) ; if ( indices . length > length ( ) ) throw new IllegalArgumentException ( <str> + length ( ) + <str> + data . length ) ; if ( contiguous ) { int offset = indices [ <int> ] ; Pointer p = Pointer . to ( data ) ; set ( offset , data . length , p , inc ) ; } else throw new UnsupportedOperationException ( <str> ) ; } @Override public void assign ( int [ ] indices , double [ ] data , boolean contiguous , int inc ) { if ( indices . length ! = data . length ) throw new IllegalArgumentException ( <str> ) ; if ( indices . length > length ( ) ) throw new IllegalArgumentException ( <str> + length ( ) + <str> + data . length ) ; if ( contiguous ) { int offset = indices [ <int> ] ; Pointer p = Pointer . to ( data ) ; set ( offset , data . length , p , inc ) ; } else throw new UnsupportedOperationException ( <str> ) ; } @Override protected DataBuffer create ( int length ) { return new CudaDoubleDataBuffer ( length ) ; } @Override public void setData ( int [ ] data ) { setData ( ArrayUtil . toDoubles ( data ) ) ; } @Override public void setData ( float [ ] data ) { setData ( ArrayUtil . toDoubles ( data ) ) ; } @Override public DataBuffer . Type dataType ( ) { return DataBuffer . Type . DOUBLE ; } @Override public DataBuffer create ( double [ ] data ) { return new CudaDoubleDataBuffer ( data ) ; } @Override public DataBuffer create ( float [ ] data ) { return new CudaDoubleDataBuffer ( data ) ; } @Override public DataBuffer create ( int [ ] data ) { return new CudaDoubleDataBuffer ( data ) ; } @Override public DataBuffer create ( ByteBuf buf , int length ) { return new CudaDoubleDataBuffer ( buf , length ) ; } private void writeObject ( java . io . ObjectOutputStream stream ) throws java . io . IOException { stream . defaultWriteObject ( ) ; if ( getHostPointer ( ) = = null ) { stream . writeInt ( <int> ) ; } else { double [ ] arr = this . asDouble ( ) ; stream . writeInt ( arr . length ) ; for ( int i = <int> ; i < arr . length ; i + + ) { stream . writeDouble ( arr [ i ] ) ; } } } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; int n = stream . readInt ( ) ; double [ ] arr = new double [ n ] ; for ( int i = <int> ; i < n ; i + + ) { arr [ i ] = stream . readDouble ( ) ; } this . length = n ; this . elementSize = Sizeof . DOUBLE ; wrappedBuffer = ByteBuffer . allocateDirect ( length ( ) * getElementSize ( ) ) ; wrappedBuffer . order ( ByteOrder . nativeOrder ( ) ) ; setData ( arr ) ; } } 
