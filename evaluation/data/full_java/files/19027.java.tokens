package io . netty . handler . codec . dns ; import io . netty . buffer . ByteBuf ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . socket . DatagramPacket ; import io . netty . handler . codec . MessageToMessageEncoder ; import java . net . InetSocketAddress ; import java . util . List ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; @ChannelHandler.Sharable public class DatagramDnsQueryEncoder extends MessageToMessageEncoder < AddressedEnvelope < DnsQuery , InetSocketAddress > > { private final DnsRecordEncoder recordEncoder ; public DatagramDnsQueryEncoder ( ) { this ( DnsRecordEncoder . DEFAULT ) ; } public DatagramDnsQueryEncoder ( DnsRecordEncoder recordEncoder ) { this . recordEncoder = checkNotNull ( recordEncoder , <str> ) ; } @Override protected void encode ( ChannelHandlerContext ctx , AddressedEnvelope < DnsQuery , InetSocketAddress > in , List < Object > out ) throws Exception { final InetSocketAddress recipient = in . recipient ( ) ; final DnsQuery query = in . content ( ) ; final ByteBuf buf = allocateBuffer ( ctx , in ) ; boolean success = false ; try { encodeHeader ( query , buf ) ; encodeQuestions ( query , buf ) ; encodeRecords ( query , DnsSection . ADDITIONAL , buf ) ; success = true ; } finally { if ( ! success ) { buf . release ( ) ; } } out . add ( new DatagramPacket ( buf , recipient , null ) ) ; } protected ByteBuf allocateBuffer ( ChannelHandlerContext ctx , @SuppressWarnings ( <str> ) AddressedEnvelope < DnsQuery , InetSocketAddress > msg ) throws Exception { return ctx . alloc ( ) . ioBuffer ( <int> ) ; } private static void encodeHeader ( DnsQuery query , ByteBuf buf ) { buf . writeShort ( query . id ( ) ) ; int flags = <int> ; flags | = ( query . opCode ( ) . byteValue ( ) & <hex> ) < < <int> ; flags | = query . isRecursionDesired ( ) ? <int> < < <int> : <int> ; buf . writeShort ( flags ) ; buf . writeShort ( query . count ( DnsSection . QUESTION ) ) ; buf . writeShort ( <int> ) ; buf . writeShort ( <int> ) ; buf . writeShort ( query . count ( DnsSection . ADDITIONAL ) ) ; } private void encodeQuestions ( DnsQuery query , ByteBuf buf ) throws Exception { final int count = query . count ( DnsSection . QUESTION ) ; for ( int i = <int> ; i < count ; i + + ) { recordEncoder . encodeQuestion ( ( DnsQuestion ) query . recordAt ( DnsSection . QUESTION , i ) , buf ) ; } } private void encodeRecords ( DnsQuery query , DnsSection section , ByteBuf buf ) throws Exception { final int count = query . count ( section ) ; for ( int i = <int> ; i < count ; i + + ) { recordEncoder . encodeRecord ( query . recordAt ( section , i ) , buf ) ; } } } 
