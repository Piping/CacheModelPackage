package org . gradle . messaging . remote . internal ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . messaging . dispatch . * ; import java . util . HashSet ; import java . util . Set ; public class AsyncConnectionAdapter < T > implements AsyncConnection < T > , Stoppable { private final Connection < T > connection ; private final AsyncReceive < T > incoming ; private final ProtocolStack < T > stack ; private final AsyncDispatch < T > outgoing ; private final Set < Stoppable > executors = new HashSet < Stoppable > ( ) ; public AsyncConnectionAdapter ( Connection < T > connection , DispatchFailureHandler < ? super T > dispatchFailureHandler , ExecutorFactory executor , Protocol < T > . . . protocols ) { this . connection = connection ; StoppableExecutor outgoingExecutor = executor . create ( String . format ( <str> , connection ) ) ; executors . add ( outgoingExecutor ) ; outgoing = new AsyncDispatch < T > ( outgoingExecutor ) ; outgoing . dispatchTo ( new FailureHandlingDispatch < T > ( connection , dispatchFailureHandler ) ) ; StoppableExecutor dispatchExecutor = executor . create ( String . format ( <str> , connection ) ) ; executors . add ( dispatchExecutor ) ; stack = new ProtocolStack < T > ( dispatchExecutor , dispatchFailureHandler , dispatchFailureHandler , protocols ) ; stack . getBottom ( ) . dispatchTo ( outgoing ) ; StoppableExecutor incomingExecutor = executor . create ( String . format ( <str> , connection ) ) ; executors . add ( incomingExecutor ) ; incoming = new AsyncReceive < T > ( incomingExecutor ) ; incoming . dispatchTo ( stack . getBottom ( ) ) ; incoming . receiveFrom ( new ConnectionReceive < T > ( connection ) ) ; } public void dispatch ( T message ) { stack . getTop ( ) . dispatch ( message ) ; } public void dispatchTo ( Dispatch < ? super T > handler ) { stack . getTop ( ) . dispatchTo ( handler ) ; } public void stop ( ) { CompositeStoppable . stoppable ( stack , outgoing , connection , incoming ) . add ( executors ) . stop ( ) ; } private class ConnectionReceive < T > implements Receive < T > { private final Connection < T > connection ; public ConnectionReceive ( Connection < T > connection ) { this . connection = connection ; } public T receive ( ) { T result = connection . receive ( ) ; if ( result = = null ) { stack . requestStop ( ) ; } return result ; } } } 
