package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNodeFilters ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . Map ; import static org . elasticsearch . cluster . node . DiscoveryNodeFilters . OpType . AND ; import static org . elasticsearch . cluster . node . DiscoveryNodeFilters . OpType . OR ; public class FilterAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String INDEX_ROUTING_REQUIRE_GROUP = <str> ; public static final String INDEX_ROUTING_INCLUDE_GROUP = <str> ; public static final String INDEX_ROUTING_EXCLUDE_GROUP = <str> ; public static final String CLUSTER_ROUTING_REQUIRE_GROUP = <str> ; public static final String CLUSTER_ROUTING_INCLUDE_GROUP = <str> ; public static final String CLUSTER_ROUTING_EXCLUDE_GROUP = <str> ; private volatile DiscoveryNodeFilters clusterRequireFilters ; private volatile DiscoveryNodeFilters clusterIncludeFilters ; private volatile DiscoveryNodeFilters clusterExcludeFilters ; @Inject public FilterAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; Map < String , String > requireMap = settings . getByPrefix ( CLUSTER_ROUTING_REQUIRE_GROUP ) . getAsMap ( ) ; if ( requireMap . isEmpty ( ) ) { clusterRequireFilters = null ; } else { clusterRequireFilters = DiscoveryNodeFilters . buildFromKeyValue ( AND , requireMap ) ; } Map < String , String > includeMap = settings . getByPrefix ( CLUSTER_ROUTING_INCLUDE_GROUP ) . getAsMap ( ) ; if ( includeMap . isEmpty ( ) ) { clusterIncludeFilters = null ; } else { clusterIncludeFilters = DiscoveryNodeFilters . buildFromKeyValue ( OR , includeMap ) ; } Map < String , String > excludeMap = settings . getByPrefix ( CLUSTER_ROUTING_EXCLUDE_GROUP ) . getAsMap ( ) ; if ( excludeMap . isEmpty ( ) ) { clusterExcludeFilters = null ; } else { clusterExcludeFilters = DiscoveryNodeFilters . buildFromKeyValue ( OR , excludeMap ) ; } nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return shouldFilter ( shardRouting , node , allocation ) ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return shouldFilter ( shardRouting , node , allocation ) ; } private Decision shouldFilter ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( clusterRequireFilters ! = null ) { if ( ! clusterRequireFilters . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , clusterRequireFilters ) ; } } if ( clusterIncludeFilters ! = null ) { if ( ! clusterIncludeFilters . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , clusterIncludeFilters ) ; } } if ( clusterExcludeFilters ! = null ) { if ( clusterExcludeFilters . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , clusterExcludeFilters ) ; } } IndexMetaData indexMd = allocation . routingNodes ( ) . metaData ( ) . index ( shardRouting . index ( ) ) ; if ( indexMd . requireFilters ( ) ! = null ) { if ( ! indexMd . requireFilters ( ) . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , indexMd . requireFilters ( ) ) ; } } if ( indexMd . includeFilters ( ) ! = null ) { if ( ! indexMd . includeFilters ( ) . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , indexMd . includeFilters ( ) ) ; } } if ( indexMd . excludeFilters ( ) ! = null ) { if ( indexMd . excludeFilters ( ) . match ( node . node ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , indexMd . excludeFilters ( ) ) ; } } return allocation . decision ( Decision . YES , NAME , <str> ) ; } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { Map < String , String > requireMap = settings . getByPrefix ( CLUSTER_ROUTING_REQUIRE_GROUP ) . getAsMap ( ) ; if ( ! requireMap . isEmpty ( ) ) { clusterRequireFilters = DiscoveryNodeFilters . buildFromKeyValue ( AND , requireMap ) ; } Map < String , String > includeMap = settings . getByPrefix ( CLUSTER_ROUTING_INCLUDE_GROUP ) . getAsMap ( ) ; if ( ! includeMap . isEmpty ( ) ) { clusterIncludeFilters = DiscoveryNodeFilters . buildFromKeyValue ( OR , includeMap ) ; } Map < String , String > excludeMap = settings . getByPrefix ( CLUSTER_ROUTING_EXCLUDE_GROUP ) . getAsMap ( ) ; if ( ! excludeMap . isEmpty ( ) ) { clusterExcludeFilters = DiscoveryNodeFilters . buildFromKeyValue ( OR , excludeMap ) ; } } } } 
