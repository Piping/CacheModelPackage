package com . google . common . primitives ; import static java . math . BigInteger . ONE ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . Comparator ; import java . util . List ; import java . util . Random ; @GwtCompatible ( emulated = true ) public class UnsignedLongsTest extends TestCase { private static final long LEAST = <int> L ; private static final long GREATEST = <hex> ; public void testCompare ( ) { assertTrue ( UnsignedLongs . compare ( <int> , <hex> ) < <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <int> ) > <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) < <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) > <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) < <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) > <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) < <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) > <int> ) ; assertTrue ( UnsignedLongs . compare ( <hex> , <hex> ) = = <int> ) ; } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { UnsignedLongs . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( LEAST , UnsignedLongs . max ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedLongs . max ( GREATEST ) ) ; assertEquals ( <hex> , UnsignedLongs . max ( <hex> , <int> , <int> , <int> L , <hex> , <hex> ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { UnsignedLongs . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( LEAST , UnsignedLongs . min ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedLongs . min ( GREATEST ) ) ; assertEquals ( <int> L , UnsignedLongs . min ( <hex> , <int> , <int> , <int> L , <hex> , <hex> ) ) ; } public void testLexicographicalComparator ( ) { List < long [ ] > ordered = Arrays . asList ( new long [ ] { } , new long [ ] { LEAST } , new long [ ] { LEAST , LEAST } , new long [ ] { LEAST , ( long ) <int> } , new long [ ] { ( long ) <int> } , new long [ ] { ( long ) <int> , LEAST } , new long [ ] { GREATEST , GREATEST - ( long ) <int> } , new long [ ] { GREATEST , GREATEST } , new long [ ] { GREATEST , GREATEST , GREATEST } ) ; Comparator < long [ ] > comparator = UnsignedLongs . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; } public void testDivide ( ) { assertEquals ( <int> , UnsignedLongs . divide ( <int> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . divide ( <int> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . divide ( <hex> , <hex> ) ) ; assertEquals ( <int> , UnsignedLongs . divide ( <hex> , <hex> ) ) ; assertEquals ( <int> , UnsignedLongs . divide ( <hex> , <int> ) ) ; assertEquals ( <hex> , UnsignedLongs . divide ( <hex> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . divide ( <hex> , <int> ) ) ; } public void testRemainder ( ) { assertEquals ( <int> , UnsignedLongs . remainder ( <int> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . remainder ( <int> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . remainder ( <hex> , <hex> ) ) ; assertEquals ( <hex> , UnsignedLongs . remainder ( <hex> , <hex> ) ) ; assertEquals ( <int> , UnsignedLongs . remainder ( <hex> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . remainder ( <hex> , <int> ) ) ; assertEquals ( <int> , UnsignedLongs . remainder ( <hex> , <int> ) ) ; } @GwtIncompatible ( <str> ) public void testDivideRemainderEuclideanProperty ( ) { Random r = new Random ( <int> L ) ; for ( int i = <int> ; i < <int> ; i + + ) { long dividend = r . nextLong ( ) ; long divisor = r . nextLong ( ) ; assertEquals ( <int> , dividend - ( divisor * UnsignedLongs . divide ( dividend , divisor ) + UnsignedLongs . remainder ( dividend , divisor ) ) ) ; } } public void testParseLong ( ) { assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testParseLongFails ( ) { try { UnsignedLongs . parseUnsignedLong ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testDecodeLong ( ) { assertEquals ( <hex> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <oct> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <int> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedLongs . decode ( <str> ) ) ; assertEquals ( <int> L , UnsignedLongs . decode ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testDecodeLongFails ( ) { try { UnsignedLongs . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedLongs . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedLongs . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedLongs . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testParseLongWithRadix ( ) { assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> , <int> ) ) ; assertEquals ( <hex> , UnsignedLongs . parseUnsignedLong ( <str> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testParseLongWithRadixLimits ( ) { BigInteger max = BigInteger . ZERO . setBit ( <int> ) . subtract ( ONE ) ; for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { String maxAsString = max . toString ( radix ) ; assertEquals ( max . longValue ( ) , UnsignedLongs . parseUnsignedLong ( maxAsString , radix ) ) ; try { BigInteger overflow = max . add ( ONE ) ; String overflowAsString = overflow . toString ( radix ) ; UnsignedLongs . parseUnsignedLong ( overflowAsString , radix ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } try { UnsignedLongs . parseUnsignedLong ( <str> , <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } @SuppressWarnings ( <str> ) public void testParseLongThrowsExceptionForInvalidRadix ( ) { try { UnsignedLongs . parseUnsignedLong ( <str> , Character . MIN_RADIX - <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedLongs . parseUnsignedLong ( <str> , Character . MAX_RADIX + <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedLongs . parseUnsignedLong ( <str> , - <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testToString ( ) { String [ ] tests = { <str> , <str> , <str> , <str> , <str> } ; int [ ] bases = { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int base : bases ) { for ( String x : tests ) { BigInteger xValue = new BigInteger ( x , <int> ) ; long xLong = xValue . longValue ( ) ; assertEquals ( xValue . toString ( base ) , UnsignedLongs . toString ( xLong , base ) ) ; } } } public void testJoin ( ) { assertEquals ( <str> , UnsignedLongs . join ( <str> ) ) ; assertEquals ( <str> , UnsignedLongs . join ( <str> , <int> ) ) ; assertEquals ( <str> , UnsignedLongs . join ( <str> , <int> , <int> ) ) ; assertEquals ( <str> , UnsignedLongs . join ( <str> , - <int> , Long . MIN_VALUE ) ) ; assertEquals ( <str> , UnsignedLongs . join ( <str> , <int> , <int> , <int> ) ) ; assertEquals ( <str> , UnsignedLongs . join ( <str> , - <int> , Long . MIN_VALUE ) ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( UnsignedLongs . class ) ; } } 
