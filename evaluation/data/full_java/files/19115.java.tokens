package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import java . net . URI ; import java . util . ArrayList ; import java . nio . charset . Charset ; import java . nio . charset . UnsupportedCharsetException ; import java . util . Iterator ; import java . util . List ; public final class HttpUtil { @Deprecated static final EmptyHttpHeaders EMPTY_HEADERS = new EmptyHttpHeaders ( ) ; private static final AsciiString CHARSET_EQUALS = AsciiString . of ( HttpHeaderValues . CHARSET + <str> ) ; private HttpUtil ( ) { } public static boolean isOriginForm ( URI uri ) { return uri . getScheme ( ) = = null & & uri . getSchemeSpecificPart ( ) = = null & & uri . getHost ( ) = = null & & uri . getAuthority ( ) = = null ; } public static boolean isAsteriskForm ( URI uri ) { return <str> . equals ( uri . getPath ( ) ) & & uri . getScheme ( ) = = null & & uri . getSchemeSpecificPart ( ) = = null & & uri . getHost ( ) = = null & & uri . getAuthority ( ) = = null & & uri . getQuery ( ) = = null & & uri . getFragment ( ) = = null ; } public static boolean isKeepAlive ( HttpMessage message ) { CharSequence connection = message . headers ( ) . get ( HttpHeaderNames . CONNECTION ) ; if ( connection ! = null & & HttpHeaderValues . CLOSE . contentEqualsIgnoreCase ( connection ) ) { return false ; } if ( message . protocolVersion ( ) . isKeepAliveDefault ( ) ) { return ! HttpHeaderValues . CLOSE . contentEqualsIgnoreCase ( connection ) ; } else { return HttpHeaderValues . KEEP_ALIVE . contentEqualsIgnoreCase ( connection ) ; } } public static void setKeepAlive ( HttpMessage message , boolean keepAlive ) { setKeepAlive ( message . headers ( ) , message . protocolVersion ( ) , keepAlive ) ; } public static void setKeepAlive ( HttpHeaders h , HttpVersion httpVersion , boolean keepAlive ) { if ( httpVersion . isKeepAliveDefault ( ) ) { if ( keepAlive ) { h . remove ( HttpHeaderNames . CONNECTION ) ; } else { h . set ( HttpHeaderNames . CONNECTION , HttpHeaderValues . CLOSE ) ; } } else { if ( keepAlive ) { h . set ( HttpHeaderNames . CONNECTION , HttpHeaderValues . KEEP_ALIVE ) ; } else { h . remove ( HttpHeaderNames . CONNECTION ) ; } } } public static long getContentLength ( HttpMessage message ) { String value = message . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ; if ( value ! = null ) { return Long . parseLong ( value ) ; } long webSocketContentLength = getWebSocketContentLength ( message ) ; if ( webSocketContentLength > = <int> ) { return webSocketContentLength ; } throw new NumberFormatException ( <str> + HttpHeaderNames . CONTENT_LENGTH ) ; } public static long getContentLength ( HttpMessage message , long defaultValue ) { String value = message . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ; if ( value ! = null ) { return Long . parseLong ( value ) ; } long webSocketContentLength = getWebSocketContentLength ( message ) ; if ( webSocketContentLength > = <int> ) { return webSocketContentLength ; } return defaultValue ; } public static int getContentLength ( HttpMessage message , int defaultValue ) { return ( int ) Math . min ( Integer . MAX_VALUE , getContentLength ( message , ( long ) defaultValue ) ) ; } private static int getWebSocketContentLength ( HttpMessage message ) { HttpHeaders h = message . headers ( ) ; if ( message instanceof HttpRequest ) { HttpRequest req = ( HttpRequest ) message ; if ( HttpMethod . GET . equals ( req . method ( ) ) & & h . contains ( HttpHeaderNames . SEC_WEBSOCKET_KEY1 ) & & h . contains ( HttpHeaderNames . SEC_WEBSOCKET_KEY2 ) ) { return <int> ; } } else if ( message instanceof HttpResponse ) { HttpResponse res = ( HttpResponse ) message ; if ( res . status ( ) . code ( ) = = <int> & & h . contains ( HttpHeaderNames . SEC_WEBSOCKET_ORIGIN ) & & h . contains ( HttpHeaderNames . SEC_WEBSOCKET_LOCATION ) ) { return <int> ; } } return - <int> ; } public static void setContentLength ( HttpMessage message , long length ) { message . headers ( ) . set ( HttpHeaderNames . CONTENT_LENGTH , length ) ; } public static boolean isContentLengthSet ( HttpMessage m ) { return m . headers ( ) . contains ( HttpHeaderNames . CONTENT_LENGTH ) ; } public static boolean is100ContinueExpected ( HttpMessage message ) { if ( ! ( message instanceof HttpRequest ) ) { return false ; } if ( message . protocolVersion ( ) . compareTo ( HttpVersion . HTTP_1_1 ) < <int> ) { return false ; } CharSequence value = message . headers ( ) . get ( HttpHeaderNames . EXPECT ) ; if ( value = = null ) { return false ; } if ( HttpHeaderValues . CONTINUE . contentEqualsIgnoreCase ( value ) ) { return true ; } return message . headers ( ) . contains ( HttpHeaderNames . EXPECT , HttpHeaderValues . CONTINUE , true ) ; } public static void set100ContinueExpected ( HttpMessage message , boolean expected ) { if ( expected ) { message . headers ( ) . set ( HttpHeaderNames . EXPECT , HttpHeaderValues . CONTINUE ) ; } else { message . headers ( ) . remove ( HttpHeaderNames . EXPECT ) ; } } public static boolean isTransferEncodingChunked ( HttpMessage message ) { return message . headers ( ) . contains ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED , true ) ; } public static void setTransferEncodingChunked ( HttpMessage m , boolean chunked ) { if ( chunked ) { m . headers ( ) . add ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; m . headers ( ) . remove ( HttpHeaderNames . CONTENT_LENGTH ) ; } else { List < String > encodings = m . headers ( ) . getAll ( HttpHeaderNames . TRANSFER_ENCODING ) ; if ( encodings . isEmpty ( ) ) { return ; } List < CharSequence > values = new ArrayList < CharSequence > ( encodings ) ; Iterator < CharSequence > valuesIt = values . iterator ( ) ; while ( valuesIt . hasNext ( ) ) { CharSequence value = valuesIt . next ( ) ; if ( HttpHeaderValues . CHUNKED . contentEqualsIgnoreCase ( value ) ) { valuesIt . remove ( ) ; } } if ( values . isEmpty ( ) ) { m . headers ( ) . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; } else { m . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , values ) ; } } } public static Charset getCharset ( HttpMessage message ) { return getCharset ( message , CharsetUtil . ISO_8859_1 ) ; } public static Charset getCharset ( HttpMessage message , Charset defaultCharset ) { CharSequence charsetCharSequence = getCharsetAsString ( message ) ; if ( charsetCharSequence ! = null ) { try { return Charset . forName ( charsetCharSequence . toString ( ) ) ; } catch ( UnsupportedCharsetException unsupportedException ) { return defaultCharset ; } } else { return defaultCharset ; } } public static CharSequence getCharsetAsString ( HttpMessage message ) { CharSequence contentTypeValue = message . headers ( ) . get ( HttpHeaderNames . CONTENT_TYPE ) ; if ( contentTypeValue ! = null ) { int indexOfCharset = AsciiString . indexOfIgnoreCaseAscii ( contentTypeValue , CHARSET_EQUALS , <int> ) ; if ( indexOfCharset ! = AsciiString . INDEX_NOT_FOUND ) { int indexOfEncoding = indexOfCharset + CHARSET_EQUALS . length ( ) ; if ( indexOfEncoding < contentTypeValue . length ( ) ) { return contentTypeValue . subSequence ( indexOfEncoding , contentTypeValue . length ( ) ) ; } } } return null ; } static void encodeAscii0 ( CharSequence seq , ByteBuf buf ) { int length = seq . length ( ) ; for ( int i = <int> ; i < length ; i + + ) { buf . writeByte ( c2b ( seq . charAt ( i ) ) ) ; } } private static byte c2b ( char c ) { return c > <int> ? ( byte ) <str> : ( byte ) c ; } } 
