package com . badlogic . gdx . tests . g3d . shadows . utils ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; public class BoundingSphereDirectionalAnalyzer implements DirectionalAnalyzer { protected BoundingBox bb = new BoundingBox ( ) ; protected Vector3 tmpV = new Vector3 ( ) ; protected Vector3 tmpV2 = new Vector3 ( ) ; @Override public Camera analyze ( DirectionalLight light , Camera out , Camera mainCamera ) { bb . inf ( ) ; for ( int i = <int> ; i < mainCamera . frustum . planePoints . length ; i + + ) { bb . ext ( mainCamera . frustum . planePoints [ i ] ) ; } float radius = bb . getDimensions ( tmpV ) . len ( ) * <float> ; bb . getCenter ( tmpV ) ; tmpV2 . set ( light . direction ) ; tmpV2 . scl ( radius * <float> ) ; out . direction . set ( light . direction ) ; out . position . set ( tmpV . sub ( tmpV2 ) ) ; out . near = <float> * radius ; out . far = <float> * radius ; Vector3 d = light . direction ; if ( d . z < d . x + d . y ) out . up . set ( - light . direction . y , light . direction . x , light . direction . z ) ; else out . up . set ( light . direction . x , - light . direction . z , light . direction . y ) ; out . viewportWidth = radius ; out . viewportHeight = radius ; return out ; } } 
