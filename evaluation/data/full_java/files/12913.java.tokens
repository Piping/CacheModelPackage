package org . gradle . internal . rules ; import org . gradle . api . specs . Spec ; import org . gradle . internal . reflect . JavaMethod ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . model . Mutate ; import org . gradle . model . internal . inspect . ValidationProblemCollector ; import org . gradle . model . internal . type . ModelType ; import java . lang . reflect . Method ; import java . lang . reflect . Type ; import java . util . Arrays ; import java . util . List ; public class RuleSourceBackedRuleAction < R , T > implements RuleAction < T > { private final R instance ; private final JavaMethod < R , T > ruleMethod ; private final List < Class < ? > > inputTypes ; private RuleSourceBackedRuleAction ( R instance , JavaMethod < R , T > ruleMethod ) { this . instance = instance ; this . ruleMethod = ruleMethod ; this . inputTypes = determineInputTypes ( ruleMethod . getParameterTypes ( ) ) ; } public static < R , T > RuleSourceBackedRuleAction < R , T > create ( ModelType < T > subjectType , R ruleSourceInstance ) { ModelType < R > ruleSourceType = ModelType . typeOf ( ruleSourceInstance ) ; List < Method > mutateMethods = JavaReflectionUtil . findAllMethods ( ruleSourceType . getConcreteClass ( ) , new Spec < Method > ( ) { public boolean isSatisfiedBy ( Method element ) { return element . isAnnotationPresent ( Mutate . class ) ; } } ) ; ValidationProblemCollector problems = new ValidationProblemCollector ( ruleSourceType ) ; if ( mutateMethods . size ( ) = = <int> ) { problems . add ( <str> + Mutate . class . getName ( ) ) ; } else { if ( mutateMethods . size ( ) > <int> ) { problems . add ( <str> + Mutate . class . getName ( ) ) ; } for ( Method ruleMethod : mutateMethods ) { if ( ruleMethod . getReturnType ( ) ! = Void . TYPE ) { problems . add ( ruleMethod , <str> ) ; } Type [ ] parameterTypes = ruleMethod . getGenericParameterTypes ( ) ; if ( parameterTypes . length = = <int> | | ! subjectType . isAssignableFrom ( ModelType . of ( parameterTypes [ <int> ] ) ) ) { problems . add ( ruleMethod , String . format ( <str> , subjectType ) ) ; } } } if ( problems . hasProblems ( ) ) { throw new RuleActionValidationException ( problems . format ( ) ) ; } return new RuleSourceBackedRuleAction < R , T > ( ruleSourceInstance , new JavaMethod < R , T > ( ruleSourceType . getConcreteClass ( ) , subjectType . getConcreteClass ( ) , mutateMethods . get ( <int> ) ) ) ; } public static List < Class < ? > > determineInputTypes ( Class < ? > [ ] parameterTypes ) { return Arrays . asList ( parameterTypes ) . subList ( <int> , parameterTypes . length ) ; } public List < Class < ? > > getInputTypes ( ) { return inputTypes ; } public void execute ( T subject , List < ? > inputs ) { Object [ ] args = new Object [ inputs . size ( ) + <int> ] ; args [ <int> ] = subject ; for ( int i = <int> ; i < inputs . size ( ) ; i + + ) { Object input = inputs . get ( i ) ; args [ i + <int> ] = input ; } ruleMethod . invoke ( instance , args ) ; } } 
