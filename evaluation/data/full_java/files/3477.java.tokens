package org . nd4j . linalg . shape . concat . padding ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . convolution . Convolution ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import static org . junit . Assert . * ; public class PaddingTestsC extends BaseNd4jTest { public PaddingTestsC ( ) { } public PaddingTestsC ( String name ) { super ( name ) ; } public PaddingTestsC ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Override public char ordering ( ) { return <str> ; } @Test public void testPrepend ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> } } ) ; INDArray prepend = Nd4j . prepend ( linspace , <int> , <float> , - <int> ) ; assertEquals ( assertion , prepend ) ; } @Test public void testPaddingOneThrougFour ( ) { int ph = <int> ; int pw = <int> ; int sy = <int> ; int sx = <int> ; INDArray ret = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; INDArray padded = Nd4j . pad ( ret , new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { ph , ph + sy - <int> } , { pw , pw + sx - <int> } } , Nd4j . PadMode . CONSTANT ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; assertArrayEquals ( assertion . shape ( ) , padded . shape ( ) ) ; assertEquals ( assertion , padded ) ; } @Test public void testAppend2 ( ) { INDArray ret = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; INDArray appendAssertion = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; INDArray appended = Nd4j . append ( ret , <int> , <int> , <int> ) ; assertArrayEquals ( appendAssertion . shape ( ) , appended . shape ( ) ) ; assertEquals ( appendAssertion , appended ) ; } @Test public void testPaddingTensor ( ) { int kh = <int> , kw = <int> , sy = <int> , sx = <int> , ph = <int> , pw = <int> ; INDArray linspaced = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; int n = linspaced . size ( <int> ) ; int c = linspaced . size ( <int> ) ; int h = linspaced . size ( <int> ) ; int w = linspaced . size ( <int> ) ; int outWidth = Convolution . outSize ( h , kh , sy , ph , true ) ; int outHeight = Convolution . outSize ( w , kw , sx , pw , true ) ; INDArray padded = Nd4j . pad ( linspaced , new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { ph , ph + sy - <int> } , { pw , pw + sx - <int> } } , Nd4j . PadMode . CONSTANT ) ; System . out . println ( padded ) ; } @Test public void testAppend ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray otherAppend = Nd4j . append ( linspace , <int> , <float> , - <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> } } ) ; assertEquals ( assertion , otherAppend ) ; } } 
