package io . netty . handler . codec . spdy ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_DATA_FLAG_FIN ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_DATA_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_FLAG_FIN ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_FLAG_UNIDIRECTIONAL ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_GOAWAY_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_HEADERS_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_HEADER_FLAGS_OFFSET ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_HEADER_LENGTH_OFFSET ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_HEADER_SIZE ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_HEADER_TYPE_OFFSET ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_PING_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_RST_STREAM_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SETTINGS_CLEAR ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SETTINGS_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SETTINGS_PERSISTED ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SETTINGS_PERSIST_VALUE ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SYN_REPLY_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_SYN_STREAM_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . SPDY_WINDOW_UPDATE_FRAME ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . getSignedInt ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . getUnsignedInt ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . getUnsignedMedium ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . getUnsignedShort ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; public class SpdyFrameDecoder { private final int spdyVersion ; private final int maxChunkSize ; private final SpdyFrameDecoderDelegate delegate ; private State state ; private byte flags ; private int length ; private int streamId ; private int numSettings ; private enum State { READ_COMMON_HEADER , READ_DATA_FRAME , READ_SYN_STREAM_FRAME , READ_SYN_REPLY_FRAME , READ_RST_STREAM_FRAME , READ_SETTINGS_FRAME , READ_SETTING , READ_PING_FRAME , READ_GOAWAY_FRAME , READ_HEADERS_FRAME , READ_WINDOW_UPDATE_FRAME , READ_HEADER_BLOCK , DISCARD_FRAME , FRAME_ERROR } public SpdyFrameDecoder ( SpdyVersion spdyVersion , SpdyFrameDecoderDelegate delegate ) { this ( spdyVersion , delegate , <int> ) ; } public SpdyFrameDecoder ( SpdyVersion spdyVersion , SpdyFrameDecoderDelegate delegate , int maxChunkSize ) { if ( spdyVersion = = null ) { throw new NullPointerException ( <str> ) ; } if ( delegate = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxChunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxChunkSize ) ; } this . spdyVersion = spdyVersion . getVersion ( ) ; this . delegate = delegate ; this . maxChunkSize = maxChunkSize ; state = State . READ_COMMON_HEADER ; } public void decode ( ByteBuf buffer ) { boolean last ; int statusCode ; while ( true ) { switch ( state ) { case READ_COMMON_HEADER : if ( buffer . readableBytes ( ) < SPDY_HEADER_SIZE ) { return ; } int frameOffset = buffer . readerIndex ( ) ; int flagsOffset = frameOffset + SPDY_HEADER_FLAGS_OFFSET ; int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET ; buffer . skipBytes ( SPDY_HEADER_SIZE ) ; boolean control = ( buffer . getByte ( frameOffset ) & <hex> ) ! = <int> ; int version ; int type ; if ( control ) { version = getUnsignedShort ( buffer , frameOffset ) & <hex> ; type = getUnsignedShort ( buffer , frameOffset + SPDY_HEADER_TYPE_OFFSET ) ; streamId = <int> ; } else { version = spdyVersion ; type = SPDY_DATA_FRAME ; streamId = getUnsignedInt ( buffer , frameOffset ) ; } flags = buffer . getByte ( flagsOffset ) ; length = getUnsignedMedium ( buffer , lengthOffset ) ; if ( version ! = spdyVersion ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else if ( ! isValidFrameHeader ( streamId , type , flags , length ) ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = getNextState ( type , length ) ; } break ; case READ_DATA_FRAME : if ( length = = <int> ) { state = State . READ_COMMON_HEADER ; delegate . readDataFrame ( streamId , hasFlag ( flags , SPDY_DATA_FLAG_FIN ) , Unpooled . buffer ( <int> ) ) ; break ; } int dataLength = Math . min ( maxChunkSize , length ) ; if ( buffer . readableBytes ( ) < dataLength ) { return ; } ByteBuf data = buffer . alloc ( ) . buffer ( dataLength ) ; data . writeBytes ( buffer , dataLength ) ; length - = dataLength ; if ( length = = <int> ) { state = State . READ_COMMON_HEADER ; } last = length = = <int> & & hasFlag ( flags , SPDY_DATA_FLAG_FIN ) ; delegate . readDataFrame ( streamId , last , data ) ; break ; case READ_SYN_STREAM_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } int offset = buffer . readerIndex ( ) ; streamId = getUnsignedInt ( buffer , offset ) ; int associatedToStreamId = getUnsignedInt ( buffer , offset + <int> ) ; byte priority = ( byte ) ( buffer . getByte ( offset + <int> ) > > <int> & <hex> ) ; last = hasFlag ( flags , SPDY_FLAG_FIN ) ; boolean unidirectional = hasFlag ( flags , SPDY_FLAG_UNIDIRECTIONAL ) ; buffer . skipBytes ( <int> ) ; length - = <int> ; if ( streamId = = <int> ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_HEADER_BLOCK ; delegate . readSynStreamFrame ( streamId , associatedToStreamId , priority , last , unidirectional ) ; } break ; case READ_SYN_REPLY_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } streamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; last = hasFlag ( flags , SPDY_FLAG_FIN ) ; buffer . skipBytes ( <int> ) ; length - = <int> ; if ( streamId = = <int> ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_HEADER_BLOCK ; delegate . readSynReplyFrame ( streamId , last ) ; } break ; case READ_RST_STREAM_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } streamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; statusCode = getSignedInt ( buffer , buffer . readerIndex ( ) + <int> ) ; buffer . skipBytes ( <int> ) ; if ( streamId = = <int> | | statusCode = = <int> ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_COMMON_HEADER ; delegate . readRstStreamFrame ( streamId , statusCode ) ; } break ; case READ_SETTINGS_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } boolean clear = hasFlag ( flags , SPDY_SETTINGS_CLEAR ) ; numSettings = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; buffer . skipBytes ( <int> ) ; length - = <int> ; if ( ( length & <hex> ) ! = <int> | | length > > <int> ! = numSettings ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_SETTING ; delegate . readSettingsFrame ( clear ) ; } break ; case READ_SETTING : if ( numSettings = = <int> ) { state = State . READ_COMMON_HEADER ; delegate . readSettingsEnd ( ) ; break ; } if ( buffer . readableBytes ( ) < <int> ) { return ; } byte settingsFlags = buffer . getByte ( buffer . readerIndex ( ) ) ; int id = getUnsignedMedium ( buffer , buffer . readerIndex ( ) + <int> ) ; int value = getSignedInt ( buffer , buffer . readerIndex ( ) + <int> ) ; boolean persistValue = hasFlag ( settingsFlags , SPDY_SETTINGS_PERSIST_VALUE ) ; boolean persisted = hasFlag ( settingsFlags , SPDY_SETTINGS_PERSISTED ) ; buffer . skipBytes ( <int> ) ; - - numSettings ; delegate . readSetting ( id , value , persistValue , persisted ) ; break ; case READ_PING_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } int pingId = getSignedInt ( buffer , buffer . readerIndex ( ) ) ; buffer . skipBytes ( <int> ) ; state = State . READ_COMMON_HEADER ; delegate . readPingFrame ( pingId ) ; break ; case READ_GOAWAY_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } int lastGoodStreamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; statusCode = getSignedInt ( buffer , buffer . readerIndex ( ) + <int> ) ; buffer . skipBytes ( <int> ) ; state = State . READ_COMMON_HEADER ; delegate . readGoAwayFrame ( lastGoodStreamId , statusCode ) ; break ; case READ_HEADERS_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } streamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; last = hasFlag ( flags , SPDY_FLAG_FIN ) ; buffer . skipBytes ( <int> ) ; length - = <int> ; if ( streamId = = <int> ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_HEADER_BLOCK ; delegate . readHeadersFrame ( streamId , last ) ; } break ; case READ_WINDOW_UPDATE_FRAME : if ( buffer . readableBytes ( ) < <int> ) { return ; } streamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; int deltaWindowSize = getUnsignedInt ( buffer , buffer . readerIndex ( ) + <int> ) ; buffer . skipBytes ( <int> ) ; if ( deltaWindowSize = = <int> ) { state = State . FRAME_ERROR ; delegate . readFrameError ( <str> ) ; } else { state = State . READ_COMMON_HEADER ; delegate . readWindowUpdateFrame ( streamId , deltaWindowSize ) ; } break ; case READ_HEADER_BLOCK : if ( length = = <int> ) { state = State . READ_COMMON_HEADER ; delegate . readHeaderBlockEnd ( ) ; break ; } if ( ! buffer . isReadable ( ) ) { return ; } int compressedBytes = Math . min ( buffer . readableBytes ( ) , length ) ; ByteBuf headerBlock = buffer . alloc ( ) . buffer ( compressedBytes ) ; headerBlock . writeBytes ( buffer , compressedBytes ) ; length - = compressedBytes ; delegate . readHeaderBlock ( headerBlock ) ; break ; case DISCARD_FRAME : int numBytes = Math . min ( buffer . readableBytes ( ) , length ) ; buffer . skipBytes ( numBytes ) ; length - = numBytes ; if ( length = = <int> ) { state = State . READ_COMMON_HEADER ; break ; } return ; case FRAME_ERROR : buffer . skipBytes ( buffer . readableBytes ( ) ) ; return ; default: throw new Error ( <str> ) ; } } } private static boolean hasFlag ( byte flags , byte flag ) { return ( flags & flag ) ! = <int> ; } private static State getNextState ( int type , int length ) { switch ( type ) { case SPDY_DATA_FRAME : return State . READ_DATA_FRAME ; case SPDY_SYN_STREAM_FRAME : return State . READ_SYN_STREAM_FRAME ; case SPDY_SYN_REPLY_FRAME : return State . READ_SYN_REPLY_FRAME ; case SPDY_RST_STREAM_FRAME : return State . READ_RST_STREAM_FRAME ; case SPDY_SETTINGS_FRAME : return State . READ_SETTINGS_FRAME ; case SPDY_PING_FRAME : return State . READ_PING_FRAME ; case SPDY_GOAWAY_FRAME : return State . READ_GOAWAY_FRAME ; case SPDY_HEADERS_FRAME : return State . READ_HEADERS_FRAME ; case SPDY_WINDOW_UPDATE_FRAME : return State . READ_WINDOW_UPDATE_FRAME ; default: if ( length ! = <int> ) { return State . DISCARD_FRAME ; } else { return State . READ_COMMON_HEADER ; } } } private static boolean isValidFrameHeader ( int streamId , int type , byte flags , int length ) { switch ( type ) { case SPDY_DATA_FRAME : return streamId ! = <int> ; case SPDY_SYN_STREAM_FRAME : return length > = <int> ; case SPDY_SYN_REPLY_FRAME : return length > = <int> ; case SPDY_RST_STREAM_FRAME : return flags = = <int> & & length = = <int> ; case SPDY_SETTINGS_FRAME : return length > = <int> ; case SPDY_PING_FRAME : return length = = <int> ; case SPDY_GOAWAY_FRAME : return length = = <int> ; case SPDY_HEADERS_FRAME : return length > = <int> ; case SPDY_WINDOW_UPDATE_FRAME : return length = = <int> ; default: return true ; } } } 
