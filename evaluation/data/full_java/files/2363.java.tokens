package org . nd4j . linalg . util ; import java . math . BigInteger ; import java . util . Vector ; class Bernoulli { static Vector < Rational > a = new Vector < Rational > ( ) ; public Bernoulli ( ) { if ( a . size ( ) = = <int> ) { a . add ( Rational . ONE ) ; a . add ( new Rational ( <int> , <int> ) ) ; } } protected void set ( final int n , final Rational value ) { final int nindx = n / <int> ; if ( nindx < a . size ( ) ) { a . set ( nindx , value ) ; } else { while ( a . size ( ) < nindx ) { a . add ( Rational . ZERO ) ; } a . add ( value ) ; } } public Rational at ( int n ) { if ( n = = <int> ) { return ( new Rational ( - <int> , <int> ) ) ; } else if ( n % <int> ! = <int> ) { return Rational . ZERO ; } else { final int nindx = n / <int> ; if ( a . size ( ) < = nindx ) { for ( int i = <int> * a . size ( ) ; i < = n ; i + = <int> ) { set ( i , doubleSum ( i ) ) ; } } return a . elementAt ( nindx ) ; } } private Rational doubleSum ( int n ) { Rational resul = Rational . ZERO ; for ( int k = <int> ; k < = n ; k + + ) { Rational jsum = Rational . ZERO ; BigInteger bin = BigInteger . ONE ; for ( int j = <int> ; j < = k ; j + + ) { BigInteger jpown = ( new BigInteger ( <str> + j ) ) . pow ( n ) ; if ( j % <int> = = <int> ) { jsum = jsum . add ( bin . multiply ( jpown ) ) ; } else { jsum = jsum . subtract ( bin . multiply ( jpown ) ) ; } bin = bin . multiply ( new BigInteger ( <str> + ( k - j ) ) ) . divide ( new BigInteger ( <str> + ( j + <int> ) ) ) ; } resul = resul . add ( jsum . divide ( new BigInteger ( <str> + ( k + <int> ) ) ) ) ; } return resul ; } } 
