package com . badlogic . gdx . graphics . g3d . particles ; import com . badlogic . gdx . assets . AssetDescriptor ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonValue ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . ObjectMap . Entry ; import com . badlogic . gdx . utils . reflect . ClassReflection ; import com . badlogic . gdx . utils . reflect . ReflectionException ; public class ResourceData < T > implements Json . Serializable { public static interface Configurable < T > { public void save ( AssetManager manager , ResourceData < T > resources ) ; public void load ( AssetManager manager , ResourceData < T > resources ) ; } public static class SaveData implements Json . Serializable { ObjectMap < String , Object > data ; IntArray assets ; private int loadIndex ; protected ResourceData resources ; public SaveData ( ) { data = new ObjectMap < String , Object > ( ) ; assets = new IntArray ( ) ; loadIndex = <int> ; } public SaveData ( ResourceData resources ) { data = new ObjectMap < String , Object > ( ) ; assets = new IntArray ( ) ; loadIndex = <int> ; this . resources = resources ; } public < K > void saveAsset ( String filename , Class < K > type ) { int i = resources . getAssetData ( filename , type ) ; if ( i = = - <int> ) { resources . sharedAssets . add ( new AssetData ( filename , type ) ) ; i = resources . sharedAssets . size - <int> ; } assets . add ( i ) ; } public void save ( String key , Object value ) { data . put ( key , value ) ; } public AssetDescriptor loadAsset ( ) { if ( loadIndex = = assets . size ) return null ; AssetData data = ( AssetData ) resources . sharedAssets . get ( assets . get ( loadIndex + + ) ) ; return new AssetDescriptor ( data . filename , data . type ) ; } public < K > K load ( String key ) { return ( K ) data . get ( key ) ; } @Override public void write ( Json json ) { json . writeValue ( <str> , data , ObjectMap . class ) ; json . writeValue ( <str> , assets . toArray ( ) , int [ ] . class ) ; } @Override public void read ( Json json , JsonValue jsonData ) { data = json . readValue ( <str> , ObjectMap . class , jsonData ) ; assets . addAll ( json . readValue ( <str> , int [ ] . class , jsonData ) ) ; } } public static class AssetData < T > implements Json . Serializable { public String filename ; public Class < T > type ; public AssetData ( ) { } public AssetData ( String filename , Class < T > type ) { this . filename = filename ; this . type = type ; } @Override public void write ( Json json ) { json . writeValue ( <str> , filename ) ; json . writeValue ( <str> , type . getName ( ) ) ; } @Override public void read ( Json json , JsonValue jsonData ) { filename = json . readValue ( <str> , String . class , jsonData ) ; String className = json . readValue ( <str> , String . class , jsonData ) ; try { type = ( Class < T > ) ClassReflection . forName ( className ) ; } catch ( ReflectionException e ) { throw new GdxRuntimeException ( <str> + className , e ) ; } } } private ObjectMap < String , SaveData > uniqueData ; private Array < SaveData > data ; Array < AssetData > sharedAssets ; private int currentLoadIndex ; public T resource ; public ResourceData ( ) { uniqueData = new ObjectMap < String , SaveData > ( ) ; data = new Array < SaveData > ( true , <int> , SaveData . class ) ; sharedAssets = new Array < AssetData > ( ) ; currentLoadIndex = <int> ; } public ResourceData ( T resource ) { this ( ) ; this . resource = resource ; } < K > int getAssetData ( String filename , Class < K > type ) { int i = <int> ; for ( AssetData data : sharedAssets ) { if ( data . filename . equals ( filename ) & & data . type . equals ( type ) ) { return i ; } + + i ; } return - <int> ; } public Array < AssetDescriptor > getAssetDescriptors ( ) { Array < AssetDescriptor > descriptors = new Array < AssetDescriptor > ( ) ; for ( AssetData data : sharedAssets ) { descriptors . add ( new AssetDescriptor < T > ( data . filename , data . type ) ) ; } return descriptors ; } public Array < AssetData > getAssets ( ) { return sharedAssets ; } public SaveData createSaveData ( ) { SaveData saveData = new SaveData ( this ) ; data . add ( saveData ) ; return saveData ; } public SaveData createSaveData ( String key ) { SaveData saveData = new SaveData ( this ) ; if ( uniqueData . containsKey ( key ) ) throw new RuntimeException ( <str> ) ; uniqueData . put ( key , saveData ) ; return saveData ; } public SaveData getSaveData ( ) { return data . get ( currentLoadIndex + + ) ; } public SaveData getSaveData ( String key ) { return uniqueData . get ( key ) ; } @Override public void write ( Json json ) { json . writeValue ( <str> , uniqueData , ObjectMap . class ) ; json . writeValue ( <str> , data , Array . class , SaveData . class ) ; json . writeValue ( <str> , sharedAssets . toArray ( AssetData . class ) , AssetData [ ] . class ) ; json . writeValue ( <str> , resource , null ) ; } @Override public void read ( Json json , JsonValue jsonData ) { uniqueData = json . readValue ( <str> , ObjectMap . class , jsonData ) ; for ( Entry < String , SaveData > entry : uniqueData . entries ( ) ) { entry . value . resources = this ; } data = json . readValue ( <str> , Array . class , SaveData . class , jsonData ) ; for ( SaveData saveData : data ) { saveData . resources = this ; } sharedAssets . addAll ( json . readValue ( <str> , Array . class , AssetData . class , jsonData ) ) ; resource = json . readValue ( <str> , null , jsonData ) ; } } 
