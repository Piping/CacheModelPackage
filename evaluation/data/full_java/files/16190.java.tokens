package org . gradle . foundation . ipc . basic ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . foundation . common . ObserverLord ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . ExecHandle ; import org . gradle . process . internal . ExecHandleBuilder ; import java . io . ByteArrayOutputStream ; public class ProcessLauncherServer extends Server < ProcessLauncherServer . Protocol , ProcessLauncherServer . ServerObserver > { private volatile ExecHandle externalProcess ; private static final Logger LOGGER = Logging . getLogger ( ProcessLauncherServer . class ) ; public interface Protocol extends Server . Protocol < ProcessLauncherServer > { public void aboutToKillProcess ( ) ; public ExecutionInfo getExecutionInfo ( int serverPort ) ; public void clientExited ( int result , String output ) ; } public interface ServerObserver extends Server . ServerObserver { public void clientExited ( int result , String output ) ; } public ProcessLauncherServer ( Protocol protocol ) { super ( protocol ) ; } @Override protected void communicationsStarted ( ) { launchExternalProcess ( ) ; } private void launchExternalProcess ( ) { Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { ExecutionInfo executionInfo = null ; ExecHandle execHandle = null ; ByteArrayOutputStream output = null ; try { executionInfo = protocol . getExecutionInfo ( getPort ( ) ) ; ExecHandleBuilder builder = new ExecHandleBuilder ( ) ; builder . workingDir ( executionInfo . getWorkingDirectory ( ) ) ; builder . commandLine ( ( Object [ ] ) executionInfo . getCommandLineArguments ( ) ) ; builder . environment ( executionInfo . getEnvironmentVariables ( ) ) ; output = new ByteArrayOutputStream ( ) ; builder . setStandardOutput ( output ) ; builder . setErrorOutput ( output ) ; execHandle = builder . build ( ) ; setExternalProcess ( execHandle ) ; execHandle . start ( ) ; } catch ( Throwable e ) { LOGGER . error ( <str> , e ) ; notifyClientExited ( - <int> , e . getMessage ( ) ) ; setExternalProcess ( null ) ; return ; } ExecResult result = execHandle . waitForFinish ( ) ; LOGGER . debug ( <str> , result . getExitValue ( ) ) ; setExternalProcess ( null ) ; executionInfo . processExecutionComplete ( ) ; notifyClientExited ( result . getExitValue ( ) , output . toString ( ) ) ; } } ) ; thread . start ( ) ; } public void stop ( ) { super . stop ( ) ; killProcess ( ) ; } public void setExternalProcess ( ExecHandle externalProcess ) { this . externalProcess = externalProcess ; } public synchronized void killProcess ( ) { if ( externalProcess ! = null ) { requestShutdown ( ) ; protocol . aboutToKillProcess ( ) ; externalProcess . abort ( ) ; setExternalProcess ( null ) ; notifyClientExited ( - <int> , <str> ) ; } } private void notifyClientExited ( final int result , final String output ) { protocol . clientExited ( result , output ) ; observerLord . notifyObservers ( new ObserverLord . ObserverNotification < ServerObserver > ( ) { public void notify ( ServerObserver observer ) { observer . clientExited ( result , output ) ; } } ) ; } } 
