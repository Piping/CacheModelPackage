package org . apache . cassandra . io . compress ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . Random ; import org . junit . Test ; import org . apache . cassandra . db . ClusteringComparator ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . io . util . ChannelProxy ; import org . apache . cassandra . io . util . FileMark ; import org . apache . cassandra . io . util . MmappedRegions ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . io . util . SequentialWriter ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . utils . ChecksumType ; import org . apache . cassandra . utils . SyncUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; public class CompressedRandomAccessReaderTest { @Test public void testResetAndTruncate ( ) throws IOException { testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , false , false , <int> ) ; testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , false , false , CompressionParams . DEFAULT_CHUNK_LENGTH ) ; } @Test public void testResetAndTruncateCompressed ( ) throws IOException { testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , true , false , <int> ) ; testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , true , false , CompressionParams . DEFAULT_CHUNK_LENGTH ) ; } @Test public void testResetAndTruncateCompressedMmap ( ) throws IOException { testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , true , true , <int> ) ; testResetAndTruncate ( File . createTempFile ( <str> , <str> ) , true , true , CompressionParams . DEFAULT_CHUNK_LENGTH ) ; } @Test public void test6791 ( ) throws IOException , ConfigurationException { File f = File . createTempFile ( <str> , <str> ) ; String filename = f . getAbsolutePath ( ) ; try ( ChannelProxy channel = new ChannelProxy ( f ) ) { MetadataCollector sstableMetadataCollector = new MetadataCollector ( new ClusteringComparator ( BytesType . instance ) ) ; try ( CompressedSequentialWriter writer = new CompressedSequentialWriter ( f , filename + <str> , CompressionParams . snappy ( <int> ) , sstableMetadataCollector ) ) { for ( int i = <int> ; i < <int> ; i + + ) writer . write ( <str> . getBytes ( ) ) ; FileMark mark = writer . mark ( ) ; for ( int i = <int> ; i < <int> ; + + i ) writer . write ( <str> . getBytes ( ) ) ; writer . resetAndTruncate ( mark ) ; for ( int i = <int> ; i < <int> ; i + + ) writer . write ( <str> . getBytes ( ) ) ; writer . finish ( ) ; } try ( RandomAccessReader reader = new CompressedRandomAccessReader . Builder ( channel , new CompressionMetadata ( filename + <str> , f . length ( ) , ChecksumType . CRC32 ) ) . build ( ) ) { String res = reader . readLine ( ) ; assertEquals ( res , <str> ) ; assertEquals ( <int> , res . length ( ) ) ; } } finally { if ( f . exists ( ) ) assertTrue ( f . delete ( ) ) ; File metadata = new File ( filename + <str> ) ; if ( metadata . exists ( ) ) metadata . delete ( ) ; } } private static void testResetAndTruncate ( File f , boolean compressed , boolean usemmap , int junkSize ) throws IOException { final String filename = f . getAbsolutePath ( ) ; try ( ChannelProxy channel = new ChannelProxy ( f ) ) { MetadataCollector sstableMetadataCollector = new MetadataCollector ( new ClusteringComparator ( BytesType . instance ) ) . replayPosition ( null ) ; try ( SequentialWriter writer = compressed ? new CompressedSequentialWriter ( f , filename + <str> , CompressionParams . snappy ( ) , sstableMetadataCollector ) : SequentialWriter . open ( f ) ) { writer . write ( <str> . getBytes ( ) ) ; FileMark mark = writer . mark ( ) ; writer . write ( <str> . getBytes ( ) ) ; for ( int i = <int> ; i < junkSize ; + + i ) { writer . write ( ( byte ) <int> ) ; } writer . resetAndTruncate ( mark ) ; writer . write ( <str> . getBytes ( ) ) ; writer . finish ( ) ; } assert f . exists ( ) ; CompressionMetadata compressionMetadata = compressed ? new CompressionMetadata ( filename + <str> , f . length ( ) , ChecksumType . CRC32 ) : null ; RandomAccessReader . Builder builder = compressed ? new CompressedRandomAccessReader . Builder ( channel , compressionMetadata ) : new RandomAccessReader . Builder ( channel ) ; if ( usemmap ) { if ( compressed ) builder . regions ( MmappedRegions . map ( channel , compressionMetadata ) ) ; else builder . regions ( MmappedRegions . map ( channel , f . length ( ) ) ) ; } try ( RandomAccessReader reader = builder . build ( ) ) { String expected = <str> ; assertEquals ( expected . length ( ) , reader . length ( ) ) ; byte [ ] b = new byte [ expected . length ( ) ] ; reader . readFully ( b ) ; assert new String ( b ) . equals ( expected ) : <str> + expected + <str> + new String ( b ) + <str> ; } if ( usemmap ) builder . regions . close ( ) ; } finally { if ( f . exists ( ) ) assertTrue ( f . delete ( ) ) ; File metadata = new File ( filename + <str> ) ; if ( compressed & & metadata . exists ( ) ) metadata . delete ( ) ; } } @Test public void testDataCorruptionDetection ( ) throws IOException { String CONTENT = <str> ; File file = new File ( <str> ) ; file . deleteOnExit ( ) ; File metadata = new File ( file . getPath ( ) + <str> ) ; metadata . deleteOnExit ( ) ; assertTrue ( file . createNewFile ( ) ) ; assertTrue ( metadata . createNewFile ( ) ) ; MetadataCollector sstableMetadataCollector = new MetadataCollector ( new ClusteringComparator ( BytesType . instance ) ) . replayPosition ( null ) ; try ( SequentialWriter writer = new CompressedSequentialWriter ( file , metadata . getPath ( ) , CompressionParams . snappy ( ) , sstableMetadataCollector ) ) { writer . write ( CONTENT . getBytes ( ) ) ; writer . finish ( ) ; } try ( ChannelProxy channel = new ChannelProxy ( file ) ) { CompressionMetadata meta = new CompressionMetadata ( metadata . getPath ( ) , file . length ( ) , ChecksumType . CRC32 ) ; CompressionMetadata . Chunk chunk = meta . chunkFor ( <int> ) ; try ( RandomAccessReader reader = new CompressedRandomAccessReader . Builder ( channel , meta ) . build ( ) ) { assertEquals ( CONTENT , reader . readLine ( ) ) ; Random random = new Random ( ) ; RandomAccessFile checksumModifier = null ; try { checksumModifier = new RandomAccessFile ( file , <str> ) ; byte [ ] checksum = new byte [ <int> ] ; checksumModifier . seek ( chunk . length ) ; checksumModifier . read ( checksum ) ; checksumModifier . seek ( chunk . length ) ; for ( int i = <int> ; i < checksum . length ; i + + ) { checksumModifier . write ( random . nextInt ( ) ) ; SyncUtil . sync ( checksumModifier ) ; try ( final RandomAccessReader r = new CompressedRandomAccessReader . Builder ( channel , meta ) . build ( ) ) { Throwable exception = null ; try { r . readLine ( ) ; } catch ( Throwable t ) { exception = t ; } assertNotNull ( exception ) ; assertSame ( exception . getClass ( ) , CorruptSSTableException . class ) ; assertSame ( exception . getCause ( ) . getClass ( ) , CorruptBlockException . class ) ; } } updateChecksum ( checksumModifier , chunk . length , checksum ) ; try ( RandomAccessReader cr = new CompressedRandomAccessReader . Builder ( channel , meta ) . build ( ) ) { assertEquals ( CONTENT , cr . readLine ( ) ) ; } } finally { if ( checksumModifier ! = null ) checksumModifier . close ( ) ; } } } } private static void updateChecksum ( RandomAccessFile file , long checksumOffset , byte [ ] checksum ) throws IOException { file . seek ( checksumOffset ) ; file . write ( checksum ) ; SyncUtil . sync ( file ) ; } } 
