package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . EmptyHttpHeaders ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpConstants ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . stream . ChunkedInput ; import io . netty . util . internal . ThreadLocalRandom ; import java . io . File ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . regex . Pattern ; import static io . netty . buffer . Unpooled . * ; public class HttpPostRequestEncoder implements ChunkedInput < HttpContent > { public enum EncoderMode { RFC1738 , RFC3986 , HTML5 } private static final Map < Pattern , String > percentEncodings = new HashMap < Pattern , String > ( ) ; static { percentEncodings . put ( Pattern . compile ( <str> ) , <str> ) ; percentEncodings . put ( Pattern . compile ( <str> ) , <str> ) ; percentEncodings . put ( Pattern . compile ( <str> ) , <str> ) ; } private final HttpDataFactory factory ; private final HttpRequest request ; private final Charset charset ; private boolean isChunked ; private final List < InterfaceHttpData > bodyListDatas ; final List < InterfaceHttpData > multipartHttpDatas ; private final boolean isMultipart ; String multipartDataBoundary ; String multipartMixedBoundary ; private boolean headerFinalized ; private final EncoderMode encoderMode ; public HttpPostRequestEncoder ( HttpRequest request , boolean multipart ) throws ErrorDataEncoderException { this ( new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) , request , multipart , HttpConstants . DEFAULT_CHARSET , EncoderMode . RFC1738 ) ; } public HttpPostRequestEncoder ( HttpDataFactory factory , HttpRequest request , boolean multipart ) throws ErrorDataEncoderException { this ( factory , request , multipart , HttpConstants . DEFAULT_CHARSET , EncoderMode . RFC1738 ) ; } public HttpPostRequestEncoder ( HttpDataFactory factory , HttpRequest request , boolean multipart , Charset charset , EncoderMode encoderMode ) throws ErrorDataEncoderException { if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } if ( request = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } HttpMethod method = request . method ( ) ; if ( ! ( method . equals ( HttpMethod . POST ) | | method . equals ( HttpMethod . PUT ) | | method . equals ( HttpMethod . PATCH ) | | method . equals ( HttpMethod . OPTIONS ) ) ) { throw new ErrorDataEncoderException ( <str> ) ; } this . request = request ; this . charset = charset ; this . factory = factory ; bodyListDatas = new ArrayList < InterfaceHttpData > ( ) ; isLastChunk = false ; isLastChunkSent = false ; isMultipart = multipart ; multipartHttpDatas = new ArrayList < InterfaceHttpData > ( ) ; this . encoderMode = encoderMode ; if ( isMultipart ) { initDataMultipart ( ) ; } } public void cleanFiles ( ) { factory . cleanRequestHttpData ( request ) ; } private boolean isLastChunk ; private boolean isLastChunkSent ; private FileUpload currentFileUpload ; private boolean duringMixedMode ; private long globalBodySize ; private long globalProgress ; public boolean isMultipart ( ) { return isMultipart ; } private void initDataMultipart ( ) { multipartDataBoundary = getNewMultipartDelimiter ( ) ; } private void initMixedMultipart ( ) { multipartMixedBoundary = getNewMultipartDelimiter ( ) ; } private static String getNewMultipartDelimiter ( ) { return Long . toHexString ( ThreadLocalRandom . current ( ) . nextLong ( ) ) . toLowerCase ( ) ; } public List < InterfaceHttpData > getBodyListAttributes ( ) { return bodyListDatas ; } public void setBodyHttpDatas ( List < InterfaceHttpData > datas ) throws ErrorDataEncoderException { if ( datas = = null ) { throw new NullPointerException ( <str> ) ; } globalBodySize = <int> ; bodyListDatas . clear ( ) ; currentFileUpload = null ; duringMixedMode = false ; multipartHttpDatas . clear ( ) ; for ( InterfaceHttpData data : datas ) { addBodyHttpData ( data ) ; } } public void addBodyAttribute ( String name , String value ) throws ErrorDataEncoderException { if ( name = = null ) { throw new NullPointerException ( <str> ) ; } String svalue = value ; if ( value = = null ) { svalue = <str> ; } Attribute data = factory . createAttribute ( request , name , svalue ) ; addBodyHttpData ( data ) ; } public void addBodyFileUpload ( String name , File file , String contentType , boolean isText ) throws ErrorDataEncoderException { if ( name = = null ) { throw new NullPointerException ( <str> ) ; } if ( file = = null ) { throw new NullPointerException ( <str> ) ; } String scontentType = contentType ; String contentTransferEncoding = null ; if ( contentType = = null ) { if ( isText ) { scontentType = HttpPostBodyUtil . DEFAULT_TEXT_CONTENT_TYPE ; } else { scontentType = HttpPostBodyUtil . DEFAULT_BINARY_CONTENT_TYPE ; } } if ( ! isText ) { contentTransferEncoding = HttpPostBodyUtil . TransferEncodingMechanism . BINARY . value ( ) ; } FileUpload fileUpload = factory . createFileUpload ( request , name , file . getName ( ) , scontentType , contentTransferEncoding , null , file . length ( ) ) ; try { fileUpload . setContent ( file ) ; } catch ( IOException e ) { throw new ErrorDataEncoderException ( e ) ; } addBodyHttpData ( fileUpload ) ; } public void addBodyFileUploads ( String name , File [ ] file , String [ ] contentType , boolean [ ] isText ) throws ErrorDataEncoderException { if ( file . length ! = contentType . length & & file . length ! = isText . length ) { throw new NullPointerException ( <str> ) ; } for ( int i = <int> ; i < file . length ; i + + ) { addBodyFileUpload ( name , file [ i ] , contentType [ i ] , isText [ i ] ) ; } } public void addBodyHttpData ( InterfaceHttpData data ) throws ErrorDataEncoderException { if ( headerFinalized ) { throw new ErrorDataEncoderException ( <str> ) ; } if ( data = = null ) { throw new NullPointerException ( <str> ) ; } bodyListDatas . add ( data ) ; if ( ! isMultipart ) { if ( data instanceof Attribute ) { Attribute attribute = ( Attribute ) data ; try { String key = encodeAttribute ( attribute . getName ( ) , charset ) ; String value = encodeAttribute ( attribute . getValue ( ) , charset ) ; Attribute newattribute = factory . createAttribute ( request , key , value ) ; multipartHttpDatas . add ( newattribute ) ; globalBodySize + = newattribute . getName ( ) . length ( ) + <int> + newattribute . length ( ) + <int> ; } catch ( IOException e ) { throw new ErrorDataEncoderException ( e ) ; } } else if ( data instanceof FileUpload ) { FileUpload fileUpload = ( FileUpload ) data ; String key = encodeAttribute ( fileUpload . getName ( ) , charset ) ; String value = encodeAttribute ( fileUpload . getFilename ( ) , charset ) ; Attribute newattribute = factory . createAttribute ( request , key , value ) ; multipartHttpDatas . add ( newattribute ) ; globalBodySize + = newattribute . getName ( ) . length ( ) + <int> + newattribute . length ( ) + <int> ; } return ; } if ( data instanceof Attribute ) { if ( duringMixedMode ) { InternalAttribute internal = new InternalAttribute ( charset ) ; internal . addValue ( <str> + multipartMixedBoundary + <str> ) ; multipartHttpDatas . add ( internal ) ; multipartMixedBoundary = null ; currentFileUpload = null ; duringMixedMode = false ; } InternalAttribute internal = new InternalAttribute ( charset ) ; if ( ! multipartHttpDatas . isEmpty ( ) ) { internal . addValue ( <str> ) ; } internal . addValue ( <str> + multipartDataBoundary + <str> ) ; Attribute attribute = ( Attribute ) data ; internal . addValue ( HttpHeaderNames . CONTENT_DISPOSITION + <str> + HttpHeaderValues . FORM_DATA + <str> + HttpHeaderValues . NAME + <str> + attribute . getName ( ) + <str> ) ; internal . addValue ( HttpHeaderNames . CONTENT_LENGTH + <str> + attribute . length ( ) + <str> ) ; Charset localcharset = attribute . getCharset ( ) ; if ( localcharset ! = null ) { internal . addValue ( HttpHeaderNames . CONTENT_TYPE + <str> + HttpPostBodyUtil . DEFAULT_TEXT_CONTENT_TYPE + <str> + HttpHeaderValues . CHARSET + <str> + localcharset . name ( ) + <str> ) ; } internal . addValue ( <str> ) ; multipartHttpDatas . add ( internal ) ; multipartHttpDatas . add ( data ) ; globalBodySize + = attribute . length ( ) + internal . size ( ) ; } else if ( data instanceof FileUpload ) { FileUpload fileUpload = ( FileUpload ) data ; InternalAttribute internal = new InternalAttribute ( charset ) ; if ( ! multipartHttpDatas . isEmpty ( ) ) { internal . addValue ( <str> ) ; } boolean localMixed ; if ( duringMixedMode ) { if ( currentFileUpload ! = null & & currentFileUpload . getName ( ) . equals ( fileUpload . getName ( ) ) ) { localMixed = true ; } else { internal . addValue ( <str> + multipartMixedBoundary + <str> ) ; multipartHttpDatas . add ( internal ) ; multipartMixedBoundary = null ; internal = new InternalAttribute ( charset ) ; internal . addValue ( <str> ) ; localMixed = false ; currentFileUpload = fileUpload ; duringMixedMode = false ; } } else { if ( encoderMode ! = EncoderMode . HTML5 & & currentFileUpload ! = null & & currentFileUpload . getName ( ) . equals ( fileUpload . getName ( ) ) ) { initMixedMultipart ( ) ; InternalAttribute pastAttribute = ( InternalAttribute ) multipartHttpDatas . get ( multipartHttpDatas . size ( ) - <int> ) ; globalBodySize - = pastAttribute . size ( ) ; StringBuilder replacement = new StringBuilder ( <int> + multipartDataBoundary . length ( ) + multipartMixedBoundary . length ( ) * <int> + fileUpload . getFilename ( ) . length ( ) + fileUpload . getName ( ) . length ( ) ) . append ( <str> ) . append ( multipartDataBoundary ) . append ( <str> ) . append ( HttpHeaderNames . CONTENT_DISPOSITION ) . append ( <str> ) . append ( HttpHeaderValues . FORM_DATA ) . append ( <str> ) . append ( HttpHeaderValues . NAME ) . append ( <str> ) . append ( fileUpload . getName ( ) ) . append ( <str> ) . append ( HttpHeaderNames . CONTENT_TYPE ) . append ( <str> ) . append ( HttpHeaderValues . MULTIPART_MIXED ) . append ( <str> ) . append ( HttpHeaderValues . BOUNDARY ) . append ( <str> ) . append ( multipartMixedBoundary ) . append ( <str> ) . append ( <str> ) . append ( multipartMixedBoundary ) . append ( <str> ) . append ( HttpHeaderNames . CONTENT_DISPOSITION ) . append ( <str> ) . append ( HttpHeaderValues . ATTACHMENT ) . append ( <str> ) . append ( HttpHeaderValues . FILENAME ) . append ( <str> ) . append ( fileUpload . getFilename ( ) ) . append ( <str> ) ; pastAttribute . setValue ( replacement . toString ( ) , <int> ) ; pastAttribute . setValue ( <str> , <int> ) ; globalBodySize + = pastAttribute . size ( ) ; localMixed = true ; duringMixedMode = true ; } else { localMixed = false ; currentFileUpload = fileUpload ; duringMixedMode = false ; } } if ( localMixed ) { internal . addValue ( <str> + multipartMixedBoundary + <str> ) ; internal . addValue ( HttpHeaderNames . CONTENT_DISPOSITION + <str> + HttpHeaderValues . ATTACHMENT + <str> + HttpHeaderValues . FILENAME + <str> + fileUpload . getFilename ( ) + <str> ) ; } else { internal . addValue ( <str> + multipartDataBoundary + <str> ) ; internal . addValue ( HttpHeaderNames . CONTENT_DISPOSITION + <str> + HttpHeaderValues . FORM_DATA + <str> + HttpHeaderValues . NAME + <str> + fileUpload . getName ( ) + <str> + HttpHeaderValues . FILENAME + <str> + fileUpload . getFilename ( ) + <str> ) ; } internal . addValue ( HttpHeaderNames . CONTENT_LENGTH + <str> + fileUpload . length ( ) + <str> ) ; internal . addValue ( HttpHeaderNames . CONTENT_TYPE + <str> + fileUpload . getContentType ( ) ) ; String contentTransferEncoding = fileUpload . getContentTransferEncoding ( ) ; if ( contentTransferEncoding ! = null & & contentTransferEncoding . equals ( HttpPostBodyUtil . TransferEncodingMechanism . BINARY . value ( ) ) ) { internal . addValue ( <str> + HttpHeaderNames . CONTENT_TRANSFER_ENCODING + <str> + HttpPostBodyUtil . TransferEncodingMechanism . BINARY . value ( ) + <str> ) ; } else if ( fileUpload . getCharset ( ) ! = null ) { internal . addValue ( <str> + HttpHeaderValues . CHARSET + <str> + fileUpload . getCharset ( ) . name ( ) + <str> ) ; } else { internal . addValue ( <str> ) ; } multipartHttpDatas . add ( internal ) ; multipartHttpDatas . add ( data ) ; globalBodySize + = fileUpload . length ( ) + internal . size ( ) ; } } private ListIterator < InterfaceHttpData > iterator ; public HttpRequest finalizeRequest ( ) throws ErrorDataEncoderException { if ( ! headerFinalized ) { if ( isMultipart ) { InternalAttribute internal = new InternalAttribute ( charset ) ; if ( duringMixedMode ) { internal . addValue ( <str> + multipartMixedBoundary + <str> ) ; } internal . addValue ( <str> + multipartDataBoundary + <str> ) ; multipartHttpDatas . add ( internal ) ; multipartMixedBoundary = null ; currentFileUpload = null ; duringMixedMode = false ; globalBodySize + = internal . size ( ) ; } headerFinalized = true ; } else { throw new ErrorDataEncoderException ( <str> ) ; } HttpHeaders headers = request . headers ( ) ; List < String > contentTypes = headers . getAll ( HttpHeaderNames . CONTENT_TYPE ) ; List < String > transferEncoding = headers . getAll ( HttpHeaderNames . TRANSFER_ENCODING ) ; if ( contentTypes ! = null ) { headers . remove ( HttpHeaderNames . CONTENT_TYPE ) ; for ( String contentType : contentTypes ) { String lowercased = contentType . toLowerCase ( ) ; if ( lowercased . startsWith ( HttpHeaderValues . MULTIPART_FORM_DATA . toString ( ) ) | | lowercased . startsWith ( HttpHeaderValues . APPLICATION_X_WWW_FORM_URLENCODED . toString ( ) ) ) { } else { headers . add ( HttpHeaderNames . CONTENT_TYPE , contentType ) ; } } } if ( isMultipart ) { String value = HttpHeaderValues . MULTIPART_FORM_DATA + <str> + HttpHeaderValues . BOUNDARY + <str> + multipartDataBoundary ; headers . add ( HttpHeaderNames . CONTENT_TYPE , value ) ; } else { headers . add ( HttpHeaderNames . CONTENT_TYPE , HttpHeaderValues . APPLICATION_X_WWW_FORM_URLENCODED ) ; } long realSize = globalBodySize ; if ( isMultipart ) { iterator = multipartHttpDatas . listIterator ( ) ; } else { realSize - = <int> ; iterator = multipartHttpDatas . listIterator ( ) ; } headers . set ( HttpHeaderNames . CONTENT_LENGTH , String . valueOf ( realSize ) ) ; if ( realSize > HttpPostBodyUtil . chunkSize | | isMultipart ) { isChunked = true ; if ( transferEncoding ! = null ) { headers . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; for ( CharSequence v : transferEncoding ) { if ( HttpHeaderValues . CHUNKED . contentEqualsIgnoreCase ( v ) ) { } else { headers . add ( HttpHeaderNames . TRANSFER_ENCODING , v ) ; } } } HttpUtil . setTransferEncodingChunked ( request , true ) ; return new WrappedHttpRequest ( request ) ; } else { HttpContent chunk = nextChunk ( ) ; if ( request instanceof FullHttpRequest ) { FullHttpRequest fullRequest = ( FullHttpRequest ) request ; ByteBuf chunkContent = chunk . content ( ) ; if ( fullRequest . content ( ) ! = chunkContent ) { fullRequest . content ( ) . clear ( ) . writeBytes ( chunkContent ) ; chunkContent . release ( ) ; } return fullRequest ; } else { return new WrappedFullHttpRequest ( request , chunk ) ; } } } public boolean isChunked ( ) { return isChunked ; } private String encodeAttribute ( String s , Charset charset ) throws ErrorDataEncoderException { if ( s = = null ) { return <str> ; } try { String encoded = URLEncoder . encode ( s , charset . name ( ) ) ; if ( encoderMode = = EncoderMode . RFC3986 ) { for ( Map . Entry < Pattern , String > entry : percentEncodings . entrySet ( ) ) { String replacement = entry . getValue ( ) ; encoded = entry . getKey ( ) . matcher ( encoded ) . replaceAll ( replacement ) ; } } return encoded ; } catch ( UnsupportedEncodingException e ) { throw new ErrorDataEncoderException ( charset . name ( ) , e ) ; } } private ByteBuf currentBuffer ; private InterfaceHttpData currentData ; private boolean isKey = true ; private ByteBuf fillByteBuf ( ) { int length = currentBuffer . readableBytes ( ) ; if ( length > HttpPostBodyUtil . chunkSize ) { ByteBuf slice = currentBuffer . slice ( currentBuffer . readerIndex ( ) , HttpPostBodyUtil . chunkSize ) ; currentBuffer . retain ( ) ; currentBuffer . skipBytes ( HttpPostBodyUtil . chunkSize ) ; return slice ; } else { ByteBuf slice = currentBuffer ; currentBuffer = null ; return slice ; } } private HttpContent encodeNextChunkMultipart ( int sizeleft ) throws ErrorDataEncoderException { if ( currentData = = null ) { return null ; } ByteBuf buffer ; if ( currentData instanceof InternalAttribute ) { buffer = ( ( InternalAttribute ) currentData ) . toByteBuf ( ) ; currentData = null ; } else { if ( currentData instanceof Attribute ) { try { buffer = ( ( Attribute ) currentData ) . getChunk ( sizeleft ) ; } catch ( IOException e ) { throw new ErrorDataEncoderException ( e ) ; } } else { try { buffer = ( ( HttpData ) currentData ) . getChunk ( sizeleft ) ; } catch ( IOException e ) { throw new ErrorDataEncoderException ( e ) ; } } if ( buffer . capacity ( ) = = <int> ) { currentData = null ; return null ; } } if ( currentBuffer = = null ) { currentBuffer = buffer ; } else { currentBuffer = wrappedBuffer ( currentBuffer , buffer ) ; } if ( currentBuffer . readableBytes ( ) < HttpPostBodyUtil . chunkSize ) { currentData = null ; return null ; } buffer = fillByteBuf ( ) ; return new DefaultHttpContent ( buffer ) ; } private HttpContent encodeNextChunkUrlEncoded ( int sizeleft ) throws ErrorDataEncoderException { if ( currentData = = null ) { return null ; } int size = sizeleft ; ByteBuf buffer ; if ( isKey ) { String key = currentData . getName ( ) ; buffer = wrappedBuffer ( key . getBytes ( ) ) ; isKey = false ; if ( currentBuffer = = null ) { currentBuffer = wrappedBuffer ( buffer , wrappedBuffer ( <str> . getBytes ( ) ) ) ; size - = buffer . readableBytes ( ) + <int> ; } else { currentBuffer = wrappedBuffer ( currentBuffer , buffer , wrappedBuffer ( <str> . getBytes ( ) ) ) ; size - = buffer . readableBytes ( ) + <int> ; } if ( currentBuffer . readableBytes ( ) > = HttpPostBodyUtil . chunkSize ) { buffer = fillByteBuf ( ) ; return new DefaultHttpContent ( buffer ) ; } } try { buffer = ( ( HttpData ) currentData ) . getChunk ( size ) ; } catch ( IOException e ) { throw new ErrorDataEncoderException ( e ) ; } ByteBuf delimiter = null ; if ( buffer . readableBytes ( ) < size ) { isKey = true ; delimiter = iterator . hasNext ( ) ? wrappedBuffer ( <str> . getBytes ( ) ) : null ; } if ( buffer . capacity ( ) = = <int> ) { currentData = null ; if ( currentBuffer = = null ) { currentBuffer = delimiter ; } else { if ( delimiter ! = null ) { currentBuffer = wrappedBuffer ( currentBuffer , delimiter ) ; } } if ( currentBuffer . readableBytes ( ) > = HttpPostBodyUtil . chunkSize ) { buffer = fillByteBuf ( ) ; return new DefaultHttpContent ( buffer ) ; } return null ; } if ( currentBuffer = = null ) { if ( delimiter ! = null ) { currentBuffer = wrappedBuffer ( buffer , delimiter ) ; } else { currentBuffer = buffer ; } } else { if ( delimiter ! = null ) { currentBuffer = wrappedBuffer ( currentBuffer , buffer , delimiter ) ; } else { currentBuffer = wrappedBuffer ( currentBuffer , buffer ) ; } } if ( currentBuffer . readableBytes ( ) < HttpPostBodyUtil . chunkSize ) { currentData = null ; isKey = true ; return null ; } buffer = fillByteBuf ( ) ; return new DefaultHttpContent ( buffer ) ; } @Override public void close ( ) throws Exception { } @Override public HttpContent readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( isLastChunkSent ) { return null ; } else { HttpContent nextChunk = nextChunk ( ) ; globalProgress + = nextChunk . content ( ) . readableBytes ( ) ; return nextChunk ; } } private HttpContent nextChunk ( ) throws ErrorDataEncoderException { if ( isLastChunk ) { isLastChunkSent = true ; return LastHttpContent . EMPTY_LAST_CONTENT ; } ByteBuf buffer ; int size = HttpPostBodyUtil . chunkSize ; if ( currentBuffer ! = null ) { size - = currentBuffer . readableBytes ( ) ; } if ( size < = <int> ) { buffer = fillByteBuf ( ) ; return new DefaultHttpContent ( buffer ) ; } if ( currentData ! = null ) { if ( isMultipart ) { HttpContent chunk = encodeNextChunkMultipart ( size ) ; if ( chunk ! = null ) { return chunk ; } } else { HttpContent chunk = encodeNextChunkUrlEncoded ( size ) ; if ( chunk ! = null ) { return chunk ; } } size = HttpPostBodyUtil . chunkSize - currentBuffer . readableBytes ( ) ; } if ( ! iterator . hasNext ( ) ) { isLastChunk = true ; buffer = currentBuffer ; currentBuffer = null ; return new DefaultHttpContent ( buffer ) ; } while ( size > <int> & & iterator . hasNext ( ) ) { currentData = iterator . next ( ) ; HttpContent chunk ; if ( isMultipart ) { chunk = encodeNextChunkMultipart ( size ) ; } else { chunk = encodeNextChunkUrlEncoded ( size ) ; } if ( chunk = = null ) { size = HttpPostBodyUtil . chunkSize - currentBuffer . readableBytes ( ) ; continue ; } return chunk ; } isLastChunk = true ; if ( currentBuffer = = null ) { isLastChunkSent = true ; return LastHttpContent . EMPTY_LAST_CONTENT ; } buffer = currentBuffer ; currentBuffer = null ; return new DefaultHttpContent ( buffer ) ; } @Override public boolean isEndOfInput ( ) throws Exception { return isLastChunkSent ; } @Override public long length ( ) { return isMultipart ? globalBodySize : globalBodySize - <int> ; } @Override public long progress ( ) { return globalProgress ; } public static class ErrorDataEncoderException extends Exception { private static final long serialVersionUID = <int> ; public ErrorDataEncoderException ( ) { } public ErrorDataEncoderException ( String msg ) { super ( msg ) ; } public ErrorDataEncoderException ( Throwable cause ) { super ( cause ) ; } public ErrorDataEncoderException ( String msg , Throwable cause ) { super ( msg , cause ) ; } } private static class WrappedHttpRequest implements HttpRequest { private final HttpRequest request ; WrappedHttpRequest ( HttpRequest request ) { this . request = request ; } @Override public HttpRequest setProtocolVersion ( HttpVersion version ) { request . setProtocolVersion ( version ) ; return this ; } @Override public HttpRequest setMethod ( HttpMethod method ) { request . setMethod ( method ) ; return this ; } @Override public HttpRequest setUri ( String uri ) { request . setUri ( uri ) ; return this ; } @Override public HttpMethod getMethod ( ) { return request . method ( ) ; } @Override public HttpMethod method ( ) { return request . method ( ) ; } @Override public String getUri ( ) { return request . uri ( ) ; } @Override public String uri ( ) { return request . uri ( ) ; } @Override public HttpVersion getProtocolVersion ( ) { return request . protocolVersion ( ) ; } @Override public HttpVersion protocolVersion ( ) { return request . protocolVersion ( ) ; } @Override public HttpHeaders headers ( ) { return request . headers ( ) ; } @Override public DecoderResult decoderResult ( ) { return request . decoderResult ( ) ; } @Override @Deprecated public DecoderResult getDecoderResult ( ) { return request . getDecoderResult ( ) ; } @Override public void setDecoderResult ( DecoderResult result ) { request . setDecoderResult ( result ) ; } } private static final class WrappedFullHttpRequest extends WrappedHttpRequest implements FullHttpRequest { private final HttpContent content ; private WrappedFullHttpRequest ( HttpRequest request , HttpContent content ) { super ( request ) ; this . content = content ; } @Override public FullHttpRequest setProtocolVersion ( HttpVersion version ) { super . setProtocolVersion ( version ) ; return this ; } @Override public FullHttpRequest setMethod ( HttpMethod method ) { super . setMethod ( method ) ; return this ; } @Override public FullHttpRequest setUri ( String uri ) { super . setUri ( uri ) ; return this ; } private FullHttpRequest copy ( boolean copyContent , ByteBuf newContent ) { DefaultFullHttpRequest copy = new DefaultFullHttpRequest ( protocolVersion ( ) , method ( ) , uri ( ) , copyContent ? content ( ) . copy ( ) : newContent = = null ? buffer ( <int> ) : newContent ) ; copy . headers ( ) . set ( headers ( ) ) ; copy . trailingHeaders ( ) . set ( trailingHeaders ( ) ) ; return copy ; } @Override public FullHttpRequest copy ( ByteBuf newContent ) { return copy ( false , newContent ) ; } @Override public FullHttpRequest copy ( ) { return copy ( true , null ) ; } @Override public FullHttpRequest duplicate ( ) { DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest ( getProtocolVersion ( ) , getMethod ( ) , getUri ( ) , content ( ) . duplicate ( ) ) ; duplicate . headers ( ) . set ( headers ( ) ) ; duplicate . trailingHeaders ( ) . set ( trailingHeaders ( ) ) ; return duplicate ; } @Override public FullHttpRequest retain ( int increment ) { content . retain ( increment ) ; return this ; } @Override public FullHttpRequest retain ( ) { content . retain ( ) ; return this ; } @Override public FullHttpRequest touch ( ) { content . touch ( ) ; return this ; } @Override public FullHttpRequest touch ( Object hint ) { content . touch ( hint ) ; return this ; } @Override public ByteBuf content ( ) { return content . content ( ) ; } @Override public HttpHeaders trailingHeaders ( ) { if ( content instanceof LastHttpContent ) { return ( ( LastHttpContent ) content ) . trailingHeaders ( ) ; } else { return EmptyHttpHeaders . INSTANCE ; } } @Override public int refCnt ( ) { return content . refCnt ( ) ; } @Override public boolean release ( ) { return content . release ( ) ; } @Override public boolean release ( int decrement ) { return content . release ( decrement ) ; } } } 
