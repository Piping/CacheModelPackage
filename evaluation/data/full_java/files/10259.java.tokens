package com . google . common . base ; import static java . util . concurrent . TimeUnit . MICROSECONDS ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . FakeTicker ; import junit . framework . TestCase ; @GwtCompatible ( emulated = true ) public class StopwatchTest extends TestCase { private final FakeTicker ticker = new FakeTicker ( ) ; private final Stopwatch stopwatch = new Stopwatch ( ticker ) ; public void testCreateStarted ( ) { Stopwatch startedStopwatch = Stopwatch . createStarted ( ) ; assertTrue ( startedStopwatch . isRunning ( ) ) ; } public void testCreateUnstarted ( ) { Stopwatch unstartedStopwatch = Stopwatch . createUnstarted ( ) ; assertFalse ( unstartedStopwatch . isRunning ( ) ) ; assertEquals ( <int> , unstartedStopwatch . elapsed ( NANOSECONDS ) ) ; } public void testInitialState ( ) { assertFalse ( stopwatch . isRunning ( ) ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testStart ( ) { assertSame ( stopwatch , stopwatch . start ( ) ) ; assertTrue ( stopwatch . isRunning ( ) ) ; } public void testStart_whileRunning ( ) { stopwatch . start ( ) ; try { stopwatch . start ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertTrue ( stopwatch . isRunning ( ) ) ; } public void testStop ( ) { stopwatch . start ( ) ; assertSame ( stopwatch , stopwatch . stop ( ) ) ; assertFalse ( stopwatch . isRunning ( ) ) ; } public void testStop_new ( ) { try { stopwatch . stop ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertFalse ( stopwatch . isRunning ( ) ) ; } public void testStop_alreadyStopped ( ) { stopwatch . start ( ) ; stopwatch . stop ( ) ; try { stopwatch . stop ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertFalse ( stopwatch . isRunning ( ) ) ; } public void testReset_new ( ) { ticker . advance ( <int> ) ; stopwatch . reset ( ) ; assertFalse ( stopwatch . isRunning ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; stopwatch . start ( ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testReset_whileRunning ( ) { ticker . advance ( <int> ) ; stopwatch . start ( ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; stopwatch . reset ( ) ; assertFalse ( stopwatch . isRunning ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testElapsed_whileRunning ( ) { ticker . advance ( <int> ) ; stopwatch . start ( ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testElapsed_notRunning ( ) { ticker . advance ( <int> ) ; stopwatch . start ( ) ; ticker . advance ( <int> ) ; stopwatch . stop ( ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testElapsed_multipleSegments ( ) { stopwatch . start ( ) ; ticker . advance ( <int> ) ; stopwatch . stop ( ) ; ticker . advance ( <int> ) ; stopwatch . start ( ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; stopwatch . stop ( ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( NANOSECONDS ) ) ; } public void testElapsed_micros ( ) { stopwatch . start ( ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( MICROSECONDS ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( MICROSECONDS ) ) ; } public void testElapsed_millis ( ) { stopwatch . start ( ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( MILLISECONDS ) ) ; ticker . advance ( <int> ) ; assertEquals ( <int> , stopwatch . elapsed ( MILLISECONDS ) ) ; } @GwtIncompatible ( <str> ) public void testToString ( ) { stopwatch . start ( ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; ticker . advance ( <int> ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; ticker . advance ( ( long ) ( <float> * <int> * <int> ) ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; ticker . advance ( ( long ) ( <float> * <int> * <int> * <int> ) ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; ticker . advance ( ( long ) ( <float> * <int> * <int> * <int> * <int> ) ) ; assertEquals ( <str> , stopwatch . toString ( ) ) ; } } 
