package org . gradle . api . internal . file ; import groovy . lang . Closure ; import org . gradle . api . file . FileTree ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . internal . file . collections . FileCollectionResolveContext ; import org . gradle . api . internal . file . collections . ResolvableFileCollectionResolveContext ; import org . gradle . api . internal . tasks . TaskDependencyResolveContext ; import org . gradle . api . tasks . util . PatternFilterable ; import org . gradle . internal . Cast ; import java . util . Collection ; public abstract class CompositeFileTree extends CompositeFileCollection implements FileTreeInternal { protected Collection < ? extends FileTreeInternal > getSourceCollections ( ) { return Cast . uncheckedCast ( super . getSourceCollections ( ) ) ; } public FileTree plus ( FileTree fileTree ) { return new UnionFileTree ( this , Cast . cast ( FileTreeInternal . class , fileTree ) ) ; } public FileTree matching ( Closure filterConfigClosure ) { return new FilteredFileTree ( filterConfigClosure ) ; } public FileTree matching ( PatternFilterable patterns ) { return new FilteredFileTree ( patterns ) ; } public FileTree visit ( Closure visitor ) { for ( FileTree tree : getSourceCollections ( ) ) { tree . visit ( visitor ) ; } return this ; } public FileTree visit ( FileVisitor visitor ) { for ( FileTree tree : getSourceCollections ( ) ) { tree . visit ( visitor ) ; } return this ; } @Override public void visitTreeOrBackingFile ( FileVisitor visitor ) { visit ( visitor ) ; } @Override public FileTree getAsFileTree ( ) { return this ; } private class FilteredFileTree extends CompositeFileTree { private final Closure closure ; private final PatternFilterable patterns ; public FilteredFileTree ( Closure closure ) { this . closure = closure ; patterns = null ; } public FilteredFileTree ( PatternFilterable patterns ) { this . patterns = patterns ; closure = null ; } @Override public String getDisplayName ( ) { return CompositeFileTree . this . getDisplayName ( ) ; } @Override public void visitContents ( FileCollectionResolveContext context ) { ResolvableFileCollectionResolveContext nestedContext = context . newContext ( ) ; CompositeFileTree . this . visitContents ( nestedContext ) ; for ( FileTree set : nestedContext . resolveAsFileTrees ( ) ) { if ( closure ! = null ) { context . add ( set . matching ( closure ) ) ; } else { context . add ( set . matching ( patterns ) ) ; } } } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { CompositeFileTree . this . visitDependencies ( context ) ; } } } 
