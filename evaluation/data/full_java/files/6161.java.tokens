package org . elasticsearch . common . xcontent . support . filtering ; import com . fasterxml . jackson . core . filter . TokenFilter ; import org . elasticsearch . common . util . CollectionUtils ; import java . util . ArrayList ; import java . util . List ; public class FilterPathBasedFilter extends TokenFilter { private static final TokenFilter MATCHING = new TokenFilter ( ) { } ; private static final TokenFilter NO_MATCHING = new TokenFilter ( ) { } ; private final FilterPath [ ] filters ; public FilterPathBasedFilter ( FilterPath [ ] filters ) { if ( CollectionUtils . isEmpty ( filters ) ) { throw new IllegalArgumentException ( <str> ) ; } this . filters = filters ; } public FilterPathBasedFilter ( String [ ] filters ) { this ( FilterPath . compile ( filters ) ) ; } private TokenFilter evaluate ( String name , FilterPath [ ] filters ) { if ( filters ! = null ) { List < FilterPath > nextFilters = null ; for ( FilterPath filter : filters ) { FilterPath next = filter . matchProperty ( name ) ; if ( next ! = null ) { if ( next . matches ( ) ) { return MATCHING ; } else { if ( nextFilters = = null ) { nextFilters = new ArrayList < > ( ) ; } if ( filter . isDoubleWildcard ( ) ) { nextFilters . add ( filter ) ; } nextFilters . add ( next ) ; } } } if ( ( nextFilters ! = null ) & & ( nextFilters . isEmpty ( ) = = false ) ) { return new FilterPathBasedFilter ( nextFilters . toArray ( new FilterPath [ nextFilters . size ( ) ] ) ) ; } } return NO_MATCHING ; } @Override public TokenFilter includeProperty ( String name ) { TokenFilter include = evaluate ( name , filters ) ; if ( include = = MATCHING ) { return TokenFilter . INCLUDE_ALL ; } if ( include = = NO_MATCHING ) { return null ; } return include ; } @Override protected boolean _includeScalar ( ) { for ( FilterPath filter : filters ) { if ( filter . matches ( ) ) { return true ; } } return false ; } } 
