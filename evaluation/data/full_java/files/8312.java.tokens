package org . elasticsearch . indexing ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . cluster . metadata . MetaDataCreateIndexService ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . indices . InvalidIndexNameException ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicIntegerArray ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class IndexActionIT extends ESIntegTestCase { public void testAutoGenerateIdNoDuplicates ( ) throws Exception { int numberOfIterations = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numberOfIterations ; i + + ) { Throwable firstError = null ; createIndex ( <str> ) ; int numOfDocs = randomIntBetween ( <int> , <int> ) ; logger . info ( <str> , numOfDocs ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( numOfDocs ) ; for ( int j = <int> ; j < numOfDocs ; j + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , <str> ) ) ; } indexRandom ( true , builders ) ; ensureYellow ( <str> ) ; logger . info ( <str> ) ; int numOfChecks = randomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < numOfChecks ; j + + ) { try { logger . debug ( <str> ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . get ( ) , numOfDocs ) ; } catch ( Throwable t ) { logger . error ( <str> , t ) ; if ( firstError = = null ) { firstError = t ; } } try { logger . debug ( <str> ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . get ( ) , numOfDocs ) ; } catch ( Throwable t ) { logger . error ( <str> , t ) ; if ( firstError = = null ) { firstError = t ; } } } if ( firstError ! = null ) { fail ( firstError . getMessage ( ) ) ; } internalCluster ( ) . wipeIndices ( <str> ) ; } } public void testCreatedFlag ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertFalse ( indexResponse . isCreated ( ) ) ; client ( ) . prepareDelete ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; } public void testCreatedFlagWithFlush ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; client ( ) . prepareDelete ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; flush ( ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; } public void testCreatedFlagParallelExecution ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; int threadCount = <int> ; final int docCount = <int> ; int taskCount = docCount * threadCount ; final AtomicIntegerArray createdCounts = new AtomicIntegerArray ( docCount ) ; ExecutorService threadPool = Executors . newFixedThreadPool ( threadCount ) ; List < Callable < Void > > tasks = new ArrayList < > ( taskCount ) ; final Random random = getRandom ( ) ; for ( int i = <int> ; i < taskCount ; i + + ) { tasks . add ( new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { int docId = random . nextInt ( docCount ) ; IndexResponse indexResponse = index ( <str> , <str> , Integer . toString ( docId ) , <str> , <str> ) ; if ( indexResponse . isCreated ( ) ) createdCounts . incrementAndGet ( docId ) ; return null ; } } ) ; } threadPool . invokeAll ( tasks ) ; for ( int i = <int> ; i < docCount ; i + + ) { assertThat ( createdCounts . get ( i ) , lessThanOrEqualTo ( <int> ) ) ; } terminate ( threadPool ) ; } public void testCreatedFlagWithExternalVersioning ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; } public void testCreateFlagWithBulk ( ) { createIndex ( <str> ) ; ensureGreen ( ) ; BulkResponse bulkResponse = client ( ) . prepareBulk ( ) . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) ) . execute ( ) . actionGet ( ) ; assertThat ( bulkResponse . hasFailures ( ) , equalTo ( false ) ) ; assertThat ( bulkResponse . getItems ( ) . length , equalTo ( <int> ) ) ; IndexResponse indexResponse = bulkResponse . getItems ( ) [ <int> ] . getResponse ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; } public void testCreateIndexWithLongName ( ) { int min = MetaDataCreateIndexService . MAX_INDEX_NAME_BYTES + <int> ; int max = MetaDataCreateIndexService . MAX_INDEX_NAME_BYTES * <int> ; try { createIndex ( randomAsciiOfLengthBetween ( min , max ) . toLowerCase ( Locale . ROOT ) ) ; fail ( <str> ) ; } catch ( InvalidIndexNameException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { client ( ) . prepareIndex ( randomAsciiOfLengthBetween ( min , max ) . toLowerCase ( Locale . ROOT ) , <str> ) . setSource ( <str> , <str> ) . get ( ) ; fail ( <str> ) ; } catch ( InvalidIndexNameException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { client ( ) . prepareIndex ( randomAsciiOfLength ( MetaDataCreateIndexService . MAX_INDEX_NAME_BYTES - <int> ) . toLowerCase ( Locale . ROOT ) + <str> . toLowerCase ( Locale . ROOT ) , <str> ) . setSource ( <str> , <str> ) . get ( ) ; fail ( <str> ) ; } catch ( InvalidIndexNameException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } createIndex ( randomAsciiOfLength ( MetaDataCreateIndexService . MAX_INDEX_NAME_BYTES ) . toLowerCase ( Locale . ROOT ) ) ; } public void testInvalidIndexName ( ) { try { createIndex ( <str> ) ; fail ( <str> ) ; } catch ( InvalidIndexNameException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { createIndex ( <str> ) ; fail ( <str> ) ; } catch ( InvalidIndexNameException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } } 
