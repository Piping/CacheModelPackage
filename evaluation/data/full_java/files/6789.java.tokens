package org . elasticsearch . index . store ; import org . apache . lucene . store . * ; import org . apache . lucene . util . Constants ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . index . IndexModule ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardPath ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Collections ; import java . util . Set ; public class FsDirectoryService extends DirectoryService implements StoreRateLimiting . Listener , StoreRateLimiting . Provider { protected final IndexStore indexStore ; private final CounterMetric rateLimitingTimeInNanos = new CounterMetric ( ) ; private final ShardPath path ; @Inject public FsDirectoryService ( IndexSettings indexSettings , IndexStore indexStore , ShardPath path ) { super ( path . getShardId ( ) , indexSettings ) ; this . path = path ; this . indexStore = indexStore ; } @Override public long throttleTimeInNanos ( ) { return rateLimitingTimeInNanos . count ( ) ; } @Override public StoreRateLimiting rateLimiting ( ) { return indexStore . rateLimiting ( ) ; } public static LockFactory buildLockFactory ( IndexSettings indexSettings ) { final Settings settings = indexSettings . getSettings ( ) ; String fsLock = settings . get ( <str> , settings . get ( <str> , <str> ) ) ; LockFactory lockFactory ; if ( fsLock . equals ( <str> ) ) { lockFactory = NativeFSLockFactory . INSTANCE ; } else if ( fsLock . equals ( <str> ) ) { lockFactory = SimpleFSLockFactory . INSTANCE ; } else { throw new IllegalArgumentException ( <str> + fsLock + <str> ) ; } return lockFactory ; } protected final LockFactory buildLockFactory ( ) throws IOException { return buildLockFactory ( indexSettings ) ; } @Override public Directory newDirectory ( ) throws IOException { final Path location = path . resolveIndex ( ) ; Files . createDirectories ( location ) ; Directory wrapped = newFSDirectory ( location , buildLockFactory ( ) ) ; return new RateLimitedFSDirectory ( wrapped , this , this ) ; } @Override public void onPause ( long nanos ) { rateLimitingTimeInNanos . inc ( nanos ) ; } private static final Set < String > PRIMARY_EXTENSIONS = Collections . unmodifiableSet ( Sets . newHashSet ( <str> , <str> , <str> ) ) ; protected Directory newFSDirectory ( Path location , LockFactory lockFactory ) throws IOException { final String storeType = indexSettings . getSettings ( ) . get ( IndexModule . STORE_TYPE , IndexModule . Type . DEFAULT . getSettingsKey ( ) ) ; if ( IndexModule . Type . FS . match ( storeType ) | | IndexModule . Type . DEFAULT . match ( storeType ) ) { final FSDirectory open = FSDirectory . open ( location , lockFactory ) ; if ( open instanceof MMapDirectory & & Constants . WINDOWS = = false ) { return newDefaultDir ( location , ( MMapDirectory ) open , lockFactory ) ; } return open ; } else if ( IndexModule . Type . SIMPLEFS . match ( storeType ) ) { return new SimpleFSDirectory ( location , lockFactory ) ; } else if ( IndexModule . Type . NIOFS . match ( storeType ) ) { return new NIOFSDirectory ( location , lockFactory ) ; } else if ( IndexModule . Type . MMAPFS . match ( storeType ) ) { return new MMapDirectory ( location , lockFactory ) ; } throw new IllegalArgumentException ( <str> + storeType + <str> ) ; } private Directory newDefaultDir ( Path location , final MMapDirectory mmapDir , LockFactory lockFactory ) throws IOException { return new FileSwitchDirectory ( PRIMARY_EXTENSIONS , mmapDir , new NIOFSDirectory ( location , lockFactory ) , true ) { @Override public String [ ] listAll ( ) throws IOException { return mmapDir . listAll ( ) ; } } ; } } 
