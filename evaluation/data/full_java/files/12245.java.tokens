package org . gradle . plugin . use . internal ; import org . codehaus . groovy . ast . expr . * ; import org . codehaus . groovy . ast . stmt . BlockStatement ; import org . codehaus . groovy . ast . stmt . ExpressionStatement ; import org . codehaus . groovy . ast . stmt . Statement ; import org . codehaus . groovy . control . SourceUnit ; import org . gradle . api . internal . DocumentationRegistry ; import org . gradle . groovy . scripts . ScriptSource ; import org . gradle . groovy . scripts . internal . RestrictiveCodeVisitor ; import org . gradle . groovy . scripts . internal . ScriptBlock ; import org . gradle . plugin . internal . InvalidPluginIdException ; import org . gradle . plugin . internal . PluginId ; import org . gradle . plugin . use . PluginDependencySpec ; import static org . gradle . groovy . scripts . internal . AstUtils . isString ; public class PluginUseScriptBlockMetadataExtractor { public static final String INVALID_ARGUMENT_LIST = <str> ; public static final String BASE_MESSAGE = <str> ; public static final String VERSION_MESSAGE = <str> ; private static final String NOT_LITERAL_METHOD_NAME = <str> ; private static final String NOT_LITERAL_ID_METHOD_NAME = BASE_MESSAGE + <str> + NOT_LITERAL_METHOD_NAME ; private final DocumentationRegistry documentationRegistry ; private final PluginRequestCollector pluginRequestCollector ; public PluginUseScriptBlockMetadataExtractor ( ScriptSource scriptSource , DocumentationRegistry documentationRegistry ) { this . pluginRequestCollector = new PluginRequestCollector ( scriptSource ) ; this . documentationRegistry = documentationRegistry ; } public void extract ( SourceUnit sourceUnit , ScriptBlock scriptBlock ) { ClosureExpression closureArg = scriptBlock . getClosureExpression ( ) ; closureArg . getCode ( ) . visit ( new RestrictiveCodeVisitor ( sourceUnit , formatErrorMessage ( BASE_MESSAGE ) ) { @Override public void visitBlockStatement ( BlockStatement block ) { for ( Statement statement : block . getStatements ( ) ) { statement . visit ( this ) ; } } @Override public void visitMethodCallExpression ( MethodCallExpression call ) { if ( ! call . isImplicitThis ( ) ) { Expression target = call . getObjectExpression ( ) ; if ( ! ( target instanceof MethodCallExpression ) ) { restrict ( target , formatErrorMessage ( BASE_MESSAGE ) ) ; return ; } visitMethodCallExpression ( ( MethodCallExpression ) target ) ; } if ( call . getMethod ( ) instanceof ConstantExpression ) { ConstantExpression methodName = ( ConstantExpression ) call . getMethod ( ) ; if ( isString ( methodName ) ) { String methodNameText = methodName . getText ( ) ; if ( methodNameText . equals ( <str> ) | | methodNameText . equals ( <str> ) ) { ConstantExpression argumentExpression = hasSingleConstantStringArg ( call ) ; if ( argumentExpression = = null ) { return ; } String argStringValue = argumentExpression . getValue ( ) . toString ( ) ; if ( argStringValue . length ( ) = = <int> ) { restrict ( argumentExpression , formatErrorMessage ( INVALID_ARGUMENT_LIST ) ) ; return ; } if ( methodName . getText ( ) . equals ( <str> ) ) { if ( call . isImplicitThis ( ) ) { try { PluginId . validate ( argStringValue ) ; call . setNodeMetaData ( PluginDependencySpec . class , pluginRequestCollector . createSpec ( call . getLineNumber ( ) ) . id ( argStringValue ) ) ; } catch ( InvalidPluginIdException e ) { restrict ( argumentExpression , formatErrorMessage ( e . getReason ( ) ) ) ; } } else { restrict ( call , formatErrorMessage ( BASE_MESSAGE ) ) ; } } if ( methodName . getText ( ) . equals ( <str> ) ) { Expression objectExpression = call . getObjectExpression ( ) ; if ( objectExpression instanceof MethodCallExpression ) { PluginDependencySpec spec = objectExpression . getNodeMetaData ( PluginDependencySpec . class ) ; if ( spec ! = null ) { spec . version ( argStringValue ) ; } } else { restrict ( call , formatErrorMessage ( BASE_MESSAGE ) ) ; } } } else { if ( ! call . isImplicitThis ( ) ) { restrict ( methodName , formatErrorMessage ( VERSION_MESSAGE ) ) ; } else { restrict ( methodName , formatErrorMessage ( BASE_MESSAGE ) ) ; } } } else { restrict ( methodName , formatErrorMessage ( NOT_LITERAL_ID_METHOD_NAME ) ) ; } } else { restrict ( call ) ; } } private ConstantExpression hasSingleConstantStringArg ( MethodCallExpression call ) { ArgumentListExpression argumentList = ( ArgumentListExpression ) call . getArguments ( ) ; if ( argumentList . getExpressions ( ) . size ( ) = = <int> ) { Expression argumentExpression = argumentList . getExpressions ( ) . get ( <int> ) ; if ( argumentExpression instanceof ConstantExpression ) { ConstantExpression constantArgumentExpression = ( ConstantExpression ) argumentExpression ; if ( isString ( constantArgumentExpression ) ) { return constantArgumentExpression ; } else { restrict ( constantArgumentExpression , formatErrorMessage ( INVALID_ARGUMENT_LIST ) ) ; } } else { restrict ( argumentExpression , formatErrorMessage ( INVALID_ARGUMENT_LIST ) ) ; } } else { restrict ( argumentList , formatErrorMessage ( INVALID_ARGUMENT_LIST ) ) ; } return null ; } @Override public void visitExpressionStatement ( ExpressionStatement statement ) { statement . getExpression ( ) . visit ( this ) ; } } ) ; } public PluginRequests getRequests ( ) { return new DefaultPluginRequests ( pluginRequestCollector . getRequests ( ) ) ; } public String formatErrorMessage ( String message ) { return String . format ( <str> , message , documentationRegistry . getDocumentationFor ( <str> , <str> ) ) ; } } 
