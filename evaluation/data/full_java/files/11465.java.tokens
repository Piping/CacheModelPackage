package org . gradle . api . internal . file ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . internal . file . collections . * ; import org . gradle . api . internal . tasks . AbstractTaskDependency ; import org . gradle . api . internal . tasks . TaskDependencyContainer ; import org . gradle . api . internal . tasks . TaskDependencyResolveContext ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . TaskDependency ; import java . io . File ; import java . util . * ; public abstract class CompositeFileCollection extends AbstractFileCollection implements FileCollectionContainer , TaskDependencyContainer { public Set < File > getFiles ( ) { List < Set < File > > fileSets = new LinkedList < Set < File > > ( ) ; int fileCount = <int> ; for ( FileCollection collection : getSourceCollections ( ) ) { Set < File > files = collection . getFiles ( ) ; fileCount + = files . size ( ) ; fileSets . add ( files ) ; } Set < File > allFiles = new LinkedHashSet < File > ( fileCount ) ; for ( Set < File > fileSet : fileSets ) { allFiles . addAll ( fileSet ) ; } return allFiles ; } @Override public boolean contains ( File file ) { for ( FileCollection collection : getSourceCollections ( ) ) { if ( collection . contains ( file ) ) { return true ; } } return false ; } @Override public boolean isEmpty ( ) { for ( FileCollection collection : getSourceCollections ( ) ) { if ( ! collection . isEmpty ( ) ) { return false ; } } return true ; } @Override protected void addAsResourceCollection ( Object builder , String nodeName ) { for ( FileCollection fileCollection : getSourceCollections ( ) ) { fileCollection . addToAntBuilder ( builder , nodeName , AntType . ResourceCollection ) ; } } @Override protected Collection < DirectoryFileTree > getAsFileTrees ( ) { List < DirectoryFileTree > fileTree = new ArrayList < DirectoryFileTree > ( ) ; for ( FileCollection source : getSourceCollections ( ) ) { AbstractFileCollection collection = ( AbstractFileCollection ) source ; fileTree . addAll ( collection . getAsFileTrees ( ) ) ; } return fileTree ; } @Override public FileTree getAsFileTree ( ) { return new CompositeFileTree ( ) { @Override public void visitContents ( FileCollectionResolveContext context ) { ResolvableFileCollectionResolveContext nested = context . newContext ( ) ; CompositeFileCollection . this . visitContents ( nested ) ; context . add ( nested . resolveAsFileTrees ( ) ) ; } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { CompositeFileCollection . this . visitDependencies ( context ) ; } @Override public String getDisplayName ( ) { return CompositeFileCollection . this . getDisplayName ( ) ; } } ; } @Override public FileCollection filter ( final Spec < ? super File > filterSpec ) { return new CompositeFileCollection ( ) { @Override public void visitContents ( FileCollectionResolveContext context ) { for ( FileCollection collection : CompositeFileCollection . this . getSourceCollections ( ) ) { context . add ( collection . filter ( filterSpec ) ) ; } } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { CompositeFileCollection . this . visitDependencies ( context ) ; } @Override public String getDisplayName ( ) { return CompositeFileCollection . this . getDisplayName ( ) ; } } ; } @Override public final TaskDependency getBuildDependencies ( ) { return new AbstractTaskDependency ( ) { @Override public String toString ( ) { return CompositeFileCollection . this . toString ( ) + <str> ; } public void visitDependencies ( TaskDependencyResolveContext context ) { CompositeFileCollection . this . visitDependencies ( context ) ; } } ; } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { BuildDependenciesOnlyFileCollectionResolveContext fileContext = new BuildDependenciesOnlyFileCollectionResolveContext ( context ) ; visitContents ( fileContext ) ; } protected Collection < ? extends FileCollectionInternal > getSourceCollections ( ) { DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext ( ) ; visitContents ( context ) ; return context . resolveAsFileCollections ( ) ; } @Override public void registerWatchPoints ( FileSystemSubset . Builder builder ) { for ( FileCollectionInternal files : getSourceCollections ( ) ) { files . registerWatchPoints ( builder ) ; } } } 
