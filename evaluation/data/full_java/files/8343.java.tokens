package org . elasticsearch . indices . memory ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . hamcrest . Matchers . equalTo ; public class IndexingMemoryControllerTests extends ESSingleNodeTestCase { static class MockController extends IndexingMemoryController { final static ByteSizeValue INACTIVE = new ByteSizeValue ( - <int> ) ; final Map < IndexShard , ByteSizeValue > indexingBuffers = new HashMap < > ( ) ; final Map < IndexShard , ByteSizeValue > translogBuffers = new HashMap < > ( ) ; final Map < IndexShard , Long > lastIndexTimeNanos = new HashMap < > ( ) ; final Set < IndexShard > activeShards = new HashSet < > ( ) ; long currentTimeSec = TimeValue . timeValueNanos ( System . nanoTime ( ) ) . seconds ( ) ; public MockController ( Settings settings ) { super ( Settings . builder ( ) . put ( SHARD_INACTIVE_INTERVAL_TIME_SETTING , <str> ) . put ( IndexShard . INDEX_SHARD_INACTIVE_TIME_SETTING , <str> ) . put ( settings ) . build ( ) , null , null , <int> * <int> * <int> ) ; } public void deleteShard ( IndexShard id ) { indexingBuffers . remove ( id ) ; translogBuffers . remove ( id ) ; } public void assertBuffers ( IndexShard id , ByteSizeValue indexing , ByteSizeValue translog ) { assertThat ( indexingBuffers . get ( id ) , equalTo ( indexing ) ) ; assertThat ( translogBuffers . get ( id ) , equalTo ( translog ) ) ; } public void assertInactive ( IndexShard id ) { assertThat ( indexingBuffers . get ( id ) , equalTo ( INACTIVE ) ) ; assertThat ( translogBuffers . get ( id ) , equalTo ( INACTIVE ) ) ; } @Override protected long currentTimeInNanos ( ) { return TimeValue . timeValueSeconds ( currentTimeSec ) . nanos ( ) ; } @Override protected List < IndexShard > availableShards ( ) { return new ArrayList < > ( indexingBuffers . keySet ( ) ) ; } @Override protected boolean shardAvailable ( IndexShard shard ) { return indexingBuffers . containsKey ( shard ) ; } @Override protected void updateShardBuffers ( IndexShard shard , ByteSizeValue shardIndexingBufferSize , ByteSizeValue shardTranslogBufferSize ) { indexingBuffers . put ( shard , shardIndexingBufferSize ) ; translogBuffers . put ( shard , shardTranslogBufferSize ) ; } @Override protected boolean checkIdle ( IndexShard shard ) { final TimeValue inactiveTime = settings . getAsTime ( IndexShard . INDEX_SHARD_INACTIVE_TIME_SETTING , TimeValue . timeValueMinutes ( <int> ) ) ; Long ns = lastIndexTimeNanos . get ( shard ) ; if ( ns = = null ) { return true ; } else if ( currentTimeInNanos ( ) - ns > = inactiveTime . nanos ( ) ) { indexingBuffers . put ( shard , INACTIVE ) ; translogBuffers . put ( shard , INACTIVE ) ; activeShards . remove ( shard ) ; return true ; } else { return false ; } } public void incrementTimeSec ( int sec ) { currentTimeSec + = sec ; } public void simulateIndexing ( IndexShard shard ) { lastIndexTimeNanos . put ( shard , currentTimeInNanos ( ) ) ; if ( indexingBuffers . containsKey ( shard ) = = false ) { indexingBuffers . put ( shard , IndexingMemoryController . INACTIVE_SHARD_INDEXING_BUFFER ) ; translogBuffers . put ( shard , IndexingMemoryController . INACTIVE_SHARD_TRANSLOG_BUFFER ) ; } activeShards . add ( shard ) ; forceCheck ( ) ; } } public void testShardAdditionAndRemoval ( ) { createIndex ( <str> , Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ) ; IndicesService indicesService = getInstanceFromNode ( IndicesService . class ) ; IndexService test = indicesService . indexService ( <str> ) ; MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; IndexShard shard0 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard0 ) ; controller . assertBuffers ( shard0 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; IndexShard shard1 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard1 ) ; controller . assertBuffers ( shard0 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . assertBuffers ( shard1 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . deleteShard ( shard0 ) ; controller . forceCheck ( ) ; controller . assertBuffers ( shard1 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . deleteShard ( shard1 ) ; controller . forceCheck ( ) ; IndexShard shard2 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard2 ) ; controller . assertBuffers ( shard2 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; } public void testActiveInactive ( ) { createIndex ( <str> , Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ) ; IndicesService indicesService = getInstanceFromNode ( IndicesService . class ) ; IndexService test = indicesService . indexService ( <str> ) ; MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . put ( IndexShard . INDEX_SHARD_INACTIVE_TIME_SETTING , <str> ) . build ( ) ) ; IndexShard shard0 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard0 ) ; IndexShard shard1 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard1 ) ; controller . assertBuffers ( shard0 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . assertBuffers ( shard1 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . simulateIndexing ( shard0 ) ; controller . simulateIndexing ( shard1 ) ; controller . incrementTimeSec ( <int> ) ; controller . forceCheck ( ) ; controller . assertInactive ( shard0 ) ; controller . assertInactive ( shard1 ) ; controller . simulateIndexing ( shard0 ) ; controller . assertBuffers ( shard0 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . assertInactive ( shard1 ) ; controller . incrementTimeSec ( <int> ) ; controller . forceCheck ( ) ; controller . assertBuffers ( shard0 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; controller . assertInactive ( shard1 ) ; controller . incrementTimeSec ( <int> ) ; controller . forceCheck ( ) ; controller . assertInactive ( shard0 ) ; controller . assertInactive ( shard1 ) ; controller . simulateIndexing ( shard1 ) ; controller . assertInactive ( shard0 ) ; controller . assertBuffers ( shard1 , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; } public void testMinShardBufferSizes ( ) { MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MIN_SHARD_INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MIN_SHARD_TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; assertTwoActiveShards ( controller , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; } public void testMaxShardBufferSizes ( ) { MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MAX_SHARD_INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MAX_SHARD_TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; assertTwoActiveShards ( controller , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; } public void testRelativeBufferSizes ( ) { MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; assertThat ( controller . indexingBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ) ; assertThat ( controller . translogBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; } public void testMinBufferSizes ( ) { MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MIN_INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MIN_TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; assertThat ( controller . indexingBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ) ; assertThat ( controller . translogBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; } public void testMaxBufferSizes ( ) { MockController controller = new MockController ( Settings . builder ( ) . put ( IndexingMemoryController . INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MAX_INDEX_BUFFER_SIZE_SETTING , <str> ) . put ( IndexingMemoryController . MAX_TRANSLOG_BUFFER_SIZE_SETTING , <str> ) . build ( ) ) ; assertThat ( controller . indexingBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ) ; assertThat ( controller . translogBufferSize ( ) , equalTo ( new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; } protected void assertTwoActiveShards ( MockController controller , ByteSizeValue indexBufferSize , ByteSizeValue translogBufferSize ) { createIndex ( <str> , Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ) ; IndicesService indicesService = getInstanceFromNode ( IndicesService . class ) ; IndexService test = indicesService . indexService ( <str> ) ; IndexShard shard0 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard0 ) ; IndexShard shard1 = test . getShard ( <int> ) ; controller . simulateIndexing ( shard1 ) ; controller . assertBuffers ( shard0 , indexBufferSize , translogBufferSize ) ; controller . assertBuffers ( shard1 , indexBufferSize , translogBufferSize ) ; } } 
