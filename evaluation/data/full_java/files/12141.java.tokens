package org . gradle . internal . typeconversion ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . tasks . Optional ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . util . ConfigureUtil ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; public abstract class MapNotationConverter < T > extends TypedNotationConverter < Map , T > { private final Method convertMethod ; private final String [ ] keyNames ; private final boolean [ ] optional ; public MapNotationConverter ( ) { super ( Map . class ) ; convertMethod = findConvertMethod ( ) ; Annotation [ ] [ ] parameterAnnotations = convertMethod . getParameterAnnotations ( ) ; keyNames = new String [ parameterAnnotations . length ] ; optional = new boolean [ parameterAnnotations . length ] ; for ( int i = <int> ; i < parameterAnnotations . length ; i + + ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; keyNames [ i ] = keyName ( annotations ) ; optional [ i ] = optional ( annotations ) ; } } private Method findConvertMethod ( ) { for ( Method method : getClass ( ) . getDeclaredMethods ( ) ) { if ( method . getName ( ) . equals ( <str> ) ) { method . setAccessible ( true ) ; return method ; } } throw new UnsupportedOperationException ( String . format ( <str> , getClass ( ) . getSimpleName ( ) ) ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) ; } public T parseType ( Map values ) throws UnsupportedNotationException { Map < String , Object > mutableValues = new HashMap < String , Object > ( values ) ; Set < String > missing = new TreeSet < String > ( ) ; Object [ ] params = new Object [ convertMethod . getParameterTypes ( ) . length ] ; for ( int i = <int> ; i < params . length ; i + + ) { String keyName = keyNames [ i ] ; boolean optional = this . optional [ i ] ; Class < ? > type = convertMethod . getParameterTypes ( ) [ i ] ; Object value ; if ( type . equals ( String . class ) ) { value = get ( mutableValues , keyName ) ; } else { value = type . cast ( mutableValues . get ( keyName ) ) ; } if ( ! optional & & value = = null ) { missing . add ( keyName ) ; } mutableValues . remove ( keyName ) ; params [ i ] = value ; } if ( ! missing . isEmpty ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , missing , values ) ) ; } T result ; try { result = ( T ) convertMethod . invoke ( this , params ) ; } catch ( IllegalAccessException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } catch ( InvocationTargetException e ) { throw UncheckedException . unwrapAndRethrow ( e ) ; } ConfigureUtil . configureByMap ( mutableValues , result ) ; return result ; } private boolean optional ( Annotation [ ] annotations ) { for ( Annotation annotation : annotations ) { if ( annotation instanceof Optional ) { return true ; } } return false ; } private String keyName ( Annotation [ ] annotations ) { for ( Annotation annotation : annotations ) { if ( annotation instanceof MapKey ) { return ( ( MapKey ) annotation ) . value ( ) ; } } throw new UnsupportedOperationException ( <str> ) ; } protected String get ( Map < String , Object > args , String key ) { Object value = args . get ( key ) ; String str = value ! = null ? value . toString ( ) : null ; if ( str ! = null & & str . length ( ) = = <int> ) { return null ; } return str ; } } 
