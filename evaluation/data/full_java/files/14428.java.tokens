package org . gradle . model . internal . registry ; import org . gradle . model . InvalidModelRuleException ; import org . gradle . model . ModelRuleBindingException ; import org . gradle . model . internal . core . ModelNode ; import org . gradle . model . internal . core . ModelPath ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import org . gradle . model . internal . report . AmbiguousBindingReporter ; abstract class ModelBinding { final BindingPredicate predicate ; final ModelRuleDescriptor referrer ; final boolean writable ; protected ModelNodeInternal boundTo ; protected ModelBinding ( ModelRuleDescriptor referrer , BindingPredicate predicate , boolean writable ) { this . predicate = predicate ; this . referrer = referrer ; this . writable = writable ; } public BindingPredicate getPredicate ( ) { return predicate ; } public boolean isBound ( ) { return boundTo ! = null ; } public ModelNodeInternal getNode ( ) { if ( boundTo = = null ) { throw new IllegalStateException ( <str> ) ; } return boundTo ; } @Override public String toString ( ) { return <str> + predicate + <str> + boundTo + <str> ; } public abstract boolean canBindInState ( ModelNode . State state ) ; public final void onBind ( ModelNodeInternal node ) { if ( boundTo ! = null ) { ModelRuleDescriptor creatorDescriptor = node . getDescriptor ( ) ; ModelPath path = node . getPath ( ) ; throw new InvalidModelRuleException ( referrer , new ModelRuleBindingException ( new AmbiguousBindingReporter ( predicate . getReference ( ) , boundTo . getPath ( ) , boundTo . getDescriptor ( ) , path , creatorDescriptor ) . asString ( ) ) ) ; } doOnBind ( node ) ; } protected void doOnBind ( ModelNodeInternal node ) { } public void onUnbind ( ModelNodeInternal node ) { if ( node = = boundTo ) { boundTo = null ; } } } 
