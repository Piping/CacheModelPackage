package org . apache . cassandra . cql3 ; import java . util . ArrayList ; import java . util . List ; import java . util . stream . Collectors ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Term . MultiColumnRaw ; import org . apache . cassandra . cql3 . Term . Raw ; import org . apache . cassandra . cql3 . restrictions . MultiColumnRestriction ; import org . apache . cassandra . cql3 . restrictions . Restriction ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . exceptions . InvalidRequestException ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; public class MultiColumnRelation extends Relation { private final List < ColumnIdentifier . Raw > entities ; private final Term . MultiColumnRaw valuesOrMarker ; private final List < ? extends Term . MultiColumnRaw > inValues ; private final Tuples . INRaw inMarker ; private MultiColumnRelation ( List < ColumnIdentifier . Raw > entities , Operator relationType , Term . MultiColumnRaw valuesOrMarker , List < ? extends Term . MultiColumnRaw > inValues , Tuples . INRaw inMarker ) { this . entities = entities ; this . relationType = relationType ; this . valuesOrMarker = valuesOrMarker ; this . inValues = inValues ; this . inMarker = inMarker ; } public static MultiColumnRelation createNonInRelation ( List < ColumnIdentifier . Raw > entities , Operator relationType , Term . MultiColumnRaw valuesOrMarker ) { assert relationType ! = Operator . IN ; return new MultiColumnRelation ( entities , relationType , valuesOrMarker , null , null ) ; } public static MultiColumnRelation createInRelation ( List < ColumnIdentifier . Raw > entities , List < ? extends Term . MultiColumnRaw > inValues ) { return new MultiColumnRelation ( entities , Operator . IN , null , inValues , null ) ; } public static MultiColumnRelation createSingleMarkerInRelation ( List < ColumnIdentifier . Raw > entities , Tuples . INRaw inMarker ) { return new MultiColumnRelation ( entities , Operator . IN , null , null , inMarker ) ; } public List < ColumnIdentifier . Raw > getEntities ( ) { return entities ; } public Term . MultiColumnRaw getValue ( ) { return relationType = = Operator . IN ? inMarker : valuesOrMarker ; } public List < ? extends Term . Raw > getInValues ( ) { assert relationType = = Operator . IN ; return inValues ; } @Override public boolean isMultiColumn ( ) { return true ; } @Override protected Restriction newEQRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { List < ColumnDefinition > receivers = receivers ( cfm ) ; Term term = toTerm ( receivers , getValue ( ) , cfm . ksName , boundNames ) ; return new MultiColumnRestriction . EQRestriction ( receivers , term ) ; } @Override protected Restriction newINRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { List < ColumnDefinition > receivers = receivers ( cfm ) ; List < Term > terms = toTerms ( receivers , inValues , cfm . ksName , boundNames ) ; if ( terms = = null ) { Term term = toTerm ( receivers , getValue ( ) , cfm . ksName , boundNames ) ; return new MultiColumnRestriction . InRestrictionWithMarker ( receivers , ( AbstractMarker ) term ) ; } return new MultiColumnRestriction . InRestrictionWithValues ( receivers , terms ) ; } @Override protected Restriction newSliceRestriction ( CFMetaData cfm , VariableSpecifications boundNames , Bound bound , boolean inclusive ) throws InvalidRequestException { List < ColumnDefinition > receivers = receivers ( cfm ) ; Term term = toTerm ( receivers ( cfm ) , getValue ( ) , cfm . ksName , boundNames ) ; return new MultiColumnRestriction . SliceRestriction ( receivers , bound , inclusive , term ) ; } @Override protected Restriction newContainsRestriction ( CFMetaData cfm , VariableSpecifications boundNames , boolean isKey ) throws InvalidRequestException { throw invalidRequest ( <str> , operator ( ) ) ; } @Override protected Restriction newIsNotRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { throw new AssertionError ( String . format ( <str> , operator ( ) ) ) ; } @Override protected Term toTerm ( List < ? extends ColumnSpecification > receivers , Raw raw , String keyspace , VariableSpecifications boundNames ) throws InvalidRequestException { Term term = ( ( MultiColumnRaw ) raw ) . prepare ( keyspace , receivers ) ; term . collectMarkerSpecification ( boundNames ) ; return term ; } protected List < ColumnDefinition > receivers ( CFMetaData cfm ) throws InvalidRequestException { List < ColumnDefinition > names = new ArrayList < > ( getEntities ( ) . size ( ) ) ; int previousPosition = - <int> ; for ( ColumnIdentifier . Raw raw : getEntities ( ) ) { ColumnDefinition def = toColumnDefinition ( cfm , raw ) ; checkTrue ( def . isClusteringColumn ( ) , <str> , def . name ) ; checkFalse ( names . contains ( def ) , <str> , def . name , this ) ; checkFalse ( previousPosition ! = - <int> & & def . position ( ) ! = previousPosition + <int> , <str> , this ) ; names . add ( def ) ; previousPosition = def . position ( ) ; } return names ; } public Relation renameIdentifier ( ColumnIdentifier . Raw from , ColumnIdentifier . Raw to ) { if ( ! entities . contains ( from ) ) return this ; List < ColumnIdentifier . Raw > newEntities = entities . stream ( ) . map ( e - > e . equals ( from ) ? to : e ) . collect ( Collectors . toList ( ) ) ; return new MultiColumnRelation ( newEntities , operator ( ) , valuesOrMarker , inValues , inMarker ) ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( Tuples . tupleToString ( entities ) ) ; if ( isIN ( ) ) { return builder . append ( <str> ) . append ( inMarker ! = null ? <str> : Tuples . tupleToString ( inValues ) ) . toString ( ) ; } return builder . append ( <str> ) . append ( relationType ) . append ( <str> ) . append ( valuesOrMarker ) . toString ( ) ; } } 
