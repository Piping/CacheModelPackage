package io . netty . handler . ipfilter ; import java . math . BigInteger ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; public final class IpSubnetFilterRule implements IpFilterRule { private final IpFilterRule filterRule ; public IpSubnetFilterRule ( String ipAddress , int cidrPrefix , IpFilterRuleType ruleType ) { try { filterRule = selectFilterRule ( InetAddress . getByName ( ipAddress ) , cidrPrefix , ruleType ) ; } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } public IpSubnetFilterRule ( InetAddress ipAddress , int cidrPrefix , IpFilterRuleType ruleType ) { filterRule = selectFilterRule ( ipAddress , cidrPrefix , ruleType ) ; } private static IpFilterRule selectFilterRule ( InetAddress ipAddress , int cidrPrefix , IpFilterRuleType ruleType ) { if ( ipAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( ruleType = = null ) { throw new NullPointerException ( <str> ) ; } if ( ipAddress instanceof Inet4Address ) { return new Ip4SubnetFilterRule ( ( Inet4Address ) ipAddress , cidrPrefix , ruleType ) ; } else if ( ipAddress instanceof Inet6Address ) { return new Ip6SubnetFilterRule ( ( Inet6Address ) ipAddress , cidrPrefix , ruleType ) ; } else { throw new IllegalArgumentException ( <str> ) ; } } @Override public boolean matches ( InetSocketAddress remoteAddress ) { return filterRule . matches ( remoteAddress ) ; } @Override public IpFilterRuleType ruleType ( ) { return filterRule . ruleType ( ) ; } private static final class Ip4SubnetFilterRule implements IpFilterRule { private final int networkAddress ; private final int subnetMask ; private final IpFilterRuleType ruleType ; private Ip4SubnetFilterRule ( Inet4Address ipAddress , int cidrPrefix , IpFilterRuleType ruleType ) { if ( cidrPrefix < <int> | | cidrPrefix > <int> ) { throw new IllegalArgumentException ( String . format ( <str> + <str> , cidrPrefix ) ) ; } subnetMask = prefixToSubnetMask ( cidrPrefix ) ; networkAddress = ipToInt ( ipAddress ) & subnetMask ; this . ruleType = ruleType ; } @Override public boolean matches ( InetSocketAddress remoteAddress ) { int ipAddress = ipToInt ( ( Inet4Address ) remoteAddress . getAddress ( ) ) ; return ( ipAddress & subnetMask ) = = networkAddress ; } @Override public IpFilterRuleType ruleType ( ) { return ruleType ; } private static int ipToInt ( Inet4Address ipAddress ) { byte [ ] octets = ipAddress . getAddress ( ) ; assert octets . length = = <int> ; return ( octets [ <int> ] & <hex> ) < < <int> | ( octets [ <int> ] & <hex> ) < < <int> | ( octets [ <int> ] & <hex> ) < < <int> | octets [ <int> ] & <hex> ; } private static int prefixToSubnetMask ( int cidrPrefix ) { return ( int ) ( ( - <int> < < <int> - cidrPrefix ) & <hex> ) ; } } private static final class Ip6SubnetFilterRule implements IpFilterRule { private static final BigInteger MINUS_ONE = BigInteger . valueOf ( - <int> ) ; private final BigInteger networkAddress ; private final BigInteger subnetMask ; private final IpFilterRuleType ruleType ; private Ip6SubnetFilterRule ( Inet6Address ipAddress , int cidrPrefix , IpFilterRuleType ruleType ) { if ( cidrPrefix < <int> | | cidrPrefix > <int> ) { throw new IllegalArgumentException ( String . format ( <str> + <str> , cidrPrefix ) ) ; } subnetMask = prefixToSubnetMask ( cidrPrefix ) ; networkAddress = ipToInt ( ipAddress ) . and ( subnetMask ) ; this . ruleType = ruleType ; } @Override public boolean matches ( InetSocketAddress remoteAddress ) { BigInteger ipAddress = ipToInt ( ( Inet6Address ) remoteAddress . getAddress ( ) ) ; return ipAddress . and ( subnetMask ) . equals ( networkAddress ) ; } @Override public IpFilterRuleType ruleType ( ) { return ruleType ; } private static BigInteger ipToInt ( Inet6Address ipAddress ) { byte [ ] octets = ipAddress . getAddress ( ) ; assert octets . length = = <int> ; return new BigInteger ( octets ) ; } private static BigInteger prefixToSubnetMask ( int cidrPrefix ) { return MINUS_ONE . shiftLeft ( <int> - cidrPrefix ) ; } } } 
