package org . elasticsearch . index . query . functionscore . fieldvaluefactor ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . search . function . FieldValueFactorFunction ; import org . elasticsearch . common . lucene . search . function . ScoreFunction ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . fielddata . IndexNumericFieldData ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . query . functionscore . ScoreFunctionBuilder ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public class FieldValueFactorFunctionBuilder extends ScoreFunctionBuilder < FieldValueFactorFunctionBuilder > { public static final FieldValueFactorFunction . Modifier DEFAULT_MODIFIER = FieldValueFactorFunction . Modifier . NONE ; public static final float DEFAULT_FACTOR = <int> ; private final String field ; private float factor = DEFAULT_FACTOR ; private Double missing ; private FieldValueFactorFunction . Modifier modifier = DEFAULT_MODIFIER ; public FieldValueFactorFunctionBuilder ( String fieldName ) { if ( fieldName = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . field = fieldName ; } @Override public String getName ( ) { return FieldValueFactorFunctionParser . NAMES [ <int> ] ; } public String fieldName ( ) { return this . field ; } public FieldValueFactorFunctionBuilder factor ( float boostFactor ) { this . factor = boostFactor ; return this ; } public float factor ( ) { return this . factor ; } public FieldValueFactorFunctionBuilder missing ( double missing ) { this . missing = missing ; return this ; } public Double missing ( ) { return this . missing ; } public FieldValueFactorFunctionBuilder modifier ( FieldValueFactorFunction . Modifier modifier ) { if ( modifier = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . modifier = modifier ; return this ; } public FieldValueFactorFunction . Modifier modifier ( ) { return this . modifier ; } @Override public void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( getName ( ) ) ; builder . field ( <str> , field ) ; builder . field ( <str> , factor ) ; if ( missing ! = null ) { builder . field ( <str> , missing ) ; } builder . field ( <str> , modifier . name ( ) . toLowerCase ( Locale . ROOT ) ) ; builder . endObject ( ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( field ) ; out . writeFloat ( factor ) ; if ( missing = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeDouble ( missing ) ; } modifier . writeTo ( out ) ; } @Override protected FieldValueFactorFunctionBuilder doReadFrom ( StreamInput in ) throws IOException { FieldValueFactorFunctionBuilder functionBuilder = new FieldValueFactorFunctionBuilder ( in . readString ( ) ) ; functionBuilder . factor = in . readFloat ( ) ; if ( in . readBoolean ( ) ) { functionBuilder . missing = in . readDouble ( ) ; } functionBuilder . modifier = FieldValueFactorFunction . Modifier . readModifierFrom ( in ) ; return functionBuilder ; } @Override protected boolean doEquals ( FieldValueFactorFunctionBuilder functionBuilder ) { return Objects . equals ( this . field , functionBuilder . field ) & & Objects . equals ( this . factor , functionBuilder . factor ) & & Objects . equals ( this . missing , functionBuilder . missing ) & & Objects . equals ( this . modifier , functionBuilder . modifier ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( this . field , this . factor , this . missing , this . modifier ) ; } @Override protected ScoreFunction doToFunction ( QueryShardContext context ) { MappedFieldType fieldType = context . getMapperService ( ) . smartNameFieldType ( field ) ; IndexNumericFieldData fieldData = null ; if ( fieldType = = null ) { if ( missing = = null ) { throw new ElasticsearchException ( <str> + field + <str> ) ; } } else { fieldData = context . getForField ( fieldType ) ; } return new FieldValueFactorFunction ( field , factor , modifier , missing , fieldData ) ; } } 
