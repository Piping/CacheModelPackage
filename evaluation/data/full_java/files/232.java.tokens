package org . apache . cassandra . cql3 . statements ; import java . util . * ; import java . util . stream . Collectors ; import com . google . common . collect . Iterables ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . CFName ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . db . marshal . CounterColumnType ; import org . apache . cassandra . db . marshal . ReversedType ; import org . apache . cassandra . db . view . View ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . schema . Indexes ; import org . apache . cassandra . schema . TableParams ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . transport . Event ; import static org . apache . cassandra . thrift . ThriftValidation . validateColumnFamily ; public class AlterTableStatement extends SchemaAlteringStatement { public enum Type { ADD , ALTER , DROP , OPTS , RENAME } public final Type oType ; public final CQL3Type . Raw validator ; public final ColumnIdentifier . Raw rawColumnName ; private final TableAttributes attrs ; private final Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames ; private final boolean isStatic ; public AlterTableStatement ( CFName name , Type type , ColumnIdentifier . Raw columnName , CQL3Type . Raw validator , TableAttributes attrs , Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames , boolean isStatic ) { super ( name ) ; this . oType = type ; this . rawColumnName = columnName ; this . validator = validator ; this . attrs = attrs ; this . renames = renames ; this . isStatic = isStatic ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . hasColumnFamilyAccess ( keyspace ( ) , columnFamily ( ) , Permission . ALTER ) ; } public void validate ( ClientState state ) { } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { CFMetaData meta = validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; if ( meta . isView ( ) ) throw new InvalidRequestException ( <str> ) ; CFMetaData cfm = meta . copy ( ) ; CQL3Type validator = this . validator = = null ? null : this . validator . prepare ( keyspace ( ) ) ; ColumnIdentifier columnName = null ; ColumnDefinition def = null ; if ( rawColumnName ! = null ) { columnName = rawColumnName . prepare ( cfm ) ; def = cfm . getColumnDefinition ( columnName ) ; } List < ViewDefinition > viewUpdates = null ; Iterable < ViewDefinition > views = View . findAll ( keyspace ( ) , columnFamily ( ) ) ; switch ( oType ) { case ADD : assert columnName ! = null ; if ( cfm . isDense ( ) ) throw new InvalidRequestException ( <str> ) ; if ( isStatic ) { if ( ! cfm . isCompound ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . clusteringColumns ( ) . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; } if ( def ! = null ) { switch ( def . kind ) { case PARTITION_KEY : case CLUSTERING : throw new InvalidRequestException ( String . format ( <str> , columnName ) ) ; default : throw new InvalidRequestException ( String . format ( <str> , columnName ) ) ; } } if ( meta . isCounter ( ) & & meta . getDroppedColumns ( ) . containsKey ( columnName . bytes ) ) throw new InvalidRequestException ( String . format ( <str> , columnName ) ) ; AbstractType < ? > type = validator . getType ( ) ; if ( type . isCollection ( ) & & type . isMultiCell ( ) ) { if ( ! cfm . isCompound ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . isSuper ( ) ) throw new InvalidRequestException ( <str> ) ; CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; if ( dropped ! = null & & dropped . type instanceof CollectionType & & dropped . type . isMultiCell ( ) & & ! type . isCompatibleWith ( dropped . type ) ) { String message = String . format ( <str> + <str> , columnName , dropped . type . asCQL3Type ( ) ) ; throw new InvalidRequestException ( message ) ; } } cfm . addColumnDefinition ( isStatic ? ColumnDefinition . staticDef ( cfm , columnName . bytes , type ) : ColumnDefinition . regularDef ( cfm , columnName . bytes , type ) ) ; if ( ! isStatic ) { for ( ViewDefinition view : views ) { if ( view . includeAllColumns ) { ViewDefinition viewCopy = view . copy ( ) ; viewCopy . metadata . addColumnDefinition ( ColumnDefinition . regularDef ( viewCopy . metadata , columnName . bytes , type ) ) ; if ( viewUpdates = = null ) viewUpdates = new ArrayList < > ( ) ; viewUpdates . add ( viewCopy ) ; } } } break ; case ALTER : assert columnName ! = null ; if ( def = = null ) throw new InvalidRequestException ( String . format ( <str> , columnName , columnFamily ( ) ) ) ; AbstractType < ? > validatorType = def . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) ? ReversedType . getInstance ( validator . getType ( ) ) : validator . getType ( ) ; validateAlter ( cfm , def , validatorType ) ; cfm . addOrReplaceColumnDefinition ( def . withNewType ( validatorType ) ) ; for ( ViewDefinition view : views ) { if ( ! view . includes ( columnName ) ) continue ; ViewDefinition viewCopy = view . copy ( ) ; ColumnDefinition viewDef = view . metadata . getColumnDefinition ( columnName ) ; AbstractType viewType = viewDef . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) ? ReversedType . getInstance ( validator . getType ( ) ) : validator . getType ( ) ; validateAlter ( view . metadata , viewDef , viewType ) ; viewCopy . metadata . addOrReplaceColumnDefinition ( viewDef . withNewType ( viewType ) ) ; if ( viewUpdates = = null ) viewUpdates = new ArrayList < > ( ) ; viewUpdates . add ( viewCopy ) ; } break ; case DROP : assert columnName ! = null ; if ( ! cfm . isCQLTable ( ) ) throw new InvalidRequestException ( <str> ) ; if ( def = = null ) throw new InvalidRequestException ( String . format ( <str> , columnName , columnFamily ( ) ) ) ; switch ( def . kind ) { case PARTITION_KEY : case CLUSTERING : throw new InvalidRequestException ( String . format ( <str> , columnName ) ) ; case REGULAR : case STATIC : ColumnDefinition toDelete = null ; for ( ColumnDefinition columnDef : cfm . partitionColumns ( ) ) { if ( columnDef . name . equals ( columnName ) ) { toDelete = columnDef ; break ; } } assert toDelete ! = null ; cfm . removeColumnDefinition ( toDelete ) ; cfm . recordColumnDrop ( toDelete ) ; break ; } Indexes allIndexes = cfm . getIndexes ( ) ; if ( ! allIndexes . isEmpty ( ) ) { ColumnFamilyStore store = Keyspace . openAndGetStore ( cfm ) ; Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; if ( ! dependentIndexes . isEmpty ( ) ) throw new InvalidRequestException ( String . format ( <str> + <str> , def , dependentIndexes . stream ( ) . map ( i - > i . name ) . collect ( Collectors . joining ( <str> ) ) ) ) ; } boolean rejectAlter = false ; StringBuilder builder = new StringBuilder ( ) ; for ( ViewDefinition view : views ) { if ( ! view . includes ( columnName ) ) continue ; if ( rejectAlter ) builder . append ( <str> ) ; rejectAlter = true ; builder . append ( view . viewName ) ; } if ( rejectAlter ) throw new InvalidRequestException ( String . format ( <str> , columnName . toString ( ) , keyspace ( ) , builder . toString ( ) ) ) ; break ; case OPTS : if ( attrs = = null ) throw new InvalidRequestException ( <str> ) ; attrs . validate ( ) ; TableParams params = attrs . asAlteredTableParams ( cfm . params ) ; if ( ! Iterables . isEmpty ( views ) & & params . gcGraceSeconds = = <int> ) { throw new InvalidRequestException ( <str> + <str> + <str> + <str> + <str> ) ; } if ( meta . isCounter ( ) & & params . defaultTimeToLive > <int> ) throw new InvalidRequestException ( <str> ) ; cfm . params ( params ) ; break ; case RENAME : for ( Map . Entry < ColumnIdentifier . Raw , ColumnIdentifier . Raw > entry : renames . entrySet ( ) ) { ColumnIdentifier from = entry . getKey ( ) . prepare ( cfm ) ; ColumnIdentifier to = entry . getValue ( ) . prepare ( cfm ) ; cfm . renameColumn ( from , to ) ; for ( ViewDefinition view : views ) { if ( ! view . includes ( from ) ) continue ; ViewDefinition viewCopy = view . copy ( ) ; ColumnIdentifier viewFrom = entry . getKey ( ) . prepare ( viewCopy . metadata ) ; ColumnIdentifier viewTo = entry . getValue ( ) . prepare ( viewCopy . metadata ) ; viewCopy . renameColumn ( viewFrom , viewTo ) ; if ( viewUpdates = = null ) viewUpdates = new ArrayList < > ( ) ; viewUpdates . add ( viewCopy ) ; } } break ; } MigrationManager . announceColumnFamilyUpdate ( cfm , false , isLocalOnly ) ; if ( viewUpdates ! = null ) { for ( ViewDefinition viewUpdate : viewUpdates ) MigrationManager . announceViewUpdate ( viewUpdate , isLocalOnly ) ; } return new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , keyspace ( ) , columnFamily ( ) ) ; } private static void validateAlter ( CFMetaData cfm , ColumnDefinition def , AbstractType < ? > validatorType ) { switch ( def . kind ) { case PARTITION_KEY : if ( validatorType instanceof CounterColumnType ) throw new InvalidRequestException ( String . format ( <str> , def . name ) ) ; AbstractType < ? > currentType = cfm . getKeyValidatorAsClusteringComparator ( ) . subtype ( def . position ( ) ) ; if ( ! validatorType . isValueCompatibleWith ( currentType ) ) throw new ConfigurationException ( String . format ( <str> , def . name , currentType . asCQL3Type ( ) , validatorType . asCQL3Type ( ) ) ) ; break ; case CLUSTERING : if ( ! cfm . isCQLTable ( ) ) throw new InvalidRequestException ( String . format ( <str> , def . name ) ) ; AbstractType < ? > oldType = cfm . comparator . subtype ( def . position ( ) ) ; if ( ! validatorType . isCompatibleWith ( oldType ) ) { throw new ConfigurationException ( String . format ( <str> , def . name , oldType . asCQL3Type ( ) , validatorType . asCQL3Type ( ) ) ) ; } break ; case REGULAR : case STATIC : if ( ! validatorType . isValueCompatibleWith ( def . type ) ) throw new ConfigurationException ( String . format ( <str> , def . name , def . type . asCQL3Type ( ) , validatorType . asCQL3Type ( ) ) ) ; break ; } } public String toString ( ) { return String . format ( <str> , cfName , oType , rawColumnName , validator ) ; } } 
