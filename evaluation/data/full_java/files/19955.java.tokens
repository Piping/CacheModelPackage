package io . netty . handler . ssl ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; final class CipherSuiteConverter { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( CipherSuiteConverter . class ) ; private static final Pattern JAVA_CIPHERSUITE_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern OPENSSL_CIPHERSUITE_PATTERN = Pattern . compile ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; private static final Pattern JAVA_AES_CBC_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern JAVA_AES_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern OPENSSL_AES_CBC_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern OPENSSL_AES_PATTERN = Pattern . compile ( <str> ) ; private static final ConcurrentMap < String , String > j2o = PlatformDependent . newConcurrentHashMap ( ) ; private static final ConcurrentMap < String , Map < String , String > > o2j = PlatformDependent . newConcurrentHashMap ( ) ; static void clearCache ( ) { j2o . clear ( ) ; o2j . clear ( ) ; } static boolean isJ2OCached ( String key , String value ) { return value . equals ( j2o . get ( key ) ) ; } static boolean isO2JCached ( String key , String protocol , String value ) { Map < String , String > p2j = o2j . get ( key ) ; if ( p2j = = null ) { return false ; } else { return value . equals ( p2j . get ( protocol ) ) ; } } static String toOpenSsl ( Iterable < String > javaCipherSuites ) { final StringBuilder buf = new StringBuilder ( ) ; for ( String c : javaCipherSuites ) { if ( c = = null ) { break ; } String converted = toOpenSsl ( c ) ; if ( converted ! = null ) { c = converted ; } buf . append ( c ) ; buf . append ( <str> ) ; } if ( buf . length ( ) > <int> ) { buf . setLength ( buf . length ( ) - <int> ) ; return buf . toString ( ) ; } else { return <str> ; } } static String toOpenSsl ( String javaCipherSuite ) { String converted = j2o . get ( javaCipherSuite ) ; if ( converted ! = null ) { return converted ; } else { return cacheFromJava ( javaCipherSuite ) ; } } private static String cacheFromJava ( String javaCipherSuite ) { String openSslCipherSuite = toOpenSslUncached ( javaCipherSuite ) ; if ( openSslCipherSuite = = null ) { return null ; } j2o . putIfAbsent ( javaCipherSuite , openSslCipherSuite ) ; final String javaCipherSuiteSuffix = javaCipherSuite . substring ( <int> ) ; Map < String , String > p2j = new HashMap < String , String > ( <int> ) ; p2j . put ( <str> , javaCipherSuiteSuffix ) ; p2j . put ( <str> , <str> + javaCipherSuiteSuffix ) ; p2j . put ( <str> , <str> + javaCipherSuiteSuffix ) ; o2j . put ( openSslCipherSuite , p2j ) ; logger . debug ( <str> , javaCipherSuite , openSslCipherSuite ) ; return openSslCipherSuite ; } static String toOpenSslUncached ( String javaCipherSuite ) { Matcher m = JAVA_CIPHERSUITE_PATTERN . matcher ( javaCipherSuite ) ; if ( ! m . matches ( ) ) { return null ; } String handshakeAlgo = toOpenSslHandshakeAlgo ( m . group ( <int> ) ) ; String bulkCipher = toOpenSslBulkCipher ( m . group ( <int> ) ) ; String hmacAlgo = toOpenSslHmacAlgo ( m . group ( <int> ) ) ; if ( handshakeAlgo . length ( ) = = <int> ) { return bulkCipher + <str> + hmacAlgo ; } else { return handshakeAlgo + <str> + bulkCipher + <str> + hmacAlgo ; } } private static String toOpenSslHandshakeAlgo ( String handshakeAlgo ) { final boolean export = handshakeAlgo . endsWith ( <str> ) ; if ( export ) { handshakeAlgo = handshakeAlgo . substring ( <int> , handshakeAlgo . length ( ) - <int> ) ; } if ( <str> . equals ( handshakeAlgo ) ) { handshakeAlgo = <str> ; } else if ( handshakeAlgo . endsWith ( <str> ) ) { handshakeAlgo = <str> + handshakeAlgo . substring ( <int> , handshakeAlgo . length ( ) - <int> ) ; } if ( export ) { if ( handshakeAlgo . length ( ) = = <int> ) { handshakeAlgo = <str> ; } else { handshakeAlgo = <str> + handshakeAlgo ; } } return handshakeAlgo . replace ( <str> , <str> ) ; } private static String toOpenSslBulkCipher ( String bulkCipher ) { if ( bulkCipher . startsWith ( <str> ) ) { Matcher m = JAVA_AES_CBC_PATTERN . matcher ( bulkCipher ) ; if ( m . matches ( ) ) { return m . replaceFirst ( <str> ) ; } m = JAVA_AES_PATTERN . matcher ( bulkCipher ) ; if ( m . matches ( ) ) { return m . replaceFirst ( <str> ) ; } } if ( <str> . equals ( bulkCipher ) ) { return <str> ; } if ( <str> . equals ( bulkCipher ) | | <str> . equals ( bulkCipher ) ) { return <str> ; } if ( <str> . equals ( bulkCipher ) | | <str> . equals ( bulkCipher ) ) { return <str> ; } if ( <str> . equals ( bulkCipher ) ) { return <str> ; } return bulkCipher . replace ( <str> , <str> ) ; } private static String toOpenSslHmacAlgo ( String hmacAlgo ) { return hmacAlgo ; } static String toJava ( String openSslCipherSuite , String protocol ) { Map < String , String > p2j = o2j . get ( openSslCipherSuite ) ; if ( p2j = = null ) { p2j = cacheFromOpenSsl ( openSslCipherSuite ) ; } String javaCipherSuite = p2j . get ( protocol ) ; if ( javaCipherSuite = = null ) { javaCipherSuite = protocol + <str> + p2j . get ( <str> ) ; } return javaCipherSuite ; } private static Map < String , String > cacheFromOpenSsl ( String openSslCipherSuite ) { String javaCipherSuiteSuffix = toJavaUncached ( openSslCipherSuite ) ; if ( javaCipherSuiteSuffix = = null ) { return null ; } final String javaCipherSuiteSsl = <str> + javaCipherSuiteSuffix ; final String javaCipherSuiteTls = <str> + javaCipherSuiteSuffix ; final Map < String , String > p2j = new HashMap < String , String > ( <int> ) ; p2j . put ( <str> , javaCipherSuiteSuffix ) ; p2j . put ( <str> , javaCipherSuiteSsl ) ; p2j . put ( <str> , javaCipherSuiteTls ) ; o2j . putIfAbsent ( openSslCipherSuite , p2j ) ; j2o . putIfAbsent ( javaCipherSuiteTls , openSslCipherSuite ) ; j2o . putIfAbsent ( javaCipherSuiteSsl , openSslCipherSuite ) ; logger . debug ( <str> , javaCipherSuiteTls , openSslCipherSuite ) ; logger . debug ( <str> , javaCipherSuiteSsl , openSslCipherSuite ) ; return p2j ; } static String toJavaUncached ( String openSslCipherSuite ) { Matcher m = OPENSSL_CIPHERSUITE_PATTERN . matcher ( openSslCipherSuite ) ; if ( ! m . matches ( ) ) { return null ; } String handshakeAlgo = m . group ( <int> ) ; final boolean export ; if ( handshakeAlgo = = null ) { handshakeAlgo = <str> ; export = false ; } else if ( handshakeAlgo . startsWith ( <str> ) ) { handshakeAlgo = handshakeAlgo . substring ( <int> ) ; export = true ; } else if ( <str> . equals ( handshakeAlgo ) ) { handshakeAlgo = <str> ; export = true ; } else { export = false ; } handshakeAlgo = toJavaHandshakeAlgo ( handshakeAlgo , export ) ; String bulkCipher = toJavaBulkCipher ( m . group ( <int> ) , export ) ; String hmacAlgo = toJavaHmacAlgo ( m . group ( <int> ) ) ; return handshakeAlgo + <str> + bulkCipher + <str> + hmacAlgo ; } private static String toJavaHandshakeAlgo ( String handshakeAlgo , boolean export ) { if ( handshakeAlgo . length ( ) = = <int> ) { handshakeAlgo = <str> ; } else if ( <str> . equals ( handshakeAlgo ) ) { handshakeAlgo = <str> ; } else if ( <str> . equals ( handshakeAlgo ) ) { handshakeAlgo = <str> ; } handshakeAlgo = handshakeAlgo . replace ( <str> , <str> ) ; if ( export ) { return handshakeAlgo + <str> ; } else { return handshakeAlgo ; } } private static String toJavaBulkCipher ( String bulkCipher , boolean export ) { if ( bulkCipher . startsWith ( <str> ) ) { Matcher m = OPENSSL_AES_CBC_PATTERN . matcher ( bulkCipher ) ; if ( m . matches ( ) ) { return m . replaceFirst ( <str> ) ; } m = OPENSSL_AES_PATTERN . matcher ( bulkCipher ) ; if ( m . matches ( ) ) { return m . replaceFirst ( <str> ) ; } } if ( <str> . equals ( bulkCipher ) ) { return <str> ; } if ( <str> . equals ( bulkCipher ) ) { if ( export ) { return <str> ; } else { return <str> ; } } if ( <str> . equals ( bulkCipher ) ) { if ( export ) { return <str> ; } else { return <str> ; } } if ( <str> . equals ( bulkCipher ) ) { if ( export ) { return <str> ; } else { return <str> ; } } return bulkCipher . replace ( <str> , <str> ) ; } private static String toJavaHmacAlgo ( String hmacAlgo ) { return hmacAlgo ; } private CipherSuiteConverter ( ) { } } 
