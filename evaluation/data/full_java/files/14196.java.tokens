package org . gradle . messaging . remote . internal . inet ; import org . gradle . messaging . remote . internal . Connection ; import org . gradle . messaging . remote . internal . MessageIOException ; import org . gradle . messaging . remote . internal . MessageSerializer ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . net . * ; public class MulticastConnection < T > implements Connection < T > { private static final Logger LOGGER = LoggerFactory . getLogger ( MulticastConnection . class ) ; private static final int MAX_MESSAGE_SIZE = <int> * <int> ; private final MulticastSocket socket ; private final SocketInetAddress address ; private final MessageSerializer < T > serializer ; private final SocketInetAddress localAddress ; public MulticastConnection ( SocketInetAddress address , MessageSerializer < T > serializer , InetAddressFactory addressFactory ) { this . address = address ; this . serializer = serializer ; try { socket = new MulticastSocket ( address . getPort ( ) ) ; boolean bound = false ; SocketException bindFailure = null ; for ( NetworkInterface networkInterface : addressFactory . findMulticastInterfaces ( ) ) { try { socket . joinGroup ( new InetSocketAddress ( address . getAddress ( ) , address . getPort ( ) ) , networkInterface ) ; LOGGER . debug ( <str> , address , networkInterface . getDisplayName ( ) ) ; bound = true ; } catch ( SocketException e ) { LOGGER . debug ( <str> , address , networkInterface . getDisplayName ( ) ) ; if ( bindFailure = = null ) { bindFailure = e ; } } } if ( ! bound ) { throw bindFailure ; } } catch ( IOException e ) { throw new RuntimeException ( String . format ( <str> , address . getDisplayName ( ) ) , e ) ; } localAddress = new SocketInetAddress ( socket . getInetAddress ( ) , socket . getLocalPort ( ) ) ; } @Override public String toString ( ) { return String . format ( <str> , address ) ; } public void dispatch ( T message ) { try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; serializer . newWriter ( outputStream ) . write ( message ) ; outputStream . close ( ) ; byte [ ] buffer = outputStream . toByteArray ( ) ; socket . send ( new DatagramPacket ( buffer , buffer . length , address . getAddress ( ) , address . getPort ( ) ) ) ; } catch ( Exception e ) { throw new MessageIOException ( String . format ( <str> , address ) , e ) ; } } public T receive ( ) { try { byte [ ] buffer = new byte [ MAX_MESSAGE_SIZE ] ; DatagramPacket packet = new DatagramPacket ( buffer , <int> , buffer . length ) ; socket . receive ( packet ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( packet . getData ( ) , packet . getOffset ( ) , packet . getLength ( ) ) ; return serializer . newReader ( inputStream , localAddress , new SocketInetAddress ( packet . getAddress ( ) , packet . getPort ( ) ) ) . read ( ) ; } catch ( SocketException e ) { return null ; } catch ( Exception e ) { throw new MessageIOException ( String . format ( <str> , address ) , e ) ; } } public void requestStop ( ) { socket . close ( ) ; } public void stop ( ) { requestStop ( ) ; } } 
