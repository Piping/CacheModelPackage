package org . elasticsearch . script . mustache ; import com . github . mustachejava . Mustache ; import org . elasticsearch . SpecialPermission ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . FastStringReader ; import org . elasticsearch . common . io . UTF8StreamWriter ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptEngineService ; import org . elasticsearch . script . ScriptException ; import org . elasticsearch . script . SearchScript ; import org . elasticsearch . search . lookup . SearchLookup ; import java . lang . ref . SoftReference ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . Collections ; import java . util . Map ; public class MustacheScriptEngineService extends AbstractComponent implements ScriptEngineService { public static final String NAME = <str> ; private static ThreadLocal < SoftReference < UTF8StreamWriter > > utf8StreamWriter = new ThreadLocal < > ( ) ; private static UTF8StreamWriter utf8StreamWriter ( ) { SoftReference < UTF8StreamWriter > ref = utf8StreamWriter . get ( ) ; UTF8StreamWriter writer = ( ref = = null ) ? null : ref . get ( ) ; if ( writer = = null ) { writer = new UTF8StreamWriter ( <int> * <int> ) ; utf8StreamWriter . set ( new SoftReference < > ( writer ) ) ; } writer . reset ( ) ; return writer ; } @Inject public MustacheScriptEngineService ( Settings settings ) { super ( settings ) ; } @Override public Object compile ( String template ) { return ( new JsonEscapingMustacheFactory ( ) ) . compile ( new FastStringReader ( template ) , <str> ) ; } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return new String [ ] { NAME } ; } @Override public boolean sandboxed ( ) { return true ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , @Nullable Map < String , Object > vars ) { return new MustacheExecutableScript ( compiledScript , vars ) ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , @Nullable Map < String , Object > vars ) { throw new UnsupportedOperationException ( ) ; } @Override public void close ( ) { } @Override public void scriptRemoved ( CompiledScript script ) { } static final SpecialPermission SPECIAL_PERMISSION = new SpecialPermission ( ) ; private class MustacheExecutableScript implements ExecutableScript { private CompiledScript template ; private Map < String , Object > vars ; public MustacheExecutableScript ( CompiledScript template , Map < String , Object > vars ) { this . template = template ; this . vars = vars = = null ? Collections . < String , Object > emptyMap ( ) : vars ; } @Override public void setNextVar ( String name , Object value ) { this . vars . put ( name , value ) ; } @Override public Object run ( ) { final BytesStreamOutput result = new BytesStreamOutput ( ) ; try ( UTF8StreamWriter writer = utf8StreamWriter ( ) . setOutput ( result ) ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( SPECIAL_PERMISSION ) ; } AccessController . doPrivileged ( new PrivilegedAction < Void > ( ) { @Override public Void run ( ) { ( ( Mustache ) template . compiled ( ) ) . execute ( writer , vars ) ; return null ; } } ) ; } catch ( Exception e ) { logger . error ( <str> + template , e ) ; throw new ScriptException ( <str> + template , e ) ; } return result . bytes ( ) ; } @Override public Object unwrap ( Object value ) { return value ; } } } 
