package com . badlogic . gdx . tools . hiero . unicodefont ; import java . awt . AlphaComposite ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . font . FontRenderContext ; import java . awt . image . BufferedImage ; import java . awt . image . WritableRaster ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . IntBuffer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import org . lwjgl . opengl . GL11 ; import org . lwjgl . opengl . GL12 ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . tools . hiero . unicodefont . effects . ColorEffect ; import com . badlogic . gdx . tools . hiero . unicodefont . effects . Effect ; public class GlyphPage { private final UnicodeFont unicodeFont ; private final int pageWidth , pageHeight ; private final Texture texture ; private int pageX , pageY , rowHeight ; private boolean orderAscending ; private final List pageGlyphs = new ArrayList ( <int> ) ; GlyphPage ( UnicodeFont unicodeFont , int pageWidth , int pageHeight ) { this . unicodeFont = unicodeFont ; this . pageWidth = pageWidth ; this . pageHeight = pageHeight ; texture = new Texture ( pageWidth , pageHeight , Format . RGBA8888 ) ; } int loadGlyphs ( List glyphs , int maxGlyphsToLoad ) { if ( rowHeight ! = <int> & & maxGlyphsToLoad = = - <int> ) { int testX = pageX ; int testY = pageY ; int testRowHeight = rowHeight ; for ( Iterator iter = getIterator ( glyphs ) ; iter . hasNext ( ) ; ) { Glyph glyph = ( Glyph ) iter . next ( ) ; int width = glyph . getWidth ( ) ; int height = glyph . getHeight ( ) ; if ( testX + width > = pageWidth ) { testX = <int> ; testY + = testRowHeight ; testRowHeight = height ; } else if ( height > testRowHeight ) { testRowHeight = height ; } if ( testY + testRowHeight > = pageWidth ) return <int> ; testX + = width ; } } GL11 . glColor4f ( <int> , <int> , <int> , <int> ) ; texture . bind ( ) ; int i = <int> ; for ( Iterator iter = getIterator ( glyphs ) ; iter . hasNext ( ) ; ) { Glyph glyph = ( Glyph ) iter . next ( ) ; int width = Math . min ( MAX_GLYPH_SIZE , glyph . getWidth ( ) ) ; int height = Math . min ( MAX_GLYPH_SIZE , glyph . getHeight ( ) ) ; if ( rowHeight = = <int> ) { rowHeight = height ; } else { if ( pageX + width > = pageWidth ) { if ( pageY + rowHeight + height > = pageHeight ) break ; pageX = <int> ; pageY + = rowHeight ; rowHeight = height ; } else if ( height > rowHeight ) { if ( pageY + height > = pageHeight ) break ; rowHeight = height ; } } renderGlyph ( glyph , width , height ) ; pageGlyphs . add ( glyph ) ; pageX + = width ; iter . remove ( ) ; i + + ; if ( i = = maxGlyphsToLoad ) { orderAscending = ! orderAscending ; break ; } } orderAscending = ! orderAscending ; return i ; } private void renderGlyph ( Glyph glyph , int width , int height ) { scratchGraphics . setComposite ( AlphaComposite . Clear ) ; scratchGraphics . fillRect ( <int> , <int> , MAX_GLYPH_SIZE , MAX_GLYPH_SIZE ) ; scratchGraphics . setComposite ( AlphaComposite . SrcOver ) ; if ( unicodeFont . getNativeRendering ( ) ) { for ( Iterator iter = unicodeFont . getEffects ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Effect effect = ( Effect ) iter . next ( ) ; if ( effect instanceof ColorEffect ) scratchGraphics . setColor ( ( ( ColorEffect ) effect ) . getColor ( ) ) ; } scratchGraphics . setColor ( java . awt . Color . white ) ; scratchGraphics . setFont ( unicodeFont . getFont ( ) ) ; scratchGraphics . drawString ( <str> + ( char ) glyph . getCodePoint ( ) , <int> , unicodeFont . getAscent ( ) ) ; } else { scratchGraphics . setColor ( java . awt . Color . white ) ; for ( Iterator iter = unicodeFont . getEffects ( ) . iterator ( ) ; iter . hasNext ( ) ; ) ( ( Effect ) iter . next ( ) ) . draw ( scratchImage , scratchGraphics , unicodeFont , glyph ) ; glyph . setShape ( null ) ; } width = Math . min ( width , texture . getWidth ( ) ) ; height = Math . min ( height , texture . getHeight ( ) ) ; WritableRaster raster = scratchImage . getRaster ( ) ; int [ ] row = new int [ width ] ; for ( int y = <int> ; y < height ; y + + ) { raster . getDataElements ( <int> , y , width , <int> , row ) ; scratchIntBuffer . put ( row ) ; } GL11 . glTexSubImage2D ( GL11 . GL_TEXTURE_2D , <int> , pageX , pageY , width , height , GL12 . GL_BGRA , GL11 . GL_UNSIGNED_BYTE , scratchByteBuffer ) ; scratchIntBuffer . clear ( ) ; float u = pageX / ( float ) texture . getWidth ( ) ; float v = pageY / ( float ) texture . getHeight ( ) ; float u2 = ( pageX + width ) / ( float ) texture . getWidth ( ) ; float v2 = ( pageY + height ) / ( float ) texture . getHeight ( ) ; glyph . setTexture ( texture , u , v , u2 , v2 ) ; } private Iterator getIterator ( List glyphs ) { if ( orderAscending ) return glyphs . iterator ( ) ; final ListIterator iter = glyphs . listIterator ( glyphs . size ( ) ) ; return new Iterator ( ) { public boolean hasNext ( ) { return iter . hasPrevious ( ) ; } public Object next ( ) { return iter . previous ( ) ; } public void remove ( ) { iter . remove ( ) ; } } ; } public List getGlyphs ( ) { return pageGlyphs ; } public Texture getTexture ( ) { return texture ; } static public final int MAX_GLYPH_SIZE = <int> ; static private ByteBuffer scratchByteBuffer = ByteBuffer . allocateDirect ( MAX_GLYPH_SIZE * MAX_GLYPH_SIZE * <int> ) ; static { scratchByteBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; } static private IntBuffer scratchIntBuffer = scratchByteBuffer . asIntBuffer ( ) ; static private BufferedImage scratchImage = new BufferedImage ( MAX_GLYPH_SIZE , MAX_GLYPH_SIZE , BufferedImage . TYPE_INT_ARGB ) ; static Graphics2D scratchGraphics = ( Graphics2D ) scratchImage . getGraphics ( ) ; static { scratchGraphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; scratchGraphics . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; } static public FontRenderContext renderContext = scratchGraphics . getFontRenderContext ( ) ; } 
