package org . elasticsearch . index . mapper . ip ; import org . apache . lucene . analysis . NumericTokenStream ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . search . NumericRangeQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Numbers ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . network . Cidrs ; import org . elasticsearch . common . network . InetAddresses ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . analysis . NumericAnalyzer ; import org . elasticsearch . index . analysis . NumericTokenizer ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . index . mapper . core . LongFieldMapper . CustomLongNumericField ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . search . aggregations . bucket . range . ipv4 . InternalIPv4Range ; import java . io . IOException ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static org . elasticsearch . index . mapper . MapperBuilders . ipField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseNumberField ; public class IpFieldMapper extends NumberFieldMapper { public static final String CONTENT_TYPE = <str> ; public static final long MAX_IP = <int> ; public static String longToIp ( long longIp ) { int octet3 = ( int ) ( ( longIp > > <int> ) % <int> ) ; int octet2 = ( int ) ( ( longIp > > <int> ) % <int> ) ; int octet1 = ( int ) ( ( longIp > > <int> ) % <int> ) ; int octet0 = ( int ) ( ( longIp ) % <int> ) ; return octet3 + <str> + octet2 + <str> + octet1 + <str> + octet0 ; } private static final Pattern pattern = Pattern . compile ( <str> ) ; public static long ipToLong ( String ip ) { try { if ( ! InetAddresses . isInetAddress ( ip ) ) { throw new IllegalArgumentException ( <str> + ip + <str> ) ; } String [ ] octets = pattern . split ( ip ) ; if ( octets . length ! = <int> ) { throw new IllegalArgumentException ( <str> + ip + <str> ) ; } return ( Long . parseLong ( octets [ <int> ] ) < < <int> ) + ( Integer . parseInt ( octets [ <int> ] ) < < <int> ) + ( Integer . parseInt ( octets [ <int> ] ) < < <int> ) + Integer . parseInt ( octets [ <int> ] ) ; } catch ( Exception e ) { if ( e instanceof IllegalArgumentException ) { throw ( IllegalArgumentException ) e ; } throw new IllegalArgumentException ( <str> + ip + <str> , e ) ; } } public static class Defaults extends NumberFieldMapper . Defaults { public static final String NULL_VALUE = null ; public static final MappedFieldType FIELD_TYPE = new IpFieldType ( ) ; static { FIELD_TYPE . freeze ( ) ; } } public static class Builder extends NumberFieldMapper . Builder < Builder , IpFieldMapper > { protected String nullValue = Defaults . NULL_VALUE ; public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE , Defaults . PRECISION_STEP_64_BIT ) ; builder = this ; } @Override public IpFieldMapper build ( BuilderContext context ) { setupFieldType ( context ) ; IpFieldMapper fieldMapper = new IpFieldMapper ( name , fieldType , defaultFieldType , ignoreMalformed ( context ) , coerce ( context ) , context . indexSettings ( ) , multiFieldsBuilder . build ( this , context ) , copyTo ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } @Override protected NamedAnalyzer makeNumberAnalyzer ( int precisionStep ) { String name = precisionStep = = Integer . MAX_VALUE ? <str> : ( <str> + precisionStep ) ; return new NamedAnalyzer ( name , new NumericIpAnalyzer ( precisionStep ) ) ; } @Override protected int maxPrecisionStep ( ) { return <int> ; } } public static class TypeParser implements Mapper . TypeParser { @Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { IpFieldMapper . Builder builder = ipField ( name ) ; parseNumberField ( builder , name , node , parserContext ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { if ( propNode = = null ) { throw new MapperParsingException ( <str> ) ; } builder . nullValue ( propNode . toString ( ) ) ; iterator . remove ( ) ; } } return builder ; } } public static final class IpFieldType extends LongFieldMapper . LongFieldType { public IpFieldType ( ) { setFieldDataType ( new FieldDataType ( <str> ) ) ; } protected IpFieldType ( IpFieldType ref ) { super ( ref ) ; } @Override public NumberFieldType clone ( ) { return new IpFieldType ( this ) ; } @Override public String typeName ( ) { return CONTENT_TYPE ; } @Override public Long value ( Object value ) { if ( value = = null ) { return null ; } if ( value instanceof Number ) { return ( ( Number ) value ) . longValue ( ) ; } if ( value instanceof BytesRef ) { return Numbers . bytesToLong ( ( BytesRef ) value ) ; } return ipToLong ( value . toString ( ) ) ; } @Override public Object valueForSearch ( Object value ) { Long val = value ( value ) ; if ( val = = null ) { return null ; } return longToIp ( val ) ; } @Override public BytesRef indexedValueForSearch ( Object value ) { BytesRefBuilder bytesRef = new BytesRefBuilder ( ) ; NumericUtils . longToPrefixCoded ( parseValue ( value ) , <int> , bytesRef ) ; return bytesRef . get ( ) ; } @Override public Query termQuery ( Object value , @Nullable QueryShardContext context ) { if ( value ! = null ) { long [ ] fromTo ; if ( value instanceof BytesRef ) { fromTo = Cidrs . cidrMaskToMinMax ( ( ( BytesRef ) value ) . utf8ToString ( ) ) ; } else { fromTo = Cidrs . cidrMaskToMinMax ( value . toString ( ) ) ; } if ( fromTo ! = null ) { return rangeQuery ( fromTo [ <int> ] = = <int> ? null : fromTo [ <int> ] , fromTo [ <int> ] = = InternalIPv4Range . MAX_IP ? null : fromTo [ <int> ] , true , false ) ; } } return super . termQuery ( value , context ) ; } @Override public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper ) { return NumericRangeQuery . newLongRange ( names ( ) . indexName ( ) , numericPrecisionStep ( ) , lowerTerm = = null ? null : parseValue ( lowerTerm ) , upperTerm = = null ? null : parseValue ( upperTerm ) , includeLower , includeUpper ) ; } @Override public Query fuzzyQuery ( Object value , Fuzziness fuzziness , int prefixLength , int maxExpansions , boolean transpositions ) { long iValue = parseValue ( value ) ; long iSim ; try { iSim = ipToLong ( fuzziness . asString ( ) ) ; } catch ( IllegalArgumentException e ) { iSim = fuzziness . asLong ( ) ; } return NumericRangeQuery . newLongRange ( names ( ) . indexName ( ) , numericPrecisionStep ( ) , iValue - iSim , iValue + iSim , true , true ) ; } } protected IpFieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Explicit < Boolean > ignoreMalformed , Explicit < Boolean > coerce , Settings indexSettings , MultiFields multiFields , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , ignoreMalformed , coerce , indexSettings , multiFields , copyTo ) ; } private static long parseValue ( Object value ) { if ( value instanceof Number ) { return ( ( Number ) value ) . longValue ( ) ; } if ( value instanceof BytesRef ) { return ipToLong ( ( ( BytesRef ) value ) . utf8ToString ( ) ) ; } return ipToLong ( value . toString ( ) ) ; } @Override protected void innerParseCreateField ( ParseContext context , List < Field > fields ) throws IOException { String ipAsString ; if ( context . externalValueSet ( ) ) { ipAsString = ( String ) context . externalValue ( ) ; if ( ipAsString = = null ) { ipAsString = fieldType ( ) . nullValueAsString ( ) ; } } else { if ( context . parser ( ) . currentToken ( ) = = XContentParser . Token . VALUE_NULL ) { ipAsString = fieldType ( ) . nullValueAsString ( ) ; } else { ipAsString = context . parser ( ) . text ( ) ; } } if ( ipAsString = = null ) { return ; } if ( context . includeInAll ( includeInAll , this ) ) { context . allEntries ( ) . addText ( fieldType ( ) . names ( ) . fullName ( ) , ipAsString , fieldType ( ) . boost ( ) ) ; } final long value = ipToLong ( ipAsString ) ; if ( fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE | | fieldType ( ) . stored ( ) ) { CustomLongNumericField field = new CustomLongNumericField ( value , fieldType ( ) ) ; field . setBoost ( fieldType ( ) . boost ( ) ) ; fields . add ( field ) ; } if ( fieldType ( ) . hasDocValues ( ) ) { addDocValue ( context , fields , value ) ; } } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { super . doXContentBody ( builder , includeDefaults , params ) ; if ( includeDefaults | | fieldType ( ) . numericPrecisionStep ( ) ! = Defaults . PRECISION_STEP_64_BIT ) { builder . field ( <str> , fieldType ( ) . numericPrecisionStep ( ) ) ; } if ( includeDefaults | | fieldType ( ) . nullValueAsString ( ) ! = null ) { builder . field ( <str> , fieldType ( ) . nullValueAsString ( ) ) ; } if ( includeInAll ! = null ) { builder . field ( <str> , includeInAll ) ; } else if ( includeDefaults ) { builder . field ( <str> , false ) ; } } public static class NumericIpAnalyzer extends NumericAnalyzer < NumericIpTokenizer > { private final int precisionStep ; public NumericIpAnalyzer ( int precisionStep ) { this . precisionStep = precisionStep ; } @Override protected NumericIpTokenizer createNumericTokenizer ( char [ ] buffer ) throws IOException { return new NumericIpTokenizer ( precisionStep , buffer ) ; } } public static class NumericIpTokenizer extends NumericTokenizer { public NumericIpTokenizer ( int precisionStep , char [ ] buffer ) throws IOException { super ( new NumericTokenStream ( precisionStep ) , buffer , null ) ; } @Override protected void setValue ( NumericTokenStream tokenStream , String value ) { tokenStream . setLongValue ( ipToLong ( value ) ) ; } } } 
