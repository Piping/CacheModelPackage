package org . gradle . build . docs . dsl . docbook ; import org . gradle . build . docs . dsl . source . TypeNameResolver ; import org . gradle . build . docs . dsl . source . model . ClassMetaData ; import org . gradle . build . docs . dsl . source . model . MethodMetaData ; import org . gradle . build . docs . dsl . source . model . TypeMetaData ; import org . gradle . build . docs . model . ClassMetaDataRepository ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class JavadocLinkConverter { private static final Pattern LINK_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern TYPE_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern PARAM_DELIMITER = Pattern . compile ( <str> ) ; private final Document document ; private final TypeNameResolver typeNameResolver ; private final LinkRenderer linkRenderer ; private final ClassMetaDataRepository < ClassMetaData > repository ; public JavadocLinkConverter ( Document document , TypeNameResolver typeNameResolver , LinkRenderer linkRenderer , ClassMetaDataRepository < ClassMetaData > repository ) { this . document = document ; this . typeNameResolver = typeNameResolver ; this . linkRenderer = linkRenderer ; this . repository = repository ; } public Node resolve ( String link , ClassMetaData classMetaData , GenerationListener listener ) { Node node = doResolve ( link , classMetaData , listener ) ; if ( node ! = null ) { return node ; } listener . warning ( String . format ( <str> , link ) ) ; Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( link ) ) ; return element ; } private Node doResolve ( String link , ClassMetaData classMetaData , GenerationListener listener ) { Matcher matcher = LINK_PATTERN . matcher ( link ) ; if ( ! matcher . matches ( ) ) { return null ; } String className = null ; if ( matcher . group ( <int> ) . length ( ) > <int> ) { className = typeNameResolver . resolve ( matcher . group ( <int> ) , classMetaData ) ; if ( className = = null ) { return null ; } } if ( matcher . group ( <int> ) = = null ) { return linkRenderer . link ( new TypeMetaData ( className ) , listener ) ; } ClassMetaData targetClass ; if ( className ! = null ) { targetClass = repository . find ( className ) ; if ( targetClass = = null ) { return null ; } } else { targetClass = classMetaData ; } String methodSignature = matcher . group ( <int> ) ; if ( matcher . group ( <int> ) ! = null ) { StringBuilder signature = new StringBuilder ( ) ; signature . append ( methodSignature ) ; signature . append ( <str> ) ; if ( matcher . group ( <int> ) . length ( ) > <int> ) { String [ ] types = PARAM_DELIMITER . split ( matcher . group ( <int> ) ) ; for ( int i = <int> ; i < types . length ; i + + ) { String type = types [ i ] ; Matcher typeMatcher = TYPE_PATTERN . matcher ( type ) ; if ( ! typeMatcher . matches ( ) ) { return null ; } if ( i > <int> ) { signature . append ( <str> ) ; } signature . append ( typeNameResolver . resolve ( typeMatcher . group ( <int> ) , classMetaData ) ) ; String suffix = typeMatcher . group ( <int> ) ; if ( suffix . equals ( <str> ) ) { suffix = <str> ; } signature . append ( suffix ) ; } } signature . append ( <str> ) ; methodSignature = signature . toString ( ) ; } if ( targetClass . isEnum ( ) & & targetClass . getEnumConstant ( methodSignature ) ! = null ) { return linkRenderer . link ( targetClass . getEnumConstant ( methodSignature ) , listener ) ; } MethodMetaData method = findMethod ( methodSignature , targetClass ) ; if ( method = = null ) { return null ; } return linkRenderer . link ( method , listener ) ; } private MethodMetaData findMethod ( String name , ClassMetaData targetClass ) { List < MethodMetaData > candidates = new ArrayList < MethodMetaData > ( ) ; for ( MethodMetaData methodMetaData : targetClass . getDeclaredMethods ( ) ) { if ( name . equals ( methodMetaData . getOverrideSignature ( ) ) ) { return methodMetaData ; } if ( name . equals ( methodMetaData . getName ( ) ) ) { candidates . add ( methodMetaData ) ; } } if ( candidates . size ( ) ! = <int> ) { return null ; } return candidates . get ( <int> ) ; } public Node resolveValue ( String fieldName , ClassMetaData classMetaData , GenerationListener listener ) { String [ ] parts = fieldName . split ( <str> ) ; ClassMetaData targetClass ; if ( parts [ <int> ] . length ( ) > <int> ) { String targetClassName = typeNameResolver . resolve ( parts [ <int> ] , classMetaData ) ; targetClass = repository . find ( targetClassName ) ; if ( targetClass = = null ) { listener . warning ( String . format ( <str> , targetClass , fieldName ) ) ; Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( targetClassName + <str> + parts [ <int> ] ) ) ; return element ; } } else { targetClass = classMetaData ; } String value = targetClass . getConstants ( ) . get ( parts [ <int> ] ) ; if ( value = = null ) { listener . warning ( String . format ( <str> , fieldName ) ) ; Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( targetClass . getClassName ( ) + <str> + parts [ <int> ] ) ) ; return element ; } return createLiteralNode ( value ) ; } private Node createLiteralNode ( String value ) { Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( value ) ) ; return element ; } } 
