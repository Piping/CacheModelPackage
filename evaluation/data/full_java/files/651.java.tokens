package org . apache . cassandra . index . internal . composites ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . IndexEntry ; import org . apache . cassandra . schema . IndexMetadata ; public class ClusteringColumnIndex extends CassandraIndex { public ClusteringColumnIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexDef ) { super ( baseCfs , indexDef ) ; } public ByteBuffer getIndexedValue ( ByteBuffer partitionKey , Clustering clustering , CellPath path , ByteBuffer cellValue ) { return clustering . get ( indexedColumn . position ( ) ) ; } public CBuilder buildIndexClusteringPrefix ( ByteBuffer partitionKey , ClusteringPrefix prefix , CellPath path ) { CBuilder builder = CBuilder . create ( getIndexComparator ( ) ) ; builder . add ( partitionKey ) ; for ( int i = <int> ; i < Math . min ( indexedColumn . position ( ) , prefix . size ( ) ) ; i + + ) builder . add ( prefix . get ( i ) ) ; for ( int i = indexedColumn . position ( ) + <int> ; i < prefix . size ( ) ; i + + ) builder . add ( prefix . get ( i ) ) ; return builder ; } public IndexEntry decodeEntry ( DecoratedKey indexedValue , Row indexEntry ) { int ckCount = baseCfs . metadata . clusteringColumns ( ) . size ( ) ; Clustering clustering = indexEntry . clustering ( ) ; CBuilder builder = CBuilder . create ( baseCfs . getComparator ( ) ) ; for ( int i = <int> ; i < indexedColumn . position ( ) ; i + + ) builder . add ( clustering . get ( i + <int> ) ) ; builder . add ( indexedValue . getKey ( ) ) ; for ( int i = indexedColumn . position ( ) + <int> ; i < ckCount ; i + + ) builder . add ( clustering . get ( i ) ) ; return new IndexEntry ( indexedValue , clustering , indexEntry . primaryKeyLivenessInfo ( ) . timestamp ( ) , clustering . get ( <int> ) , builder . build ( ) ) ; } public boolean isStale ( Row data , ByteBuffer indexValue , int nowInSec ) { return ! data . hasLiveData ( nowInSec ) ; } } 
