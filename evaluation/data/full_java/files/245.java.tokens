package org . apache . cassandra . cql3 . statements ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . locator . LocalStrategy ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . * ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . Event ; public class CreateKeyspaceStatement extends SchemaAlteringStatement { private final String name ; private final KeyspaceAttributes attrs ; private final boolean ifNotExists ; public CreateKeyspaceStatement ( String name , KeyspaceAttributes attrs , boolean ifNotExists ) { super ( ) ; this . name = name ; this . attrs = attrs ; this . ifNotExists = ifNotExists ; } @Override public String keyspace ( ) { return name ; } public void checkAccess ( ClientState state ) throws UnauthorizedException { state . hasAllKeyspacesAccess ( Permission . CREATE ) ; } public void validate ( ClientState state ) throws RequestValidationException { ThriftValidation . validateKeyspaceNotSystem ( name ) ; if ( ! name . matches ( <str> ) ) throw new InvalidRequestException ( String . format ( <str> , name ) ) ; if ( name . length ( ) > Schema . NAME_LENGTH ) throw new InvalidRequestException ( String . format ( <str> , Schema . NAME_LENGTH , name ) ) ; attrs . validate ( ) ; if ( attrs . getReplicationStrategyClass ( ) = = null ) throw new ConfigurationException ( <str> ) ; KeyspaceParams params = attrs . asNewKeyspaceParams ( ) ; params . validate ( name ) ; if ( params . replication . klass . equals ( LocalStrategy . class ) ) throw new ConfigurationException ( <str> ) ; } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { KeyspaceMetadata ksm = KeyspaceMetadata . create ( name , attrs . asNewKeyspaceParams ( ) ) ; try { MigrationManager . announceNewKeyspace ( ksm , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , keyspace ( ) ) ; } catch ( AlreadyExistsException e ) { if ( ifNotExists ) return null ; throw e ; } } protected void grantPermissionsToCreator ( QueryState state ) { try { RoleResource role = RoleResource . role ( state . getClientState ( ) . getUser ( ) . getName ( ) ) ; DataResource keyspace = DataResource . keyspace ( keyspace ( ) ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , keyspace . applicablePermissions ( ) , keyspace , role ) ; FunctionResource functions = FunctionResource . keyspace ( keyspace ( ) ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , functions . applicablePermissions ( ) , functions , role ) ; } catch ( RequestExecutionException e ) { throw new RuntimeException ( e ) ; } } } 
