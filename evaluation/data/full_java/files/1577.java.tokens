package org . apache . cassandra . io . util ; import java . io . EOFException ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . Arrays ; import java . util . concurrent . ThreadLocalRandom ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . utils . memory . MemoryUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class MemoryTest { @Test public void testByteBuffers ( ) { byte [ ] bytes = new byte [ <int> ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; final Memory memory = Memory . allocate ( bytes . length ) ; memory . setBytes ( <int> , bytes , <int> , bytes . length ) ; ByteBuffer canon = ByteBuffer . wrap ( bytes ) . order ( ByteOrder . nativeOrder ( ) ) ; test ( canon , memory ) ; memory . setBytes ( <int> , new byte [ <int> ] , <int> , <int> ) ; memory . setBytes ( <int> , canon . duplicate ( ) ) ; test ( canon , memory ) ; memory . close ( ) ; } @Test public void testInputStream ( ) throws IOException { byte [ ] bytes = new byte [ <int> ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; final Memory memory = Memory . allocate ( bytes . length ) ; memory . setBytes ( <int> , bytes , <int> , bytes . length ) ; try ( MemoryInputStream stream = new MemoryInputStream ( memory , <int> ) ) { byte [ ] bb = new byte [ bytes . length ] ; assertEquals ( bytes . length , stream . available ( ) ) ; stream . readFully ( bb ) ; assertEquals ( <int> , stream . available ( ) ) ; assertTrue ( Arrays . equals ( bytes , bb ) ) ; try { stream . readInt ( ) ; fail ( <str> ) ; } catch ( EOFException e ) { } } } private static void test ( ByteBuffer canon , Memory memory ) { ByteBuffer hollow = MemoryUtil . getHollowDirectByteBuffer ( ) ; test ( canon , hollow , memory , <int> , <int> ) ; test ( canon , hollow , memory , <int> , <int> ) ; test ( canon , hollow , memory , <int> , <int> ) ; test ( canon , hollow , memory , <int> , <int> ) ; } private static void test ( ByteBuffer canon , ByteBuffer hollow , Memory memory , int offset , int length ) { canon = canon . duplicate ( ) ; canon . position ( offset ) . limit ( offset + length ) ; canon = canon . slice ( ) . order ( ByteOrder . nativeOrder ( ) ) ; test ( canon , memory . asByteBuffer ( offset , length ) ) ; memory . setByteBuffer ( hollow , offset , length ) ; test ( canon , hollow ) ; } private static void test ( ByteBuffer canon , ByteBuffer test ) { Assert . assertEquals ( canon , test ) ; for ( int i = <int> ; i < = canon . limit ( ) - <int> ; i + = <int> ) Assert . assertEquals ( canon . getInt ( i ) , test . getInt ( i ) ) ; for ( int i = <int> ; i < = canon . limit ( ) - <int> ; i + = <int> ) Assert . assertEquals ( canon . getLong ( i ) , test . getLong ( i ) ) ; } } 
