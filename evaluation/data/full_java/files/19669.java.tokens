package io . netty . util . concurrent ; import io . netty . util . internal . StringUtil ; import java . util . Locale ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; public class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolId = new AtomicInteger ( ) ; private final AtomicInteger nextId = new AtomicInteger ( ) ; private final String prefix ; private final boolean daemon ; private final int priority ; public DefaultThreadFactory ( Class < ? > poolType ) { this ( poolType , false , Thread . NORM_PRIORITY ) ; } public DefaultThreadFactory ( String poolName ) { this ( poolName , false , Thread . NORM_PRIORITY ) ; } public DefaultThreadFactory ( Class < ? > poolType , boolean daemon ) { this ( poolType , daemon , Thread . NORM_PRIORITY ) ; } public DefaultThreadFactory ( String poolName , boolean daemon ) { this ( poolName , daemon , Thread . NORM_PRIORITY ) ; } public DefaultThreadFactory ( Class < ? > poolType , int priority ) { this ( poolType , false , priority ) ; } public DefaultThreadFactory ( String poolName , int priority ) { this ( poolName , false , priority ) ; } public DefaultThreadFactory ( Class < ? > poolType , boolean daemon , int priority ) { this ( toPoolName ( poolType ) , daemon , priority ) ; } private static String toPoolName ( Class < ? > poolType ) { if ( poolType = = null ) { throw new NullPointerException ( <str> ) ; } String poolName = StringUtil . simpleClassName ( poolType ) ; switch ( poolName . length ( ) ) { case <int> : return <str> ; case <int> : return poolName . toLowerCase ( Locale . US ) ; default : if ( Character . isUpperCase ( poolName . charAt ( <int> ) ) & & Character . isLowerCase ( poolName . charAt ( <int> ) ) ) { return Character . toLowerCase ( poolName . charAt ( <int> ) ) + poolName . substring ( <int> ) ; } else { return poolName ; } } } public DefaultThreadFactory ( String poolName , boolean daemon , int priority ) { if ( poolName = = null ) { throw new NullPointerException ( <str> ) ; } if ( priority < Thread . MIN_PRIORITY | | priority > Thread . MAX_PRIORITY ) { throw new IllegalArgumentException ( <str> + priority + <str> ) ; } prefix = poolName + <str> + poolId . incrementAndGet ( ) + <str> ; this . daemon = daemon ; this . priority = priority ; } @Override public Thread newThread ( Runnable r ) { Thread t = newThread ( new DefaultRunnableDecorator ( r ) , prefix + nextId . incrementAndGet ( ) ) ; try { if ( t . isDaemon ( ) ) { if ( ! daemon ) { t . setDaemon ( false ) ; } } else { if ( daemon ) { t . setDaemon ( true ) ; } } if ( t . getPriority ( ) ! = priority ) { t . setPriority ( priority ) ; } } catch ( Exception ignored ) { } return t ; } protected Thread newThread ( Runnable r , String name ) { return new FastThreadLocalThread ( r , name ) ; } private static final class DefaultRunnableDecorator implements Runnable { private final Runnable r ; DefaultRunnableDecorator ( Runnable r ) { this . r = r ; } @Override public void run ( ) { try { r . run ( ) ; } finally { FastThreadLocal . removeAll ( ) ; } } } } 
