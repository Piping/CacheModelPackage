package io . netty . handler . codec . memcache ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . FileRegion ; import io . netty . handler . codec . MessageToMessageEncoder ; import io . netty . util . internal . StringUtil ; import java . util . List ; public abstract class AbstractMemcacheObjectEncoder < M extends MemcacheMessage > extends MessageToMessageEncoder < Object > { private boolean expectingMoreContent ; @Override protected void encode ( ChannelHandlerContext ctx , Object msg , List < Object > out ) throws Exception { if ( msg instanceof MemcacheMessage ) { if ( expectingMoreContent ) { throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } @SuppressWarnings ( { <str> , <str> } ) final M m = ( M ) msg ; out . add ( encodeMessage ( ctx , m ) ) ; return ; } if ( msg instanceof MemcacheContent | | msg instanceof ByteBuf | | msg instanceof FileRegion ) { int contentLength = contentLength ( msg ) ; if ( contentLength > <int> ) { out . add ( encodeAndRetain ( msg ) ) ; } else { out . add ( Unpooled . EMPTY_BUFFER ) ; } expectingMoreContent = ! ( msg instanceof LastMemcacheContent ) ; } } @Override public boolean acceptOutboundMessage ( Object msg ) throws Exception { return msg instanceof MemcacheObject | | msg instanceof ByteBuf | | msg instanceof FileRegion ; } protected abstract ByteBuf encodeMessage ( ChannelHandlerContext ctx , M msg ) ; private static int contentLength ( Object msg ) { if ( msg instanceof MemcacheContent ) { return ( ( MemcacheContent ) msg ) . content ( ) . readableBytes ( ) ; } if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . readableBytes ( ) ; } if ( msg instanceof FileRegion ) { return ( int ) ( ( FileRegion ) msg ) . count ( ) ; } throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } private static Object encodeAndRetain ( Object msg ) { if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . retain ( ) ; } if ( msg instanceof MemcacheContent ) { return ( ( MemcacheContent ) msg ) . content ( ) . retain ( ) ; } if ( msg instanceof FileRegion ) { return ( ( FileRegion ) msg ) . retain ( ) ; } throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } } 
