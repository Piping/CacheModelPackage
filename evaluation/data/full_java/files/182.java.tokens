package org . apache . cassandra . cql3 . functions ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import static java . util . stream . Collectors . joining ; public final class FunctionResolver { private FunctionResolver ( ) { } private static final FunctionName TOKEN_FUNCTION_NAME = FunctionName . nativeFunction ( <str> ) ; public static ColumnSpecification makeArgSpec ( String receiverKs , String receiverCf , Function fun , int i ) { return new ColumnSpecification ( receiverKs , receiverCf , new ColumnIdentifier ( <str> + i + <str> + fun . name ( ) . toString ( ) . toLowerCase ( ) + <str> , true ) , fun . argTypes ( ) . get ( i ) ) ; } public static Function get ( String keyspace , FunctionName name , List < ? extends AssignmentTestable > providedArgs , String receiverKs , String receiverCf , AbstractType < ? > receiverType ) throws InvalidRequestException { if ( name . equalsNativeFunction ( TOKEN_FUNCTION_NAME ) ) return new TokenFct ( Schema . instance . getCFMetaData ( receiverKs , receiverCf ) ) ; if ( name . equalsNativeFunction ( ToJsonFct . NAME ) ) throw new InvalidRequestException ( <str> ) ; if ( name . equalsNativeFunction ( FromJsonFct . NAME ) ) { if ( receiverType = = null ) throw new InvalidRequestException ( <str> ) ; return FromJsonFct . getInstance ( receiverType ) ; } Collection < Function > candidates ; if ( ! name . hasKeyspace ( ) ) { candidates = new ArrayList < > ( ) ; candidates . addAll ( Schema . instance . getFunctions ( name . asNativeFunction ( ) ) ) ; candidates . addAll ( Schema . instance . getFunctions ( new FunctionName ( keyspace , name . name ) ) ) ; } else { candidates = Schema . instance . getFunctions ( name ) ; } if ( candidates . isEmpty ( ) ) return null ; if ( candidates . size ( ) = = <int> ) { Function fun = candidates . iterator ( ) . next ( ) ; validateTypes ( keyspace , fun , providedArgs , receiverKs , receiverCf ) ; return fun ; } List < Function > compatibles = null ; for ( Function toTest : candidates ) { AssignmentTestable . TestResult r = matchAguments ( keyspace , toTest , providedArgs , receiverKs , receiverCf ) ; switch ( r ) { case EXACT_MATCH : return toTest ; case WEAKLY_ASSIGNABLE : if ( compatibles = = null ) compatibles = new ArrayList < > ( ) ; compatibles . add ( toTest ) ; break ; } } if ( compatibles = = null ) { throw new InvalidRequestException ( String . format ( <str> , name , format ( candidates ) ) ) ; } if ( compatibles . size ( ) > <int> ) throw new InvalidRequestException ( String . format ( <str> , name , format ( compatibles ) ) ) ; return compatibles . get ( <int> ) ; } private static void validateTypes ( String keyspace , Function fun , List < ? extends AssignmentTestable > providedArgs , String receiverKs , String receiverCf ) throws InvalidRequestException { if ( providedArgs . size ( ) ! = fun . argTypes ( ) . size ( ) ) throw new InvalidRequestException ( String . format ( <str> , fun . name ( ) , fun . argTypes ( ) . size ( ) , providedArgs . size ( ) ) ) ; for ( int i = <int> ; i < providedArgs . size ( ) ; i + + ) { AssignmentTestable provided = providedArgs . get ( i ) ; if ( provided = = null ) continue ; ColumnSpecification expected = makeArgSpec ( receiverKs , receiverCf , fun , i ) ; if ( ! provided . testAssignment ( keyspace , expected ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , provided , i , fun . name ( ) , expected . type . asCQL3Type ( ) ) ) ; } } private static AssignmentTestable . TestResult matchAguments ( String keyspace , Function fun , List < ? extends AssignmentTestable > providedArgs , String receiverKs , String receiverCf ) { if ( providedArgs . size ( ) ! = fun . argTypes ( ) . size ( ) ) return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; AssignmentTestable . TestResult res = AssignmentTestable . TestResult . EXACT_MATCH ; for ( int i = <int> ; i < providedArgs . size ( ) ; i + + ) { AssignmentTestable provided = providedArgs . get ( i ) ; if ( provided = = null ) { res = AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; continue ; } ColumnSpecification expected = makeArgSpec ( receiverKs , receiverCf , fun , i ) ; AssignmentTestable . TestResult argRes = provided . testAssignment ( keyspace , expected ) ; if ( argRes = = AssignmentTestable . TestResult . NOT_ASSIGNABLE ) return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; if ( argRes = = AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ) res = AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; } return res ; } private static String format ( Collection < Function > funs ) { return funs . stream ( ) . map ( Function : : toString ) . collect ( joining ( <str> ) ) ; } } 
