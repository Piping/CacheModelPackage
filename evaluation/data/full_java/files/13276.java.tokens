package org . gradle . integtests . fixtures . executer ; import org . gradle . util . TextUtil ; import org . hamcrest . Matcher ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Pattern ; import static org . gradle . util . Matchers . isEmpty ; import static org . gradle . util . Matchers . normalizedLineSeparators ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . startsWith ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class OutputScrapingExecutionFailure extends OutputScrapingExecutionResult implements ExecutionFailure { private static final Pattern FAILURE_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern CAUSE_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern DESCRIPTION_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern LOCATION_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern RESOLUTION_PATTERN = Pattern . compile ( <str> ) ; private final String description ; private final String lineNumber ; private final String fileName ; private final String resolution ; private final List < String > causes = new ArrayList < String > ( ) ; public OutputScrapingExecutionFailure ( String output , String error ) { super ( output , error ) ; java . util . regex . Matcher matcher = FAILURE_PATTERN . matcher ( error ) ; if ( matcher . find ( ) ) { if ( matcher . find ( ) ) { throw new AssertionError ( <str> ) ; } } matcher = LOCATION_PATTERN . matcher ( error ) ; if ( matcher . find ( ) ) { fileName = matcher . group ( <int> ) . trim ( ) ; lineNumber = matcher . group ( <int> ) ; } else { fileName = <str> ; lineNumber = <str> ; } matcher = DESCRIPTION_PATTERN . matcher ( error ) ; if ( matcher . find ( ) ) { String problemStr = matcher . group ( <int> ) ; Problem problem = extract ( problemStr ) ; description = problem . description ; causes . addAll ( problem . causes ) ; while ( matcher . find ( ) ) { problemStr = matcher . group ( <int> ) ; problem = extract ( problemStr ) ; causes . addAll ( problem . causes ) ; } } else { description = <str> ; } matcher = RESOLUTION_PATTERN . matcher ( error ) ; if ( ! matcher . find ( ) ) { resolution = <str> ; } else { resolution = matcher . group ( <int> ) . trim ( ) ; } } private Problem extract ( String problem ) { java . util . regex . Matcher matcher = CAUSE_PATTERN . matcher ( problem ) ; String description ; List < String > causes = new ArrayList < String > ( ) ; if ( ! matcher . find ( ) ) { description = TextUtil . normaliseLineSeparators ( problem . trim ( ) ) ; } else { description = TextUtil . normaliseLineSeparators ( problem . substring ( <int> , matcher . start ( ) ) . trim ( ) ) ; while ( true ) { int pos = matcher . end ( ) ; int prefix = matcher . group ( <int> ) . length ( ) ; String prefixPattern = toPrefixPattern ( prefix ) ; if ( matcher . find ( pos ) ) { String cause = TextUtil . normaliseLineSeparators ( problem . substring ( pos , matcher . start ( ) ) . trim ( ) . replaceAll ( prefixPattern , <str> ) ) ; causes . add ( cause ) ; } else { String cause = TextUtil . normaliseLineSeparators ( problem . substring ( pos ) . trim ( ) . replaceAll ( prefixPattern , <str> ) ) ; causes . add ( cause ) ; break ; } } } return new Problem ( description , causes ) ; } private String toPrefixPattern ( int prefix ) { StringBuilder builder = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < prefix ; i + + ) { builder . append ( <str> ) ; } return builder . toString ( ) ; } public ExecutionFailure assertHasLineNumber ( int lineNumber ) { assertThat ( this . lineNumber , equalTo ( String . valueOf ( lineNumber ) ) ) ; return this ; } public ExecutionFailure assertHasFileName ( String filename ) { assertThat ( this . fileName , equalTo ( filename ) ) ; return this ; } public ExecutionFailure assertHasCause ( String description ) { assertThatCause ( normalizedLineSeparators ( startsWith ( description ) ) ) ; return this ; } public ExecutionFailure assertThatCause ( Matcher < String > matcher ) { for ( String cause : causes ) { if ( matcher . matches ( cause ) ) { return this ; } } fail ( String . format ( <str> , causes ) ) ; return this ; } public ExecutionFailure assertHasResolution ( String resolution ) { assertThat ( this . resolution , equalTo ( resolution ) ) ; return this ; } public ExecutionFailure assertHasNoCause ( ) { assertThat ( causes , isEmpty ( ) ) ; return this ; } public ExecutionFailure assertHasDescription ( String context ) { assertThatDescription ( startsWith ( context ) ) ; return this ; } public ExecutionFailure assertThatDescription ( Matcher < String > matcher ) { assertThat ( description , matcher ) ; return this ; } public ExecutionFailure assertTestsFailed ( ) { new DetailedExecutionFailure ( this ) . assertTestsFailed ( ) ; return this ; } public DependencyResolutionFailure assertResolutionFailure ( String configurationPath ) { return new DependencyResolutionFailure ( this , configurationPath ) ; } private static class Problem { final String description ; final List < String > causes ; private Problem ( String description , List < String > causes ) { this . description = description ; this . causes = causes ; } } } 
