package com . badlogic . gdx . backends . android . surfaceview ; import javax . microedition . khronos . egl . EGL10 ; import javax . microedition . khronos . egl . EGLConfig ; import javax . microedition . khronos . egl . EGLContext ; import javax . microedition . khronos . egl . EGLDisplay ; import android . annotation . TargetApi ; import android . content . Context ; import android . graphics . PixelFormat ; import android . opengl . GLSurfaceView ; import android . os . SystemClock ; import android . util . Log ; import android . view . KeyCharacterMap ; import android . view . KeyEvent ; import android . view . inputmethod . BaseInputConnection ; import android . view . inputmethod . EditorInfo ; import android . view . inputmethod . InputConnection ; public class GLSurfaceView20 extends GLSurfaceView { static String TAG = <str> ; private static final boolean DEBUG = false ; final ResolutionStrategy resolutionStrategy ; public GLSurfaceView20 ( Context context , ResolutionStrategy resolutionStrategy ) { super ( context ) ; this . resolutionStrategy = resolutionStrategy ; init ( false , <int> , <int> ) ; } public GLSurfaceView20 ( Context context , boolean translucent , int depth , int stencil , ResolutionStrategy resolutionStrategy ) { super ( context ) ; this . resolutionStrategy = resolutionStrategy ; init ( translucent , depth , stencil ) ; } @Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { ResolutionStrategy . MeasuredDimension measures = resolutionStrategy . calcMeasures ( widthMeasureSpec , heightMeasureSpec ) ; setMeasuredDimension ( measures . width , measures . height ) ; } @Override public InputConnection onCreateInputConnection ( EditorInfo outAttrs ) { if ( outAttrs ! = null ) { outAttrs . imeOptions = outAttrs . imeOptions | EditorInfo . IME_FLAG_NO_EXTRACT_UI ; } BaseInputConnection connection = new BaseInputConnection ( this , false ) { @Override public boolean deleteSurroundingText ( int beforeLength , int afterLength ) { int sdkVersion = android . os . Build . VERSION . SDK_INT ; if ( sdkVersion > = <int> ) { if ( beforeLength = = <int> & & afterLength = = <int> ) { sendDownUpKeyEventForBackwardCompatibility ( KeyEvent . KEYCODE_DEL ) ; return true ; } } return super . deleteSurroundingText ( beforeLength , afterLength ) ; } @TargetApi ( <int> ) private void sendDownUpKeyEventForBackwardCompatibility ( final int code ) { final long eventTime = SystemClock . uptimeMillis ( ) ; super . sendKeyEvent ( new KeyEvent ( eventTime , eventTime , KeyEvent . ACTION_DOWN , code , <int> , <int> , KeyCharacterMap . VIRTUAL_KEYBOARD , <int> , KeyEvent . FLAG_SOFT_KEYBOARD | KeyEvent . FLAG_KEEP_TOUCH_MODE ) ) ; super . sendKeyEvent ( new KeyEvent ( SystemClock . uptimeMillis ( ) , eventTime , KeyEvent . ACTION_UP , code , <int> , <int> , KeyCharacterMap . VIRTUAL_KEYBOARD , <int> , KeyEvent . FLAG_SOFT_KEYBOARD | KeyEvent . FLAG_KEEP_TOUCH_MODE ) ) ; } } ; return connection ; } private void init ( boolean translucent , int depth , int stencil ) { if ( translucent ) { this . getHolder ( ) . setFormat ( PixelFormat . TRANSLUCENT ) ; } setEGLContextFactory ( new ContextFactory ( ) ) ; setEGLConfigChooser ( translucent ? new ConfigChooser ( <int> , <int> , <int> , <int> , depth , stencil ) : new ConfigChooser ( <int> , <int> , <int> , <int> , depth , stencil ) ) ; } static class ContextFactory implements GLSurfaceView . EGLContextFactory { private static int EGL_CONTEXT_CLIENT_VERSION = <hex> ; public EGLContext createContext ( EGL10 egl , EGLDisplay display , EGLConfig eglConfig ) { Log . w ( TAG , <str> ) ; checkEglError ( <str> , egl ) ; int [ ] attrib_list = { EGL_CONTEXT_CLIENT_VERSION , <int> , EGL10 . EGL_NONE } ; EGLContext context = egl . eglCreateContext ( display , eglConfig , EGL10 . EGL_NO_CONTEXT , attrib_list ) ; checkEglError ( <str> , egl ) ; return context ; } public void destroyContext ( EGL10 egl , EGLDisplay display , EGLContext context ) { egl . eglDestroyContext ( display , context ) ; } } static void checkEglError ( String prompt , EGL10 egl ) { int error ; while ( ( error = egl . eglGetError ( ) ) ! = EGL10 . EGL_SUCCESS ) { Log . e ( TAG , String . format ( <str> , prompt , error ) ) ; } } private static class ConfigChooser implements GLSurfaceView . EGLConfigChooser { public ConfigChooser ( int r , int g , int b , int a , int depth , int stencil ) { mRedSize = r ; mGreenSize = g ; mBlueSize = b ; mAlphaSize = a ; mDepthSize = depth ; mStencilSize = stencil ; } private static int EGL_OPENGL_ES2_BIT = <int> ; private static int [ ] s_configAttribs2 = { EGL10 . EGL_RED_SIZE , <int> , EGL10 . EGL_GREEN_SIZE , <int> , EGL10 . EGL_BLUE_SIZE , <int> , EGL10 . EGL_RENDERABLE_TYPE , EGL_OPENGL_ES2_BIT , EGL10 . EGL_NONE } ; public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display ) { int [ ] num_config = new int [ <int> ] ; egl . eglChooseConfig ( display , s_configAttribs2 , null , <int> , num_config ) ; int numConfigs = num_config [ <int> ] ; if ( numConfigs < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } EGLConfig [ ] configs = new EGLConfig [ numConfigs ] ; egl . eglChooseConfig ( display , s_configAttribs2 , configs , numConfigs , num_config ) ; if ( DEBUG ) { printConfigs ( egl , display , configs ) ; } return chooseConfig ( egl , display , configs ) ; } public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) { for ( EGLConfig config : configs ) { int d = findConfigAttrib ( egl , display , config , EGL10 . EGL_DEPTH_SIZE , <int> ) ; int s = findConfigAttrib ( egl , display , config , EGL10 . EGL_STENCIL_SIZE , <int> ) ; if ( d < mDepthSize | | s < mStencilSize ) continue ; int r = findConfigAttrib ( egl , display , config , EGL10 . EGL_RED_SIZE , <int> ) ; int g = findConfigAttrib ( egl , display , config , EGL10 . EGL_GREEN_SIZE , <int> ) ; int b = findConfigAttrib ( egl , display , config , EGL10 . EGL_BLUE_SIZE , <int> ) ; int a = findConfigAttrib ( egl , display , config , EGL10 . EGL_ALPHA_SIZE , <int> ) ; if ( r = = mRedSize & & g = = mGreenSize & & b = = mBlueSize & & a = = mAlphaSize ) return config ; } return null ; } private int findConfigAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attribute , int defaultValue ) { if ( egl . eglGetConfigAttrib ( display , config , attribute , mValue ) ) { return mValue [ <int> ] ; } return defaultValue ; } private void printConfigs ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) { int numConfigs = configs . length ; Log . w ( TAG , String . format ( <str> , numConfigs ) ) ; for ( int i = <int> ; i < numConfigs ; i + + ) { Log . w ( TAG , String . format ( <str> , i ) ) ; printConfig ( egl , display , configs [ i ] ) ; } } private void printConfig ( EGL10 egl , EGLDisplay display , EGLConfig config ) { int [ ] attributes = { EGL10 . EGL_BUFFER_SIZE , EGL10 . EGL_ALPHA_SIZE , EGL10 . EGL_BLUE_SIZE , EGL10 . EGL_GREEN_SIZE , EGL10 . EGL_RED_SIZE , EGL10 . EGL_DEPTH_SIZE , EGL10 . EGL_STENCIL_SIZE , EGL10 . EGL_CONFIG_CAVEAT , EGL10 . EGL_CONFIG_ID , EGL10 . EGL_LEVEL , EGL10 . EGL_MAX_PBUFFER_HEIGHT , EGL10 . EGL_MAX_PBUFFER_PIXELS , EGL10 . EGL_MAX_PBUFFER_WIDTH , EGL10 . EGL_NATIVE_RENDERABLE , EGL10 . EGL_NATIVE_VISUAL_ID , EGL10 . EGL_NATIVE_VISUAL_TYPE , <hex> , EGL10 . EGL_SAMPLES , EGL10 . EGL_SAMPLE_BUFFERS , EGL10 . EGL_SURFACE_TYPE , EGL10 . EGL_TRANSPARENT_TYPE , EGL10 . EGL_TRANSPARENT_RED_VALUE , EGL10 . EGL_TRANSPARENT_GREEN_VALUE , EGL10 . EGL_TRANSPARENT_BLUE_VALUE , <hex> , <hex> , <hex> , <hex> , EGL10 . EGL_LUMINANCE_SIZE , EGL10 . EGL_ALPHA_MASK_SIZE , EGL10 . EGL_COLOR_BUFFER_TYPE , EGL10 . EGL_RENDERABLE_TYPE , <hex> } ; String [ ] names = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; int [ ] value = new int [ <int> ] ; for ( int i = <int> ; i < attributes . length ; i + + ) { int attribute = attributes [ i ] ; String name = names [ i ] ; if ( egl . eglGetConfigAttrib ( display , config , attribute , value ) ) { Log . w ( TAG , String . format ( <str> , name , value [ <int> ] ) ) ; } else { while ( egl . eglGetError ( ) ! = EGL10 . EGL_SUCCESS ) ; } } } protected int mRedSize ; protected int mGreenSize ; protected int mBlueSize ; protected int mAlphaSize ; protected int mDepthSize ; protected int mStencilSize ; private int [ ] mValue = new int [ <int> ] ; } } 
