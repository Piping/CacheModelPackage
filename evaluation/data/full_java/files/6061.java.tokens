package org . elasticsearch . common . transport ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . transport . local . LocalTransport ; import java . io . IOException ; public final class LocalTransportAddress implements TransportAddress { public static final LocalTransportAddress PROTO = new LocalTransportAddress ( <str> ) ; private String id ; public LocalTransportAddress ( StreamInput in ) throws IOException { id = in . readString ( ) ; } public LocalTransportAddress ( String id ) { this . id = id ; } public String id ( ) { return this . id ; } @Override public short uniqueAddressTypeId ( ) { return <int> ; } @Override public boolean sameHost ( TransportAddress other ) { return other instanceof LocalTransportAddress & & id . equals ( ( ( LocalTransportAddress ) other ) . id ) ; } @Override public String getHost ( ) { return <str> ; } @Override public String getAddress ( ) { return <str> ; } @Override public int getPort ( ) { return <int> ; } @Override public LocalTransportAddress readFrom ( StreamInput in ) throws IOException { return new LocalTransportAddress ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( id ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; LocalTransportAddress that = ( LocalTransportAddress ) o ; if ( id ! = null ? ! id . equals ( that . id ) : that . id ! = null ) return false ; return true ; } @Override public int hashCode ( ) { return id ! = null ? id . hashCode ( ) : <int> ; } @Override public String toString ( ) { return <str> + id + <str> ; } } 
