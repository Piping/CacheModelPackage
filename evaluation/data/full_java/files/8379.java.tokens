package org . elasticsearch . percolator ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . percolate . PercolateResponse ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Semaphore ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . index . query . QueryBuilders . boolQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . percolator . PercolatorTestUtil . convertFromTextArray ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . arrayContaining ; import static org . hamcrest . Matchers . arrayContainingInAnyOrder ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . emptyArray ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . nullValue ; public class ConcurrentPercolatorIT extends ESIntegTestCase { public void testSimpleConcurrentPercolator ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; final BytesReference onlyField1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ; final BytesReference onlyField2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . bytes ( ) ; final BytesReference bothFields = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . bytes ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , termQuery ( <str> , <int> ) ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; refresh ( ) ; final CountDownLatch start = new CountDownLatch ( <int> ) ; final AtomicBoolean stop = new AtomicBoolean ( false ) ; final AtomicInteger counts = new AtomicInteger ( <int> ) ; final AtomicReference < Throwable > exceptionHolder = new AtomicReference < > ( ) ; Thread [ ] threads = new Thread [ scaledRandomIntBetween ( <int> , <int> ) ] ; final int numberOfPercolations = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { start . await ( ) ; while ( ! stop . get ( ) ) { int count = counts . incrementAndGet ( ) ; if ( ( count > numberOfPercolations ) ) { stop . set ( true ) ; } PercolateResponse percolate ; if ( count % <int> = = <int> ) { percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( bothFields ) . execute ( ) . actionGet ( ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; assertThat ( convertFromTextArray ( percolate . getMatches ( ) , <str> ) , arrayContainingInAnyOrder ( <str> , <str> ) ) ; } else if ( count % <int> = = <int> ) { percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( onlyField2 ) . execute ( ) . actionGet ( ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; assertThat ( convertFromTextArray ( percolate . getMatches ( ) , <str> ) , arrayContaining ( <str> ) ) ; } else { percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( onlyField1 ) . execute ( ) . actionGet ( ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; assertThat ( convertFromTextArray ( percolate . getMatches ( ) , <str> ) , arrayContaining ( <str> ) ) ; } } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( Throwable e ) { exceptionHolder . set ( e ) ; Thread . currentThread ( ) . interrupt ( ) ; } } } ; threads [ i ] = new Thread ( r ) ; threads [ i ] . start ( ) ; } start . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } Throwable assertionError = exceptionHolder . get ( ) ; if ( assertionError ! = null ) { assertionError . printStackTrace ( ) ; } assertThat ( assertionError + <str> , assertionError , nullValue ( ) ) ; } public void testConcurrentAddingAndPercolating ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; final int numIndexThreads = scaledRandomIntBetween ( <int> , <int> ) ; final int numPercolateThreads = scaledRandomIntBetween ( <int> , <int> ) ; final int numPercolatorOperationsPerThread = scaledRandomIntBetween ( <int> , <int> ) ; final Set < Throwable > exceptionsHolder = ConcurrentCollections . newConcurrentSet ( ) ; final CountDownLatch start = new CountDownLatch ( <int> ) ; final AtomicInteger runningPercolateThreads = new AtomicInteger ( numPercolateThreads ) ; final AtomicInteger type1 = new AtomicInteger ( ) ; final AtomicInteger type2 = new AtomicInteger ( ) ; final AtomicInteger type3 = new AtomicInteger ( ) ; final AtomicInteger idGen = new AtomicInteger ( ) ; Thread [ ] indexThreads = new Thread [ numIndexThreads ] ; for ( int i = <int> ; i < numIndexThreads ; i + + ) { final Random rand = new Random ( getRandom ( ) . nextLong ( ) ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { XContentBuilder onlyField1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ; XContentBuilder onlyField2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ; XContentBuilder field1And2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , boolQuery ( ) . must ( termQuery ( <str> , <str> ) ) . must ( termQuery ( <str> , <str> ) ) ) . endObject ( ) ; start . await ( ) ; while ( runningPercolateThreads . get ( ) > <int> ) { Thread . sleep ( <int> ) ; int x = rand . nextInt ( <int> ) ; String id = Integer . toString ( idGen . incrementAndGet ( ) ) ; IndexResponse response ; switch ( x ) { case <int> : response = client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , id ) . setSource ( onlyField1 ) . execute ( ) . actionGet ( ) ; type1 . incrementAndGet ( ) ; break ; case <int> : response = client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , id ) . setSource ( onlyField2 ) . execute ( ) . actionGet ( ) ; type2 . incrementAndGet ( ) ; break ; case <int> : response = client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , id ) . setSource ( field1And2 ) . execute ( ) . actionGet ( ) ; type3 . incrementAndGet ( ) ; break ; default : throw new IllegalStateException ( <str> + x ) ; } assertThat ( response . getId ( ) , equalTo ( id ) ) ; assertThat ( response . getVersion ( ) , equalTo ( <int> ) ) ; } } catch ( Throwable t ) { exceptionsHolder . add ( t ) ; logger . error ( <str> , t ) ; } } } ; indexThreads [ i ] = new Thread ( r ) ; indexThreads [ i ] . start ( ) ; } Thread [ ] percolateThreads = new Thread [ numPercolateThreads ] ; for ( int i = <int> ; i < numPercolateThreads ; i + + ) { final Random rand = new Random ( getRandom ( ) . nextLong ( ) ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { XContentBuilder onlyField1Doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; XContentBuilder onlyField2Doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; XContentBuilder field1AndField2Doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; start . await ( ) ; for ( int counter = <int> ; counter < numPercolatorOperationsPerThread ; counter + + ) { int x = rand . nextInt ( <int> ) ; int atLeastExpected ; PercolateResponse response ; switch ( x ) { case <int> : atLeastExpected = type1 . get ( ) ; response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( onlyField1Doc ) . execute ( ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( response . getTotalShards ( ) ) ) ; assertThat ( response . getMatches ( ) . length , greaterThanOrEqualTo ( atLeastExpected ) ) ; break ; case <int> : atLeastExpected = type2 . get ( ) ; response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( onlyField2Doc ) . execute ( ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( response . getTotalShards ( ) ) ) ; assertThat ( response . getMatches ( ) . length , greaterThanOrEqualTo ( atLeastExpected ) ) ; break ; case <int> : atLeastExpected = type3 . get ( ) ; response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( field1AndField2Doc ) . execute ( ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( response . getTotalShards ( ) ) ) ; assertThat ( response . getMatches ( ) . length , greaterThanOrEqualTo ( atLeastExpected ) ) ; break ; } } } catch ( Throwable t ) { exceptionsHolder . add ( t ) ; logger . error ( <str> , t ) ; } finally { runningPercolateThreads . decrementAndGet ( ) ; } } } ; percolateThreads [ i ] = new Thread ( r ) ; percolateThreads [ i ] . start ( ) ; } start . countDown ( ) ; for ( Thread thread : indexThreads ) { thread . join ( ) ; } for ( Thread thread : percolateThreads ) { thread . join ( ) ; } for ( Throwable t : exceptionsHolder ) { logger . error ( <str> , t . getMessage ( ) , t ) ; } assertThat ( exceptionsHolder . isEmpty ( ) , equalTo ( true ) ) ; } public void testConcurrentAddingAndRemovingWhilePercolating ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) ) ; ensureGreen ( ) ; final int numIndexThreads = scaledRandomIntBetween ( <int> , <int> ) ; final int numberPercolateOperation = scaledRandomIntBetween ( <int> , <int> ) ; final AtomicReference < Throwable > exceptionHolder = new AtomicReference < > ( null ) ; final AtomicInteger idGen = new AtomicInteger ( <int> ) ; final Set < String > liveIds = ConcurrentCollections . newConcurrentSet ( ) ; final AtomicBoolean run = new AtomicBoolean ( true ) ; Thread [ ] indexThreads = new Thread [ numIndexThreads ] ; final Semaphore semaphore = new Semaphore ( numIndexThreads , true ) ; for ( int i = <int> ; i < indexThreads . length ; i + + ) { final Random rand = new Random ( getRandom ( ) . nextLong ( ) ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ; outer : while ( run . get ( ) ) { semaphore . acquire ( ) ; try { if ( ! liveIds . isEmpty ( ) & & rand . nextInt ( <int> ) < <int> ) { String id ; do { if ( liveIds . isEmpty ( ) ) { continue outer ; } id = Integer . toString ( randomInt ( idGen . get ( ) ) ) ; } while ( ! liveIds . remove ( id ) ) ; DeleteResponse response = client ( ) . prepareDelete ( <str> , PercolatorService . TYPE_NAME , id ) . execute ( ) . actionGet ( ) ; assertThat ( response . getId ( ) , equalTo ( id ) ) ; assertThat ( <str> + id + <str> , response . isFound ( ) , equalTo ( true ) ) ; } else { String id = Integer . toString ( idGen . getAndIncrement ( ) ) ; IndexResponse response = client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , id ) . setSource ( doc ) . execute ( ) . actionGet ( ) ; liveIds . add ( id ) ; assertThat ( response . isCreated ( ) , equalTo ( true ) ) ; assertThat ( response . getId ( ) , equalTo ( id ) ) ; } } finally { semaphore . release ( ) ; } } } catch ( InterruptedException iex ) { logger . error ( <str> , iex ) ; run . set ( false ) ; } catch ( Throwable t ) { run . set ( false ) ; exceptionHolder . set ( t ) ; logger . error ( <str> , t ) ; } } } ; indexThreads [ i ] = new Thread ( r ) ; indexThreads [ i ] . start ( ) ; } XContentBuilder percolateDoc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; for ( int counter = <int> ; counter < numberPercolateOperation ; counter + + ) { Thread . sleep ( <int> ) ; semaphore . acquire ( numIndexThreads ) ; try { if ( ! run . get ( ) ) { break ; } int atLeastExpected = liveIds . size ( ) ; PercolateResponse response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( percolateDoc ) . execute ( ) . actionGet ( ) ; assertThat ( response . getShardFailures ( ) , emptyArray ( ) ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( response . getTotalShards ( ) ) ) ; assertThat ( response . getMatches ( ) . length , equalTo ( atLeastExpected ) ) ; } finally { semaphore . release ( numIndexThreads ) ; } } run . set ( false ) ; for ( Thread thread : indexThreads ) { thread . join ( ) ; } assertThat ( <str> + exceptionHolder . toString ( ) , exceptionHolder . get ( ) , nullValue ( ) ) ; } } 
