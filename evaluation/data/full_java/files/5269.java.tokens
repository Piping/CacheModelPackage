package org . elasticsearch . action . bulk ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import java . io . Closeable ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicLong ; public class BulkProcessor implements Closeable { public static interface Listener { void beforeBulk ( long executionId , BulkRequest request ) ; void afterBulk ( long executionId , BulkRequest request , BulkResponse response ) ; void afterBulk ( long executionId , BulkRequest request , Throwable failure ) ; } public static class Builder { private final Client client ; private final Listener listener ; private String name ; private int concurrentRequests = <int> ; private int bulkActions = <int> ; private ByteSizeValue bulkSize = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ; private TimeValue flushInterval = null ; public Builder ( Client client , Listener listener ) { this . client = client ; this . listener = listener ; } public Builder setName ( String name ) { this . name = name ; return this ; } public Builder setConcurrentRequests ( int concurrentRequests ) { this . concurrentRequests = concurrentRequests ; return this ; } public Builder setBulkActions ( int bulkActions ) { this . bulkActions = bulkActions ; return this ; } public Builder setBulkSize ( ByteSizeValue bulkSize ) { this . bulkSize = bulkSize ; return this ; } public Builder setFlushInterval ( TimeValue flushInterval ) { this . flushInterval = flushInterval ; return this ; } public BulkProcessor build ( ) { return new BulkProcessor ( client , listener , name , concurrentRequests , bulkActions , bulkSize , flushInterval ) ; } } public static Builder builder ( Client client , Listener listener ) { if ( client = = null ) { throw new NullPointerException ( <str> ) ; } return new Builder ( client , listener ) ; } private final Client client ; private final Listener listener ; private final String name ; private final int concurrentRequests ; private final int bulkActions ; private final long bulkSize ; private final TimeValue flushInterval ; private final Semaphore semaphore ; private final ScheduledThreadPoolExecutor scheduler ; private final ScheduledFuture scheduledFuture ; private final AtomicLong executionIdGen = new AtomicLong ( ) ; private BulkRequest bulkRequest ; private volatile boolean closed = false ; BulkProcessor ( Client client , Listener listener , @Nullable String name , int concurrentRequests , int bulkActions , ByteSizeValue bulkSize , @Nullable TimeValue flushInterval ) { this . client = client ; this . listener = listener ; this . name = name ; this . concurrentRequests = concurrentRequests ; this . bulkActions = bulkActions ; this . bulkSize = bulkSize . bytes ( ) ; this . semaphore = new Semaphore ( concurrentRequests ) ; this . bulkRequest = new BulkRequest ( ) ; this . flushInterval = flushInterval ; if ( flushInterval ! = null ) { this . scheduler = ( ScheduledThreadPoolExecutor ) Executors . newScheduledThreadPool ( <int> , EsExecutors . daemonThreadFactory ( client . settings ( ) , ( name ! = null ? <str> + name + <str> : <str> ) + <str> ) ) ; this . scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; this . scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; this . scheduledFuture = this . scheduler . scheduleWithFixedDelay ( new Flush ( ) , flushInterval . millis ( ) , flushInterval . millis ( ) , TimeUnit . MILLISECONDS ) ; } else { this . scheduler = null ; this . scheduledFuture = null ; } } @Override public void close ( ) { try { awaitClose ( <int> , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException exc ) { Thread . currentThread ( ) . interrupt ( ) ; } } public synchronized boolean awaitClose ( long timeout , TimeUnit unit ) throws InterruptedException { if ( closed ) { return true ; } closed = true ; if ( this . scheduledFuture ! = null ) { FutureUtils . cancel ( this . scheduledFuture ) ; this . scheduler . shutdown ( ) ; } if ( bulkRequest . numberOfActions ( ) > <int> ) { execute ( ) ; } if ( this . concurrentRequests < <int> ) { return true ; } if ( semaphore . tryAcquire ( this . concurrentRequests , timeout , unit ) ) { semaphore . release ( this . concurrentRequests ) ; return true ; } return false ; } public BulkProcessor add ( IndexRequest request ) { return add ( ( ActionRequest ) request ) ; } public BulkProcessor add ( DeleteRequest request ) { return add ( ( ActionRequest ) request ) ; } public BulkProcessor add ( ActionRequest request ) { return add ( request , null ) ; } public BulkProcessor add ( ActionRequest request , @Nullable Object payload ) { internalAdd ( request , payload ) ; return this ; } boolean isOpen ( ) { return closed = = false ; } protected void ensureOpen ( ) { if ( closed ) { throw new IllegalStateException ( <str> ) ; } } private synchronized void internalAdd ( ActionRequest request , @Nullable Object payload ) { ensureOpen ( ) ; bulkRequest . add ( request , payload ) ; executeIfNeeded ( ) ; } public BulkProcessor add ( BytesReference data , @Nullable String defaultIndex , @Nullable String defaultType ) throws Exception { return add ( data , defaultIndex , defaultType , null ) ; } public synchronized BulkProcessor add ( BytesReference data , @Nullable String defaultIndex , @Nullable String defaultType , @Nullable Object payload ) throws Exception { bulkRequest . add ( data , defaultIndex , defaultType , null , null , payload , true ) ; executeIfNeeded ( ) ; return this ; } private void executeIfNeeded ( ) { ensureOpen ( ) ; if ( ! isOverTheLimit ( ) ) { return ; } execute ( ) ; } private void execute ( ) { final BulkRequest bulkRequest = this . bulkRequest ; final long executionId = executionIdGen . incrementAndGet ( ) ; this . bulkRequest = new BulkRequest ( ) ; if ( concurrentRequests = = <int> ) { boolean afterCalled = false ; try { listener . beforeBulk ( executionId , bulkRequest ) ; BulkResponse bulkItemResponses = client . bulk ( bulkRequest ) . actionGet ( ) ; afterCalled = true ; listener . afterBulk ( executionId , bulkRequest , bulkItemResponses ) ; } catch ( Exception e ) { if ( ! afterCalled ) { listener . afterBulk ( executionId , bulkRequest , e ) ; } } } else { boolean success = false ; boolean acquired = false ; try { listener . beforeBulk ( executionId , bulkRequest ) ; semaphore . acquire ( ) ; acquired = true ; client . bulk ( bulkRequest , new ActionListener < BulkResponse > ( ) { @Override public void onResponse ( BulkResponse response ) { try { listener . afterBulk ( executionId , bulkRequest , response ) ; } finally { semaphore . release ( ) ; } } @Override public void onFailure ( Throwable e ) { try { listener . afterBulk ( executionId , bulkRequest , e ) ; } finally { semaphore . release ( ) ; } } } ) ; success = true ; } catch ( InterruptedException e ) { Thread . interrupted ( ) ; listener . afterBulk ( executionId , bulkRequest , e ) ; } catch ( Throwable t ) { listener . afterBulk ( executionId , bulkRequest , t ) ; } finally { if ( ! success & & acquired ) { semaphore . release ( ) ; } } } } private boolean isOverTheLimit ( ) { if ( bulkActions ! = - <int> & & bulkRequest . numberOfActions ( ) > = bulkActions ) { return true ; } if ( bulkSize ! = - <int> & & bulkRequest . estimatedSizeInBytes ( ) > = bulkSize ) { return true ; } return false ; } public synchronized void flush ( ) { ensureOpen ( ) ; if ( bulkRequest . numberOfActions ( ) > <int> ) { execute ( ) ; } } class Flush implements Runnable { @Override public void run ( ) { synchronized ( BulkProcessor . this ) { if ( closed ) { return ; } if ( bulkRequest . numberOfActions ( ) = = <int> ) { return ; } execute ( ) ; } } } } 
