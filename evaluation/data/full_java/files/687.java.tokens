package org . apache . cassandra . io . sstable ; import java . io . * ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . * ; public final class IndexHelper { private IndexHelper ( ) { } public static int indexFor ( ClusteringPrefix name , List < IndexInfo > indexList , ClusteringComparator comparator , boolean reversed , int lastIndex ) { IndexInfo target = new IndexInfo ( name , name , <int> , <int> , null ) ; int startIdx = <int> ; List < IndexInfo > toSearch = indexList ; if ( reversed ) { if ( lastIndex < indexList . size ( ) - <int> ) { toSearch = indexList . subList ( <int> , lastIndex + <int> ) ; } } else { if ( lastIndex > <int> ) { startIdx = lastIndex ; toSearch = indexList . subList ( lastIndex , indexList . size ( ) ) ; } } int index = Collections . binarySearch ( toSearch , target , comparator . indexComparator ( reversed ) ) ; return startIdx + ( index < <int> ? - index - ( reversed ? <int> : <int> ) : index ) ; } public static class IndexInfo { private static final long EMPTY_SIZE = ObjectSizes . measure ( new IndexInfo ( null , null , <int> , <int> , null ) ) ; public final long offset ; public final long width ; public final ClusteringPrefix firstName ; public final ClusteringPrefix lastName ; public final DeletionTime endOpenMarker ; public IndexInfo ( ClusteringPrefix firstName , ClusteringPrefix lastName , long offset , long width , DeletionTime endOpenMarker ) { this . firstName = firstName ; this . lastName = lastName ; this . offset = offset ; this . width = width ; this . endOpenMarker = endOpenMarker ; } public static class Serializer { public static final long WIDTH_BASE = <int> * <int> ; private final ISerializer < ClusteringPrefix > clusteringSerializer ; private final Version version ; public Serializer ( CFMetaData metadata , Version version , SerializationHeader header ) { this . clusteringSerializer = metadata . serializers ( ) . indexEntryClusteringPrefixSerializer ( version , header ) ; this . version = version ; } public void serialize ( IndexInfo info , DataOutputPlus out ) throws IOException { assert version . storeRows ( ) : <str> ; clusteringSerializer . serialize ( info . firstName , out ) ; clusteringSerializer . serialize ( info . lastName , out ) ; out . writeUnsignedVInt ( info . offset ) ; out . writeVInt ( info . width - WIDTH_BASE ) ; out . writeBoolean ( info . endOpenMarker ! = null ) ; if ( info . endOpenMarker ! = null ) DeletionTime . serializer . serialize ( info . endOpenMarker , out ) ; } public IndexInfo deserialize ( DataInputPlus in ) throws IOException { ClusteringPrefix firstName = clusteringSerializer . deserialize ( in ) ; ClusteringPrefix lastName = clusteringSerializer . deserialize ( in ) ; long offset ; long width ; DeletionTime endOpenMarker = null ; if ( version . storeRows ( ) ) { offset = in . readUnsignedVInt ( ) ; width = in . readVInt ( ) + WIDTH_BASE ; if ( in . readBoolean ( ) ) endOpenMarker = DeletionTime . serializer . deserialize ( in ) ; } else { offset = in . readLong ( ) ; width = in . readLong ( ) ; } return new IndexInfo ( firstName , lastName , offset , width , endOpenMarker ) ; } public long serializedSize ( IndexInfo info ) { assert version . storeRows ( ) : <str> ; long size = clusteringSerializer . serializedSize ( info . firstName ) + clusteringSerializer . serializedSize ( info . lastName ) + TypeSizes . sizeofUnsignedVInt ( info . offset ) + TypeSizes . sizeofVInt ( info . width - WIDTH_BASE ) + TypeSizes . sizeof ( info . endOpenMarker ! = null ) ; if ( info . endOpenMarker ! = null ) size + = DeletionTime . serializer . serializedSize ( info . endOpenMarker ) ; return size ; } } public long unsharedHeapSize ( ) { return EMPTY_SIZE + firstName . unsharedHeapSize ( ) + lastName . unsharedHeapSize ( ) + ( endOpenMarker = = null ? <int> : endOpenMarker . unsharedHeapSize ( ) ) ; } } } 
