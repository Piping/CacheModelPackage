package com . badlogic . gdx . tools . hiero . unicodefont . effects ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Composite ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . image . BufferedImage ; import java . awt . image . ConvolveOp ; import java . awt . image . Kernel ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import com . badlogic . gdx . tools . hiero . unicodefont . Glyph ; import com . badlogic . gdx . tools . hiero . unicodefont . UnicodeFont ; public class ShadowEffect implements ConfigurableEffect { public static final int NUM_KERNELS = <int> ; public static final float [ ] [ ] GAUSSIAN_BLUR_KERNELS = generateGaussianBlurKernels ( NUM_KERNELS ) ; private Color color = Color . black ; private float opacity = <float> ; private float xDistance = <int> , yDistance = <int> ; private int blurKernelSize = <int> ; private int blurPasses = <int> ; public ShadowEffect ( ) { } public ShadowEffect ( Color color , int xDistance , int yDistance , float opacity ) { this . color = color ; this . xDistance = xDistance ; this . yDistance = yDistance ; this . opacity = opacity ; } public void draw ( BufferedImage image , Graphics2D g , UnicodeFont unicodeFont , Glyph glyph ) { g = ( Graphics2D ) g . create ( ) ; g . translate ( xDistance , yDistance ) ; g . setColor ( new Color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) , Math . round ( opacity * <int> ) ) ) ; g . fill ( glyph . getShape ( ) ) ; for ( Iterator iter = unicodeFont . getEffects ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Effect effect = ( Effect ) iter . next ( ) ; if ( effect instanceof OutlineEffect ) { Composite composite = g . getComposite ( ) ; g . setComposite ( AlphaComposite . Src ) ; g . setStroke ( ( ( OutlineEffect ) effect ) . getStroke ( ) ) ; g . draw ( glyph . getShape ( ) ) ; g . setComposite ( composite ) ; break ; } } g . dispose ( ) ; if ( blurKernelSize > <int> & & blurKernelSize < NUM_KERNELS & & blurPasses > <int> ) blur ( image ) ; } private void blur ( BufferedImage image ) { float [ ] matrix = GAUSSIAN_BLUR_KERNELS [ blurKernelSize - <int> ] ; Kernel gaussianBlur1 = new Kernel ( matrix . length , <int> , matrix ) ; Kernel gaussianBlur2 = new Kernel ( <int> , matrix . length , matrix ) ; RenderingHints hints = new RenderingHints ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_SPEED ) ; ConvolveOp gaussianOp1 = new ConvolveOp ( gaussianBlur1 , ConvolveOp . EDGE_NO_OP , hints ) ; ConvolveOp gaussianOp2 = new ConvolveOp ( gaussianBlur2 , ConvolveOp . EDGE_NO_OP , hints ) ; BufferedImage scratchImage = EffectUtil . getScratchImage ( ) ; for ( int i = <int> ; i < blurPasses ; i + + ) { gaussianOp1 . filter ( image , scratchImage ) ; gaussianOp2 . filter ( scratchImage , image ) ; } } public Color getColor ( ) { return color ; } public void setColor ( Color color ) { this . color = color ; } public float getXDistance ( ) { return xDistance ; } public void setXDistance ( float distance ) { xDistance = distance ; } public float getYDistance ( ) { return yDistance ; } public void setYDistance ( float distance ) { yDistance = distance ; } public int getBlurKernelSize ( ) { return blurKernelSize ; } public void setBlurKernelSize ( int blurKernelSize ) { this . blurKernelSize = blurKernelSize ; } public int getBlurPasses ( ) { return blurPasses ; } public void setBlurPasses ( int blurPasses ) { this . blurPasses = blurPasses ; } public float getOpacity ( ) { return opacity ; } public void setOpacity ( float opacity ) { this . opacity = opacity ; } public String toString ( ) { return <str> ; } public List getValues ( ) { List values = new ArrayList ( ) ; values . add ( EffectUtil . colorValue ( <str> , color ) ) ; values . add ( EffectUtil . floatValue ( <str> , opacity , <int> , <int> , <str> ) ) ; values . add ( EffectUtil . floatValue ( <str> , xDistance , - <int> , <int> , <str> + <str> ) ) ; values . add ( EffectUtil . floatValue ( <str> , yDistance , - <int> , <int> , <str> + <str> ) ) ; List options = new ArrayList ( ) ; options . add ( new String [ ] { <str> , <str> } ) ; for ( int i = <int> ; i < NUM_KERNELS ; i + + ) options . add ( new String [ ] { String . valueOf ( i ) } ) ; String [ ] [ ] optionsArray = ( String [ ] [ ] ) options . toArray ( new String [ options . size ( ) ] [ ] ) ; values . add ( EffectUtil . optionValue ( <str> , String . valueOf ( blurKernelSize ) , optionsArray , <str> ) ) ; values . add ( EffectUtil . intValue ( <str> , blurPasses , <str> ) ) ; return values ; } public void setValues ( List values ) { for ( Iterator iter = values . iterator ( ) ; iter . hasNext ( ) ; ) { Value value = ( Value ) iter . next ( ) ; if ( value . getName ( ) . equals ( <str> ) ) { color = ( Color ) value . getObject ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { opacity = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { xDistance = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { yDistance = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { blurKernelSize = Integer . parseInt ( ( String ) value . getObject ( ) ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { blurPasses = ( ( Integer ) value . getObject ( ) ) . intValue ( ) ; } } } private static float [ ] [ ] generateGaussianBlurKernels ( int level ) { float [ ] [ ] pascalsTriangle = generatePascalsTriangle ( level ) ; float [ ] [ ] gaussianTriangle = new float [ pascalsTriangle . length ] [ ] ; for ( int i = <int> ; i < gaussianTriangle . length ; i + + ) { float total = <float> ; gaussianTriangle [ i ] = new float [ pascalsTriangle [ i ] . length ] ; for ( int j = <int> ; j < pascalsTriangle [ i ] . length ; j + + ) total + = pascalsTriangle [ i ] [ j ] ; float coefficient = <int> / total ; for ( int j = <int> ; j < pascalsTriangle [ i ] . length ; j + + ) gaussianTriangle [ i ] [ j ] = coefficient * pascalsTriangle [ i ] [ j ] ; } return gaussianTriangle ; } private static float [ ] [ ] generatePascalsTriangle ( int level ) { if ( level < <int> ) level = <int> ; float [ ] [ ] triangle = new float [ level ] [ ] ; triangle [ <int> ] = new float [ <int> ] ; triangle [ <int> ] = new float [ <int> ] ; triangle [ <int> ] [ <int> ] = <float> ; triangle [ <int> ] [ <int> ] = <float> ; triangle [ <int> ] [ <int> ] = <float> ; for ( int i = <int> ; i < level ; i + + ) { triangle [ i ] = new float [ i + <int> ] ; triangle [ i ] [ <int> ] = <float> ; triangle [ i ] [ i ] = <float> ; for ( int j = <int> ; j < triangle [ i ] . length - <int> ; j + + ) triangle [ i ] [ j ] = triangle [ i - <int> ] [ j - <int> ] + triangle [ i - <int> ] [ j ] ; } return triangle ; } } 
