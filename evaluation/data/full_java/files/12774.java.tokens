package org . gradle . api . internal . artifacts . repositories . resolver ; import org . apache . ivy . core . IvyPatternHelper ; import org . gradle . api . artifacts . ModuleIdentifier ; import org . gradle . internal . component . model . IvyArtifactName ; import org . gradle . internal . resolve . result . ResourceAwareResolveResult ; import org . gradle . internal . resource . ExternalResourceName ; import org . gradle . internal . resource . ResourceException ; import org . gradle . internal . resource . transport . ExternalResourceRepository ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ResourceVersionLister implements VersionLister { private static final Logger LOGGER = LoggerFactory . getLogger ( ResourceVersionLister . class ) ; private static final String REVISION_TOKEN = IvyPatternHelper . getTokenString ( IvyPatternHelper . REVISION_KEY ) ; public static final int REV_TOKEN_LENGTH = REVISION_TOKEN . length ( ) ; private final ExternalResourceRepository repository ; private final String fileSeparator = <str> ; public ResourceVersionLister ( ExternalResourceRepository repository ) { this . repository = repository ; } public VersionPatternVisitor newVisitor ( final ModuleIdentifier module , final Collection < String > dest , final ResourceAwareResolveResult result ) { return new VersionPatternVisitor ( ) { final Set < ExternalResourceName > directories = new HashSet < ExternalResourceName > ( ) ; public void visit ( ResourcePattern pattern , IvyArtifactName artifact ) throws ResourceException { ExternalResourceName versionListPattern = pattern . toVersionListPattern ( module , artifact ) ; LOGGER . debug ( <str> , versionListPattern ) ; try { List < String > versionStrings = listRevisionToken ( versionListPattern ) ; for ( String versionString : versionStrings ) { dest . add ( versionString ) ; } } catch ( Exception e ) { throw ResourceException . failure ( versionListPattern . getUri ( ) , String . format ( <str> , pattern ) , e ) ; } } private List < String > listRevisionToken ( ExternalResourceName versionListPattern ) { String pattern = versionListPattern . getPath ( ) ; if ( ! pattern . contains ( REVISION_TOKEN ) ) { LOGGER . debug ( <str> , pattern ) ; return Collections . emptyList ( ) ; } String prefix = pattern . substring ( <int> , pattern . indexOf ( REVISION_TOKEN ) ) ; if ( revisionMatchesDirectoryName ( pattern ) ) { ExternalResourceName parent = versionListPattern . getRoot ( ) . resolve ( prefix ) ; return listAll ( parent ) ; } else { int parentFolderSlashIndex = prefix . lastIndexOf ( fileSeparator ) ; String revisionParentFolder = parentFolderSlashIndex = = - <int> ? <str> : prefix . substring ( <int> , parentFolderSlashIndex + <int> ) ; ExternalResourceName parent = versionListPattern . getRoot ( ) . resolve ( revisionParentFolder ) ; LOGGER . debug ( <str> , repository , revisionParentFolder ) ; if ( ! directories . add ( parent ) ) { return Collections . emptyList ( ) ; } result . attempted ( parent ) ; List < String > all = repository . list ( parent . getUri ( ) ) ; if ( all = = null ) { return Collections . emptyList ( ) ; } LOGGER . debug ( <str> , all . size ( ) ) ; Pattern regexPattern = createRegexPattern ( pattern , parentFolderSlashIndex ) ; List < String > ret = filterMatchedValues ( all , regexPattern ) ; LOGGER . debug ( <str> , ret . size ( ) , pattern ) ; return ret ; } } private List < String > filterMatchedValues ( List < String > all , final Pattern p ) { List < String > ret = new ArrayList < String > ( all . size ( ) ) ; for ( String path : all ) { Matcher m = p . matcher ( path ) ; if ( m . matches ( ) ) { String value = m . group ( <int> ) ; ret . add ( value ) ; } } return ret ; } private Pattern createRegexPattern ( String pattern , int prefixLastSlashIndex ) { int endNameIndex = pattern . indexOf ( fileSeparator , prefixLastSlashIndex + <int> ) ; String namePattern ; if ( endNameIndex ! = - <int> ) { namePattern = pattern . substring ( prefixLastSlashIndex + <int> , endNameIndex ) ; } else { namePattern = pattern . substring ( prefixLastSlashIndex + <int> ) ; } namePattern = namePattern . replaceAll ( <str> , <str> ) ; String acceptNamePattern = namePattern . replaceAll ( <str> , <str> ) ; return Pattern . compile ( acceptNamePattern ) ; } private boolean revisionMatchesDirectoryName ( String pattern ) { int startToken = pattern . indexOf ( REVISION_TOKEN ) ; if ( startToken > <int> & & ! pattern . substring ( startToken - <int> , startToken ) . equals ( fileSeparator ) ) { return false ; } int endToken = startToken + REV_TOKEN_LENGTH ; if ( endToken < pattern . length ( ) & & ! pattern . substring ( endToken , endToken + <int> ) . equals ( fileSeparator ) ) { return false ; } return true ; } private List < String > listAll ( ExternalResourceName parent ) { if ( ! directories . add ( parent ) ) { return Collections . emptyList ( ) ; } LOGGER . debug ( <str> , repository , parent ) ; result . attempted ( parent . toString ( ) ) ; List < String > paths = repository . list ( parent . getUri ( ) ) ; if ( paths = = null ) { return Collections . emptyList ( ) ; } LOGGER . debug ( <str> , paths . size ( ) ) ; return paths ; } } ; } } 
