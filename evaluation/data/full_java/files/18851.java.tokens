package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . util . ReferenceCountUtil ; import java . util . List ; public abstract class MessageAggregator < I , S , C extends ByteBufHolder , O extends ByteBufHolder > extends MessageToMessageDecoder < I > { private static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = <int> ; private final int maxContentLength ; private O currentMessage ; private boolean handlingOversizedMessage ; private int maxCumulationBufferComponents = DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS ; private ChannelHandlerContext ctx ; private ChannelFutureListener continueResponseWriteListener ; protected MessageAggregator ( int maxContentLength ) { validateMaxContentLength ( maxContentLength ) ; this . maxContentLength = maxContentLength ; } protected MessageAggregator ( int maxContentLength , Class < ? extends I > inboundMessageType ) { super ( inboundMessageType ) ; validateMaxContentLength ( maxContentLength ) ; this . maxContentLength = maxContentLength ; } private static void validateMaxContentLength ( int maxContentLength ) { if ( maxContentLength < <int> ) { throw new IllegalArgumentException ( <str> + maxContentLength + <str> ) ; } } @Override public boolean acceptInboundMessage ( Object msg ) throws Exception { if ( ! super . acceptInboundMessage ( msg ) ) { return false ; } @SuppressWarnings ( <str> ) I in = ( I ) msg ; return ( isContentMessage ( in ) | | isStartMessage ( in ) ) & & ! isAggregated ( in ) ; } protected abstract boolean isStartMessage ( I msg ) throws Exception ; protected abstract boolean isContentMessage ( I msg ) throws Exception ; protected abstract boolean isLastContentMessage ( C msg ) throws Exception ; protected abstract boolean isAggregated ( I msg ) throws Exception ; public final int maxContentLength ( ) { return maxContentLength ; } public final int maxCumulationBufferComponents ( ) { return maxCumulationBufferComponents ; } public final void setMaxCumulationBufferComponents ( int maxCumulationBufferComponents ) { if ( maxCumulationBufferComponents < <int> ) { throw new IllegalArgumentException ( <str> + maxCumulationBufferComponents + <str> ) ; } if ( ctx = = null ) { this . maxCumulationBufferComponents = maxCumulationBufferComponents ; } else { throw new IllegalStateException ( <str> ) ; } } public final boolean isHandlingOversizedMessage ( ) { return handlingOversizedMessage ; } protected final ChannelHandlerContext ctx ( ) { if ( ctx = = null ) { throw new IllegalStateException ( <str> ) ; } return ctx ; } @Override protected void decode ( final ChannelHandlerContext ctx , I msg , List < Object > out ) throws Exception { O currentMessage = this . currentMessage ; if ( isStartMessage ( msg ) ) { handlingOversizedMessage = false ; if ( currentMessage ! = null ) { throw new MessageAggregationException ( ) ; } @SuppressWarnings ( <str> ) S m = ( S ) msg ; Object continueResponse = newContinueResponse ( m , maxContentLength , ctx . pipeline ( ) ) ; if ( continueResponse ! = null ) { ChannelFutureListener listener = continueResponseWriteListener ; if ( listener = = null ) { continueResponseWriteListener = listener = new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { ctx . fireExceptionCaught ( future . cause ( ) ) ; } } } ; } boolean closeAfterWrite = closeAfterContinueResponse ( continueResponse ) ; handlingOversizedMessage = ignoreContentAfterContinueResponse ( continueResponse ) ; final ChannelFuture future = ctx . writeAndFlush ( continueResponse ) . addListener ( listener ) ; if ( closeAfterWrite ) { future . addListener ( ChannelFutureListener . CLOSE ) ; return ; } if ( handlingOversizedMessage ) { return ; } } else if ( isContentLengthInvalid ( m , maxContentLength ) ) { invokeHandleOversizedMessage ( ctx , m ) ; return ; } if ( m instanceof DecoderResultProvider & & ! ( ( DecoderResultProvider ) m ) . decoderResult ( ) . isSuccess ( ) ) { O aggregated ; if ( m instanceof ByteBufHolder & & ( ( ByteBufHolder ) m ) . content ( ) . isReadable ( ) ) { aggregated = beginAggregation ( m , ( ( ByteBufHolder ) m ) . content ( ) . retain ( ) ) ; } else { aggregated = beginAggregation ( m , Unpooled . EMPTY_BUFFER ) ; } finishAggregation ( aggregated ) ; out . add ( aggregated ) ; this . currentMessage = null ; return ; } CompositeByteBuf content = ctx . alloc ( ) . compositeBuffer ( maxCumulationBufferComponents ) ; if ( m instanceof ByteBufHolder ) { appendPartialContent ( content , ( ( ByteBufHolder ) m ) . content ( ) ) ; } this . currentMessage = beginAggregation ( m , content ) ; } else if ( isContentMessage ( msg ) ) { @SuppressWarnings ( <str> ) final C m = ( C ) msg ; final ByteBuf partialContent = ( ( ByteBufHolder ) msg ) . content ( ) ; final boolean isLastContentMessage = isLastContentMessage ( m ) ; if ( handlingOversizedMessage ) { if ( isLastContentMessage ) { this . currentMessage = null ; } return ; } if ( currentMessage = = null ) { throw new MessageAggregationException ( ) ; } CompositeByteBuf content = ( CompositeByteBuf ) currentMessage . content ( ) ; if ( content . readableBytes ( ) > maxContentLength - partialContent . readableBytes ( ) ) { @SuppressWarnings ( <str> ) S s = ( S ) currentMessage ; invokeHandleOversizedMessage ( ctx , s ) ; return ; } appendPartialContent ( content , partialContent ) ; aggregate ( currentMessage , m ) ; final boolean last ; if ( m instanceof DecoderResultProvider ) { DecoderResult decoderResult = ( ( DecoderResultProvider ) m ) . decoderResult ( ) ; if ( ! decoderResult . isSuccess ( ) ) { if ( currentMessage instanceof DecoderResultProvider ) { ( ( DecoderResultProvider ) currentMessage ) . setDecoderResult ( DecoderResult . failure ( decoderResult . cause ( ) ) ) ; } last = true ; } else { last = isLastContentMessage ; } } else { last = isLastContentMessage ; } if ( last ) { finishAggregation ( currentMessage ) ; out . add ( currentMessage ) ; this . currentMessage = null ; } } else { throw new MessageAggregationException ( ) ; } } private static void appendPartialContent ( CompositeByteBuf content , ByteBuf partialContent ) { if ( partialContent . isReadable ( ) ) { partialContent . retain ( ) ; content . addComponent ( partialContent ) ; content . writerIndex ( content . writerIndex ( ) + partialContent . readableBytes ( ) ) ; } } protected abstract boolean isContentLengthInvalid ( S start , int maxContentLength ) throws Exception ; protected abstract Object newContinueResponse ( S start , int maxContentLength , ChannelPipeline pipeline ) throws Exception ; protected abstract boolean closeAfterContinueResponse ( Object msg ) throws Exception ; protected abstract boolean ignoreContentAfterContinueResponse ( Object msg ) throws Exception ; protected abstract O beginAggregation ( S start , ByteBuf content ) throws Exception ; protected void aggregate ( O aggregated , C content ) throws Exception { } protected void finishAggregation ( O aggregated ) throws Exception { } private void invokeHandleOversizedMessage ( ChannelHandlerContext ctx , S oversized ) throws Exception { handlingOversizedMessage = true ; currentMessage = null ; try { handleOversizedMessage ( ctx , oversized ) ; } finally { ReferenceCountUtil . release ( oversized ) ; } } protected void handleOversizedMessage ( ChannelHandlerContext ctx , S oversized ) throws Exception { ctx . fireExceptionCaught ( new TooLongFrameException ( <str> + maxContentLength ( ) + <str> ) ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { if ( currentMessage ! = null ) { currentMessage . release ( ) ; currentMessage = null ; } super . channelInactive ( ctx ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { super . handlerRemoved ( ctx ) ; if ( currentMessage ! = null ) { currentMessage . release ( ) ; currentMessage = null ; } } } 
