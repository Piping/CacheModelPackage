package com . badlogic . gdx . graphics . g3d . shaders ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Attribute ; import com . badlogic . gdx . graphics . g3d . Attributes ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . Shader ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . CubemapAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . DepthTestAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . DirectionalLightsAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . IntAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . PointLightsAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . SpotLightsAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . environment . AmbientCubemap ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . environment . PointLight ; import com . badlogic . gdx . graphics . g3d . environment . SpotLight ; import com . badlogic . gdx . graphics . g3d . utils . RenderContext ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class DefaultShader extends BaseShader { public static class Config { public String vertexShader = null ; public String fragmentShader = null ; public int numDirectionalLights = <int> ; public int numPointLights = <int> ; public int numSpotLights = <int> ; public int numBones = <int> ; public boolean ignoreUnimplemented = true ; public int defaultCullFace = - <int> ; public int defaultDepthFunc = - <int> ; public Config ( ) { } public Config ( final String vertexShader , final String fragmentShader ) { this . vertexShader = vertexShader ; this . fragmentShader = fragmentShader ; } } public static class Inputs { public final static Uniform projTrans = new Uniform ( <str> ) ; public final static Uniform viewTrans = new Uniform ( <str> ) ; public final static Uniform projViewTrans = new Uniform ( <str> ) ; public final static Uniform cameraPosition = new Uniform ( <str> ) ; public final static Uniform cameraDirection = new Uniform ( <str> ) ; public final static Uniform cameraUp = new Uniform ( <str> ) ; public final static Uniform worldTrans = new Uniform ( <str> ) ; public final static Uniform viewWorldTrans = new Uniform ( <str> ) ; public final static Uniform projViewWorldTrans = new Uniform ( <str> ) ; public final static Uniform normalMatrix = new Uniform ( <str> ) ; public final static Uniform bones = new Uniform ( <str> ) ; public final static Uniform shininess = new Uniform ( <str> , FloatAttribute . Shininess ) ; public final static Uniform opacity = new Uniform ( <str> , BlendingAttribute . Type ) ; public final static Uniform diffuseColor = new Uniform ( <str> , ColorAttribute . Diffuse ) ; public final static Uniform diffuseTexture = new Uniform ( <str> , TextureAttribute . Diffuse ) ; public final static Uniform diffuseUVTransform = new Uniform ( <str> , TextureAttribute . Diffuse ) ; public final static Uniform specularColor = new Uniform ( <str> , ColorAttribute . Specular ) ; public final static Uniform specularTexture = new Uniform ( <str> , TextureAttribute . Specular ) ; public final static Uniform specularUVTransform = new Uniform ( <str> , TextureAttribute . Specular ) ; public final static Uniform emissiveColor = new Uniform ( <str> , ColorAttribute . Emissive ) ; public final static Uniform emissiveTexture = new Uniform ( <str> , TextureAttribute . Emissive ) ; public final static Uniform emissiveUVTransform = new Uniform ( <str> , TextureAttribute . Emissive ) ; public final static Uniform reflectionColor = new Uniform ( <str> , ColorAttribute . Reflection ) ; public final static Uniform reflectionTexture = new Uniform ( <str> , TextureAttribute . Reflection ) ; public final static Uniform reflectionUVTransform = new Uniform ( <str> , TextureAttribute . Reflection ) ; public final static Uniform normalTexture = new Uniform ( <str> , TextureAttribute . Normal ) ; public final static Uniform normalUVTransform = new Uniform ( <str> , TextureAttribute . Normal ) ; public final static Uniform ambientTexture = new Uniform ( <str> , TextureAttribute . Ambient ) ; public final static Uniform ambientUVTransform = new Uniform ( <str> , TextureAttribute . Ambient ) ; public final static Uniform alphaTest = new Uniform ( <str> ) ; public final static Uniform ambientCube = new Uniform ( <str> ) ; public final static Uniform dirLights = new Uniform ( <str> ) ; public final static Uniform pointLights = new Uniform ( <str> ) ; public final static Uniform spotLights = new Uniform ( <str> ) ; public final static Uniform environmentCubemap = new Uniform ( <str> ) ; } public static class Setters { public final static Setter projTrans = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . projection ) ; } } ; public final static Setter viewTrans = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . view ) ; } } ; public final static Setter projViewTrans = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . combined ) ; } } ; public final static Setter cameraPosition = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . position . x , shader . camera . position . y , shader . camera . position . z , <float> / ( shader . camera . far * shader . camera . far ) ) ; } } ; public final static Setter cameraDirection = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . direction ) ; } } ; public final static Setter cameraUp = new GlobalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , shader . camera . up ) ; } } ; public final static Setter worldTrans = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , renderable . worldTransform ) ; } } ; public final static Setter viewWorldTrans = new LocalSetter ( ) { final Matrix4 temp = new Matrix4 ( ) ; @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , temp . set ( shader . camera . view ) . mul ( renderable . worldTransform ) ) ; } } ; public final static Setter projViewWorldTrans = new LocalSetter ( ) { final Matrix4 temp = new Matrix4 ( ) ; @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , temp . set ( shader . camera . combined ) . mul ( renderable . worldTransform ) ) ; } } ; public final static Setter normalMatrix = new LocalSetter ( ) { private final Matrix3 tmpM = new Matrix3 ( ) ; @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , tmpM . set ( renderable . worldTransform ) . inv ( ) . transpose ( ) ) ; } } ; public static class Bones extends LocalSetter { private final static Matrix4 idtMatrix = new Matrix4 ( ) ; public final float bones [ ] ; public Bones ( final int numBones ) { this . bones = new float [ numBones * <int> ] ; } @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { for ( int i = <int> ; i < bones . length ; i + + ) { final int idx = i / <int> ; bones [ i ] = ( renderable . bones = = null | | idx > = renderable . bones . length | | renderable . bones [ idx ] = = null ) ? idtMatrix . val [ i % <int> ] : renderable . bones [ idx ] . val [ i % <int> ] ; } shader . program . setUniformMatrix4fv ( shader . loc ( inputID ) , bones , <int> , bones . length ) ; } } public final static Setter shininess = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , ( ( FloatAttribute ) ( combinedAttributes . get ( FloatAttribute . Shininess ) ) ) . value ) ; } } ; public final static Setter diffuseColor = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , ( ( ColorAttribute ) ( combinedAttributes . get ( ColorAttribute . Diffuse ) ) ) . color ) ; } } ; public final static Setter diffuseTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Diffuse ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter diffuseUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Diffuse ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public final static Setter specularColor = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , ( ( ColorAttribute ) ( combinedAttributes . get ( ColorAttribute . Specular ) ) ) . color ) ; } } ; public final static Setter specularTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Specular ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter specularUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Specular ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public final static Setter emissiveColor = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , ( ( ColorAttribute ) ( combinedAttributes . get ( ColorAttribute . Emissive ) ) ) . color ) ; } } ; public final static Setter emissiveTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Emissive ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter emissiveUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Emissive ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public final static Setter reflectionColor = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { shader . set ( inputID , ( ( ColorAttribute ) ( combinedAttributes . get ( ColorAttribute . Reflection ) ) ) . color ) ; } } ; public final static Setter reflectionTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Reflection ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter reflectionUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Reflection ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public final static Setter normalTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Normal ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter normalUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Normal ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public final static Setter ambientTexture = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final int unit = shader . context . textureBinder . bind ( ( ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Ambient ) ) ) . textureDescription ) ; shader . set ( inputID , unit ) ; } } ; public final static Setter ambientUVTransform = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { final TextureAttribute ta = ( TextureAttribute ) ( combinedAttributes . get ( TextureAttribute . Ambient ) ) ; shader . set ( inputID , ta . offsetU , ta . offsetV , ta . scaleU , ta . scaleV ) ; } } ; public static class ACubemap extends LocalSetter { private final static float ones [ ] = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; private final AmbientCubemap cacheAmbientCubemap = new AmbientCubemap ( ) ; private final static Vector3 tmpV1 = new Vector3 ( ) ; public final int dirLightsOffset ; public final int pointLightsOffset ; public ACubemap ( final int dirLightsOffset , final int pointLightsOffset ) { this . dirLightsOffset = dirLightsOffset ; this . pointLightsOffset = pointLightsOffset ; } @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { if ( renderable . environment = = null ) shader . program . setUniform3fv ( shader . loc ( inputID ) , ones , <int> , ones . length ) ; else { renderable . worldTransform . getTranslation ( tmpV1 ) ; if ( combinedAttributes . has ( ColorAttribute . AmbientLight ) ) cacheAmbientCubemap . set ( ( ( ColorAttribute ) combinedAttributes . get ( ColorAttribute . AmbientLight ) ) . color ) ; if ( combinedAttributes . has ( DirectionalLightsAttribute . Type ) ) { Array < DirectionalLight > lights = ( ( DirectionalLightsAttribute ) combinedAttributes . get ( DirectionalLightsAttribute . Type ) ) . lights ; for ( int i = dirLightsOffset ; i < lights . size ; i + + ) cacheAmbientCubemap . add ( lights . get ( i ) . color , lights . get ( i ) . direction ) ; } if ( combinedAttributes . has ( PointLightsAttribute . Type ) ) { Array < PointLight > lights = ( ( PointLightsAttribute ) combinedAttributes . get ( PointLightsAttribute . Type ) ) . lights ; for ( int i = pointLightsOffset ; i < lights . size ; i + + ) cacheAmbientCubemap . add ( lights . get ( i ) . color , lights . get ( i ) . position , tmpV1 , lights . get ( i ) . intensity ) ; } cacheAmbientCubemap . clamp ( ) ; shader . program . setUniform3fv ( shader . loc ( inputID ) , cacheAmbientCubemap . data , <int> , cacheAmbientCubemap . data . length ) ; } } } public final static Setter environmentCubemap = new LocalSetter ( ) { @Override public void set ( BaseShader shader , int inputID , Renderable renderable , Attributes combinedAttributes ) { if ( combinedAttributes . has ( CubemapAttribute . EnvironmentMap ) ) { shader . set ( inputID , shader . context . textureBinder . bind ( ( ( CubemapAttribute ) combinedAttributes . get ( CubemapAttribute . EnvironmentMap ) ) . textureDescription ) ) ; } } } ; } private static String defaultVertexShader = null ; public static String getDefaultVertexShader ( ) { if ( defaultVertexShader = = null ) defaultVertexShader = Gdx . files . classpath ( <str> ) . readString ( ) ; return defaultVertexShader ; } private static String defaultFragmentShader = null ; public static String getDefaultFragmentShader ( ) { if ( defaultFragmentShader = = null ) defaultFragmentShader = Gdx . files . classpath ( <str> ) . readString ( ) ; return defaultFragmentShader ; } protected static long implementedFlags = BlendingAttribute . Type | TextureAttribute . Diffuse | ColorAttribute . Diffuse | ColorAttribute . Specular | FloatAttribute . Shininess ; @Deprecated public static int defaultCullFace = GL20 . GL_BACK ; @Deprecated public static int defaultDepthFunc = GL20 . GL_LEQUAL ; public final int u_projTrans ; public final int u_viewTrans ; public final int u_projViewTrans ; public final int u_cameraPosition ; public final int u_cameraDirection ; public final int u_cameraUp ; public final int u_time ; public final int u_worldTrans ; public final int u_viewWorldTrans ; public final int u_projViewWorldTrans ; public final int u_normalMatrix ; public final int u_bones ; public final int u_shininess ; public final int u_opacity ; public final int u_diffuseColor ; public final int u_diffuseTexture ; public final int u_diffuseUVTransform ; public final int u_specularColor ; public final int u_specularTexture ; public final int u_specularUVTransform ; public final int u_emissiveColor ; public final int u_emissiveTexture ; public final int u_emissiveUVTransform ; public final int u_reflectionColor ; public final int u_reflectionTexture ; public final int u_reflectionUVTransform ; public final int u_normalTexture ; public final int u_normalUVTransform ; public final int u_ambientTexture ; public final int u_ambientUVTransform ; public final int u_alphaTest ; protected final int u_ambientCubemap ; protected final int u_environmentCubemap ; protected final int u_dirLights0color = register ( new Uniform ( <str> ) ) ; protected final int u_dirLights0direction = register ( new Uniform ( <str> ) ) ; protected final int u_dirLights1color = register ( new Uniform ( <str> ) ) ; protected final int u_pointLights0color = register ( new Uniform ( <str> ) ) ; protected final int u_pointLights0position = register ( new Uniform ( <str> ) ) ; protected final int u_pointLights0intensity = register ( new Uniform ( <str> ) ) ; protected final int u_pointLights1color = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0color = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0position = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0intensity = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0direction = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0cutoffAngle = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights0exponent = register ( new Uniform ( <str> ) ) ; protected final int u_spotLights1color = register ( new Uniform ( <str> ) ) ; protected final int u_fogColor = register ( new Uniform ( <str> ) ) ; protected final int u_shadowMapProjViewTrans = register ( new Uniform ( <str> ) ) ; protected final int u_shadowTexture = register ( new Uniform ( <str> ) ) ; protected final int u_shadowPCFOffset = register ( new Uniform ( <str> ) ) ; protected int dirLightsLoc ; protected int dirLightsColorOffset ; protected int dirLightsDirectionOffset ; protected int dirLightsSize ; protected int pointLightsLoc ; protected int pointLightsColorOffset ; protected int pointLightsPositionOffset ; protected int pointLightsIntensityOffset ; protected int pointLightsSize ; protected int spotLightsLoc ; protected int spotLightsColorOffset ; protected int spotLightsPositionOffset ; protected int spotLightsDirectionOffset ; protected int spotLightsIntensityOffset ; protected int spotLightsCutoffAngleOffset ; protected int spotLightsExponentOffset ; protected int spotLightsSize ; protected final boolean lighting ; protected final boolean environmentCubemap ; protected final boolean shadowMap ; protected final AmbientCubemap ambientCubemap = new AmbientCubemap ( ) ; protected final DirectionalLight directionalLights [ ] ; protected final PointLight pointLights [ ] ; protected final SpotLight spotLights [ ] ; private Renderable renderable ; protected final long attributesMask ; private long vertexMask ; protected final Config config ; private final static long optionalAttributes = IntAttribute . CullFace | DepthTestAttribute . Type ; public DefaultShader ( final Renderable renderable ) { this ( renderable , new Config ( ) ) ; } public DefaultShader ( final Renderable renderable , final Config config ) { this ( renderable , config , createPrefix ( renderable , config ) ) ; } public DefaultShader ( final Renderable renderable , final Config config , final String prefix ) { this ( renderable , config , prefix , config . vertexShader ! = null ? config . vertexShader : getDefaultVertexShader ( ) , config . fragmentShader ! = null ? config . fragmentShader : getDefaultFragmentShader ( ) ) ; } public DefaultShader ( final Renderable renderable , final Config config , final String prefix , final String vertexShader , final String fragmentShader ) { this ( renderable , config , new ShaderProgram ( prefix + vertexShader , prefix + fragmentShader ) ) ; } public DefaultShader ( final Renderable renderable , final Config config , final ShaderProgram shaderProgram ) { final Attributes attributes = combineAttributes ( renderable ) ; this . config = config ; this . program = shaderProgram ; this . lighting = renderable . environment ! = null ; this . environmentCubemap = attributes . has ( CubemapAttribute . EnvironmentMap ) | | ( lighting & & attributes . has ( CubemapAttribute . EnvironmentMap ) ) ; this . shadowMap = lighting & & renderable . environment . shadowMap ! = null ; this . renderable = renderable ; attributesMask = attributes . getMask ( ) | optionalAttributes ; vertexMask = renderable . meshPart . mesh . getVertexAttributes ( ) . getMask ( ) ; this . directionalLights = new DirectionalLight [ lighting & & config . numDirectionalLights > <int> ? config . numDirectionalLights : <int> ] ; for ( int i = <int> ; i < directionalLights . length ; i + + ) directionalLights [ i ] = new DirectionalLight ( ) ; this . pointLights = new PointLight [ lighting & & config . numPointLights > <int> ? config . numPointLights : <int> ] ; for ( int i = <int> ; i < pointLights . length ; i + + ) pointLights [ i ] = new PointLight ( ) ; this . spotLights = new SpotLight [ lighting & & config . numSpotLights > <int> ? config . numSpotLights : <int> ] ; for ( int i = <int> ; i < spotLights . length ; i + + ) spotLights [ i ] = new SpotLight ( ) ; if ( ! config . ignoreUnimplemented & & ( implementedFlags & attributesMask ) ! = attributesMask ) throw new GdxRuntimeException ( <str> + attributesMask + <str> ) ; u_projTrans = register ( Inputs . projTrans , Setters . projTrans ) ; u_viewTrans = register ( Inputs . viewTrans , Setters . viewTrans ) ; u_projViewTrans = register ( Inputs . projViewTrans , Setters . projViewTrans ) ; u_cameraPosition = register ( Inputs . cameraPosition , Setters . cameraPosition ) ; u_cameraDirection = register ( Inputs . cameraDirection , Setters . cameraDirection ) ; u_cameraUp = register ( Inputs . cameraUp , Setters . cameraUp ) ; u_time = register ( new Uniform ( <str> ) ) ; u_worldTrans = register ( Inputs . worldTrans , Setters . worldTrans ) ; u_viewWorldTrans = register ( Inputs . viewWorldTrans , Setters . viewWorldTrans ) ; u_projViewWorldTrans = register ( Inputs . projViewWorldTrans , Setters . projViewWorldTrans ) ; u_normalMatrix = register ( Inputs . normalMatrix , Setters . normalMatrix ) ; u_bones = ( renderable . bones ! = null & & config . numBones > <int> ) ? register ( Inputs . bones , new Setters . Bones ( config . numBones ) ) : - <int> ; u_shininess = register ( Inputs . shininess , Setters . shininess ) ; u_opacity = register ( Inputs . opacity ) ; u_diffuseColor = register ( Inputs . diffuseColor , Setters . diffuseColor ) ; u_diffuseTexture = register ( Inputs . diffuseTexture , Setters . diffuseTexture ) ; u_diffuseUVTransform = register ( Inputs . diffuseUVTransform , Setters . diffuseUVTransform ) ; u_specularColor = register ( Inputs . specularColor , Setters . specularColor ) ; u_specularTexture = register ( Inputs . specularTexture , Setters . specularTexture ) ; u_specularUVTransform = register ( Inputs . specularUVTransform , Setters . specularUVTransform ) ; u_emissiveColor = register ( Inputs . emissiveColor , Setters . emissiveColor ) ; u_emissiveTexture = register ( Inputs . emissiveTexture , Setters . emissiveTexture ) ; u_emissiveUVTransform = register ( Inputs . emissiveUVTransform , Setters . emissiveUVTransform ) ; u_reflectionColor = register ( Inputs . reflectionColor , Setters . reflectionColor ) ; u_reflectionTexture = register ( Inputs . reflectionTexture , Setters . reflectionTexture ) ; u_reflectionUVTransform = register ( Inputs . reflectionUVTransform , Setters . reflectionUVTransform ) ; u_normalTexture = register ( Inputs . normalTexture , Setters . normalTexture ) ; u_normalUVTransform = register ( Inputs . normalUVTransform , Setters . normalUVTransform ) ; u_ambientTexture = register ( Inputs . ambientTexture , Setters . ambientTexture ) ; u_ambientUVTransform = register ( Inputs . ambientUVTransform , Setters . ambientUVTransform ) ; u_alphaTest = register ( Inputs . alphaTest ) ; u_ambientCubemap = lighting ? register ( Inputs . ambientCube , new Setters . ACubemap ( config . numDirectionalLights , config . numPointLights ) ) : - <int> ; u_environmentCubemap = environmentCubemap ? register ( Inputs . environmentCubemap , Setters . environmentCubemap ) : - <int> ; } @Override public void init ( ) { final ShaderProgram program = this . program ; this . program = null ; init ( program , renderable ) ; renderable = null ; dirLightsLoc = loc ( u_dirLights0color ) ; dirLightsColorOffset = loc ( u_dirLights0color ) - dirLightsLoc ; dirLightsDirectionOffset = loc ( u_dirLights0direction ) - dirLightsLoc ; dirLightsSize = loc ( u_dirLights1color ) - dirLightsLoc ; if ( dirLightsSize < <int> ) dirLightsSize = <int> ; pointLightsLoc = loc ( u_pointLights0color ) ; pointLightsColorOffset = loc ( u_pointLights0color ) - pointLightsLoc ; pointLightsPositionOffset = loc ( u_pointLights0position ) - pointLightsLoc ; pointLightsIntensityOffset = has ( u_pointLights0intensity ) ? loc ( u_pointLights0intensity ) - pointLightsLoc : - <int> ; pointLightsSize = loc ( u_pointLights1color ) - pointLightsLoc ; if ( pointLightsSize < <int> ) pointLightsSize = <int> ; spotLightsLoc = loc ( u_spotLights0color ) ; spotLightsColorOffset = loc ( u_spotLights0color ) - spotLightsLoc ; spotLightsPositionOffset = loc ( u_spotLights0position ) - spotLightsLoc ; spotLightsDirectionOffset = loc ( u_spotLights0direction ) - spotLightsLoc ; spotLightsIntensityOffset = has ( u_spotLights0intensity ) ? loc ( u_spotLights0intensity ) - spotLightsLoc : - <int> ; spotLightsCutoffAngleOffset = loc ( u_spotLights0cutoffAngle ) - spotLightsLoc ; spotLightsExponentOffset = loc ( u_spotLights0exponent ) - spotLightsLoc ; spotLightsSize = loc ( u_spotLights1color ) - spotLightsLoc ; if ( spotLightsSize < <int> ) spotLightsSize = <int> ; } private static final boolean and ( final long mask , final long flag ) { return ( mask & flag ) = = flag ; } private static final boolean or ( final long mask , final long flag ) { return ( mask & flag ) ! = <int> ; } private final static Attributes tmpAttributes = new Attributes ( ) ; private static final Attributes combineAttributes ( final Renderable renderable ) { tmpAttributes . clear ( ) ; if ( renderable . environment ! = null ) tmpAttributes . set ( renderable . environment ) ; if ( renderable . material ! = null ) tmpAttributes . set ( renderable . material ) ; return tmpAttributes ; } public static String createPrefix ( final Renderable renderable , final Config config ) { final Attributes attributes = combineAttributes ( renderable ) ; String prefix = <str> ; final long attributesMask = attributes . getMask ( ) ; final long vertexMask = renderable . meshPart . mesh . getVertexAttributes ( ) . getMask ( ) ; if ( and ( vertexMask , Usage . Position ) ) prefix + = <str> ; if ( or ( vertexMask , Usage . ColorUnpacked | Usage . ColorPacked ) ) prefix + = <str> ; if ( and ( vertexMask , Usage . BiNormal ) ) prefix + = <str> ; if ( and ( vertexMask , Usage . Tangent ) ) prefix + = <str> ; if ( and ( vertexMask , Usage . Normal ) ) prefix + = <str> ; if ( and ( vertexMask , Usage . Normal ) | | and ( vertexMask , Usage . Tangent | Usage . BiNormal ) ) { if ( renderable . environment ! = null ) { prefix + = <str> ; prefix + = <str> ; prefix + = <str> + config . numDirectionalLights + <str> ; prefix + = <str> + config . numPointLights + <str> ; prefix + = <str> + config . numSpotLights + <str> ; if ( attributes . has ( ColorAttribute . Fog ) ) { prefix + = <str> ; } if ( renderable . environment . shadowMap ! = null ) prefix + = <str> ; if ( attributes . has ( CubemapAttribute . EnvironmentMap ) ) prefix + = <str> ; } } final int n = renderable . meshPart . mesh . getVertexAttributes ( ) . size ( ) ; for ( int i = <int> ; i < n ; i + + ) { final VertexAttribute attr = renderable . meshPart . mesh . getVertexAttributes ( ) . get ( i ) ; if ( attr . usage = = Usage . BoneWeight ) prefix + = <str> + attr . unit + <str> ; else if ( attr . usage = = Usage . TextureCoordinates ) prefix + = <str> + attr . unit + <str> ; } if ( ( attributesMask & BlendingAttribute . Type ) = = BlendingAttribute . Type ) prefix + = <str> + BlendingAttribute . Alias + <str> ; if ( ( attributesMask & TextureAttribute . Diffuse ) = = TextureAttribute . Diffuse ) { prefix + = <str> + TextureAttribute . DiffuseAlias + <str> ; prefix + = <str> + TextureAttribute . DiffuseAlias + <str> ; } if ( ( attributesMask & TextureAttribute . Specular ) = = TextureAttribute . Specular ) { prefix + = <str> + TextureAttribute . SpecularAlias + <str> ; prefix + = <str> + TextureAttribute . SpecularAlias + <str> ; } if ( ( attributesMask & TextureAttribute . Normal ) = = TextureAttribute . Normal ) { prefix + = <str> + TextureAttribute . NormalAlias + <str> ; prefix + = <str> + TextureAttribute . NormalAlias + <str> ; } if ( ( attributesMask & TextureAttribute . Emissive ) = = TextureAttribute . Emissive ) { prefix + = <str> + TextureAttribute . EmissiveAlias + <str> ; prefix + = <str> + TextureAttribute . EmissiveAlias + <str> ; } if ( ( attributesMask & TextureAttribute . Reflection ) = = TextureAttribute . Reflection ) { prefix + = <str> + TextureAttribute . ReflectionAlias + <str> ; prefix + = <str> + TextureAttribute . ReflectionAlias + <str> ; } if ( ( attributesMask & TextureAttribute . Ambient ) = = TextureAttribute . Ambient ) { prefix + = <str> + TextureAttribute . AmbientAlias + <str> ; prefix + = <str> + TextureAttribute . AmbientAlias + <str> ; } if ( ( attributesMask & ColorAttribute . Diffuse ) = = ColorAttribute . Diffuse ) prefix + = <str> + ColorAttribute . DiffuseAlias + <str> ; if ( ( attributesMask & ColorAttribute . Specular ) = = ColorAttribute . Specular ) prefix + = <str> + ColorAttribute . SpecularAlias + <str> ; if ( ( attributesMask & ColorAttribute . Emissive ) = = ColorAttribute . Emissive ) prefix + = <str> + ColorAttribute . EmissiveAlias + <str> ; if ( ( attributesMask & ColorAttribute . Reflection ) = = ColorAttribute . Reflection ) prefix + = <str> + ColorAttribute . ReflectionAlias + <str> ; if ( ( attributesMask & FloatAttribute . Shininess ) = = FloatAttribute . Shininess ) prefix + = <str> + FloatAttribute . ShininessAlias + <str> ; if ( ( attributesMask & FloatAttribute . AlphaTest ) = = FloatAttribute . AlphaTest ) prefix + = <str> + FloatAttribute . AlphaTestAlias + <str> ; if ( renderable . bones ! = null & & config . numBones > <int> ) prefix + = <str> + config . numBones + <str> ; return prefix ; } @Override public boolean canRender ( final Renderable renderable ) { final Attributes attributes = combineAttributes ( renderable ) ; return ( attributesMask = = ( attributes . getMask ( ) | optionalAttributes ) ) & & ( vertexMask = = renderable . meshPart . mesh . getVertexAttributes ( ) . getMask ( ) ) & & ( renderable . environment ! = null ) = = lighting ; } @Override public int compareTo ( Shader other ) { if ( other = = null ) return - <int> ; if ( other = = this ) return <int> ; return <int> ; } @Override public boolean equals ( Object obj ) { return ( obj instanceof DefaultShader ) ? equals ( ( DefaultShader ) obj ) : false ; } public boolean equals ( DefaultShader obj ) { return ( obj = = this ) ; } private Matrix3 normalMatrix = new Matrix3 ( ) ; private Camera camera ; private float time ; private boolean lightsSet ; @Override public void begin ( final Camera camera , final RenderContext context ) { super . begin ( camera , context ) ; for ( final DirectionalLight dirLight : directionalLights ) dirLight . set ( <int> , <int> , <int> , <int> , - <int> , <int> ) ; for ( final PointLight pointLight : pointLights ) pointLight . set ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; for ( final SpotLight spotLight : spotLights ) spotLight . set ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , <int> , <int> ) ; lightsSet = false ; if ( has ( u_time ) ) set ( u_time , time + = Gdx . graphics . getDeltaTime ( ) ) ; } @Override public void render ( Renderable renderable , Attributes combinedAttributes ) { if ( ! combinedAttributes . has ( BlendingAttribute . Type ) ) context . setBlending ( false , GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; bindMaterial ( combinedAttributes ) ; if ( lighting ) bindLights ( renderable , combinedAttributes ) ; super . render ( renderable , combinedAttributes ) ; } @Override public void end ( ) { super . end ( ) ; } protected void bindMaterial ( final Attributes attributes ) { int cullFace = config . defaultCullFace = = - <int> ? defaultCullFace : config . defaultCullFace ; int depthFunc = config . defaultDepthFunc = = - <int> ? defaultDepthFunc : config . defaultDepthFunc ; float depthRangeNear = <float> ; float depthRangeFar = <float> ; boolean depthMask = true ; for ( final Attribute attr : attributes ) { final long t = attr . type ; if ( BlendingAttribute . is ( t ) ) { context . setBlending ( true , ( ( BlendingAttribute ) attr ) . sourceFunction , ( ( BlendingAttribute ) attr ) . destFunction ) ; set ( u_opacity , ( ( BlendingAttribute ) attr ) . opacity ) ; } else if ( ( t & IntAttribute . CullFace ) = = IntAttribute . CullFace ) cullFace = ( ( IntAttribute ) attr ) . value ; else if ( ( t & FloatAttribute . AlphaTest ) = = FloatAttribute . AlphaTest ) set ( u_alphaTest , ( ( FloatAttribute ) attr ) . value ) ; else if ( ( t & DepthTestAttribute . Type ) = = DepthTestAttribute . Type ) { DepthTestAttribute dta = ( DepthTestAttribute ) attr ; depthFunc = dta . depthFunc ; depthRangeNear = dta . depthRangeNear ; depthRangeFar = dta . depthRangeFar ; depthMask = dta . depthMask ; } else if ( ! config . ignoreUnimplemented ) throw new GdxRuntimeException ( <str> + attr . toString ( ) ) ; } context . setCullFace ( cullFace ) ; context . setDepthTest ( depthFunc , depthRangeNear , depthRangeFar ) ; context . setDepthMask ( depthMask ) ; } private final Vector3 tmpV1 = new Vector3 ( ) ; protected void bindLights ( final Renderable renderable , final Attributes attributes ) { final Environment lights = renderable . environment ; final DirectionalLightsAttribute dla = attributes . get ( DirectionalLightsAttribute . class , DirectionalLightsAttribute . Type ) ; final Array < DirectionalLight > dirs = dla = = null ? null : dla . lights ; final PointLightsAttribute pla = attributes . get ( PointLightsAttribute . class , PointLightsAttribute . Type ) ; final Array < PointLight > points = pla = = null ? null : pla . lights ; final SpotLightsAttribute sla = attributes . get ( SpotLightsAttribute . class , SpotLightsAttribute . Type ) ; final Array < SpotLight > spots = sla = = null ? null : sla . lights ; if ( dirLightsLoc > = <int> ) { for ( int i = <int> ; i < directionalLights . length ; i + + ) { if ( dirs = = null | | i > = dirs . size ) { if ( lightsSet & & directionalLights [ i ] . color . r = = <float> & & directionalLights [ i ] . color . g = = <float> & & directionalLights [ i ] . color . b = = <float> ) continue ; directionalLights [ i ] . color . set ( <int> , <int> , <int> , <int> ) ; } else if ( lightsSet & & directionalLights [ i ] . equals ( dirs . get ( i ) ) ) continue ; else directionalLights [ i ] . set ( dirs . get ( i ) ) ; int idx = dirLightsLoc + i * dirLightsSize ; program . setUniformf ( idx + dirLightsColorOffset , directionalLights [ i ] . color . r , directionalLights [ i ] . color . g , directionalLights [ i ] . color . b ) ; program . setUniformf ( idx + dirLightsDirectionOffset , directionalLights [ i ] . direction . x , directionalLights [ i ] . direction . y , directionalLights [ i ] . direction . z ) ; if ( dirLightsSize < = <int> ) break ; } } if ( pointLightsLoc > = <int> ) { for ( int i = <int> ; i < pointLights . length ; i + + ) { if ( points = = null | | i > = points . size ) { if ( lightsSet & & pointLights [ i ] . intensity = = <float> ) continue ; pointLights [ i ] . intensity = <float> ; } else if ( lightsSet & & pointLights [ i ] . equals ( points . get ( i ) ) ) continue ; else pointLights [ i ] . set ( points . get ( i ) ) ; int idx = pointLightsLoc + i * pointLightsSize ; program . setUniformf ( idx + pointLightsColorOffset , pointLights [ i ] . color . r * pointLights [ i ] . intensity , pointLights [ i ] . color . g * pointLights [ i ] . intensity , pointLights [ i ] . color . b * pointLights [ i ] . intensity ) ; program . setUniformf ( idx + pointLightsPositionOffset , pointLights [ i ] . position . x , pointLights [ i ] . position . y , pointLights [ i ] . position . z ) ; if ( pointLightsIntensityOffset > = <int> ) program . setUniformf ( idx + pointLightsIntensityOffset , pointLights [ i ] . intensity ) ; if ( pointLightsSize < = <int> ) break ; } } if ( spotLightsLoc > = <int> ) { for ( int i = <int> ; i < spotLights . length ; i + + ) { if ( spots = = null | | i > = spots . size ) { if ( lightsSet & & spotLights [ i ] . intensity = = <float> ) continue ; spotLights [ i ] . intensity = <float> ; } else if ( lightsSet & & spotLights [ i ] . equals ( spots . get ( i ) ) ) continue ; else spotLights [ i ] . set ( spots . get ( i ) ) ; int idx = spotLightsLoc + i * spotLightsSize ; program . setUniformf ( idx + spotLightsColorOffset , spotLights [ i ] . color . r * spotLights [ i ] . intensity , spotLights [ i ] . color . g * spotLights [ i ] . intensity , spotLights [ i ] . color . b * spotLights [ i ] . intensity ) ; program . setUniformf ( idx + spotLightsPositionOffset , spotLights [ i ] . position ) ; program . setUniformf ( idx + spotLightsDirectionOffset , spotLights [ i ] . direction ) ; program . setUniformf ( idx + spotLightsCutoffAngleOffset , spotLights [ i ] . cutoffAngle ) ; program . setUniformf ( idx + spotLightsExponentOffset , spotLights [ i ] . exponent ) ; if ( spotLightsIntensityOffset > = <int> ) program . setUniformf ( idx + spotLightsIntensityOffset , spotLights [ i ] . intensity ) ; if ( spotLightsSize < = <int> ) break ; } } if ( attributes . has ( ColorAttribute . Fog ) ) { set ( u_fogColor , ( ( ColorAttribute ) attributes . get ( ColorAttribute . Fog ) ) . color ) ; } if ( lights ! = null & & lights . shadowMap ! = null ) { set ( u_shadowMapProjViewTrans , lights . shadowMap . getProjViewTrans ( ) ) ; set ( u_shadowTexture , lights . shadowMap . getDepthMap ( ) ) ; set ( u_shadowPCFOffset , <float> / ( <float> * lights . shadowMap . getDepthMap ( ) . texture . getWidth ( ) ) ) ; } lightsSet = true ; } @Override public void dispose ( ) { program . dispose ( ) ; super . dispose ( ) ; } public int getDefaultCullFace ( ) { return config . defaultCullFace = = - <int> ? defaultCullFace : config . defaultCullFace ; } public void setDefaultCullFace ( int cullFace ) { config . defaultCullFace = cullFace ; } public int getDefaultDepthFunc ( ) { return config . defaultDepthFunc = = - <int> ? defaultDepthFunc : config . defaultDepthFunc ; } public void setDefaultDepthFunc ( int depthFunc ) { config . defaultDepthFunc = depthFunc ; } } 
