package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseNotifier ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . concurrent . EventExecutor ; import java . util . concurrent . TimeUnit ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; public class Bzip2Encoder extends MessageToByteEncoder < ByteBuf > { private enum State { INIT , INIT_BLOCK , WRITE_DATA , CLOSE_BLOCK } private State currentState = State . INIT ; private final Bzip2BitWriter writer = new Bzip2BitWriter ( ) ; private final int streamBlockSize ; private int streamCRC ; private Bzip2BlockCompressor blockCompressor ; private volatile boolean finished ; private volatile ChannelHandlerContext ctx ; public Bzip2Encoder ( ) { this ( MAX_BLOCK_SIZE ) ; } public Bzip2Encoder ( final int blockSizeMultiplier ) { if ( blockSizeMultiplier < MIN_BLOCK_SIZE | | blockSizeMultiplier > MAX_BLOCK_SIZE ) { throw new IllegalArgumentException ( <str> + blockSizeMultiplier + <str> ) ; } streamBlockSize = blockSizeMultiplier * BASE_BLOCK_SIZE ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { if ( finished ) { out . writeBytes ( in ) ; return ; } for ( ; ; ) { switch ( currentState ) { case INIT : out . ensureWritable ( <int> ) ; out . writeMedium ( MAGIC_NUMBER ) ; out . writeByte ( <str> + streamBlockSize / BASE_BLOCK_SIZE ) ; currentState = State . INIT_BLOCK ; case INIT_BLOCK : blockCompressor = new Bzip2BlockCompressor ( writer , streamBlockSize ) ; currentState = State . WRITE_DATA ; case WRITE_DATA : if ( ! in . isReadable ( ) ) { return ; } Bzip2BlockCompressor blockCompressor = this . blockCompressor ; final int length = in . readableBytes ( ) < blockCompressor . availableSize ( ) ? in . readableBytes ( ) : blockCompressor . availableSize ( ) ; final int offset ; final byte [ ] array ; if ( in . hasArray ( ) ) { array = in . array ( ) ; offset = in . arrayOffset ( ) + in . readerIndex ( ) ; } else { array = new byte [ length ] ; in . getBytes ( in . readerIndex ( ) , array ) ; offset = <int> ; } final int bytesWritten = blockCompressor . write ( array , offset , length ) ; in . skipBytes ( bytesWritten ) ; if ( ! blockCompressor . isFull ( ) ) { if ( in . isReadable ( ) ) { break ; } else { return ; } } currentState = State . CLOSE_BLOCK ; case CLOSE_BLOCK : closeBlock ( out ) ; currentState = State . INIT_BLOCK ; break ; default : throw new IllegalStateException ( ) ; } } } private void closeBlock ( ByteBuf out ) { final Bzip2BlockCompressor blockCompressor = this . blockCompressor ; if ( ! blockCompressor . isEmpty ( ) ) { blockCompressor . close ( out ) ; final int blockCRC = blockCompressor . crc ( ) ; streamCRC = ( streamCRC < < <int> | streamCRC > > > <int> ) ^ blockCRC ; } } public boolean isClosed ( ) { return finished ; } public ChannelFuture close ( ) { return close ( ctx ( ) . newPromise ( ) ) ; } public ChannelFuture close ( final ChannelPromise promise ) { ChannelHandlerContext ctx = ctx ( ) ; EventExecutor executor = ctx . executor ( ) ; if ( executor . inEventLoop ( ) ) { return finishEncode ( ctx , promise ) ; } else { executor . execute ( new Runnable ( ) { @Override public void run ( ) { ChannelFuture f = finishEncode ( ctx ( ) , promise ) ; f . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } ) ; return promise ; } } @Override public void close ( final ChannelHandlerContext ctx , final ChannelPromise promise ) throws Exception { ChannelFuture f = finishEncode ( ctx , ctx . newPromise ( ) ) ; f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture f ) throws Exception { ctx . close ( promise ) ; } } ) ; if ( ! f . isDone ( ) ) { ctx . executor ( ) . schedule ( new Runnable ( ) { @Override public void run ( ) { ctx . close ( promise ) ; } } , <int> , TimeUnit . SECONDS ) ; } } private ChannelFuture finishEncode ( final ChannelHandlerContext ctx , ChannelPromise promise ) { if ( finished ) { promise . setSuccess ( ) ; return promise ; } finished = true ; final ByteBuf footer = ctx . alloc ( ) . buffer ( ) ; closeBlock ( footer ) ; final int streamCRC = this . streamCRC ; final Bzip2BitWriter writer = this . writer ; try { writer . writeBits ( footer , <int> , END_OF_STREAM_MAGIC_1 ) ; writer . writeBits ( footer , <int> , END_OF_STREAM_MAGIC_2 ) ; writer . writeInt ( footer , streamCRC ) ; writer . flush ( footer ) ; } finally { blockCompressor = null ; } return ctx . writeAndFlush ( footer , promise ) ; } private ChannelHandlerContext ctx ( ) { ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( <str> ) ; } return ctx ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; } } 
