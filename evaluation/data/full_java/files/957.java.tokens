package org . apache . cassandra . service ; import java . net . InetAddress ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . exceptions . ReadFailureException ; import org . apache . cassandra . exceptions . ReadTimeoutException ; import org . apache . cassandra . exceptions . UnavailableException ; import org . apache . cassandra . metrics . ReadRepairMetrics ; import org . apache . cassandra . net . IAsyncCallbackWithFailure ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . concurrent . SimpleCondition ; public class ReadCallback implements IAsyncCallbackWithFailure < ReadResponse > { protected static final Logger logger = LoggerFactory . getLogger ( ReadCallback . class ) ; public final ResponseResolver resolver ; private final SimpleCondition condition = new SimpleCondition ( ) ; private final long start ; final int blockfor ; final List < InetAddress > endpoints ; private final ReadCommand command ; private final ConsistencyLevel consistencyLevel ; private static final AtomicIntegerFieldUpdater < ReadCallback > recievedUpdater = AtomicIntegerFieldUpdater . newUpdater ( ReadCallback . class , <str> ) ; private volatile int received = <int> ; private static final AtomicIntegerFieldUpdater < ReadCallback > failuresUpdater = AtomicIntegerFieldUpdater . newUpdater ( ReadCallback . class , <str> ) ; private volatile int failures = <int> ; private final Keyspace keyspace ; public ReadCallback ( ResponseResolver resolver , ConsistencyLevel consistencyLevel , ReadCommand command , List < InetAddress > filteredEndpoints ) { this ( resolver , consistencyLevel , consistencyLevel . blockFor ( Keyspace . open ( command . metadata ( ) . ksName ) ) , command , Keyspace . open ( command . metadata ( ) . ksName ) , filteredEndpoints ) ; } public ReadCallback ( ResponseResolver resolver , ConsistencyLevel consistencyLevel , int blockfor , ReadCommand command , Keyspace keyspace , List < InetAddress > endpoints ) { this . command = command ; this . keyspace = keyspace ; this . blockfor = blockfor ; this . consistencyLevel = consistencyLevel ; this . resolver = resolver ; this . start = System . nanoTime ( ) ; this . endpoints = endpoints ; assert ! ( command instanceof PartitionRangeReadCommand ) | | blockfor > = endpoints . size ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( String . format ( <str> , blockfor , StringUtils . join ( this . endpoints , <str> ) ) ) ; } public boolean await ( long timePastStart , TimeUnit unit ) { long time = unit . toNanos ( timePastStart ) - ( System . nanoTime ( ) - start ) ; try { return condition . await ( time , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException ex ) { throw new AssertionError ( ex ) ; } } public void awaitResults ( ) throws ReadFailureException , ReadTimeoutException { boolean signaled = await ( command . getTimeout ( ) , TimeUnit . MILLISECONDS ) ; boolean failed = blockfor + failures > endpoints . size ( ) ; if ( signaled & & ! failed ) return ; if ( Tracing . isTracing ( ) ) { String gotData = received > <int> ? ( resolver . isDataPresent ( ) ? <str> : <str> ) : <str> ; Tracing . trace ( <str> , new Object [ ] { ( failed ? <str> : <str> ) , received , blockfor , gotData } ) ; } else if ( logger . isDebugEnabled ( ) ) { String gotData = received > <int> ? ( resolver . isDataPresent ( ) ? <str> : <str> ) : <str> ; logger . debug ( <str> , new Object [ ] { ( failed ? <str> : <str> ) , received , blockfor , gotData } ) ; } throw failed ? new ReadFailureException ( consistencyLevel , received , failures , blockfor , resolver . isDataPresent ( ) ) : new ReadTimeoutException ( consistencyLevel , received , blockfor , resolver . isDataPresent ( ) ) ; } public PartitionIterator get ( ) throws ReadFailureException , ReadTimeoutException , DigestMismatchException { awaitResults ( ) ; PartitionIterator result = blockfor = = <int> ? resolver . getData ( ) : resolver . resolve ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; return result ; } public int blockFor ( ) { return blockfor ; } public void response ( MessageIn < ReadResponse > message ) { resolver . preprocess ( message ) ; int n = waitingFor ( message . from ) ? recievedUpdater . incrementAndGet ( this ) : received ; if ( n > = blockfor & & resolver . isDataPresent ( ) ) { condition . signalAll ( ) ; if ( blockfor < endpoints . size ( ) & & n = = endpoints . size ( ) ) { TraceState traceState = Tracing . instance . get ( ) ; if ( traceState ! = null ) traceState . trace ( <str> ) ; StageManager . getStage ( Stage . READ_REPAIR ) . execute ( new AsyncRepairRunner ( traceState ) ) ; } } } private boolean waitingFor ( InetAddress from ) { return consistencyLevel . isDatacenterLocal ( ) ? DatabaseDescriptor . getLocalDataCenter ( ) . equals ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( from ) ) : true ; } public int getReceivedCount ( ) { return received ; } public void response ( ReadResponse result ) { MessageIn < ReadResponse > message = MessageIn . create ( FBUtilities . getBroadcastAddress ( ) , result , Collections . < String , byte [ ] > emptyMap ( ) , MessagingService . Verb . INTERNAL_RESPONSE , MessagingService . current_version , MessageIn . createTimestamp ( ) ) ; response ( message ) ; } public void assureSufficientLiveNodes ( ) throws UnavailableException { consistencyLevel . assureSufficientLiveNodes ( keyspace , endpoints ) ; } public boolean isLatencyForSnitch ( ) { return true ; } private class AsyncRepairRunner implements Runnable { private final TraceState traceState ; public AsyncRepairRunner ( TraceState traceState ) { this . traceState = traceState ; } public void run ( ) { try { resolver . resolve ( ) ; } catch ( DigestMismatchException e ) { assert resolver instanceof DigestResolver ; if ( traceState ! = null ) traceState . trace ( <str> , e . toString ( ) ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , e ) ; ReadRepairMetrics . repairedBackground . mark ( ) ; final DataResolver repairResolver = new DataResolver ( keyspace , command , consistencyLevel , endpoints . size ( ) ) ; AsyncRepairCallback repairHandler = new AsyncRepairCallback ( repairResolver , endpoints . size ( ) ) ; for ( InetAddress endpoint : endpoints ) { MessageOut < ReadCommand > message = command . createMessage ( MessagingService . instance ( ) . getVersion ( endpoint ) ) ; MessagingService . instance ( ) . sendRR ( message , endpoint , repairHandler ) ; } } } } @Override public void onFailure ( InetAddress from ) { int n = waitingFor ( from ) ? failuresUpdater . incrementAndGet ( this ) : failures ; if ( blockfor + n > endpoints . size ( ) ) condition . signalAll ( ) ; } } 
