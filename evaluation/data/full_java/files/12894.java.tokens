package org . gradle . internal . resource . transfer ; import com . google . common . io . Files ; import org . apache . commons . io . IOUtils ; import org . gradle . api . Nullable ; import org . gradle . api . Transformer ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . artifacts . ivyservice . CacheLockingManager ; import org . gradle . api . internal . artifacts . ivyservice . resolutionstrategy . DefaultExternalResourceCachePolicy ; import org . gradle . api . internal . artifacts . ivyservice . resolutionstrategy . ExternalResourceCachePolicy ; import org . gradle . api . internal . file . TemporaryFileProvider ; import org . gradle . internal . Factory ; import org . gradle . internal . hash . HashUtil ; import org . gradle . internal . hash . HashValue ; import org . gradle . internal . resource . ExternalResource ; import org . gradle . internal . resource . ResourceException ; import org . gradle . internal . resource . cached . CachedExternalResource ; import org . gradle . internal . resource . cached . CachedExternalResourceIndex ; import org . gradle . internal . resource . local . * ; import org . gradle . internal . resource . metadata . ExternalResourceMetaData ; import org . gradle . internal . resource . metadata . ExternalResourceMetaDataCompare ; import org . gradle . internal . resource . transport . ExternalResourceRepository ; import org . gradle . util . BuildCommencedTimeProvider ; import org . gradle . util . GFileUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URI ; public class DefaultCacheAwareExternalResourceAccessor implements CacheAwareExternalResourceAccessor { private static final Logger LOGGER = LoggerFactory . getLogger ( DefaultCacheAwareExternalResourceAccessor . class ) ; private final ExternalResourceRepository delegate ; private final CachedExternalResourceIndex < String > cachedExternalResourceIndex ; private final BuildCommencedTimeProvider timeProvider ; private final TemporaryFileProvider temporaryFileProvider ; private final CacheLockingManager cacheLockingManager ; private final ExternalResourceCachePolicy externalResourceCachePolicy = new DefaultExternalResourceCachePolicy ( ) ; public DefaultCacheAwareExternalResourceAccessor ( ExternalResourceRepository delegate , CachedExternalResourceIndex < String > cachedExternalResourceIndex , BuildCommencedTimeProvider timeProvider , TemporaryFileProvider temporaryFileProvider , CacheLockingManager cacheLockingManager ) { this . delegate = delegate ; this . cachedExternalResourceIndex = cachedExternalResourceIndex ; this . timeProvider = timeProvider ; this . temporaryFileProvider = temporaryFileProvider ; this . cacheLockingManager = cacheLockingManager ; } public LocallyAvailableExternalResource getResource ( final URI location , final ResourceFileStore fileStore , @Nullable LocallyAvailableResourceCandidates localCandidates ) throws IOException { LOGGER . debug ( <str> , location ) ; CachedExternalResource cached = cachedExternalResourceIndex . lookup ( location . toString ( ) ) ; if ( cached = = null & & ( localCandidates = = null | | localCandidates . isNone ( ) ) ) { return copyToCache ( location , fileStore , delegate . withProgressLogging ( ) . getResource ( location ) ) ; } if ( cached ! = null & & ! externalResourceCachePolicy . mustRefreshExternalResource ( getAgeMillis ( timeProvider , cached ) ) ) { return new DefaultLocallyAvailableExternalResource ( location , new DefaultLocallyAvailableResource ( cached . getCachedFile ( ) ) , cached . getExternalResourceMetaData ( ) ) ; } final ExternalResourceMetaData remoteMetaData = delegate . getResourceMetaData ( location ) ; if ( remoteMetaData = = null ) { return null ; } if ( cached ! = null ) { boolean isUnchanged = ExternalResourceMetaDataCompare . isDefinitelyUnchanged ( cached . getExternalResourceMetaData ( ) , new Factory < ExternalResourceMetaData > ( ) { public ExternalResourceMetaData create ( ) { return remoteMetaData ; } } ) ; if ( isUnchanged ) { LOGGER . info ( <str> , cached . getExternalLastModified ( ) , location ) ; return new DefaultLocallyAvailableExternalResource ( location , new DefaultLocallyAvailableResource ( cached . getCachedFile ( ) ) , cached . getExternalResourceMetaData ( ) ) ; } } boolean hasLocalCandidates = localCandidates ! = null & & ! localCandidates . isNone ( ) ; if ( hasLocalCandidates ) { HashValue remoteChecksum = remoteMetaData . getSha1 ( ) ; if ( remoteChecksum = = null ) { remoteChecksum = getResourceSha1 ( location ) ; } if ( remoteChecksum ! = null ) { LocallyAvailableResource local = localCandidates . findByHashValue ( remoteChecksum ) ; if ( local ! = null ) { LOGGER . info ( <str> , location , local . getFile ( ) ) ; LocallyAvailableExternalResource resource = copyCandidateToCache ( location , fileStore , remoteMetaData , remoteChecksum , local ) ; if ( resource ! = null ) { return resource ; } } } } return copyToCache ( location , fileStore , delegate . withProgressLogging ( ) . getResource ( location ) ) ; } private HashValue getResourceSha1 ( URI location ) { try { URI sha1Location = new URI ( location . toASCIIString ( ) + <str> ) ; ExternalResource resource = delegate . getResource ( sha1Location ) ; if ( resource = = null ) { return null ; } try { return resource . withContent ( new Transformer < HashValue , InputStream > ( ) { @Override public HashValue transform ( InputStream inputStream ) { try { String sha = IOUtils . toString ( inputStream , <str> ) ; return HashValue . parse ( sha ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } } ) ; } finally { resource . close ( ) ; } } catch ( Exception e ) { throw new ResourceException ( location , String . format ( <str> , location ) , e ) ; } } private LocallyAvailableExternalResource copyCandidateToCache ( URI source , ResourceFileStore fileStore , ExternalResourceMetaData remoteMetaData , HashValue remoteChecksum , LocallyAvailableResource local ) throws IOException { final File destination = temporaryFileProvider . createTemporaryFile ( <str> , <str> ) ; try { Files . copy ( local . getFile ( ) , destination ) ; HashValue localChecksum = HashUtil . createHash ( destination , <str> ) ; if ( ! localChecksum . equals ( remoteChecksum ) ) { return null ; } return moveIntoCache ( source , destination , fileStore , remoteMetaData ) ; } finally { destination . delete ( ) ; } } private LocallyAvailableExternalResource copyToCache ( URI source , ResourceFileStore fileStore , ExternalResource resource ) { if ( resource = = null ) { return null ; } final File destination = temporaryFileProvider . createTemporaryFile ( <str> , <str> ) ; try { final DownloadToFileAction downloadAction = new DownloadToFileAction ( destination ) ; try { try { LOGGER . debug ( <str> , source , destination ) ; if ( destination . getParentFile ( ) ! = null ) { GFileUtils . mkdirs ( destination . getParentFile ( ) ) ; } resource . withContent ( downloadAction ) ; } finally { resource . close ( ) ; } } catch ( Exception e ) { throw ResourceException . failure ( source , String . format ( <str> , source ) , e ) ; } return moveIntoCache ( source , destination , fileStore , downloadAction . metaData ) ; } finally { destination . delete ( ) ; } } private LocallyAvailableExternalResource moveIntoCache ( final URI source , final File destination , final ResourceFileStore fileStore , final ExternalResourceMetaData metaData ) { return cacheLockingManager . useCache ( String . format ( <str> , source ) , new Factory < LocallyAvailableExternalResource > ( ) { public LocallyAvailableExternalResource create ( ) { LocallyAvailableResource cachedResource = fileStore . moveIntoCache ( destination ) ; File fileInFileStore = cachedResource . getFile ( ) ; cachedExternalResourceIndex . store ( source . toString ( ) , fileInFileStore , metaData ) ; return new DefaultLocallyAvailableExternalResource ( source , cachedResource , metaData ) ; } } ) ; } public long getAgeMillis ( BuildCommencedTimeProvider timeProvider , CachedExternalResource cached ) { return timeProvider . getCurrentTime ( ) - cached . getCachedAt ( ) ; } private static class DownloadToFileAction implements ExternalResource . ContentAction < Object > { private final File destination ; private ExternalResourceMetaData metaData ; public DownloadToFileAction ( File destination ) { this . destination = destination ; } @Override public Object execute ( InputStream inputStream , ExternalResourceMetaData metaData ) throws IOException { this . metaData = metaData ; FileOutputStream outputStream = new FileOutputStream ( destination ) ; try { IOUtils . copyLarge ( inputStream , outputStream ) ; } finally { outputStream . close ( ) ; } return null ; } } } 
