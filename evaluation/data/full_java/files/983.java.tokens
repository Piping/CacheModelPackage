package org . apache . cassandra . streaming ; import java . io . BufferedOutputStream ; import java . io . IOException ; import java . net . Socket ; import java . net . SocketException ; import java . nio . ByteBuffer ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . nio . channels . WritableByteChannel ; import java . util . Collection ; import java . util . Comparator ; import java . util . concurrent . PriorityBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import com . google . common . util . concurrent . Futures ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . common . util . concurrent . SettableFuture ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . io . util . DataOutputStreamPlus ; import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; import org . apache . cassandra . streaming . messages . StreamInitMessage ; import org . apache . cassandra . streaming . messages . StreamMessage ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . JVMStabilityInspector ; public class ConnectionHandler { private static final Logger logger = LoggerFactory . getLogger ( ConnectionHandler . class ) ; private final StreamSession session ; private IncomingMessageHandler incoming ; private OutgoingMessageHandler outgoing ; ConnectionHandler ( StreamSession session ) { this . session = session ; this . incoming = new IncomingMessageHandler ( session ) ; this . outgoing = new OutgoingMessageHandler ( session ) ; } @SuppressWarnings ( <str> ) public void initiate ( ) throws IOException { logger . debug ( <str> , session . planId ( ) ) ; Socket incomingSocket = session . createConnection ( ) ; incoming . start ( incomingSocket , StreamMessage . CURRENT_VERSION ) ; incoming . sendInitMessage ( incomingSocket , true ) ; logger . debug ( <str> , session . planId ( ) ) ; Socket outgoingSocket = session . createConnection ( ) ; outgoing . start ( outgoingSocket , StreamMessage . CURRENT_VERSION ) ; outgoing . sendInitMessage ( outgoingSocket , false ) ; } public void initiateOnReceivingSide ( Socket socket , boolean isForOutgoing , int version ) throws IOException { if ( isForOutgoing ) outgoing . start ( socket , version ) ; else incoming . start ( socket , version ) ; } public ListenableFuture < ? > close ( ) { logger . debug ( <str> , session . planId ( ) , session . peer ) ; ListenableFuture < ? > inClosed = incoming = = null ? Futures . immediateFuture ( null ) : incoming . close ( ) ; ListenableFuture < ? > outClosed = outgoing = = null ? Futures . immediateFuture ( null ) : outgoing . close ( ) ; return Futures . allAsList ( inClosed , outClosed ) ; } public void sendMessages ( Collection < ? extends StreamMessage > messages ) { for ( StreamMessage message : messages ) sendMessage ( message ) ; } public void sendMessage ( StreamMessage message ) { if ( outgoing . isClosed ( ) ) throw new RuntimeException ( <str> ) ; outgoing . enqueue ( message ) ; } public boolean isOutgoingConnected ( ) { return outgoing ! = null & & ! outgoing . isClosed ( ) ; } abstract static class MessageHandler implements Runnable { protected final StreamSession session ; protected int protocolVersion ; protected Socket socket ; private final AtomicReference < SettableFuture < ? > > closeFuture = new AtomicReference < > ( ) ; protected MessageHandler ( StreamSession session ) { this . session = session ; } protected abstract String name ( ) ; @SuppressWarnings ( <str> ) protected static DataOutputStreamPlus getWriteChannel ( Socket socket ) throws IOException { WritableByteChannel out = socket . getChannel ( ) ; if ( out = = null ) return new WrappedDataOutputStreamPlus ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; return new BufferedDataOutputStreamPlus ( out ) ; } protected static ReadableByteChannel getReadChannel ( Socket socket ) throws IOException { ReadableByteChannel in = socket . getChannel ( ) ; return in = = null ? Channels . newChannel ( socket . getInputStream ( ) ) : in ; } @SuppressWarnings ( <str> ) public void sendInitMessage ( Socket socket , boolean isForOutgoing ) throws IOException { StreamInitMessage message = new StreamInitMessage ( FBUtilities . getBroadcastAddress ( ) , session . sessionIndex ( ) , session . planId ( ) , session . description ( ) , isForOutgoing , session . keepSSTableLevel ( ) , session . isIncremental ( ) ) ; ByteBuffer messageBuf = message . createMessage ( false , protocolVersion ) ; DataOutputStreamPlus out = getWriteChannel ( socket ) ; out . write ( messageBuf ) ; out . flush ( ) ; } public void start ( Socket socket , int protocolVersion ) { this . socket = socket ; this . protocolVersion = protocolVersion ; new Thread ( this , name ( ) + <str> + session . peer ) . start ( ) ; } public ListenableFuture < ? > close ( ) { SettableFuture < ? > future = SettableFuture . create ( ) ; return closeFuture . compareAndSet ( null , future ) ? future : closeFuture . get ( ) ; } public boolean isClosed ( ) { return closeFuture . get ( ) ! = null ; } protected void signalCloseDone ( ) { closeFuture . get ( ) . set ( null ) ; try { socket . close ( ) ; } catch ( IOException e ) { logger . debug ( <str> , e ) ; } } } static class IncomingMessageHandler extends MessageHandler { IncomingMessageHandler ( StreamSession session ) { super ( session ) ; } protected String name ( ) { return <str> ; } @SuppressWarnings ( <str> ) public void run ( ) { try { ReadableByteChannel in = getReadChannel ( socket ) ; while ( ! isClosed ( ) ) { StreamMessage message = StreamMessage . deserialize ( in , protocolVersion , session ) ; if ( message ! = null ) { logger . debug ( <str> , session . planId ( ) , message ) ; session . messageReceived ( message ) ; } } } catch ( SocketException e ) { close ( ) ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; session . onError ( t ) ; } finally { signalCloseDone ( ) ; } } } static class OutgoingMessageHandler extends MessageHandler { private final PriorityBlockingQueue < StreamMessage > messageQueue = new PriorityBlockingQueue < > ( <int> , new Comparator < StreamMessage > ( ) { public int compare ( StreamMessage o1 , StreamMessage o2 ) { return o2 . getPriority ( ) - o1 . getPriority ( ) ; } } ) ; OutgoingMessageHandler ( StreamSession session ) { super ( session ) ; } protected String name ( ) { return <str> ; } public void enqueue ( StreamMessage message ) { messageQueue . put ( message ) ; } @SuppressWarnings ( <str> ) public void run ( ) { try { DataOutputStreamPlus out = getWriteChannel ( socket ) ; StreamMessage next ; while ( ! isClosed ( ) ) { if ( ( next = messageQueue . poll ( <int> , TimeUnit . SECONDS ) ) ! = null ) { logger . debug ( <str> , session . planId ( ) , next ) ; sendMessage ( out , next ) ; if ( next . type = = StreamMessage . Type . SESSION_FAILED ) close ( ) ; } } while ( ( next = messageQueue . poll ( ) ) ! = null ) sendMessage ( out , next ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } catch ( Throwable e ) { session . onError ( e ) ; } finally { signalCloseDone ( ) ; } } private void sendMessage ( DataOutputStreamPlus out , StreamMessage message ) { try { StreamMessage . serialize ( message , out , protocolVersion , session ) ; out . flush ( ) ; } catch ( SocketException e ) { session . onError ( e ) ; close ( ) ; } catch ( IOException e ) { session . onError ( e ) ; } } } } 
