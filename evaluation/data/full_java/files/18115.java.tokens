package com . badlogic . gdx . graphics . glutils ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . IntBuffer ; import java . util . HashMap ; import java . util . Map ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GLTexture ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; public abstract class GLFrameBuffer < T extends GLTexture > implements Disposable { private final static Map < Application , Array < GLFrameBuffer > > buffers = new HashMap < Application , Array < GLFrameBuffer > > ( ) ; private final static int GL_DEPTH24_STENCIL8_OES = <hex> ; protected T colorTexture ; private static int defaultFramebufferHandle ; private static boolean defaultFramebufferHandleInitialized = false ; private int framebufferHandle ; private int depthbufferHandle ; private int stencilbufferHandle ; private int depthStencilPackedBufferHandle ; protected final int width ; protected final int height ; protected final boolean hasDepth ; protected final boolean hasStencil ; private boolean hasDepthStencilPackedBuffer ; protected final Pixmap . Format format ; public GLFrameBuffer ( Pixmap . Format format , int width , int height , boolean hasDepth ) { this ( format , width , height , hasDepth , false ) ; } public GLFrameBuffer ( Pixmap . Format format , int width , int height , boolean hasDepth , boolean hasStencil ) { this . width = width ; this . height = height ; this . format = format ; this . hasDepth = hasDepth ; this . hasStencil = hasStencil ; build ( ) ; addManagedFrameBuffer ( Gdx . app , this ) ; } protected abstract T createColorTexture ( ) ; protected abstract void disposeColorTexture ( T colorTexture ) ; private void build ( ) { GL20 gl = Gdx . gl20 ; if ( ! defaultFramebufferHandleInitialized ) { defaultFramebufferHandleInitialized = true ; if ( Gdx . app . getType ( ) = = ApplicationType . iOS ) { IntBuffer intbuf = ByteBuffer . allocateDirect ( <int> * Integer . SIZE / <int> ) . order ( ByteOrder . nativeOrder ( ) ) . asIntBuffer ( ) ; gl . glGetIntegerv ( GL20 . GL_FRAMEBUFFER_BINDING , intbuf ) ; defaultFramebufferHandle = intbuf . get ( <int> ) ; } else { defaultFramebufferHandle = <int> ; } } colorTexture = createColorTexture ( ) ; framebufferHandle = gl . glGenFramebuffer ( ) ; if ( hasDepth ) { depthbufferHandle = gl . glGenRenderbuffer ( ) ; } if ( hasStencil ) { stencilbufferHandle = gl . glGenRenderbuffer ( ) ; } gl . glBindTexture ( GL20 . GL_TEXTURE_2D , colorTexture . getTextureObjectHandle ( ) ) ; if ( hasDepth ) { gl . glBindRenderbuffer ( GL20 . GL_RENDERBUFFER , depthbufferHandle ) ; gl . glRenderbufferStorage ( GL20 . GL_RENDERBUFFER , GL20 . GL_DEPTH_COMPONENT16 , colorTexture . getWidth ( ) , colorTexture . getHeight ( ) ) ; } if ( hasStencil ) { gl . glBindRenderbuffer ( GL20 . GL_RENDERBUFFER , stencilbufferHandle ) ; gl . glRenderbufferStorage ( GL20 . GL_RENDERBUFFER , GL20 . GL_STENCIL_INDEX8 , colorTexture . getWidth ( ) , colorTexture . getHeight ( ) ) ; } gl . glBindFramebuffer ( GL20 . GL_FRAMEBUFFER , framebufferHandle ) ; gl . glFramebufferTexture2D ( GL20 . GL_FRAMEBUFFER , GL20 . GL_COLOR_ATTACHMENT0 , GL20 . GL_TEXTURE_2D , colorTexture . getTextureObjectHandle ( ) , <int> ) ; if ( hasDepth ) { gl . glFramebufferRenderbuffer ( GL20 . GL_FRAMEBUFFER , GL20 . GL_DEPTH_ATTACHMENT , GL20 . GL_RENDERBUFFER , depthbufferHandle ) ; } if ( hasStencil ) { gl . glFramebufferRenderbuffer ( GL20 . GL_FRAMEBUFFER , GL20 . GL_STENCIL_ATTACHMENT , GL20 . GL_RENDERBUFFER , stencilbufferHandle ) ; } gl . glBindRenderbuffer ( GL20 . GL_RENDERBUFFER , <int> ) ; gl . glBindTexture ( GL20 . GL_TEXTURE_2D , <int> ) ; int result = gl . glCheckFramebufferStatus ( GL20 . GL_FRAMEBUFFER ) ; if ( result = = GL20 . GL_FRAMEBUFFER_UNSUPPORTED & & hasDepth & & hasStencil & & ( Gdx . graphics . supportsExtension ( <str> ) | | Gdx . graphics . supportsExtension ( <str> ) ) ) { if ( hasDepth ) { gl . glDeleteRenderbuffer ( depthbufferHandle ) ; depthbufferHandle = <int> ; } if ( hasStencil ) { gl . glDeleteRenderbuffer ( stencilbufferHandle ) ; stencilbufferHandle = <int> ; } depthStencilPackedBufferHandle = gl . glGenRenderbuffer ( ) ; hasDepthStencilPackedBuffer = true ; gl . glBindRenderbuffer ( GL20 . GL_RENDERBUFFER , depthStencilPackedBufferHandle ) ; gl . glRenderbufferStorage ( GL20 . GL_RENDERBUFFER , GL_DEPTH24_STENCIL8_OES , colorTexture . getWidth ( ) , colorTexture . getHeight ( ) ) ; gl . glBindRenderbuffer ( GL20 . GL_RENDERBUFFER , <int> ) ; gl . glFramebufferRenderbuffer ( GL20 . GL_FRAMEBUFFER , GL20 . GL_DEPTH_ATTACHMENT , GL20 . GL_RENDERBUFFER , depthStencilPackedBufferHandle ) ; gl . glFramebufferRenderbuffer ( GL20 . GL_FRAMEBUFFER , GL20 . GL_STENCIL_ATTACHMENT , GL20 . GL_RENDERBUFFER , depthStencilPackedBufferHandle ) ; result = gl . glCheckFramebufferStatus ( GL20 . GL_FRAMEBUFFER ) ; } gl . glBindFramebuffer ( GL20 . GL_FRAMEBUFFER , defaultFramebufferHandle ) ; if ( result ! = GL20 . GL_FRAMEBUFFER_COMPLETE ) { disposeColorTexture ( colorTexture ) ; if ( hasDepthStencilPackedBuffer ) { gl . glDeleteBuffer ( depthStencilPackedBufferHandle ) ; } else { if ( hasDepth ) gl . glDeleteRenderbuffer ( depthbufferHandle ) ; if ( hasStencil ) gl . glDeleteRenderbuffer ( stencilbufferHandle ) ; } gl . glDeleteFramebuffer ( framebufferHandle ) ; if ( result = = GL20 . GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT ) throw new IllegalStateException ( <str> ) ; if ( result = = GL20 . GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS ) throw new IllegalStateException ( <str> ) ; if ( result = = GL20 . GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT ) throw new IllegalStateException ( <str> ) ; if ( result = = GL20 . GL_FRAMEBUFFER_UNSUPPORTED ) throw new IllegalStateException ( <str> ) ; throw new IllegalStateException ( <str> + result ) ; } } @Override public void dispose ( ) { GL20 gl = Gdx . gl20 ; disposeColorTexture ( colorTexture ) ; if ( hasDepthStencilPackedBuffer ) { gl . glDeleteRenderbuffer ( depthStencilPackedBufferHandle ) ; } else { if ( hasDepth ) gl . glDeleteRenderbuffer ( depthbufferHandle ) ; if ( hasStencil ) gl . glDeleteRenderbuffer ( stencilbufferHandle ) ; } gl . glDeleteFramebuffer ( framebufferHandle ) ; if ( buffers . get ( Gdx . app ) ! = null ) buffers . get ( Gdx . app ) . removeValue ( this , true ) ; } public void bind ( ) { Gdx . gl20 . glBindFramebuffer ( GL20 . GL_FRAMEBUFFER , framebufferHandle ) ; } public static void unbind ( ) { Gdx . gl20 . glBindFramebuffer ( GL20 . GL_FRAMEBUFFER , defaultFramebufferHandle ) ; } public void begin ( ) { bind ( ) ; setFrameBufferViewport ( ) ; } protected void setFrameBufferViewport ( ) { Gdx . gl20 . glViewport ( <int> , <int> , colorTexture . getWidth ( ) , colorTexture . getHeight ( ) ) ; } public void end ( ) { end ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; } public void end ( int x , int y , int width , int height ) { unbind ( ) ; Gdx . gl20 . glViewport ( x , y , width , height ) ; } public T getColorBufferTexture ( ) { return colorTexture ; } public int getFramebufferHandle ( ) { return framebufferHandle ; } public int getDepthBufferHandle ( ) { return depthbufferHandle ; } public int getStencilBufferHandle ( ) { return stencilbufferHandle ; } protected int getDepthStencilPackedBuffer ( ) { return depthStencilPackedBufferHandle ; } public int getHeight ( ) { return colorTexture . getHeight ( ) ; } public int getWidth ( ) { return colorTexture . getWidth ( ) ; } public int getDepth ( ) { return colorTexture . getDepth ( ) ; } private static void addManagedFrameBuffer ( Application app , GLFrameBuffer frameBuffer ) { Array < GLFrameBuffer > managedResources = buffers . get ( app ) ; if ( managedResources = = null ) managedResources = new Array < GLFrameBuffer > ( ) ; managedResources . add ( frameBuffer ) ; buffers . put ( app , managedResources ) ; } public static void invalidateAllFrameBuffers ( Application app ) { if ( Gdx . gl20 = = null ) return ; Array < GLFrameBuffer > bufferArray = buffers . get ( app ) ; if ( bufferArray = = null ) return ; for ( int i = <int> ; i < bufferArray . size ; i + + ) { bufferArray . get ( i ) . build ( ) ; } } public static void clearAllFrameBuffers ( Application app ) { buffers . remove ( app ) ; } public static StringBuilder getManagedStatus ( final StringBuilder builder ) { builder . append ( <str> ) ; for ( Application app : buffers . keySet ( ) ) { builder . append ( buffers . get ( app ) . size ) ; builder . append ( <str> ) ; } builder . append ( <str> ) ; return builder ; } public static String getManagedStatus ( ) { return getManagedStatus ( new StringBuilder ( ) ) . toString ( ) ; } } 
