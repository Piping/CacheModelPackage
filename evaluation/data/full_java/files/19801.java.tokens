package io . netty . example . http . file ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelProgressiveFuture ; import io . netty . channel . ChannelProgressiveFutureListener ; import io . netty . channel . DefaultFileRegion ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . DefaultHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpChunkedInput ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . stream . ChunkedFile ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . SystemPropertyUtil ; import javax . activation . MimetypesFileTypeMap ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . Locale ; import java . util . TimeZone ; import java . util . regex . Pattern ; import static io . netty . handler . codec . http . HttpMethod . * ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . * ; public class HttpStaticFileServerHandler extends SimpleChannelInboundHandler < FullHttpRequest > { public static final String HTTP_DATE_FORMAT = <str> ; public static final String HTTP_DATE_GMT_TIMEZONE = <str> ; public static final int HTTP_CACHE_SECONDS = <int> ; @Override public void channelRead0 ( ChannelHandlerContext ctx , FullHttpRequest request ) throws Exception { if ( ! request . decoderResult ( ) . isSuccess ( ) ) { sendError ( ctx , BAD_REQUEST ) ; return ; } if ( request . method ( ) ! = GET ) { sendError ( ctx , METHOD_NOT_ALLOWED ) ; return ; } final String uri = request . uri ( ) ; final String path = sanitizeUri ( uri ) ; if ( path = = null ) { sendError ( ctx , FORBIDDEN ) ; return ; } File file = new File ( path ) ; if ( file . isHidden ( ) | | ! file . exists ( ) ) { sendError ( ctx , NOT_FOUND ) ; return ; } if ( file . isDirectory ( ) ) { if ( uri . endsWith ( <str> ) ) { sendListing ( ctx , file ) ; } else { sendRedirect ( ctx , uri + <str> ) ; } return ; } if ( ! file . isFile ( ) ) { sendError ( ctx , FORBIDDEN ) ; return ; } String ifModifiedSince = request . headers ( ) . get ( HttpHeaderNames . IF_MODIFIED_SINCE ) ; if ( ifModifiedSince ! = null & & ! ifModifiedSince . isEmpty ( ) ) { SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; Date ifModifiedSinceDate = dateFormatter . parse ( ifModifiedSince ) ; long ifModifiedSinceDateSeconds = ifModifiedSinceDate . getTime ( ) / <int> ; long fileLastModifiedSeconds = file . lastModified ( ) / <int> ; if ( ifModifiedSinceDateSeconds = = fileLastModifiedSeconds ) { sendNotModified ( ctx ) ; return ; } } RandomAccessFile raf ; try { raf = new RandomAccessFile ( file , <str> ) ; } catch ( FileNotFoundException ignore ) { sendError ( ctx , NOT_FOUND ) ; return ; } long fileLength = raf . length ( ) ; HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; HttpUtil . setContentLength ( response , fileLength ) ; setContentTypeHeader ( response , file ) ; setDateAndCacheHeaders ( response , file ) ; if ( HttpUtil . isKeepAlive ( request ) ) { response . headers ( ) . set ( HttpHeaderNames . CONNECTION , HttpHeaderValues . KEEP_ALIVE ) ; } ctx . write ( response ) ; ChannelFuture sendFileFuture ; ChannelFuture lastContentFuture ; if ( ctx . pipeline ( ) . get ( SslHandler . class ) = = null ) { sendFileFuture = ctx . write ( new DefaultFileRegion ( raf . getChannel ( ) , <int> , fileLength ) , ctx . newProgressivePromise ( ) ) ; lastContentFuture = ctx . writeAndFlush ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } else { sendFileFuture = ctx . writeAndFlush ( new HttpChunkedInput ( new ChunkedFile ( raf , <int> , fileLength , <int> ) ) , ctx . newProgressivePromise ( ) ) ; lastContentFuture = sendFileFuture ; } sendFileFuture . addListener ( new ChannelProgressiveFutureListener ( ) { @Override public void operationProgressed ( ChannelProgressiveFuture future , long progress , long total ) { if ( total < <int> ) { System . err . println ( future . channel ( ) + <str> + progress ) ; } else { System . err . println ( future . channel ( ) + <str> + progress + <str> + total ) ; } } @Override public void operationComplete ( ChannelProgressiveFuture future ) { System . err . println ( future . channel ( ) + <str> ) ; } } ) ; if ( ! HttpUtil . isKeepAlive ( request ) ) { lastContentFuture . addListener ( ChannelFutureListener . CLOSE ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; if ( ctx . channel ( ) . isActive ( ) ) { sendError ( ctx , INTERNAL_SERVER_ERROR ) ; } } private static final Pattern INSECURE_URI = Pattern . compile ( <str> ) ; private static String sanitizeUri ( String uri ) { try { uri = URLDecoder . decode ( uri , <str> ) ; } catch ( UnsupportedEncodingException e ) { throw new Error ( e ) ; } if ( uri . isEmpty ( ) | | uri . charAt ( <int> ) ! = <str> ) { return null ; } uri = uri . replace ( <str> , File . separatorChar ) ; if ( uri . contains ( File . separator + <str> ) | | uri . contains ( <str> + File . separator ) | | uri . charAt ( <int> ) = = <str> | | uri . charAt ( uri . length ( ) - <int> ) = = <str> | | INSECURE_URI . matcher ( uri ) . matches ( ) ) { return null ; } return SystemPropertyUtil . get ( <str> ) + File . separator + uri ; } private static final Pattern ALLOWED_FILE_NAME = Pattern . compile ( <str> ) ; private static void sendListing ( ChannelHandlerContext ctx , File dir ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , OK ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; String dirPath = dir . getPath ( ) ; StringBuilder buf = new StringBuilder ( ) . append ( <str> ) . append ( <str> ) . append ( <str> ) . append ( dirPath ) . append ( <str> ) . append ( <str> ) . append ( dirPath ) . append ( <str> ) . append ( <str> ) . append ( <str> ) ; for ( File f : dir . listFiles ( ) ) { if ( f . isHidden ( ) | | ! f . canRead ( ) ) { continue ; } String name = f . getName ( ) ; if ( ! ALLOWED_FILE_NAME . matcher ( name ) . matches ( ) ) { continue ; } buf . append ( <str> ) . append ( name ) . append ( <str> ) . append ( name ) . append ( <str> ) ; } buf . append ( <str> ) ; ByteBuf buffer = Unpooled . copiedBuffer ( buf , CharsetUtil . UTF_8 ) ; response . content ( ) . writeBytes ( buffer ) ; buffer . release ( ) ; ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } private static void sendRedirect ( ChannelHandlerContext ctx , String newUri ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , FOUND ) ; response . headers ( ) . set ( HttpHeaderNames . LOCATION , newUri ) ; ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } private static void sendError ( ChannelHandlerContext ctx , HttpResponseStatus status ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , status , Unpooled . copiedBuffer ( <str> + status + <str> , CharsetUtil . UTF_8 ) ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } private static void sendNotModified ( ChannelHandlerContext ctx ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , NOT_MODIFIED ) ; setDateHeader ( response ) ; ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } private static void setDateHeader ( FullHttpResponse response ) { SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; dateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; Calendar time = new GregorianCalendar ( ) ; response . headers ( ) . set ( HttpHeaderNames . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; } private static void setDateAndCacheHeaders ( HttpResponse response , File fileToCache ) { SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; dateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; Calendar time = new GregorianCalendar ( ) ; response . headers ( ) . set ( HttpHeaderNames . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; time . add ( Calendar . SECOND , HTTP_CACHE_SECONDS ) ; response . headers ( ) . set ( HttpHeaderNames . EXPIRES , dateFormatter . format ( time . getTime ( ) ) ) ; response . headers ( ) . set ( HttpHeaderNames . CACHE_CONTROL , <str> + HTTP_CACHE_SECONDS ) ; response . headers ( ) . set ( HttpHeaderNames . LAST_MODIFIED , dateFormatter . format ( new Date ( fileToCache . lastModified ( ) ) ) ) ; } private static void setContentTypeHeader ( HttpResponse response , File file ) { MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap ( ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , mimeTypesMap . getContentType ( file . getPath ( ) ) ) ; } } 
