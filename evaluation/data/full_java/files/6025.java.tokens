package org . elasticsearch . common . network ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . Constants ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public abstract class NetworkUtils { private NetworkUtils ( ) { } @Deprecated static final boolean PREFER_V6 = Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ; @Deprecated public static final boolean SUPPORTS_V6 ; static { boolean v = false ; try { for ( NetworkInterface nic : getInterfaces ( ) ) { for ( InetAddress address : Collections . list ( nic . getInetAddresses ( ) ) ) { if ( address instanceof Inet6Address ) { v = true ; break ; } } } } catch ( SecurityException | SocketException misconfiguration ) { v = true ; } SUPPORTS_V6 = v ; } static int sortKey ( InetAddress address , boolean prefer_v6 ) { int key = address . getAddress ( ) . length ; if ( prefer_v6 ) { key = - key ; } if ( address . isAnyLocalAddress ( ) ) { key + = <int> ; } if ( address . isMulticastAddress ( ) ) { key + = <int> ; } if ( address . isLoopbackAddress ( ) ) { key + = <int> ; } if ( address . isLinkLocalAddress ( ) ) { key + = <int> ; } if ( address . isSiteLocalAddress ( ) ) { key + = <int> ; } return key ; } @Deprecated public static void sortAddresses ( List < InetAddress > list ) { Collections . sort ( list , new Comparator < InetAddress > ( ) { @Override public int compare ( InetAddress left , InetAddress right ) { int cmp = Integer . compare ( sortKey ( left , PREFER_V6 ) , sortKey ( right , PREFER_V6 ) ) ; if ( cmp = = <int> ) { cmp = new BytesRef ( left . getAddress ( ) ) . compareTo ( new BytesRef ( right . getAddress ( ) ) ) ; } return cmp ; } } ) ; } static List < NetworkInterface > getInterfaces ( ) throws SocketException { List < NetworkInterface > all = new ArrayList < > ( ) ; addAllInterfaces ( all , Collections . list ( NetworkInterface . getNetworkInterfaces ( ) ) ) ; Collections . sort ( all , new Comparator < NetworkInterface > ( ) { @Override public int compare ( NetworkInterface left , NetworkInterface right ) { return Integer . compare ( left . getIndex ( ) , right . getIndex ( ) ) ; } } ) ; return all ; } private static void addAllInterfaces ( List < NetworkInterface > target , List < NetworkInterface > level ) { if ( ! level . isEmpty ( ) ) { target . addAll ( level ) ; for ( NetworkInterface intf : level ) { addAllInterfaces ( target , Collections . list ( intf . getSubInterfaces ( ) ) ) ; } } } public static boolean defaultReuseAddress ( ) { return Constants . WINDOWS ? false : true ; } static InetAddress [ ] getLoopbackAddresses ( ) throws SocketException { List < InetAddress > list = new ArrayList < > ( ) ; for ( NetworkInterface intf : getInterfaces ( ) ) { if ( intf . isUp ( ) ) { for ( InetAddress address : Collections . list ( intf . getInetAddresses ( ) ) ) { if ( intf . isLoopback ( ) | | address . isLoopbackAddress ( ) ) { list . add ( address ) ; } } } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + getInterfaces ( ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] getSiteLocalAddresses ( ) throws SocketException { List < InetAddress > list = new ArrayList < > ( ) ; for ( NetworkInterface intf : getInterfaces ( ) ) { if ( intf . isUp ( ) ) { for ( InetAddress address : Collections . list ( intf . getInetAddresses ( ) ) ) { if ( address . isSiteLocalAddress ( ) ) { list . add ( address ) ; } } } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + getInterfaces ( ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] getGlobalAddresses ( ) throws SocketException { List < InetAddress > list = new ArrayList < > ( ) ; for ( NetworkInterface intf : getInterfaces ( ) ) { if ( intf . isUp ( ) ) { for ( InetAddress address : Collections . list ( intf . getInetAddresses ( ) ) ) { if ( address . isLoopbackAddress ( ) = = false & & address . isSiteLocalAddress ( ) = = false & & address . isLinkLocalAddress ( ) = = false ) { list . add ( address ) ; } } } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + getInterfaces ( ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] getAllAddresses ( ) throws SocketException { List < InetAddress > list = new ArrayList < > ( ) ; for ( NetworkInterface intf : getInterfaces ( ) ) { if ( intf . isUp ( ) ) { for ( InetAddress address : Collections . list ( intf . getInetAddresses ( ) ) ) { list . add ( address ) ; } } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + getInterfaces ( ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] getAddressesForInterface ( String name ) throws SocketException { NetworkInterface intf = NetworkInterface . getByName ( name ) ; if ( intf = = null ) { throw new IllegalArgumentException ( <str> + name + <str> + getInterfaces ( ) ) ; } if ( ! intf . isUp ( ) ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } List < InetAddress > list = Collections . list ( intf . getInetAddresses ( ) ) ; if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] filterIPV4 ( InetAddress addresses [ ] ) { List < InetAddress > list = new ArrayList < > ( ) ; for ( InetAddress address : addresses ) { if ( address instanceof Inet4Address ) { list . add ( address ) ; } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + Arrays . toString ( addresses ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } static InetAddress [ ] filterIPV6 ( InetAddress addresses [ ] ) { List < InetAddress > list = new ArrayList < > ( ) ; for ( InetAddress address : addresses ) { if ( address instanceof Inet6Address ) { list . add ( address ) ; } } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + Arrays . toString ( addresses ) ) ; } return list . toArray ( new InetAddress [ list . size ( ) ] ) ; } } 
