package org . elasticsearch . discovery . zen ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . indices . recovery . RecoveryResponse ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoveryStats ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . fd . FaultDetection ; import org . elasticsearch . discovery . zen . membership . MembershipAction ; import org . elasticsearch . discovery . zen . publish . PublishClusterStateAction ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BytesTransportRequest ; import org . elasticsearch . transport . EmptyTransportResponseHandler ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; import static org . hamcrest . Matchers . sameInstance ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> , numClientNodes = <int> ) @ESIntegTestCase.SuppressLocalMode public class ZenDiscoveryIT extends ESIntegTestCase { public void testChangeRejoinOnMasterOptionIsDynamic ( ) throws Exception { Settings nodeSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; String nodeName = internalCluster ( ) . startNode ( nodeSettings ) ; ZenDiscovery zenDiscovery = ( ZenDiscovery ) internalCluster ( ) . getInstance ( Discovery . class , nodeName ) ; assertThat ( zenDiscovery . isRejoinOnMasterGone ( ) , is ( true ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( ZenDiscovery . SETTING_REJOIN_ON_MASTER_GONE , false ) ) . get ( ) ; assertThat ( zenDiscovery . isRejoinOnMasterGone ( ) , is ( false ) ) ; } public void testNoShardRelocationsOccurWhenElectedMasterNodeFails ( ) throws Exception { Settings defaultSettings = Settings . builder ( ) . put ( FaultDetection . SETTING_PING_TIMEOUT , <str> ) . put ( FaultDetection . SETTING_PING_RETRIES , <str> ) . put ( <str> , <str> ) . build ( ) ; Settings masterNodeSettings = Settings . builder ( ) . put ( <str> , false ) . put ( defaultSettings ) . build ( ) ; internalCluster ( ) . startNodesAsync ( <int> , masterNodeSettings ) . get ( ) ; Settings dateNodeSettings = Settings . builder ( ) . put ( <str> , false ) . put ( defaultSettings ) . build ( ) ; internalCluster ( ) . startNodesAsync ( <int> , dateNodeSettings ) . get ( ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , is ( false ) ) ; createIndex ( <str> ) ; ensureSearchable ( <str> ) ; RecoveryResponse r = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) ; int numRecoveriesBeforeNewMaster = r . shardRecoveryStates ( ) . get ( <str> ) . size ( ) ; final String oldMaster = internalCluster ( ) . getMasterName ( ) ; internalCluster ( ) . stopCurrentMasterNode ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { String current = internalCluster ( ) . getMasterName ( ) ; assertThat ( current , notNullValue ( ) ) ; assertThat ( current , not ( equalTo ( oldMaster ) ) ) ; } } ) ; ensureSearchable ( <str> ) ; r = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) ; int numRecoveriesAfterNewMaster = r . shardRecoveryStates ( ) . get ( <str> ) . size ( ) ; assertThat ( numRecoveriesAfterNewMaster , equalTo ( numRecoveriesBeforeNewMaster ) ) ; } @TestLogging ( value = <str> ) public void testNodeFailuresAreProcessedOnce ( ) throws ExecutionException , InterruptedException , IOException { Settings defaultSettings = Settings . builder ( ) . put ( FaultDetection . SETTING_PING_TIMEOUT , <str> ) . put ( FaultDetection . SETTING_PING_RETRIES , <str> ) . put ( <str> , <str> ) . build ( ) ; Settings masterNodeSettings = Settings . builder ( ) . put ( <str> , false ) . put ( defaultSettings ) . build ( ) ; String master = internalCluster ( ) . startNode ( masterNodeSettings ) ; Settings dateNodeSettings = Settings . builder ( ) . put ( <str> , false ) . put ( defaultSettings ) . build ( ) ; internalCluster ( ) . startNodesAsync ( <int> , dateNodeSettings ) . get ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class , master ) ; final ArrayList < ClusterState > statesFound = new ArrayList < > ( ) ; final CountDownLatch nodesStopped = new CountDownLatch ( <int> ) ; clusterService . add ( new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { statesFound . add ( event . state ( ) ) ; try { nodesStopped . await ( ) ; } catch ( InterruptedException e ) { } } } ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; nodesStopped . countDown ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . get ( ) ; assertThat ( statesFound , Matchers . hasSize ( <int> ) ) ; } public void testNodeRejectsClusterStateWithWrongMasterNode ( ) throws Exception { Settings settings = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; List < String > nodeNames = internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; List < String > nonMasterNodes = new ArrayList < > ( nodeNames ) ; nonMasterNodes . remove ( internalCluster ( ) . getMasterName ( ) ) ; String noneMasterNode = nonMasterNodes . get ( <int> ) ; ClusterState state = internalCluster ( ) . getInstance ( ClusterService . class ) . state ( ) ; DiscoveryNode node = null ; for ( DiscoveryNode discoveryNode : state . nodes ( ) ) { if ( discoveryNode . name ( ) . equals ( noneMasterNode ) ) { node = discoveryNode ; } } assert node ! = null ; DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( state . nodes ( ) ) . put ( new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . CURRENT ) ) . masterNodeId ( <str> ) ; ClusterState . Builder builder = ClusterState . builder ( state ) ; builder . nodes ( nodes ) ; BytesReference bytes = PublishClusterStateAction . serializeFullClusterState ( builder . build ( ) , node . version ( ) ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicReference < Exception > reference = new AtomicReference < > ( ) ; internalCluster ( ) . getInstance ( TransportService . class , noneMasterNode ) . sendRequest ( node , PublishClusterStateAction . SEND_ACTION_NAME , new BytesTransportRequest ( bytes , Version . CURRENT ) , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleResponse ( TransportResponse . Empty response ) { super . handleResponse ( response ) ; latch . countDown ( ) ; } @Override public void handleException ( TransportException exp ) { super . handleException ( exp ) ; reference . set ( exp ) ; latch . countDown ( ) ; } } ) ; latch . await ( ) ; assertThat ( reference . get ( ) , notNullValue ( ) ) ; assertThat ( ExceptionsHelper . detailedMessage ( reference . get ( ) ) , containsString ( <str> ) ) ; } public void testHandleNodeJoin_incompatibleMinVersion ( ) throws UnknownHostException { Settings nodeSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; String nodeName = internalCluster ( ) . startNode ( nodeSettings , Version . V_2_0_0_beta1 ) ; ZenDiscovery zenDiscovery = ( ZenDiscovery ) internalCluster ( ) . getInstance ( Discovery . class , nodeName ) ; DiscoveryNode node = new DiscoveryNode ( <str> , new InetSocketTransportAddress ( InetAddress . getByName ( <str> ) , <int> ) , Version . V_1_6_0 ) ; final AtomicReference < IllegalStateException > holder = new AtomicReference < > ( ) ; zenDiscovery . handleJoinRequest ( node , new MembershipAction . JoinCallback ( ) { @Override public void onSuccess ( ) { } @Override public void onFailure ( Throwable t ) { holder . set ( ( IllegalStateException ) t ) ; } } ) ; assertThat ( holder . get ( ) , notNullValue ( ) ) ; assertThat ( holder . get ( ) . getMessage ( ) , equalTo ( <str> + Version . V_2_0_0_beta1 . minimumCompatibilityVersion ( ) + <str> ) ) ; } public void testJoinElectedMaster_incompatibleMinVersion ( ) { ElectMasterService electMasterService = new ElectMasterService ( Settings . EMPTY , Version . V_2_0_0_beta1 ) ; DiscoveryNode node = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . V_2_0_0_beta1 ) ; assertThat ( electMasterService . electMaster ( Collections . singletonList ( node ) ) , sameInstance ( node ) ) ; node = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . V_1_6_0 ) ; assertThat ( <str> , electMasterService . electMaster ( Collections . singletonList ( node ) ) , nullValue ( ) ) ; } public void testDiscoveryStats ( ) throws IOException { String expectedStatsJsonResponse = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; Settings nodeSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( nodeSettings ) ; logger . info ( <str> ) ; NodesStatsResponse statsResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setDiscovery ( true ) . get ( ) ; assertThat ( statsResponse . getNodes ( ) . length , equalTo ( <int> ) ) ; DiscoveryStats stats = statsResponse . getNodes ( ) [ <int> ] . getDiscoveryStats ( ) ; assertThat ( stats . getQueueStats ( ) , notNullValue ( ) ) ; assertThat ( stats . getQueueStats ( ) . getTotal ( ) , equalTo ( <int> ) ) ; assertThat ( stats . getQueueStats ( ) . getCommitted ( ) , equalTo ( <int> ) ) ; assertThat ( stats . getQueueStats ( ) . getPending ( ) , equalTo ( <int> ) ) ; XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; stats . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( expectedStatsJsonResponse ) ) ; } } 
