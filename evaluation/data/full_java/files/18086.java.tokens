package com . badlogic . gdx . graphics . g3d . particles . values ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . math . CumulativeDistribution ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; public final class WeightMeshSpawnShapeValue extends MeshSpawnShapeValue { private CumulativeDistribution < Triangle > distribution ; public WeightMeshSpawnShapeValue ( WeightMeshSpawnShapeValue value ) { super ( value ) ; distribution = new CumulativeDistribution < Triangle > ( ) ; load ( value ) ; } public WeightMeshSpawnShapeValue ( ) { super ( ) ; distribution = new CumulativeDistribution < Triangle > ( ) ; } @Override public void init ( ) { calculateWeights ( ) ; } public void calculateWeights ( ) { distribution . clear ( ) ; VertexAttributes attributes = mesh . getVertexAttributes ( ) ; int indicesCount = mesh . getNumIndices ( ) ; int vertexCount = mesh . getNumVertices ( ) ; int vertexSize = ( short ) ( attributes . vertexSize / <int> ) , positionOffset = ( short ) ( attributes . findByUsage ( Usage . Position ) . offset / <int> ) ; float [ ] vertices = new float [ vertexCount * vertexSize ] ; mesh . getVertices ( vertices ) ; if ( indicesCount > <int> ) { short [ ] indices = new short [ indicesCount ] ; mesh . getIndices ( indices ) ; for ( int i = <int> ; i < indicesCount ; i + = <int> ) { int p1Offset = indices [ i ] * vertexSize + positionOffset , p2Offset = indices [ i + <int> ] * vertexSize + positionOffset , p3Offset = indices [ i + <int> ] * vertexSize + positionOffset ; float x1 = vertices [ p1Offset ] , y1 = vertices [ p1Offset + <int> ] , z1 = vertices [ p1Offset + <int> ] , x2 = vertices [ p2Offset ] , y2 = vertices [ p2Offset + <int> ] , z2 = vertices [ p2Offset + <int> ] , x3 = vertices [ p3Offset ] , y3 = vertices [ p3Offset + <int> ] , z3 = vertices [ p3Offset + <int> ] ; float area = Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / <float> ) ; distribution . add ( new Triangle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) , area ) ; } } else { for ( int i = <int> ; i < vertexCount ; i + = vertexSize ) { int p1Offset = i + positionOffset , p2Offset = p1Offset + vertexSize , p3Offset = p2Offset + vertexSize ; float x1 = vertices [ p1Offset ] , y1 = vertices [ p1Offset + <int> ] , z1 = vertices [ p1Offset + <int> ] , x2 = vertices [ p2Offset ] , y2 = vertices [ p2Offset + <int> ] , z2 = vertices [ p2Offset + <int> ] , x3 = vertices [ p3Offset ] , y3 = vertices [ p3Offset + <int> ] , z3 = vertices [ p3Offset + <int> ] ; float area = Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / <float> ) ; distribution . add ( new Triangle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) , area ) ; } } distribution . generateNormalized ( ) ; } @Override public void spawnAux ( Vector3 vector , float percent ) { Triangle t = distribution . value ( ) ; float a = MathUtils . random ( ) , b = MathUtils . random ( ) ; vector . set ( t . x1 + a * ( t . x2 - t . x1 ) + b * ( t . x3 - t . x1 ) , t . y1 + a * ( t . y2 - t . y1 ) + b * ( t . y3 - t . y1 ) , t . z1 + a * ( t . z2 - t . z1 ) + b * ( t . z3 - t . z1 ) ) ; } @Override public SpawnShapeValue copy ( ) { return new WeightMeshSpawnShapeValue ( this ) ; } } 
