package org . elasticsearch . search . aggregations . pipeline . movavg . models ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . pipeline . movavg . MovAvgParser ; import java . io . IOException ; import java . text . ParseException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; public class EwmaModel extends MovAvgModel { protected static final ParseField NAME_FIELD = new ParseField ( <str> ) ; private final double alpha ; public EwmaModel ( double alpha ) { this . alpha = alpha ; } @Override public boolean canBeMinimized ( ) { return true ; } @Override public MovAvgModel neighboringModel ( ) { double alpha = Math . random ( ) ; return new EwmaModel ( alpha ) ; } @Override public MovAvgModel clone ( ) { return new EwmaModel ( this . alpha ) ; } @Override protected < T extends Number > double [ ] doPredict ( Collection < T > values , int numPredictions ) { double [ ] predictions = new double [ numPredictions ] ; Arrays . fill ( predictions , next ( values ) ) ; return predictions ; } @Override public < T extends Number > double next ( Collection < T > values ) { double avg = <int> ; boolean first = true ; for ( T v : values ) { if ( first ) { avg = v . doubleValue ( ) ; first = false ; } else { avg = ( v . doubleValue ( ) * alpha ) + ( avg * ( <int> - alpha ) ) ; } } return avg ; } public static final MovAvgModelStreams . Stream STREAM = new MovAvgModelStreams . Stream ( ) { @Override public MovAvgModel readResult ( StreamInput in ) throws IOException { return new EwmaModel ( in . readDouble ( ) ) ; } @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } } ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; out . writeDouble ( alpha ) ; } public static class SingleExpModelParser extends AbstractModelParser { @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } @Override public MovAvgModel parse ( @Nullable Map < String , Object > settings , String pipelineName , int windowSize , ParseFieldMatcher parseFieldMatcher ) throws ParseException { double alpha = parseDoubleParam ( settings , <str> , <float> ) ; checkUnrecognizedParams ( settings ) ; return new EwmaModel ( alpha ) ; } } public static class EWMAModelBuilder implements MovAvgModelBuilder { private Double alpha ; public EWMAModelBuilder alpha ( double alpha ) { this . alpha = alpha ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( MovAvgParser . MODEL . getPreferredName ( ) , NAME_FIELD . getPreferredName ( ) ) ; builder . startObject ( MovAvgParser . SETTINGS . getPreferredName ( ) ) ; if ( alpha ! = null ) { builder . field ( <str> , alpha ) ; } builder . endObject ( ) ; return builder ; } } } 
