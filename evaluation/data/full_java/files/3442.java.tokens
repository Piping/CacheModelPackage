package org . nd4j . linalg . checkutil ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . apache . commons . math3 . linear . BlockRealMatrix ; import org . apache . commons . math3 . linear . RealMatrix ; import org . apache . commons . math3 . util . Pair ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; public class CheckUtil { public static boolean checkMmul ( INDArray first , INDArray second , double maxRelativeDifference , double minAbsDifference ) { if ( first . size ( <int> ) ! = second . size ( <int> ) ) throw new IllegalArgumentException ( <str> ) ; RealMatrix rmFirst = convertToApacheMatrix ( first ) ; RealMatrix rmSecond = convertToApacheMatrix ( second ) ; INDArray result = first . mmul ( second ) ; RealMatrix rmResult = rmFirst . multiply ( rmSecond ) ; if ( ! checkShape ( rmResult , result ) ) return false ; boolean ok = checkEntries ( rmResult , result , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray onCopies = Shape . toOffsetZeroCopy ( first ) . mmul ( Shape . toOffsetZeroCopy ( second ) ) ; printFailureDetails ( first , second , rmResult , result , onCopies , <str> ) ; } return ok ; } public static boolean checkGemm ( INDArray a , INDArray b , INDArray c , boolean transposeA , boolean transposeB , double alpha , double beta , double maxRelativeDifference , double minAbsDifference ) { int commonDimA = ( transposeA ? a . rows ( ) : a . columns ( ) ) ; int commonDimB = ( transposeB ? b . columns ( ) : b . rows ( ) ) ; if ( commonDimA ! = commonDimB ) throw new IllegalArgumentException ( <str> + Arrays . toString ( a . shape ( ) ) + <str> + Arrays . toString ( b . shape ( ) ) + <str> + transposeA + <str> + transposeB ) ; int outRows = ( transposeA ? a . columns ( ) : a . rows ( ) ) ; int outCols = ( transposeB ? b . rows ( ) : b . columns ( ) ) ; if ( c . rows ( ) ! = outRows | | c . columns ( ) ! = outCols ) throw new IllegalArgumentException ( <str> ) ; if ( c . offset ( ) ! = <int> | | c . ordering ( ) ! = <str> ) throw new IllegalArgumentException ( <str> ) ; RealMatrix rmA = convertToApacheMatrix ( transposeA ? a . transpose ( ) : a ) ; RealMatrix rmB = convertToApacheMatrix ( transposeB ? b . transpose ( ) : b ) ; RealMatrix rmC = convertToApacheMatrix ( c ) ; RealMatrix rmExpected = rmA . multiply ( rmB ) . scalarMultiply ( alpha ) . add ( rmC . scalarMultiply ( beta ) ) ; INDArray cCopy1 = Nd4j . create ( c . shape ( ) , <str> ) ; cCopy1 . assign ( c ) ; INDArray cCopy2 = Nd4j . create ( c . shape ( ) , <str> ) ; cCopy2 . assign ( c ) ; INDArray out = Nd4j . gemm ( a , b , c , transposeA , transposeB , alpha , beta ) ; if ( out ! = c ) { System . out . println ( <str> ) ; return false ; } if ( ! checkShape ( rmExpected , out ) ) return false ; boolean ok = checkEntries ( rmExpected , out , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray aCopy = Shape . toOffsetZeroCopy ( a ) ; INDArray bCopy = Shape . toOffsetZeroCopy ( b ) ; INDArray onCopies = Nd4j . gemm ( aCopy , bCopy , cCopy1 , transposeA , transposeB , alpha , beta ) ; printGemmFailureDetails ( a , b , cCopy2 , transposeA , transposeB , alpha , beta , rmExpected , out , onCopies ) ; } return ok ; } public static boolean checkAdd ( INDArray first , INDArray second , double maxRelativeDifference , double minAbsDifference ) { RealMatrix rmFirst = convertToApacheMatrix ( first ) ; RealMatrix rmSecond = convertToApacheMatrix ( second ) ; INDArray result = first . add ( second ) ; RealMatrix rmResult = rmFirst . add ( rmSecond ) ; if ( ! checkShape ( rmResult , result ) ) return false ; boolean ok = checkEntries ( rmResult , result , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray onCopies = Shape . toOffsetZeroCopy ( first ) . add ( Shape . toOffsetZeroCopy ( second ) ) ; printFailureDetails ( first , second , rmResult , result , onCopies , <str> ) ; } return ok ; } public static boolean checkSubtract ( INDArray first , INDArray second , double maxRelativeDifference , double minAbsDifference ) { RealMatrix rmFirst = convertToApacheMatrix ( first ) ; RealMatrix rmSecond = convertToApacheMatrix ( second ) ; INDArray result = first . sub ( second ) ; RealMatrix rmResult = rmFirst . subtract ( rmSecond ) ; if ( ! checkShape ( rmResult , result ) ) return false ; boolean ok = checkEntries ( rmResult , result , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray onCopies = Shape . toOffsetZeroCopy ( first ) . sub ( Shape . toOffsetZeroCopy ( second ) ) ; printFailureDetails ( first , second , rmResult , result , onCopies , <str> ) ; } return ok ; } public static boolean checkMulManually ( INDArray first , INDArray second , double maxRelativeDifference , double minAbsDifference ) { INDArray result = first . mul ( second ) ; int [ ] shape = first . shape ( ) ; INDArray expected = Nd4j . zeros ( first . shape ( ) ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { double v = first . getDouble ( i , j ) * second . getDouble ( i , j ) ; expected . putScalar ( new int [ ] { i , j } , v ) ; } } if ( ! checkShape ( expected , result ) ) return false ; boolean ok = checkEntries ( expected , result , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray onCopies = Shape . toOffsetZeroCopy ( first ) . mul ( Shape . toOffsetZeroCopy ( second ) ) ; printFailureDetails ( first , second , expected , result , onCopies , <str> ) ; } return ok ; } public static boolean checkDivManually ( INDArray first , INDArray second , double maxRelativeDifference , double minAbsDifference ) { INDArray result = first . div ( second ) ; int [ ] shape = first . shape ( ) ; INDArray expected = Nd4j . zeros ( first . shape ( ) ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { double v = first . getDouble ( i , j ) / second . getDouble ( i , j ) ; expected . putScalar ( new int [ ] { i , j } , v ) ; } } if ( ! checkShape ( expected , result ) ) return false ; boolean ok = checkEntries ( expected , result , maxRelativeDifference , minAbsDifference ) ; if ( ! ok ) { INDArray onCopies = Shape . toOffsetZeroCopy ( first ) . mul ( Shape . toOffsetZeroCopy ( second ) ) ; printFailureDetails ( first , second , expected , result , onCopies , <str> ) ; } return ok ; } private static boolean checkShape ( RealMatrix rmResult , INDArray result ) { int [ ] outShape = { rmResult . getRowDimension ( ) , rmResult . getColumnDimension ( ) } ; if ( ! Arrays . equals ( outShape , result . shape ( ) ) ) { System . out . println ( <str> + Arrays . toString ( result . shape ( ) ) + <str> + Arrays . toString ( outShape ) ) ; return false ; } return true ; } private static boolean checkShape ( INDArray expected , INDArray actual ) { if ( ! Arrays . equals ( expected . shape ( ) , actual . shape ( ) ) ) { System . out . println ( <str> + Arrays . toString ( actual . shape ( ) ) + <str> + Arrays . toString ( expected . shape ( ) ) ) ; return false ; } return true ; } public static boolean checkEntries ( RealMatrix rmResult , INDArray result , double maxRelativeDifference , double minAbsDifference ) { int [ ] outShape = { rmResult . getRowDimension ( ) , rmResult . getColumnDimension ( ) } ; for ( int i = <int> ; i < outShape [ <int> ] ; i + + ) { for ( int j = <int> ; j < outShape [ <int> ] ; j + + ) { double expOut = rmResult . getEntry ( i , j ) ; double actOut = result . getDouble ( i , j ) ; if ( expOut = = <float> & & actOut = = <float> ) continue ; double absError = Math . abs ( expOut - actOut ) ; double relError = absError / ( Math . abs ( expOut ) + Math . abs ( actOut ) ) ; if ( relError > maxRelativeDifference & & absError > minAbsDifference ) { System . out . println ( <str> + i + <str> + j + <str> + expOut + <str> + actOut + <str> + absError + <str> + relError ) ; return false ; } } } return true ; } public static boolean checkEntries ( INDArray expected , INDArray actual , double maxRelativeDifference , double minAbsDifference ) { int [ ] outShape = expected . shape ( ) ; for ( int i = <int> ; i < outShape [ <int> ] ; i + + ) { for ( int j = <int> ; j < outShape [ <int> ] ; j + + ) { double expOut = expected . getDouble ( i , j ) ; double actOut = actual . getDouble ( i , j ) ; if ( expOut = = <float> & & actOut = = <float> ) continue ; double absError = Math . abs ( expOut - actOut ) ; double relError = absError / ( Math . abs ( expOut ) + Math . abs ( actOut ) ) ; if ( relError > maxRelativeDifference & & absError > minAbsDifference ) { System . out . println ( <str> + i + <str> + j + <str> + expOut + <str> + actOut + <str> + absError + <str> + relError ) ; return false ; } } } return true ; } public static RealMatrix convertToApacheMatrix ( INDArray matrix ) { if ( matrix . rank ( ) ! = <int> ) throw new IllegalArgumentException ( <str> ) ; int [ ] shape = matrix . shape ( ) ; BlockRealMatrix out = new BlockRealMatrix ( shape [ <int> ] , shape [ <int> ] ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { double value = matrix . getDouble ( i , j ) ; out . setEntry ( i , j , value ) ; } } return out ; } public static void printFailureDetails ( INDArray first , INDArray second , RealMatrix expected , INDArray actual , INDArray onCopies , String op ) { System . out . println ( <str> + Nd4j . factory ( ) . getClass ( ) + <str> ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( first ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( second ) ; System . out . println ( <str> ) ; printApacheMatrix ( expected ) ; System . out . println ( <str> + op + <str> ) ; printMatrixFullPrecision ( onCopies ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( actual ) ; } public static void printGemmFailureDetails ( INDArray a , INDArray b , INDArray c , boolean transposeA , boolean transposeB , double alpha , double beta , RealMatrix expected , INDArray actual , INDArray onCopies ) { System . out . println ( <str> + Nd4j . factory ( ) . getClass ( ) + <str> ) ; System . out . println ( <str> + transposeA + <str> + transposeB + <str> + alpha + <str> + beta + <str> ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( a ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( b ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( c ) ; System . out . println ( <str> ) ; printApacheMatrix ( expected ) ; System . out . println ( <str> + transposeA + <str> + transposeB + <str> + alpha + <str> + beta + <str> ) ; printMatrixFullPrecision ( onCopies ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( actual ) ; } public static void printMatrixFullPrecision ( INDArray matrix ) { boolean floatType = ( matrix . data ( ) . dataType ( ) = = DataBuffer . Type . FLOAT ) ; printNDArrayHeader ( matrix ) ; int [ ] shape = matrix . shape ( ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { if ( floatType ) System . out . print ( matrix . getFloat ( i , j ) ) ; else System . out . print ( matrix . getDouble ( i , j ) ) ; if ( j ! = shape [ <int> ] - <int> ) System . out . print ( <str> ) ; else System . out . println ( ) ; } } } public static void printNDArrayHeader ( INDArray array ) { System . out . println ( array . data ( ) . dataType ( ) + <str> + array . ordering ( ) + <str> + array . offset ( ) + <str> + Arrays . toString ( array . shape ( ) ) + <str> + Arrays . toString ( array . stride ( ) ) + <str> + array . length ( ) + <str> + array . data ( ) . length ( ) ) ; } public static void printFailureDetails ( INDArray first , INDArray second , INDArray expected , INDArray actual , INDArray onCopies , String op ) { System . out . println ( <str> + Nd4j . factory ( ) . getClass ( ) + <str> ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( first ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( second ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( expected ) ; System . out . println ( <str> + op + <str> ) ; printMatrixFullPrecision ( onCopies ) ; System . out . println ( <str> ) ; printMatrixFullPrecision ( actual ) ; } public static void printApacheMatrix ( RealMatrix matrix ) { int nRows = matrix . getRowDimension ( ) ; int nCols = matrix . getColumnDimension ( ) ; System . out . println ( <str> + nRows + <str> + nCols + <str> ) ; for ( int i = <int> ; i < nRows ; i + + ) { for ( int j = <int> ; j < nCols ; j + + ) { System . out . print ( matrix . getEntry ( i , j ) ) ; if ( j ! = nCols - <int> ) System . out . print ( <str> ) ; else System . out . println ( ) ; } } } } 
