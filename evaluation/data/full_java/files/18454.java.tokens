package com . badlogic . gdx . tests ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . box2d . Body ; import com . badlogic . gdx . physics . box2d . BodyDef ; import com . badlogic . gdx . physics . box2d . BodyDef . BodyType ; import com . badlogic . gdx . physics . box2d . Box2DDebugRenderer ; import com . badlogic . gdx . physics . box2d . CircleShape ; import com . badlogic . gdx . physics . box2d . Contact ; import com . badlogic . gdx . physics . box2d . EdgeShape ; import com . badlogic . gdx . physics . box2d . Fixture ; import com . badlogic . gdx . physics . box2d . PolygonShape ; import com . badlogic . gdx . physics . box2d . World ; import com . badlogic . gdx . physics . box2d . WorldManifold ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . TimeUtils ; public class Box2DCharacterControllerTest extends GdxTest implements ApplicationListener { final static float MAX_VELOCITY = <int> f ; boolean jump = false ; World world ; Body player ; Fixture playerPhysicsFixture ; Fixture playerSensorFixture ; OrthographicCamera cam ; Box2DDebugRenderer renderer ; Array < Platform > platforms = new Array < Platform > ( ) ; Platform groundedPlatform = null ; float stillTime = <int> ; long lastGroundTime = <int> ; SpriteBatch batch ; BitmapFont font ; float accum = <int> ; float TICK = <int> / <int> f ; @Override public void create ( ) { world = new World ( new Vector2 ( <int> , - <int> ) , true ) ; renderer = new Box2DDebugRenderer ( ) ; cam = new OrthographicCamera ( <int> , <int> ) ; createWorld ( ) ; Gdx . input . setInputProcessor ( this ) ; batch = new SpriteBatch ( ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , false ) ; } @Override public void dispose ( ) { world . dispose ( ) ; renderer . dispose ( ) ; batch . dispose ( ) ; font . dispose ( ) ; } private void createWorld ( ) { float y1 = <int> ; float y2 = y1 ; for ( int i = <int> ; i < <int> ; i + + ) { Body ground = createEdge ( BodyType . StaticBody , - <int> + i * <int> , y1 , - <int> + i * <int> + <int> , y2 , <int> ) ; y1 = y2 ; y2 = <int> ; } Body box = createBox ( BodyType . StaticBody , <int> , <int> , <int> ) ; box . setTransform ( <int> , <int> , <int> ) ; box = createBox ( BodyType . StaticBody , <float> , <float> , <int> ) ; box . setTransform ( <int> , <float> , <int> ) ; player = createPlayer ( ) ; player . setTransform ( - <float> , <float> , <int> ) ; player . setFixedRotation ( true ) ; for ( int i = <int> ; i < <int> ; i + + ) { box = createBox ( BodyType . DynamicBody , ( float ) Math . random ( ) , ( float ) Math . random ( ) , <int> ) ; box . setTransform ( ( float ) Math . random ( ) * <int> f - ( float ) Math . random ( ) * <int> f , ( float ) Math . random ( ) * <int> + <int> , ( float ) ( Math . random ( ) * <int> * Math . PI ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { Body circle = createCircle ( BodyType . DynamicBody , ( float ) Math . random ( ) * <float> , <int> ) ; circle . setTransform ( ( float ) Math . random ( ) * <int> f - ( float ) Math . random ( ) * <int> f , ( float ) Math . random ( ) * <int> + <int> , ( float ) ( Math . random ( ) * <int> * Math . PI ) ) ; } platforms . add ( new CirclePlatform ( - <int> , - <int> , <int> , ( float ) Math . PI / <int> ) ) ; platforms . add ( new MovingPlatform ( - <int> , <int> , <int> , <float> , <int> , <int> , ( float ) Math . PI / <int> f , <int> ) ) ; platforms . add ( new MovingPlatform ( <int> , <int> , <int> , <float> , <int> , <int> , <int> , <int> ) ) ; platforms . add ( new MovingPlatform ( - <int> , <int> , <int> , <float> , - <int> , <int> , <int> , <int> ) ) ; } Body createBox ( BodyType type , float width , float height , float density ) { BodyDef def = new BodyDef ( ) ; def . type = type ; Body box = world . createBody ( def ) ; PolygonShape poly = new PolygonShape ( ) ; poly . setAsBox ( width , height ) ; box . createFixture ( poly , density ) ; poly . dispose ( ) ; return box ; } private Body createEdge ( BodyType type , float x1 , float y1 , float x2 , float y2 , float density ) { BodyDef def = new BodyDef ( ) ; def . type = type ; Body box = world . createBody ( def ) ; EdgeShape poly = new EdgeShape ( ) ; poly . set ( new Vector2 ( <int> , <int> ) , new Vector2 ( x2 - x1 , y2 - y1 ) ) ; box . createFixture ( poly , density ) ; box . setTransform ( x1 , y1 , <int> ) ; poly . dispose ( ) ; return box ; } Body createCircle ( BodyType type , float radius , float density ) { BodyDef def = new BodyDef ( ) ; def . type = type ; Body box = world . createBody ( def ) ; CircleShape poly = new CircleShape ( ) ; poly . setRadius ( radius ) ; box . createFixture ( poly , density ) ; poly . dispose ( ) ; return box ; } private Body createPlayer ( ) { BodyDef def = new BodyDef ( ) ; def . type = BodyType . DynamicBody ; Body box = world . createBody ( def ) ; PolygonShape poly = new PolygonShape ( ) ; poly . setAsBox ( <float> , <float> ) ; playerPhysicsFixture = box . createFixture ( poly , <int> ) ; poly . dispose ( ) ; CircleShape circle = new CircleShape ( ) ; circle . setRadius ( <float> ) ; circle . setPosition ( new Vector2 ( <int> , - <float> ) ) ; playerSensorFixture = box . createFixture ( circle , <int> ) ; circle . dispose ( ) ; box . setBullet ( true ) ; return box ; } @Override public void resume ( ) { } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; cam . position . set ( player . getPosition ( ) . x , player . getPosition ( ) . y , <int> ) ; cam . update ( ) ; renderer . render ( world , cam . combined ) ; Vector2 vel = player . getLinearVelocity ( ) ; Vector2 pos = player . getPosition ( ) ; boolean grounded = isPlayerGrounded ( Gdx . graphics . getDeltaTime ( ) ) ; if ( grounded ) { lastGroundTime = TimeUtils . nanoTime ( ) ; } else { if ( TimeUtils . nanoTime ( ) - lastGroundTime < <int> ) { grounded = true ; } } if ( Math . abs ( vel . x ) > MAX_VELOCITY ) { vel . x = Math . signum ( vel . x ) * MAX_VELOCITY ; player . setLinearVelocity ( vel . x , vel . y ) ; } if ( ! Gdx . input . isKeyPressed ( Keys . A ) & & ! Gdx . input . isKeyPressed ( Keys . D ) ) { stillTime + = Gdx . graphics . getDeltaTime ( ) ; player . setLinearVelocity ( vel . x * <float> , vel . y ) ; } else { stillTime = <int> ; } if ( ! grounded ) { playerPhysicsFixture . setFriction ( <float> ) ; playerSensorFixture . setFriction ( <float> ) ; } else { if ( ! Gdx . input . isKeyPressed ( Keys . A ) & & ! Gdx . input . isKeyPressed ( Keys . D ) & & stillTime > <float> ) { playerPhysicsFixture . setFriction ( <int> f ) ; playerSensorFixture . setFriction ( <int> f ) ; } else { playerPhysicsFixture . setFriction ( <float> ) ; playerSensorFixture . setFriction ( <float> ) ; } if ( groundedPlatform ! = null & & groundedPlatform instanceof MovingPlatform & & ( ( MovingPlatform ) groundedPlatform ) . dist = = <int> ) { player . applyLinearImpulse ( <int> , - <int> , pos . x , pos . y , true ) ; } } Array < Contact > contacts = world . getContactList ( ) ; for ( int i = <int> ; i < world . getContactCount ( ) ; i + + ) { Contact contact = contacts . get ( i ) ; contact . resetFriction ( ) ; } if ( Gdx . input . isKeyPressed ( Keys . A ) & & vel . x > - MAX_VELOCITY ) { player . applyLinearImpulse ( - <float> , <int> , pos . x , pos . y , true ) ; } if ( Gdx . input . isKeyPressed ( Keys . D ) & & vel . x < MAX_VELOCITY ) { player . applyLinearImpulse ( <float> , <int> , pos . x , pos . y , true ) ; } if ( jump ) { jump = false ; if ( grounded ) { player . setLinearVelocity ( vel . x , <int> ) ; System . out . println ( <str> + player . getLinearVelocity ( ) ) ; player . setTransform ( pos . x , pos . y + <float> , <int> ) ; player . applyLinearImpulse ( <int> , <int> , pos . x , pos . y , true ) ; System . out . println ( <str> + player . getLinearVelocity ( ) ) ; } } for ( int i = <int> ; i < platforms . size ; i + + ) { Platform platform = platforms . get ( i ) ; platform . update ( Math . max ( <int> / <float> , Gdx . graphics . getDeltaTime ( ) ) ) ; } world . step ( Gdx . graphics . getDeltaTime ( ) , <int> , <int> ) ; player . setAwake ( true ) ; cam . project ( point . set ( pos . x , pos . y , <int> ) ) ; batch . begin ( ) ; font . draw ( batch , <str> + playerPhysicsFixture . getFriction ( ) + <str> + grounded , point . x + <int> , point . y ) ; batch . end ( ) ; } private boolean isPlayerGrounded ( float deltaTime ) { groundedPlatform = null ; Array < Contact > contactList = world . getContactList ( ) ; for ( int i = <int> ; i < contactList . size ; i + + ) { Contact contact = contactList . get ( i ) ; if ( contact . isTouching ( ) & & ( contact . getFixtureA ( ) = = playerSensorFixture | | contact . getFixtureB ( ) = = playerSensorFixture ) ) { Vector2 pos = player . getPosition ( ) ; WorldManifold manifold = contact . getWorldManifold ( ) ; boolean below = true ; for ( int j = <int> ; j < manifold . getNumberOfContactPoints ( ) ; j + + ) { below & = ( manifold . getPoints ( ) [ j ] . y < pos . y - <float> ) ; } if ( below ) { if ( contact . getFixtureA ( ) . getUserData ( ) ! = null & & contact . getFixtureA ( ) . getUserData ( ) . equals ( <str> ) ) { groundedPlatform = ( Platform ) contact . getFixtureA ( ) . getBody ( ) . getUserData ( ) ; } if ( contact . getFixtureB ( ) . getUserData ( ) ! = null & & contact . getFixtureB ( ) . getUserData ( ) . equals ( <str> ) ) { groundedPlatform = ( Platform ) contact . getFixtureB ( ) . getBody ( ) . getUserData ( ) ; } return true ; } return false ; } } return false ; } @Override public boolean keyDown ( int keycode ) { if ( keycode = = Keys . W ) jump = true ; return false ; } @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . W ) jump = false ; return false ; } Vector2 last = null ; Vector3 point = new Vector3 ( ) ; @Override public boolean touchDown ( int x , int y , int pointerId , int button ) { cam . unproject ( point . set ( x , y , <int> ) ) ; if ( button = = Input . Buttons . LEFT ) { if ( last = = null ) { last = new Vector2 ( point . x , point . y ) ; } else { createEdge ( BodyType . StaticBody , last . x , last . y , point . x , point . y , <int> ) ; last . set ( point . x , point . y ) ; } } else { last = null ; } return false ; } abstract class Platform { abstract void update ( float deltatime ) ; } class CirclePlatform extends Platform { Body platform ; public CirclePlatform ( int x , int y , float radius , float da ) { platform = createCircle ( BodyType . KinematicBody , radius , <int> ) ; platform . setTransform ( x , y , <int> ) ; platform . getFixtureList ( ) . get ( <int> ) . setUserData ( <str> ) ; platform . setAngularVelocity ( da ) ; platform . setUserData ( this ) ; } @Override void update ( float deltatime ) { } } class MovingPlatform extends Platform { Body platform ; Vector2 pos = new Vector2 ( ) ; Vector2 dir = new Vector2 ( ) ; float dist = <int> ; float maxDist = <int> ; public MovingPlatform ( float x , float y , float width , float height , float dx , float dy , float da , float maxDist ) { platform = createBox ( BodyType . KinematicBody , width , height , <int> ) ; pos . x = x ; pos . y = y ; dir . x = dx ; dir . y = dy ; this . maxDist = maxDist ; platform . setTransform ( pos , <int> ) ; platform . getFixtureList ( ) . get ( <int> ) . setUserData ( <str> ) ; platform . setAngularVelocity ( da ) ; platform . setUserData ( this ) ; } public void update ( float deltaTime ) { dist + = dir . len ( ) * deltaTime ; if ( dist > maxDist ) { dir . scl ( - <int> ) ; dist = <int> ; } platform . setLinearVelocity ( dir ) ; } } } 
