package com . badlogic . gdx . graphics . g3d ; import com . badlogic . gdx . assets . loaders . ModelLoader ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . model . MeshPart ; import com . badlogic . gdx . graphics . g3d . model . Node ; import com . badlogic . gdx . graphics . g3d . model . NodeAnimation ; import com . badlogic . gdx . graphics . g3d . model . NodeKeyframe ; import com . badlogic . gdx . graphics . g3d . model . NodePart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelAnimation ; import com . badlogic . gdx . graphics . g3d . model . data . ModelData ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMaterial ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMesh ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMeshPart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNode ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodeAnimation ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodeKeyframe ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodePart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelTexture ; import com . badlogic . gdx . graphics . g3d . utils . TextureDescriptor ; import com . badlogic . gdx . graphics . g3d . utils . TextureProvider ; import com . badlogic . gdx . graphics . g3d . utils . TextureProvider . FileTextureProvider ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . ArrayMap ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; public class Model implements Disposable { public final Array < Material > materials = new Array ( ) ; public final Array < Node > nodes = new Array ( ) ; public final Array < Animation > animations = new Array ( ) ; public final Array < Mesh > meshes = new Array ( ) ; public final Array < MeshPart > meshParts = new Array ( ) ; protected final Array < Disposable > disposables = new Array ( ) ; public Model ( ) { } public Model ( ModelData modelData ) { this ( modelData , new FileTextureProvider ( ) ) ; } public Model ( ModelData modelData , TextureProvider textureProvider ) { load ( modelData , textureProvider ) ; } private void load ( ModelData modelData , TextureProvider textureProvider ) { loadMeshes ( modelData . meshes ) ; loadMaterials ( modelData . materials , textureProvider ) ; loadNodes ( modelData . nodes ) ; loadAnimations ( modelData . animations ) ; calculateTransforms ( ) ; } private void loadAnimations ( Iterable < ModelAnimation > modelAnimations ) { for ( final ModelAnimation anim : modelAnimations ) { Animation animation = new Animation ( ) ; animation . id = anim . id ; for ( ModelNodeAnimation nanim : anim . nodeAnimations ) { final Node node = getNode ( nanim . nodeId ) ; if ( node = = null ) continue ; NodeAnimation nodeAnim = new NodeAnimation ( ) ; nodeAnim . node = node ; if ( nanim . translation ! = null ) { nodeAnim . translation = new Array < NodeKeyframe < Vector3 > > ( ) ; nodeAnim . translation . ensureCapacity ( nanim . translation . size ) ; for ( ModelNodeKeyframe < Vector3 > kf : nanim . translation ) { if ( kf . keytime > animation . duration ) animation . duration = kf . keytime ; nodeAnim . translation . add ( new NodeKeyframe < Vector3 > ( kf . keytime , new Vector3 ( kf . value = = null ? node . translation : kf . value ) ) ) ; } } if ( nanim . rotation ! = null ) { nodeAnim . rotation = new Array < NodeKeyframe < Quaternion > > ( ) ; nodeAnim . rotation . ensureCapacity ( nanim . rotation . size ) ; for ( ModelNodeKeyframe < Quaternion > kf : nanim . rotation ) { if ( kf . keytime > animation . duration ) animation . duration = kf . keytime ; nodeAnim . rotation . add ( new NodeKeyframe < Quaternion > ( kf . keytime , new Quaternion ( kf . value = = null ? node . rotation : kf . value ) ) ) ; } } if ( nanim . scaling ! = null ) { nodeAnim . scaling = new Array < NodeKeyframe < Vector3 > > ( ) ; nodeAnim . scaling . ensureCapacity ( nanim . scaling . size ) ; for ( ModelNodeKeyframe < Vector3 > kf : nanim . scaling ) { if ( kf . keytime > animation . duration ) animation . duration = kf . keytime ; nodeAnim . scaling . add ( new NodeKeyframe < Vector3 > ( kf . keytime , new Vector3 ( kf . value = = null ? node . scale : kf . value ) ) ) ; } } if ( ( nodeAnim . translation ! = null & & nodeAnim . translation . size > <int> ) | | ( nodeAnim . rotation ! = null & & nodeAnim . rotation . size > <int> ) | | ( nodeAnim . scaling ! = null & & nodeAnim . scaling . size > <int> ) ) animation . nodeAnimations . add ( nodeAnim ) ; } if ( animation . nodeAnimations . size > <int> ) animations . add ( animation ) ; } } private ObjectMap < NodePart , ArrayMap < String , Matrix4 > > nodePartBones = new ObjectMap < NodePart , ArrayMap < String , Matrix4 > > ( ) ; private void loadNodes ( Iterable < ModelNode > modelNodes ) { nodePartBones . clear ( ) ; for ( ModelNode node : modelNodes ) { nodes . add ( loadNode ( node ) ) ; } for ( ObjectMap . Entry < NodePart , ArrayMap < String , Matrix4 > > e : nodePartBones . entries ( ) ) { if ( e . key . invBoneBindTransforms = = null ) e . key . invBoneBindTransforms = new ArrayMap < Node , Matrix4 > ( Node . class , Matrix4 . class ) ; e . key . invBoneBindTransforms . clear ( ) ; for ( ObjectMap . Entry < String , Matrix4 > b : e . value . entries ( ) ) e . key . invBoneBindTransforms . put ( getNode ( b . key ) , new Matrix4 ( b . value ) . inv ( ) ) ; } } private Node loadNode ( ModelNode modelNode ) { Node node = new Node ( ) ; node . id = modelNode . id ; if ( modelNode . translation ! = null ) node . translation . set ( modelNode . translation ) ; if ( modelNode . rotation ! = null ) node . rotation . set ( modelNode . rotation ) ; if ( modelNode . scale ! = null ) node . scale . set ( modelNode . scale ) ; if ( modelNode . parts ! = null ) { for ( ModelNodePart modelNodePart : modelNode . parts ) { MeshPart meshPart = null ; Material meshMaterial = null ; if ( modelNodePart . meshPartId ! = null ) { for ( MeshPart part : meshParts ) { if ( modelNodePart . meshPartId . equals ( part . id ) ) { meshPart = part ; break ; } } } if ( modelNodePart . materialId ! = null ) { for ( Material material : materials ) { if ( modelNodePart . materialId . equals ( material . id ) ) { meshMaterial = material ; break ; } } } if ( meshPart = = null | | meshMaterial = = null ) throw new GdxRuntimeException ( <str> + node . id ) ; if ( meshPart ! = null & & meshMaterial ! = null ) { NodePart nodePart = new NodePart ( ) ; nodePart . meshPart = meshPart ; nodePart . material = meshMaterial ; node . parts . add ( nodePart ) ; if ( modelNodePart . bones ! = null ) nodePartBones . put ( nodePart , modelNodePart . bones ) ; } } } if ( modelNode . children ! = null ) { for ( ModelNode child : modelNode . children ) { node . addChild ( loadNode ( child ) ) ; } } return node ; } private void loadMeshes ( Iterable < ModelMesh > meshes ) { for ( ModelMesh mesh : meshes ) { convertMesh ( mesh ) ; } } private void convertMesh ( ModelMesh modelMesh ) { int numIndices = <int> ; for ( ModelMeshPart part : modelMesh . parts ) { numIndices + = part . indices . length ; } VertexAttributes attributes = new VertexAttributes ( modelMesh . attributes ) ; int numVertices = modelMesh . vertices . length / ( attributes . vertexSize / <int> ) ; Mesh mesh = new Mesh ( true , numVertices , numIndices , attributes ) ; meshes . add ( mesh ) ; disposables . add ( mesh ) ; BufferUtils . copy ( modelMesh . vertices , mesh . getVerticesBuffer ( ) , modelMesh . vertices . length , <int> ) ; int offset = <int> ; mesh . getIndicesBuffer ( ) . clear ( ) ; for ( ModelMeshPart part : modelMesh . parts ) { MeshPart meshPart = new MeshPart ( ) ; meshPart . id = part . id ; meshPart . primitiveType = part . primitiveType ; meshPart . offset = offset ; meshPart . size = part . indices . length ; meshPart . mesh = mesh ; mesh . getIndicesBuffer ( ) . put ( part . indices ) ; offset + = meshPart . size ; meshParts . add ( meshPart ) ; } mesh . getIndicesBuffer ( ) . position ( <int> ) ; for ( MeshPart part : meshParts ) part . update ( ) ; } private void loadMaterials ( Iterable < ModelMaterial > modelMaterials , TextureProvider textureProvider ) { for ( ModelMaterial mtl : modelMaterials ) { this . materials . add ( convertMaterial ( mtl , textureProvider ) ) ; } } private Material convertMaterial ( ModelMaterial mtl , TextureProvider textureProvider ) { Material result = new Material ( ) ; result . id = mtl . id ; if ( mtl . ambient ! = null ) result . set ( new ColorAttribute ( ColorAttribute . Ambient , mtl . ambient ) ) ; if ( mtl . diffuse ! = null ) result . set ( new ColorAttribute ( ColorAttribute . Diffuse , mtl . diffuse ) ) ; if ( mtl . specular ! = null ) result . set ( new ColorAttribute ( ColorAttribute . Specular , mtl . specular ) ) ; if ( mtl . emissive ! = null ) result . set ( new ColorAttribute ( ColorAttribute . Emissive , mtl . emissive ) ) ; if ( mtl . reflection ! = null ) result . set ( new ColorAttribute ( ColorAttribute . Reflection , mtl . reflection ) ) ; if ( mtl . shininess > <float> ) result . set ( new FloatAttribute ( FloatAttribute . Shininess , mtl . shininess ) ) ; if ( mtl . opacity ! = <float> ) result . set ( new BlendingAttribute ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA , mtl . opacity ) ) ; ObjectMap < String , Texture > textures = new ObjectMap < String , Texture > ( ) ; if ( mtl . textures ! = null ) { for ( ModelTexture tex : mtl . textures ) { Texture texture ; if ( textures . containsKey ( tex . fileName ) ) { texture = textures . get ( tex . fileName ) ; } else { texture = textureProvider . load ( tex . fileName ) ; textures . put ( tex . fileName , texture ) ; disposables . add ( texture ) ; } TextureDescriptor descriptor = new TextureDescriptor ( texture ) ; descriptor . minFilter = texture . getMinFilter ( ) ; descriptor . magFilter = texture . getMagFilter ( ) ; descriptor . uWrap = texture . getUWrap ( ) ; descriptor . vWrap = texture . getVWrap ( ) ; float offsetU = tex . uvTranslation = = null ? <float> : tex . uvTranslation . x ; float offsetV = tex . uvTranslation = = null ? <float> : tex . uvTranslation . y ; float scaleU = tex . uvScaling = = null ? <float> : tex . uvScaling . x ; float scaleV = tex . uvScaling = = null ? <float> : tex . uvScaling . y ; switch ( tex . usage ) { case ModelTexture . USAGE_DIFFUSE : result . set ( new TextureAttribute ( TextureAttribute . Diffuse , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_SPECULAR : result . set ( new TextureAttribute ( TextureAttribute . Specular , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_BUMP : result . set ( new TextureAttribute ( TextureAttribute . Bump , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_NORMAL : result . set ( new TextureAttribute ( TextureAttribute . Normal , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_AMBIENT : result . set ( new TextureAttribute ( TextureAttribute . Ambient , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_EMISSIVE : result . set ( new TextureAttribute ( TextureAttribute . Emissive , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; case ModelTexture . USAGE_REFLECTION : result . set ( new TextureAttribute ( TextureAttribute . Reflection , descriptor , offsetU , offsetV , scaleU , scaleV ) ) ; break ; } } } return result ; } public void manageDisposable ( Disposable disposable ) { if ( ! disposables . contains ( disposable , true ) ) disposables . add ( disposable ) ; } public Iterable < Disposable > getManagedDisposables ( ) { return disposables ; } @Override public void dispose ( ) { for ( Disposable disposable : disposables ) { disposable . dispose ( ) ; } } public void calculateTransforms ( ) { final int n = nodes . size ; for ( int i = <int> ; i < n ; i + + ) { nodes . get ( i ) . calculateTransforms ( true ) ; } for ( int i = <int> ; i < n ; i + + ) { nodes . get ( i ) . calculateBoneTransforms ( true ) ; } } public BoundingBox calculateBoundingBox ( final BoundingBox out ) { out . inf ( ) ; return extendBoundingBox ( out ) ; } public BoundingBox extendBoundingBox ( final BoundingBox out ) { final int n = nodes . size ; for ( int i = <int> ; i < n ; i + + ) nodes . get ( i ) . extendBoundingBox ( out ) ; return out ; } public Animation getAnimation ( final String id ) { return getAnimation ( id , true ) ; } public Animation getAnimation ( final String id , boolean ignoreCase ) { final int n = animations . size ; Animation animation ; if ( ignoreCase ) { for ( int i = <int> ; i < n ; i + + ) if ( ( animation = animations . get ( i ) ) . id . equalsIgnoreCase ( id ) ) return animation ; } else { for ( int i = <int> ; i < n ; i + + ) if ( ( animation = animations . get ( i ) ) . id . equals ( id ) ) return animation ; } return null ; } public Material getMaterial ( final String id ) { return getMaterial ( id , true ) ; } public Material getMaterial ( final String id , boolean ignoreCase ) { final int n = materials . size ; Material material ; if ( ignoreCase ) { for ( int i = <int> ; i < n ; i + + ) if ( ( material = materials . get ( i ) ) . id . equalsIgnoreCase ( id ) ) return material ; } else { for ( int i = <int> ; i < n ; i + + ) if ( ( material = materials . get ( i ) ) . id . equals ( id ) ) return material ; } return null ; } public Node getNode ( final String id ) { return getNode ( id , true ) ; } public Node getNode ( final String id , boolean recursive ) { return getNode ( id , recursive , false ) ; } public Node getNode ( final String id , boolean recursive , boolean ignoreCase ) { return Node . getNode ( nodes , id , recursive , ignoreCase ) ; } } 
