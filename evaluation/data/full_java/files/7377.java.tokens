package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . search . aggregations . Aggregations ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . ReduceContext ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . InternalMultiBucketAggregation ; import org . elasticsearch . search . aggregations . bucket . InternalSingleBucketAggregation ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation . Bucket ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; import java . util . stream . StreamSupport ; public abstract class SiblingPipelineAggregator extends PipelineAggregator { protected SiblingPipelineAggregator ( ) { super ( ) ; } protected SiblingPipelineAggregator ( String name , String [ ] bucketsPaths , Map < String , Object > metaData ) { super ( name , bucketsPaths , metaData ) ; } @SuppressWarnings ( <str> ) @Override public InternalAggregation reduce ( InternalAggregation aggregation , ReduceContext reduceContext ) { if ( aggregation instanceof InternalMultiBucketAggregation ) { @SuppressWarnings ( <str> ) InternalMultiBucketAggregation multiBucketsAgg = ( InternalMultiBucketAggregation ) aggregation ; List < ? extends Bucket > buckets = multiBucketsAgg . getBuckets ( ) ; List < Bucket > newBuckets = new ArrayList < > ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; i + + ) { InternalMultiBucketAggregation . InternalBucket bucket = ( InternalMultiBucketAggregation . InternalBucket ) buckets . get ( i ) ; InternalAggregation aggToAdd = doReduce ( bucket . getAggregations ( ) , reduceContext ) ; List < InternalAggregation > aggs = StreamSupport . stream ( bucket . getAggregations ( ) . spliterator ( ) , false ) . map ( ( p ) - > { return ( InternalAggregation ) p ; } ) . collect ( Collectors . toList ( ) ) ; aggs . add ( aggToAdd ) ; InternalMultiBucketAggregation . InternalBucket newBucket = multiBucketsAgg . createBucket ( new InternalAggregations ( aggs ) , bucket ) ; newBuckets . add ( newBucket ) ; } return multiBucketsAgg . create ( newBuckets ) ; } else if ( aggregation instanceof InternalSingleBucketAggregation ) { InternalSingleBucketAggregation singleBucketAgg = ( InternalSingleBucketAggregation ) aggregation ; InternalAggregation aggToAdd = doReduce ( singleBucketAgg . getAggregations ( ) , reduceContext ) ; List < InternalAggregation > aggs = StreamSupport . stream ( singleBucketAgg . getAggregations ( ) . spliterator ( ) , false ) . map ( ( p ) - > { return ( InternalAggregation ) p ; } ) . collect ( Collectors . toList ( ) ) ; aggs . add ( aggToAdd ) ; return singleBucketAgg . create ( new InternalAggregations ( aggs ) ) ; } else { throw new IllegalStateException ( <str> + aggregation . getName ( ) + <str> + aggregation . type ( ) . name ( ) + <str> ) ; } } public abstract InternalAggregation doReduce ( Aggregations aggregations , ReduceContext context ) ; } 
