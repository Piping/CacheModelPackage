package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . base . Joiner ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . testing . IteratorFeature ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import java . util . SortedSet ; import java . util . concurrent . TimeUnit ; import javax . annotation . Nullable ; @SuppressWarnings ( <str> ) @GwtCompatible ( emulated = true ) public class FluentIterableTest extends TestCase { @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( FluentIterable . class ) ; } public void testFromArrayAndAppend ( ) { FluentIterable < TimeUnit > units = FluentIterable . from ( TimeUnit . values ( ) ) . append ( TimeUnit . SECONDS ) ; } public void testFromArrayAndIteratorRemove ( ) { FluentIterable < TimeUnit > units = FluentIterable . from ( TimeUnit . values ( ) ) ; try { Iterables . removeIf ( units , Predicates . equalTo ( TimeUnit . SECONDS ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } public void testOfArrayAndIteratorRemove ( ) { FluentIterable < TimeUnit > units = FluentIterable . of ( TimeUnit . values ( ) ) ; assertTrue ( Iterables . removeIf ( units , Predicates . equalTo ( TimeUnit . SECONDS ) ) ) ; } public void testFrom ( ) { assertEquals ( ImmutableList . of ( <int> , <int> , <int> , <int> ) , Lists . newArrayList ( FluentIterable . from ( ImmutableList . of ( <int> , <int> , <int> , <int> ) ) ) ) ; } @SuppressWarnings ( <str> ) public void testFrom_alreadyFluentIterable ( ) { FluentIterable < Integer > iterable = FluentIterable . from ( asList ( <int> ) ) ; assertSame ( iterable , FluentIterable . from ( iterable ) ) ; } public void testOf ( ) { assertEquals ( ImmutableList . of ( <int> , <int> , <int> , <int> ) , Lists . newArrayList ( FluentIterable . of ( <int> , <int> , <int> , <int> ) ) ) ; } public void testOfArray ( ) { assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , Lists . newArrayList ( FluentIterable . of ( new Object [ ] { <str> , <str> , <str> , <str> } ) ) ) ; } public void testFromArray ( ) { assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , Lists . newArrayList ( FluentIterable . from ( new Object [ ] { <str> , <str> , <str> , <str> } ) ) ) ; } public void testOf_empty ( ) { assertEquals ( ImmutableList . of ( ) , Lists . newArrayList ( FluentIterable . of ( ) ) ) ; } public void testSize0 ( ) { assertEquals ( <int> , FluentIterable . < String > of ( ) . size ( ) ) ; } public void testSize1Collection ( ) { assertEquals ( <int> , FluentIterable . from ( asList ( <str> ) ) . size ( ) ) ; } public void testSize2NonCollection ( ) { Iterable < Integer > iterable = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return asList ( <int> , <int> ) . iterator ( ) ; } } ; assertEquals ( <int> , FluentIterable . from ( iterable ) . size ( ) ) ; } public void testSize_collectionDoesntIterate ( ) { List < Integer > nums = asList ( <int> , <int> , <int> , <int> , <int> ) ; List < Integer > collection = new ArrayList < Integer > ( nums ) { @Override public Iterator < Integer > iterator ( ) { throw new AssertionFailedError ( <str> ) ; } } ; assertEquals ( <int> , FluentIterable . from ( collection ) . size ( ) ) ; } public void testContains_nullSetYes ( ) { Iterable < String > set = Sets . newHashSet ( <str> , null , <str> ) ; assertTrue ( FluentIterable . from ( set ) . contains ( null ) ) ; } public void testContains_nullSetNo ( ) { Iterable < String > set = ImmutableSortedSet . of ( <str> , <str> ) ; assertFalse ( FluentIterable . from ( set ) . contains ( null ) ) ; } public void testContains_nullIterableYes ( ) { Iterable < String > iterable = iterable ( <str> , null , <str> ) ; assertTrue ( FluentIterable . from ( iterable ) . contains ( null ) ) ; } public void testContains_nullIterableNo ( ) { Iterable < String > iterable = iterable ( <str> , <str> ) ; assertFalse ( FluentIterable . from ( iterable ) . contains ( null ) ) ; } public void testContains_nonNullSetYes ( ) { Iterable < String > set = Sets . newHashSet ( <str> , null , <str> ) ; assertTrue ( FluentIterable . from ( set ) . contains ( <str> ) ) ; } public void testContains_nonNullSetNo ( ) { Iterable < String > set = Sets . newHashSet ( <str> , <str> ) ; assertFalse ( FluentIterable . from ( set ) . contains ( <str> ) ) ; } public void testContains_nonNullIterableYes ( ) { Iterable < String > set = iterable ( <str> , null , <str> ) ; assertTrue ( FluentIterable . from ( set ) . contains ( <str> ) ) ; } public void testContains_nonNullIterableNo ( ) { Iterable < String > iterable = iterable ( <str> , <str> ) ; assertFalse ( FluentIterable . from ( iterable ) . contains ( <str> ) ) ; } public void testOfToString ( ) { assertEquals ( <str> , FluentIterable . of ( <str> , <str> , <str> , <str> ) . toString ( ) ) ; } public void testToString ( ) { assertEquals ( <str> , FluentIterable . from ( Collections . emptyList ( ) ) . toString ( ) ) ; assertEquals ( <str> , FluentIterable . < String > of ( ) . toString ( ) ) ; assertEquals ( <str> , FluentIterable . from ( asList ( <str> , <str> , <str> , <str> ) ) . toString ( ) ) ; } public void testCycle ( ) { FluentIterable < String > cycle = FluentIterable . from ( asList ( <str> , <str> ) ) . cycle ( ) ; int howManyChecked = <int> ; for ( String string : cycle ) { String expected = ( howManyChecked % <int> = = <int> ) ? <str> : <str> ; assertEquals ( expected , string ) ; if ( howManyChecked + + = = <int> ) { break ; } } assertEquals ( <str> , cycle . iterator ( ) . next ( ) ) ; } public void testCycle_emptyIterable ( ) { FluentIterable < Integer > cycle = FluentIterable . < Integer > of ( ) . cycle ( ) ; assertFalse ( cycle . iterator ( ) . hasNext ( ) ) ; } public void testCycle_removingAllElementsStopsCycle ( ) { FluentIterable < Integer > cycle = fluent ( <int> , <int> ) . cycle ( ) ; Iterator < Integer > iterator = cycle . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; iterator . next ( ) ; iterator . remove ( ) ; assertFalse ( iterator . hasNext ( ) ) ; assertFalse ( cycle . iterator ( ) . hasNext ( ) ) ; } public void testAppend ( ) { FluentIterable < Integer > result = FluentIterable . < Integer > from ( asList ( <int> , <int> , <int> ) ) . append ( Lists . newArrayList ( <int> , <int> , <int> ) ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> , <int> ) , Lists . newArrayList ( result ) ) ; assertEquals ( <str> , result . toString ( ) ) ; result = FluentIterable . < Integer > from ( asList ( <int> , <int> , <int> ) ) . append ( <int> , <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> , <int> ) , Lists . newArrayList ( result ) ) ; assertEquals ( <str> , result . toString ( ) ) ; } public void testAppend_toEmpty ( ) { FluentIterable < Integer > result = FluentIterable . < Integer > of ( ) . append ( Lists . newArrayList ( <int> , <int> , <int> ) ) ; assertEquals ( asList ( <int> , <int> , <int> ) , Lists . newArrayList ( result ) ) ; } public void testAppend_emptyList ( ) { FluentIterable < Integer > result = FluentIterable . < Integer > from ( asList ( <int> , <int> , <int> ) ) . append ( Lists . < Integer > newArrayList ( ) ) ; assertEquals ( asList ( <int> , <int> , <int> ) , Lists . newArrayList ( result ) ) ; } @SuppressWarnings ( <str> ) public void testAppend_nullPointerException ( ) { try { FluentIterable . < Integer > from ( asList ( <int> , <int> ) ) . append ( ( List < Integer > ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testFilter ( ) { FluentIterable < String > filtered = FluentIterable . from ( asList ( <str> , <str> ) ) . filter ( Predicates . equalTo ( <str> ) ) ; List < String > expected = Collections . singletonList ( <str> ) ; List < String > actual = Lists . newArrayList ( filtered ) ; assertEquals ( expected , actual ) ; assertCanIterateAgain ( filtered ) ; assertEquals ( <str> , filtered . toString ( ) ) ; } private static class TypeA { } private interface TypeB { } private static class HasBoth extends TypeA implements TypeB { } @GwtIncompatible ( <str> ) public void testFilterByType ( ) throws Exception { HasBoth hasBoth = new HasBoth ( ) ; FluentIterable < TypeA > alist = FluentIterable . from ( asList ( new TypeA ( ) , new TypeA ( ) , hasBoth , new TypeA ( ) ) ) ; Iterable < TypeB > blist = alist . filter ( TypeB . class ) ; assertThat ( blist ) . containsExactly ( hasBoth ) . inOrder ( ) ; } public void testAnyMatch ( ) { ArrayList < String > list = Lists . newArrayList ( ) ; FluentIterable < String > iterable = FluentIterable . < String > from ( list ) ; Predicate < String > predicate = Predicates . equalTo ( <str> ) ; assertFalse ( iterable . anyMatch ( predicate ) ) ; list . add ( <str> ) ; assertFalse ( iterable . anyMatch ( predicate ) ) ; list . add ( <str> ) ; assertTrue ( iterable . anyMatch ( predicate ) ) ; } public void testAllMatch ( ) { List < String > list = Lists . newArrayList ( ) ; FluentIterable < String > iterable = FluentIterable . < String > from ( list ) ; Predicate < String > predicate = Predicates . equalTo ( <str> ) ; assertTrue ( iterable . allMatch ( predicate ) ) ; list . add ( <str> ) ; assertTrue ( iterable . allMatch ( predicate ) ) ; list . add ( <str> ) ; assertFalse ( iterable . allMatch ( predicate ) ) ; } public void testFirstMatch ( ) { FluentIterable < String > iterable = FluentIterable . from ( Lists . newArrayList ( <str> , <str> ) ) ; assertThat ( iterable . firstMatch ( Predicates . equalTo ( <str> ) ) ) . hasValue ( <str> ) ; assertThat ( iterable . firstMatch ( Predicates . equalTo ( <str> ) ) ) . hasValue ( <str> ) ; assertThat ( iterable . firstMatch ( Predicates . alwaysFalse ( ) ) ) . isAbsent ( ) ; assertThat ( iterable . firstMatch ( Predicates . alwaysTrue ( ) ) ) . hasValue ( <str> ) ; } private static final class IntegerValueOfFunction implements Function < String , Integer > { @Override public Integer apply ( String from ) { return Integer . valueOf ( from ) ; } } public void testTransformWith ( ) { List < String > input = asList ( <str> , <str> , <str> ) ; Iterable < Integer > iterable = FluentIterable . from ( input ) . transform ( new IntegerValueOfFunction ( ) ) ; assertEquals ( asList ( <int> , <int> , <int> ) , Lists . newArrayList ( iterable ) ) ; assertCanIterateAgain ( iterable ) ; assertEquals ( <str> , iterable . toString ( ) ) ; } public void testTransformWith_poorlyBehavedTransform ( ) { List < String > input = asList ( <str> , null , <str> ) ; Iterable < Integer > iterable = FluentIterable . from ( input ) . transform ( new IntegerValueOfFunction ( ) ) ; Iterator < Integer > resultIterator = iterable . iterator ( ) ; resultIterator . next ( ) ; try { resultIterator . next ( ) ; fail ( <str> ) ; } catch ( NumberFormatException expected ) { } } private static final class StringValueOfFunction implements Function < Integer , String > { @Override public String apply ( Integer from ) { return String . valueOf ( from ) ; } } public void testTransformWith_nullFriendlyTransform ( ) { List < Integer > input = asList ( <int> , <int> , null , <int> ) ; Iterable < String > result = FluentIterable . from ( input ) . transform ( new StringValueOfFunction ( ) ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> ) , Lists . newArrayList ( result ) ) ; } private static final class RepeatedStringValueOfFunction implements Function < Integer , List < String > > { @Override public List < String > apply ( Integer from ) { String value = String . valueOf ( from ) ; return ImmutableList . of ( value , value ) ; } } public void testTransformAndConcat ( ) { List < Integer > input = asList ( <int> , <int> , <int> ) ; Iterable < String > result = FluentIterable . from ( input ) . transformAndConcat ( new RepeatedStringValueOfFunction ( ) ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) , Lists . newArrayList ( result ) ) ; } private static final class RepeatedStringValueOfWildcardFunction implements Function < Integer , List < ? extends String > > { @Override public List < String > apply ( Integer from ) { String value = String . valueOf ( from ) ; return ImmutableList . of ( value , value ) ; } } public void testTransformAndConcat_wildcardFunctionGenerics ( ) { List < Integer > input = asList ( <int> , <int> , <int> ) ; FluentIterable . from ( input ) . transformAndConcat ( new RepeatedStringValueOfWildcardFunction ( ) ) ; } public void testFirst_list ( ) { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( list ) . first ( ) ) . hasValue ( <str> ) ; } public void testFirst_null ( ) { List < String > list = Lists . newArrayList ( null , <str> , <str> ) ; try { FluentIterable . from ( list ) . first ( ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testFirst_emptyList ( ) { List < String > list = Collections . emptyList ( ) ; assertThat ( FluentIterable . from ( list ) . first ( ) ) . isAbsent ( ) ; } public void testFirst_sortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( sortedSet ) . first ( ) ) . hasValue ( <str> ) ; } public void testFirst_emptySortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( ) ; assertThat ( FluentIterable . from ( sortedSet ) . first ( ) ) . isAbsent ( ) ; } public void testFirst_iterable ( ) { Set < String > set = ImmutableSet . of ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( set ) . first ( ) ) . hasValue ( <str> ) ; } public void testFirst_emptyIterable ( ) { Set < String > set = Sets . newHashSet ( ) ; assertThat ( FluentIterable . from ( set ) . first ( ) ) . isAbsent ( ) ; } public void testLast_list ( ) { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( list ) . last ( ) ) . hasValue ( <str> ) ; } public void testLast_null ( ) { List < String > list = Lists . newArrayList ( <str> , <str> , null ) ; try { FluentIterable . from ( list ) . last ( ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testLast_emptyList ( ) { List < String > list = Collections . emptyList ( ) ; assertThat ( FluentIterable . from ( list ) . last ( ) ) . isAbsent ( ) ; } public void testLast_sortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( sortedSet ) . last ( ) ) . hasValue ( <str> ) ; } public void testLast_emptySortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( ) ; assertThat ( FluentIterable . from ( sortedSet ) . last ( ) ) . isAbsent ( ) ; } public void testLast_iterable ( ) { Set < String > set = ImmutableSet . of ( <str> , <str> , <str> ) ; assertThat ( FluentIterable . from ( set ) . last ( ) ) . hasValue ( <str> ) ; } public void testLast_emptyIterable ( ) { Set < String > set = Sets . newHashSet ( ) ; assertThat ( FluentIterable . from ( set ) . last ( ) ) . isAbsent ( ) ; } public void testSkip_simple ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( Lists . newArrayList ( <str> , <str> , <str> ) , Lists . newArrayList ( FluentIterable . from ( set ) . skip ( <int> ) ) ) ; assertEquals ( <str> , FluentIterable . from ( set ) . skip ( <int> ) . toString ( ) ) ; } public void testSkip_simpleList ( ) { Collection < String > list = Lists . newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( Lists . newArrayList ( <str> , <str> , <str> ) , Lists . newArrayList ( FluentIterable . from ( list ) . skip ( <int> ) ) ) ; assertEquals ( <str> , FluentIterable . from ( list ) . skip ( <int> ) . toString ( ) ) ; } public void testSkip_pastEnd ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> ) ; assertEquals ( Collections . emptyList ( ) , Lists . newArrayList ( FluentIterable . from ( set ) . skip ( <int> ) ) ) ; } public void testSkip_pastEndList ( ) { Collection < String > list = Lists . newArrayList ( <str> , <str> ) ; assertEquals ( Collections . emptyList ( ) , Lists . newArrayList ( FluentIterable . from ( list ) . skip ( <int> ) ) ) ; } public void testSkip_skipNone ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> ) ; assertEquals ( Lists . newArrayList ( <str> , <str> ) , Lists . newArrayList ( FluentIterable . from ( set ) . skip ( <int> ) ) ) ; } public void testSkip_skipNoneList ( ) { Collection < String > list = Lists . newArrayList ( <str> , <str> ) ; assertEquals ( Lists . newArrayList ( <str> , <str> ) , Lists . newArrayList ( FluentIterable . from ( list ) . skip ( <int> ) ) ) ; } public void testSkip_iterator ( ) throws Exception { new IteratorTester < Integer > ( <int> , IteratorFeature . MODIFIABLE , Lists . newArrayList ( <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { Collection < Integer > collection = Sets . newLinkedHashSet ( ) ; Collections . addAll ( collection , <int> , <int> , <int> ) ; return FluentIterable . from ( collection ) . skip ( <int> ) . iterator ( ) ; } } . test ( ) ; } public void testSkip_iteratorList ( ) throws Exception { new IteratorTester < Integer > ( <int> , IteratorFeature . MODIFIABLE , Lists . newArrayList ( <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return FluentIterable . from ( Lists . newArrayList ( <int> , <int> , <int> ) ) . skip ( <int> ) . iterator ( ) ; } } . test ( ) ; } public void testSkip_nonStructurallyModifiedList ( ) throws Exception { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; FluentIterable < String > tail = FluentIterable . from ( list ) . skip ( <int> ) ; Iterator < String > tailIterator = tail . iterator ( ) ; list . set ( <int> , <str> ) ; assertEquals ( <str> , tailIterator . next ( ) ) ; assertEquals ( <str> , tailIterator . next ( ) ) ; assertFalse ( tailIterator . hasNext ( ) ) ; } public void testSkip_structurallyModifiedSkipSome ( ) throws Exception { Collection < String > set = Sets . newLinkedHashSet ( ) ; Collections . addAll ( set , <str> , <str> , <str> ) ; FluentIterable < String > tail = FluentIterable . from ( set ) . skip ( <int> ) ; set . remove ( <str> ) ; set . addAll ( Lists . newArrayList ( <str> , <str> , <str> ) ) ; assertThat ( tail ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testSkip_structurallyModifiedSkipSomeList ( ) throws Exception { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; FluentIterable < String > tail = FluentIterable . from ( list ) . skip ( <int> ) ; list . subList ( <int> , <int> ) . clear ( ) ; list . addAll ( <int> , Lists . newArrayList ( <str> , <str> , <str> ) ) ; assertThat ( tail ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testSkip_structurallyModifiedSkipAll ( ) throws Exception { Collection < String > set = Sets . newLinkedHashSet ( ) ; Collections . addAll ( set , <str> , <str> , <str> ) ; FluentIterable < String > tail = FluentIterable . from ( set ) . skip ( <int> ) ; set . remove ( <str> ) ; set . remove ( <str> ) ; assertFalse ( tail . iterator ( ) . hasNext ( ) ) ; } public void testSkip_structurallyModifiedSkipAllList ( ) throws Exception { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; FluentIterable < String > tail = FluentIterable . from ( list ) . skip ( <int> ) ; list . subList ( <int> , <int> ) . clear ( ) ; assertThat ( tail ) . isEmpty ( ) ; } @SuppressWarnings ( <str> ) public void testSkip_illegalArgument ( ) { try { FluentIterable . from ( asList ( <str> , <str> , <str> ) ) . skip ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testLimit ( ) { Iterable < String > iterable = Lists . newArrayList ( <str> , <str> , <str> ) ; FluentIterable < String > limited = FluentIterable . from ( iterable ) . limit ( <int> ) ; assertEquals ( ImmutableList . of ( <str> , <str> ) , Lists . newArrayList ( limited ) ) ; assertCanIterateAgain ( limited ) ; assertEquals ( <str> , limited . toString ( ) ) ; } @SuppressWarnings ( <str> ) public void testLimit_illegalArgument ( ) { try { FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . limit ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testIsEmpty ( ) { assertTrue ( FluentIterable . < String > from ( Collections . < String > emptyList ( ) ) . isEmpty ( ) ) ; assertFalse ( FluentIterable . < String > from ( Lists . newArrayList ( <str> ) ) . isEmpty ( ) ) ; } public void testToList ( ) { assertEquals ( Lists . newArrayList ( <int> , <int> , <int> , <int> ) , fluent ( <int> , <int> , <int> , <int> ) . toList ( ) ) ; } public void testToList_empty ( ) { assertTrue ( fluent ( ) . toList ( ) . isEmpty ( ) ) ; } public void testToSortedList_withComparator ( ) { assertEquals ( Lists . newArrayList ( <int> , <int> , <int> , <int> ) , fluent ( <int> , <int> , <int> , <int> ) . toSortedList ( Ordering . < Integer > natural ( ) . reverse ( ) ) ) ; } public void testToSortedList_withDuplicates ( ) { assertEquals ( Lists . newArrayList ( <int> , <int> , <int> , <int> ) , fluent ( <int> , <int> , <int> , <int> ) . toSortedList ( Ordering . < Integer > natural ( ) . reverse ( ) ) ) ; } public void testToSet ( ) { assertThat ( fluent ( <int> , <int> , <int> , <int> ) . toSet ( ) ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testToSet_removeDuplicates ( ) { assertThat ( fluent ( <int> , <int> , <int> , <int> ) . toSet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testToSet_empty ( ) { assertTrue ( fluent ( ) . toSet ( ) . isEmpty ( ) ) ; } public void testToSortedSet ( ) { assertThat ( fluent ( <int> , <int> , <int> , <int> ) . toSortedSet ( Ordering . < Integer > natural ( ) . reverse ( ) ) ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testToSortedSet_removeDuplicates ( ) { assertThat ( fluent ( <int> , <int> , <int> , <int> ) . toSortedSet ( Ordering . < Integer > natural ( ) . reverse ( ) ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; } public void testToMultiset ( ) { assertThat ( fluent ( <int> , <int> , <int> , <int> , <int> , <int> ) . toMultiset ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testToMultiset_empty ( ) { assertThat ( fluent ( ) . toMultiset ( ) ) . isEmpty ( ) ; } public void testToMap ( ) { assertThat ( fluent ( <int> , <int> , <int> ) . toMap ( Functions . toStringFunction ( ) ) . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <int> , <str> ) , Maps . immutableEntry ( <int> , <str> ) , Maps . immutableEntry ( <int> , <str> ) ) . inOrder ( ) ; } public void testToMap_nullKey ( ) { try { fluent ( <int> , null , <int> ) . toMap ( Functions . constant ( <str> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testToMap_nullValue ( ) { try { fluent ( <int> , <int> , <int> ) . toMap ( Functions . constant ( null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testIndex ( ) { ImmutableListMultimap < Integer , String > expected = ImmutableListMultimap . < Integer , String > builder ( ) . putAll ( <int> , <str> , <str> ) . put ( <int> , <str> ) . put ( <int> , <str> ) . build ( ) ; ImmutableListMultimap < Integer , String > index = FluentIterable . from ( asList ( <str> , <str> , <str> , <str> ) ) . index ( new Function < String , Integer > ( ) { @Override public Integer apply ( String input ) { return input . length ( ) ; } } ) ; assertEquals ( expected , index ) ; } public void testIndex_nullKey ( ) { try { fluent ( <int> , <int> , <int> ) . index ( Functions . constant ( null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testIndex_nullValue ( ) { try { fluent ( <int> , null , <int> ) . index ( Functions . constant ( <str> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testUniqueIndex ( ) { ImmutableMap < Integer , String > expected = ImmutableMap . of ( <int> , <str> , <int> , <str> , <int> , <str> ) ; ImmutableMap < Integer , String > index = FluentIterable . from ( asList ( <str> , <str> , <str> ) ) . uniqueIndex ( new Function < String , Integer > ( ) { @Override public Integer apply ( String input ) { return input . length ( ) ; } } ) ; assertEquals ( expected , index ) ; } public void testUniqueIndex_duplicateKey ( ) { try { FluentIterable . from ( asList ( <str> , <str> , <str> , <str> ) ) . uniqueIndex ( new Function < String , Integer > ( ) { @Override public Integer apply ( String input ) { return input . length ( ) ; } } ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testUniqueIndex_nullKey ( ) { try { fluent ( <int> , <int> , <int> ) . uniqueIndex ( Functions . constant ( null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testUniqueIndex_nullValue ( ) { try { fluent ( <int> , null , <int> ) . uniqueIndex ( new Function < Integer , Object > ( ) { @Override public Object apply ( @Nullable Integer input ) { return String . valueOf ( input ) ; } } ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCopyInto_List ( ) { assertThat ( fluent ( <int> , <int> , <int> ) . copyInto ( Lists . newArrayList ( <int> , <int> ) ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testCopyInto_Set ( ) { assertThat ( fluent ( <int> , <int> , <int> ) . copyInto ( Sets . newHashSet ( <int> , <int> ) ) ) . containsExactly ( <int> , <int> , <int> , <int> ) ; } public void testCopyInto_SetAllDuplicates ( ) { assertThat ( fluent ( <int> , <int> , <int> ) . copyInto ( Sets . newHashSet ( <int> , <int> , <int> , <int> ) ) ) . containsExactly ( <int> , <int> , <int> , <int> ) ; } public void testCopyInto_NonCollection ( ) { final ArrayList < Integer > list = Lists . newArrayList ( <int> , <int> , <int> ) ; final ArrayList < Integer > iterList = Lists . newArrayList ( <int> , <int> , <int> ) ; Iterable < Integer > iterable = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return iterList . iterator ( ) ; } } ; assertThat ( FluentIterable . from ( iterable ) . copyInto ( list ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testJoin ( ) { assertEquals ( <str> , fluent ( <int> , <int> , <int> , <int> ) . join ( Joiner . on ( <str> ) ) ) ; } public void testJoin_empty ( ) { assertEquals ( <str> , fluent ( ) . join ( Joiner . on ( <str> ) ) ) ; } public void testGet ( ) { assertEquals ( <str> , FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . get ( <int> ) ) ; assertEquals ( <str> , FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . get ( <int> ) ) ; assertEquals ( <str> , FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . get ( <int> ) ) ; } public void testGet_outOfBounds ( ) { try { FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . get ( - <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } try { FluentIterable . from ( Lists . newArrayList ( <str> , <str> , <str> ) ) . get ( <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } private static void assertCanIterateAgain ( Iterable < ? > iterable ) { for ( @SuppressWarnings ( <str> ) Object obj : iterable ) { } } private static FluentIterable < Integer > fluent ( Integer . . . elements ) { return FluentIterable . from ( Lists . newArrayList ( elements ) ) ; } private static Iterable < String > iterable ( String . . . elements ) { final List < String > list = asList ( elements ) ; return new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return list . iterator ( ) ; } } ; } } 
