package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . marshal . SetType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . ListType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . utils . * ; public class RowUpdateBuilder { private final PartitionUpdate update ; private final long timestamp ; private final int ttl ; private final int localDeletionTime ; private final DeletionTime deletionTime ; private final Mutation mutation ; private Row . Builder regularBuilder ; private Row . Builder staticBuilder ; private boolean useRowMarker = true ; private RowUpdateBuilder ( PartitionUpdate update , long timestamp , int ttl , int localDeletionTime , Mutation mutation ) { this . update = update ; this . timestamp = timestamp ; this . ttl = ttl ; this . localDeletionTime = localDeletionTime ; this . deletionTime = new DeletionTime ( timestamp , localDeletionTime ) ; this . mutation = mutation = = null ? new Mutation ( update . metadata ( ) . ksName , update . partitionKey ( ) ) . add ( update ) : mutation ; } private RowUpdateBuilder ( PartitionUpdate update , long timestamp , int ttl , Mutation mutation ) { this ( update , timestamp , ttl , FBUtilities . nowInSeconds ( ) , mutation ) ; } private void startRow ( Clustering clustering ) { assert staticBuilder = = null : <str> ; assert regularBuilder = = null : <str> ; regularBuilder = BTreeRow . unsortedBuilder ( FBUtilities . nowInSeconds ( ) ) ; regularBuilder . newRow ( clustering ) ; if ( update . metadata ( ) . isCQLTable ( ) & & useRowMarker ) regularBuilder . addPrimaryKeyLivenessInfo ( LivenessInfo . create ( update . metadata ( ) , timestamp , ttl , localDeletionTime ) ) ; } private Row . Builder builder ( ) { assert staticBuilder = = null : <str> ; if ( regularBuilder = = null ) { assert update . metadata ( ) . comparator . size ( ) = = <int> : <str> ; startRow ( Clustering . EMPTY ) ; } return regularBuilder ; } private Row . Builder staticBuilder ( ) { assert regularBuilder = = null : <str> ; if ( staticBuilder = = null ) { staticBuilder = BTreeRow . unsortedBuilder ( FBUtilities . nowInSeconds ( ) ) ; staticBuilder . newRow ( Clustering . STATIC_CLUSTERING ) ; } return staticBuilder ; } private Row . Builder builder ( ColumnDefinition c ) { return c . isStatic ( ) ? staticBuilder ( ) : builder ( ) ; } public RowUpdateBuilder ( CFMetaData metadata , long timestamp , Object partitionKey ) { this ( metadata , FBUtilities . nowInSeconds ( ) , timestamp , partitionKey ) ; } public RowUpdateBuilder ( CFMetaData metadata , int localDeletionTime , long timestamp , Object partitionKey ) { this ( metadata , localDeletionTime , timestamp , metadata . params . defaultTimeToLive , partitionKey ) ; } public RowUpdateBuilder ( CFMetaData metadata , long timestamp , int ttl , Object partitionKey ) { this ( metadata , FBUtilities . nowInSeconds ( ) , timestamp , ttl , partitionKey ) ; } public RowUpdateBuilder ( CFMetaData metadata , int localDeletionTime , long timestamp , int ttl , Object partitionKey ) { this ( new PartitionUpdate ( metadata , makeKey ( metadata , partitionKey ) , metadata . partitionColumns ( ) , <int> ) , timestamp , ttl , localDeletionTime , null ) ; } public RowUpdateBuilder ( CFMetaData metadata , long timestamp , Mutation mutation ) { this ( metadata , timestamp , LivenessInfo . NO_TTL , mutation ) ; } public RowUpdateBuilder ( CFMetaData metadata , long timestamp , int ttl , Mutation mutation ) { this ( getOrAdd ( metadata , mutation ) , timestamp , ttl , mutation ) ; } public RowUpdateBuilder ( PartitionUpdate update , long timestamp , int ttl ) { this ( update , timestamp , ttl , null ) ; } public RowUpdateBuilder noRowMarker ( ) { this . useRowMarker = false ; return this ; } public RowUpdateBuilder clustering ( Object . . . clusteringValues ) { assert clusteringValues . length = = update . metadata ( ) . comparator . size ( ) : <str> + update . metadata ( ) . comparator . size ( ) + <str> + clusteringValues . length ; startRow ( clusteringValues . length = = <int> ? Clustering . EMPTY : update . metadata ( ) . comparator . make ( clusteringValues ) ) ; return this ; } public Mutation build ( ) { Row . Builder builder = regularBuilder = = null ? staticBuilder : regularBuilder ; if ( builder ! = null ) update . add ( builder . build ( ) ) ; return mutation ; } public PartitionUpdate buildUpdate ( ) { build ( ) ; return update ; } private static void deleteRow ( PartitionUpdate update , long timestamp , int localDeletionTime , Object . . . clusteringValues ) { assert clusteringValues . length = = update . metadata ( ) . comparator . size ( ) | | ( clusteringValues . length = = <int> & & ! update . columns ( ) . statics . isEmpty ( ) ) ; boolean isStatic = clusteringValues . length ! = update . metadata ( ) . comparator . size ( ) ; Row . Builder builder = BTreeRow . sortedBuilder ( ) ; if ( isStatic ) builder . newRow ( Clustering . STATIC_CLUSTERING ) ; else builder . newRow ( clusteringValues . length = = <int> ? Clustering . EMPTY : update . metadata ( ) . comparator . make ( clusteringValues ) ) ; builder . addRowDeletion ( Row . Deletion . regular ( new DeletionTime ( timestamp , localDeletionTime ) ) ) ; update . add ( builder . build ( ) ) ; } public static Mutation deleteRow ( CFMetaData metadata , long timestamp , Mutation mutation , Object . . . clusteringValues ) { deleteRow ( getOrAdd ( metadata , mutation ) , timestamp , FBUtilities . nowInSeconds ( ) , clusteringValues ) ; return mutation ; } public static Mutation deleteRow ( CFMetaData metadata , long timestamp , Object key , Object . . . clusteringValues ) { return deleteRowAt ( metadata , timestamp , FBUtilities . nowInSeconds ( ) , key , clusteringValues ) ; } public static Mutation deleteRowAt ( CFMetaData metadata , long timestamp , int localDeletionTime , Object key , Object . . . clusteringValues ) { PartitionUpdate update = new PartitionUpdate ( metadata , makeKey ( metadata , key ) , metadata . partitionColumns ( ) , <int> ) ; deleteRow ( update , timestamp , localDeletionTime , clusteringValues ) ; return new Mutation ( update . metadata ( ) . ksName , update . partitionKey ( ) ) . add ( update ) ; } private static DecoratedKey makeKey ( CFMetaData metadata , Object . . . partitionKey ) { if ( partitionKey . length = = <int> & & partitionKey [ <int> ] instanceof DecoratedKey ) return ( DecoratedKey ) partitionKey [ <int> ] ; ByteBuffer key = CFMetaData . serializePartitionKey ( metadata . getKeyValidatorAsClusteringComparator ( ) . make ( partitionKey ) ) ; return metadata . decorateKey ( key ) ; } private static PartitionUpdate getOrAdd ( CFMetaData metadata , Mutation mutation ) { PartitionUpdate upd = mutation . get ( metadata ) ; if ( upd = = null ) { upd = new PartitionUpdate ( metadata , mutation . key ( ) , metadata . partitionColumns ( ) , <int> ) ; mutation . add ( upd ) ; } return upd ; } public RowUpdateBuilder resetCollection ( String columnName ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c ! = null : <str> + columnName ; assert c . isStatic ( ) | | update . metadata ( ) . comparator . size ( ) = = <int> | | regularBuilder ! = null : <str> + c + <str> ; assert c . type . isCollection ( ) & & c . type . isMultiCell ( ) ; builder ( c ) . addComplexDeletion ( c , new DeletionTime ( timestamp - <int> , localDeletionTime ) ) ; return this ; } public RowUpdateBuilder addRangeTombstone ( RangeTombstone rt ) { update . add ( rt ) ; return this ; } public RowUpdateBuilder addRangeTombstone ( Slice slice ) { return addRangeTombstone ( new RangeTombstone ( slice , deletionTime ) ) ; } public RowUpdateBuilder addRangeTombstone ( Object start , Object end ) { ClusteringComparator cmp = update . metadata ( ) . comparator ; Slice slice = Slice . make ( cmp . make ( start ) , cmp . make ( end ) ) ; return addRangeTombstone ( slice ) ; } public RowUpdateBuilder add ( String columnName , Object value ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c ! = null : <str> + columnName ; return add ( c , value ) ; } private Cell makeCell ( ColumnDefinition c , ByteBuffer value , CellPath path ) { return value = = null ? BufferCell . tombstone ( c , timestamp , localDeletionTime ) : ( ttl = = LivenessInfo . NO_TTL ? BufferCell . live ( update . metadata ( ) , c , timestamp , value , path ) : BufferCell . expiring ( c , timestamp , ttl , localDeletionTime , value , path ) ) ; } public RowUpdateBuilder add ( ColumnDefinition columnDefinition , Object value ) { assert columnDefinition . isStatic ( ) | | update . metadata ( ) . comparator . size ( ) = = <int> | | regularBuilder ! = null : <str> + columnDefinition + <str> ; builder ( columnDefinition ) . addCell ( makeCell ( columnDefinition , bb ( value , columnDefinition . type ) , null ) ) ; return this ; } public RowUpdateBuilder delete ( String columnName ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c ! = null : <str> + columnName ; return delete ( c ) ; } public RowUpdateBuilder delete ( ColumnDefinition columnDefinition ) { return add ( columnDefinition , null ) ; } private static ByteBuffer bb ( Object value , AbstractType < ? > type ) { if ( value = = null ) return null ; if ( value instanceof ByteBuffer ) return ( ByteBuffer ) value ; if ( type . isCounter ( ) ) { assert value instanceof Long : <str> ; return CounterContext . instance ( ) . createGlobal ( CounterId . getLocalId ( ) , <int> , ( Long ) value ) ; } return ( ( AbstractType ) type ) . decompose ( value ) ; } public RowUpdateBuilder map ( String columnName , Map < ? , ? > map ) { resetCollection ( columnName ) ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) addMapEntry ( columnName , entry . getKey ( ) , entry . getValue ( ) ) ; return this ; } public RowUpdateBuilder set ( String columnName , Set < ? > set ) { resetCollection ( columnName ) ; for ( Object element : set ) addSetEntry ( columnName , element ) ; return this ; } public RowUpdateBuilder frozenList ( String columnName , List < ? > list ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof ListType & & ! c . type . isMultiCell ( ) : <str> + c + <str> ; builder ( c ) . addCell ( makeCell ( c , bb ( ( ( AbstractType ) c . type ) . decompose ( list ) , c . type ) , null ) ) ; return this ; } public RowUpdateBuilder frozenSet ( String columnName , Set < ? > set ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof SetType & & ! c . type . isMultiCell ( ) : <str> + c + <str> ; builder ( c ) . addCell ( makeCell ( c , bb ( ( ( AbstractType ) c . type ) . decompose ( set ) , c . type ) , null ) ) ; return this ; } public RowUpdateBuilder frozenMap ( String columnName , Map < ? , ? > map ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof MapType & & ! c . type . isMultiCell ( ) : <str> + c + <str> ; builder ( c ) . addCell ( makeCell ( c , bb ( ( ( AbstractType ) c . type ) . decompose ( map ) , c . type ) , null ) ) ; return this ; } public RowUpdateBuilder addMapEntry ( String columnName , Object key , Object value ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | update . metadata ( ) . comparator . size ( ) = = <int> | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof MapType & & c . type . isMultiCell ( ) : <str> + c + <str> ; MapType mt = ( MapType ) c . type ; builder ( c ) . addCell ( makeCell ( c , bb ( value , mt . getValuesType ( ) ) , CellPath . create ( bb ( key , mt . getKeysType ( ) ) ) ) ) ; return this ; } public RowUpdateBuilder addListEntry ( String columnName , Object value ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof ListType & & c . type . isMultiCell ( ) : <str> + c + <str> ; ListType lt = ( ListType ) c . type ; builder ( c ) . addCell ( makeCell ( c , bb ( value , lt . getElementsType ( ) ) , CellPath . create ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) ) ) ; return this ; } public RowUpdateBuilder addSetEntry ( String columnName , Object value ) { ColumnDefinition c = getDefinition ( columnName ) ; assert c . isStatic ( ) | | regularBuilder ! = null : <str> + c + <str> ; assert c . type instanceof SetType & & c . type . isMultiCell ( ) : <str> + c + <str> ; SetType st = ( SetType ) c . type ; builder ( c ) . addCell ( makeCell ( c , ByteBufferUtil . EMPTY_BYTE_BUFFER , CellPath . create ( bb ( value , st . getElementsType ( ) ) ) ) ) ; return this ; } private ColumnDefinition getDefinition ( String name ) { return update . metadata ( ) . getColumnDefinition ( new ColumnIdentifier ( name , true ) ) ; } public UnfilteredRowIterator unfilteredIterator ( ) { return update . unfilteredIterator ( ) ; } } 
