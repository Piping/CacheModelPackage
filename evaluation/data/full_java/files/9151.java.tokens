package com . google . common . cache ; import java . util . Random ; abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( <str> ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <int> , <int> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc = = null ) { threadHashCode . set ( hc = new int [ <int> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <int> ] = ( r = = <int> ) ? <int> : r ; } else h = hc [ <int> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) ! = null & & ( n = as . length ) > <int> ) { if ( ( a = as [ ( n - <int> ) & h ] ) = = null ) { if ( busy = = <int> ) { Cell r = new Cell ( x ) ; if ( busy = = <int> & & casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) ! = null & & ( m = rs . length ) > <int> & & rs [ j = ( m - <int> ) & h ] = = null ) { rs [ j ] = r ; created = true ; } } finally { busy = <int> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n > = NCPU | | cells ! = as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy = = <int> & & casBusy ( ) ) { try { if ( cells = = as ) { Cell [ ] rs = new Cell [ n < < <int> ] ; for ( int i = <int> ; i < n ; + + i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <int> ; } collide = false ; continue ; } h ^ = h < < <int> ; h ^ = h > > > <int> ; h ^ = h < < <int> ; hc [ <int> ] = h ; } else if ( busy = = <int> & & cells = = as & & casBusy ( ) ) { boolean init = false ; try { if ( cells = = as ) { Cell [ ] rs = new Cell [ <int> ] ; rs [ h & <int> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <int> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as ! = null ) { int n = as . length ; for ( int i = <int> ; i < n ; + + i ) { Cell a = as [ i ] ; if ( a ! = null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ; private static final long baseOffset ; private static final long busyOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > sk = Striped64 . class ; baseOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( <str> ) ) ; busyOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( <str> ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } } 
