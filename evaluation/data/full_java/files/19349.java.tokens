package io . netty . handler . codec . http2 ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . channel . ChannelHandlerAdapter ; import io . netty . handler . logging . LogLevel ; import io . netty . util . internal . logging . InternalLogLevel ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; public class Http2FrameLogger extends ChannelHandlerAdapter { public enum Direction { INBOUND , OUTBOUND } private static final int BUFFER_LENGTH_THRESHOLD = <int> ; private final InternalLogger logger ; private final InternalLogLevel level ; public Http2FrameLogger ( LogLevel level ) { this ( level . toInternalLevel ( ) , InternalLoggerFactory . getInstance ( Http2FrameLogger . class ) ) ; } public Http2FrameLogger ( LogLevel level , String name ) { this ( level . toInternalLevel ( ) , InternalLoggerFactory . getInstance ( name ) ) ; } public Http2FrameLogger ( LogLevel level , Class < ? > clazz ) { this ( level . toInternalLevel ( ) , InternalLoggerFactory . getInstance ( clazz ) ) ; } private Http2FrameLogger ( InternalLogLevel level , InternalLogger logger ) { this . level = checkNotNull ( level , <str> ) ; this . logger = checkNotNull ( logger , <str> ) ; } public void logData ( Direction direction , int streamId , ByteBuf data , int padding , boolean endStream ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , padding , endStream , data . readableBytes ( ) , toString ( data ) ) ; } } public void logHeaders ( Direction direction , int streamId , Http2Headers headers , int padding , boolean endStream ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , headers , padding , endStream ) ; } } public void logHeaders ( Direction direction , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) { if ( enabled ( ) ) { log ( direction , <str> + <str> , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; } } public void logPriority ( Direction direction , int streamId , int streamDependency , short weight , boolean exclusive ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , streamDependency , weight , exclusive ) ; } } public void logRstStream ( Direction direction , int streamId , long errorCode ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , errorCode ) ; } } public void logSettingsAck ( Direction direction ) { if ( enabled ( ) ) { log ( direction , <str> ) ; } } public void logSettings ( Direction direction , Http2Settings settings ) { if ( enabled ( ) ) { log ( direction , <str> , settings ) ; } } public void logPing ( Direction direction , ByteBuf data ) { if ( enabled ( ) ) { log ( direction , <str> , data . readableBytes ( ) , toString ( data ) ) ; } } public void logPingAck ( Direction direction , ByteBuf data ) { if ( enabled ( ) ) { log ( direction , <str> , data . readableBytes ( ) , toString ( data ) ) ; } } public void logPushPromise ( Direction direction , int streamId , int promisedStreamId , Http2Headers headers , int padding ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , promisedStreamId , headers , padding ) ; } } public void logGoAway ( Direction direction , int lastStreamId , long errorCode , ByteBuf debugData ) { if ( enabled ( ) ) { log ( direction , <str> , lastStreamId , errorCode , debugData . readableBytes ( ) , toString ( debugData ) ) ; } } public void logWindowsUpdate ( Direction direction , int streamId , int windowSizeIncrement ) { if ( enabled ( ) ) { log ( direction , <str> , streamId , windowSizeIncrement ) ; } } public void logUnknownFrame ( Direction direction , byte frameType , int streamId , Http2Flags flags , ByteBuf data ) { if ( enabled ( ) ) { log ( direction , <str> , frameType & <hex> , streamId , flags . value ( ) , data . readableBytes ( ) , toString ( data ) ) ; } } private boolean enabled ( ) { return logger . isEnabled ( level ) ; } private String toString ( ByteBuf buf ) { if ( level = = InternalLogLevel . TRACE | | buf . readableBytes ( ) < = BUFFER_LENGTH_THRESHOLD ) { return ByteBufUtil . hexDump ( buf ) ; } int length = Math . min ( buf . readableBytes ( ) , BUFFER_LENGTH_THRESHOLD ) ; return ByteBufUtil . hexDump ( buf , buf . readerIndex ( ) , length ) + <str> ; } private void log ( Direction direction , String format , Object . . . args ) { StringBuilder b = new StringBuilder ( <int> ) ; b . append ( <str> ) . append ( direction . name ( ) ) . append ( <str> ) . append ( String . format ( format , args ) ) . append ( <str> ) ; logger . log ( level , b . toString ( ) ) ; } } 
