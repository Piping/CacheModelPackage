package io . netty . handler . codec . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . memcache . AbstractMemcacheObjectDecoder ; import io . netty . handler . codec . memcache . DefaultLastMemcacheContent ; import io . netty . handler . codec . memcache . DefaultMemcacheContent ; import io . netty . handler . codec . memcache . LastMemcacheContent ; import io . netty . handler . codec . memcache . MemcacheContent ; import io . netty . util . CharsetUtil ; import java . util . List ; import static io . netty . buffer . ByteBufUtil . * ; public abstract class AbstractBinaryMemcacheDecoder < M extends BinaryMemcacheMessage > extends AbstractMemcacheObjectDecoder { public static final int DEFAULT_MAX_CHUNK_SIZE = <int> ; private final int chunkSize ; private M currentMessage ; private int alreadyReadChunkSize ; private State state = State . READ_HEADER ; protected AbstractBinaryMemcacheDecoder ( ) { this ( DEFAULT_MAX_CHUNK_SIZE ) ; } protected AbstractBinaryMemcacheDecoder ( int chunkSize ) { if ( chunkSize < <int> ) { throw new IllegalArgumentException ( <str> + chunkSize ) ; } this . chunkSize = chunkSize ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { switch ( state ) { case READ_HEADER : try { if ( in . readableBytes ( ) < <int> ) { return ; } resetDecoder ( ) ; currentMessage = decodeHeader ( in ) ; state = State . READ_EXTRAS ; } catch ( Exception e ) { out . add ( invalidMessage ( e ) ) ; return ; } case READ_EXTRAS : try { byte extrasLength = currentMessage . extrasLength ( ) ; if ( extrasLength > <int> ) { if ( in . readableBytes ( ) < extrasLength ) { return ; } currentMessage . setExtras ( readBytes ( ctx . alloc ( ) , in , extrasLength ) ) ; } state = State . READ_KEY ; } catch ( Exception e ) { out . add ( invalidMessage ( e ) ) ; return ; } case READ_KEY : try { short keyLength = currentMessage . keyLength ( ) ; if ( keyLength > <int> ) { if ( in . readableBytes ( ) < keyLength ) { return ; } currentMessage . setKey ( in . toString ( in . readerIndex ( ) , keyLength , CharsetUtil . UTF_8 ) ) ; in . skipBytes ( keyLength ) ; } out . add ( currentMessage ) ; state = State . READ_CONTENT ; } catch ( Exception e ) { out . add ( invalidMessage ( e ) ) ; return ; } case READ_CONTENT : try { int valueLength = currentMessage . totalBodyLength ( ) - currentMessage . keyLength ( ) - currentMessage . extrasLength ( ) ; int toRead = in . readableBytes ( ) ; if ( valueLength > <int> ) { if ( toRead = = <int> ) { return ; } if ( toRead > chunkSize ) { toRead = chunkSize ; } int remainingLength = valueLength - alreadyReadChunkSize ; if ( toRead > remainingLength ) { toRead = remainingLength ; } ByteBuf chunkBuffer = readBytes ( ctx . alloc ( ) , in , toRead ) ; MemcacheContent chunk ; if ( ( alreadyReadChunkSize + = toRead ) > = valueLength ) { chunk = new DefaultLastMemcacheContent ( chunkBuffer ) ; } else { chunk = new DefaultMemcacheContent ( chunkBuffer ) ; } out . add ( chunk ) ; if ( alreadyReadChunkSize < valueLength ) { return ; } } else { out . add ( LastMemcacheContent . EMPTY_LAST_CONTENT ) ; } state = State . READ_HEADER ; return ; } catch ( Exception e ) { out . add ( invalidChunk ( e ) ) ; return ; } case BAD_MESSAGE : in . skipBytes ( actualReadableBytes ( ) ) ; return ; default : throw new Error ( <str> + state ) ; } } private M invalidMessage ( Exception cause ) { state = State . BAD_MESSAGE ; M message = buildInvalidMessage ( ) ; message . setDecoderResult ( DecoderResult . failure ( cause ) ) ; return message ; } private MemcacheContent invalidChunk ( Exception cause ) { state = State . BAD_MESSAGE ; MemcacheContent chunk = new DefaultLastMemcacheContent ( Unpooled . EMPTY_BUFFER ) ; chunk . setDecoderResult ( DecoderResult . failure ( cause ) ) ; return chunk ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { super . channelInactive ( ctx ) ; if ( currentMessage ! = null ) { currentMessage . release ( ) ; } resetDecoder ( ) ; } protected void resetDecoder ( ) { currentMessage = null ; alreadyReadChunkSize = <int> ; } protected abstract M decodeHeader ( ByteBuf in ) ; protected abstract M buildInvalidMessage ( ) ; enum State { READ_HEADER , READ_EXTRAS , READ_KEY , READ_CONTENT , BAD_MESSAGE } } 
