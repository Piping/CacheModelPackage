package org . elasticsearch . index . mapper . geo ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . GeoUtils ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . search . SearchHitField ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . test . VersionUtils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . isIn ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class GeoPointFieldMapperTests extends ESSingleNodeTestCase { public void testLatLonValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; boolean indexCreatedBefore22 = version . before ( Version . V_2_2_0 ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; final boolean stored = indexCreatedBefore22 = = false ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . stored ( ) , is ( stored ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . stored ( ) , is ( stored ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; if ( indexCreatedBefore22 = = true ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLatLonValuesWithGeohash ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( GeoHashUtils . stringEncode ( <float> , <float> ) ) ) ; } public void testLatLonInOneValueWithGeohash ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( GeoHashUtils . stringEncode ( <float> , <float> ) ) ) ; } public void testGeoHashIndexValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( GeoHashUtils . stringEncode ( <float> , <float> ) ) ) ; } public void testGeoHashValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , notNullValue ( ) ) ; } public void testNormalizeLatLonValuesDefault ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) ; if ( version . before ( Version . V_2_2_0 ) ) { mapping . field ( <str> , true ) ; } mapping . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , - <int> ) . field ( <str> , - <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( - <float> , - <float> ) ) ) ; } doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( - <float> , - <float> ) ) ) ; } } public void testValidateLatLonValues ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) ; if ( version . before ( Version . V_2_2_0 ) ) { mapping . field ( <str> , false ) ; } mapping . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , - <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; fail ( ) ; } catch ( MapperParsingException e ) { } try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; fail ( ) ; } catch ( MapperParsingException e ) { } try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , - <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; fail ( ) ; } catch ( MapperParsingException e ) { } try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; fail ( ) ; } catch ( MapperParsingException e ) { } } public void testNoValidateLatLonValues ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) ; if ( version . before ( Version . V_2_2_0 ) ) { mapping . field ( <str> , false ) ; } mapping . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , - <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , - <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; } public void testLatLonValuesStored ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testArrayLatLonValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLatLonInOneValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLatLonInOneValueStored ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLatLonInOneValueArray ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <str> ) . value ( <str> ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLonLatArray ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLonLatArrayDynamic ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startArray ( <str> ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLonLatArrayStored ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLonLatArrayArrayStored ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) . length , equalTo ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; assertThat ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . numericValue ( ) . doubleValue ( ) , equalTo ( <float> ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . getFields ( <str> ) [ <int> ] . stringValue ( ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testOptionDeprecation ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_2_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapperParser parser = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) ; try { String validateMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( validateMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } try { String validateMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( validateMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } try { String validateMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( validateMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } try { String normalizeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( normalizeMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } try { String normalizeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( normalizeMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } try { String normalizeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( normalizeMapping ) ; fail ( <str> + MapperParsingException . class . getName ( ) + <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } } public void testBackwardCompatibleOptions ( ) throws Exception { Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . V_1_7_1 ) ) . build ( ) ; DocumentMapperParser parser = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; } public void testGeoPointMapperMerge ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_2_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; String stage1Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; MapperService mapperService = createIndex ( <str> , settings ) . mapperService ( ) ; DocumentMapper stage1 = mapperService . merge ( <str> , new CompressedXContent ( stage1Mapping ) , true , false ) ; String stage2Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( stage2Mapping ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } stage2Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; mapperService . merge ( <str> , new CompressedXContent ( stage2Mapping ) , false , false ) ; } public void testGeoHashSearch ( ) throws Exception { int precision = randomIntBetween ( <int> , <int> ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , precision ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; CreateIndexRequestBuilder mappingRequest = client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ; mappingRequest . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , - <float> ) . endObject ( ) . endObject ( ) ) . setRefresh ( true ) . execute ( ) . actionGet ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . addField ( <str> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) ; Map < String , SearchHitField > m = searchResponse . getHits ( ) . getAt ( <int> ) . getFields ( ) ; assertEquals ( <str> . substring ( <int> , precision ) , m . get ( <str> ) . value ( ) ) ; } public void testGeoHashSearchWithPrefix ( ) throws Exception { int precision = randomIntBetween ( <int> , <int> ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , precision ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; CreateIndexRequestBuilder mappingRequest = client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ; mappingRequest . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , - <float> ) . endObject ( ) . endObject ( ) ) . setRefresh ( true ) . execute ( ) . actionGet ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . addField ( <str> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) ; Map < String , SearchHitField > m = searchResponse . getHits ( ) . getAt ( <int> ) . getFields ( ) ; List < Object > hashes = m . get ( <str> ) . values ( ) ; final int numHashes = hashes . size ( ) ; for ( int i = <int> ; i < numHashes ; + + i ) { assertEquals ( <str> . substring ( <int> , numHashes - i ) , hashes . get ( i ) ) ; } } } 
