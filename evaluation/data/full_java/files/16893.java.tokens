package java . io ; import java . util . ArrayList ; import com . google . gwt . storage . client . Storage ; public class File { public static final File ROOT = new File ( <str> ) ; public static final char separatorChar = <str> ; public static final String separator = <str> + separatorChar ; public static final char pathSeparatorChar = <str> ; public static final String pathSeparator = <str> + pathSeparatorChar ; public static final Storage LocalStorage = Storage . getLocalStorageIfSupported ( ) ; File parent ; String name ; boolean absolute ; public File ( String pathname ) { while ( pathname . endsWith ( separator ) & & pathname . length ( ) > <int> ) { pathname = pathname . substring ( <int> , pathname . length ( ) - <int> ) ; } int cut = pathname . lastIndexOf ( separatorChar ) ; if ( cut = = - <int> ) { name = pathname ; } else if ( cut = = <int> ) { name = pathname . substring ( cut ) ; parent = name . equals ( <str> ) ? null : ROOT ; } else { name = pathname . substring ( cut + <int> ) ; parent = new File ( pathname . substring ( <int> , cut ) ) ; } } public File ( String parent , String child ) { this ( new File ( parent ) , child ) ; } public File ( File parent , String child ) { this . parent = parent ; this . name = child ; } public String getName ( ) { return name ; } public String getParent ( ) { return parent = = null ? <str> : parent . getPath ( ) ; } public File getParentFile ( ) { return parent ; } public String getPath ( ) { return parent = = null ? name : ( parent . getPath ( ) + separatorChar + name ) ; } private boolean isRoot ( ) { return name . equals ( <str> ) & & parent = = null ; } public boolean isAbsolute ( ) { if ( isRoot ( ) ) { return true ; } if ( parent = = null ) { return false ; } return parent . isAbsolute ( ) ; } public String getAbsolutePath ( ) { String path = getAbsoluteFile ( ) . getPath ( ) ; return path . length ( ) = = <int> ? <str> : path ; } public File getAbsoluteFile ( ) { if ( isAbsolute ( ) ) { return this ; } if ( parent = = null ) { return new File ( ROOT , name ) ; } return new File ( parent . getAbsoluteFile ( ) , name ) ; } public String getCanonicalPath ( ) { return getCanonicalFile ( ) . getAbsolutePath ( ) ; } public File getCanonicalFile ( ) { File cParent = parent = = null ? null : parent . getCanonicalFile ( ) ; if ( name . equals ( <str> ) ) { return cParent = = null ? ROOT : cParent ; } if ( cParent ! = null & & cParent . name . equals ( <str> ) ) { cParent = null ; } if ( name . equals ( <str> ) ) { if ( cParent = = null ) { return ROOT ; } if ( cParent . parent = = null ) { return ROOT ; } return cParent . parent ; } if ( cParent = = null & & ! name . equals ( <str> ) ) { return new File ( ROOT , name ) ; } return new File ( cParent , name ) ; } public boolean canRead ( ) { return true ; } public boolean canWrite ( ) { return true ; } public boolean exists ( ) { return LocalStorage . getItem ( getCanonicalPath ( ) ) ! = null ; } public boolean isDirectory ( ) { String s = LocalStorage . getItem ( getCanonicalPath ( ) ) ; return s ! = null & & s . startsWith ( <str> ) ; } public boolean isFile ( ) { String s = LocalStorage . getItem ( getCanonicalPath ( ) ) ; return s ! = null & & ! s . startsWith ( <str> ) ; } public boolean isHidden ( ) { return false ; } public long lastModified ( ) { return <int> ; } public long length ( ) { try { if ( ! exists ( ) ) { return <int> ; } RandomAccessFile raf = new RandomAccessFile ( this , <str> ) ; long len = raf . length ( ) ; raf . close ( ) ; return len ; } catch ( IOException e ) { return <int> ; } } public boolean createNewFile ( ) throws IOException { if ( exists ( ) ) return false ; if ( ! parent . exists ( ) ) return false ; LocalStorage . setItem ( getCanonicalPath ( ) , RandomAccessFile . btoa ( <str> ) ) ; return true ; } public boolean delete ( ) { if ( ! exists ( ) ) { return false ; } LocalStorage . removeItem ( getCanonicalPath ( ) ) ; return true ; } public void deleteOnExit ( ) { throw new RuntimeException ( <str> ) ; } public String [ ] list ( ) { throw new RuntimeException ( <str> ) ; } public File [ ] listFiles ( ) { return listFiles ( null ) ; } public File [ ] listFiles ( FilenameFilter filter ) { ArrayList < File > files = new ArrayList < File > ( ) ; String prefix = getCanonicalPath ( ) ; if ( ! prefix . endsWith ( separator ) ) { prefix + = separatorChar ; } int cut = prefix . length ( ) ; int cnt = LocalStorage . getLength ( ) ; for ( int i = <int> ; i < cnt ; i + + ) { String key = LocalStorage . key ( i ) ; if ( key . startsWith ( prefix ) & & key . indexOf ( separatorChar , cut ) = = - <int> ) { String name = key . substring ( cut ) ; if ( filter = = null | | filter . accept ( this , name ) ) { files . add ( new File ( this , name ) ) ; } } } return files . toArray ( new File [ files . size ( ) ] ) ; } public boolean mkdir ( ) { if ( parent ! = null & & ! parent . exists ( ) ) { return false ; } if ( exists ( ) ) { return false ; } LocalStorage . setItem ( getCanonicalPath ( ) , <str> ) ; return true ; } public boolean mkdirs ( ) { if ( parent ! = null ) { parent . mkdirs ( ) ; } return mkdir ( ) ; } public boolean renameTo ( File dest ) { throw new RuntimeException ( <str> ) ; } public boolean setLastModified ( long time ) { return false ; } public boolean setReadOnly ( ) { return false ; } public static File [ ] listRoots ( ) { return new File [ ] { ROOT } ; } public static File createTempFile ( String prefix , String suffix , File directory ) throws IOException { throw new RuntimeException ( <str> ) ; } public static File createTempFile ( String prefix , String suffix ) throws IOException { throw new RuntimeException ( <str> ) ; } public int compareTo ( File pathname ) { throw new RuntimeException ( <str> ) ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof File ) ) { return false ; } return getPath ( ) . equals ( ( ( File ) obj ) . getPath ( ) ) ; } public int hashCode ( ) { return parent ! = null ? parent . hashCode ( ) + name . hashCode ( ) : name . hashCode ( ) ; } public String toString ( ) { return name ; } } 
