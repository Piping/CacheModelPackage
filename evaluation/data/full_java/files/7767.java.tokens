package org . elasticsearch . action . termvectors ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . io . BytesStream ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; public class GetTermVectorsCheckDocFreqIT extends ESIntegTestCase { @Override protected int numberOfShards ( ) { return <int> ; } @Override protected int numberOfReplicas ( ) { return <int> ; } @Override public Settings indexSettings ( ) { return Settings . builder ( ) . put ( super . indexSettings ( ) ) . put ( <str> , <str> ) . putArray ( <str> , <str> , <str> ) . build ( ) ; } public void testSimpleTermVectors ( ) throws IOException { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , mapping ) ) ; ensureGreen ( ) ; int numDocs = <int> ; for ( int i = <int> ; i < numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; refresh ( ) ; } String [ ] values = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; int [ ] freq = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; int [ ] [ ] pos = { { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> , <int> } } ; int [ ] [ ] startOffset = { { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> , <int> } } ; int [ ] [ ] endOffset = { { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> } , { <int> , <int> } } ; for ( int i = <int> ; i < numDocs ; i + + ) { checkAllInfo ( numDocs , values , freq , pos , startOffset , endOffset , i ) ; checkWithoutTermStatistics ( numDocs , values , freq , pos , startOffset , endOffset , i ) ; checkWithoutFieldStatistics ( numDocs , values , freq , pos , startOffset , endOffset , i ) ; } } private void checkWithoutFieldStatistics ( int numDocs , String [ ] values , int [ ] freq , int [ ] [ ] pos , int [ ] [ ] startOffset , int [ ] [ ] endOffset , int i ) throws IOException { TermVectorsRequestBuilder resp = client ( ) . prepareTermVectors ( <str> , <str> , Integer . toString ( i ) ) . setPayloads ( true ) . setOffsets ( true ) . setPositions ( true ) . setTermStatistics ( true ) . setFieldStatistics ( false ) . setSelectedFields ( ) ; TermVectorsResponse response = resp . execute ( ) . actionGet ( ) ; assertThat ( <str> + i + <str> , response . isExists ( ) , equalTo ( true ) ) ; Fields fields = response . getFields ( ) ; assertThat ( fields . size ( ) , equalTo ( <int> ) ) ; Terms terms = fields . terms ( <str> ) ; assertThat ( terms . size ( ) , equalTo ( <int> ) ) ; assertThat ( terms . getSumTotalTermFreq ( ) , Matchers . equalTo ( ( long ) - <int> ) ) ; assertThat ( terms . getDocCount ( ) , Matchers . equalTo ( - <int> ) ) ; assertThat ( terms . getSumDocFreq ( ) , equalTo ( ( long ) - <int> ) ) ; TermsEnum iterator = terms . iterator ( ) ; for ( int j = <int> ; j < values . length ; j + + ) { String string = values [ j ] ; BytesRef next = iterator . next ( ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; assertThat ( <str> + string , string , equalTo ( next . utf8ToString ( ) ) ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; if ( string . equals ( <str> ) ) { assertThat ( <str> + string , numDocs * <int> , equalTo ( ( int ) iterator . totalTermFreq ( ) ) ) ; } else { assertThat ( <str> + string , numDocs , equalTo ( ( int ) iterator . totalTermFreq ( ) ) ) ; } PostingsEnum docsAndPositions = iterator . postings ( null , PostingsEnum . ALL ) ; assertThat ( docsAndPositions . nextDoc ( ) , equalTo ( <int> ) ) ; assertThat ( freq [ j ] , equalTo ( docsAndPositions . freq ( ) ) ) ; assertThat ( iterator . docFreq ( ) , equalTo ( numDocs ) ) ; int [ ] termPos = pos [ j ] ; int [ ] termStartOffset = startOffset [ j ] ; int [ ] termEndOffset = endOffset [ j ] ; assertThat ( termPos . length , equalTo ( freq [ j ] ) ) ; assertThat ( termStartOffset . length , equalTo ( freq [ j ] ) ) ; assertThat ( termEndOffset . length , equalTo ( freq [ j ] ) ) ; for ( int k = <int> ; k < freq [ j ] ; k + + ) { int nextPosition = docsAndPositions . nextPosition ( ) ; assertThat ( <str> + string , nextPosition , equalTo ( termPos [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . startOffset ( ) , equalTo ( termStartOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . endOffset ( ) , equalTo ( termEndOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . getPayload ( ) , equalTo ( new BytesRef ( <str> ) ) ) ; } } assertThat ( iterator . next ( ) , Matchers . nullValue ( ) ) ; XContentBuilder xBuilder = XContentFactory . jsonBuilder ( ) ; xBuilder . startObject ( ) ; response . toXContent ( xBuilder , null ) ; xBuilder . endObject ( ) ; String utf8 = xBuilder . bytes ( ) . toUtf8 ( ) . replaceFirst ( <str> , <str> ) ; ; String expectedString = <str> + i + <str> ; assertThat ( utf8 , equalTo ( expectedString ) ) ; } private void checkWithoutTermStatistics ( int numDocs , String [ ] values , int [ ] freq , int [ ] [ ] pos , int [ ] [ ] startOffset , int [ ] [ ] endOffset , int i ) throws IOException { TermVectorsRequestBuilder resp = client ( ) . prepareTermVectors ( <str> , <str> , Integer . toString ( i ) ) . setPayloads ( true ) . setOffsets ( true ) . setPositions ( true ) . setTermStatistics ( false ) . setFieldStatistics ( true ) . setSelectedFields ( ) ; assertThat ( resp . request ( ) . termStatistics ( ) , equalTo ( false ) ) ; TermVectorsResponse response = resp . execute ( ) . actionGet ( ) ; assertThat ( <str> + i + <str> , response . isExists ( ) , equalTo ( true ) ) ; Fields fields = response . getFields ( ) ; assertThat ( fields . size ( ) , equalTo ( <int> ) ) ; Terms terms = fields . terms ( <str> ) ; assertThat ( terms . size ( ) , equalTo ( <int> ) ) ; assertThat ( terms . getSumTotalTermFreq ( ) , Matchers . equalTo ( ( long ) ( <int> * numDocs ) ) ) ; assertThat ( terms . getDocCount ( ) , Matchers . equalTo ( numDocs ) ) ; assertThat ( terms . getSumDocFreq ( ) , equalTo ( ( long ) numDocs * values . length ) ) ; TermsEnum iterator = terms . iterator ( ) ; for ( int j = <int> ; j < values . length ; j + + ) { String string = values [ j ] ; BytesRef next = iterator . next ( ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; assertThat ( <str> + string , string , equalTo ( next . utf8ToString ( ) ) ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; assertThat ( <str> + string , - <int> , equalTo ( ( int ) iterator . totalTermFreq ( ) ) ) ; PostingsEnum docsAndPositions = iterator . postings ( null , PostingsEnum . ALL ) ; assertThat ( docsAndPositions . nextDoc ( ) , equalTo ( <int> ) ) ; assertThat ( freq [ j ] , equalTo ( docsAndPositions . freq ( ) ) ) ; assertThat ( iterator . docFreq ( ) , equalTo ( - <int> ) ) ; int [ ] termPos = pos [ j ] ; int [ ] termStartOffset = startOffset [ j ] ; int [ ] termEndOffset = endOffset [ j ] ; assertThat ( termPos . length , equalTo ( freq [ j ] ) ) ; assertThat ( termStartOffset . length , equalTo ( freq [ j ] ) ) ; assertThat ( termEndOffset . length , equalTo ( freq [ j ] ) ) ; for ( int k = <int> ; k < freq [ j ] ; k + + ) { int nextPosition = docsAndPositions . nextPosition ( ) ; assertThat ( <str> + string , nextPosition , equalTo ( termPos [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . startOffset ( ) , equalTo ( termStartOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . endOffset ( ) , equalTo ( termEndOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . getPayload ( ) , equalTo ( new BytesRef ( <str> ) ) ) ; } } assertThat ( iterator . next ( ) , Matchers . nullValue ( ) ) ; XContentBuilder xBuilder = XContentFactory . jsonBuilder ( ) ; xBuilder . startObject ( ) ; response . toXContent ( xBuilder , null ) ; xBuilder . endObject ( ) ; String utf8 = xBuilder . bytes ( ) . toUtf8 ( ) . replaceFirst ( <str> , <str> ) ; ; String expectedString = <str> + i + <str> ; assertThat ( utf8 , equalTo ( expectedString ) ) ; } private void checkAllInfo ( int numDocs , String [ ] values , int [ ] freq , int [ ] [ ] pos , int [ ] [ ] startOffset , int [ ] [ ] endOffset , int i ) throws IOException { TermVectorsRequestBuilder resp = client ( ) . prepareTermVectors ( <str> , <str> , Integer . toString ( i ) ) . setPayloads ( true ) . setOffsets ( true ) . setPositions ( true ) . setFieldStatistics ( true ) . setTermStatistics ( true ) . setSelectedFields ( ) ; assertThat ( resp . request ( ) . fieldStatistics ( ) , equalTo ( true ) ) ; TermVectorsResponse response = resp . execute ( ) . actionGet ( ) ; assertThat ( <str> + i + <str> , response . isExists ( ) , equalTo ( true ) ) ; Fields fields = response . getFields ( ) ; assertThat ( fields . size ( ) , equalTo ( <int> ) ) ; Terms terms = fields . terms ( <str> ) ; assertThat ( terms . size ( ) , equalTo ( <int> ) ) ; assertThat ( terms . getSumTotalTermFreq ( ) , Matchers . equalTo ( ( long ) ( <int> * numDocs ) ) ) ; assertThat ( terms . getDocCount ( ) , Matchers . equalTo ( numDocs ) ) ; assertThat ( terms . getSumDocFreq ( ) , equalTo ( ( long ) numDocs * values . length ) ) ; TermsEnum iterator = terms . iterator ( ) ; for ( int j = <int> ; j < values . length ; j + + ) { String string = values [ j ] ; BytesRef next = iterator . next ( ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; assertThat ( <str> + string , string , equalTo ( next . utf8ToString ( ) ) ) ; assertThat ( next , Matchers . notNullValue ( ) ) ; if ( string . equals ( <str> ) ) { assertThat ( <str> + string , numDocs * <int> , equalTo ( ( int ) iterator . totalTermFreq ( ) ) ) ; } else { assertThat ( <str> + string , numDocs , equalTo ( ( int ) iterator . totalTermFreq ( ) ) ) ; } PostingsEnum docsAndPositions = iterator . postings ( null , PostingsEnum . ALL ) ; assertThat ( docsAndPositions . nextDoc ( ) , equalTo ( <int> ) ) ; assertThat ( freq [ j ] , equalTo ( docsAndPositions . freq ( ) ) ) ; assertThat ( iterator . docFreq ( ) , equalTo ( numDocs ) ) ; int [ ] termPos = pos [ j ] ; int [ ] termStartOffset = startOffset [ j ] ; int [ ] termEndOffset = endOffset [ j ] ; assertThat ( termPos . length , equalTo ( freq [ j ] ) ) ; assertThat ( termStartOffset . length , equalTo ( freq [ j ] ) ) ; assertThat ( termEndOffset . length , equalTo ( freq [ j ] ) ) ; for ( int k = <int> ; k < freq [ j ] ; k + + ) { int nextPosition = docsAndPositions . nextPosition ( ) ; assertThat ( <str> + string , nextPosition , equalTo ( termPos [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . startOffset ( ) , equalTo ( termStartOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . endOffset ( ) , equalTo ( termEndOffset [ k ] ) ) ; assertThat ( <str> + string , docsAndPositions . getPayload ( ) , equalTo ( new BytesRef ( <str> ) ) ) ; } } assertThat ( iterator . next ( ) , Matchers . nullValue ( ) ) ; XContentBuilder xBuilder = XContentFactory . jsonBuilder ( ) ; xBuilder . startObject ( ) ; response . toXContent ( xBuilder , ToXContent . EMPTY_PARAMS ) ; xBuilder . endObject ( ) ; String utf8 = xBuilder . bytes ( ) . toUtf8 ( ) . replaceFirst ( <str> , <str> ) ; ; String expectedString = <str> + i + <str> ; assertThat ( utf8 , equalTo ( expectedString ) ) ; } } 
