package com . badlogic . gdx . jnigen ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class AntPathMatcher { public boolean isPattern ( String str ) { return ( str . indexOf ( <str> ) ! = - <int> | | str . indexOf ( <str> ) ! = - <int> ) ; } public static String [ ] tokenizeToStringArray ( String str , String delimiters , boolean trimTokens , boolean ignoreEmptyTokens ) { if ( str = = null ) { return null ; } StringTokenizer st = new StringTokenizer ( str , delimiters ) ; List < String > tokens = new ArrayList < String > ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( trimTokens ) { token = token . trim ( ) ; } if ( ! ignoreEmptyTokens | | token . length ( ) > <int> ) { tokens . add ( token ) ; } } return tokens . toArray ( new String [ tokens . size ( ) ] ) ; } public boolean match ( String file , String [ ] patterns ) { if ( patterns = = null | | patterns . length = = <int> ) return true ; for ( String pattern : patterns ) { if ( match ( pattern , file ) ) { return true ; } } return false ; } public boolean match ( String pattern , String str ) { if ( str . startsWith ( <str> ) ! = pattern . startsWith ( <str> ) ) { return false ; } String [ ] patDirs = tokenizeToStringArray ( pattern , <str> , true , true ) ; String [ ] strDirs = tokenizeToStringArray ( str , <str> , true , true ) ; int patIdxStart = <int> ; int patIdxEnd = patDirs . length - <int> ; int strIdxStart = <int> ; int strIdxEnd = strDirs . length - <int> ; while ( patIdxStart < = patIdxEnd & & strIdxStart < = strIdxEnd ) { String patDir = ( String ) patDirs [ patIdxStart ] ; if ( patDir . equals ( <str> ) ) { break ; } if ( ! matchStrings ( patDir , ( String ) strDirs [ strIdxStart ] ) ) { return false ; } patIdxStart + + ; strIdxStart + + ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( ! patDirs [ i ] . equals ( <str> ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart < = patIdxEnd & & strIdxStart < = strIdxEnd ) { String patDir = ( String ) patDirs [ patIdxEnd ] ; if ( patDir . equals ( <str> ) ) { break ; } if ( ! matchStrings ( patDir , ( String ) strDirs [ strIdxEnd ] ) ) { return false ; } patIdxEnd - - ; strIdxEnd - - ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( ! patDirs [ i ] . equals ( <str> ) ) { return false ; } } return true ; } while ( patIdxStart ! = patIdxEnd & & strIdxStart < = strIdxEnd ) { int patIdxTmp = - <int> ; for ( int i = patIdxStart + <int> ; i < = patIdxEnd ; i + + ) { if ( patDirs [ i ] . equals ( <str> ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp = = patIdxStart + <int> ) { patIdxStart + + ; continue ; } int patLength = ( patIdxTmp - patIdxStart - <int> ) ; int strLength = ( strIdxEnd - strIdxStart + <int> ) ; int foundIdx = - <int> ; strLoop : for ( int i = <int> ; i < = strLength - patLength ; i + + ) { for ( int j = <int> ; j < patLength ; j + + ) { String subPat = ( String ) patDirs [ patIdxStart + j + <int> ] ; String subStr = ( String ) strDirs [ strIdxStart + i + j ] ; if ( ! matchStrings ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx = = - <int> ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( ! patDirs [ i ] . equals ( <str> ) ) { return false ; } } return true ; } private boolean matchStrings ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = <int> ; int patIdxEnd = patArr . length - <int> ; int strIdxStart = <int> ; int strIdxEnd = strArr . length - <int> ; char ch ; boolean containsStar = false ; for ( int i = <int> ; i < patArr . length ; i + + ) { if ( patArr [ i ] = = <str> ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd ! = strIdxEnd ) { return false ; } for ( int i = <int> ; i < = patIdxEnd ; i + + ) { ch = patArr [ i ] ; if ( ch ! = <str> ) { if ( ch ! = strArr [ i ] ) { return false ; } } } return true ; } if ( patIdxEnd = = <int> ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) ! = <str> & & strIdxStart < = strIdxEnd ) { if ( ch ! = <str> ) { if ( ch ! = strArr [ strIdxStart ] ) { return false ; } } patIdxStart + + ; strIdxStart + + ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( patArr [ i ] ! = <str> ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) ! = <str> & & strIdxStart < = strIdxEnd ) { if ( ch ! = <str> ) { if ( ch ! = strArr [ strIdxEnd ] ) { return false ; } } patIdxEnd - - ; strIdxEnd - - ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( patArr [ i ] ! = <str> ) { return false ; } } return true ; } while ( patIdxStart ! = patIdxEnd & & strIdxStart < = strIdxEnd ) { int patIdxTmp = - <int> ; for ( int i = patIdxStart + <int> ; i < = patIdxEnd ; i + + ) { if ( patArr [ i ] = = <str> ) { patIdxTmp = i ; break ; } } if ( patIdxTmp = = patIdxStart + <int> ) { patIdxStart + + ; continue ; } int patLength = ( patIdxTmp - patIdxStart - <int> ) ; int strLength = ( strIdxEnd - strIdxStart + <int> ) ; int foundIdx = - <int> ; strLoop : for ( int i = <int> ; i < = strLength - patLength ; i + + ) { for ( int j = <int> ; j < patLength ; j + + ) { ch = patArr [ patIdxStart + j + <int> ] ; if ( ch ! = <str> ) { if ( ch ! = strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx = = - <int> ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i < = patIdxEnd ; i + + ) { if ( patArr [ i ] ! = <str> ) { return false ; } } return true ; } } 
