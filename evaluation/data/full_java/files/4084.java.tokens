package org . eclipse . debug . internal . ui . actions . expressions ; import org . eclipse . debug . core . model . IWatchExpression ; import org . eclipse . debug . internal . ui . viewers . model . provisional . TreeModelViewer ; import org . eclipse . debug . internal . ui . views . expression . ExpressionView ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; public class EditWatchExpressinInPlaceAction extends Action implements ISelectionChangedListener { private ExpressionView fView ; private TreeModelViewer fViewer ; private EditWatchExpressionAction fEditActionDelegate = new EditWatchExpressionAction ( ) ; public EditWatchExpressinInPlaceAction ( ExpressionView view ) { fView = view ; fViewer = ( TreeModelViewer ) view . getViewer ( ) ; fEditActionDelegate . init ( view ) ; ISelectionProvider selectionProvider = fView . getSite ( ) . getSelectionProvider ( ) ; selectionProvider . addSelectionChangedListener ( this ) ; fEditActionDelegate . selectionChanged ( this , selectionProvider . getSelection ( ) ) ; } @Override public void selectionChanged ( SelectionChangedEvent event ) { IStructuredSelection selection = fEditActionDelegate . getCurrentSelection ( ) ; setEnabled ( selection ! = null & & selection . size ( ) = = <int> ) ; } public void dispose ( ) { fView . getSite ( ) . getSelectionProvider ( ) . removeSelectionChangedListener ( this ) ; } @Override public void run ( ) { IStructuredSelection selelection = fEditActionDelegate . getCurrentSelection ( ) ; if ( selelection . size ( ) ! = <int> ) { return ; } int expressionColumn = getExpressionColumnIndex ( ) ; IWatchExpression [ ] expressions = fEditActionDelegate . getSelectedExpressions ( ) ; if ( expressionColumn ! = - <int> & & ! isWatchExpressionWithNewLine ( expressions ) ) { fViewer . editElement ( selelection . getFirstElement ( ) , expressionColumn ) ; } else if ( expressions . length = = <int> ) { fEditActionDelegate . run ( this ) ; } } private boolean isWatchExpressionWithNewLine ( IWatchExpression [ ] expressions ) { return expressions . length = = <int> & & expressions [ <int> ] . getExpressionText ( ) . indexOf ( <str> ) ! = - <int> ; } private int getExpressionColumnIndex ( ) { Object [ ] columnProperties = fViewer . getColumnProperties ( ) ; for ( int i = <int> ; columnProperties ! = null & & i < columnProperties . length ; i + + ) { if ( IDebugUIConstants . COLUMN_ID_VARIABLE_NAME . equals ( columnProperties [ i ] ) ) { return i ; } } return - <int> ; } } 
