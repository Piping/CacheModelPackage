package org . elasticsearch . action . search ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . search . type . * ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . IndexClosedException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . action . search . SearchType . * ; public class TransportSearchAction extends HandledTransportAction < SearchRequest , SearchResponse > { private final ClusterService clusterService ; private final TransportSearchDfsQueryThenFetchAction dfsQueryThenFetchAction ; private final TransportSearchQueryThenFetchAction queryThenFetchAction ; private final TransportSearchDfsQueryAndFetchAction dfsQueryAndFetchAction ; private final TransportSearchQueryAndFetchAction queryAndFetchAction ; private final boolean optimizeSingleShard ; @Inject public TransportSearchAction ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterService clusterService , TransportSearchDfsQueryThenFetchAction dfsQueryThenFetchAction , TransportSearchQueryThenFetchAction queryThenFetchAction , TransportSearchDfsQueryAndFetchAction dfsQueryAndFetchAction , TransportSearchQueryAndFetchAction queryAndFetchAction , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , SearchAction . NAME , threadPool , transportService , actionFilters , indexNameExpressionResolver , SearchRequest : : new ) ; this . clusterService = clusterService ; this . dfsQueryThenFetchAction = dfsQueryThenFetchAction ; this . queryThenFetchAction = queryThenFetchAction ; this . dfsQueryAndFetchAction = dfsQueryAndFetchAction ; this . queryAndFetchAction = queryAndFetchAction ; this . optimizeSingleShard = this . settings . getAsBoolean ( <str> , true ) ; } @Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { if ( optimizeSingleShard ) { try { ClusterState clusterState = clusterService . state ( ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , searchRequest ) ; Map < String , Set < String > > routingMap = indexNameExpressionResolver . resolveSearchRouting ( clusterState , searchRequest . routing ( ) , searchRequest . indices ( ) ) ; int shardCount = clusterService . operationRouting ( ) . searchShardsCount ( clusterState , concreteIndices , routingMap ) ; if ( shardCount = = <int> ) { searchRequest . searchType ( QUERY_AND_FETCH ) ; } } catch ( IndexNotFoundException | IndexClosedException e ) { } catch ( Exception e ) { logger . debug ( <str> , e ) ; } } if ( searchRequest . searchType ( ) = = DFS_QUERY_THEN_FETCH ) { dfsQueryThenFetchAction . execute ( searchRequest , listener ) ; } else if ( searchRequest . searchType ( ) = = SearchType . QUERY_THEN_FETCH ) { queryThenFetchAction . execute ( searchRequest , listener ) ; } else if ( searchRequest . searchType ( ) = = SearchType . DFS_QUERY_AND_FETCH ) { dfsQueryAndFetchAction . execute ( searchRequest , listener ) ; } else if ( searchRequest . searchType ( ) = = SearchType . QUERY_AND_FETCH ) { queryAndFetchAction . execute ( searchRequest , listener ) ; } else { throw new IllegalStateException ( <str> + searchRequest . searchType ( ) + <str> ) ; } } } 
