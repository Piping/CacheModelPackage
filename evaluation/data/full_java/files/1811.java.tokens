package clojure . asm . commons ; import clojure . asm . Label ; import clojure . asm . MethodVisitor ; import clojure . asm . Opcodes ; import clojure . asm . Type ; public class LocalVariablesSorter extends MethodVisitor { private static final Type OBJECT_TYPE = Type . getObjectType ( <str> ) ; private int [ ] mapping = new int [ <int> ] ; private Object [ ] newLocals = new Object [ <int> ] ; protected final int firstLocal ; protected int nextLocal ; private boolean changed ; public LocalVariablesSorter ( final int access , final String desc , final MethodVisitor mv ) { this ( Opcodes . ASM4 , access , desc , mv ) ; } protected LocalVariablesSorter ( final int api , final int access , final String desc , final MethodVisitor mv ) { super ( api , mv ) ; Type [ ] args = Type . getArgumentTypes ( desc ) ; nextLocal = ( Opcodes . ACC_STATIC & access ) = = <int> ? <int> : <int> ; for ( int i = <int> ; i < args . length ; i + + ) { nextLocal + = args [ i ] . getSize ( ) ; } firstLocal = nextLocal ; } @Override public void visitVarInsn ( final int opcode , final int var ) { Type type ; switch ( opcode ) { case Opcodes . LLOAD : case Opcodes . LSTORE : type = Type . LONG_TYPE ; break ; case Opcodes . DLOAD : case Opcodes . DSTORE : type = Type . DOUBLE_TYPE ; break ; case Opcodes . FLOAD : case Opcodes . FSTORE : type = Type . FLOAT_TYPE ; break ; case Opcodes . ILOAD : case Opcodes . ISTORE : type = Type . INT_TYPE ; break ; default: type = OBJECT_TYPE ; break ; } mv . visitVarInsn ( opcode , remap ( var , type ) ) ; } @Override public void visitIincInsn ( final int var , final int increment ) { mv . visitIincInsn ( remap ( var , Type . INT_TYPE ) , increment ) ; } @Override public void visitMaxs ( final int maxStack , final int maxLocals ) { mv . visitMaxs ( maxStack , nextLocal ) ; } @Override public void visitLocalVariable ( final String name , final String desc , final String signature , final Label start , final Label end , final int index ) { int newIndex = remap ( index , Type . getType ( desc ) ) ; mv . visitLocalVariable ( name , desc , signature , start , end , newIndex ) ; } @Override public void visitFrame ( final int type , final int nLocal , final Object [ ] local , final int nStack , final Object [ ] stack ) { if ( type ! = Opcodes . F_NEW ) { throw new IllegalStateException ( <str> ) ; } if ( ! changed ) { mv . visitFrame ( type , nLocal , local , nStack , stack ) ; return ; } Object [ ] oldLocals = new Object [ newLocals . length ] ; System . arraycopy ( newLocals , <int> , oldLocals , <int> , oldLocals . length ) ; updateNewLocals ( newLocals ) ; int index = <int> ; int number = <int> ; for ( ; number < nLocal ; + + number ) { Object t = local [ number ] ; int size = t = = Opcodes . LONG | | t = = Opcodes . DOUBLE ? <int> : <int> ; if ( t ! = Opcodes . TOP ) { Type typ = OBJECT_TYPE ; if ( t = = Opcodes . INTEGER ) { typ = Type . INT_TYPE ; } else if ( t = = Opcodes . FLOAT ) { typ = Type . FLOAT_TYPE ; } else if ( t = = Opcodes . LONG ) { typ = Type . LONG_TYPE ; } else if ( t = = Opcodes . DOUBLE ) { typ = Type . DOUBLE_TYPE ; } else if ( t instanceof String ) { typ = Type . getObjectType ( ( String ) t ) ; } setFrameLocal ( remap ( index , typ ) , t ) ; } index + = size ; } index = <int> ; number = <int> ; for ( int i = <int> ; index < newLocals . length ; + + i ) { Object t = newLocals [ index + + ] ; if ( t ! = null & & t ! = Opcodes . TOP ) { newLocals [ i ] = t ; number = i + <int> ; if ( t = = Opcodes . LONG | | t = = Opcodes . DOUBLE ) { index + = <int> ; } } else { newLocals [ i ] = Opcodes . TOP ; } } mv . visitFrame ( type , number , newLocals , nStack , stack ) ; newLocals = oldLocals ; } public int newLocal ( final Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; default : t = type . getInternalName ( ) ; break ; } int local = newLocalMapping ( type ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; } protected void updateNewLocals ( Object [ ] newLocals ) { } protected void setLocalType ( final int local , final Type type ) { } private void setFrameLocal ( final int local , final Object type ) { int l = newLocals . length ; if ( local > = l ) { Object [ ] a = new Object [ Math . max ( <int> * l , local + <int> ) ] ; System . arraycopy ( newLocals , <int> , a , <int> , l ) ; newLocals = a ; } newLocals [ local ] = type ; } private int remap ( final int var , final Type type ) { if ( var + type . getSize ( ) < = firstLocal ) { return var ; } int key = <int> * var + type . getSize ( ) - <int> ; int size = mapping . length ; if ( key > = size ) { int [ ] newMapping = new int [ Math . max ( <int> * size , key + <int> ) ] ; System . arraycopy ( mapping , <int> , newMapping , <int> , size ) ; mapping = newMapping ; } int value = mapping [ key ] ; if ( value = = <int> ) { value = newLocalMapping ( type ) ; setLocalType ( value , type ) ; mapping [ key ] = value + <int> ; } else { value - - ; } if ( value ! = var ) { changed = true ; } return value ; } protected int newLocalMapping ( final Type type ) { int local = nextLocal ; nextLocal + = type . getSize ( ) ; return local ; } } 
