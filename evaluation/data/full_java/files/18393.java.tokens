package com . badlogic . gdx . utils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . utils . ObjectMap . Entry ; public class XmlReader { private final Array < Element > elements = new Array ( <int> ) ; private Element root , current ; private final StringBuilder textBuffer = new StringBuilder ( <int> ) ; public Element parse ( String xml ) { char [ ] data = xml . toCharArray ( ) ; return parse ( data , <int> , data . length ) ; } public Element parse ( Reader reader ) throws IOException { try { char [ ] data = new char [ <int> ] ; int offset = <int> ; while ( true ) { int length = reader . read ( data , offset , data . length - offset ) ; if ( length = = - <int> ) break ; if ( length = = <int> ) { char [ ] newData = new char [ data . length * <int> ] ; System . arraycopy ( data , <int> , newData , <int> , data . length ) ; data = newData ; } else offset + = length ; } return parse ( data , <int> , offset ) ; } catch ( IOException ex ) { throw new SerializationException ( ex ) ; } finally { StreamUtils . closeQuietly ( reader ) ; } } public Element parse ( InputStream input ) throws IOException { try { return parse ( new InputStreamReader ( input , <str> ) ) ; } catch ( IOException ex ) { throw new SerializationException ( ex ) ; } finally { StreamUtils . closeQuietly ( input ) ; } } public Element parse ( FileHandle file ) throws IOException { try { return parse ( file . reader ( <str> ) ) ; } catch ( Exception ex ) { throw new SerializationException ( <str> + file , ex ) ; } } public Element parse ( char [ ] data , int offset , int length ) { int cs , p = offset , pe = length ; int s = <int> ; String attributeName = null ; boolean hasBody = false ; { cs = xml_start ; } { int _klen ; int _trans = <int> ; int _acts ; int _nacts ; int _keys ; int _goto_targ = <int> ; _goto: while ( true ) { switch ( _goto_targ ) { case <int> : if ( p = = pe ) { _goto_targ = <int> ; continue _goto ; } if ( cs = = <int> ) { _goto_targ = <int> ; continue _goto ; } case <int> : _match : do { _keys = _xml_key_offsets [ cs ] ; _trans = _xml_index_offsets [ cs ] ; _klen = _xml_single_lengths [ cs ] ; if ( _klen > <int> ) { int _lower = _keys ; int _mid ; int _upper = _keys + _klen - <int> ; while ( true ) { if ( _upper < _lower ) break ; _mid = _lower + ( ( _upper - _lower ) > > <int> ) ; if ( data [ p ] < _xml_trans_keys [ _mid ] ) _upper = _mid - <int> ; else if ( data [ p ] > _xml_trans_keys [ _mid ] ) _lower = _mid + <int> ; else { _trans + = ( _mid - _keys ) ; break _match ; } } _keys + = _klen ; _trans + = _klen ; } _klen = _xml_range_lengths [ cs ] ; if ( _klen > <int> ) { int _lower = _keys ; int _mid ; int _upper = _keys + ( _klen < < <int> ) - <int> ; while ( true ) { if ( _upper < _lower ) break ; _mid = _lower + ( ( ( _upper - _lower ) > > <int> ) & ~ <int> ) ; if ( data [ p ] < _xml_trans_keys [ _mid ] ) _upper = _mid - <int> ; else if ( data [ p ] > _xml_trans_keys [ _mid + <int> ] ) _lower = _mid + <int> ; else { _trans + = ( ( _mid - _keys ) > > <int> ) ; break _match ; } } _trans + = _klen ; } } while ( false ) ; _trans = _xml_indicies [ _trans ] ; cs = _xml_trans_targs [ _trans ] ; if ( _xml_trans_actions [ _trans ] ! = <int> ) { _acts = _xml_trans_actions [ _trans ] ; _nacts = ( int ) _xml_actions [ _acts + + ] ; while ( _nacts - - > <int> ) { switch ( _xml_actions [ _acts + + ] ) { case <int> : { s = p ; } break ; case <int> : { char c = data [ s ] ; if ( c = = <str> | | c = = <str> ) { if ( data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> ) { s + = <int> ; p = s + <int> ; while ( data [ p - <int> ] ! = <str> | | data [ p - <int> ] ! = <str> | | data [ p ] ! = <str> ) p + + ; text ( new String ( data , s , p - s - <int> ) ) ; } else if ( c = = <str> & & data [ s + <int> ] = = <str> & & data [ s + <int> ] = = <str> ) { p = s + <int> ; while ( data [ p ] ! = <str> | | data [ p + <int> ] ! = <str> | | data [ p + <int> ] ! = <str> ) p + + ; p + = <int> ; } else while ( data [ p ] ! = <str> ) p + + ; { cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } hasBody = true ; open ( new String ( data , s , p - s ) ) ; } break ; case <int> : { hasBody = false ; close ( ) ; { cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } break ; case <int> : { close ( ) ; { cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } break ; case <int> : { if ( hasBody ) { cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } break ; case <int> : { attributeName = new String ( data , s , p - s ) ; } break ; case <int> : { attribute ( attributeName , new String ( data , s , p - s ) ) ; } break ; case <int> : { int end = p ; while ( end ! = s ) { switch ( data [ end - <int> ] ) { case <str> : case <str> : case <str> : case <str> : end - - ; continue ; } break ; } int current = s ; boolean entityFound = false ; while ( current ! = end ) { if ( data [ current + + ] ! = <str> ) continue ; int entityStart = current ; while ( current ! = end ) { if ( data [ current + + ] ! = <str> ) continue ; textBuffer . append ( data , s , entityStart - s - <int> ) ; String name = new String ( data , entityStart , current - entityStart - <int> ) ; String value = entity ( name ) ; textBuffer . append ( value ! = null ? value : name ) ; s = current ; entityFound = true ; break ; } } if ( entityFound ) { if ( s < end ) textBuffer . append ( data , s , end - s ) ; text ( textBuffer . toString ( ) ) ; textBuffer . setLength ( <int> ) ; } else text ( new String ( data , s , end - s ) ) ; } break ; } } } case <int> : if ( cs = = <int> ) { _goto_targ = <int> ; continue _goto ; } if ( + + p ! = pe ) { _goto_targ = <int> ; continue _goto ; } case <int> : case <int> : } break ; } } if ( p < pe ) { int lineNumber = <int> ; for ( int i = <int> ; i < p ; i + + ) if ( data [ i ] = = <str> ) lineNumber + + ; throw new SerializationException ( <str> + lineNumber + <str> + new String ( data , p , Math . min ( <int> , pe - p ) ) ) ; } else if ( elements . size ! = <int> ) { Element element = elements . peek ( ) ; elements . clear ( ) ; throw new SerializationException ( <str> + element . getName ( ) ) ; } Element root = this . root ; this . root = null ; return root ; } private static byte [ ] init__xml_actions_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_actions [ ] = init__xml_actions_0 ( ) ; private static byte [ ] init__xml_key_offsets_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_key_offsets [ ] = init__xml_key_offsets_0 ( ) ; private static char [ ] init__xml_trans_keys_0 ( ) { return new char [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final char _xml_trans_keys [ ] = init__xml_trans_keys_0 ( ) ; private static byte [ ] init__xml_single_lengths_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_single_lengths [ ] = init__xml_single_lengths_0 ( ) ; private static byte [ ] init__xml_range_lengths_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_range_lengths [ ] = init__xml_range_lengths_0 ( ) ; private static short [ ] init__xml_index_offsets_0 ( ) { return new short [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final short _xml_index_offsets [ ] = init__xml_index_offsets_0 ( ) ; private static byte [ ] init__xml_indicies_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_indicies [ ] = init__xml_indicies_0 ( ) ; private static byte [ ] init__xml_trans_targs_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_trans_targs [ ] = init__xml_trans_targs_0 ( ) ; private static byte [ ] init__xml_trans_actions_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _xml_trans_actions [ ] = init__xml_trans_actions_0 ( ) ; static final int xml_start = <int> ; static final int xml_first_final = <int> ; static final int xml_error = <int> ; static final int xml_en_elementBody = <int> ; static final int xml_en_main = <int> ; protected void open ( String name ) { Element child = new Element ( name , current ) ; Element parent = current ; if ( parent ! = null ) parent . addChild ( child ) ; elements . add ( child ) ; current = child ; } protected void attribute ( String name , String value ) { current . setAttribute ( name , value ) ; } protected String entity ( String name ) { if ( name . equals ( <str> ) ) return <str> ; if ( name . equals ( <str> ) ) return <str> ; if ( name . equals ( <str> ) ) return <str> ; if ( name . equals ( <str> ) ) return <str> ; if ( name . equals ( <str> ) ) return <str> ; if ( name . startsWith ( <str> ) ) return Character . toString ( ( char ) Integer . parseInt ( name . substring ( <int> ) , <int> ) ) ; return null ; } protected void text ( String text ) { String existing = current . getText ( ) ; current . setText ( existing ! = null ? existing + text : text ) ; } protected void close ( ) { root = elements . pop ( ) ; current = elements . size > <int> ? elements . peek ( ) : null ; } static public class Element { private final String name ; private ObjectMap < String , String > attributes ; private Array < Element > children ; private String text ; private Element parent ; public Element ( String name , Element parent ) { this . name = name ; this . parent = parent ; } public String getName ( ) { return name ; } public ObjectMap < String , String > getAttributes ( ) { return attributes ; } public String getAttribute ( String name ) { if ( attributes = = null ) throw new GdxRuntimeException ( <str> + name + <str> + name ) ; String value = attributes . get ( name ) ; if ( value = = null ) throw new GdxRuntimeException ( <str> + name + <str> + name ) ; return value ; } public String getAttribute ( String name , String defaultValue ) { if ( attributes = = null ) return defaultValue ; String value = attributes . get ( name ) ; if ( value = = null ) return defaultValue ; return value ; } public void setAttribute ( String name , String value ) { if ( attributes = = null ) attributes = new ObjectMap ( <int> ) ; attributes . put ( name , value ) ; } public int getChildCount ( ) { if ( children = = null ) return <int> ; return children . size ; } public Element getChild ( int index ) { if ( children = = null ) throw new GdxRuntimeException ( <str> + name ) ; return children . get ( index ) ; } public void addChild ( Element element ) { if ( children = = null ) children = new Array ( <int> ) ; children . add ( element ) ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public void removeChild ( int index ) { if ( children ! = null ) children . removeIndex ( index ) ; } public void removeChild ( Element child ) { if ( children ! = null ) children . removeValue ( child , true ) ; } public void remove ( ) { parent . removeChild ( this ) ; } public Element getParent ( ) { return parent ; } public String toString ( ) { return toString ( <str> ) ; } public String toString ( String indent ) { StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( indent ) ; buffer . append ( <str> ) ; buffer . append ( name ) ; if ( attributes ! = null ) { for ( Entry < String , String > entry : attributes . entries ( ) ) { buffer . append ( <str> ) ; buffer . append ( entry . key ) ; buffer . append ( <str> ) ; buffer . append ( entry . value ) ; buffer . append ( <str> ) ; } } if ( children = = null & & ( text = = null | | text . length ( ) = = <int> ) ) buffer . append ( <str> ) ; else { buffer . append ( <str> ) ; String childIndent = indent + <str> ; if ( text ! = null & & text . length ( ) > <int> ) { buffer . append ( childIndent ) ; buffer . append ( text ) ; buffer . append ( <str> ) ; } if ( children ! = null ) { for ( Element child : children ) { buffer . append ( child . toString ( childIndent ) ) ; buffer . append ( <str> ) ; } } buffer . append ( indent ) ; buffer . append ( <str> ) ; buffer . append ( name ) ; buffer . append ( <str> ) ; } return buffer . toString ( ) ; } public Element getChildByName ( String name ) { if ( children = = null ) return null ; for ( int i = <int> ; i < children . size ; i + + ) { Element element = children . get ( i ) ; if ( element . name . equals ( name ) ) return element ; } return null ; } public Element getChildByNameRecursive ( String name ) { if ( children = = null ) return null ; for ( int i = <int> ; i < children . size ; i + + ) { Element element = children . get ( i ) ; if ( element . name . equals ( name ) ) return element ; Element found = element . getChildByNameRecursive ( name ) ; if ( found ! = null ) return found ; } return null ; } public Array < Element > getChildrenByName ( String name ) { Array < Element > result = new Array < Element > ( ) ; if ( children = = null ) return result ; for ( int i = <int> ; i < children . size ; i + + ) { Element child = children . get ( i ) ; if ( child . name . equals ( name ) ) result . add ( child ) ; } return result ; } public Array < Element > getChildrenByNameRecursively ( String name ) { Array < Element > result = new Array < Element > ( ) ; getChildrenByNameRecursively ( name , result ) ; return result ; } private void getChildrenByNameRecursively ( String name , Array < Element > result ) { if ( children = = null ) return ; for ( int i = <int> ; i < children . size ; i + + ) { Element child = children . get ( i ) ; if ( child . name . equals ( name ) ) result . add ( child ) ; child . getChildrenByNameRecursively ( name , result ) ; } } public float getFloatAttribute ( String name ) { return Float . parseFloat ( getAttribute ( name ) ) ; } public float getFloatAttribute ( String name , float defaultValue ) { String value = getAttribute ( name , null ) ; if ( value = = null ) return defaultValue ; return Float . parseFloat ( value ) ; } public int getIntAttribute ( String name ) { return Integer . parseInt ( getAttribute ( name ) ) ; } public int getIntAttribute ( String name , int defaultValue ) { String value = getAttribute ( name , null ) ; if ( value = = null ) return defaultValue ; return Integer . parseInt ( value ) ; } public boolean getBooleanAttribute ( String name ) { return Boolean . parseBoolean ( getAttribute ( name ) ) ; } public boolean getBooleanAttribute ( String name , boolean defaultValue ) { String value = getAttribute ( name , null ) ; if ( value = = null ) return defaultValue ; return Boolean . parseBoolean ( value ) ; } public String get ( String name ) { String value = get ( name , null ) ; if ( value = = null ) throw new GdxRuntimeException ( <str> + this . name + <str> + name ) ; return value ; } public String get ( String name , String defaultValue ) { if ( attributes ! = null ) { String value = attributes . get ( name ) ; if ( value ! = null ) return value ; } Element child = getChildByName ( name ) ; if ( child = = null ) return defaultValue ; String value = child . getText ( ) ; if ( value = = null ) return defaultValue ; return value ; } public int getInt ( String name ) { String value = get ( name , null ) ; if ( value = = null ) throw new GdxRuntimeException ( <str> + this . name + <str> + name ) ; return Integer . parseInt ( value ) ; } public int getInt ( String name , int defaultValue ) { String value = get ( name , null ) ; if ( value = = null ) return defaultValue ; return Integer . parseInt ( value ) ; } public float getFloat ( String name ) { String value = get ( name , null ) ; if ( value = = null ) throw new GdxRuntimeException ( <str> + this . name + <str> + name ) ; return Float . parseFloat ( value ) ; } public float getFloat ( String name , float defaultValue ) { String value = get ( name , null ) ; if ( value = = null ) return defaultValue ; return Float . parseFloat ( value ) ; } public boolean getBoolean ( String name ) { String value = get ( name , null ) ; if ( value = = null ) throw new GdxRuntimeException ( <str> + this . name + <str> + name ) ; return Boolean . parseBoolean ( value ) ; } public boolean getBoolean ( String name , boolean defaultValue ) { String value = get ( name , null ) ; if ( value = = null ) return defaultValue ; return Boolean . parseBoolean ( value ) ; } } } 
