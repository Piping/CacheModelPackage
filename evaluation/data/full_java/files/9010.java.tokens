package org . elasticsearch . test . rest ; import com . carrotsearch . randomizedtesting . RandomizedTest ; import com . carrotsearch . randomizedtesting . annotations . TestGroup ; import com . carrotsearch . randomizedtesting . annotations . TimeoutSuite ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . LuceneTestCase . SuppressCodecs ; import org . apache . lucene . util . LuceneTestCase . SuppressFsync ; import org . apache . lucene . util . TimeUnits ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . node . Node ; import org . elasticsearch . repositories . uri . URLRepository ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . rest . client . RestException ; import org . elasticsearch . test . rest . parser . RestTestParseException ; import org . elasticsearch . test . rest . parser . RestTestSuiteParser ; import org . elasticsearch . test . rest . section . DoSection ; import org . elasticsearch . test . rest . section . ExecutableSection ; import org . elasticsearch . test . rest . section . RestTestSuite ; import org . elasticsearch . test . rest . section . SkipSection ; import org . elasticsearch . test . rest . section . TestSection ; import org . elasticsearch . test . rest . spec . RestApi ; import org . elasticsearch . test . rest . spec . RestSpec ; import org . elasticsearch . test . rest . support . FileUtils ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . io . IOException ; import java . io . InputStream ; import java . lang . annotation . ElementType ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . nio . file . FileSystem ; import java . nio . file . FileSystems ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardCopyOption ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . Set ; @ESRestTestCase.Rest @SuppressFsync @SuppressCodecs ( <str> ) @ClusterScope ( randomDynamicTemplates = false ) @TimeoutSuite ( millis = <int> * TimeUnits . MINUTE ) public abstract class ESRestTestCase extends ESIntegTestCase { public static final String TESTS_REST = <str> ; @Inherited @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) @TestGroup ( enabled = true , sysProperty = ESRestTestCase . TESTS_REST ) public @interface Rest { } public static final String REST_TESTS_SUITE = <str> ; public static final String REST_TESTS_BLACKLIST = <str> ; public static final String REST_TESTS_VALIDATE_SPEC = <str> ; public static final String REST_TESTS_SPEC = <str> ; public static final String REST_LOAD_PACKAGED_TESTS = <str> ; private static final String DEFAULT_TESTS_PATH = <str> ; private static final String DEFAULT_SPEC_PATH = <str> ; private static final String PATHS_SEPARATOR = <str> ; private final List < BlacklistedPathPatternMatcher > blacklistPathMatchers = new ArrayList < > ( ) ; private static RestTestExecutionContext restTestExecutionContext ; private final RestTestCandidate testCandidate ; public ESRestTestCase ( RestTestCandidate testCandidate ) { this . testCandidate = testCandidate ; String [ ] blacklist = resolvePathsProperty ( REST_TESTS_BLACKLIST , null ) ; for ( String entry : blacklist ) { this . blacklistPathMatchers . add ( new BlacklistedPathPatternMatcher ( entry ) ) ; } } @Override protected void afterIfFailed ( List < Throwable > errors ) { logger . info ( <str> , XContentHelper . toString ( restTestExecutionContext . stash ( ) ) ) ; super . afterIfFailed ( errors ) ; } @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . putArray ( URLRepository . ALLOWED_URLS_SETTING , <str> ) . put ( Node . HTTP_ENABLED , true ) . put ( <str> , <str> ) . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; } public static Iterable < Object [ ] > createParameters ( int id , int count ) throws IOException , RestTestParseException { TestGroup testGroup = Rest . class . getAnnotation ( TestGroup . class ) ; String sysProperty = TestGroup . Utilities . getSysProperty ( Rest . class ) ; boolean enabled ; try { enabled = RandomizedTest . systemPropertyAsBoolean ( sysProperty , testGroup . enabled ( ) ) ; } catch ( IllegalArgumentException e ) { enabled = false ; } if ( ! enabled ) { return new ArrayList < > ( ) ; } List < RestTestCandidate > restTestCandidates = collectTestCandidates ( id , count ) ; List < Object [ ] > objects = new ArrayList < > ( ) ; for ( RestTestCandidate restTestCandidate : restTestCandidates ) { objects . add ( new Object [ ] { restTestCandidate } ) ; } return objects ; } private static List < RestTestCandidate > collectTestCandidates ( int id , int count ) throws RestTestParseException , IOException { List < RestTestCandidate > testCandidates = new ArrayList < > ( ) ; FileSystem fileSystem = getFileSystem ( ) ; try { String [ ] paths = resolvePathsProperty ( REST_TESTS_SUITE , DEFAULT_TESTS_PATH ) ; Map < String , Set < Path > > yamlSuites = FileUtils . findYamlSuites ( fileSystem , DEFAULT_TESTS_PATH , paths ) ; RestTestSuiteParser restTestSuiteParser = new RestTestSuiteParser ( ) ; for ( String api : yamlSuites . keySet ( ) ) { List < Path > yamlFiles = new ArrayList < > ( yamlSuites . get ( api ) ) ; for ( Path yamlFile : yamlFiles ) { String key = api + yamlFile . getFileName ( ) . toString ( ) ; if ( mustExecute ( key , id , count ) ) { RestTestSuite restTestSuite = restTestSuiteParser . parse ( api , yamlFile ) ; for ( TestSection testSection : restTestSuite . getTestSections ( ) ) { testCandidates . add ( new RestTestCandidate ( restTestSuite , testSection ) ) ; } } } } } finally { IOUtils . close ( fileSystem ) ; } Collections . sort ( testCandidates , new Comparator < RestTestCandidate > ( ) { @Override public int compare ( RestTestCandidate o1 , RestTestCandidate o2 ) { return o1 . getTestPath ( ) . compareTo ( o2 . getTestPath ( ) ) ; } } ) ; return testCandidates ; } private static boolean mustExecute ( String test , int id , int count ) { int hash = ( int ) ( Math . abs ( ( long ) test . hashCode ( ) ) % count ) ; return hash = = id ; } private static String [ ] resolvePathsProperty ( String propertyName , String defaultValue ) { String property = System . getProperty ( propertyName ) ; if ( ! Strings . hasLength ( property ) ) { return defaultValue = = null ? Strings . EMPTY_ARRAY : new String [ ] { defaultValue } ; } else { return property . split ( PATHS_SEPARATOR ) ; } } @SuppressForbidden ( reason = <str> ) static FileSystem getFileSystem ( ) throws IOException { URL codeLocation = FileUtils . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) ; boolean loadPackaged = RandomizedTest . systemPropertyAsBoolean ( REST_LOAD_PACKAGED_TESTS , true ) ; if ( codeLocation . getFile ( ) . endsWith ( <str> ) & & loadPackaged ) { try { Path tmp = Files . createTempFile ( null , <str> ) ; try ( InputStream in = codeLocation . openStream ( ) ) { Files . copy ( in , tmp , StandardCopyOption . REPLACE_EXISTING ) ; } return FileSystems . newFileSystem ( new URI ( <str> + tmp . toUri ( ) ) , Collections . < String , Object > emptyMap ( ) ) ; } catch ( URISyntaxException e ) { throw new IOException ( <str> , e ) ; } } else { return null ; } } @BeforeClass public static void initExecutionContext ( ) throws IOException , RestException { String [ ] specPaths = resolvePathsProperty ( REST_TESTS_SPEC , DEFAULT_SPEC_PATH ) ; RestSpec restSpec = null ; FileSystem fileSystem = getFileSystem ( ) ; try { restSpec = RestSpec . parseFrom ( fileSystem , DEFAULT_SPEC_PATH , specPaths ) ; } finally { IOUtils . close ( fileSystem ) ; } validateSpec ( restSpec ) ; restTestExecutionContext = new RestTestExecutionContext ( restSpec ) ; } private static void validateSpec ( RestSpec restSpec ) { boolean validateSpec = RandomizedTest . systemPropertyAsBoolean ( REST_TESTS_VALIDATE_SPEC , true ) ; if ( validateSpec ) { StringBuilder errorMessage = new StringBuilder ( ) ; for ( RestApi restApi : restSpec . getApis ( ) ) { if ( restApi . getMethods ( ) . contains ( <str> ) & & restApi . isBodySupported ( ) ) { if ( ! restApi . getMethods ( ) . contains ( <str> ) ) { errorMessage . append ( <str> ) . append ( restApi . getName ( ) ) . append ( <str> ) ; } } } if ( errorMessage . length ( ) > <int> ) { throw new IllegalArgumentException ( errorMessage . toString ( ) ) ; } } } @AfterClass public static void close ( ) { if ( restTestExecutionContext ! = null ) { restTestExecutionContext . close ( ) ; restTestExecutionContext = null ; } } @Override protected int maximumNumberOfShards ( ) { return <int> ; } @Override protected int maximumNumberOfReplicas ( ) { return <int> ; } protected Settings restClientSettings ( ) { return Settings . EMPTY ; } @Before public void reset ( ) throws IOException , RestException { for ( BlacklistedPathPatternMatcher blacklistedPathMatcher : blacklistPathMatchers ) { String testPath = testCandidate . getSuitePath ( ) + <str> + testCandidate . getTestSection ( ) . getName ( ) ; assumeFalse ( <str> + testCandidate . getTestPath ( ) + <str> , blacklistedPathMatcher . isSuffixMatch ( testPath ) ) ; } restTestExecutionContext . initClient ( cluster ( ) . httpAddresses ( ) , restClientSettings ( ) ) ; restTestExecutionContext . clear ( ) ; assumeFalse ( buildSkipMessage ( testCandidate . getSuitePath ( ) , testCandidate . getSetupSection ( ) . getSkipSection ( ) ) , testCandidate . getSetupSection ( ) . getSkipSection ( ) . skip ( restTestExecutionContext . esVersion ( ) ) ) ; assumeFalse ( buildSkipMessage ( testCandidate . getTestPath ( ) , testCandidate . getTestSection ( ) . getSkipSection ( ) ) , testCandidate . getTestSection ( ) . getSkipSection ( ) . skip ( restTestExecutionContext . esVersion ( ) ) ) ; } private static String buildSkipMessage ( String description , SkipSection skipSection ) { StringBuilder messageBuilder = new StringBuilder ( ) ; if ( skipSection . isVersionCheck ( ) ) { messageBuilder . append ( <str> ) . append ( description ) . append ( <str> ) . append ( skipSection . getReason ( ) ) . append ( <str> ) ; } else { messageBuilder . append ( <str> ) . append ( description ) . append ( <str> ) . append ( skipSection . getFeatures ( ) ) . append ( <str> ) ; } return messageBuilder . toString ( ) ; } public void test ( ) throws IOException { if ( testCandidate . getTestSection ( ) . getExecutableSections ( ) . size ( ) = = <int> ) { throw new IllegalArgumentException ( <str> + testCandidate . getTestPath ( ) + <str> ) ; } if ( ! testCandidate . getSetupSection ( ) . isEmpty ( ) ) { logger . info ( <str> , testCandidate . getTestPath ( ) ) ; for ( DoSection doSection : testCandidate . getSetupSection ( ) . getDoSections ( ) ) { doSection . execute ( restTestExecutionContext ) ; } logger . info ( <str> , testCandidate . getTestPath ( ) ) ; } restTestExecutionContext . clear ( ) ; for ( ExecutableSection executableSection : testCandidate . getTestSection ( ) . getExecutableSections ( ) ) { executableSection . execute ( restTestExecutionContext ) ; } } } 
