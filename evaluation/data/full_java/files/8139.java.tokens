package org . elasticsearch . index . mapper ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . similarity . BM25SimilarityProvider ; import org . elasticsearch . test . ESTestCase ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public abstract class FieldTypeTestCase extends ESTestCase { public static abstract class Modifier { public final String property ; public final boolean strictOnly ; public final boolean symmetric ; public Modifier ( String property , boolean strictOnly , boolean symmetric ) { this . property = property ; this . strictOnly = strictOnly ; this . symmetric = symmetric ; } public abstract void modify ( MappedFieldType ft ) ; public void normalizeOther ( MappedFieldType other ) { } } private final List < Modifier > modifiers = new ArrayList < > ( Arrays . asList ( new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setBoost ( <float> ) ; } } , new Modifier ( <str> , false , false ) { @Override public void modify ( MappedFieldType ft ) { ft . setHasDocValues ( ft . hasDocValues ( ) = = false ) ; } } , new Modifier ( <str> , false , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setIndexAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , false , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setIndexAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } @Override public void normalizeOther ( MappedFieldType other ) { other . setIndexAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSearchAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSearchAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } @Override public void normalizeOther ( MappedFieldType other ) { other . setSearchAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSearchQuoteAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSearchQuoteAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } @Override public void normalizeOther ( MappedFieldType other ) { other . setSearchQuoteAnalyzer ( new NamedAnalyzer ( <str> , new StandardAnalyzer ( ) ) ) ; } } , new Modifier ( <str> , false , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSimilarity ( new BM25SimilarityProvider ( <str> , Settings . EMPTY ) ) ; } } , new Modifier ( <str> , false , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setSimilarity ( new BM25SimilarityProvider ( <str> , Settings . EMPTY ) ) ; } @Override public void normalizeOther ( MappedFieldType other ) { other . setSimilarity ( new BM25SimilarityProvider ( <str> , Settings . EMPTY ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setNormsLoading ( MappedFieldType . Loading . LAZY ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setFieldDataType ( new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ) ) ; } } , new Modifier ( <str> , true , true ) { @Override public void modify ( MappedFieldType ft ) { ft . setNullValue ( dummyNullValue ) ; } } ) ) ; protected void addModifier ( Modifier modifier ) { modifiers . add ( modifier ) ; } private Object dummyNullValue = <str> ; protected void setDummyNullValue ( Object value ) { dummyNullValue = value ; } protected abstract MappedFieldType createDefaultFieldType ( ) ; MappedFieldType createNamedDefaultFieldType ( ) { MappedFieldType fieldType = createDefaultFieldType ( ) ; fieldType . setNames ( new MappedFieldType . Names ( <str> ) ) ; return fieldType ; } protected void assertFieldTypeEquals ( String property , MappedFieldType ft1 , MappedFieldType ft2 ) { if ( ft1 . equals ( ft2 ) = = false ) { fail ( <str> + property + <str> + toString ( ft1 ) + <str> + toString ( ft2 ) + <str> ) ; } } protected void assertFieldTypeNotEquals ( String property , MappedFieldType ft1 , MappedFieldType ft2 ) { if ( ft1 . equals ( ft2 ) ) { fail ( <str> + property + <str> + toString ( ft1 ) + <str> + toString ( ft2 ) + <str> ) ; } } protected void assertCompatible ( String msg , MappedFieldType ft1 , MappedFieldType ft2 , boolean strict ) { List < String > conflicts = new ArrayList < > ( ) ; ft1 . checkCompatibility ( ft2 , conflicts , strict ) ; assertTrue ( <str> + msg + <str> + conflicts , conflicts . isEmpty ( ) ) ; } protected void assertNotCompatible ( String msg , MappedFieldType ft1 , MappedFieldType ft2 , boolean strict , String . . . messages ) { assert messages . length ! = <int> ; List < String > conflicts = new ArrayList < > ( ) ; ft1 . checkCompatibility ( ft2 , conflicts , strict ) ; for ( String message : messages ) { boolean found = false ; for ( String conflict : conflicts ) { if ( conflict . contains ( message ) ) { found = true ; } } assertTrue ( <str> + msg + <str> + message + <str> + conflicts , found ) ; } } protected String toString ( MappedFieldType ft ) { return <str> + <str> + ft . names ( ) + <str> + ft . boost ( ) + <str> + ft . hasDocValues ( ) + <str> + ft . indexAnalyzer ( ) + <str> + ft . searchAnalyzer ( ) + <str> + ft . searchQuoteAnalyzer ( ) + <str> + ft . similarity ( ) + <str> + ft . normsLoading ( ) + <str> + ft . fieldDataType ( ) + <str> + ft . nullValue ( ) + <str> + ft . nullValueAsString ( ) + <str> + <str> + super . toString ( ) ; } public void testClone ( ) { MappedFieldType fieldType = createNamedDefaultFieldType ( ) ; MappedFieldType clone = fieldType . clone ( ) ; assertNotSame ( clone , fieldType ) ; assertEquals ( clone . getClass ( ) , fieldType . getClass ( ) ) ; assertEquals ( clone , fieldType ) ; assertEquals ( clone , clone . clone ( ) ) ; for ( Modifier modifier : modifiers ) { fieldType = createNamedDefaultFieldType ( ) ; modifier . modify ( fieldType ) ; clone = fieldType . clone ( ) ; assertNotSame ( clone , fieldType ) ; assertFieldTypeEquals ( modifier . property , clone , fieldType ) ; } } public void testEquals ( ) { MappedFieldType ft1 = createNamedDefaultFieldType ( ) ; MappedFieldType ft2 = createNamedDefaultFieldType ( ) ; assertEquals ( ft1 , ft1 ) ; assertEquals ( ft1 , ft2 ) ; assertEquals ( ft2 , ft1 ) ; assertEquals ( ft1 . hashCode ( ) , ft2 . hashCode ( ) ) ; for ( Modifier modifier : modifiers ) { ft1 = createNamedDefaultFieldType ( ) ; ft2 = createNamedDefaultFieldType ( ) ; modifier . modify ( ft2 ) ; assertFieldTypeNotEquals ( modifier . property , ft1 , ft2 ) ; assertNotEquals ( <str> + modifier . property , ft1 . hashCode ( ) , ft2 . hashCode ( ) ) ; modifier . modify ( ft1 ) ; assertFieldTypeEquals ( modifier . property , ft1 , ft2 ) ; assertEquals ( <str> + modifier . property , ft1 . hashCode ( ) , ft2 . hashCode ( ) ) ; } } public void testFreeze ( ) { for ( Modifier modifier : modifiers ) { MappedFieldType fieldType = createNamedDefaultFieldType ( ) ; fieldType . freeze ( ) ; try { modifier . modify ( fieldType ) ; fail ( <str> + modifier . property ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } } } public void testCheckTypeName ( ) { final MappedFieldType fieldType = createNamedDefaultFieldType ( ) ; List < String > conflicts = new ArrayList < > ( ) ; fieldType . checkCompatibility ( fieldType , conflicts , random ( ) . nextBoolean ( ) ) ; assertTrue ( conflicts . toString ( ) , conflicts . isEmpty ( ) ) ; MappedFieldType bogus = new MappedFieldType ( ) { @Override public MappedFieldType clone ( ) { return null ; } @Override public String typeName ( ) { return fieldType . typeName ( ) ; } } ; try { fieldType . checkCompatibility ( bogus , conflicts , random ( ) . nextBoolean ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } assertTrue ( conflicts . toString ( ) , conflicts . isEmpty ( ) ) ; MappedFieldType other = new MappedFieldType ( ) { @Override public MappedFieldType clone ( ) { return null ; } @Override public String typeName ( ) { return <str> ; } } ; try { fieldType . checkCompatibility ( other , conflicts , random ( ) . nextBoolean ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } assertTrue ( conflicts . toString ( ) , conflicts . isEmpty ( ) ) ; } public void testCheckCompatibility ( ) { MappedFieldType ft1 = createNamedDefaultFieldType ( ) ; MappedFieldType ft2 = createNamedDefaultFieldType ( ) ; assertCompatible ( <str> , ft1 , ft2 , true ) ; assertCompatible ( <str> , ft1 , ft2 , false ) ; assertCompatible ( <str> , ft2 , ft1 , true ) ; assertCompatible ( <str> , ft2 , ft1 , false ) ; for ( Modifier modifier : modifiers ) { ft1 = createNamedDefaultFieldType ( ) ; ft2 = createNamedDefaultFieldType ( ) ; modifier . normalizeOther ( ft1 ) ; modifier . modify ( ft2 ) ; if ( modifier . strictOnly ) { String [ ] conflicts = { <str> , <str> + modifier . property + <str> } ; assertCompatible ( modifier . property , ft1 , ft2 , false ) ; assertNotCompatible ( modifier . property , ft1 , ft2 , true , conflicts ) ; assertCompatible ( modifier . property , ft2 , ft1 , false ) ; if ( modifier . symmetric ) { assertNotCompatible ( modifier . property , ft2 , ft1 , true , conflicts ) ; } else { assertCompatible ( modifier . property , ft2 , ft1 , true ) ; } } else { String conflict = <str> + modifier . property + <str> ; assertNotCompatible ( modifier . property , ft1 , ft2 , true , conflict ) ; assertNotCompatible ( modifier . property , ft1 , ft2 , false , conflict ) ; if ( modifier . symmetric ) { assertNotCompatible ( modifier . property , ft2 , ft1 , true , conflict ) ; assertNotCompatible ( modifier . property , ft2 , ft1 , false , conflict ) ; } else { assertCompatible ( modifier . property , ft2 , ft1 , true ) ; assertCompatible ( modifier . property , ft2 , ft1 , false ) ; } } } } } 
