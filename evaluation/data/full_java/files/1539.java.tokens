package org . apache . cassandra . hints ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . zip . CRC32 ; import com . google . common . collect . Iterables ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceParams ; import static junit . framework . Assert . * ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . apache . cassandra . utils . FBUtilities . updateChecksum ; public class HintsBufferTest { private static final String KEYSPACE = <str> ; private static final String TABLE = <str> ; private static final int HINTS_COUNT = <int> ; private static final int HINT_THREADS_COUNT = <int> ; private static final int HOST_ID_COUNT = <int> ; @BeforeClass public static void defineSchema ( ) { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE ) ) ; } @Test @SuppressWarnings ( <str> ) public void testOverlyLargeAllocation ( ) { HintsBuffer buffer = HintsBuffer . create ( <int> ) ; try { buffer . allocate ( <int> - HintsBuffer . ENTRY_OVERHEAD_SIZE ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertEquals ( String . format ( <str> , <int> - HintsBuffer . ENTRY_OVERHEAD_SIZE ) , e . getMessage ( ) ) ; } try ( HintsBuffer . Allocation allocation = buffer . allocate ( <int> - HintsBuffer . ENTRY_OVERHEAD_SIZE ) ) { assertNotNull ( allocation ) ; } } @Test public void testWrite ( ) throws IOException , InterruptedException { UUID [ ] hostIds = new UUID [ HOST_ID_COUNT ] ; for ( int i = <int> ; i < hostIds . length ; i + + ) hostIds [ i ] = UUID . randomUUID ( ) ; Random random = new Random ( System . currentTimeMillis ( ) ) ; UUID [ ] load = new UUID [ HINTS_COUNT ] ; for ( int i = <int> ; i < load . length ; i + + ) load [ i ] = hostIds [ random . nextInt ( HOST_ID_COUNT ) ] ; int hintSize = ( int ) Hint . serializer . serializedSize ( createHint ( <int> , System . currentTimeMillis ( ) ) , MessagingService . current_version ) ; int entrySize = hintSize + HintsBuffer . ENTRY_OVERHEAD_SIZE ; int slabSize = entrySize * HINTS_COUNT ; HintsBuffer buffer = HintsBuffer . create ( slabSize ) ; long baseTimestamp = System . currentTimeMillis ( ) ; List < Thread > threads = new ArrayList < > ( HINT_THREADS_COUNT ) ; for ( int i = <int> ; i < HINT_THREADS_COUNT ; i + + ) threads . add ( new Thread ( new Writer ( buffer , load , hintSize , i , baseTimestamp ) ) ) ; threads . forEach ( java . lang . Thread : : start ) ; for ( Thread thread : threads ) thread . join ( ) ; assertEquals ( slabSize , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . remaining ( ) ) ; assertNull ( buffer . allocate ( <int> ) ) ; buffer . waitForModifications ( ) ; assertTrue ( buffer . isClosed ( ) ) ; assertEquals ( HOST_ID_COUNT , buffer . hostIds ( ) . size ( ) ) ; assertEquals ( new HashSet < > ( Arrays . asList ( hostIds ) ) , buffer . hostIds ( ) ) ; for ( UUID hostId : hostIds ) { Iterator < ByteBuffer > iter = buffer . consumingHintsIterator ( hostId ) ; while ( iter . hasNext ( ) ) { int idx = validateEntry ( hostId , iter . next ( ) , baseTimestamp , load ) ; load [ idx ] = null ; } } for ( UUID hostId : load ) assertNull ( hostId ) ; buffer . free ( ) ; } private static int validateEntry ( UUID hostId , ByteBuffer buffer , long baseTimestamp , UUID [ ] load ) throws IOException { CRC32 crc = new CRC32 ( ) ; DataInputPlus di = new DataInputBuffer ( buffer , true ) ; int hintSize = di . readInt ( ) ; assertEquals ( hintSize + HintsBuffer . ENTRY_OVERHEAD_SIZE , buffer . remaining ( ) ) ; updateChecksum ( crc , buffer , buffer . position ( ) , <int> ) ; assertEquals ( ( int ) crc . getValue ( ) , di . readInt ( ) ) ; Hint hint = Hint . serializer . deserialize ( di , MessagingService . current_version ) ; updateChecksum ( crc , buffer , buffer . position ( ) + <int> , hintSize ) ; assertEquals ( ( int ) crc . getValue ( ) , di . readInt ( ) ) ; int idx = ( int ) ( hint . creationTime - baseTimestamp ) ; assertEquals ( hostId , load [ idx ] ) ; Row row = hint . mutation . getPartitionUpdates ( ) . iterator ( ) . next ( ) . iterator ( ) . next ( ) ; assertEquals ( <int> , Iterables . size ( row . cells ( ) ) ) ; assertEquals ( bytes ( idx ) , row . clustering ( ) . get ( <int> ) ) ; Cell cell = row . cells ( ) . iterator ( ) . next ( ) ; assertEquals ( TimeUnit . MILLISECONDS . toMicros ( baseTimestamp + idx ) , cell . timestamp ( ) ) ; assertEquals ( bytes ( idx ) , cell . value ( ) ) ; return idx ; } private static Hint createHint ( int idx , long baseTimestamp ) { long timestamp = baseTimestamp + idx ; return Hint . create ( createMutation ( idx , TimeUnit . MILLISECONDS . toMicros ( timestamp ) ) , timestamp ) ; } private static Mutation createMutation ( int index , long timestamp ) { CFMetaData table = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; return new RowUpdateBuilder ( table , timestamp , bytes ( index ) ) . clustering ( bytes ( index ) ) . add ( <str> , bytes ( index ) ) . build ( ) ; } static class Writer implements Runnable { final HintsBuffer buffer ; final UUID [ ] load ; final int hintSize ; final int index ; final long baseTimestamp ; Writer ( HintsBuffer buffer , UUID [ ] load , int hintSize , int index , long baseTimestamp ) { this . buffer = buffer ; this . load = load ; this . hintSize = hintSize ; this . index = index ; this . baseTimestamp = baseTimestamp ; } public void run ( ) { int hintsPerThread = HINTS_COUNT / HINT_THREADS_COUNT ; for ( int i = index * hintsPerThread ; i < ( index + <int> ) * hintsPerThread ; i + + ) { try ( HintsBuffer . Allocation allocation = buffer . allocate ( hintSize ) ) { Hint hint = createHint ( i , baseTimestamp ) ; allocation . write ( Collections . singleton ( load [ i ] ) , hint ) ; } } } } } 
