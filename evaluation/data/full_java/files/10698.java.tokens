package org . gradle . build . docs . dsl . docbook ; import groovy . lang . Closure ; import org . gradle . build . docs . dsl . docbook . model . BlockDoc ; import org . gradle . build . docs . dsl . docbook . model . ClassDoc ; import org . gradle . build . docs . dsl . docbook . model . MethodDoc ; import org . gradle . build . docs . dsl . docbook . model . PropertyDoc ; import org . gradle . build . docs . dsl . source . model . MethodMetaData ; import org . gradle . build . docs . dsl . source . model . TypeMetaData ; import org . w3c . dom . Element ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public class ClassDocMethodsBuilder extends ModelBuilderSupport { private final JavadocConverter javadocConverter ; private final GenerationListener listener ; public ClassDocMethodsBuilder ( JavadocConverter converter , GenerationListener listener ) { this . javadocConverter = converter ; this . listener = listener ; } public void build ( ClassDoc classDoc ) { Set < String > signatures = new HashSet < String > ( ) ; for ( Element tr : children ( classDoc . getMethodsTable ( ) , <str> ) ) { List < Element > cells = children ( tr , <str> ) ; if ( cells . size ( ) ! = <int> ) { throw new RuntimeException ( String . format ( <str> , tr ) ) ; } String methodName = cells . get ( <int> ) . getTextContent ( ) . trim ( ) ; Collection < MethodMetaData > methods = classDoc . getClassMetaData ( ) . findDeclaredMethods ( methodName ) ; if ( methods . isEmpty ( ) ) { throw new RuntimeException ( String . format ( <str> , classDoc . getName ( ) , methodName , classDoc . getClassMetaData ( ) . getDeclaredMethodNames ( ) ) ) ; } for ( MethodMetaData method : methods ) { DocComment docComment = javadocConverter . parse ( method , listener ) ; MethodDoc methodDoc = new MethodDoc ( method , docComment . getDocbook ( ) ) ; if ( methodDoc . getDescription ( ) = = null ) { throw new RuntimeException ( String . format ( <str> , classDoc . getName ( ) , method . getSignature ( ) ) ) ; } PropertyDoc property = classDoc . findProperty ( methodName ) ; boolean multiValued = false ; if ( property ! = null & & method . getParameters ( ) . size ( ) = = <int> & & method . getParameters ( ) . get ( <int> ) . getType ( ) . getSignature ( ) . equals ( Closure . class . getName ( ) ) ) { TypeMetaData type = property . getMetaData ( ) . getType ( ) ; if ( type . getName ( ) . equals ( <str> ) | | type . getName ( ) . equals ( <str> ) | | type . getName ( ) . equals ( <str> ) | | type . getName ( ) . equals ( <str> ) ) { type = type . getTypeArgs ( ) . get ( <int> ) ; multiValued = true ; } classDoc . addClassBlock ( new BlockDoc ( methodDoc , property , type , multiValued ) ) ; } else { classDoc . addClassMethod ( methodDoc ) ; signatures . add ( method . getOverrideSignature ( ) ) ; } } } for ( ClassDoc supertype : classDoc . getSuperTypes ( ) ) { for ( MethodDoc method : supertype . getClassMethods ( ) ) { if ( signatures . add ( method . getMetaData ( ) . getOverrideSignature ( ) ) ) { classDoc . addClassMethod ( method ) ; } } } } } 
