package org . elasticsearch . search . aggregations . bucket . terms ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . bucket . BucketUtils ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Order ; import org . elasticsearch . search . aggregations . bucket . terms . TermsParametersParser . OrderElement ; import org . elasticsearch . search . aggregations . bucket . terms . support . IncludeExclude ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class TermsParser implements Aggregator . Parser { @Override public String type ( ) { return StringTerms . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { TermsParametersParser aggParser = new TermsParametersParser ( ) ; ValuesSourceParser vsParser = ValuesSourceParser . any ( aggregationName , StringTerms . TYPE , context ) . scriptable ( true ) . formattable ( true ) . build ( ) ; IncludeExclude . Parser incExcParser = new IncludeExclude . Parser ( ) ; aggParser . parse ( aggregationName , parser , context , vsParser , incExcParser ) ; List < OrderElement > orderElements = aggParser . getOrderElements ( ) ; List < Terms . Order > orders = new ArrayList < > ( orderElements . size ( ) ) ; for ( OrderElement orderElement : orderElements ) { orders . add ( resolveOrder ( orderElement . key ( ) , orderElement . asc ( ) ) ) ; } Terms . Order order ; if ( orders . size ( ) = = <int> & & ( orders . get ( <int> ) = = InternalOrder . TERM_ASC | | orders . get ( <int> ) = = InternalOrder . TERM_DESC ) ) { order = orders . get ( <int> ) ; } else { order = Order . compound ( orders ) ; } TermsAggregator . BucketCountThresholds bucketCountThresholds = aggParser . getBucketCountThresholds ( ) ; if ( ! ( order = = InternalOrder . TERM_ASC | | order = = InternalOrder . TERM_DESC ) & & bucketCountThresholds . getShardSize ( ) = = aggParser . getDefaultBucketCountThresholds ( ) . getShardSize ( ) ) { bucketCountThresholds . setShardSize ( BucketUtils . suggestShardSideQueueSize ( bucketCountThresholds . getRequiredSize ( ) , context . numberOfShards ( ) ) ) ; } bucketCountThresholds . ensureValidity ( ) ; return new TermsAggregatorFactory ( aggregationName , vsParser . config ( ) , order , bucketCountThresholds , aggParser . getIncludeExclude ( ) , aggParser . getExecutionHint ( ) , aggParser . getCollectionMode ( ) , aggParser . showTermDocCountError ( ) ) ; } static Terms . Order resolveOrder ( String key , boolean asc ) { if ( <str> . equals ( key ) ) { return Order . term ( asc ) ; } if ( <str> . equals ( key ) ) { return Order . count ( asc ) ; } return Order . aggregation ( key , asc ) ; } } 
