package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelPromise ; import io . netty . handler . ssl . ApplicationProtocolNames ; import io . netty . util . AsciiString ; import io . netty . util . concurrent . EventExecutor ; import static io . netty . buffer . Unpooled . directBuffer ; import static io . netty . buffer . Unpooled . unmodifiableBuffer ; import static io . netty . buffer . Unpooled . unreleasableBuffer ; import static io . netty . util . CharsetUtil . UTF_8 ; public final class Http2CodecUtil { public static final int CONNECTION_STREAM_ID = <int> ; public static final int HTTP_UPGRADE_STREAM_ID = <int> ; public static final CharSequence HTTP_UPGRADE_SETTINGS_HEADER = new AsciiString ( <str> ) ; public static final CharSequence HTTP_UPGRADE_PROTOCOL_NAME = <str> ; public static final CharSequence TLS_UPGRADE_PROTOCOL_NAME = ApplicationProtocolNames . HTTP_2 ; public static final int PING_FRAME_PAYLOAD_LENGTH = <int> ; public static final short MAX_UNSIGNED_BYTE = <hex> ; public static final int MAX_UNSIGNED_SHORT = <hex> ; public static final long MAX_UNSIGNED_INT = <hex> ; public static final int FRAME_HEADER_LENGTH = <int> ; public static final int SETTING_ENTRY_LENGTH = <int> ; public static final int PRIORITY_ENTRY_LENGTH = <int> ; public static final int INT_FIELD_LENGTH = <int> ; public static final short MAX_WEIGHT = <int> ; public static final short MIN_WEIGHT = <int> ; private static final ByteBuf CONNECTION_PREFACE = unmodifiableBuffer ( unreleasableBuffer ( directBuffer ( <int> ) . writeBytes ( <str> . getBytes ( UTF_8 ) ) ) ) ; private static final ByteBuf EMPTY_PING = unmodifiableBuffer ( unreleasableBuffer ( directBuffer ( PING_FRAME_PAYLOAD_LENGTH ) . writeZero ( PING_FRAME_PAYLOAD_LENGTH ) ) ) ; private static final int MAX_PADDING_LENGTH_LENGTH = <int> ; public static final int DATA_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + MAX_PADDING_LENGTH_LENGTH ; public static final int HEADERS_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + MAX_PADDING_LENGTH_LENGTH + INT_FIELD_LENGTH + <int> ; public static final int PRIORITY_FRAME_LENGTH = FRAME_HEADER_LENGTH + PRIORITY_ENTRY_LENGTH ; public static final int RST_STREAM_FRAME_LENGTH = FRAME_HEADER_LENGTH + INT_FIELD_LENGTH ; public static final int PUSH_PROMISE_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + MAX_PADDING_LENGTH_LENGTH + INT_FIELD_LENGTH ; public static final int GO_AWAY_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + <int> * INT_FIELD_LENGTH ; public static final int WINDOW_UPDATE_FRAME_LENGTH = FRAME_HEADER_LENGTH + INT_FIELD_LENGTH ; public static final int CONTINUATION_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + MAX_PADDING_LENGTH_LENGTH ; public static final char SETTINGS_HEADER_TABLE_SIZE = <int> ; public static final char SETTINGS_ENABLE_PUSH = <int> ; public static final char SETTINGS_MAX_CONCURRENT_STREAMS = <int> ; public static final char SETTINGS_INITIAL_WINDOW_SIZE = <int> ; public static final char SETTINGS_MAX_FRAME_SIZE = <int> ; public static final char SETTINGS_MAX_HEADER_LIST_SIZE = <int> ; public static final int NUM_STANDARD_SETTINGS = <int> ; public static final int MAX_HEADER_TABLE_SIZE = Integer . MAX_VALUE ; public static final long MAX_CONCURRENT_STREAMS = MAX_UNSIGNED_INT ; public static final int MAX_INITIAL_WINDOW_SIZE = Integer . MAX_VALUE ; public static final int MAX_FRAME_SIZE_LOWER_BOUND = <hex> ; public static final int MAX_FRAME_SIZE_UPPER_BOUND = <hex> ; public static final long MAX_HEADER_LIST_SIZE = Long . MAX_VALUE ; public static final long MIN_HEADER_TABLE_SIZE = <int> ; public static final long MIN_CONCURRENT_STREAMS = <int> ; public static final int MIN_INITIAL_WINDOW_SIZE = <int> ; public static final long MIN_HEADER_LIST_SIZE = <int> ; public static final int DEFAULT_WINDOW_SIZE = <int> ; public static final boolean DEFAULT_ENABLE_PUSH = true ; public static final short DEFAULT_PRIORITY_WEIGHT = <int> ; public static final int DEFAULT_HEADER_TABLE_SIZE = <int> ; public static final int DEFAULT_MAX_HEADER_SIZE = <int> ; public static final int DEFAULT_MAX_FRAME_SIZE = MAX_FRAME_SIZE_LOWER_BOUND ; public static final int SMALLEST_MAX_CONCURRENT_STREAMS = <int> ; public static boolean isMaxFrameSizeValid ( int maxFrameSize ) { return maxFrameSize > = MAX_FRAME_SIZE_LOWER_BOUND & & maxFrameSize < = MAX_FRAME_SIZE_UPPER_BOUND ; } public static ByteBuf connectionPrefaceBuf ( ) { return CONNECTION_PREFACE . duplicate ( ) . retain ( ) ; } public static ByteBuf emptyPingBuf ( ) { return EMPTY_PING . duplicate ( ) . retain ( ) ; } public static Http2Exception getEmbeddedHttp2Exception ( Throwable cause ) { while ( cause ! = null ) { if ( cause instanceof Http2Exception ) { return ( Http2Exception ) cause ; } cause = cause . getCause ( ) ; } return null ; } public static ByteBuf toByteBuf ( ChannelHandlerContext ctx , Throwable cause ) { if ( cause = = null | | cause . getMessage ( ) = = null ) { return Unpooled . EMPTY_BUFFER ; } ByteBuf debugData = ctx . alloc ( ) . buffer ( cause . getMessage ( ) . length ( ) * <int> ) ; ByteBufUtil . writeUtf8 ( debugData , cause . getMessage ( ) ) ; return debugData ; } public static int readUnsignedInt ( ByteBuf buf ) { return ( buf . readByte ( ) & <hex> ) < < <int> | ( buf . readByte ( ) & <hex> ) < < <int> | ( buf . readByte ( ) & <hex> ) < < <int> | buf . readByte ( ) & <hex> ; } public static void writeUnsignedInt ( long value , ByteBuf out ) { out . writeByte ( ( int ) ( value > > <int> & <hex> ) ) ; out . writeByte ( ( int ) ( value > > <int> & <hex> ) ) ; out . writeByte ( ( int ) ( value > > <int> & <hex> ) ) ; out . writeByte ( ( int ) ( value & <hex> ) ) ; } public static void writeUnsignedShort ( int value , ByteBuf out ) { out . writeByte ( value > > <int> & <hex> ) ; out . writeByte ( value & <hex> ) ; } public static void writeFrameHeader ( ByteBuf out , int payloadLength , byte type , Http2Flags flags , int streamId ) { out . ensureWritable ( FRAME_HEADER_LENGTH + payloadLength ) ; writeFrameHeaderInternal ( out , payloadLength , type , flags , streamId ) ; } static void writeFrameHeaderInternal ( ByteBuf out , int payloadLength , byte type , Http2Flags flags , int streamId ) { out . writeMedium ( payloadLength ) ; out . writeByte ( type ) ; out . writeByte ( flags . value ( ) ) ; out . writeInt ( streamId ) ; } static class SimpleChannelPromiseAggregator extends DefaultChannelPromise { private final ChannelPromise promise ; private int expectedCount ; private int successfulCount ; private int failureCount ; private boolean doneAllocating ; SimpleChannelPromiseAggregator ( ChannelPromise promise , Channel c , EventExecutor e ) { super ( c , e ) ; assert promise ! = null ; this . promise = promise ; } public ChannelPromise newPromise ( ) { if ( doneAllocating ) { throw new IllegalStateException ( <str> ) ; } + + expectedCount ; return this ; } public ChannelPromise doneAllocatingPromises ( ) { if ( ! doneAllocating ) { doneAllocating = true ; if ( successfulCount = = expectedCount ) { promise . setSuccess ( ) ; return super . setSuccess ( null ) ; } } return this ; } @Override public boolean tryFailure ( Throwable cause ) { if ( allowFailure ( ) ) { + + failureCount ; if ( failureCount = = <int> ) { promise . tryFailure ( cause ) ; return super . tryFailure ( cause ) ; } return true ; } return false ; } @Override public ChannelPromise setFailure ( Throwable cause ) { if ( allowFailure ( ) ) { + + failureCount ; if ( failureCount = = <int> ) { promise . setFailure ( cause ) ; return super . setFailure ( cause ) ; } } return this ; } private boolean allowFailure ( ) { return awaitingPromises ( ) | | expectedCount = = <int> ; } private boolean awaitingPromises ( ) { return successfulCount + failureCount < expectedCount ; } @Override public ChannelPromise setSuccess ( Void result ) { if ( awaitingPromises ( ) ) { + + successfulCount ; if ( successfulCount = = expectedCount & & doneAllocating ) { promise . setSuccess ( result ) ; return super . setSuccess ( result ) ; } } return this ; } @Override public boolean trySuccess ( Void result ) { if ( awaitingPromises ( ) ) { + + successfulCount ; if ( successfulCount = = expectedCount & & doneAllocating ) { promise . trySuccess ( result ) ; return super . trySuccess ( result ) ; } return true ; } return false ; } } private Http2CodecUtil ( ) { } } 
