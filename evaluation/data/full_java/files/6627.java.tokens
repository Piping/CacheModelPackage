package org . elasticsearch . index . query ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . Arrays ; import java . util . Objects ; public class IndicesQueryBuilder extends AbstractQueryBuilder < IndicesQueryBuilder > { public static final String NAME = <str> ; private final QueryBuilder innerQuery ; private final String [ ] indices ; private QueryBuilder noMatchQuery = defaultNoMatchQuery ( ) ; static final IndicesQueryBuilder PROTOTYPE = new IndicesQueryBuilder ( EmptyQueryBuilder . PROTOTYPE , <str> ) ; public IndicesQueryBuilder ( QueryBuilder innerQuery , String . . . indices ) { if ( innerQuery = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( indices = = null | | indices . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . innerQuery = Objects . requireNonNull ( innerQuery ) ; this . indices = indices ; } public QueryBuilder innerQuery ( ) { return this . innerQuery ; } public String [ ] indices ( ) { return this . indices ; } public IndicesQueryBuilder noMatchQuery ( QueryBuilder noMatchQuery ) { if ( noMatchQuery = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . noMatchQuery = noMatchQuery ; return this ; } public IndicesQueryBuilder noMatchQuery ( String type ) { this . noMatchQuery = IndicesQueryParser . parseNoMatchQuery ( type ) ; return this ; } public QueryBuilder noMatchQuery ( ) { return this . noMatchQuery ; } static QueryBuilder defaultNoMatchQuery ( ) { return QueryBuilders . matchAllQuery ( ) ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( IndicesQueryParser . INDICES_FIELD . getPreferredName ( ) , indices ) ; builder . field ( IndicesQueryParser . QUERY_FIELD . getPreferredName ( ) ) ; innerQuery . toXContent ( builder , params ) ; builder . field ( IndicesQueryParser . NO_MATCH_QUERY . getPreferredName ( ) ) ; noMatchQuery . toXContent ( builder , params ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { if ( context . matchesIndices ( indices ) ) { return innerQuery . toQuery ( context ) ; } return noMatchQuery . toQuery ( context ) ; } @Override protected IndicesQueryBuilder doReadFrom ( StreamInput in ) throws IOException { IndicesQueryBuilder indicesQueryBuilder = new IndicesQueryBuilder ( in . readQuery ( ) , in . readStringArray ( ) ) ; indicesQueryBuilder . noMatchQuery = in . readQuery ( ) ; return indicesQueryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeQuery ( innerQuery ) ; out . writeStringArray ( indices ) ; out . writeQuery ( noMatchQuery ) ; } @Override public int doHashCode ( ) { return Objects . hash ( innerQuery , noMatchQuery , Arrays . hashCode ( indices ) ) ; } @Override protected boolean doEquals ( IndicesQueryBuilder other ) { return Objects . equals ( innerQuery , other . innerQuery ) & & Arrays . equals ( indices , other . indices ) & & Objects . equals ( noMatchQuery , other . noMatchQuery ) ; } } 
