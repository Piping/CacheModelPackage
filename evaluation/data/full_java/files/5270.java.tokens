package org . elasticsearch . action . bulk ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . CompositeIndicesRequest ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . update . UpdateRequest ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContent ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . VersionType ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . action . ValidateActions . addValidationError ; public class BulkRequest extends ActionRequest < BulkRequest > implements CompositeIndicesRequest { private static final int REQUEST_OVERHEAD = <int> ; final List < ActionRequest > requests = new ArrayList < > ( ) ; List < Object > payloads = null ; protected TimeValue timeout = BulkShardRequest . DEFAULT_TIMEOUT ; private WriteConsistencyLevel consistencyLevel = WriteConsistencyLevel . DEFAULT ; private boolean refresh = false ; private long sizeInBytes = <int> ; public BulkRequest ( ) { } public BulkRequest ( ActionRequest request ) { super ( request ) ; } public BulkRequest add ( ActionRequest . . . requests ) { for ( ActionRequest request : requests ) { add ( request , null ) ; } return this ; } public BulkRequest add ( ActionRequest request ) { return add ( request , null ) ; } public BulkRequest add ( ActionRequest request , @Nullable Object payload ) { if ( request instanceof IndexRequest ) { add ( ( IndexRequest ) request , payload ) ; } else if ( request instanceof DeleteRequest ) { add ( ( DeleteRequest ) request , payload ) ; } else if ( request instanceof UpdateRequest ) { add ( ( UpdateRequest ) request , payload ) ; } else { throw new IllegalArgumentException ( <str> + request + <str> ) ; } return this ; } public BulkRequest add ( Iterable < ActionRequest > requests ) { for ( ActionRequest request : requests ) { add ( request ) ; } return this ; } public BulkRequest add ( IndexRequest request ) { return internalAdd ( request , null ) ; } public BulkRequest add ( IndexRequest request , @Nullable Object payload ) { return internalAdd ( request , payload ) ; } BulkRequest internalAdd ( IndexRequest request , @Nullable Object payload ) { requests . add ( request ) ; addPayload ( payload ) ; sizeInBytes + = ( request . source ( ) ! = null ? request . source ( ) . length ( ) : <int> ) + REQUEST_OVERHEAD ; return this ; } public BulkRequest add ( UpdateRequest request ) { return internalAdd ( request , null ) ; } public BulkRequest add ( UpdateRequest request , @Nullable Object payload ) { return internalAdd ( request , payload ) ; } BulkRequest internalAdd ( UpdateRequest request , @Nullable Object payload ) { requests . add ( request ) ; addPayload ( payload ) ; if ( request . doc ( ) ! = null ) { sizeInBytes + = request . doc ( ) . source ( ) . length ( ) ; } if ( request . upsertRequest ( ) ! = null ) { sizeInBytes + = request . upsertRequest ( ) . source ( ) . length ( ) ; } if ( request . script ( ) ! = null ) { sizeInBytes + = request . script ( ) . getScript ( ) . length ( ) * <int> ; } return this ; } public BulkRequest add ( DeleteRequest request ) { return add ( request , null ) ; } public BulkRequest add ( DeleteRequest request , @Nullable Object payload ) { requests . add ( request ) ; addPayload ( payload ) ; sizeInBytes + = REQUEST_OVERHEAD ; return this ; } private void addPayload ( Object payload ) { if ( payloads = = null ) { if ( payload = = null ) { return ; } payloads = new ArrayList < > ( requests . size ( ) + <int> ) ; for ( int i = <int> ; i < requests . size ( ) ; i + + ) { payloads . add ( null ) ; } } payloads . add ( payload ) ; } public List < ActionRequest > requests ( ) { return this . requests ; } @Override @SuppressWarnings ( <str> ) public List < ? extends IndicesRequest > subRequests ( ) { List < IndicesRequest > indicesRequests = new ArrayList < > ( ) ; for ( ActionRequest request : requests ) { assert request instanceof IndicesRequest ; indicesRequests . add ( ( IndicesRequest ) request ) ; } return indicesRequests ; } @Nullable public List < Object > payloads ( ) { return this . payloads ; } public int numberOfActions ( ) { return requests . size ( ) ; } public long estimatedSizeInBytes ( ) { return sizeInBytes ; } public BulkRequest add ( byte [ ] data , int from , int length ) throws Exception { return add ( data , from , length , null , null ) ; } public BulkRequest add ( byte [ ] data , int from , int length , @Nullable String defaultIndex , @Nullable String defaultType ) throws Exception { return add ( new BytesArray ( data , from , length ) , defaultIndex , defaultType ) ; } public BulkRequest add ( BytesReference data , @Nullable String defaultIndex , @Nullable String defaultType ) throws Exception { return add ( data , defaultIndex , defaultType , null , null , null , true ) ; } public BulkRequest add ( BytesReference data , @Nullable String defaultIndex , @Nullable String defaultType , boolean allowExplicitIndex ) throws Exception { return add ( data , defaultIndex , defaultType , null , null , null , allowExplicitIndex ) ; } public BulkRequest add ( BytesReference data , @Nullable String defaultIndex , @Nullable String defaultType , @Nullable String defaultRouting , @Nullable String [ ] defaultFields , @Nullable Object payload , boolean allowExplicitIndex ) throws Exception { XContent xContent = XContentFactory . xContent ( data ) ; int line = <int> ; int from = <int> ; int length = data . length ( ) ; byte marker = xContent . streamSeparator ( ) ; while ( true ) { int nextMarker = findNextMarker ( marker , from , data , length ) ; if ( nextMarker = = - <int> ) { break ; } line + + ; try ( XContentParser parser = xContent . createParser ( data . slice ( from , nextMarker - from ) ) ) { from = nextMarker + <int> ; XContentParser . Token token = parser . nextToken ( ) ; if ( token = = null ) { continue ; } assert token = = XContentParser . Token . START_OBJECT ; token = parser . nextToken ( ) ; assert token = = XContentParser . Token . FIELD_NAME ; String action = parser . currentName ( ) ; String index = defaultIndex ; String type = defaultType ; String id = null ; String routing = defaultRouting ; String parent = null ; String [ ] fields = defaultFields ; String timestamp = null ; TimeValue ttl = null ; String opType = null ; long version = Versions . MATCH_ANY ; VersionType versionType = VersionType . INTERNAL ; int retryOnConflict = <int> ; token = parser . nextToken ( ) ; if ( token = = XContentParser . Token . START_OBJECT ) { String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { if ( ! allowExplicitIndex ) { throw new IllegalArgumentException ( <str> ) ; } index = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { type = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { id = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { routing = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { parent = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { timestamp = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { if ( parser . currentToken ( ) = = XContentParser . Token . VALUE_STRING ) { ttl = TimeValue . parseTimeValue ( parser . text ( ) , null , currentFieldName ) ; } else { ttl = new TimeValue ( parser . longValue ( ) ) ; } } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { opType = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { version = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { versionType = VersionType . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { retryOnConflict = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { throw new IllegalArgumentException ( <str> + line + <str> ) ; } else { throw new IllegalArgumentException ( <str> + line + <str> + currentFieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { List < Object > values = parser . list ( ) ; fields = values . toArray ( new String [ values . size ( ) ] ) ; } else { throw new IllegalArgumentException ( <str> + line + <str> + currentFieldName + <str> + token + <str> ) ; } } else if ( token ! = XContentParser . Token . VALUE_NULL ) { throw new IllegalArgumentException ( <str> + line + <str> + currentFieldName + <str> + token + <str> ) ; } } } else if ( token ! = XContentParser . Token . END_OBJECT ) { throw new IllegalArgumentException ( <str> + line + <str> + XContentParser . Token . START_OBJECT + <str> + XContentParser . Token . END_OBJECT + <str> + token + <str> ) ; } if ( <str> . equals ( action ) ) { add ( new DeleteRequest ( index , type , id ) . routing ( routing ) . parent ( parent ) . version ( version ) . versionType ( versionType ) , payload ) ; } else { nextMarker = findNextMarker ( marker , from , data , length ) ; if ( nextMarker = = - <int> ) { break ; } line + + ; if ( <str> . equals ( action ) ) { if ( opType = = null ) { internalAdd ( new IndexRequest ( index , type , id ) . routing ( routing ) . parent ( parent ) . timestamp ( timestamp ) . ttl ( ttl ) . version ( version ) . versionType ( versionType ) . source ( data . slice ( from , nextMarker - from ) ) , payload ) ; } else { internalAdd ( new IndexRequest ( index , type , id ) . routing ( routing ) . parent ( parent ) . timestamp ( timestamp ) . ttl ( ttl ) . version ( version ) . versionType ( versionType ) . create ( <str> . equals ( opType ) ) . source ( data . slice ( from , nextMarker - from ) ) , payload ) ; } } else if ( <str> . equals ( action ) ) { internalAdd ( new IndexRequest ( index , type , id ) . routing ( routing ) . parent ( parent ) . timestamp ( timestamp ) . ttl ( ttl ) . version ( version ) . versionType ( versionType ) . create ( true ) . source ( data . slice ( from , nextMarker - from ) ) , payload ) ; } else if ( <str> . equals ( action ) ) { UpdateRequest updateRequest = new UpdateRequest ( index , type , id ) . routing ( routing ) . parent ( parent ) . retryOnConflict ( retryOnConflict ) . version ( version ) . versionType ( versionType ) . routing ( routing ) . parent ( parent ) . source ( data . slice ( from , nextMarker - from ) ) ; if ( fields ! = null ) { updateRequest . fields ( fields ) ; } IndexRequest upsertRequest = updateRequest . upsertRequest ( ) ; if ( upsertRequest ! = null ) { upsertRequest . timestamp ( timestamp ) ; upsertRequest . ttl ( ttl ) ; upsertRequest . version ( version ) ; upsertRequest . versionType ( versionType ) ; } IndexRequest doc = updateRequest . doc ( ) ; if ( doc ! = null ) { doc . timestamp ( timestamp ) ; doc . ttl ( ttl ) ; doc . version ( version ) ; doc . versionType ( versionType ) ; } internalAdd ( updateRequest , payload ) ; } from = nextMarker + <int> ; } } } return this ; } public BulkRequest consistencyLevel ( WriteConsistencyLevel consistencyLevel ) { this . consistencyLevel = consistencyLevel ; return this ; } public WriteConsistencyLevel consistencyLevel ( ) { return this . consistencyLevel ; } public BulkRequest refresh ( boolean refresh ) { this . refresh = refresh ; return this ; } public boolean refresh ( ) { return this . refresh ; } public final BulkRequest timeout ( TimeValue timeout ) { this . timeout = timeout ; return this ; } public final BulkRequest timeout ( String timeout ) { return timeout ( TimeValue . parseTimeValue ( timeout , null , getClass ( ) . getSimpleName ( ) + <str> ) ) ; } public TimeValue timeout ( ) { return timeout ; } private int findNextMarker ( byte marker , int from , BytesReference data , int length ) { for ( int i = from ; i < length ; i + + ) { if ( data . get ( i ) = = marker ) { return i ; } } return - <int> ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( requests . isEmpty ( ) ) { validationException = addValidationError ( <str> , validationException ) ; } for ( ActionRequest request : requests ) { if ( ( request instanceof DeleteRequest & & ( ( DeleteRequest ) request ) . refresh ( ) ) | | ( request instanceof UpdateRequest & & ( ( UpdateRequest ) request ) . refresh ( ) ) | | ( request instanceof IndexRequest & & ( ( IndexRequest ) request ) . refresh ( ) ) ) { validationException = addValidationError ( <str> , validationException ) ; } ActionRequestValidationException ex = request . validate ( ) ; if ( ex ! = null ) { if ( validationException = = null ) { validationException = new ActionRequestValidationException ( ) ; } validationException . addValidationErrors ( ex . validationErrors ( ) ) ; } } return validationException ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; consistencyLevel = WriteConsistencyLevel . fromId ( in . readByte ( ) ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { byte type = in . readByte ( ) ; if ( type = = <int> ) { IndexRequest request = new IndexRequest ( ) ; request . readFrom ( in ) ; requests . add ( request ) ; } else if ( type = = <int> ) { DeleteRequest request = new DeleteRequest ( ) ; request . readFrom ( in ) ; requests . add ( request ) ; } else if ( type = = <int> ) { UpdateRequest request = new UpdateRequest ( ) ; request . readFrom ( in ) ; requests . add ( request ) ; } } refresh = in . readBoolean ( ) ; timeout = TimeValue . readTimeValue ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeByte ( consistencyLevel . id ( ) ) ; out . writeVInt ( requests . size ( ) ) ; for ( ActionRequest request : requests ) { if ( request instanceof IndexRequest ) { out . writeByte ( ( byte ) <int> ) ; } else if ( request instanceof DeleteRequest ) { out . writeByte ( ( byte ) <int> ) ; } else if ( request instanceof UpdateRequest ) { out . writeByte ( ( byte ) <int> ) ; } request . writeTo ( out ) ; } out . writeBoolean ( refresh ) ; timeout . writeTo ( out ) ; } } 
