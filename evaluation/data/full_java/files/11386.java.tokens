package org . gradle . api . internal . changedetection . rules ; import com . google . common . collect . AbstractIterator ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class CachingTaskStateChanges implements TaskStateChanges { private final TaskStateChanges delegate ; private final List < TaskStateChange > cache = new ArrayList < TaskStateChange > ( ) ; private final int maxCachedChanges ; private Iterator < TaskStateChange > delegateIterator ; boolean overrun ; public CachingTaskStateChanges ( int maxCachedChanges , TaskStateChanges delegate ) { this . maxCachedChanges = maxCachedChanges ; this . delegate = delegate ; } public Iterator < TaskStateChange > iterator ( ) { if ( delegateIterator = = null | | overrun ) { reset ( ) ; } return new AbstractIterator < TaskStateChange > ( ) { final Iterator < TaskStateChange > cacheIterator = new ArrayList < TaskStateChange > ( cache ) . iterator ( ) ; @Override protected TaskStateChange computeNext ( ) { if ( cacheIterator . hasNext ( ) ) { return cacheIterator . next ( ) ; } if ( delegateIterator . hasNext ( ) ) { TaskStateChange next = delegateIterator . next ( ) ; maybeCache ( next ) ; return next ; } return endOfData ( ) ; } } ; } private void maybeCache ( TaskStateChange next ) { if ( overrun ) { return ; } if ( cache . size ( ) < maxCachedChanges ) { cache . add ( next ) ; } else { overrun = true ; } } private void reset ( ) { cache . clear ( ) ; delegateIterator = delegate . iterator ( ) ; overrun = false ; } public void snapshotAfterTask ( ) { delegate . snapshotAfterTask ( ) ; } } 
