package com . badlogic . gdx . tests . gles2 ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . tests . utils . GdxTest ; public class MipMap2D extends GdxTest { ShaderProgram shader ; Texture texture ; Mesh mesh ; @Override public void create ( ) { String vertexShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; String fragmentShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; shader = new ShaderProgram ( vertexShader , fragmentShader ) ; mesh = new Mesh ( true , <int> , <int> , new VertexAttribute ( Usage . Position , <int> , <str> ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , <str> ) ) ; float [ ] vertices = { - <float> , <float> , <float> , <float> , <float> , <float> , - <float> , - <float> , <float> , <float> , <float> , <float> , <float> , - <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } ; short [ ] indices = { <int> , <int> , <int> , <int> , <int> , <int> } ; mesh . setVertices ( vertices ) ; mesh . setIndices ( indices ) ; createTexture ( ) ; } private void createTexture ( ) { Pixmap pixmap = new Pixmap ( <int> , <int> , Format . RGB565 ) ; boolean useRed = true ; for ( int y = <int> ; y < <int> ; y + = <int> ) { for ( int x = <int> ; x < <int> ; x + = <int> ) { pixmap . setColor ( useRed ? <int> : <int> , <int> , useRed ? <int> : <int> , <int> ) ; pixmap . fillRectangle ( x , y , <int> , <int> ) ; useRed = ! useRed ; } useRed = ! useRed ; } texture = new Texture ( pixmap , true ) ; texture . setFilter ( TextureFilter . MipMapLinearLinear , TextureFilter . Linear ) ; } public void resume ( ) { createTexture ( ) ; } public void render ( ) { Gdx . gl20 . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl20 . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; Gdx . gl20 . glActiveTexture ( GL20 . GL_TEXTURE0 ) ; texture . bind ( ) ; shader . begin ( ) ; shader . setUniformf ( <str> , <int> ) ; Gdx . gl20 . glTexParameteri ( GL20 . GL_TEXTURE_2D , GL20 . GL_TEXTURE_MIN_FILTER , GL20 . GL_NEAREST ) ; shader . setUniformf ( <str> , - <float> ) ; mesh . render ( shader , GL20 . GL_TRIANGLES ) ; Gdx . gl20 . glTexParameteri ( GL20 . GL_TEXTURE_2D , GL20 . GL_TEXTURE_MIN_FILTER , GL20 . GL_LINEAR_MIPMAP_LINEAR ) ; shader . setUniformf ( <str> , <float> ) ; mesh . render ( shader , GL20 . GL_TRIANGLES ) ; shader . end ( ) ; } } 
