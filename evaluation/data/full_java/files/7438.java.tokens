package org . elasticsearch . search . aggregations . pipeline . serialdiff ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . support . format . ValueFormat ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; public class SerialDiffParser implements PipelineAggregator . Parser { public static final ParseField FORMAT = new ParseField ( <str> ) ; public static final ParseField GAP_POLICY = new ParseField ( <str> ) ; public static final ParseField LAG = new ParseField ( <str> ) ; @Override public String type ( ) { return SerialDiffPipelineAggregator . TYPE . name ( ) ; } @Override public PipelineAggregatorFactory parse ( String reducerName , XContentParser parser , SearchContext context ) throws IOException { XContentParser . Token token ; String currentFieldName = null ; String [ ] bucketsPaths = null ; String format = null ; GapPolicy gapPolicy = GapPolicy . SKIP ; int lag = <int> ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , FORMAT ) ) { format = parser . text ( ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { bucketsPaths = new String [ ] { parser . text ( ) } ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , GAP_POLICY ) ) { gapPolicy = GapPolicy . parse ( context , parser . text ( ) , parser . getTokenLocation ( ) ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , LAG ) ) { lag = parser . intValue ( true ) ; if ( lag < = <int> ) { throw new SearchParseException ( context , <str> + lag + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { List < String > paths = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String path = parser . text ( ) ; paths . add ( path ) ; } bucketsPaths = paths . toArray ( new String [ paths . size ( ) ] ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> , parser . getTokenLocation ( ) ) ; } } if ( bucketsPaths = = null ) { throw new SearchParseException ( context , <str> + BUCKETS_PATH . getPreferredName ( ) + <str> + reducerName + <str> , parser . getTokenLocation ( ) ) ; } ValueFormatter formatter ; if ( format ! = null ) { formatter = ValueFormat . Patternable . Number . format ( format ) . formatter ( ) ; } else { formatter = ValueFormatter . RAW ; } return new SerialDiffPipelineAggregator . Factory ( reducerName , bucketsPaths , formatter , gapPolicy , lag ) ; } } 
