package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . base . Objects ; import com . google . common . base . Supplier ; import com . google . common . collect . Table . Cell ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; import javax . annotation . Nullable ; @GwtCompatible public final class Tables { private Tables ( ) { } public static < R , C , V > Cell < R , C , V > immutableCell ( @Nullable R rowKey , @Nullable C columnKey , @Nullable V value ) { return new ImmutableCell < R , C , V > ( rowKey , columnKey , value ) ; } static final class ImmutableCell < R , C , V > extends AbstractCell < R , C , V > implements Serializable { private final R rowKey ; private final C columnKey ; private final V value ; ImmutableCell ( @Nullable R rowKey , @Nullable C columnKey , @Nullable V value ) { this . rowKey = rowKey ; this . columnKey = columnKey ; this . value = value ; } @Override public R getRowKey ( ) { return rowKey ; } @Override public C getColumnKey ( ) { return columnKey ; } @Override public V getValue ( ) { return value ; } private static final long serialVersionUID = <int> ; } abstract static class AbstractCell < R , C , V > implements Cell < R , C , V > { AbstractCell ( ) { } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Cell ) { Cell < ? , ? , ? > other = ( Cell < ? , ? , ? > ) obj ; return Objects . equal ( getRowKey ( ) , other . getRowKey ( ) ) & & Objects . equal ( getColumnKey ( ) , other . getColumnKey ( ) ) & & Objects . equal ( getValue ( ) , other . getValue ( ) ) ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( getRowKey ( ) , getColumnKey ( ) , getValue ( ) ) ; } @Override public String toString ( ) { return <str> + getRowKey ( ) + <str> + getColumnKey ( ) + <str> + getValue ( ) ; } } public static < R , C , V > Table < C , R , V > transpose ( Table < R , C , V > table ) { return ( table instanceof TransposeTable ) ? ( ( TransposeTable < R , C , V > ) table ) . original : new TransposeTable < C , R , V > ( table ) ; } private static class TransposeTable < C , R , V > extends AbstractTable < C , R , V > { final Table < R , C , V > original ; TransposeTable ( Table < R , C , V > original ) { this . original = checkNotNull ( original ) ; } @Override public void clear ( ) { original . clear ( ) ; } @Override public Map < C , V > column ( R columnKey ) { return original . row ( columnKey ) ; } @Override public Set < R > columnKeySet ( ) { return original . rowKeySet ( ) ; } @Override public Map < R , Map < C , V > > columnMap ( ) { return original . rowMap ( ) ; } @Override public boolean contains ( @Nullable Object rowKey , @Nullable Object columnKey ) { return original . contains ( columnKey , rowKey ) ; } @Override public boolean containsColumn ( @Nullable Object columnKey ) { return original . containsRow ( columnKey ) ; } @Override public boolean containsRow ( @Nullable Object rowKey ) { return original . containsColumn ( rowKey ) ; } @Override public boolean containsValue ( @Nullable Object value ) { return original . containsValue ( value ) ; } @Override public V get ( @Nullable Object rowKey , @Nullable Object columnKey ) { return original . get ( columnKey , rowKey ) ; } @Override public V put ( C rowKey , R columnKey , V value ) { return original . put ( columnKey , rowKey , value ) ; } @Override public void putAll ( Table < ? extends C , ? extends R , ? extends V > table ) { original . putAll ( transpose ( table ) ) ; } @Override public V remove ( @Nullable Object rowKey , @Nullable Object columnKey ) { return original . remove ( columnKey , rowKey ) ; } @Override public Map < R , V > row ( C rowKey ) { return original . column ( rowKey ) ; } @Override public Set < C > rowKeySet ( ) { return original . columnKeySet ( ) ; } @Override public Map < C , Map < R , V > > rowMap ( ) { return original . columnMap ( ) ; } @Override public int size ( ) { return original . size ( ) ; } @Override public Collection < V > values ( ) { return original . values ( ) ; } private static final Function < Cell < ? , ? , ? > , Cell < ? , ? , ? > > TRANSPOSE_CELL = new Function < Cell < ? , ? , ? > , Cell < ? , ? , ? > > ( ) { @Override public Cell < ? , ? , ? > apply ( Cell < ? , ? , ? > cell ) { return immutableCell ( cell . getColumnKey ( ) , cell . getRowKey ( ) , cell . getValue ( ) ) ; } } ; @SuppressWarnings ( <str> ) @Override Iterator < Cell < C , R , V > > cellIterator ( ) { return Iterators . transform ( original . cellSet ( ) . iterator ( ) , ( Function ) TRANSPOSE_CELL ) ; } } @Beta public static < R , C , V > Table < R , C , V > newCustomTable ( Map < R , Map < C , V > > backingMap , Supplier < ? extends Map < C , V > > factory ) { checkArgument ( backingMap . isEmpty ( ) ) ; checkNotNull ( factory ) ; return new StandardTable < R , C , V > ( backingMap , factory ) ; } @Beta public static < R , C , V1 , V2 > Table < R , C , V2 > transformValues ( Table < R , C , V1 > fromTable , Function < ? super V1 , V2 > function ) { return new TransformedTable < R , C , V1 , V2 > ( fromTable , function ) ; } private static class TransformedTable < R , C , V1 , V2 > extends AbstractTable < R , C , V2 > { final Table < R , C , V1 > fromTable ; final Function < ? super V1 , V2 > function ; TransformedTable ( Table < R , C , V1 > fromTable , Function < ? super V1 , V2 > function ) { this . fromTable = checkNotNull ( fromTable ) ; this . function = checkNotNull ( function ) ; } @Override public boolean contains ( Object rowKey , Object columnKey ) { return fromTable . contains ( rowKey , columnKey ) ; } @Override public V2 get ( Object rowKey , Object columnKey ) { return contains ( rowKey , columnKey ) ? function . apply ( fromTable . get ( rowKey , columnKey ) ) : null ; } @Override public int size ( ) { return fromTable . size ( ) ; } @Override public void clear ( ) { fromTable . clear ( ) ; } @Override public V2 put ( R rowKey , C columnKey , V2 value ) { throw new UnsupportedOperationException ( ) ; } @Override public void putAll ( Table < ? extends R , ? extends C , ? extends V2 > table ) { throw new UnsupportedOperationException ( ) ; } @Override public V2 remove ( Object rowKey , Object columnKey ) { return contains ( rowKey , columnKey ) ? function . apply ( fromTable . remove ( rowKey , columnKey ) ) : null ; } @Override public Map < C , V2 > row ( R rowKey ) { return Maps . transformValues ( fromTable . row ( rowKey ) , function ) ; } @Override public Map < R , V2 > column ( C columnKey ) { return Maps . transformValues ( fromTable . column ( columnKey ) , function ) ; } Function < Cell < R , C , V1 > , Cell < R , C , V2 > > cellFunction ( ) { return new Function < Cell < R , C , V1 > , Cell < R , C , V2 > > ( ) { @Override public Cell < R , C , V2 > apply ( Cell < R , C , V1 > cell ) { return immutableCell ( cell . getRowKey ( ) , cell . getColumnKey ( ) , function . apply ( cell . getValue ( ) ) ) ; } } ; } @Override Iterator < Cell < R , C , V2 > > cellIterator ( ) { return Iterators . transform ( fromTable . cellSet ( ) . iterator ( ) , cellFunction ( ) ) ; } @Override public Set < R > rowKeySet ( ) { return fromTable . rowKeySet ( ) ; } @Override public Set < C > columnKeySet ( ) { return fromTable . columnKeySet ( ) ; } @Override Collection < V2 > createValues ( ) { return Collections2 . transform ( fromTable . values ( ) , function ) ; } @Override public Map < R , Map < C , V2 > > rowMap ( ) { Function < Map < C , V1 > , Map < C , V2 > > rowFunction = new Function < Map < C , V1 > , Map < C , V2 > > ( ) { @Override public Map < C , V2 > apply ( Map < C , V1 > row ) { return Maps . transformValues ( row , function ) ; } } ; return Maps . transformValues ( fromTable . rowMap ( ) , rowFunction ) ; } @Override public Map < C , Map < R , V2 > > columnMap ( ) { Function < Map < R , V1 > , Map < R , V2 > > columnFunction = new Function < Map < R , V1 > , Map < R , V2 > > ( ) { @Override public Map < R , V2 > apply ( Map < R , V1 > column ) { return Maps . transformValues ( column , function ) ; } } ; return Maps . transformValues ( fromTable . columnMap ( ) , columnFunction ) ; } } public static < R , C , V > Table < R , C , V > unmodifiableTable ( Table < ? extends R , ? extends C , ? extends V > table ) { return new UnmodifiableTable < R , C , V > ( table ) ; } private static class UnmodifiableTable < R , C , V > extends ForwardingTable < R , C , V > implements Serializable { final Table < ? extends R , ? extends C , ? extends V > delegate ; UnmodifiableTable ( Table < ? extends R , ? extends C , ? extends V > delegate ) { this . delegate = checkNotNull ( delegate ) ; } @SuppressWarnings ( <str> ) @Override protected Table < R , C , V > delegate ( ) { return ( Table < R , C , V > ) delegate ; } @Override public Set < Cell < R , C , V > > cellSet ( ) { return Collections . unmodifiableSet ( super . cellSet ( ) ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Map < R , V > column ( @Nullable C columnKey ) { return Collections . unmodifiableMap ( super . column ( columnKey ) ) ; } @Override public Set < C > columnKeySet ( ) { return Collections . unmodifiableSet ( super . columnKeySet ( ) ) ; } @Override public Map < C , Map < R , V > > columnMap ( ) { Function < Map < R , V > , Map < R , V > > wrapper = unmodifiableWrapper ( ) ; return Collections . unmodifiableMap ( Maps . transformValues ( super . columnMap ( ) , wrapper ) ) ; } @Override public V put ( @Nullable R rowKey , @Nullable C columnKey , @Nullable V value ) { throw new UnsupportedOperationException ( ) ; } @Override public void putAll ( Table < ? extends R , ? extends C , ? extends V > table ) { throw new UnsupportedOperationException ( ) ; } @Override public V remove ( @Nullable Object rowKey , @Nullable Object columnKey ) { throw new UnsupportedOperationException ( ) ; } @Override public Map < C , V > row ( @Nullable R rowKey ) { return Collections . unmodifiableMap ( super . row ( rowKey ) ) ; } @Override public Set < R > rowKeySet ( ) { return Collections . unmodifiableSet ( super . rowKeySet ( ) ) ; } @Override public Map < R , Map < C , V > > rowMap ( ) { Function < Map < C , V > , Map < C , V > > wrapper = unmodifiableWrapper ( ) ; return Collections . unmodifiableMap ( Maps . transformValues ( super . rowMap ( ) , wrapper ) ) ; } @Override public Collection < V > values ( ) { return Collections . unmodifiableCollection ( super . values ( ) ) ; } private static final long serialVersionUID = <int> ; } @Beta public static < R , C , V > RowSortedTable < R , C , V > unmodifiableRowSortedTable ( RowSortedTable < R , ? extends C , ? extends V > table ) { return new UnmodifiableRowSortedMap < R , C , V > ( table ) ; } static final class UnmodifiableRowSortedMap < R , C , V > extends UnmodifiableTable < R , C , V > implements RowSortedTable < R , C , V > { public UnmodifiableRowSortedMap ( RowSortedTable < R , ? extends C , ? extends V > delegate ) { super ( delegate ) ; } @Override protected RowSortedTable < R , C , V > delegate ( ) { return ( RowSortedTable < R , C , V > ) super . delegate ( ) ; } @Override public SortedMap < R , Map < C , V > > rowMap ( ) { Function < Map < C , V > , Map < C , V > > wrapper = unmodifiableWrapper ( ) ; return Collections . unmodifiableSortedMap ( Maps . transformValues ( delegate ( ) . rowMap ( ) , wrapper ) ) ; } @Override public SortedSet < R > rowKeySet ( ) { return Collections . unmodifiableSortedSet ( delegate ( ) . rowKeySet ( ) ) ; } private static final long serialVersionUID = <int> ; } @SuppressWarnings ( <str> ) private static < K , V > Function < Map < K , V > , Map < K , V > > unmodifiableWrapper ( ) { return ( Function ) UNMODIFIABLE_WRAPPER ; } private static final Function < ? extends Map < ? , ? > , ? extends Map < ? , ? > > UNMODIFIABLE_WRAPPER = new Function < Map < Object , Object > , Map < Object , Object > > ( ) { @Override public Map < Object , Object > apply ( Map < Object , Object > input ) { return Collections . unmodifiableMap ( input ) ; } } ; static boolean equalsImpl ( Table < ? , ? , ? > table , @Nullable Object obj ) { if ( obj = = table ) { return true ; } else if ( obj instanceof Table ) { Table < ? , ? , ? > that = ( Table < ? , ? , ? > ) obj ; return table . cellSet ( ) . equals ( that . cellSet ( ) ) ; } else { return false ; } } } 
