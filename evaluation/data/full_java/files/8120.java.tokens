package org . elasticsearch . index . fielddata ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . search . aggregations . Aggregations ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; public class FieldDataFilterIntegrationIT extends ESIntegTestCase { @Override protected int numberOfReplicas ( ) { return <int> ; } public void testRegexpFilter ( ) throws IOException { CreateIndexRequestBuilder builder = prepareCreate ( <str> ) ; XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( builder . addMapping ( <str> , mapping ) ) ; ensureGreen ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + <int> ) . setSource ( <str> , <str> , <str> , <str> ) . get ( ) ; } refresh ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( terms ( <str> ) . field ( <str> ) ) . addAggregation ( terms ( <str> ) . field ( <str> ) ) . get ( ) ; Aggregations aggs = searchResponse . getAggregations ( ) ; Terms nameAgg = aggs . get ( <str> ) ; assertThat ( nameAgg . getBuckets ( ) . size ( ) , Matchers . equalTo ( <int> ) ) ; assertThat ( nameAgg . getBuckets ( ) . iterator ( ) . next ( ) . getKeyAsString ( ) , Matchers . equalTo ( <str> ) ) ; Terms notFilteredAgg = aggs . get ( <str> ) ; assertThat ( notFilteredAgg . getBuckets ( ) . size ( ) , Matchers . equalTo ( <int> ) ) ; assertThat ( notFilteredAgg . getBuckets ( ) . get ( <int> ) . getKeyAsString ( ) , Matchers . isOneOf ( <str> , <str> ) ) ; assertThat ( notFilteredAgg . getBuckets ( ) . get ( <int> ) . getKeyAsString ( ) , Matchers . isOneOf ( <str> , <str> ) ) ; } } 
