package io . netty . util ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotEquals ; import io . netty . util . ByteProcessor . IndexOfProcessor ; import java . util . Random ; import java . util . concurrent . atomic . AtomicReference ; import org . junit . Before ; import org . junit . Test ; public class AsciiStringMemoryTest { private byte [ ] a ; private byte [ ] b ; private int aOffset = <int> ; private int bOffset = <int> ; private int length = <int> ; private AsciiString aAsciiString ; private AsciiString bAsciiString ; private Random r = new Random ( ) ; @Before public void setup ( ) { a = new byte [ <int> ] ; b = new byte [ <int> ] ; r . nextBytes ( a ) ; r . nextBytes ( b ) ; aOffset = <int> ; bOffset = <int> ; length = <int> ; System . arraycopy ( a , aOffset , b , bOffset , length ) ; aAsciiString = new AsciiString ( a , aOffset , length , false ) ; bAsciiString = new AsciiString ( b , bOffset , length , false ) ; } @Test public void testSharedMemory ( ) { + + a [ aOffset ] ; AsciiString aAsciiString1 = new AsciiString ( a , aOffset , length , true ) ; AsciiString aAsciiString2 = new AsciiString ( a , aOffset , length , false ) ; assertEquals ( aAsciiString , aAsciiString1 ) ; assertEquals ( aAsciiString , aAsciiString2 ) ; for ( int i = aOffset ; i < length ; + + i ) { assertEquals ( a [ i ] , aAsciiString . byteAt ( i - aOffset ) ) ; } } @Test public void testNotSharedMemory ( ) { AsciiString aAsciiString1 = new AsciiString ( a , aOffset , length , true ) ; + + a [ aOffset ] ; assertNotEquals ( aAsciiString , aAsciiString1 ) ; int i = aOffset ; assertNotEquals ( a [ i ] , aAsciiString1 . byteAt ( i - aOffset ) ) ; + + i ; for ( ; i < length ; + + i ) { assertEquals ( a [ i ] , aAsciiString1 . byteAt ( i - aOffset ) ) ; } } @Test public void forEachTest ( ) throws Exception { final AtomicReference < Integer > aCount = new AtomicReference < Integer > ( <int> ) ; final AtomicReference < Integer > bCount = new AtomicReference < Integer > ( <int> ) ; aAsciiString . forEachByte ( new ByteProcessor ( ) { int i ; @Override public boolean process ( byte value ) throws Exception { assertEquals ( <str> + i , value , bAsciiString . byteAt ( i + + ) ) ; aCount . set ( aCount . get ( ) + <int> ) ; return true ; } } ) ; bAsciiString . forEachByte ( new ByteProcessor ( ) { int i ; @Override public boolean process ( byte value ) throws Exception { assertEquals ( <str> + i , value , aAsciiString . byteAt ( i + + ) ) ; bCount . set ( bCount . get ( ) + <int> ) ; return true ; } } ) ; assertEquals ( aAsciiString . length ( ) , aCount . get ( ) . intValue ( ) ) ; assertEquals ( bAsciiString . length ( ) , bCount . get ( ) . intValue ( ) ) ; } @Test public void forEachWithIndexEndTest ( ) throws Exception { assertNotEquals ( - <int> , aAsciiString . forEachByte ( aAsciiString . length ( ) - <int> , <int> , new IndexOfProcessor ( aAsciiString . byteAt ( aAsciiString . length ( ) - <int> ) ) ) ) ; } @Test public void forEachWithIndexBeginTest ( ) throws Exception { assertNotEquals ( - <int> , aAsciiString . forEachByte ( <int> , <int> , new IndexOfProcessor ( aAsciiString . byteAt ( <int> ) ) ) ) ; } @Test public void forEachDescTest ( ) throws Exception { final AtomicReference < Integer > aCount = new AtomicReference < Integer > ( <int> ) ; final AtomicReference < Integer > bCount = new AtomicReference < Integer > ( <int> ) ; aAsciiString . forEachByteDesc ( new ByteProcessor ( ) { int i = <int> ; @Override public boolean process ( byte value ) throws Exception { assertEquals ( <str> + i , value , bAsciiString . byteAt ( bAsciiString . length ( ) - ( i + + ) ) ) ; aCount . set ( aCount . get ( ) + <int> ) ; return true ; } } ) ; bAsciiString . forEachByteDesc ( new ByteProcessor ( ) { int i = <int> ; @Override public boolean process ( byte value ) throws Exception { assertEquals ( <str> + i , value , aAsciiString . byteAt ( aAsciiString . length ( ) - ( i + + ) ) ) ; bCount . set ( bCount . get ( ) + <int> ) ; return true ; } } ) ; assertEquals ( aAsciiString . length ( ) , aCount . get ( ) . intValue ( ) ) ; assertEquals ( bAsciiString . length ( ) , bCount . get ( ) . intValue ( ) ) ; } @Test public void forEachDescWithIndexEndTest ( ) throws Exception { assertNotEquals ( - <int> , bAsciiString . forEachByteDesc ( bAsciiString . length ( ) - <int> , <int> , new IndexOfProcessor ( bAsciiString . byteAt ( bAsciiString . length ( ) - <int> ) ) ) ) ; } @Test public void forEachDescWithIndexBeginTest ( ) throws Exception { assertNotEquals ( - <int> , bAsciiString . forEachByteDesc ( <int> , <int> , new IndexOfProcessor ( bAsciiString . byteAt ( <int> ) ) ) ) ; } @Test public void subSequenceTest ( ) { final int start = <int> ; final int end = aAsciiString . length ( ) ; AsciiString aSubSequence = aAsciiString . subSequence ( start , end , false ) ; AsciiString bSubSequence = bAsciiString . subSequence ( start , end , true ) ; assertEquals ( aSubSequence , bSubSequence ) ; assertEquals ( aSubSequence . hashCode ( ) , bSubSequence . hashCode ( ) ) ; } @Test public void copyTest ( ) { byte [ ] aCopy = new byte [ aAsciiString . length ( ) ] ; aAsciiString . copy ( <int> , aCopy , <int> , aCopy . length ) ; AsciiString aAsciiStringCopy = new AsciiString ( aCopy , false ) ; assertEquals ( aAsciiString , aAsciiStringCopy ) ; } } 
