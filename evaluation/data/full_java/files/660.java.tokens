package org . apache . cassandra . index . internal . keys ; import java . nio . ByteBuffer ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . DataLimits ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . CassandraIndexSearcher ; import org . apache . cassandra . utils . concurrent . OpOrder ; public class KeysSearcher extends CassandraIndexSearcher { private static final Logger logger = LoggerFactory . getLogger ( KeysSearcher . class ) ; public KeysSearcher ( ReadCommand command , RowFilter . Expression expression , CassandraIndex indexer ) { super ( command , expression , indexer ) ; } protected UnfilteredPartitionIterator queryDataFromIndex ( final DecoratedKey indexKey , final RowIterator indexHits , final ReadCommand command , final ReadExecutionController executionController ) { assert indexHits . staticRow ( ) = = Rows . EMPTY_STATIC_ROW ; return new UnfilteredPartitionIterator ( ) { private UnfilteredRowIterator next ; public boolean isForThrift ( ) { return command . isForThrift ( ) ; } public CFMetaData metadata ( ) { return command . metadata ( ) ; } public boolean hasNext ( ) { return prepareNext ( ) ; } public UnfilteredRowIterator next ( ) { if ( next = = null ) prepareNext ( ) ; UnfilteredRowIterator toReturn = next ; next = null ; return toReturn ; } private boolean prepareNext ( ) { while ( next = = null & & indexHits . hasNext ( ) ) { Row hit = indexHits . next ( ) ; DecoratedKey key = index . baseCfs . decorateKey ( hit . clustering ( ) . get ( <int> ) ) ; SinglePartitionReadCommand dataCmd = SinglePartitionReadCommand . create ( isForThrift ( ) , index . baseCfs . metadata , command . nowInSec ( ) , command . columnFilter ( ) , command . rowFilter ( ) , DataLimits . NONE , key , command . clusteringIndexFilter ( key ) ) ; @SuppressWarnings ( <str> ) UnfilteredRowIterator dataIter = filterIfStale ( dataCmd . queryMemtableAndDisk ( index . baseCfs , executionController . baseReadOpOrderGroup ( ) ) , hit , indexKey . getKey ( ) , executionController . writeOpOrderGroup ( ) , isForThrift ( ) , command . nowInSec ( ) ) ; if ( dataIter ! = null ) { if ( dataIter . isEmpty ( ) ) dataIter . close ( ) ; else next = dataIter ; } } return next ! = null ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public void close ( ) { indexHits . close ( ) ; if ( next ! = null ) next . close ( ) ; } } ; } private UnfilteredRowIterator filterIfStale ( UnfilteredRowIterator iterator , Row indexHit , ByteBuffer indexedValue , OpOrder . Group writeOp , boolean isForThrift , int nowInSec ) { if ( isForThrift ) { ImmutableBTreePartition result = ImmutableBTreePartition . create ( iterator ) ; iterator . close ( ) ; Row data = result . getRow ( new Clustering ( index . getIndexedColumn ( ) . name . bytes ) ) ; Cell baseData = data . getCell ( index . baseCfs . metadata . compactValueColumn ( ) ) ; if ( baseData = = null | | ! baseData . isLive ( nowInSec ) | | index . getIndexedColumn ( ) . type . compare ( indexedValue , baseData . value ( ) ) ! = <int> ) { index . deleteStaleEntry ( index . getIndexCfs ( ) . decorateKey ( indexedValue ) , new Clustering ( index . getIndexedColumn ( ) . name . bytes ) , new DeletionTime ( indexHit . primaryKeyLivenessInfo ( ) . timestamp ( ) , nowInSec ) , writeOp ) ; return null ; } else { return result . unfilteredIterator ( ) ; } } else { assert iterator . metadata ( ) . isCompactTable ( ) ; Row data = iterator . staticRow ( ) ; if ( index . isStale ( data , indexedValue , nowInSec ) ) { index . deleteStaleEntry ( index . getIndexCfs ( ) . decorateKey ( indexedValue ) , makeIndexClustering ( iterator . partitionKey ( ) . getKey ( ) , Clustering . EMPTY ) , new DeletionTime ( indexHit . primaryKeyLivenessInfo ( ) . timestamp ( ) , nowInSec ) , writeOp ) ; iterator . close ( ) ; return null ; } else { return iterator ; } } } } 
