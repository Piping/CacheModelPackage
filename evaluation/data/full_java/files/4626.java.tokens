package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . DebugUIMessages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . memory . IMemoryRenderingUpdater ; import org . eclipse . debug . internal . ui . preferences . IDebugPreferenceConstants ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . memory . AbstractTableRendering ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; public class TableRenderingContentProvider extends BasicDebugViewContentProvider { protected Vector < TableRenderingLine > lineCache ; protected Hashtable < String , TableRenderingLine > contentCache ; private MemoryByte [ ] fContentCacheInBytes ; private String fContentCacheStartAddress ; private BigInteger fBufferTopAddress ; private TableRenderingContentInput fInput ; private BigInteger fBufferEndAddress ; private boolean fDynamicLoad ; public TableRenderingContentProvider ( ) { lineCache = new Vector < TableRenderingLine > ( ) ; contentCache = new Hashtable < String , TableRenderingLine > ( ) ; initializeDynamicLoad ( ) ; DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; } public void setViewer ( StructuredViewer viewer ) { fViewer = viewer ; } @Override public void inputChanged ( Viewer v , Object oldInput , Object newInput ) { try { if ( newInput instanceof TableRenderingContentInput ) { fInput = ( TableRenderingContentInput ) newInput ; if ( fInput . getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { loadContentForExtendedMemoryBlock ( ) ; } else { loadContentForSimpleMemoryBlock ( ) ; } getTableRendering ( fInput ) . displayTable ( ) ; } } catch ( DebugException e ) { getTableRendering ( fInput ) . displayError ( e ) ; } } @Override public void dispose ( ) { DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; super . dispose ( ) ; } @Override public Object [ ] getElements ( Object parent ) { if ( lineCache . isEmpty ( ) ) { try { getMemoryFromMemoryBlock ( ) ; } catch ( DebugException e ) { DebugUIPlugin . log ( e . getStatus ( ) ) ; getTableRendering ( fInput ) . displayError ( e ) ; return lineCache . toArray ( ) ; } } if ( lineCache . isEmpty ( ) ) { return lineCache . toArray ( ) ; } TableRenderingLine line = lineCache . get ( <int> ) ; int currentRowSize = line . getByteArray ( ) . length ; int renderingRowSize = getTableRendering ( fInput ) . getBytesPerLine ( ) ; if ( renderingRowSize ! = currentRowSize ) { try { reorganizeContentCache ( renderingRowSize ) ; reorganizeLines ( lineCache , renderingRowSize ) ; } catch ( DebugException e ) { DebugUIPlugin . log ( e . getStatus ( ) ) ; getTableRendering ( fInput ) . displayError ( e ) ; return lineCache . toArray ( ) ; } } return lineCache . toArray ( ) ; } private void getMemoryFromMemoryBlock ( ) throws DebugException { IMemoryBlock memoryBlock = fInput . getMemoryBlock ( ) ; if ( memoryBlock instanceof IMemoryBlockExtension ) { loadContentForExtendedMemoryBlock ( ) ; getTableRendering ( fInput ) . displayTable ( ) ; } else { loadContentForSimpleMemoryBlock ( ) ; getTableRendering ( fInput ) . displayTable ( ) ; } } public void loadContentForSimpleMemoryBlock ( ) throws DebugException { fInput . setPreBuffer ( <int> ) ; fInput . setPostBuffer ( <int> ) ; long startAddress = fInput . getMemoryBlock ( ) . getStartAddress ( ) ; BigInteger address = BigInteger . valueOf ( startAddress ) ; long length = fInput . getMemoryBlock ( ) . getLength ( ) ; long numLines = length / getTableRendering ( fInput ) . getBytesPerLine ( ) ; getMemoryToFitTable ( address , numLines , fInput . isUpdateDelta ( ) ) ; } public void loadContentForExtendedMemoryBlock ( ) throws DebugException { if ( fInput . getNumLines ( ) < = <int> ) { return ; } BigInteger loadAddress = fInput . getLoadAddress ( ) ; if ( loadAddress = = null ) { loadAddress = new BigInteger ( <str> ) ; } BigInteger mbStart = fInput . getStartAddress ( ) ; BigInteger mbEnd = fInput . getEndAddress ( ) ; if ( loadAddress . compareTo ( mbStart ) < <int> | | loadAddress . compareTo ( mbEnd ) > <int> ) { loadAddress = ( ( IMemoryBlockExtension ) getMemoryBlock ( ) ) . getBigBaseAddress ( ) ; fInput . setLoadAddress ( loadAddress ) ; } if ( loadAddress . compareTo ( mbStart ) < <int> | | loadAddress . compareTo ( mbEnd ) > <int> ) { throw new DebugException ( DebugUIPlugin . newErrorStatus ( DebugUIMessages . TableRenderingContentProvider_0 + loadAddress . toString ( <int> ) , null ) ) ; } int addressableUnitsPerLine = getTableRendering ( fInput ) . getAddressableUnitPerLine ( ) ; BigInteger bufferStart = loadAddress . subtract ( BigInteger . valueOf ( fInput . getPreBuffer ( ) * addressableUnitsPerLine ) ) ; BigInteger bufferEnd = loadAddress . add ( BigInteger . valueOf ( fInput . getPostBuffer ( ) * addressableUnitsPerLine ) ) ; bufferEnd = bufferEnd . add ( BigInteger . valueOf ( fInput . getNumLines ( ) * addressableUnitsPerLine ) ) ; if ( isDynamicLoad ( ) ) { if ( bufferStart . compareTo ( mbStart ) < <int> ) { bufferStart = mbStart ; } if ( bufferEnd . compareTo ( mbEnd ) > <int> ) { bufferEnd = mbEnd ; int numLines = bufferEnd . subtract ( bufferStart ) . divide ( BigInteger . valueOf ( addressableUnitsPerLine ) ) . intValue ( ) ; if ( numLines < fInput . getNumLines ( ) ) { bufferStart = bufferEnd . subtract ( BigInteger . valueOf ( fInput . getNumLines ( ) * addressableUnitsPerLine ) ) ; bufferStart = bufferStart . subtract ( BigInteger . valueOf ( fInput . getPreBuffer ( ) * addressableUnitsPerLine ) ) ; } if ( bufferStart . compareTo ( mbStart ) < <int> ) { bufferStart = mbStart ; } } if ( bufferEnd . compareTo ( bufferStart ) < = <int> ) { throw new DebugException ( DebugUIPlugin . newErrorStatus ( DebugUIMessages . TableRenderingContentProvider_1 , null ) ) ; } int numLines = bufferEnd . subtract ( bufferStart ) . divide ( BigInteger . valueOf ( addressableUnitsPerLine ) ) . intValue ( ) + <int> ; getMemoryToFitTable ( bufferStart , numLines , fInput . isUpdateDelta ( ) ) ; } else { if ( bufferStart . compareTo ( mbStart ) < <int> ) { bufferStart = mbStart ; } if ( bufferEnd . compareTo ( mbEnd ) > <int> ) { bufferStart = mbEnd . subtract ( BigInteger . valueOf ( ( fInput . getNumLines ( ) - <int> ) * addressableUnitsPerLine ) ) ; bufferEnd = mbEnd ; if ( bufferStart . compareTo ( mbStart ) < <int> ) { bufferStart = mbStart ; } } if ( bufferEnd . compareTo ( bufferStart ) < = <int> ) { throw new DebugException ( DebugUIPlugin . newErrorStatus ( DebugUIMessages . TableRenderingContentProvider_2 , null ) ) ; } int numLines = fInput . getNumLines ( ) ; int bufferNumLines = bufferEnd . subtract ( bufferStart ) . divide ( BigInteger . valueOf ( addressableUnitsPerLine ) ) . intValue ( ) + <int> ; if ( bufferNumLines < numLines ) { numLines = bufferNumLines ; } getMemoryToFitTable ( bufferStart , numLines , fInput . isUpdateDelta ( ) ) ; } } public IMemoryBlock getMemoryBlock ( ) { return fInput . getMemoryBlock ( ) ; } public void getMemoryToFitTable ( BigInteger startingAddress , long numberOfLines , boolean updateDelta ) throws DebugException { IDebugTarget target = fInput . getMemoryBlock ( ) . getDebugTarget ( ) ; if ( target . isDisconnected ( ) | | target . isTerminated ( ) ) { return ; } DebugException dbgEvt = null ; String adjustedAddress = startingAddress . toString ( <int> ) ; int addressSize ; try { addressSize = getAddressSize ( startingAddress ) ; } catch ( DebugException e1 ) { dbgEvt = e1 ; addressSize = <int> ; } int addressLength = addressSize * IInternalDebugUIConstants . CHAR_PER_BYTE ; if ( getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { startingAddress = MemoryViewUtil . alignToBoundary ( startingAddress , getTableRendering ( fInput ) . getAddressableUnitPerLine ( ) ) ; } IMemoryBlockExtension extMemoryBlock = null ; MemoryByte [ ] memoryBuffer = null ; String paddedString = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; long reqNumBytes = <int> ; try { if ( fInput . getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { reqNumBytes = getTableRendering ( fInput ) . getBytesPerLine ( ) * numberOfLines ; extMemoryBlock = ( IMemoryBlockExtension ) fInput . getMemoryBlock ( ) ; long reqNumberOfUnits = getTableRendering ( fInput ) . getAddressableUnitPerLine ( ) * numberOfLines ; memoryBuffer = extMemoryBlock . getBytesFromAddress ( startingAddress , reqNumberOfUnits ) ; if ( memoryBuffer = = null ) { DebugException e = new DebugException ( DebugUIPlugin . newErrorStatus ( DebugUIMessages . MemoryViewContentProvider_Unable_to_retrieve_content , null ) ) ; throw e ; } } else { byte [ ] memory = fInput . getMemoryBlock ( ) . getBytes ( ) ; if ( memory = = null ) { DebugException e = new DebugException ( DebugUIPlugin . newErrorStatus ( DebugUIMessages . MemoryViewContentProvider_Unable_to_retrieve_content , null ) ) ; throw e ; } int prefillNumBytes = <int> ; if ( ! startingAddress . toString ( <int> ) . endsWith ( <str> ) ) { adjustedAddress = startingAddress . toString ( <int> ) . substring ( <int> , adjustedAddress . length ( ) - <int> ) ; adjustedAddress + = <str> ; BigInteger adjustedStart = new BigInteger ( adjustedAddress , <int> ) ; prefillNumBytes = startingAddress . subtract ( adjustedStart ) . intValue ( ) ; startingAddress = adjustedStart ; } reqNumBytes = fInput . getMemoryBlock ( ) . getLength ( ) + prefillNumBytes ; while ( reqNumBytes % getTableRendering ( fInput ) . getBytesPerLine ( ) ! = <int> ) { reqNumBytes + + ; } numberOfLines = reqNumBytes / getTableRendering ( fInput ) . getBytesPerLine ( ) ; memoryBuffer = new MemoryByte [ ( int ) reqNumBytes ] ; for ( int i = <int> ; i < prefillNumBytes ; i + + ) { MemoryByte tmp = new MemoryByte ( ) ; tmp . setValue ( ( byte ) <int> ) ; tmp . setWritable ( false ) ; tmp . setReadable ( false ) ; tmp . setEndianessKnown ( false ) ; memoryBuffer [ i ] = tmp ; } int j = prefillNumBytes ; for ( int i = <int> ; i < memory . length ; i + + ) { MemoryByte tmp = new MemoryByte ( ) ; tmp . setValue ( memory [ i ] ) ; tmp . setReadable ( true ) ; tmp . setWritable ( true ) ; tmp . setEndianessKnown ( false ) ; memoryBuffer [ j ] = tmp ; j + + ; } for ( int i = j ; i < memoryBuffer . length ; i + + ) { MemoryByte tmp = new MemoryByte ( ) ; tmp . setValue ( ( byte ) <int> ) ; tmp . setWritable ( false ) ; tmp . setReadable ( false ) ; tmp . setEndianessKnown ( false ) ; memoryBuffer [ i ] = tmp ; } } } catch ( DebugException e ) { memoryBuffer = makeDummyContent ( numberOfLines ) ; dbgEvt = e ; } catch ( Throwable e ) { memoryBuffer = makeDummyContent ( numberOfLines ) ; dbgEvt = new DebugException ( DebugUIPlugin . newErrorStatus ( e . getMessage ( ) , e ) ) ; } if ( memoryBuffer . length < reqNumBytes ) { ArrayList < MemoryByte > newBuffer = new ArrayList < MemoryByte > ( ) ; for ( int i = <int> ; i < memoryBuffer . length ; i + + ) { newBuffer . add ( memoryBuffer [ i ] ) ; } for ( int i = memoryBuffer . length ; i < reqNumBytes ; i + + ) { MemoryByte mb = new MemoryByte ( ) ; mb . setReadable ( false ) ; mb . setWritable ( false ) ; mb . setEndianessKnown ( false ) ; newBuffer . add ( mb ) ; } memoryBuffer = newBuffer . toArray ( new MemoryByte [ newBuffer . size ( ) ] ) ; } if ( ! lineCache . isEmpty ( ) ) { lineCache . clear ( ) ; } String address = startingAddress . toString ( <int> ) ; fBufferTopAddress = startingAddress ; boolean manageDelta = true ; if ( fInput . getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { manageDelta = ! ( ( IMemoryBlockExtension ) fInput . getMemoryBlock ( ) ) . supportsChangeManagement ( ) ; } organizeLines ( numberOfLines , updateDelta , addressLength , memoryBuffer , paddedString , address , manageDelta ) ; if ( dbgEvt ! = null ) { throw dbgEvt ; } } private void organizeLines ( long numberOfLines , boolean updateDelta , int addressLength , MemoryByte [ ] memoryBuffer , String paddedString , String address , boolean manageDelta ) { for ( int i = <int> ; i < numberOfLines ; i + + ) { String tmpAddress = address . toUpperCase ( ) ; if ( tmpAddress . length ( ) < addressLength ) { while ( tmpAddress . length ( ) < addressLength ) { tmpAddress = <str> + tmpAddress ; } } int bytesPerLine = getTableRendering ( fInput ) . getBytesPerLine ( ) ; MemoryByte [ ] memory = new MemoryByte [ bytesPerLine ] ; boolean isMonitored = true ; int k = <int> ; for ( int j = i * bytesPerLine ; j < i * bytesPerLine + bytesPerLine ; j + + ) { byte changeFlag = memoryBuffer [ j ] . getFlags ( ) ; if ( manageDelta ) { changeFlag | = MemoryByte . HISTORY_KNOWN ; changeFlag ^ = MemoryByte . HISTORY_KNOWN ; changeFlag | = MemoryByte . CHANGED ; changeFlag ^ = MemoryByte . CHANGED ; } MemoryByte newByteObj = new MemoryByte ( memoryBuffer [ j ] . getValue ( ) , changeFlag ) ; memory [ k ] = newByteObj ; k + + ; if ( ! manageDelta ) { if ( ! memoryBuffer [ j ] . isHistoryKnown ( ) ) { isMonitored = false ; } } } TableRenderingLine newLine = new TableRenderingLine ( tmpAddress , memory , lineCache . size ( ) , paddedString ) ; TableRenderingLine oldLine = contentCache . get ( newLine . getAddress ( ) ) ; if ( manageDelta ) { if ( oldLine ! = null ) { newLine . isMonitored = true ; } else { newLine . isMonitored = false ; } } else { newLine . isMonitored = isMonitored ; } if ( manageDelta & & ! getTableRendering ( fInput ) . isDisplayingError ( ) ) { if ( updateDelta ) { if ( oldLine ! = null ) { newLine . markDeltas ( oldLine ) ; } } else { if ( oldLine ! = null ) { if ( newLine . isLineChanged ( oldLine ) ) { newLine . markDeltas ( oldLine ) ; } else { newLine . copyDeltas ( oldLine ) ; } } } } else if ( manageDelta & & getTableRendering ( fInput ) . isDisplayingError ( ) ) { newLine . isMonitored = false ; } lineCache . add ( newLine ) ; BigInteger bigInt = new BigInteger ( address , <int> ) ; fBufferEndAddress = bigInt ; int addressableUnit = getTableRendering ( fInput ) . getBytesPerLine ( ) / getTableRendering ( fInput ) . getAddressableSize ( ) ; address = bigInt . add ( BigInteger . valueOf ( addressableUnit ) ) . toString ( <int> ) ; } } private MemoryByte [ ] makeDummyContent ( long numberOfLines ) { MemoryByte [ ] memoryBuffer ; int numBytes = ( int ) ( getTableRendering ( fInput ) . getBytesPerLine ( ) * numberOfLines ) ; memoryBuffer = new MemoryByte [ numBytes ] ; for ( int i = <int> ; i < memoryBuffer . length ; i + + ) { memoryBuffer [ i ] = new MemoryByte ( ) ; memoryBuffer [ i ] . setValue ( ( byte ) <int> ) ; memoryBuffer [ i ] . setWritable ( false ) ; memoryBuffer [ i ] . setReadable ( false ) ; memoryBuffer [ i ] . setEndianessKnown ( false ) ; } return memoryBuffer ; } @Override protected void doHandleDebugEvent ( DebugEvent event ) { if ( getTableRendering ( fInput ) . isVisible ( ) ) { if ( isUpdateManagedByMB ( ) ) { return ; } } if ( ! ( event . getSource ( ) instanceof IDebugElement ) ) { return ; } if ( fInput = = null ) { return ; } IDebugElement src = ( IDebugElement ) event . getSource ( ) ; if ( event . getKind ( ) = = DebugEvent . CHANGE & & event . getSource ( ) = = fInput . getMemoryBlock ( ) ) { if ( event . getDetail ( ) = = DebugEvent . STATE ) { getTableRendering ( fInput ) . updateLabels ( ) ; } else { updateContent ( ) ; } } if ( event . getKind ( ) = = DebugEvent . SUSPEND & & src . getDebugTarget ( ) = = fInput . getMemoryBlock ( ) . getDebugTarget ( ) ) { updateContent ( ) ; } } public void updateContent ( ) { IDebugTarget dt = fInput . getMemoryBlock ( ) . getDebugTarget ( ) ; if ( dt . isDisconnected ( ) | | dt . isTerminated ( ) ) { return ; } takeContentSnapshot ( ) ; if ( ! getTableRendering ( fInput ) . isVisible ( ) ) { return ; } getTableRendering ( fInput ) . refresh ( ) ; } public void takeContentSnapshot ( ) { TableRenderingLine [ ] lines = lineCache . toArray ( new TableRenderingLine [ lineCache . size ( ) ] ) ; fContentCacheInBytes = convertLinesToBytes ( lines ) ; fContentCacheStartAddress = lines [ <int> ] . getAddress ( ) ; if ( contentCache ! = null ) { contentCache . clear ( ) ; } if ( ! getTableRendering ( fInput ) . isVisible ( ) ) { return ; } if ( ! getTableRendering ( fInput ) . isDisplayingError ( ) ) { for ( int i = <int> ; i < lines . length ; i + + ) { contentCache . put ( lines [ i ] . getAddress ( ) , lines [ i ] ) ; lines [ i ] . isMonitored = true ; } } resetDeltas ( ) ; } public BigInteger getBufferTopAddress ( ) { return fBufferTopAddress ; } public BigInteger getBufferEndAddress ( ) { return fBufferEndAddress ; } public int getAddressSize ( BigInteger address ) throws DebugException { String adjustedAddress = address . toString ( <int> ) ; int addressSize = <int> ; if ( fInput . getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { addressSize = ( ( IMemoryBlockExtension ) fInput . getMemoryBlock ( ) ) . getAddressSize ( ) ; } if ( addressSize < = <int> ) { if ( adjustedAddress . length ( ) > <int> ) { addressSize = <int> ; } else { addressSize = <int> ; } } return addressSize ; } public BigInteger getContentBaseAddress ( ) { return fInput . getContentBaseAddress ( ) ; } public void resetDeltas ( ) { Enumeration < TableRenderingLine > enumeration = contentCache . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { TableRenderingLine line = enumeration . nextElement ( ) ; line . unmarkDeltas ( ) ; } } public boolean isAddressOutOfRange ( BigInteger address ) { if ( lineCache ! = null & & ! lineCache . isEmpty ( ) ) { TableRenderingLine first = lineCache . firstElement ( ) ; TableRenderingLine last = lineCache . lastElement ( ) ; if ( first = = null | | last = = null ) { return true ; } BigInteger startAddress = new BigInteger ( first . getAddress ( ) , <int> ) ; BigInteger lastAddress = new BigInteger ( last . getAddress ( ) , <int> ) ; int addressableUnit = getTableRendering ( fInput ) . getAddressableUnitPerLine ( ) ; lastAddress = lastAddress . add ( BigInteger . valueOf ( addressableUnit ) ) . subtract ( BigInteger . valueOf ( <int> ) ) ; if ( startAddress . compareTo ( address ) < = <int> & & lastAddress . compareTo ( address ) > = <int> ) { return false ; } return true ; } return true ; } public void clearContentCache ( ) { fContentCacheInBytes = new MemoryByte [ <int> ] ; fContentCacheStartAddress = null ; contentCache . clear ( ) ; } private boolean isUpdateManagedByMB ( ) { IMemoryBlock memoryBlock = getMemoryBlock ( ) ; IMemoryRenderingUpdater managedMB = null ; if ( memoryBlock instanceof IMemoryRenderingUpdater ) { managedMB = ( IMemoryRenderingUpdater ) memoryBlock ; } if ( managedMB = = null ) { managedMB = memoryBlock . getAdapter ( IMemoryRenderingUpdater . class ) ; } if ( managedMB ! = null & & managedMB . supportsManagedUpdate ( getTableRendering ( fInput ) ) ) { return true ; } return false ; } public boolean isDynamicLoad ( ) { return fDynamicLoad ; } private void initializeDynamicLoad ( ) { fDynamicLoad = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugPreferenceConstants . PREF_DYNAMIC_LOAD_MEM ) ; } public void setDynamicLoad ( boolean dynamicLoad ) { fDynamicLoad = dynamicLoad ; } private void reorganizeLines ( Vector < TableRenderingLine > lines , int numBytesPerLine ) throws DebugException { if ( lines = = null | | lines . isEmpty ( ) ) { return ; } Object [ ] objs = lines . toArray ( ) ; if ( objs . length > <int> ) { TableRenderingLine [ ] renderingLines = lines . toArray ( new TableRenderingLine [ lines . size ( ) ] ) ; MemoryByte [ ] buffer = convertLinesToBytes ( renderingLines ) ; BigInteger lineAddress = new BigInteger ( renderingLines [ <int> ] . getAddress ( ) , <int> ) ; int numberOfLines = buffer . length / numBytesPerLine ; boolean updateDelta = false ; int addressLength = getAddressSize ( lineAddress ) * IInternalDebugUIConstants . CHAR_PER_BYTE ; MemoryByte [ ] memoryBuffer = buffer ; String address = renderingLines [ <int> ] . getAddress ( ) ; String paddedString = DebugUITools . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; boolean manageDelta = true ; if ( fInput . getMemoryBlock ( ) instanceof IMemoryBlockExtension ) { manageDelta = ! ( ( IMemoryBlockExtension ) fInput . getMemoryBlock ( ) ) . supportsChangeManagement ( ) ; } lineCache . clear ( ) ; organizeLines ( numberOfLines , updateDelta , addressLength , memoryBuffer , paddedString , address , manageDelta ) ; } } private void reorganizeContentCache ( int bytesPerLine ) { if ( contentCache = = null | | contentCache . isEmpty ( ) | | fContentCacheInBytes . length = = <int> | | fContentCacheStartAddress = = null ) { return ; } MemoryByte [ ] bytes = fContentCacheInBytes ; TableRenderingLine [ ] convertedLines = convertBytesToLines ( bytes , bytesPerLine , new BigInteger ( fContentCacheStartAddress , <int> ) ) ; contentCache . clear ( ) ; for ( int i = <int> ; i < convertedLines . length ; i + + ) { contentCache . put ( convertedLines [ i ] . getAddress ( ) , convertedLines [ i ] ) ; } } private MemoryByte [ ] convertLinesToBytes ( TableRenderingLine [ ] lines ) { TableRenderingLine temp = lines [ <int> ] ; int lineLength = temp . getLength ( ) ; MemoryByte [ ] buffer = new MemoryByte [ lines . length * lineLength ] ; for ( int i = <int> ; i < lines . length ; i + + ) { TableRenderingLine line = lines [ i ] ; MemoryByte [ ] bytes = line . getBytes ( ) ; System . arraycopy ( bytes , <int> , buffer , i * lineLength , lineLength ) ; } return buffer ; } private TableRenderingLine [ ] convertBytesToLines ( MemoryByte [ ] bytes , int bytesPerLine , BigInteger startAddress ) { int numOfLines = bytes . length / bytesPerLine ; String address = startAddress . toString ( <int> ) ; int addressLength ; try { addressLength = getAddressSize ( startAddress ) * IInternalDebugUIConstants . CHAR_PER_BYTE ; } catch ( DebugException e ) { DebugUIPlugin . log ( e ) ; addressLength = <int> * IInternalDebugUIConstants . CHAR_PER_BYTE ; } ArrayList < TableRenderingLine > lines = new ArrayList < TableRenderingLine > ( ) ; String paddedString = DebugUITools . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; for ( int i = <int> ; i < numOfLines ; i + + ) { MemoryByte [ ] temp = new MemoryByte [ bytesPerLine ] ; System . arraycopy ( bytes , i * bytesPerLine , temp , <int> , bytesPerLine ) ; String tmpAddress = address . toUpperCase ( ) ; if ( tmpAddress . length ( ) < addressLength ) { while ( tmpAddress . length ( ) < addressLength ) { tmpAddress = <str> + tmpAddress ; } } TableRenderingLine newLine = new TableRenderingLine ( tmpAddress , temp , lines . size ( ) , paddedString ) ; lines . add ( newLine ) ; BigInteger bigInt = new BigInteger ( address , <int> ) ; fBufferEndAddress = bigInt ; int addressableUnit = getTableRendering ( fInput ) . getBytesPerLine ( ) / getTableRendering ( fInput ) . getAddressableSize ( ) ; address = bigInt . add ( BigInteger . valueOf ( addressableUnit ) ) . toString ( <int> ) ; } return lines . toArray ( new TableRenderingLine [ lines . size ( ) ] ) ; } private AbstractTableRendering getTableRendering ( TableRenderingContentInput input ) { return input . getAdapter ( AbstractTableRendering . class ) ; } } 
