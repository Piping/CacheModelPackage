package com . google . common . testing ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Joiner ; import com . google . common . base . Objects ; import com . google . common . base . Throwables ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ListMultimap ; import com . google . common . collect . Lists ; import com . google . common . collect . MutableClassToInstanceMap ; import com . google . common . collect . Ordering ; import com . google . common . collect . Sets ; import com . google . common . primitives . Ints ; import com . google . common . reflect . Invokable ; import com . google . common . reflect . Parameter ; import com . google . common . reflect . Reflection ; import com . google . common . reflect . TypeToken ; import com . google . common . testing . NullPointerTester . Visibility ; import com . google . common . testing . RelationshipTester . Item ; import com . google . common . testing . RelationshipTester . ItemReporter ; import junit . framework . Assert ; import junit . framework . AssertionFailedError ; import java . io . Serializable ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; @Beta public final class ClassSanityTester { private static final Ordering < Invokable < ? , ? > > BY_METHOD_NAME = new Ordering < Invokable < ? , ? > > ( ) { @Override public int compare ( Invokable < ? , ? > left , Invokable < ? , ? > right ) { return left . getName ( ) . compareTo ( right . getName ( ) ) ; } } ; private static final Ordering < Invokable < ? , ? > > BY_PARAMETERS = new Ordering < Invokable < ? , ? > > ( ) { @Override public int compare ( Invokable < ? , ? > left , Invokable < ? , ? > right ) { return Ordering . usingToString ( ) . compare ( left . getParameters ( ) , right . getParameters ( ) ) ; } } ; private static final Ordering < Invokable < ? , ? > > BY_NUMBER_OF_PARAMETERS = new Ordering < Invokable < ? , ? > > ( ) { @Override public int compare ( Invokable < ? , ? > left , Invokable < ? , ? > right ) { return Ints . compare ( left . getParameters ( ) . size ( ) , right . getParameters ( ) . size ( ) ) ; } } ; private final MutableClassToInstanceMap < Object > defaultValues = MutableClassToInstanceMap . create ( ) ; private final ListMultimap < Class < ? > , Object > distinctValues = ArrayListMultimap . create ( ) ; private final NullPointerTester nullPointerTester = new NullPointerTester ( ) ; public ClassSanityTester ( ) { setDefault ( byte . class , ( byte ) <int> ) ; setDefault ( Byte . class , ( byte ) <int> ) ; setDefault ( short . class , ( short ) <int> ) ; setDefault ( Short . class , ( short ) <int> ) ; setDefault ( int . class , <int> ) ; setDefault ( Integer . class , <int> ) ; setDefault ( long . class , <int> ) ; setDefault ( Long . class , <int> ) ; setDefault ( float . class , <float> ) ; setDefault ( Float . class , <float> ) ; setDefault ( double . class , <float> ) ; setDefault ( Double . class , <float> ) ; setDefault ( Class . class , Class . class ) ; } public < T > ClassSanityTester setDefault ( Class < T > type , T value ) { nullPointerTester . setDefault ( type , value ) ; defaultValues . putInstance ( type , value ) ; return this ; } @Deprecated public < T > ClassSanityTester setSampleInstances ( Class < T > type , Iterable < ? extends T > instances ) { ImmutableList < ? extends T > samples = ImmutableList . copyOf ( instances ) ; Set < Object > uniqueValues = new HashSet < Object > ( ) ; for ( T instance : instances ) { checkArgument ( uniqueValues . add ( instance ) , <str> , instance ) ; } distinctValues . putAll ( checkNotNull ( type ) , samples ) ; if ( ! samples . isEmpty ( ) ) { setDefault ( type , samples . get ( <int> ) ) ; } return this ; } public < T > ClassSanityTester setDistinctValues ( Class < T > type , T value1 , T value2 ) { checkNotNull ( type ) ; checkNotNull ( value1 ) ; checkNotNull ( value2 ) ; checkArgument ( ! Objects . equal ( value1 , value2 ) , <str> ) ; distinctValues . replaceValues ( type , ImmutableList . of ( value1 , value2 ) ) ; setDefault ( type , value1 ) ; return this ; } public void testNulls ( Class < ? > cls ) { try { doTestNulls ( cls , Visibility . PACKAGE ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } } void doTestNulls ( Class < ? > cls , Visibility visibility ) throws ParameterNotInstantiableException , IllegalAccessException , InvocationTargetException , FactoryMethodReturnsNullException { if ( ! Modifier . isAbstract ( cls . getModifiers ( ) ) ) { nullPointerTester . testConstructors ( cls , visibility ) ; } nullPointerTester . testStaticMethods ( cls , visibility ) ; if ( hasInstanceMethodToTestNulls ( cls , visibility ) ) { Object instance = instantiate ( cls ) ; if ( instance ! = null ) { nullPointerTester . testInstanceMethods ( instance , visibility ) ; } } } private boolean hasInstanceMethodToTestNulls ( Class < ? > c , Visibility visibility ) { for ( Method method : nullPointerTester . getInstanceMethodsToTest ( c , visibility ) ) { for ( Parameter param : Invokable . from ( method ) . getParameters ( ) ) { if ( ! NullPointerTester . isPrimitiveOrNullable ( param ) ) { return true ; } } } return false ; } public void testEquals ( Class < ? > cls ) { try { doTestEquals ( cls ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } } void doTestEquals ( Class < ? > cls ) throws ParameterNotInstantiableException , ParameterHasNoDistinctValueException , IllegalAccessException , InvocationTargetException , FactoryMethodReturnsNullException { if ( cls . isEnum ( ) ) { return ; } List < ? extends Invokable < ? , ? > > factories = Lists . reverse ( getFactories ( TypeToken . of ( cls ) ) ) ; if ( factories . isEmpty ( ) ) { return ; } int numberOfParameters = factories . get ( <int> ) . getParameters ( ) . size ( ) ; List < ParameterNotInstantiableException > paramErrors = Lists . newArrayList ( ) ; List < ParameterHasNoDistinctValueException > distinctValueErrors = Lists . newArrayList ( ) ; List < InvocationTargetException > instantiationExceptions = Lists . newArrayList ( ) ; List < FactoryMethodReturnsNullException > nullErrors = Lists . newArrayList ( ) ; for ( Invokable < ? , ? > factory : factories ) { if ( factory . getParameters ( ) . size ( ) = = numberOfParameters ) { try { testEqualsUsing ( factory ) ; return ; } catch ( ParameterNotInstantiableException e ) { paramErrors . add ( e ) ; } catch ( ParameterHasNoDistinctValueException e ) { distinctValueErrors . add ( e ) ; } catch ( InvocationTargetException e ) { instantiationExceptions . add ( e ) ; } catch ( FactoryMethodReturnsNullException e ) { nullErrors . add ( e ) ; } } } throwFirst ( paramErrors ) ; throwFirst ( distinctValueErrors ) ; throwFirst ( instantiationExceptions ) ; throwFirst ( nullErrors ) ; } @Nullable < T > T instantiate ( Class < T > cls ) throws ParameterNotInstantiableException , IllegalAccessException , InvocationTargetException , FactoryMethodReturnsNullException { if ( cls . isEnum ( ) ) { T [ ] constants = cls . getEnumConstants ( ) ; if ( constants . length > <int> ) { return constants [ <int> ] ; } else { return null ; } } TypeToken < T > type = TypeToken . of ( cls ) ; List < ParameterNotInstantiableException > paramErrors = Lists . newArrayList ( ) ; List < InvocationTargetException > instantiationExceptions = Lists . newArrayList ( ) ; List < FactoryMethodReturnsNullException > nullErrors = Lists . newArrayList ( ) ; for ( Invokable < ? , ? extends T > factory : getFactories ( type ) ) { T instance ; try { instance = instantiate ( factory ) ; } catch ( ParameterNotInstantiableException e ) { paramErrors . add ( e ) ; continue ; } catch ( InvocationTargetException e ) { instantiationExceptions . add ( e ) ; continue ; } if ( instance = = null ) { nullErrors . add ( new FactoryMethodReturnsNullException ( factory ) ) ; } else { return instance ; } } throwFirst ( paramErrors ) ; throwFirst ( instantiationExceptions ) ; throwFirst ( nullErrors ) ; return null ; } public FactoryMethodReturnValueTester forAllPublicStaticMethods ( Class < ? > cls ) { ImmutableList . Builder < Invokable < ? , ? > > builder = ImmutableList . builder ( ) ; for ( Method method : cls . getDeclaredMethods ( ) ) { Invokable < ? , ? > invokable = Invokable . from ( method ) ; invokable . setAccessible ( true ) ; if ( invokable . isPublic ( ) & & invokable . isStatic ( ) & & ! invokable . isSynthetic ( ) ) { builder . add ( invokable ) ; } } return new FactoryMethodReturnValueTester ( cls , builder . build ( ) , <str> ) ; } public final class FactoryMethodReturnValueTester { private final Set < String > packagesToTest = Sets . newHashSet ( ) ; private final Class < ? > declaringClass ; private final ImmutableList < Invokable < ? , ? > > factories ; private final String factoryMethodsDescription ; private Class < ? > returnTypeToTest = Object . class ; private FactoryMethodReturnValueTester ( Class < ? > declaringClass , ImmutableList < Invokable < ? , ? > > factories , String factoryMethodsDescription ) { this . declaringClass = declaringClass ; this . factories = factories ; this . factoryMethodsDescription = factoryMethodsDescription ; packagesToTest . add ( Reflection . getPackageName ( declaringClass ) ) ; } public FactoryMethodReturnValueTester thatReturn ( Class < ? > returnType ) { this . returnTypeToTest = returnType ; return this ; } public FactoryMethodReturnValueTester testNulls ( ) throws Exception { for ( Invokable < ? , ? > factory : getFactoriesToTest ( ) ) { Object instance = instantiate ( factory ) ; if ( instance ! = null & & packagesToTest . contains ( Reflection . getPackageName ( instance . getClass ( ) ) ) ) { try { nullPointerTester . testAllPublicInstanceMethods ( instance ) ; } catch ( AssertionError e ) { AssertionError error = new AssertionFailedError ( <str> + factory ) ; error . initCause ( e ) ; throw error ; } } } return this ; } public FactoryMethodReturnValueTester testEquals ( ) throws Exception { for ( Invokable < ? , ? > factory : getFactoriesToTest ( ) ) { try { testEqualsUsing ( factory ) ; } catch ( FactoryMethodReturnsNullException e ) { } } return this ; } public FactoryMethodReturnValueTester testSerializable ( ) throws Exception { for ( Invokable < ? , ? > factory : getFactoriesToTest ( ) ) { Object instance = instantiate ( factory ) ; if ( instance ! = null ) { try { SerializableTester . reserialize ( instance ) ; } catch ( RuntimeException e ) { AssertionError error = new AssertionFailedError ( <str> + factory ) ; error . initCause ( e . getCause ( ) ) ; throw error ; } } } return this ; } public FactoryMethodReturnValueTester testEqualsAndSerializable ( ) throws Exception { for ( Invokable < ? , ? > factory : getFactoriesToTest ( ) ) { try { testEqualsUsing ( factory ) ; } catch ( FactoryMethodReturnsNullException e ) { } Object instance = instantiate ( factory ) ; if ( instance ! = null ) { try { SerializableTester . reserializeAndAssert ( instance ) ; } catch ( RuntimeException e ) { AssertionError error = new AssertionFailedError ( <str> + factory ) ; error . initCause ( e . getCause ( ) ) ; throw error ; } catch ( AssertionFailedError e ) { AssertionError error = new AssertionFailedError ( <str> + factory + <str> ) ; error . initCause ( e ) ; throw error ; } } } return this ; } private ImmutableList < Invokable < ? , ? > > getFactoriesToTest ( ) { ImmutableList . Builder < Invokable < ? , ? > > builder = ImmutableList . builder ( ) ; for ( Invokable < ? , ? > factory : factories ) { if ( returnTypeToTest . isAssignableFrom ( factory . getReturnType ( ) . getRawType ( ) ) ) { builder . add ( factory ) ; } } ImmutableList < Invokable < ? , ? > > factoriesToTest = builder . build ( ) ; Assert . assertFalse ( <str> + factoryMethodsDescription + <str> + returnTypeToTest . getName ( ) + <str> + declaringClass + <str> , factoriesToTest . isEmpty ( ) ) ; return factoriesToTest ; } } @Nullable private < T > T instantiate ( Invokable < ? , ? extends T > factory ) throws ParameterNotInstantiableException , InvocationTargetException , IllegalAccessException { return invoke ( factory , getDummyArguments ( factory ) ) ; } private void testEqualsUsing ( final Invokable < ? , ? > factory ) throws ParameterNotInstantiableException , ParameterHasNoDistinctValueException , IllegalAccessException , InvocationTargetException , FactoryMethodReturnsNullException { List < Parameter > params = factory . getParameters ( ) ; List < FreshValueGenerator > argGenerators = Lists . newArrayListWithCapacity ( params . size ( ) ) ; List < Object > args = Lists . newArrayListWithCapacity ( params . size ( ) ) ; for ( Parameter param : params ) { FreshValueGenerator generator = newFreshValueGenerator ( ) ; argGenerators . add ( generator ) ; args . add ( generateDummyArg ( param , generator ) ) ; } Object instance = createInstance ( factory , args ) ; List < Object > equalArgs = generateEqualFactoryArguments ( factory , params , args ) ; final List < List < List < Object > > > argGroups = Lists . newArrayList ( ) ; argGroups . add ( ImmutableList . of ( args , equalArgs ) ) ; EqualsTester tester = new EqualsTester ( new ItemReporter ( ) { @Override String reportItem ( Item < ? > item ) { List < Object > factoryArgs = argGroups . get ( item . groupNumber ) . get ( item . itemNumber ) ; return factory . getName ( ) + <str> + Joiner . on ( <str> ) . useForNull ( <str> ) . join ( factoryArgs ) + <str> ; } } ) ; tester . addEqualityGroup ( instance , createInstance ( factory , equalArgs ) ) ; for ( int i = <int> ; i < params . size ( ) ; i + + ) { List < Object > newArgs = Lists . newArrayList ( args ) ; Object newArg = argGenerators . get ( i ) . generateFresh ( params . get ( i ) . getType ( ) ) ; if ( newArg = = null | | Objects . equal ( args . get ( i ) , newArg ) ) { if ( params . get ( i ) . getType ( ) . getRawType ( ) . isEnum ( ) ) { continue ; } throw new ParameterHasNoDistinctValueException ( params . get ( i ) ) ; } newArgs . set ( i , newArg ) ; tester . addEqualityGroup ( createInstance ( factory , newArgs ) ) ; argGroups . add ( ImmutableList . of ( newArgs ) ) ; } tester . testEquals ( ) ; } private List < Object > generateEqualFactoryArguments ( Invokable < ? , ? > factory , List < Parameter > params , List < Object > args ) throws ParameterNotInstantiableException , FactoryMethodReturnsNullException , InvocationTargetException , IllegalAccessException { List < Object > equalArgs = Lists . newArrayList ( args ) ; for ( int i = <int> ; i < args . size ( ) ; i + + ) { Parameter param = params . get ( i ) ; Object arg = args . get ( i ) ; Object shouldBeEqualArg = generateDummyArg ( param , newFreshValueGenerator ( ) ) ; if ( arg ! = shouldBeEqualArg & & Objects . equal ( arg , shouldBeEqualArg ) & & hashCodeInsensitiveToArgReference ( factory , args , i , shouldBeEqualArg ) & & hashCodeInsensitiveToArgReference ( factory , args , i , generateDummyArg ( param , newFreshValueGenerator ( ) ) ) ) { equalArgs . set ( i , shouldBeEqualArg ) ; } } return equalArgs ; } private static boolean hashCodeInsensitiveToArgReference ( Invokable < ? , ? > factory , List < Object > args , int i , Object alternateArg ) throws FactoryMethodReturnsNullException , InvocationTargetException , IllegalAccessException { List < Object > tentativeArgs = Lists . newArrayList ( args ) ; tentativeArgs . set ( i , alternateArg ) ; return createInstance ( factory , tentativeArgs ) . hashCode ( ) = = createInstance ( factory , args ) . hashCode ( ) ; } @SuppressWarnings ( { <str> , <str> } ) private FreshValueGenerator newFreshValueGenerator ( ) { FreshValueGenerator generator = new FreshValueGenerator ( ) { @Override Object interfaceMethodCalled ( Class < ? > interfaceType , Method method ) { return getDummyValue ( TypeToken . of ( interfaceType ) . method ( method ) . getReturnType ( ) ) ; } } ; for ( Map . Entry < Class < ? > , Collection < Object > > entry : distinctValues . asMap ( ) . entrySet ( ) ) { generator . addSampleInstances ( ( Class ) entry . getKey ( ) , entry . getValue ( ) ) ; } return generator ; } @Nullable private static Object generateDummyArg ( Parameter param , FreshValueGenerator generator ) throws ParameterNotInstantiableException { if ( param . isAnnotationPresent ( Nullable . class ) ) { return null ; } Object arg = generator . generateFresh ( param . getType ( ) ) ; if ( arg = = null ) { throw new ParameterNotInstantiableException ( param ) ; } return arg ; } private static < X extends Throwable > void throwFirst ( List < X > exceptions ) throws X { if ( ! exceptions . isEmpty ( ) ) { throw exceptions . get ( <int> ) ; } } private static < T > ImmutableList < Invokable < ? , ? extends T > > getFactories ( TypeToken < T > type ) { List < Invokable < ? , ? extends T > > factories = Lists . newArrayList ( ) ; for ( Method method : type . getRawType ( ) . getDeclaredMethods ( ) ) { Invokable < ? , ? > invokable = type . method ( method ) ; if ( ! invokable . isPrivate ( ) & & ! invokable . isSynthetic ( ) & & invokable . isStatic ( ) & & type . isSupertypeOf ( invokable . getReturnType ( ) ) ) { @SuppressWarnings ( <str> ) Invokable < ? , ? extends T > factory = ( Invokable < ? , ? extends T > ) invokable ; factories . add ( factory ) ; } } if ( ! Modifier . isAbstract ( type . getRawType ( ) . getModifiers ( ) ) ) { for ( Constructor < ? > constructor : type . getRawType ( ) . getDeclaredConstructors ( ) ) { Invokable < T , T > invokable = type . constructor ( constructor ) ; if ( ! invokable . isPrivate ( ) & & ! invokable . isSynthetic ( ) ) { factories . add ( invokable ) ; } } } for ( Invokable < ? , ? > factory : factories ) { factory . setAccessible ( true ) ; } return BY_NUMBER_OF_PARAMETERS . compound ( BY_METHOD_NAME ) . compound ( BY_PARAMETERS ) . immutableSortedCopy ( factories ) ; } private List < Object > getDummyArguments ( Invokable < ? , ? > invokable ) throws ParameterNotInstantiableException { List < Object > args = Lists . newArrayList ( ) ; for ( Parameter param : invokable . getParameters ( ) ) { if ( param . isAnnotationPresent ( Nullable . class ) ) { args . add ( null ) ; continue ; } Object defaultValue = getDummyValue ( param . getType ( ) ) ; if ( defaultValue = = null ) { throw new ParameterNotInstantiableException ( param ) ; } args . add ( defaultValue ) ; } return args ; } private < T > T getDummyValue ( TypeToken < T > type ) { Class < ? super T > rawType = type . getRawType ( ) ; @SuppressWarnings ( <str> ) T defaultValue = ( T ) defaultValues . getInstance ( rawType ) ; if ( defaultValue ! = null ) { return defaultValue ; } @SuppressWarnings ( <str> ) T value = ( T ) ArbitraryInstances . get ( rawType ) ; if ( value ! = null ) { return value ; } if ( rawType . isInterface ( ) ) { return new SerializableDummyProxy ( this ) . newProxy ( type ) ; } return null ; } private static < T > T createInstance ( Invokable < ? , ? extends T > factory , List < ? > args ) throws FactoryMethodReturnsNullException , InvocationTargetException , IllegalAccessException { T instance = invoke ( factory , args ) ; if ( instance = = null ) { throw new FactoryMethodReturnsNullException ( factory ) ; } return instance ; } @Nullable private static < T > T invoke ( Invokable < ? , ? extends T > factory , List < ? > args ) throws InvocationTargetException , IllegalAccessException { T returnValue = factory . invoke ( null , args . toArray ( ) ) ; if ( returnValue = = null ) { Assert . assertTrue ( factory + <str> , factory . isAnnotationPresent ( Nullable . class ) ) ; } return returnValue ; } @VisibleForTesting static class ParameterNotInstantiableException extends Exception { public ParameterNotInstantiableException ( Parameter parameter ) { super ( <str> + parameter + <str> + parameter . getDeclaringInvokable ( ) ) ; } } @VisibleForTesting static class ParameterHasNoDistinctValueException extends Exception { ParameterHasNoDistinctValueException ( Parameter parameter ) { super ( <str> + parameter + <str> + parameter . getDeclaringInvokable ( ) ) ; } } @VisibleForTesting static class FactoryMethodReturnsNullException extends Exception { public FactoryMethodReturnsNullException ( Invokable < ? , ? > factory ) { super ( factory + <str> ) ; } } private static final class SerializableDummyProxy extends DummyProxy implements Serializable { private final transient ClassSanityTester tester ; SerializableDummyProxy ( ClassSanityTester tester ) { this . tester = tester ; } @Override < R > R dummyReturnValue ( TypeToken < R > returnType ) { return tester . getDummyValue ( returnType ) ; } @Override public boolean equals ( Object obj ) { return obj instanceof SerializableDummyProxy ; } @Override public int hashCode ( ) { return <int> ; } } } 
