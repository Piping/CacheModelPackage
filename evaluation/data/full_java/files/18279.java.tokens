package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . math . Interpolation ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Event ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . utils . ActorGestureListener ; import com . badlogic . gdx . scenes . scene2d . utils . Cullable ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . Layout ; import com . badlogic . gdx . scenes . scene2d . utils . ScissorStack ; public class ScrollPane extends WidgetGroup { private ScrollPaneStyle style ; private Actor widget ; final Rectangle hScrollBounds = new Rectangle ( ) ; final Rectangle vScrollBounds = new Rectangle ( ) ; final Rectangle hKnobBounds = new Rectangle ( ) ; final Rectangle vKnobBounds = new Rectangle ( ) ; private final Rectangle widgetAreaBounds = new Rectangle ( ) ; private final Rectangle widgetCullingArea = new Rectangle ( ) ; private final Rectangle scissorBounds = new Rectangle ( ) ; private ActorGestureListener flickScrollListener ; boolean scrollX , scrollY ; boolean vScrollOnRight = true ; boolean hScrollOnBottom = true ; float amountX , amountY ; float visualAmountX , visualAmountY ; float maxX , maxY ; boolean touchScrollH , touchScrollV ; final Vector2 lastPoint = new Vector2 ( ) ; float areaWidth , areaHeight ; private boolean fadeScrollBars = true , smoothScrolling = true ; float fadeAlpha , fadeAlphaSeconds = <int> , fadeDelay , fadeDelaySeconds = <int> ; boolean cancelTouchFocus = true ; boolean flickScroll = true ; float velocityX , velocityY ; float flingTimer ; private boolean overscrollX = true , overscrollY = true ; float flingTime = <float> ; private float overscrollDistance = <int> , overscrollSpeedMin = <int> , overscrollSpeedMax = <int> ; private boolean forceScrollX , forceScrollY ; private boolean disableX , disableY ; private boolean clamp = true ; private boolean scrollbarsOnTop ; private boolean variableSizeKnobs = true ; int draggingPointer = - <int> ; public ScrollPane ( Actor widget ) { this ( widget , new ScrollPaneStyle ( ) ) ; } public ScrollPane ( Actor widget , Skin skin ) { this ( widget , skin . get ( ScrollPaneStyle . class ) ) ; } public ScrollPane ( Actor widget , Skin skin , String styleName ) { this ( widget , skin . get ( styleName , ScrollPaneStyle . class ) ) ; } public ScrollPane ( Actor widget , ScrollPaneStyle style ) { if ( style = = null ) throw new IllegalArgumentException ( <str> ) ; this . style = style ; setWidget ( widget ) ; setSize ( <int> , <int> ) ; addCaptureListener ( new InputListener ( ) { private float handlePosition ; public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { if ( draggingPointer ! = - <int> ) return false ; if ( pointer = = <int> & & button ! = <int> ) return false ; getStage ( ) . setScrollFocus ( ScrollPane . this ) ; if ( ! flickScroll ) resetFade ( ) ; if ( fadeAlpha = = <int> ) return false ; if ( scrollX & & hScrollBounds . contains ( x , y ) ) { event . stop ( ) ; resetFade ( ) ; if ( hKnobBounds . contains ( x , y ) ) { lastPoint . set ( x , y ) ; handlePosition = hKnobBounds . x ; touchScrollH = true ; draggingPointer = pointer ; return true ; } setScrollX ( amountX + areaWidth * ( x < hKnobBounds . x ? - <int> : <int> ) ) ; return true ; } if ( scrollY & & vScrollBounds . contains ( x , y ) ) { event . stop ( ) ; resetFade ( ) ; if ( vKnobBounds . contains ( x , y ) ) { lastPoint . set ( x , y ) ; handlePosition = vKnobBounds . y ; touchScrollV = true ; draggingPointer = pointer ; return true ; } setScrollY ( amountY + areaHeight * ( y < vKnobBounds . y ? <int> : - <int> ) ) ; return true ; } return false ; } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { if ( pointer ! = draggingPointer ) return ; cancel ( ) ; } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { if ( pointer ! = draggingPointer ) return ; if ( touchScrollH ) { float delta = x - lastPoint . x ; float scrollH = handlePosition + delta ; handlePosition = scrollH ; scrollH = Math . max ( hScrollBounds . x , scrollH ) ; scrollH = Math . min ( hScrollBounds . x + hScrollBounds . width - hKnobBounds . width , scrollH ) ; float total = hScrollBounds . width - hKnobBounds . width ; if ( total ! = <int> ) setScrollPercentX ( ( scrollH - hScrollBounds . x ) / total ) ; lastPoint . set ( x , y ) ; } else if ( touchScrollV ) { float delta = y - lastPoint . y ; float scrollV = handlePosition + delta ; handlePosition = scrollV ; scrollV = Math . max ( vScrollBounds . y , scrollV ) ; scrollV = Math . min ( vScrollBounds . y + vScrollBounds . height - vKnobBounds . height , scrollV ) ; float total = vScrollBounds . height - vKnobBounds . height ; if ( total ! = <int> ) setScrollPercentY ( <int> - ( ( scrollV - vScrollBounds . y ) / total ) ) ; lastPoint . set ( x , y ) ; } } public boolean mouseMoved ( InputEvent event , float x , float y ) { if ( ! flickScroll ) resetFade ( ) ; return false ; } } ) ; flickScrollListener = new ActorGestureListener ( ) { public void pan ( InputEvent event , float x , float y , float deltaX , float deltaY ) { resetFade ( ) ; amountX - = deltaX ; amountY + = deltaY ; clamp ( ) ; if ( cancelTouchFocus ) cancelTouchFocus ( ) ; } public void fling ( InputEvent event , float x , float y , int button ) { if ( Math . abs ( x ) > <int> ) { flingTimer = flingTime ; velocityX = x ; if ( cancelTouchFocus ) cancelTouchFocus ( ) ; } if ( Math . abs ( y ) > <int> ) { flingTimer = flingTime ; velocityY = - y ; if ( cancelTouchFocus ) cancelTouchFocus ( ) ; } } public boolean handle ( Event event ) { if ( super . handle ( event ) ) { if ( ( ( InputEvent ) event ) . getType ( ) = = InputEvent . Type . touchDown ) flingTimer = <int> ; return true ; } return false ; } } ; addListener ( flickScrollListener ) ; addListener ( new InputListener ( ) { public boolean scrolled ( InputEvent event , float x , float y , int amount ) { resetFade ( ) ; if ( scrollY ) setScrollY ( amountY + getMouseWheelY ( ) * amount ) ; else if ( scrollX ) setScrollX ( amountX + getMouseWheelX ( ) * amount ) ; else return false ; return true ; } } ) ; } void resetFade ( ) { fadeAlpha = fadeAlphaSeconds ; fadeDelay = fadeDelaySeconds ; } public void cancelTouchFocus ( ) { Stage stage = getStage ( ) ; if ( stage ! = null ) stage . cancelTouchFocusExcept ( flickScrollListener , this ) ; } public void cancel ( ) { draggingPointer = - <int> ; touchScrollH = false ; touchScrollV = false ; flickScrollListener . getGestureDetector ( ) . cancel ( ) ; } void clamp ( ) { if ( ! clamp ) return ; scrollX ( overscrollX ? MathUtils . clamp ( amountX , - overscrollDistance , maxX + overscrollDistance ) : MathUtils . clamp ( amountX , <int> , maxX ) ) ; scrollY ( overscrollY ? MathUtils . clamp ( amountY , - overscrollDistance , maxY + overscrollDistance ) : MathUtils . clamp ( amountY , <int> , maxY ) ) ; } public void setStyle ( ScrollPaneStyle style ) { if ( style = = null ) throw new IllegalArgumentException ( <str> ) ; this . style = style ; invalidateHierarchy ( ) ; } public ScrollPaneStyle getStyle ( ) { return style ; } public void act ( float delta ) { super . act ( delta ) ; boolean panning = flickScrollListener . getGestureDetector ( ) . isPanning ( ) ; boolean animating = false ; if ( fadeAlpha > <int> & & fadeScrollBars & & ! panning & & ! touchScrollH & & ! touchScrollV ) { fadeDelay - = delta ; if ( fadeDelay < = <int> ) fadeAlpha = Math . max ( <int> , fadeAlpha - delta ) ; animating = true ; } if ( flingTimer > <int> ) { resetFade ( ) ; float alpha = flingTimer / flingTime ; amountX - = velocityX * alpha * delta ; amountY - = velocityY * alpha * delta ; clamp ( ) ; if ( amountX = = - overscrollDistance ) velocityX = <int> ; if ( amountX > = maxX + overscrollDistance ) velocityX = <int> ; if ( amountY = = - overscrollDistance ) velocityY = <int> ; if ( amountY > = maxY + overscrollDistance ) velocityY = <int> ; flingTimer - = delta ; if ( flingTimer < = <int> ) { velocityX = <int> ; velocityY = <int> ; } animating = true ; } if ( smoothScrolling & & flingTimer < = <int> & & ! panning & & ( ( ! touchScrollH | | ( scrollX & & maxX / ( hScrollBounds . width - hKnobBounds . width ) > areaWidth * <float> ) ) & & ( ! touchScrollV | | ( scrollY & & maxY / ( vScrollBounds . height - vKnobBounds . height ) > areaHeight * <float> ) ) ) ) { if ( visualAmountX ! = amountX ) { if ( visualAmountX < amountX ) visualScrollX ( Math . min ( amountX , visualAmountX + Math . max ( <int> * delta , ( amountX - visualAmountX ) * <int> * delta ) ) ) ; else visualScrollX ( Math . max ( amountX , visualAmountX - Math . max ( <int> * delta , ( visualAmountX - amountX ) * <int> * delta ) ) ) ; animating = true ; } if ( visualAmountY ! = amountY ) { if ( visualAmountY < amountY ) visualScrollY ( Math . min ( amountY , visualAmountY + Math . max ( <int> * delta , ( amountY - visualAmountY ) * <int> * delta ) ) ) ; else visualScrollY ( Math . max ( amountY , visualAmountY - Math . max ( <int> * delta , ( visualAmountY - amountY ) * <int> * delta ) ) ) ; animating = true ; } } else { if ( visualAmountX ! = amountX ) visualScrollX ( amountX ) ; if ( visualAmountY ! = amountY ) visualScrollY ( amountY ) ; } if ( ! panning ) { if ( overscrollX & & scrollX ) { if ( amountX < <int> ) { resetFade ( ) ; amountX + = ( overscrollSpeedMin + ( overscrollSpeedMax - overscrollSpeedMin ) * - amountX / overscrollDistance ) * delta ; if ( amountX > <int> ) scrollX ( <int> ) ; animating = true ; } else if ( amountX > maxX ) { resetFade ( ) ; amountX - = ( overscrollSpeedMin + ( overscrollSpeedMax - overscrollSpeedMin ) * - ( maxX - amountX ) / overscrollDistance ) * delta ; if ( amountX < maxX ) scrollX ( maxX ) ; animating = true ; } } if ( overscrollY & & scrollY ) { if ( amountY < <int> ) { resetFade ( ) ; amountY + = ( overscrollSpeedMin + ( overscrollSpeedMax - overscrollSpeedMin ) * - amountY / overscrollDistance ) * delta ; if ( amountY > <int> ) scrollY ( <int> ) ; animating = true ; } else if ( amountY > maxY ) { resetFade ( ) ; amountY - = ( overscrollSpeedMin + ( overscrollSpeedMax - overscrollSpeedMin ) * - ( maxY - amountY ) / overscrollDistance ) * delta ; if ( amountY < maxY ) scrollY ( maxY ) ; animating = true ; } } } if ( animating ) { Stage stage = getStage ( ) ; if ( stage ! = null & & stage . getActionsRequestRendering ( ) ) Gdx . graphics . requestRendering ( ) ; } } public void layout ( ) { final Drawable bg = style . background ; final Drawable hScrollKnob = style . hScrollKnob ; final Drawable vScrollKnob = style . vScrollKnob ; float bgLeftWidth = <int> , bgRightWidth = <int> , bgTopHeight = <int> , bgBottomHeight = <int> ; if ( bg ! = null ) { bgLeftWidth = bg . getLeftWidth ( ) ; bgRightWidth = bg . getRightWidth ( ) ; bgTopHeight = bg . getTopHeight ( ) ; bgBottomHeight = bg . getBottomHeight ( ) ; } float width = getWidth ( ) ; float height = getHeight ( ) ; float scrollbarHeight = <int> ; if ( hScrollKnob ! = null ) scrollbarHeight = hScrollKnob . getMinHeight ( ) ; if ( style . hScroll ! = null ) scrollbarHeight = Math . max ( scrollbarHeight , style . hScroll . getMinHeight ( ) ) ; float scrollbarWidth = <int> ; if ( vScrollKnob ! = null ) scrollbarWidth = vScrollKnob . getMinWidth ( ) ; if ( style . vScroll ! = null ) scrollbarWidth = Math . max ( scrollbarWidth , style . vScroll . getMinWidth ( ) ) ; areaWidth = width - bgLeftWidth - bgRightWidth ; areaHeight = height - bgTopHeight - bgBottomHeight ; if ( widget = = null ) return ; float widgetWidth , widgetHeight ; if ( widget instanceof Layout ) { Layout layout = ( Layout ) widget ; widgetWidth = layout . getPrefWidth ( ) ; widgetHeight = layout . getPrefHeight ( ) ; } else { widgetWidth = widget . getWidth ( ) ; widgetHeight = widget . getHeight ( ) ; } scrollX = forceScrollX | | ( widgetWidth > areaWidth & & ! disableX ) ; scrollY = forceScrollY | | ( widgetHeight > areaHeight & & ! disableY ) ; boolean fade = fadeScrollBars ; if ( ! fade ) { if ( scrollY ) { areaWidth - = scrollbarWidth ; if ( ! scrollX & & widgetWidth > areaWidth & & ! disableX ) scrollX = true ; } if ( scrollX ) { areaHeight - = scrollbarHeight ; if ( ! scrollY & & widgetHeight > areaHeight & & ! disableY ) { scrollY = true ; areaWidth - = scrollbarWidth ; } } } widgetAreaBounds . set ( bgLeftWidth , bgBottomHeight , areaWidth , areaHeight ) ; if ( fade ) { if ( scrollX & & scrollY ) { areaHeight - = scrollbarHeight ; areaWidth - = scrollbarWidth ; } } else { if ( scrollbarsOnTop ) { if ( scrollX ) widgetAreaBounds . height + = scrollbarHeight ; if ( scrollY ) widgetAreaBounds . width + = scrollbarWidth ; } else { if ( scrollX & & hScrollOnBottom ) widgetAreaBounds . y + = scrollbarHeight ; if ( scrollY & & ! vScrollOnRight ) widgetAreaBounds . x + = scrollbarWidth ; } } widgetWidth = disableX ? areaWidth : Math . max ( areaWidth , widgetWidth ) ; widgetHeight = disableY ? areaHeight : Math . max ( areaHeight , widgetHeight ) ; maxX = widgetWidth - areaWidth ; maxY = widgetHeight - areaHeight ; if ( fade ) { if ( scrollX & & scrollY ) { maxY - = scrollbarHeight ; maxX - = scrollbarWidth ; } } scrollX ( MathUtils . clamp ( amountX , <int> , maxX ) ) ; scrollY ( MathUtils . clamp ( amountY , <int> , maxY ) ) ; if ( scrollX ) { if ( hScrollKnob ! = null ) { float hScrollHeight = style . hScroll ! = null ? style . hScroll . getMinHeight ( ) : hScrollKnob . getMinHeight ( ) ; float boundsX = vScrollOnRight ? bgLeftWidth : bgLeftWidth + scrollbarWidth ; float boundsY = hScrollOnBottom ? bgBottomHeight : height - bgTopHeight - hScrollHeight ; hScrollBounds . set ( boundsX , boundsY , areaWidth , hScrollHeight ) ; if ( variableSizeKnobs ) hKnobBounds . width = Math . max ( hScrollKnob . getMinWidth ( ) , ( int ) ( hScrollBounds . width * areaWidth / widgetWidth ) ) ; else hKnobBounds . width = hScrollKnob . getMinWidth ( ) ; hKnobBounds . height = hScrollKnob . getMinHeight ( ) ; hKnobBounds . x = hScrollBounds . x + ( int ) ( ( hScrollBounds . width - hKnobBounds . width ) * getScrollPercentX ( ) ) ; hKnobBounds . y = hScrollBounds . y ; } else { hScrollBounds . set ( <int> , <int> , <int> , <int> ) ; hKnobBounds . set ( <int> , <int> , <int> , <int> ) ; } } if ( scrollY ) { if ( vScrollKnob ! = null ) { float vScrollWidth = style . vScroll ! = null ? style . vScroll . getMinWidth ( ) : vScrollKnob . getMinWidth ( ) ; float boundsX , boundsY ; if ( hScrollOnBottom ) { boundsY = height - bgTopHeight - areaHeight ; } else { boundsY = bgBottomHeight ; } if ( vScrollOnRight ) { boundsX = width - bgRightWidth - vScrollWidth ; } else { boundsX = bgLeftWidth ; } vScrollBounds . set ( boundsX , boundsY , vScrollWidth , areaHeight ) ; vKnobBounds . width = vScrollKnob . getMinWidth ( ) ; if ( variableSizeKnobs ) vKnobBounds . height = Math . max ( vScrollKnob . getMinHeight ( ) , ( int ) ( vScrollBounds . height * areaHeight / widgetHeight ) ) ; else vKnobBounds . height = vScrollKnob . getMinHeight ( ) ; if ( vScrollOnRight ) { vKnobBounds . x = width - bgRightWidth - vScrollKnob . getMinWidth ( ) ; } else { vKnobBounds . x = bgLeftWidth ; } vKnobBounds . y = vScrollBounds . y + ( int ) ( ( vScrollBounds . height - vKnobBounds . height ) * ( <int> - getScrollPercentY ( ) ) ) ; } else { vScrollBounds . set ( <int> , <int> , <int> , <int> ) ; vKnobBounds . set ( <int> , <int> , <int> , <int> ) ; } } widget . setSize ( widgetWidth , widgetHeight ) ; if ( widget instanceof Layout ) ( ( Layout ) widget ) . validate ( ) ; } @Override public void draw ( Batch batch , float parentAlpha ) { if ( widget = = null ) return ; validate ( ) ; applyTransform ( batch , computeTransform ( ) ) ; if ( scrollX ) hKnobBounds . x = hScrollBounds . x + ( int ) ( ( hScrollBounds . width - hKnobBounds . width ) * getVisualScrollPercentX ( ) ) ; if ( scrollY ) vKnobBounds . y = vScrollBounds . y + ( int ) ( ( vScrollBounds . height - vKnobBounds . height ) * ( <int> - getVisualScrollPercentY ( ) ) ) ; float y = widgetAreaBounds . y ; if ( ! scrollY ) y - = ( int ) maxY ; else y - = ( int ) ( maxY - visualAmountY ) ; float x = widgetAreaBounds . x ; if ( scrollX ) x - = ( int ) visualAmountX ; if ( ! fadeScrollBars & & scrollbarsOnTop ) { if ( scrollX & & hScrollOnBottom ) { float scrollbarHeight = <int> ; if ( style . hScrollKnob ! = null ) scrollbarHeight = style . hScrollKnob . getMinHeight ( ) ; if ( style . hScroll ! = null ) scrollbarHeight = Math . max ( scrollbarHeight , style . hScroll . getMinHeight ( ) ) ; y + = scrollbarHeight ; } if ( scrollY & & ! vScrollOnRight ) { float scrollbarWidth = <int> ; if ( style . hScrollKnob ! = null ) scrollbarWidth = style . hScrollKnob . getMinWidth ( ) ; if ( style . hScroll ! = null ) scrollbarWidth = Math . max ( scrollbarWidth , style . hScroll . getMinWidth ( ) ) ; x + = scrollbarWidth ; } } widget . setPosition ( x , y ) ; if ( widget instanceof Cullable ) { widgetCullingArea . x = - widget . getX ( ) + widgetAreaBounds . x ; widgetCullingArea . y = - widget . getY ( ) + widgetAreaBounds . y ; widgetCullingArea . width = widgetAreaBounds . width ; widgetCullingArea . height = widgetAreaBounds . height ; ( ( Cullable ) widget ) . setCullingArea ( widgetCullingArea ) ; } Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , color . a * parentAlpha ) ; if ( style . background ! = null ) style . background . draw ( batch , <int> , <int> , getWidth ( ) , getHeight ( ) ) ; getStage ( ) . calculateScissors ( widgetAreaBounds , scissorBounds ) ; batch . flush ( ) ; if ( ScissorStack . pushScissors ( scissorBounds ) ) { drawChildren ( batch , parentAlpha ) ; batch . flush ( ) ; ScissorStack . popScissors ( ) ; } batch . setColor ( color . r , color . g , color . b , color . a * parentAlpha * Interpolation . fade . apply ( fadeAlpha / fadeAlphaSeconds ) ) ; if ( scrollX & & scrollY ) { if ( style . corner ! = null ) { style . corner . draw ( batch , hScrollBounds . x + hScrollBounds . width , hScrollBounds . y , vScrollBounds . width , vScrollBounds . y ) ; } } if ( scrollX ) { if ( style . hScroll ! = null ) style . hScroll . draw ( batch , hScrollBounds . x , hScrollBounds . y , hScrollBounds . width , hScrollBounds . height ) ; if ( style . hScrollKnob ! = null ) style . hScrollKnob . draw ( batch , hKnobBounds . x , hKnobBounds . y , hKnobBounds . width , hKnobBounds . height ) ; } if ( scrollY ) { if ( style . vScroll ! = null ) style . vScroll . draw ( batch , vScrollBounds . x , vScrollBounds . y , vScrollBounds . width , vScrollBounds . height ) ; if ( style . vScrollKnob ! = null ) style . vScrollKnob . draw ( batch , vKnobBounds . x , vKnobBounds . y , vKnobBounds . width , vKnobBounds . height ) ; } resetTransform ( batch ) ; } public void fling ( float flingTime , float velocityX , float velocityY ) { this . flingTimer = flingTime ; this . velocityX = velocityX ; this . velocityY = velocityY ; } public float getPrefWidth ( ) { if ( widget instanceof Layout ) { float width = ( ( Layout ) widget ) . getPrefWidth ( ) ; if ( style . background ! = null ) width + = style . background . getLeftWidth ( ) + style . background . getRightWidth ( ) ; if ( forceScrollY ) { float scrollbarWidth = <int> ; if ( style . vScrollKnob ! = null ) scrollbarWidth = style . vScrollKnob . getMinWidth ( ) ; if ( style . vScroll ! = null ) scrollbarWidth = Math . max ( scrollbarWidth , style . vScroll . getMinWidth ( ) ) ; width + = scrollbarWidth ; } return width ; } return <int> ; } public float getPrefHeight ( ) { if ( widget instanceof Layout ) { float height = ( ( Layout ) widget ) . getPrefHeight ( ) ; if ( style . background ! = null ) height + = style . background . getTopHeight ( ) + style . background . getBottomHeight ( ) ; if ( forceScrollX ) { float scrollbarHeight = <int> ; if ( style . hScrollKnob ! = null ) scrollbarHeight = style . hScrollKnob . getMinHeight ( ) ; if ( style . hScroll ! = null ) scrollbarHeight = Math . max ( scrollbarHeight , style . hScroll . getMinHeight ( ) ) ; height + = scrollbarHeight ; } return height ; } return <int> ; } public float getMinWidth ( ) { return <int> ; } public float getMinHeight ( ) { return <int> ; } public void setWidget ( Actor widget ) { if ( widget = = this ) throw new IllegalArgumentException ( <str> ) ; if ( this . widget ! = null ) super . removeActor ( this . widget ) ; this . widget = widget ; if ( widget ! = null ) super . addActor ( widget ) ; } public Actor getWidget ( ) { return widget ; } public void addActor ( Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public void addActorAt ( int index , Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public void addActorBefore ( Actor actorBefore , Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public void addActorAfter ( Actor actorAfter , Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public boolean removeActor ( Actor actor ) { if ( actor ! = widget ) return false ; setWidget ( null ) ; return true ; } public Actor hit ( float x , float y , boolean touchable ) { if ( x < <int> | | x > = getWidth ( ) | | y < <int> | | y > = getHeight ( ) ) return null ; if ( scrollX & & hScrollBounds . contains ( x , y ) ) return this ; if ( scrollY & & vScrollBounds . contains ( x , y ) ) return this ; return super . hit ( x , y , touchable ) ; } protected void scrollX ( float pixelsX ) { this . amountX = pixelsX ; } protected void scrollY ( float pixelsY ) { this . amountY = pixelsY ; } protected void visualScrollX ( float pixelsX ) { this . visualAmountX = pixelsX ; } protected void visualScrollY ( float pixelsY ) { this . visualAmountY = pixelsY ; } protected float getMouseWheelX ( ) { return Math . max ( areaWidth * <float> , maxX * <float> ) / <int> ; } protected float getMouseWheelY ( ) { return Math . max ( areaHeight * <float> , maxY * <float> ) / <int> ; } public void setScrollX ( float pixels ) { scrollX ( MathUtils . clamp ( pixels , <int> , maxX ) ) ; } public float getScrollX ( ) { return amountX ; } public void setScrollY ( float pixels ) { scrollY ( MathUtils . clamp ( pixels , <int> , maxY ) ) ; } public float getScrollY ( ) { return amountY ; } public void updateVisualScroll ( ) { visualAmountX = amountX ; visualAmountY = amountY ; } public float getVisualScrollX ( ) { return ! scrollX ? <int> : visualAmountX ; } public float getVisualScrollY ( ) { return ! scrollY ? <int> : visualAmountY ; } public float getVisualScrollPercentX ( ) { return MathUtils . clamp ( visualAmountX / maxX , <int> , <int> ) ; } public float getVisualScrollPercentY ( ) { return MathUtils . clamp ( visualAmountY / maxY , <int> , <int> ) ; } public float getScrollPercentX ( ) { return MathUtils . clamp ( amountX / maxX , <int> , <int> ) ; } public void setScrollPercentX ( float percentX ) { scrollX ( maxX * MathUtils . clamp ( percentX , <int> , <int> ) ) ; } public float getScrollPercentY ( ) { return MathUtils . clamp ( amountY / maxY , <int> , <int> ) ; } public void setScrollPercentY ( float percentY ) { scrollY ( maxY * MathUtils . clamp ( percentY , <int> , <int> ) ) ; } public void setFlickScroll ( boolean flickScroll ) { if ( this . flickScroll = = flickScroll ) return ; this . flickScroll = flickScroll ; if ( flickScroll ) addListener ( flickScrollListener ) ; else removeListener ( flickScrollListener ) ; invalidate ( ) ; } public void setFlickScrollTapSquareSize ( float halfTapSquareSize ) { flickScrollListener . getGestureDetector ( ) . setTapSquareSize ( halfTapSquareSize ) ; } public void scrollTo ( float x , float y , float width , float height ) { scrollTo ( x , y , width , height , false , false ) ; } public void scrollTo ( float x , float y , float width , float height , boolean centerHorizontal , boolean centerVertical ) { float amountX = this . amountX ; if ( centerHorizontal ) { amountX = x - areaWidth / <int> + width / <int> ; } else { if ( x + width > amountX + areaWidth ) amountX = x + width - areaWidth ; if ( x < amountX ) amountX = x ; } scrollX ( MathUtils . clamp ( amountX , <int> , maxX ) ) ; float amountY = this . amountY ; if ( centerVertical ) { amountY = maxY - y + areaHeight / <int> - height / <int> ; } else { if ( amountY > maxY - y - height + areaHeight ) amountY = maxY - y - height + areaHeight ; if ( amountY < maxY - y ) amountY = maxY - y ; } scrollY ( MathUtils . clamp ( amountY , <int> , maxY ) ) ; } public float getMaxX ( ) { return maxX ; } public float getMaxY ( ) { return maxY ; } public float getScrollBarHeight ( ) { if ( ! scrollX ) return <int> ; float height = <int> ; if ( style . hScrollKnob ! = null ) height = style . hScrollKnob . getMinHeight ( ) ; if ( style . hScroll ! = null ) height = Math . max ( height , style . hScroll . getMinHeight ( ) ) ; return height ; } public float getScrollBarWidth ( ) { if ( ! scrollY ) return <int> ; float width = <int> ; if ( style . vScrollKnob ! = null ) width = style . vScrollKnob . getMinWidth ( ) ; if ( style . vScroll ! = null ) width = Math . max ( width , style . vScroll . getMinWidth ( ) ) ; return width ; } public float getScrollWidth ( ) { return areaWidth ; } public float getScrollHeight ( ) { return areaHeight ; } public boolean isScrollX ( ) { return scrollX ; } public boolean isScrollY ( ) { return scrollY ; } public void setScrollingDisabled ( boolean x , boolean y ) { disableX = x ; disableY = y ; } public boolean isScrollingDisabledX ( ) { return disableX ; } public boolean isScrollingDisabledY ( ) { return disableY ; } public boolean isLeftEdge ( ) { return ! scrollX | | amountX < = <int> ; } public boolean isRightEdge ( ) { return ! scrollX | | amountX > = maxX ; } public boolean isTopEdge ( ) { return ! scrollY | | amountY < = <int> ; } public boolean isBottomEdge ( ) { return ! scrollY | | amountY > = maxY ; } public boolean isDragging ( ) { return draggingPointer ! = - <int> ; } public boolean isPanning ( ) { return flickScrollListener . getGestureDetector ( ) . isPanning ( ) ; } public boolean isFlinging ( ) { return flingTimer > <int> ; } public void setVelocityX ( float velocityX ) { this . velocityX = velocityX ; } public float getVelocityX ( ) { return velocityX ; } public void setVelocityY ( float velocityY ) { this . velocityY = velocityY ; } public float getVelocityY ( ) { return velocityY ; } public void setOverscroll ( boolean overscrollX , boolean overscrollY ) { this . overscrollX = overscrollX ; this . overscrollY = overscrollY ; } public void setupOverscroll ( float distance , float speedMin , float speedMax ) { overscrollDistance = distance ; overscrollSpeedMin = speedMin ; overscrollSpeedMax = speedMax ; } public void setForceScroll ( boolean x , boolean y ) { forceScrollX = x ; forceScrollY = y ; } public boolean isForceScrollX ( ) { return forceScrollX ; } public boolean isForceScrollY ( ) { return forceScrollY ; } public void setFlingTime ( float flingTime ) { this . flingTime = flingTime ; } public void setClamp ( boolean clamp ) { this . clamp = clamp ; } public void setScrollBarPositions ( boolean bottom , boolean right ) { hScrollOnBottom = bottom ; vScrollOnRight = right ; } public void setFadeScrollBars ( boolean fadeScrollBars ) { if ( this . fadeScrollBars = = fadeScrollBars ) return ; this . fadeScrollBars = fadeScrollBars ; if ( ! fadeScrollBars ) fadeAlpha = fadeAlphaSeconds ; invalidate ( ) ; } public void setupFadeScrollBars ( float fadeAlphaSeconds , float fadeDelaySeconds ) { this . fadeAlphaSeconds = fadeAlphaSeconds ; this . fadeDelaySeconds = fadeDelaySeconds ; } public void setSmoothScrolling ( boolean smoothScrolling ) { this . smoothScrolling = smoothScrolling ; } public void setScrollbarsOnTop ( boolean scrollbarsOnTop ) { this . scrollbarsOnTop = scrollbarsOnTop ; invalidate ( ) ; } public boolean getVariableSizeKnobs ( ) { return variableSizeKnobs ; } public void setVariableSizeKnobs ( boolean variableSizeKnobs ) { this . variableSizeKnobs = variableSizeKnobs ; } public void setCancelTouchFocus ( boolean cancelTouchFocus ) { this . cancelTouchFocus = cancelTouchFocus ; } public void drawDebug ( ShapeRenderer shapes ) { shapes . flush ( ) ; applyTransform ( shapes , computeTransform ( ) ) ; if ( ScissorStack . pushScissors ( scissorBounds ) ) { drawDebugChildren ( shapes ) ; ScissorStack . popScissors ( ) ; } resetTransform ( shapes ) ; } static public class ScrollPaneStyle { public Drawable background , corner ; public Drawable hScroll , hScrollKnob ; public Drawable vScroll , vScrollKnob ; public ScrollPaneStyle ( ) { } public ScrollPaneStyle ( Drawable background , Drawable hScroll , Drawable hScrollKnob , Drawable vScroll , Drawable vScrollKnob ) { this . background = background ; this . hScroll = hScroll ; this . hScrollKnob = hScrollKnob ; this . vScroll = vScroll ; this . vScrollKnob = vScrollKnob ; } public ScrollPaneStyle ( ScrollPaneStyle style ) { this . background = style . background ; this . hScroll = style . hScroll ; this . hScrollKnob = style . hScrollKnob ; this . vScroll = style . vScroll ; this . vScrollKnob = style . vScrollKnob ; } } } 
