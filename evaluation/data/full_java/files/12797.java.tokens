package org . gradle . api . internal . notations ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . artifacts . ClientModule ; import org . gradle . api . artifacts . ExternalDependency ; import org . gradle . api . internal . artifacts . dsl . ParsedModuleStringNotation ; import org . gradle . api . internal . artifacts . dsl . dependencies . ModuleFactoryHelper ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . typeconversion . NotationConvertResult ; import org . gradle . internal . typeconversion . NotationConverter ; import org . gradle . internal . typeconversion . TypeConversionException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class DependencyStringNotationConverter < T extends ExternalDependency > implements NotationConverter < String , T > { private final Instantiator instantiator ; private final Class < T > wantedType ; public DependencyStringNotationConverter ( Instantiator instantiator , Class < T > wantedType ) { this . instantiator = instantiator ; this . wantedType = wantedType ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; } public void convert ( String notation , NotationConvertResult < ? super T > result ) throws TypeConversionException { result . converted ( createDependencyFromString ( notation ) ) ; } public static final Pattern EXTENSION_SPLITTER = Pattern . compile ( <str> ) ; private T createDependencyFromString ( String notation ) { ParsedModuleStringNotation parsedNotation = splitModuleFromExtension ( notation ) ; T moduleDependency = instantiator . newInstance ( wantedType , parsedNotation . getGroup ( ) , parsedNotation . getName ( ) , parsedNotation . getVersion ( ) ) ; ModuleFactoryHelper . addExplicitArtifactsIfDefined ( moduleDependency , parsedNotation . getArtifactType ( ) , parsedNotation . getClassifier ( ) ) ; return moduleDependency ; } private ParsedModuleStringNotation splitModuleFromExtension ( String notation ) { Matcher matcher = EXTENSION_SPLITTER . matcher ( notation ) ; boolean hasArtifactType = matcher . matches ( ) ; if ( hasArtifactType & & ! ClientModule . class . isAssignableFrom ( wantedType ) ) { if ( matcher . groupCount ( ) ! = <int> ) { throw new InvalidUserDataException ( <str> + notation + <str> ) ; } return new ParsedModuleStringNotation ( matcher . group ( <int> ) , matcher . group ( <int> ) ) ; } return new ParsedModuleStringNotation ( notation , null ) ; } } 
