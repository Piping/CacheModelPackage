package com . google . common . math ; import static com . google . common . math . StatsTesting . ALLOWED_ERROR ; import static com . google . common . math . StatsTesting . ALL_MANY_VALUES ; import static com . google . common . math . StatsTesting . ALL_STATS ; import static com . google . common . math . StatsTesting . EMPTY_STATS_ITERABLE ; import static com . google . common . math . StatsTesting . EMPTY_STATS_VARARGS ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_STATS_ITERABLE ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_STATS_VARARGS ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . LARGE_INTEGER_VALUES_MEAN ; import static com . google . common . math . StatsTesting . LARGE_INTEGER_VALUES_POPULATION_VARIANCE ; import static com . google . common . math . StatsTesting . LARGE_INTEGER_VALUES_STATS ; import static com . google . common . math . StatsTesting . LARGE_LONG_VALUES_MEAN ; import static com . google . common . math . StatsTesting . LARGE_LONG_VALUES_POPULATION_VARIANCE ; import static com . google . common . math . StatsTesting . LARGE_LONG_VALUES_STATS ; import static com . google . common . math . StatsTesting . LARGE_VALUES_MEAN ; import static com . google . common . math . StatsTesting . LARGE_VALUES_STATS ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_STATS_ITERATOR ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_STATS_SNAPSHOT ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . MANY_VALUES ; import static com . google . common . math . StatsTesting . MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . MANY_VALUES_STATS_ITERABLE ; import static com . google . common . math . StatsTesting . MANY_VALUES_STATS_ITERATOR ; import static com . google . common . math . StatsTesting . MANY_VALUES_STATS_SNAPSHOT ; import static com . google . common . math . StatsTesting . MANY_VALUES_STATS_VARARGS ; import static com . google . common . math . StatsTesting . MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . ONE_VALUE ; import static com . google . common . math . StatsTesting . ONE_VALUE_STATS ; import static com . google . common . math . StatsTesting . TWO_VALUES ; import static com . google . common . math . StatsTesting . TWO_VALUES_MAX ; import static com . google . common . math . StatsTesting . TWO_VALUES_MEAN ; import static com . google . common . math . StatsTesting . TWO_VALUES_MIN ; import static com . google . common . math . StatsTesting . TWO_VALUES_STATS ; import static com . google . common . math . StatsTesting . TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Double . NEGATIVE_INFINITY ; import static java . lang . Double . NaN ; import static java . lang . Double . POSITIVE_INFINITY ; import static java . lang . Math . sqrt ; import com . google . common . collect . ImmutableList ; import com . google . common . math . StatsTesting . ManyValues ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . nio . ByteBuffer ; public class StatsTest extends TestCase { public void testCount ( ) { assertThat ( EMPTY_STATS_VARARGS . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( EMPTY_STATS_ITERABLE . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( ONE_VALUE_STATS . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( TWO_VALUES_STATS . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( MANY_VALUES_STATS_VARARGS . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . count ( ) ) . isEqualTo ( INTEGER_MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . count ( ) ) . isEqualTo ( INTEGER_MANY_VALUES_COUNT ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . count ( ) ) . isEqualTo ( LONG_MANY_VALUES_COUNT ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . count ( ) ) . isEqualTo ( LONG_MANY_VALUES_COUNT ) ; } public void testMean ( ) { try { EMPTY_STATS_VARARGS . mean ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . mean ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( ONE_VALUE_STATS . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( Stats . of ( POSITIVE_INFINITY ) . mean ( ) ) . isPositiveInfinity ( ) ; assertThat ( Stats . of ( NEGATIVE_INFINITY ) . mean ( ) ) . isNegativeInfinity ( ) ; assertThat ( Stats . of ( NaN ) . mean ( ) ) . isNaN ( ) ; assertThat ( TWO_VALUES_STATS . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MEAN ) ; for ( ManyValues values : ALL_MANY_VALUES ) { double mean = Stats . of ( values . asArray ( ) ) . mean ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) & & values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isPositiveInfinity ( ) ; } else if ( values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNegativeInfinity ( ) ; } else { assertThat ( mean ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; } } assertThat ( MANY_VALUES_STATS_ITERABLE . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( LARGE_VALUES_STATS . mean ( ) ) . isWithin ( ALLOWED_ERROR * Double . MAX_VALUE ) . of ( LARGE_VALUES_MEAN ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN ) ; assertThat ( LARGE_INTEGER_VALUES_STATS . mean ( ) ) . isWithin ( ALLOWED_ERROR * Integer . MAX_VALUE ) . of ( LARGE_INTEGER_VALUES_MEAN ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; assertThat ( LARGE_LONG_VALUES_STATS . mean ( ) ) . isWithin ( ALLOWED_ERROR * Long . MAX_VALUE ) . of ( LARGE_LONG_VALUES_MEAN ) ; } public void testSum ( ) { assertThat ( EMPTY_STATS_VARARGS . sum ( ) ) . isEqualTo ( <float> ) ; assertThat ( EMPTY_STATS_ITERABLE . sum ( ) ) . isEqualTo ( <float> ) ; assertThat ( ONE_VALUE_STATS . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( TWO_VALUES_STATS . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MEAN * <int> ) ; assertThat ( MANY_VALUES_STATS_VARARGS . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT ) ; } public void testPopulationVariance ( ) { try { EMPTY_STATS_VARARGS . populationVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . populationVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( ONE_VALUE_STATS . populationVariance ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( Stats . of ( POSITIVE_INFINITY ) . populationVariance ( ) ) . isNaN ( ) ; assertThat ( Stats . of ( NEGATIVE_INFINITY ) . populationVariance ( ) ) . isNaN ( ) ; assertThat ( Stats . of ( NaN ) . populationVariance ( ) ) . isNaN ( ) ; assertThat ( TWO_VALUES_STATS . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / <int> ) ; assertThat ( MANY_VALUES_STATS_VARARGS . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; for ( ManyValues values : ALL_MANY_VALUES ) { double populationVariance = Stats . of ( values . asIterable ( ) ) . populationVariance ( ) ; if ( values . hasAnyNonFinite ( ) ) { assertThat ( populationVariance ) . named ( <str> + values ) . isNaN ( ) ; } else { assertThat ( populationVariance ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; } } assertThat ( MANY_VALUES_STATS_ITERATOR . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ; assertThat ( LARGE_INTEGER_VALUES_STATS . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR * Integer . MAX_VALUE * Integer . MAX_VALUE ) . of ( LARGE_INTEGER_VALUES_POPULATION_VARIANCE ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ; assertThat ( LARGE_LONG_VALUES_STATS . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR * Long . MAX_VALUE * Long . MAX_VALUE ) . of ( LARGE_LONG_VALUES_POPULATION_VARIANCE ) ; } public void testPopulationStandardDeviation ( ) { try { EMPTY_STATS_VARARGS . populationStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . populationStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( ONE_VALUE_STATS . populationStandardDeviation ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( TWO_VALUES_STATS . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / <int> ) ) ; assertThat ( MANY_VALUES_STATS_VARARGS . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ) ; } public void testSampleVariance ( ) { try { EMPTY_STATS_VARARGS . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { ONE_VALUE_STATS . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( TWO_VALUES_STATS . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ; assertThat ( MANY_VALUES_STATS_VARARGS . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ; } public void testSampleStandardDeviation ( ) { try { EMPTY_STATS_VARARGS . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { ONE_VALUE_STATS . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( TWO_VALUES_STATS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) ; assertThat ( MANY_VALUES_STATS_VARARGS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( MANY_VALUES_STATS_SNAPSHOT . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ) ; } public void testMax ( ) { try { EMPTY_STATS_VARARGS . max ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . max ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( ONE_VALUE_STATS . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( Stats . of ( POSITIVE_INFINITY ) . max ( ) ) . isPositiveInfinity ( ) ; assertThat ( Stats . of ( NEGATIVE_INFINITY ) . max ( ) ) . isNegativeInfinity ( ) ; assertThat ( Stats . of ( NaN ) . max ( ) ) . isNaN ( ) ; assertThat ( TWO_VALUES_STATS . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MAX ) ; assertThat ( MANY_VALUES_STATS_VARARGS . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; for ( ManyValues values : ALL_MANY_VALUES ) { double max = Stats . of ( values . asIterable ( ) . iterator ( ) ) . max ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( max ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) ) { assertThat ( max ) . named ( <str> + values ) . isPositiveInfinity ( ) ; } else { assertThat ( max ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; } } assertThat ( MANY_VALUES_STATS_SNAPSHOT . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MAX ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MAX ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MAX ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MAX ) ; } public void testMin ( ) { try { EMPTY_STATS_VARARGS . min ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { EMPTY_STATS_ITERABLE . min ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( ONE_VALUE_STATS . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( Stats . of ( POSITIVE_INFINITY ) . min ( ) ) . isPositiveInfinity ( ) ; assertThat ( Stats . of ( NEGATIVE_INFINITY ) . min ( ) ) . isNegativeInfinity ( ) ; assertThat ( Stats . of ( NaN ) . min ( ) ) . isNaN ( ) ; assertThat ( TWO_VALUES_STATS . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MIN ) ; assertThat ( MANY_VALUES_STATS_VARARGS . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; assertThat ( MANY_VALUES_STATS_ITERABLE . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; assertThat ( MANY_VALUES_STATS_ITERATOR . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; for ( ManyValues values : ALL_MANY_VALUES ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values . asIterable ( ) ) ; double min = accumulator . snapshot ( ) . min ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( min ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyNegativeInfinity ( ) ) { assertThat ( min ) . named ( <str> + values ) . isNegativeInfinity ( ) ; } else { assertThat ( min ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; } } assertThat ( INTEGER_MANY_VALUES_STATS_VARARGS . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MIN ) ; assertThat ( INTEGER_MANY_VALUES_STATS_ITERABLE . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MIN ) ; assertThat ( LONG_MANY_VALUES_STATS_ITERATOR . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MIN ) ; assertThat ( LONG_MANY_VALUES_STATS_SNAPSHOT . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MIN ) ; } public void testEqualsAndHashCode ( ) { new EqualsTester ( ) . addEqualityGroup ( Stats . of ( <float> , <float> , <float> , <float> ) , Stats . of ( <float> , <float> , <float> , <float> ) , Stats . of ( ImmutableList . of ( <float> , <float> , <float> , <float> ) ) , Stats . of ( ImmutableList . of ( <float> , <float> , <float> , <float> ) . iterator ( ) ) , SerializableTester . reserialize ( Stats . of ( <float> , <float> , <float> , <float> ) ) ) . addEqualityGroup ( Stats . of ( <float> , <float> ) ) . addEqualityGroup ( Stats . of ( <float> , <float> , <float> , <float> ) ) . addEqualityGroup ( Stats . of ( <float> , <float> , <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) , new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . addEqualityGroup ( new Stats ( <int> , - <float> , <float> , - <float> , <float> ) ) . testEquals ( ) ; } public void testSerializable ( ) { SerializableTester . reserializeAndAssert ( MANY_VALUES_STATS_ITERABLE ) ; } public void testMeanOf ( ) { try { Stats . meanOf ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { Stats . meanOf ( ImmutableList . < Number > of ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertThat ( Stats . meanOf ( ONE_VALUE ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( Stats . meanOf ( POSITIVE_INFINITY ) ) . isPositiveInfinity ( ) ; assertThat ( Stats . meanOf ( NEGATIVE_INFINITY ) ) . isNegativeInfinity ( ) ; assertThat ( Stats . meanOf ( NaN ) ) . isNaN ( ) ; assertThat ( Stats . meanOf ( TWO_VALUES ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MEAN ) ; for ( ManyValues values : ALL_MANY_VALUES ) { double mean = Stats . meanOf ( values . asArray ( ) ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) & & values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isPositiveInfinity ( ) ; } else if ( values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNegativeInfinity ( ) ; } else { assertThat ( mean ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; } } assertThat ( Stats . meanOf ( MANY_VALUES ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( Stats . meanOf ( MANY_VALUES . iterator ( ) ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( Stats . meanOf ( INTEGER_MANY_VALUES ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN ) ; assertThat ( Stats . meanOf ( Ints . toArray ( INTEGER_MANY_VALUES ) ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN ) ; assertThat ( Stats . meanOf ( LONG_MANY_VALUES ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; assertThat ( Stats . meanOf ( Longs . toArray ( LONG_MANY_VALUES ) ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; } public void testToByteArrayAndFromByteArrayRoundTrip ( ) { for ( Stats stats : ALL_STATS ) { byte [ ] statsByteArray = stats . toByteArray ( ) ; assertThat ( statsByteArray . length ) . isEqualTo ( Stats . BYTES ) ; assertThat ( Stats . fromByteArray ( statsByteArray ) ) . isEqualTo ( stats ) ; } } public void testFromByteArray_withNullInputThrowsNullPointerException ( ) { try { Stats . fromByteArray ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testFromByteArray_withEmptyArrayInputThrowsIllegalArgumentException ( ) { try { Stats . fromByteArray ( new byte [ <int> ] ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testFromByteArray_withTooLongArrayInputToIsParsedSuccesfuly ( ) { byte [ ] tooLongByteArray = ByteBuffer . allocate ( Stats . BYTES + <int> ) . put ( MANY_VALUES_STATS_VARARGS . toByteArray ( ) ) . putChar ( <str> ) . array ( ) ; assertThat ( Stats . fromByteArray ( tooLongByteArray ) ) . isEqualTo ( MANY_VALUES_STATS_VARARGS ) ; } public void testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException ( ) { byte [ ] tooShortByteArray = ByteBuffer . allocate ( Stats . BYTES - <int> ) . put ( MANY_VALUES_STATS_VARARGS . toByteArray ( ) , <int> , Stats . BYTES - <int> ) . array ( ) ; try { Stats . fromByteArray ( tooShortByteArray ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } 
