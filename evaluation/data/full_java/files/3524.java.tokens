package org . eclipse . core . internal . variables ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Stack ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . variables . IDynamicVariable ; import org . eclipse . core . variables . IStringVariableManager ; import org . eclipse . core . variables . IValueVariable ; import org . eclipse . core . variables . VariablesPlugin ; import org . eclipse . osgi . util . NLS ; public class StringSubstitutionEngine { private static final String VARIABLE_START = <str> ; private static final char VARIABLE_END = <str> ; private static final char VARIABLE_ARG = <str> ; private static final int SCAN_FOR_START = <int> ; private static final int SCAN_FOR_END = <int> ; private StringBuffer fResult ; private boolean fSubs ; private Stack < VariableReference > fStack ; class VariableReference { private StringBuffer fText ; public VariableReference ( ) { fText = new StringBuffer ( ) ; } public void append ( String text ) { fText . append ( text ) ; } public String getText ( ) { return fText . toString ( ) ; } } public String performStringSubstitution ( String expression , boolean reportUndefinedVariables , boolean resolveVariables , IStringVariableManager manager ) throws CoreException { substitute ( expression , reportUndefinedVariables , resolveVariables , manager ) ; List < HashSet < String > > resolvedVariableSets = new ArrayList < HashSet < String > > ( ) ; while ( fSubs ) { HashSet < String > resolved = substitute ( fResult . toString ( ) , reportUndefinedVariables , true , manager ) ; for ( int i = resolvedVariableSets . size ( ) - <int> ; i > = <int> ; i - - ) { HashSet < String > prevSet = resolvedVariableSets . get ( i ) ; if ( prevSet . equals ( resolved ) ) { HashSet < String > conflictingSet = new HashSet < String > ( ) ; for ( ; i < resolvedVariableSets . size ( ) ; i + + ) { conflictingSet . addAll ( resolvedVariableSets . get ( i ) ) ; } StringBuffer problemVariableList = new StringBuffer ( ) ; for ( String string : conflictingSet ) { problemVariableList . append ( string ) ; problemVariableList . append ( <str> ) ; } problemVariableList . setLength ( problemVariableList . length ( ) - <int> ) ; throw new CoreException ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . REFERENCE_CYCLE_ERROR , NLS . bind ( VariablesMessages . StringSubstitutionEngine_4 , new String [ ] { problemVariableList . toString ( ) } ) , null ) ) ; } } resolvedVariableSets . add ( resolved ) ; } return fResult . toString ( ) ; } public void validateStringVariables ( String expression , IStringVariableManager manager ) throws CoreException { performStringSubstitution ( expression , true , false , manager ) ; } private HashSet < String > substitute ( String expression , boolean reportUndefinedVariables , boolean resolveVariables , IStringVariableManager manager ) throws CoreException { fResult = new StringBuffer ( expression . length ( ) ) ; fStack = new Stack < VariableReference > ( ) ; fSubs = false ; HashSet < String > resolvedVariables = new HashSet < String > ( ) ; int pos = <int> ; int state = SCAN_FOR_START ; while ( pos < expression . length ( ) ) { switch ( state ) { case SCAN_FOR_START : int start = expression . indexOf ( VARIABLE_START , pos ) ; if ( start > = <int> ) { int length = start - pos ; if ( length > <int> ) { fResult . append ( expression . substring ( pos , start ) ) ; } pos = start + <int> ; state = SCAN_FOR_END ; fStack . push ( new VariableReference ( ) ) ; } else { fResult . append ( expression . substring ( pos ) ) ; pos = expression . length ( ) ; } break ; case SCAN_FOR_END : start = expression . indexOf ( VARIABLE_START , pos ) ; int end = expression . indexOf ( VARIABLE_END , pos ) ; if ( end < <int> ) { VariableReference tos = fStack . peek ( ) ; tos . append ( expression . substring ( pos ) ) ; pos = expression . length ( ) ; } else { if ( start > = <int> & & start < end ) { int length = start - pos ; if ( length > <int> ) { VariableReference tos = fStack . peek ( ) ; tos . append ( expression . substring ( pos , start ) ) ; } pos = start + <int> ; fStack . push ( new VariableReference ( ) ) ; } else { VariableReference tos = fStack . pop ( ) ; String substring = expression . substring ( pos , end ) ; tos . append ( substring ) ; resolvedVariables . add ( substring ) ; pos = end + <int> ; String value = resolve ( tos , reportUndefinedVariables , resolveVariables , manager ) ; if ( value = = null ) { value = <str> ; } if ( fStack . isEmpty ( ) ) { fResult . append ( value ) ; state = SCAN_FOR_START ; } else { tos = fStack . peek ( ) ; tos . append ( value ) ; } } } break ; default : break ; } } while ( ! fStack . isEmpty ( ) ) { VariableReference tos = fStack . pop ( ) ; if ( fStack . isEmpty ( ) ) { fResult . append ( VARIABLE_START ) ; fResult . append ( tos . getText ( ) ) ; } else { VariableReference var = fStack . peek ( ) ; var . append ( VARIABLE_START ) ; var . append ( tos . getText ( ) ) ; } } return resolvedVariables ; } private String resolve ( VariableReference var , boolean reportUndefinedVariables , boolean resolveVariables , IStringVariableManager manager ) throws CoreException { String text = var . getText ( ) ; int pos = text . indexOf ( VARIABLE_ARG ) ; String name = null ; String arg = null ; if ( pos > <int> ) { name = text . substring ( <int> , pos ) ; pos + + ; if ( pos < text . length ( ) ) { arg = text . substring ( pos ) ; } } else { name = text ; } IValueVariable valueVariable = manager . getValueVariable ( name ) ; if ( valueVariable = = null ) { IDynamicVariable dynamicVariable = manager . getDynamicVariable ( name ) ; if ( dynamicVariable = = null ) { if ( reportUndefinedVariables ) { throw new CoreException ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . INTERNAL_ERROR , NLS . bind ( VariablesMessages . StringSubstitutionEngine_3 , new String [ ] { name } ) , null ) ) ; } return getOriginalVarText ( var ) ; } if ( resolveVariables ) { fSubs = true ; return dynamicVariable . getValue ( arg ) ; } return getOriginalVarText ( var ) ; } if ( arg = = null ) { if ( resolveVariables ) { fSubs = true ; return valueVariable . getValue ( ) ; } return getOriginalVarText ( var ) ; } throw new CoreException ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . INTERNAL_ERROR , NLS . bind ( VariablesMessages . StringSubstitutionEngine_4 , new String [ ] { valueVariable . getName ( ) } ) , null ) ) ; } private String getOriginalVarText ( VariableReference var ) { StringBuffer res = new StringBuffer ( var . getText ( ) ) ; res . insert ( <int> , VARIABLE_START ) ; res . append ( VARIABLE_END ) ; return res . toString ( ) ; } } 
