package org . elasticsearch . search . aggregations . bucket . terms ; import org . apache . lucene . util . automaton . RegExp ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . ValuesSourceAggregationBuilder ; import java . io . IOException ; import java . util . Locale ; public class TermsBuilder extends ValuesSourceAggregationBuilder < TermsBuilder > { private TermsAggregator . BucketCountThresholds bucketCountThresholds = new TermsAggregator . BucketCountThresholds ( - <int> , - <int> , - <int> , - <int> ) ; private Terms . ValueType valueType ; private Terms . Order order ; private String includePattern ; private String excludePattern ; private String executionHint ; private SubAggCollectionMode collectionMode ; private Boolean showTermDocCountError ; private String [ ] includeTerms = null ; private String [ ] excludeTerms = null ; public TermsBuilder ( String name ) { super ( name , <str> ) ; } public TermsBuilder size ( int size ) { bucketCountThresholds . setRequiredSize ( size ) ; return this ; } public TermsBuilder shardSize ( int shardSize ) { bucketCountThresholds . setShardSize ( shardSize ) ; return this ; } public TermsBuilder minDocCount ( long minDocCount ) { bucketCountThresholds . setMinDocCount ( minDocCount ) ; return this ; } public TermsBuilder shardMinDocCount ( long shardMinDocCount ) { bucketCountThresholds . setShardMinDocCount ( shardMinDocCount ) ; return this ; } public TermsBuilder include ( String regex ) { if ( includeTerms ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includePattern = regex ; return this ; } public TermsBuilder include ( String [ ] terms ) { if ( includePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includeTerms = terms ; return this ; } public TermsBuilder include ( long [ ] terms ) { if ( includePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includeTerms = longsArrToStringArr ( terms ) ; return this ; } private String [ ] longsArrToStringArr ( long [ ] terms ) { String [ ] termsAsString = new String [ terms . length ] ; for ( int i = <int> ; i < terms . length ; i + + ) { termsAsString [ i ] = Long . toString ( terms [ i ] ) ; } return termsAsString ; } public TermsBuilder include ( double [ ] terms ) { if ( includePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includeTerms = doubleArrToStringArr ( terms ) ; return this ; } private String [ ] doubleArrToStringArr ( double [ ] terms ) { String [ ] termsAsString = new String [ terms . length ] ; for ( int i = <int> ; i < terms . length ; i + + ) { termsAsString [ i ] = Double . toString ( terms [ i ] ) ; } return termsAsString ; } public TermsBuilder exclude ( String regex ) { if ( excludeTerms ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludePattern = regex ; return this ; } public TermsBuilder exclude ( String [ ] terms ) { if ( excludePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludeTerms = terms ; return this ; } public TermsBuilder exclude ( long [ ] terms ) { if ( excludePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludeTerms = longsArrToStringArr ( terms ) ; return this ; } public TermsBuilder exclude ( double [ ] terms ) { if ( excludePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludeTerms = doubleArrToStringArr ( terms ) ; return this ; } public TermsBuilder valueType ( Terms . ValueType valueType ) { this . valueType = valueType ; return this ; } public TermsBuilder order ( Terms . Order order ) { this . order = order ; return this ; } public TermsBuilder executionHint ( String executionHint ) { this . executionHint = executionHint ; return this ; } public TermsBuilder collectMode ( SubAggCollectionMode mode ) { this . collectionMode = mode ; return this ; } public TermsBuilder showTermDocCountError ( boolean showTermDocCountError ) { this . showTermDocCountError = showTermDocCountError ; return this ; } @Override protected XContentBuilder doInternalXContent ( XContentBuilder builder , Params params ) throws IOException { bucketCountThresholds . toXContent ( builder ) ; if ( showTermDocCountError ! = null ) { builder . field ( AbstractTermsParametersParser . SHOW_TERM_DOC_COUNT_ERROR . getPreferredName ( ) , showTermDocCountError ) ; } if ( executionHint ! = null ) { builder . field ( AbstractTermsParametersParser . EXECUTION_HINT_FIELD_NAME . getPreferredName ( ) , executionHint ) ; } if ( valueType ! = null ) { builder . field ( <str> , valueType . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( order ! = null ) { builder . field ( <str> ) ; order . toXContent ( builder , params ) ; } if ( collectionMode ! = null ) { builder . field ( SubAggCollectionMode . KEY . getPreferredName ( ) , collectionMode . parseField ( ) . getPreferredName ( ) ) ; } if ( includeTerms ! = null ) { builder . array ( <str> , includeTerms ) ; } if ( includePattern ! = null ) { builder . field ( <str> , includePattern ) ; } if ( excludeTerms ! = null ) { builder . array ( <str> , excludeTerms ) ; } if ( excludePattern ! = null ) { builder . field ( <str> , excludePattern ) ; } return builder ; } } 
