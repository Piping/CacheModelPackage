package org . gradle . process . internal ; import com . google . common . base . Joiner ; import net . rubygrapefruit . platform . ProcessLauncher ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . concurrent . DefaultExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . internal . nativeintegration . services . NativeServices ; import org . gradle . internal . event . ListenerBroadcast ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . shutdown . ShutdownHookActionRegister ; import org . gradle . process . internal . streams . StreamsHandler ; import java . io . File ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultExecHandle implements ExecHandle , ProcessSettings { private static final Logger LOGGER = Logging . getLogger ( DefaultExecHandle . class ) ; private final String displayName ; private final File directory ; private final String command ; private final List < String > arguments ; private final Map < String , String > environment ; private final StreamsHandler streamsHandler ; private final boolean redirectErrorStream ; private final ProcessLauncher processLauncher ; private final DefaultExecutorFactory executorFactory = new DefaultExecutorFactory ( ) ; private int timeoutMillis ; private boolean daemon ; private final Lock lock ; private final Condition condition ; private final StoppableExecutor executor ; private ExecHandleState state ; private ExecHandleRunner execHandleRunner ; private ExecResultImpl execResult ; private final ListenerBroadcast < ExecHandleListener > broadcast ; private final ExecHandleShutdownHookAction shutdownHookAction ; DefaultExecHandle ( String displayName , File directory , String command , List < String > arguments , Map < String , String > environment , StreamsHandler streamsHandler , List < ExecHandleListener > listeners , boolean redirectErrorStream , int timeoutMillis , boolean daemon ) { this . displayName = displayName ; this . directory = directory ; this . command = command ; this . arguments = arguments ; this . environment = environment ; this . streamsHandler = streamsHandler ; this . redirectErrorStream = redirectErrorStream ; this . timeoutMillis = timeoutMillis ; this . daemon = daemon ; this . lock = new ReentrantLock ( ) ; this . condition = lock . newCondition ( ) ; this . state = ExecHandleState . INIT ; executor = executorFactory . create ( String . format ( <str> , displayName ) ) ; processLauncher = NativeServices . getInstance ( ) . get ( ProcessLauncher . class ) ; shutdownHookAction = new ExecHandleShutdownHookAction ( this ) ; broadcast = new ListenerBroadcast < ExecHandleListener > ( ExecHandleListener . class ) ; broadcast . addAll ( listeners ) ; } public File getDirectory ( ) { return directory ; } public String getCommand ( ) { return command ; } public boolean isDaemon ( ) { return daemon ; } @Override public String toString ( ) { return displayName ; } public List < String > getArguments ( ) { return Collections . unmodifiableList ( arguments ) ; } public Map < String , String > getEnvironment ( ) { return Collections . unmodifiableMap ( environment ) ; } public ExecHandleState getState ( ) { lock . lock ( ) ; try { return state ; } finally { lock . unlock ( ) ; } } private void setState ( ExecHandleState state ) { lock . lock ( ) ; try { LOGGER . debug ( <str> , state ) ; this . state = state ; this . condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private boolean stateIn ( ExecHandleState . . . states ) { lock . lock ( ) ; try { return Arrays . asList ( states ) . contains ( this . state ) ; } finally { lock . unlock ( ) ; } } private void setEndStateInfo ( ExecHandleState newState , int exitValue , Throwable failureCause ) { ShutdownHookActionRegister . removeAction ( shutdownHookAction ) ; ExecResultImpl result ; ExecHandleState currentState ; lock . lock ( ) ; try { currentState = this . state ; ExecException wrappedException = null ; if ( failureCause ! = null ) { if ( currentState = = ExecHandleState . STARTING ) { wrappedException = new ExecException ( String . format ( <str> , displayName ) , failureCause ) ; } else { wrappedException = new ExecException ( String . format ( <str> , displayName ) , failureCause ) ; } } setState ( newState ) ; execResult = new ExecResultImpl ( exitValue , wrappedException , displayName ) ; result = execResult ; } finally { lock . unlock ( ) ; } LOGGER . debug ( <str> , displayName , exitValue , newState ) ; if ( currentState ! = ExecHandleState . DETACHED & & newState ! = ExecHandleState . DETACHED ) { broadcast . getSource ( ) . executionFinished ( this , result ) ; } executor . requestStop ( ) ; } public ExecHandle start ( ) { LOGGER . info ( <str> , displayName , directory , command + <str> + Joiner . on ( <str> ) . useForNull ( <str> ) . join ( arguments ) ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( <str> , displayName , environment ) ; } lock . lock ( ) ; try { if ( ! stateIn ( ExecHandleState . INIT ) ) { throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; } setState ( ExecHandleState . STARTING ) ; execHandleRunner = new ExecHandleRunner ( this , streamsHandler , processLauncher , executorFactory ) ; executor . execute ( execHandleRunner ) ; while ( stateIn ( ExecHandleState . STARTING ) ) { LOGGER . debug ( <str> , displayName ) ; try { condition . await ( ) ; } catch ( InterruptedException e ) { } } if ( execResult ! = null ) { execResult . rethrowFailure ( ) ; } LOGGER . info ( <str> , displayName ) ; } finally { lock . unlock ( ) ; } return this ; } public void abort ( ) { lock . lock ( ) ; try { if ( state = = ExecHandleState . SUCCEEDED ) { return ; } if ( ! stateIn ( ExecHandleState . STARTED , ExecHandleState . DETACHED ) ) { throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; } this . execHandleRunner . abortProcess ( ) ; this . waitForFinish ( ) ; } finally { lock . unlock ( ) ; } } public ExecResult waitForFinish ( ) { lock . lock ( ) ; try { while ( ! stateIn ( ExecHandleState . SUCCEEDED , ExecHandleState . ABORTED , ExecHandleState . FAILED , ExecHandleState . DETACHED ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { } } } finally { lock . unlock ( ) ; } executor . stop ( ) ; return result ( ) ; } private ExecResult result ( ) { lock . lock ( ) ; try { execResult . rethrowFailure ( ) ; return execResult ; } finally { lock . unlock ( ) ; } } void detached ( ) { setEndStateInfo ( ExecHandleState . DETACHED , <int> , null ) ; } void started ( ) { ShutdownHookActionRegister . addAction ( shutdownHookAction ) ; setState ( ExecHandleState . STARTED ) ; broadcast . getSource ( ) . executionStarted ( this ) ; } void finished ( int exitCode ) { if ( exitCode ! = <int> ) { setEndStateInfo ( ExecHandleState . FAILED , exitCode , null ) ; } else { setEndStateInfo ( ExecHandleState . SUCCEEDED , <int> , null ) ; } } void aborted ( int exitCode ) { if ( exitCode = = <int> ) { exitCode = - <int> ; } setEndStateInfo ( ExecHandleState . ABORTED , exitCode , null ) ; } void failed ( Throwable failureCause ) { setEndStateInfo ( ExecHandleState . FAILED , - <int> , failureCause ) ; } public void addListener ( ExecHandleListener listener ) { broadcast . add ( listener ) ; } public void removeListener ( ExecHandleListener listener ) { broadcast . remove ( listener ) ; } public String getDisplayName ( ) { return displayName ; } public boolean getRedirectErrorStream ( ) { return redirectErrorStream ; } public int getTimeout ( ) { return timeoutMillis ; } private static class ExecResultImpl implements ExecResult { private final int exitValue ; private final ExecException failure ; private final String displayName ; public ExecResultImpl ( int exitValue , ExecException failure , String displayName ) { this . exitValue = exitValue ; this . failure = failure ; this . displayName = displayName ; } public int getExitValue ( ) { return exitValue ; } public ExecResult assertNormalExitValue ( ) throws ExecException { if ( exitValue ! = <int> ) { throw new ExecException ( String . format ( <str> , displayName , exitValue ) ) ; } return this ; } public ExecResult rethrowFailure ( ) throws ExecException { if ( failure ! = null ) { throw failure ; } return this ; } @Override public String toString ( ) { return <str> + exitValue + <str> + failure + <str> ; } } } 
