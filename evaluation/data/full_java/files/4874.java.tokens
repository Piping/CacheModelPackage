package org . apache . lucene . analysis . miscellaneous ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . CharTermAttribute ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . analysis . util . CharArraySet ; import java . io . IOException ; public class UniqueTokenFilter extends TokenFilter { private final CharTermAttribute termAttribute = addAttribute ( CharTermAttribute . class ) ; private final PositionIncrementAttribute posIncAttribute = addAttribute ( PositionIncrementAttribute . class ) ; private final CharArraySet previous = new CharArraySet ( <int> , false ) ; private final boolean onlyOnSamePosition ; public UniqueTokenFilter ( TokenStream in ) { this ( in , false ) ; } public UniqueTokenFilter ( TokenStream in , boolean onlyOnSamePosition ) { super ( in ) ; this . onlyOnSamePosition = onlyOnSamePosition ; } @Override public final boolean incrementToken ( ) throws IOException { while ( input . incrementToken ( ) ) { final char term [ ] = termAttribute . buffer ( ) ; final int length = termAttribute . length ( ) ; boolean duplicate ; if ( onlyOnSamePosition ) { final int posIncrement = posIncAttribute . getPositionIncrement ( ) ; if ( posIncrement > <int> ) { previous . clear ( ) ; } duplicate = ( posIncrement = = <int> & & previous . contains ( term , <int> , length ) ) ; } else { duplicate = previous . contains ( term , <int> , length ) ; } char saved [ ] = new char [ length ] ; System . arraycopy ( term , <int> , saved , <int> , length ) ; previous . add ( saved ) ; if ( ! duplicate ) { return true ; } } return false ; } @Override public final void reset ( ) throws IOException { super . reset ( ) ; previous . clear ( ) ; } } 
