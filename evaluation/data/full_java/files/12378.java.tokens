package org . gradle . api . internal . file ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . internal . file . collections . DirectoryFileTree ; import org . gradle . api . internal . file . collections . FileCollectionResolveContext ; import org . gradle . api . internal . file . collections . MinimalFileSet ; import org . gradle . api . internal . tasks . TaskDependencyResolveContext ; import org . gradle . api . specs . Spec ; import org . gradle . testfixtures . internal . NativeServicesTestFixture ; import org . gradle . util . JUnit4GroovyMockery ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import static org . gradle . util . WrapUtil . * ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class CompositeFileCollectionTest { private final JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; private final AbstractFileCollection source1 = context . mock ( AbstractFileCollection . class , <str> ) ; private final AbstractFileCollection source2 = context . mock ( AbstractFileCollection . class , <str> ) ; private final TestCompositeFileCollection collection = new TestCompositeFileCollection ( source1 , source2 ) ; @Before public void setUp ( ) { NativeServicesTestFixture . initialize ( ) ; } @Test public void containsUnionOfAllSourceCollections ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; final File file3 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . getFiles ( ) ; will ( returnValue ( toSet ( file1 , file2 ) ) ) ; one ( source2 ) . getFiles ( ) ; will ( returnValue ( toSet ( file2 , file3 ) ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 , file3 ) ) ) ; } @Test public void contentsTrackContentsOfSourceCollections ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; final File file3 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { allowing ( source1 ) . getFiles ( ) ; will ( returnValue ( toSet ( file1 ) ) ) ; exactly ( <int> ) . of ( source2 ) . getFiles ( ) ; will ( onConsecutiveCalls ( returnValue ( toSet ( file2 , file3 ) ) , returnValue ( toSet ( file3 ) ) ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 , file3 ) ) ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file3 ) ) ) ; } @Test public void containsFileWhenAtLeastOneSourceCollectionContainsFile ( ) { final File file1 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . contains ( file1 ) ; will ( returnValue ( false ) ) ; one ( source2 ) . contains ( file1 ) ; will ( returnValue ( true ) ) ; } } ) ; assertTrue ( collection . contains ( file1 ) ) ; } @Test public void doesNotContainFileWhenNoSourceCollectionsContainFile ( ) { final File file1 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . contains ( file1 ) ; will ( returnValue ( false ) ) ; one ( source2 ) . contains ( file1 ) ; will ( returnValue ( false ) ) ; } } ) ; assertFalse ( collection . contains ( file1 ) ) ; } @Test public void isEmptyWhenHasNoSets ( ) { CompositeFileCollection set = new TestCompositeFileCollection ( ) ; assertTrue ( set . isEmpty ( ) ) ; } @Test public void isEmptyWhenAllSetsAreEmpty ( ) { context . checking ( new Expectations ( ) { { one ( source1 ) . isEmpty ( ) ; will ( returnValue ( true ) ) ; one ( source2 ) . isEmpty ( ) ; will ( returnValue ( true ) ) ; } } ) ; assertTrue ( collection . isEmpty ( ) ) ; } @Test public void isNotEmptyWhenAnySetIsNotEmpty ( ) { context . checking ( new Expectations ( ) { { one ( source1 ) . isEmpty ( ) ; will ( returnValue ( false ) ) ; } } ) ; assertFalse ( collection . isEmpty ( ) ) ; } @Test public void addToAntBuilderDelegatesToEachSet ( ) { context . checking ( new Expectations ( ) { { one ( source1 ) . addToAntBuilder ( <str> , <str> , FileCollection . AntType . ResourceCollection ) ; one ( source2 ) . addToAntBuilder ( <str> , <str> , FileCollection . AntType . ResourceCollection ) ; } } ) ; collection . addToAntBuilder ( <str> , <str> , FileCollection . AntType . ResourceCollection ) ; } @Test public void getAsFileTreesReturnsUnionOfFileTrees ( ) { final DirectoryFileTree set1 = new DirectoryFileTree ( new File ( <str> ) . getAbsoluteFile ( ) ) ; final DirectoryFileTree set2 = new DirectoryFileTree ( new File ( <str> ) . getAbsoluteFile ( ) ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . getAsFileTrees ( ) ; will ( returnValue ( toList ( ( Object ) set1 ) ) ) ; one ( source2 ) . getAsFileTrees ( ) ; will ( returnValue ( toList ( ( Object ) set2 ) ) ) ; } } ) ; assertThat ( collection . getAsFileTrees ( ) , equalTo ( ( Collection ) toList ( set1 , set2 ) ) ) ; } @Test public void getAsFileTreeDelegatesToEachSet ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; FileTree fileTree = collection . getAsFileTree ( ) ; assertThat ( fileTree , instanceOf ( CompositeFileTree . class ) ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . getFiles ( ) ; will ( returnValue ( toSet ( file1 ) ) ) ; one ( source2 ) . getFiles ( ) ; will ( returnValue ( toSet ( file2 ) ) ) ; } } ) ; ( ( CompositeFileTree ) fileTree ) . getSourceCollections ( ) ; } @Test public void fileTreeIsLive ( ) { final File dir1 = new File ( <str> ) ; final File dir2 = new File ( <str> ) ; final File dir3 = new File ( <str> ) ; final MinimalFileSet source3 = context . mock ( MinimalFileSet . class ) ; FileTree fileTree = collection . getAsFileTree ( ) ; assertThat ( fileTree , instanceOf ( CompositeFileTree . class ) ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . getFiles ( ) ; will ( returnValue ( toSet ( dir1 ) ) ) ; one ( source2 ) . getFiles ( ) ; will ( returnValue ( toSet ( dir2 ) ) ) ; } } ) ; ( ( CompositeFileTree ) fileTree ) . getSourceCollections ( ) ; collection . sourceCollections . add ( source3 ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . getFiles ( ) ; will ( returnValue ( toSet ( dir1 ) ) ) ; one ( source2 ) . getFiles ( ) ; will ( returnValue ( toSet ( dir2 ) ) ) ; one ( source3 ) . getFiles ( ) ; will ( returnValue ( toSet ( dir3 ) ) ) ; } } ) ; ( ( CompositeFileTree ) fileTree ) . getSourceCollections ( ) ; } @Test public void filterDelegatesToEachSet ( ) { final FileCollectionInternal filtered1 = context . mock ( FileCollectionInternal . class ) ; final FileCollectionInternal filtered2 = context . mock ( FileCollectionInternal . class ) ; @SuppressWarnings ( <str> ) final Spec < File > spec = context . mock ( Spec . class ) ; FileCollection filtered = collection . filter ( spec ) ; assertThat ( filtered , instanceOf ( CompositeFileCollection . class ) ) ; context . checking ( new Expectations ( ) { { one ( source1 ) . filter ( spec ) ; will ( returnValue ( filtered1 ) ) ; one ( source2 ) . filter ( spec ) ; will ( returnValue ( filtered2 ) ) ; } } ) ; assertThat ( ( ( CompositeFileCollection ) filtered ) . getSourceCollections ( ) , equalTo ( ( Iterable ) toList ( filtered1 , filtered2 ) ) ) ; } private class TestCompositeFileCollection extends CompositeFileCollection { private List < Object > sourceCollections ; public TestCompositeFileCollection ( FileCollection . . . sourceCollections ) { this . sourceCollections = new ArrayList < Object > ( Arrays . asList ( sourceCollections ) ) ; } @Override public String getDisplayName ( ) { return <str> ; } @Override public void visitContents ( FileCollectionResolveContext context ) { context . add ( sourceCollections ) ; } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { throw new UnsupportedOperationException ( ) ; } } } 
