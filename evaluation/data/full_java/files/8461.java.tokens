package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . aggregations . bucket . filter . FilterAggregationBuilder ; import org . elasticsearch . search . aggregations . bucket . filter . InternalFilter ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTerms ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsAggregatorFactory ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsBuilder ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; public class TermsShardMinDocCountIT extends ESIntegTestCase { private static final String index = <str> ; private static final String type = <str> ; public String randomExecutionHint ( ) { return randomBoolean ( ) ? null : randomFrom ( SignificantTermsAggregatorFactory . ExecutionMode . values ( ) ) . toString ( ) ; } public void testShardMinDocCountSignificantTermsTest ( ) throws Exception { String termtype = <str> ; if ( randomBoolean ( ) ) { termtype = <str> ; } assertAcked ( prepareCreate ( index ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( type , <str> + termtype + <str> ) ) ; ensureYellow ( index ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , <int> , indexBuilders ) ; indexRandom ( true , false , indexBuilders ) ; SearchResponse response = client ( ) . prepareSearch ( index ) . addAggregation ( ( new FilterAggregationBuilder ( <str> ) . filter ( QueryBuilders . termQuery ( <str> , true ) ) ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . size ( <int> ) . executionHint ( randomExecutionHint ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalFilter filteredBucket = response . getAggregations ( ) . get ( <str> ) ; SignificantTerms sigterms = filteredBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sigterms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; response = client ( ) . prepareSearch ( index ) . addAggregation ( ( new FilterAggregationBuilder ( <str> ) . filter ( QueryBuilders . termQuery ( <str> , true ) ) ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . shardMinDocCount ( <int> ) . size ( <int> ) . executionHint ( randomExecutionHint ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; filteredBucket = response . getAggregations ( ) . get ( <str> ) ; sigterms = filteredBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sigterms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } private void addTermsDocs ( String term , int numInClass , int numNotInClass , List < IndexRequestBuilder > builders ) { String sourceClass = <str> + term + <str> + <str> + <str> ; String sourceNotClass = <str> + term + <str> + <str> + <str> ; for ( int i = <int> ; i < numInClass ; i + + ) { builders . add ( client ( ) . prepareIndex ( index , type ) . setSource ( sourceClass ) ) ; } for ( int i = <int> ; i < numNotInClass ; i + + ) { builders . add ( client ( ) . prepareIndex ( index , type ) . setSource ( sourceNotClass ) ) ; } } public void testShardMinDocCountTermsTest ( ) throws Exception { final String [ ] termTypes = { <str> , <str> , <str> , <str> , <str> } ; String termtype = termTypes [ randomInt ( termTypes . length - <int> ) ] ; assertAcked ( prepareCreate ( index ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( type , <str> + termtype + <str> ) ) ; ensureYellow ( index ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; addTermsDocs ( <str> , <int> , indexBuilders ) ; indexRandom ( true , false , indexBuilders ) ; SearchResponse response = client ( ) . prepareSearch ( index ) . addAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . size ( <int> ) . executionHint ( randomExecutionHint ( ) ) . order ( Terms . Order . term ( true ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms sigterms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sigterms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; response = client ( ) . prepareSearch ( index ) . addAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . shardMinDocCount ( <int> ) . size ( <int> ) . executionHint ( randomExecutionHint ( ) ) . order ( Terms . Order . term ( true ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; sigterms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sigterms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } private void addTermsDocs ( String term , int numDocs , List < IndexRequestBuilder > builders ) { String sourceClass = <str> + term + <str> ; for ( int i = <int> ; i < numDocs ; i + + ) { builders . add ( client ( ) . prepareIndex ( index , type ) . setSource ( sourceClass ) ) ; } } } 
