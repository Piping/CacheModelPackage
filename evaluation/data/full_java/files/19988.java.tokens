package io . netty . handler . ssl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . base64 . Base64 ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . security . KeyException ; import java . security . KeyStore ; import java . security . cert . CertificateException ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; final class PemReader { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PemReader . class ) ; private static final Pattern CERT_PATTERN = Pattern . compile ( <str> + <str> + <str> , Pattern . CASE_INSENSITIVE ) ; private static final Pattern KEY_PATTERN = Pattern . compile ( <str> + <str> + <str> , Pattern . CASE_INSENSITIVE ) ; static ByteBuf [ ] readCertificates ( File file ) throws CertificateException { String content ; try { content = readContent ( file ) ; } catch ( IOException e ) { throw new CertificateException ( <str> + file , e ) ; } List < ByteBuf > certs = new ArrayList < ByteBuf > ( ) ; Matcher m = CERT_PATTERN . matcher ( content ) ; int start = <int> ; for ( ; ; ) { if ( ! m . find ( start ) ) { break ; } ByteBuf base64 = Unpooled . copiedBuffer ( m . group ( <int> ) , CharsetUtil . US_ASCII ) ; ByteBuf der = Base64 . decode ( base64 ) ; base64 . release ( ) ; certs . add ( der ) ; start = m . end ( ) ; } if ( certs . isEmpty ( ) ) { throw new CertificateException ( <str> + file ) ; } return certs . toArray ( new ByteBuf [ certs . size ( ) ] ) ; } static ByteBuf readPrivateKey ( File file ) throws KeyException { String content ; try { content = readContent ( file ) ; } catch ( IOException e ) { throw new KeyException ( <str> + file , e ) ; } Matcher m = KEY_PATTERN . matcher ( content ) ; if ( ! m . find ( ) ) { throw new KeyException ( <str> + file ) ; } ByteBuf base64 = Unpooled . copiedBuffer ( m . group ( <int> ) , CharsetUtil . US_ASCII ) ; ByteBuf der = Base64 . decode ( base64 ) ; base64 . release ( ) ; return der ; } private static String readContent ( File file ) throws IOException { InputStream in = new FileInputStream ( file ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { byte [ ] buf = new byte [ <int> ] ; for ( ; ; ) { int ret = in . read ( buf ) ; if ( ret < <int> ) { break ; } out . write ( buf , <int> , ret ) ; } return out . toString ( CharsetUtil . US_ASCII . name ( ) ) ; } finally { safeClose ( in ) ; safeClose ( out ) ; } } private static void safeClose ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } private static void safeClose ( OutputStream out ) { try { out . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } private PemReader ( ) { } } 
