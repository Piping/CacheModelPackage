package org . gradle . messaging . remote . internal . inet ; import org . gradle . api . Transformer ; import org . gradle . internal . UncheckedException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . * ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; public class InetAddressFactory { private static final Logger LOGGER = LoggerFactory . getLogger ( InetAddressFactory . class ) ; private final Object lock = new Object ( ) ; private List < InetAddress > localAddresses ; private List < InetAddress > remoteAddresses ; private List < NetworkInterface > multicastInterfaces ; private InetAddress localBindingAddress ; public String getHostName ( ) { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { return findRemoteAddresses ( ) . get ( <int> ) . toString ( ) ; } } public boolean isLocal ( InetAddress address ) { try { synchronized ( lock ) { init ( ) ; return localAddresses . contains ( address ) ; } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } public List < InetAddress > findLocalAddresses ( ) { try { synchronized ( lock ) { init ( ) ; return localAddresses ; } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } public List < InetAddress > findRemoteAddresses ( ) { try { synchronized ( lock ) { init ( ) ; return remoteAddresses ; } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } public List < NetworkInterface > findMulticastInterfaces ( ) { try { synchronized ( lock ) { init ( ) ; return multicastInterfaces ; } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } public InetAddress findLocalBindingAddress ( ) { try { synchronized ( lock ) { init ( ) ; return localBindingAddress ; } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } private InetAddress findOpenshiftAddresses ( ) { for ( String key : System . getenv ( ) . keySet ( ) ) { if ( key . startsWith ( <str> ) & & key . endsWith ( <str> ) ) { String ipAddress = System . getenv ( key ) ; LOGGER . debug ( <str> , key , ipAddress ) ; try { return InetAddress . getByName ( ipAddress ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( String . format ( <str> , ipAddress , key ) , e ) ; } } } return null ; } private void init ( ) throws Exception { if ( localAddresses ! = null ) { return ; } Transformer < Boolean , NetworkInterface > loopback = loopback ( ) ; Transformer < Boolean , NetworkInterface > multicast = multicast ( ) ; localAddresses = new ArrayList < InetAddress > ( ) ; remoteAddresses = new ArrayList < InetAddress > ( ) ; multicastInterfaces = new ArrayList < NetworkInterface > ( ) ; Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( interfaces . hasMoreElements ( ) ) { NetworkInterface networkInterface = interfaces . nextElement ( ) ; LOGGER . debug ( <str> , networkInterface . getDisplayName ( ) ) ; try { Boolean isLoopbackInterface = loopback . transform ( networkInterface ) ; LOGGER . debug ( <str> , isLoopbackInterface ) ; Boolean isMulticast = multicast . transform ( networkInterface ) ; LOGGER . debug ( <str> , isMulticast ) ; boolean isRemote = false ; Enumeration < InetAddress > candidates = networkInterface . getInetAddresses ( ) ; while ( candidates . hasMoreElements ( ) ) { InetAddress candidate = candidates . nextElement ( ) ; if ( isLoopbackInterface = = null ) { if ( candidate . isLoopbackAddress ( ) ) { LOGGER . debug ( <str> , candidate ) ; localAddresses . add ( candidate ) ; } else { LOGGER . debug ( <str> , candidate ) ; remoteAddresses . add ( candidate ) ; isRemote = true ; } } else if ( isLoopbackInterface ) { if ( candidate . isLoopbackAddress ( ) ) { LOGGER . debug ( <str> , candidate ) ; localAddresses . add ( candidate ) ; } else { LOGGER . debug ( <str> , candidate ) ; } } else { if ( candidate . isLoopbackAddress ( ) ) { LOGGER . debug ( <str> , candidate ) ; } else { LOGGER . debug ( <str> , candidate ) ; remoteAddresses . add ( candidate ) ; isRemote = true ; } } } if ( ! Boolean . FALSE . equals ( isMulticast ) ) { if ( isRemote ) { LOGGER . debug ( <str> , networkInterface . getDisplayName ( ) ) ; multicastInterfaces . add ( <int> , networkInterface ) ; } else { LOGGER . debug ( <str> , networkInterface . getDisplayName ( ) ) ; multicastInterfaces . add ( networkInterface ) ; } } } catch ( Throwable e ) { throw new RuntimeException ( String . format ( <str> , networkInterface . getName ( ) ) , e ) ; } } if ( localAddresses . isEmpty ( ) ) { InetAddress fallback = InetAddress . getByName ( null ) ; LOGGER . debug ( <str> , fallback ) ; localAddresses . add ( fallback ) ; } if ( remoteAddresses . isEmpty ( ) ) { try { InetAddress fallback = InetAddress . getLocalHost ( ) ; LOGGER . debug ( <str> , fallback ) ; remoteAddresses . add ( fallback ) ; } catch ( UnknownHostException e ) { LOGGER . debug ( <str> ) ; remoteAddresses . addAll ( localAddresses ) ; } } if ( multicastInterfaces . isEmpty ( ) ) { LOGGER . debug ( <str> ) ; Enumeration < NetworkInterface > networkInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( networkInterfaces . hasMoreElements ( ) ) { multicastInterfaces . add ( networkInterfaces . nextElement ( ) ) ; } } InetAddress openshiftBindAddress = findOpenshiftAddresses ( ) ; if ( openshiftBindAddress ! = null ) { localBindingAddress = openshiftBindAddress ; localAddresses . add ( openshiftBindAddress ) ; } else { localBindingAddress = new InetSocketAddress ( <int> ) . getAddress ( ) ; } } private Transformer < Boolean , NetworkInterface > loopback ( ) { try { Method method = NetworkInterface . class . getMethod ( <str> ) ; return new MethodBackedTransformer ( method ) ; } catch ( NoSuchMethodException e ) { return new Unknown ( ) ; } } private Transformer < Boolean , NetworkInterface > multicast ( ) { try { Method method = NetworkInterface . class . getMethod ( <str> ) ; return new MethodBackedTransformer ( method ) ; } catch ( NoSuchMethodException e ) { return new Unknown ( ) ; } } private static class Unknown implements Transformer < Boolean , NetworkInterface > { public Boolean transform ( NetworkInterface original ) { return null ; } } private static class MethodBackedTransformer implements Transformer < Boolean , NetworkInterface > { private final Method method ; public MethodBackedTransformer ( Method method ) { this . method = method ; } public Boolean transform ( NetworkInterface original ) { try { try { return ( Boolean ) method . invoke ( original ) ; } catch ( InvocationTargetException e ) { if ( ! ( e . getCause ( ) instanceof SocketException ) ) { throw e . getCause ( ) ; } return null ; } } catch ( Throwable throwable ) { throw UncheckedException . throwAsUncheckedException ( throwable ) ; } } } } 
