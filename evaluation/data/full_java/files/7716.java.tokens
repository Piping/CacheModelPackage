package org . elasticsearch . action ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . CoreMatchers . equalTo ; public class OriginalIndicesTests extends ESTestCase { private static final IndicesOptions [ ] indicesOptionsValues = new IndicesOptions [ ] { IndicesOptions . lenientExpandOpen ( ) , IndicesOptions . strictExpand ( ) , IndicesOptions . strictExpandOpen ( ) , IndicesOptions . strictExpandOpenAndForbidClosed ( ) , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) } ; public void testOriginalIndicesSerialization ( ) throws IOException { int iterations = iterations ( <int> , <int> ) ; for ( int i = <int> ; i < iterations ; i + + ) { OriginalIndices originalIndices = randomOriginalIndices ( ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; out . setVersion ( randomVersion ( random ( ) ) ) ; OriginalIndices . writeOriginalIndices ( originalIndices , out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; in . setVersion ( out . getVersion ( ) ) ; OriginalIndices originalIndices2 = OriginalIndices . readOriginalIndices ( in ) ; assertThat ( originalIndices2 . indices ( ) , equalTo ( originalIndices . indices ( ) ) ) ; assertThat ( originalIndices2 . indicesOptions ( ) , equalTo ( originalIndices . indicesOptions ( ) ) ) ; } } private static OriginalIndices randomOriginalIndices ( ) { int numIndices = randomInt ( <int> ) ; String [ ] indices = new String [ numIndices ] ; for ( int j = <int> ; j < indices . length ; j + + ) { indices [ j ] = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; } IndicesOptions indicesOptions = randomFrom ( indicesOptionsValues ) ; return new OriginalIndices ( indices , indicesOptions ) ; } } 
