package org . junit . tests . experimental . theories . runner ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . notNullValue ; import static org . junit . Assert . assertThat ; import static org . junit . experimental . results . PrintableResult . testResult ; import static org . junit . experimental . results . ResultMatchers . isSuccessful ; import org . junit . Test ; import org . junit . experimental . results . ResultMatchers ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . experimental . theories . suppliers . TestedOn ; import org . junit . runner . JUnitCore ; import org . junit . runner . RunWith ; public class WithExtendedParameterSources { @RunWith ( Theories . class ) public static class ParameterAnnotations { @Theory public void everythingIsOne ( @TestedOn ( ints = { <int> } ) int number ) { assertThat ( number , is ( <int> ) ) ; } } @Test public void testedOnLimitsParameters ( ) throws Exception { assertThat ( testResult ( ParameterAnnotations . class ) , ResultMatchers . isSuccessful ( ) ) ; } @RunWith ( Theories . class ) public static class ShouldFilterOutNullSingleDataPoints { @DataPoint public static String A = <str> ; @DataPoint public static String NULL = null ; @Theory ( nullsAccepted = false ) public void allStringsAreNonNull ( String s ) { assertThat ( s , notNullValue ( ) ) ; } } @Test public void shouldFilterOutNullSingleDataPoints ( ) { assertThat ( testResult ( ShouldFilterOutNullSingleDataPoints . class ) , isSuccessful ( ) ) ; } @RunWith ( Theories . class ) public static class ShouldFilterOutNullElementsFromDataPointArrays { @DataPoints public static String [ ] SOME_NULLS = { <str> , null } ; @Theory ( nullsAccepted = false ) public void allStringsAreNonNull ( String s ) { assertThat ( s , notNullValue ( ) ) ; } } @Test public void shouldFilterOutNullElementsFromDataPointArrays ( ) { assertThat ( testResult ( ShouldFilterOutNullElementsFromDataPointArrays . class ) , isSuccessful ( ) ) ; } @RunWith ( Theories . class ) public static class ShouldRejectTheoriesWithOnlyDisallowedNullData { @DataPoints public static String value = null ; @Theory ( nullsAccepted = false ) public void allStringsAreNonNull ( String s ) { } } @Test public void ShouldRejectTheoriesWithOnlyDisallowedNullData ( ) { assertThat ( testResult ( ShouldRejectTheoriesWithOnlyDisallowedNullData . class ) , not ( isSuccessful ( ) ) ) ; } @RunWith ( Theories . class ) public static class DataPointArrays { public static String log = <str> ; @DataPoints public static String [ ] STRINGS = new String [ ] { <str> , <str> } ; @Theory public void addToLog ( String string ) { log + = string ; } } @Test public void getDataPointsFromArray ( ) { DataPointArrays . log = <str> ; JUnitCore . runClasses ( DataPointArrays . class ) ; assertThat ( DataPointArrays . log , is ( <str> ) ) ; } @RunWith ( Theories . class ) public static class DataPointArrayMethod { public static String log = <str> ; @DataPoints public static String [ ] STRINGS ( ) { return new String [ ] { <str> , <str> } ; } ; @Theory public void addToLog ( String string ) { log + = string ; } } @Test public void getDataPointsFromArrayMethod ( ) { DataPointArrayMethod . log = <str> ; JUnitCore . runClasses ( DataPointArrayMethod . class ) ; assertThat ( DataPointArrayMethod . log , is ( <str> ) ) ; } @RunWith ( Theories . class ) public static class DataPointMalformedArrayMethods { public static String log = <str> ; @DataPoints public static String [ ] STRINGS ( ) { return new String [ ] { <str> , <str> } ; } ; @DataPoints public static String STRING ( ) { return <str> ; } @DataPoints public static int [ ] INTS ( ) { return new int [ ] { <int> , <int> , <int> } ; } @Theory public void addToLog ( String string ) { log + = string ; } } @Test public void getDataPointsFromArrayMethodInSpiteOfMalformedness ( ) { DataPointArrayMethod . log = <str> ; JUnitCore . runClasses ( DataPointArrayMethod . class ) ; assertThat ( DataPointArrayMethod . log , is ( <str> ) ) ; } @RunWith ( Theories . class ) public static class DataPointArrayToBeUsedForWholeParameter { public static String log = <str> ; @DataPoint public static String [ ] STRINGS = new String [ ] { <str> , <str> } ; @Theory public void addToLog ( String [ ] strings ) { log + = strings [ <int> ] ; } } @Test public void dataPointCanBeArray ( ) { DataPointArrayToBeUsedForWholeParameter . log = <str> ; JUnitCore . runClasses ( DataPointArrayToBeUsedForWholeParameter . class ) ; assertThat ( DataPointArrayToBeUsedForWholeParameter . log , is ( <str> ) ) ; } } 
