package io . netty . bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelPromise ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . ReflectiveChannelFactory ; import io . netty . util . AttributeKey ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . StringUtil ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . LinkedHashMap ; import java . util . Map ; public abstract class AbstractBootstrap < B extends AbstractBootstrap < B , C > , C extends Channel > implements Cloneable { volatile EventLoopGroup group ; @SuppressWarnings ( <str> ) private volatile ChannelFactory < ? extends C > channelFactory ; private volatile SocketAddress localAddress ; private final Map < ChannelOption < ? > , Object > options = new LinkedHashMap < ChannelOption < ? > , Object > ( ) ; private final Map < AttributeKey < ? > , Object > attrs = new LinkedHashMap < AttributeKey < ? > , Object > ( ) ; private volatile ChannelHandler handler ; AbstractBootstrap ( ) { } AbstractBootstrap ( AbstractBootstrap < B , C > bootstrap ) { group = bootstrap . group ; channelFactory = bootstrap . channelFactory ; handler = bootstrap . handler ; localAddress = bootstrap . localAddress ; synchronized ( bootstrap . options ) { options . putAll ( bootstrap . options ) ; } synchronized ( bootstrap . attrs ) { attrs . putAll ( bootstrap . attrs ) ; } } @SuppressWarnings ( <str> ) public B group ( EventLoopGroup group ) { if ( group = = null ) { throw new NullPointerException ( <str> ) ; } if ( this . group ! = null ) { throw new IllegalStateException ( <str> ) ; } this . group = group ; return ( B ) this ; } public B channel ( Class < ? extends C > channelClass ) { if ( channelClass = = null ) { throw new NullPointerException ( <str> ) ; } return channelFactory ( new ReflectiveChannelFactory < C > ( channelClass ) ) ; } @Deprecated @SuppressWarnings ( <str> ) public B channelFactory ( ChannelFactory < ? extends C > channelFactory ) { if ( channelFactory = = null ) { throw new NullPointerException ( <str> ) ; } if ( this . channelFactory ! = null ) { throw new IllegalStateException ( <str> ) ; } this . channelFactory = channelFactory ; return ( B ) this ; } @SuppressWarnings ( { <str> , <str> } ) public B channelFactory ( io . netty . channel . ChannelFactory < ? extends C > channelFactory ) { return channelFactory ( ( ChannelFactory < C > ) channelFactory ) ; } @SuppressWarnings ( <str> ) public B localAddress ( SocketAddress localAddress ) { this . localAddress = localAddress ; return ( B ) this ; } public B localAddress ( int inetPort ) { return localAddress ( new InetSocketAddress ( inetPort ) ) ; } public B localAddress ( String inetHost , int inetPort ) { return localAddress ( new InetSocketAddress ( inetHost , inetPort ) ) ; } public B localAddress ( InetAddress inetHost , int inetPort ) { return localAddress ( new InetSocketAddress ( inetHost , inetPort ) ) ; } @SuppressWarnings ( <str> ) public < T > B option ( ChannelOption < T > option , T value ) { if ( option = = null ) { throw new NullPointerException ( <str> ) ; } if ( value = = null ) { synchronized ( options ) { options . remove ( option ) ; } } else { synchronized ( options ) { options . put ( option , value ) ; } } return ( B ) this ; } @SuppressWarnings ( <str> ) public < T > B attr ( AttributeKey < T > key , T value ) { if ( key = = null ) { throw new NullPointerException ( <str> ) ; } if ( value = = null ) { synchronized ( attrs ) { attrs . remove ( key ) ; } } else { synchronized ( attrs ) { attrs . put ( key , value ) ; } } return ( B ) this ; } @SuppressWarnings ( <str> ) public B validate ( ) { if ( group = = null ) { throw new IllegalStateException ( <str> ) ; } if ( channelFactory = = null ) { throw new IllegalStateException ( <str> ) ; } return ( B ) this ; } @Override @SuppressWarnings ( <str> ) public abstract B clone ( ) ; public ChannelFuture register ( ) { validate ( ) ; return initAndRegister ( ) ; } public ChannelFuture bind ( ) { validate ( ) ; SocketAddress localAddress = this . localAddress ; if ( localAddress = = null ) { throw new IllegalStateException ( <str> ) ; } return doBind ( localAddress ) ; } public ChannelFuture bind ( int inetPort ) { return bind ( new InetSocketAddress ( inetPort ) ) ; } public ChannelFuture bind ( String inetHost , int inetPort ) { return bind ( new InetSocketAddress ( inetHost , inetPort ) ) ; } public ChannelFuture bind ( InetAddress inetHost , int inetPort ) { return bind ( new InetSocketAddress ( inetHost , inetPort ) ) ; } public ChannelFuture bind ( SocketAddress localAddress ) { validate ( ) ; if ( localAddress = = null ) { throw new NullPointerException ( <str> ) ; } return doBind ( localAddress ) ; } private ChannelFuture doBind ( final SocketAddress localAddress ) { final ChannelFuture regFuture = initAndRegister ( ) ; final Channel channel = regFuture . channel ( ) ; if ( regFuture . cause ( ) ! = null ) { return regFuture ; } if ( regFuture . isDone ( ) ) { ChannelPromise promise = channel . newPromise ( ) ; doBind0 ( regFuture , channel , localAddress , promise ) ; return promise ; } else { final PendingRegistrationPromise promise = new PendingRegistrationPromise ( channel ) ; regFuture . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { Throwable cause = future . cause ( ) ; if ( cause ! = null ) { promise . setFailure ( cause ) ; } else { promise . executor = channel . eventLoop ( ) ; } doBind0 ( regFuture , channel , localAddress , promise ) ; } } ) ; return promise ; } } final ChannelFuture initAndRegister ( ) { final Channel channel = channelFactory ( ) . newChannel ( ) ; try { init ( channel ) ; } catch ( Throwable t ) { channel . unsafe ( ) . closeForcibly ( ) ; return new DefaultChannelPromise ( channel , GlobalEventExecutor . INSTANCE ) . setFailure ( t ) ; } ChannelFuture regFuture = group ( ) . register ( channel ) ; if ( regFuture . cause ( ) ! = null ) { if ( channel . isRegistered ( ) ) { channel . close ( ) ; } else { channel . unsafe ( ) . closeForcibly ( ) ; } } return regFuture ; } abstract void init ( Channel channel ) throws Exception ; private static void doBind0 ( final ChannelFuture regFuture , final Channel channel , final SocketAddress localAddress , final ChannelPromise promise ) { channel . eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { if ( regFuture . isSuccess ( ) ) { channel . bind ( localAddress , promise ) . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; } else { promise . setFailure ( regFuture . cause ( ) ) ; } } } ) ; } @SuppressWarnings ( <str> ) public B handler ( ChannelHandler handler ) { if ( handler = = null ) { throw new NullPointerException ( <str> ) ; } this . handler = handler ; return ( B ) this ; } final SocketAddress localAddress ( ) { return localAddress ; } @SuppressWarnings ( <str> ) final ChannelFactory < ? extends C > channelFactory ( ) { return channelFactory ; } final ChannelHandler handler ( ) { return handler ; } public EventLoopGroup group ( ) { return group ; } final Map < ChannelOption < ? > , Object > options ( ) { return options ; } final Map < AttributeKey < ? > , Object > attrs ( ) { return attrs ; } @Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) . append ( StringUtil . simpleClassName ( this ) ) . append ( <str> ) ; if ( group ! = null ) { buf . append ( <str> ) . append ( StringUtil . simpleClassName ( group ) ) . append ( <str> ) ; } if ( channelFactory ! = null ) { buf . append ( <str> ) . append ( channelFactory ) . append ( <str> ) ; } if ( localAddress ! = null ) { buf . append ( <str> ) . append ( localAddress ) . append ( <str> ) ; } synchronized ( options ) { if ( ! options . isEmpty ( ) ) { buf . append ( <str> ) . append ( options ) . append ( <str> ) ; } } synchronized ( attrs ) { if ( ! attrs . isEmpty ( ) ) { buf . append ( <str> ) . append ( attrs ) . append ( <str> ) ; } } if ( handler ! = null ) { buf . append ( <str> ) . append ( handler ) . append ( <str> ) ; } if ( buf . charAt ( buf . length ( ) - <int> ) = = <str> ) { buf . append ( <str> ) ; } else { buf . setCharAt ( buf . length ( ) - <int> , <str> ) ; buf . setLength ( buf . length ( ) - <int> ) ; } return buf . toString ( ) ; } private static final class PendingRegistrationPromise extends DefaultChannelPromise { private volatile EventExecutor executor ; private PendingRegistrationPromise ( Channel channel ) { super ( channel ) ; } @Override protected EventExecutor executor ( ) { EventExecutor executor = this . executor ; if ( executor ! = null ) { return executor ; } return GlobalEventExecutor . INSTANCE ; } } } 
