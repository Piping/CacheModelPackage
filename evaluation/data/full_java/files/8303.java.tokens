package org . elasticsearch . index . store ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . translog . TranslogConfig ; import org . elasticsearch . monitor . fs . FsInfo ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . engine . MockEngineSupport ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import static org . elasticsearch . common . util . CollectionUtils . iterableAsArrayList ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . notNullValue ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . SUITE , numDataNodes = <int> ) public class CorruptedTranslogIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } @TestLogging ( <str> ) public void testCorruptTranslogFiles ( ) throws Exception { internalCluster ( ) . startNodesAsync ( <int> , Settings . EMPTY ) . get ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . put ( MockEngineSupport . FLUSH_ON_CLOSE_RATIO , <float> ) . put ( IndexShard . INDEX_FLUSH_ON_CLOSE , false ) . put ( TranslogConfig . INDEX_TRANSLOG_SYNC_INTERVAL , <str> ) ) ) ; ensureYellow ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , <str> ) ; } disableTranslogFlush ( <str> ) ; indexRandom ( false , false , false , Arrays . asList ( builders ) ) ; corruptRandomTranslogFiles ( ) ; internalCluster ( ) . fullRestart ( ) ; Thread . sleep ( <int> ) ; enableTranslogFlush ( <str> ) ; try { client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { } } private void corruptRandomTranslogFiles ( ) throws IOException { ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; GroupShardsIterator shardIterators = state . getRoutingNodes ( ) . getRoutingTable ( ) . activePrimaryShardsGrouped ( new String [ ] { <str> } , false ) ; List < ShardIterator > iterators = iterableAsArrayList ( shardIterators ) ; ShardIterator shardIterator = RandomPicks . randomFrom ( getRandom ( ) , iterators ) ; ShardRouting shardRouting = shardIterator . nextOrNull ( ) ; assertNotNull ( shardRouting ) ; assertTrue ( shardRouting . primary ( ) ) ; assertTrue ( shardRouting . assignedToNode ( ) ) ; String nodeId = shardRouting . currentNodeId ( ) ; NodesStatsResponse nodeStatses = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( nodeId ) . setFs ( true ) . get ( ) ; Set < Path > files = new TreeSet < > ( ) ; for ( FsInfo . Path fsPath : nodeStatses . getNodes ( ) [ <int> ] . getFs ( ) ) { String path = fsPath . getPath ( ) ; final String relativeDataLocationPath = <str> + Integer . toString ( shardRouting . getId ( ) ) + <str> ; Path file = PathUtils . get ( path ) . resolve ( relativeDataLocationPath ) ; if ( Files . exists ( file ) ) { logger . info ( <str> , file ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( file ) ) { for ( Path item : stream ) { logger . info ( <str> , item ) ; if ( Files . isRegularFile ( item ) & & item . getFileName ( ) . toString ( ) . startsWith ( <str> ) ) { files . add ( item ) ; } } } } } Path fileToCorrupt = null ; if ( ! files . isEmpty ( ) ) { int corruptions = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < corruptions ; i + + ) { fileToCorrupt = RandomPicks . randomFrom ( getRandom ( ) , files ) ; try ( FileChannel raf = FileChannel . open ( fileToCorrupt , StandardOpenOption . READ , StandardOpenOption . WRITE ) ) { raf . position ( randomIntBetween ( <int> , ( int ) Math . min ( Integer . MAX_VALUE , raf . size ( ) - <int> ) ) ) ; long filePointer = raf . position ( ) ; ByteBuffer bb = ByteBuffer . wrap ( new byte [ <int> ] ) ; raf . read ( bb ) ; bb . flip ( ) ; byte oldValue = bb . get ( <int> ) ; byte newValue = ( byte ) ( oldValue + <int> ) ; bb . put ( <int> , newValue ) ; raf . position ( filePointer ) ; raf . write ( bb ) ; logger . info ( <str> , fileToCorrupt , filePointer , Integer . toHexString ( oldValue ) , Integer . toHexString ( newValue ) , fileToCorrupt ) ; } } } assertThat ( <str> , fileToCorrupt , notNullValue ( ) ) ; } } 
