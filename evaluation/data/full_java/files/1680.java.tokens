package org . apache . cassandra . stress ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . math . BigDecimal ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . Paths ; import java . util . Arrays ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . io . ByteStreams ; import org . apache . commons . lang3 . StringUtils ; import org . apache . cassandra . stress . settings . StressSettings ; import org . json . simple . JSONArray ; import org . json . simple . JSONObject ; import org . json . simple . JSONValue ; public class StressGraph { private StressSettings stressSettings ; private enum ReadingMode { START , METRICS , AGGREGATES , NEXTITERATION } private String [ ] stressArguments ; public StressGraph ( StressSettings stressSetttings , String [ ] stressArguments ) { this . stressSettings = stressSetttings ; this . stressArguments = stressArguments ; } public void generateGraph ( ) { File htmlFile = new File ( stressSettings . graph . file ) ; JSONObject stats ; if ( htmlFile . isFile ( ) ) { try { String html = new String ( Files . readAllBytes ( Paths . get ( htmlFile . toURI ( ) ) ) , StandardCharsets . UTF_8 ) ; stats = parseExistingStats ( html ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> ) ; } stats = this . createJSONStats ( stats ) ; } else { stats = this . createJSONStats ( null ) ; } try { PrintWriter out = new PrintWriter ( htmlFile ) ; String statsBlock = <str> + stats . toJSONString ( ) + <str> ; String html = getGraphHTML ( ) . replaceFirst ( <str> , statsBlock ) ; out . write ( html ) ; out . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> ) ; } } private JSONObject parseExistingStats ( String html ) { JSONObject stats ; Pattern pattern = Pattern . compile ( <str> ) ; Matcher matcher = pattern . matcher ( html ) ; matcher . matches ( ) ; stats = ( JSONObject ) JSONValue . parse ( matcher . group ( <int> ) ) ; return stats ; } private String getGraphHTML ( ) { InputStream graphHTMLRes = StressGraph . class . getClassLoader ( ) . getResourceAsStream ( <str> ) ; String graphHTML ; try { graphHTML = new String ( ByteStreams . toByteArray ( graphHTMLRes ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return graphHTML ; } private JSONArray parseLogStats ( InputStream log , JSONArray stats ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( log ) ) ; JSONObject json = new JSONObject ( ) ; JSONArray intervals = new JSONArray ( ) ; boolean runningMultipleThreadCounts = false ; String currentThreadCount = null ; Pattern threadCountMessage = Pattern . compile ( <str> ) ; ReadingMode mode = ReadingMode . START ; try { String line ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . startsWith ( <str> ) ) runningMultipleThreadCounts = true ; Matcher tc = threadCountMessage . matcher ( line ) ; if ( tc . matches ( ) ) { if ( runningMultipleThreadCounts ) { currentThreadCount = tc . group ( <int> ) ; } } if ( line . equals ( StressMetrics . HEAD ) ) { mode = ReadingMode . METRICS ; continue ; } else if ( line . equals ( <str> ) ) { mode = ReadingMode . AGGREGATES ; continue ; } else if ( mode = = ReadingMode . AGGREGATES & & line . equals ( <str> ) ) { mode = ReadingMode . NEXTITERATION ; } else if ( line . equals ( <str> ) | | line . equals ( <str> ) ) { break ; } if ( mode = = ReadingMode . METRICS ) { JSONArray metrics = new JSONArray ( ) ; String [ ] parts = line . split ( <str> ) ; if ( parts . length ! = StressMetrics . HEADMETRICS . length ) { continue ; } for ( String m : parts ) { try { metrics . add ( new BigDecimal ( m . trim ( ) ) ) ; } catch ( NumberFormatException e ) { metrics . add ( null ) ; } } intervals . add ( metrics ) ; } else if ( mode = = ReadingMode . AGGREGATES ) { String [ ] parts = line . split ( <str> , <int> ) ; if ( parts . length ! = <int> ) { continue ; } json . put ( parts [ <int> ] . trim ( ) , parts [ <int> ] . trim ( ) ) ; } else if ( mode = = ReadingMode . NEXTITERATION ) { json . put ( <str> , Arrays . asList ( StressMetrics . HEADMETRICS ) ) ; json . put ( <str> , stressSettings . graph . operation ) ; if ( currentThreadCount = = null ) json . put ( <str> , stressSettings . graph . revision ) ; else json . put ( <str> , String . format ( <str> , stressSettings . graph . revision , currentThreadCount ) ) ; json . put ( <str> , StringUtils . join ( stressArguments , <str> ) ) ; json . put ( <str> , intervals ) ; stats . add ( json ) ; json = new JSONObject ( ) ; intervals = new JSONArray ( ) ; mode = ReadingMode . START ; } } } catch ( IOException e ) { throw new RuntimeException ( <str> ) ; } stats . add ( json ) ; return stats ; } private JSONObject createJSONStats ( JSONObject json ) { JSONArray stats ; if ( json = = null ) { json = new JSONObject ( ) ; stats = new JSONArray ( ) ; } else { stats = ( JSONArray ) json . get ( <str> ) ; } try { stats = parseLogStats ( new FileInputStream ( stressSettings . graph . temporaryLogFile ) , stats ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } json . put ( <str> , stressSettings . graph . title ) ; json . put ( <str> , stats ) ; return json ; } } 
