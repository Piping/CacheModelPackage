package com . badlogic . gdx . math ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import com . badlogic . gdx . math . Intersector . SplitTriangle ; public class IntersectorTest { private static boolean triangleEquals ( float [ ] base , int baseOffset , int stride , float [ ] comp ) { assertTrue ( stride > = <int> ) ; assertTrue ( base . length - baseOffset > = <int> ) ; assertTrue ( comp . length = = <int> ) ; int offset = - <int> ; for ( int i = <int> ; i < <int> ; i + + ) { int b = baseOffset + i * stride ; if ( MathUtils . isEqual ( base [ b ] , comp [ <int> ] ) & & MathUtils . isEqual ( base [ b + <int> ] , comp [ <int> ] ) & & MathUtils . isEqual ( base [ b + <int> ] , comp [ <int> ] ) ) { offset = i ; break ; } } assertTrue ( <str> , offset ! = - <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { int b = baseOffset + ( ( offset + i ) * stride ) % ( <int> * stride ) ; int c = i * stride ; if ( ! MathUtils . isEqual ( base [ b ] , comp [ c ] ) | | ! MathUtils . isEqual ( base [ b + <int> ] , comp [ c + <int> ] ) | | ! MathUtils . isEqual ( base [ b + <int> ] , comp [ c + <int> ] ) ) { return false ; } } return true ; } @Test public void testSplitTriangle ( ) { Plane plane = new Plane ( new Vector3 ( <int> , <int> , <int> ) , <int> ) ; SplitTriangle split = new SplitTriangle ( <int> ) ; { float [ ] fTriangle = { - <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , <int> , <int> } ; Intersector . splitTriangle ( fTriangle , plane , split ) ; assertTrue ( split . numBack = = <int> ) ; assertTrue ( split . numFront = = <int> ) ; assertTrue ( split . total = = <int> ) ; assertTrue ( triangleEquals ( split . back , <int> , <int> , fTriangle ) ) ; fTriangle [ <int> ] = <float> ; assertFalse ( <str> , triangleEquals ( split . back , <int> , <int> , fTriangle ) ) ; } { float [ ] fTriangle = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; Intersector . splitTriangle ( fTriangle , plane , split ) ; assertTrue ( split . numBack = = <int> ) ; assertTrue ( split . numFront = = <int> ) ; assertTrue ( split . total = = <int> ) ; assertTrue ( triangleEquals ( split . front , <int> , <int> , fTriangle ) ) ; } { float [ ] triangle = { - <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , - <int> } ; Intersector . splitTriangle ( triangle , plane , split ) ; assertTrue ( split . numBack = = <int> ) ; assertTrue ( split . numFront = = <int> ) ; assertTrue ( split . total = = <int> ) ; assertTrue ( triangleEquals ( split . front , <int> , <int> , new float [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> } ) ) ; float [ ] [ ] firstWay = { { - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> } , { - <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> } } ; float [ ] [ ] secondWay = { { - <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , - <int> } , { <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> } } ; float [ ] base = split . back ; boolean first = ( triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) ) | | ( triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) ) ; boolean second = ( triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) ) | | ( triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) ) ; assertTrue ( <str> + first + <str> + second + <str> , first ^ second ) ; } { float [ ] triangle = { <int> , <int> , <int> , - <int> , <int> , <int> , <int> , <int> , - <int> } ; Intersector . splitTriangle ( triangle , plane , split ) ; assertTrue ( split . numBack = = <int> ) ; assertTrue ( split . numFront = = <int> ) ; assertTrue ( split . total = = <int> ) ; assertTrue ( triangleEquals ( split . back , <int> , <int> , new float [ ] { <int> , <int> , <int> , - <int> , <int> , <int> , <int> , <int> , - <int> } ) ) ; float [ ] [ ] firstWay = { { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> } , { <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , - <int> } } ; float [ ] [ ] secondWay = { { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> } , { <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , - <int> } } ; float [ ] base = split . front ; boolean first = ( triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) ) | | ( triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , firstWay [ <int> ] ) ) ; boolean second = ( triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) ) | | ( triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) & & triangleEquals ( base , <int> , <int> , secondWay [ <int> ] ) ) ; assertTrue ( <str> + first + <str> + second + <str> , first ^ second ) ; } } } 
