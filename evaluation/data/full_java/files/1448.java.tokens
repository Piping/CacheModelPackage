package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Iterators ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . index . StubIndex ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class RangeTombstoneTest { private static final String KSNAME = <str> ; private static final String CFNAME = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KSNAME , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KSNAME , CFNAME , <int> , UTF8Type . instance , Int32Type . instance , Int32Type . instance ) ) ; } @Test public void simpleQueryWithRangeTombstoneTest ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CFNAME ) ; String key = <str> ; UpdateBuilder builder ; builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; int [ ] live = new int [ ] { <int> , <int> , <int> , <int> , <int> } ; int [ ] dead = new int [ ] { <int> , <int> , <int> , <int> , <int> } ; AbstractReadCommandBuilder . SinglePartitionBuilder cmdBuilder = Util . cmd ( cfs , key ) ; for ( int i : live ) cmdBuilder . includeRow ( i ) ; for ( int i : dead ) cmdBuilder . includeRow ( i ) ; Partition partition = Util . getOnlyPartitionUnfiltered ( cmdBuilder . build ( ) ) ; int nowInSec = FBUtilities . nowInSeconds ( ) ; for ( int i : live ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; for ( int i : dead ) assertFalse ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; for ( int i : new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; for ( int i : new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) assertFalse ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; } @Test public void rangeTombstoneFilteringTest ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CFNAME ) ; String key = <str> ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; ImmutableBTreePartition partition ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; Collection < RangeTombstone > rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; Slices . Builder sb = new Slices . Builder ( cfs . getComparator ( ) ) ; sb . add ( Slice . Bound . create ( cfs . getComparator ( ) , true , true , <int> ) , Slice . Bound . create ( cfs . getComparator ( ) , false , true , <int> ) ) ; sb . add ( Slice . Bound . create ( cfs . getComparator ( ) , true , true , <int> ) , Slice . Bound . create ( cfs . getComparator ( ) , false , true , <int> ) ) ; partition = Util . getOnlyPartitionUnfiltered ( SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , Util . dk ( key ) , sb . build ( ) ) ) ; rt = rangeTombstones ( partition ) ; assertEquals ( <int> , rt . size ( ) ) ; } private Collection < RangeTombstone > rangeTombstones ( ImmutableBTreePartition partition ) { List < RangeTombstone > tombstones = new ArrayList < RangeTombstone > ( ) ; Iterators . addAll ( tombstones , partition . deletionInfo ( ) . rangeIterator ( false ) ) ; return tombstones ; } @Test public void testTrackTimesPartitionTombstone ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . truncateBlocking ( ) ; String key = <str> ; int nowInSec = FBUtilities . nowInSeconds ( ) ; new Mutation ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , Util . dk ( key ) , <int> , nowInSec ) ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , nowInSec ) ; cfs . forceMajorCompaction ( ) ; sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , nowInSec ) ; } @Test public void testTrackTimesPartitionTombstoneWithData ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . truncateBlocking ( ) ; String key = <str> ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . apply ( ) ; key = <str> ; int nowInSec = FBUtilities . nowInSeconds ( ) ; new Mutation ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , Util . dk ( key ) , <int> , nowInSec ) ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , Integer . MAX_VALUE ) ; cfs . forceMajorCompaction ( ) ; sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , Integer . MAX_VALUE ) ; } @Test public void testTrackTimesRangeTombstone ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . truncateBlocking ( ) ; String key = <str> ; int nowInSec = FBUtilities . nowInSeconds ( ) ; new RowUpdateBuilder ( cfs . metadata , nowInSec , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , nowInSec ) ; cfs . forceMajorCompaction ( ) ; sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , nowInSec ) ; } @Test public void testTrackTimesRangeTombstoneWithData ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . truncateBlocking ( ) ; String key = <str> ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . apply ( ) ; key = <str> ; int nowInSec = FBUtilities . nowInSeconds ( ) ; new Mutation ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , Util . dk ( key ) , <int> , nowInSec ) ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , Integer . MAX_VALUE ) ; cfs . forceMajorCompaction ( ) ; sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertTimes ( sstable . getSSTableMetadata ( ) , <int> , <int> , Integer . MAX_VALUE ) ; } private void assertTimes ( StatsMetadata metadata , long min , long max , int localDeletionTime ) { assertEquals ( min , metadata . minTimestamp ) ; assertEquals ( max , metadata . maxTimestamp ) ; assertEquals ( localDeletionTime , metadata . maxLocalDeletionTime ) ; } @Test public void test7810 ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; String key = <str> ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . newRow ( i ) . add ( <str> , i ) ; builder . apply ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; Thread . sleep ( <int> ) ; cfs . forceMajorCompaction ( ) ; assertEquals ( <int> , Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) . rowCount ( ) ) ; } @Test public void test7808_1 ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; String key = <str> ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) builder . newRow ( i ) . add ( <str> , i ) ; builder . apply ( ) ; cfs . forceBlockingFlush ( ) ; new Mutation ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , Util . dk ( key ) , <int> , <int> ) ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; Thread . sleep ( <int> ) ; cfs . forceMajorCompaction ( ) ; } @Test public void test7808_2 ( ) throws ExecutionException , InterruptedException { Keyspace ks = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CFNAME ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; String key = <str> ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . newRow ( i ) . add ( <str> , i ) ; builder . apply ( ) ; cfs . forceBlockingFlush ( ) ; new Mutation ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , Util . dk ( key ) , <int> , <int> ) ) . apply ( ) ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; Thread . sleep ( <int> ) ; cfs . forceMajorCompaction ( ) ; assertEquals ( <int> , Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) . rowCount ( ) ) ; } @Test public void overlappingRangeTest ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CFNAME ) ; String key = <str> ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Partition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; int nowInSec = FBUtilities . nowInSeconds ( ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) assertFalse ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; CompactionManager . instance . performMaximal ( cfs , false ) ; partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( FBUtilities . nowInSeconds ( ) ) ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( FBUtilities . nowInSeconds ( ) ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) assertFalse ( <str> + i + <str> , partition . getRow ( new Clustering ( bb ( i ) ) ) . hasLiveData ( nowInSec ) ) ; } @Test public void reverseQueryTest ( ) throws Exception { Keyspace table = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; String key = <str> ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; FilteredPartition partition = Util . getOnlyPartition ( Util . cmd ( cfs , key ) . build ( ) ) ; assertTrue ( partition . rowCount ( ) > <int> ) ; int last = i ( partition . unfilteredIterator ( ColumnFilter . all ( cfs . metadata ) , Slices . ALL , true ) . next ( ) . clustering ( ) . get ( <int> ) ) ; assertEquals ( <str> , <int> , last ) ; } @Test public void testRowWithRangeTombstonesUpdatesSecondaryIndex ( ) throws Exception { Keyspace table = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; ByteBuffer indexedColumnName = ByteBufferUtil . bytes ( <str> ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ColumnDefinition cd = cfs . metadata . getColumnDefinition ( indexedColumnName ) . copy ( ) ; IndexMetadata indexDef = IndexMetadata . fromIndexTargets ( cfs . metadata , Collections . singletonList ( new IndexTarget ( cd . name , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . CUSTOM , ImmutableMap . of ( IndexTarget . CUSTOM_INDEX_OPTION_NAME , StubIndex . class . getName ( ) ) ) ; if ( ! cfs . metadata . getIndexes ( ) . get ( <str> ) . isPresent ( ) ) cfs . metadata . indexes ( cfs . metadata . getIndexes ( ) . with ( indexDef ) ) ; Future < ? > rebuild = cfs . indexManager . addIndex ( indexDef ) ; if ( rebuild ! = null ) rebuild . get ( ) ; StubIndex index = ( StubIndex ) cfs . indexManager . listIndexes ( ) . stream ( ) . filter ( i - > <str> . equals ( i . getIndexMetadata ( ) . name ) ) . findFirst ( ) . orElseThrow ( ( ) - > new RuntimeException ( new AssertionError ( <str> ) ) ) ; index . reset ( ) ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( <int> , index . rowsInserted . size ( ) ) ; CompactionManager . instance . performMaximal ( cfs , false ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; assertEquals ( <int> , index . rowsDeleted . size ( ) ) ; } @Test public void testRangeTombstoneCompaction ( ) throws Exception { Keyspace table = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) builder . newRow ( i ) . add ( <str> , i ) ; builder . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; CompactionManager . instance . performMaximal ( cfs , false ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( UnfilteredPartitionIterator scanner = sstable . getScanner ( ) ) { try ( UnfilteredRowIterator iter = scanner . next ( ) ) { Unfiltered u1 = iter . next ( ) ; assertTrue ( <str> + u1 . toString ( cfs . metadata ) , u1 instanceof RangeTombstoneMarker ) ; Unfiltered u2 = iter . next ( ) ; assertTrue ( <str> + u2 . toString ( cfs . metadata ) , u2 instanceof RangeTombstoneMarker ) ; Unfiltered u3 = iter . next ( ) ; assertTrue ( <str> + u3 . toString ( cfs . metadata ) , u3 instanceof Row ) ; } } } @Test public void testOverwritesToDeletedColumns ( ) throws Exception { Keyspace table = Keyspace . open ( KSNAME ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; ByteBuffer indexedColumnName = ByteBufferUtil . bytes ( <str> ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ColumnDefinition cd = cfs . metadata . getColumnDefinition ( indexedColumnName ) . copy ( ) ; IndexMetadata indexDef = IndexMetadata . fromIndexTargets ( cfs . metadata , Collections . singletonList ( new IndexTarget ( cd . name , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . CUSTOM , ImmutableMap . of ( IndexTarget . CUSTOM_INDEX_OPTION_NAME , StubIndex . class . getName ( ) ) ) ; if ( ! cfs . metadata . getIndexes ( ) . get ( <str> ) . isPresent ( ) ) cfs . metadata . indexes ( cfs . metadata . getIndexes ( ) . with ( indexDef ) ) ; Future < ? > rebuild = cfs . indexManager . addIndex ( indexDef ) ; if ( rebuild ! = null ) rebuild . get ( ) ; StubIndex index = ( StubIndex ) cfs . indexManager . getIndexByName ( <str> ) ; index . reset ( ) ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . addRangeTombstone ( <int> , <int> ) . build ( ) . applyUnsafe ( ) ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( <int> ) . newRow ( <int> ) . add ( <str> , <int> ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( <int> , index . rowsInserted . size ( ) ) ; assertEquals ( <int> , index . rowsUpdated . size ( ) ) ; } private static ByteBuffer bb ( int i ) { return ByteBufferUtil . bytes ( i ) ; } private static int i ( ByteBuffer bb ) { return ByteBufferUtil . toInt ( bb ) ; } } 
