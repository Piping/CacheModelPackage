package org . elasticsearch . http . netty ; import java . nio . charset . StandardCharsets ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . jboss . netty . bootstrap . ClientBootstrap ; import org . jboss . netty . channel . * ; import org . jboss . netty . channel . socket . nio . NioClientSocketChannelFactory ; import org . jboss . netty . handler . codec . http . * ; import java . io . Closeable ; import java . net . SocketAddress ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import static org . jboss . netty . handler . codec . http . HttpHeaders . Names . HOST ; import static org . jboss . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; public class NettyHttpClient implements Closeable { public static Collection < String > returnHttpResponseBodies ( Collection < HttpResponse > responses ) { List < String > list = new ArrayList < > ( responses . size ( ) ) ; for ( HttpResponse response : responses ) { list . add ( response . getContent ( ) . toString ( StandardCharsets . UTF_8 ) ) ; } return list ; } public static Collection < String > returnOpaqueIds ( Collection < HttpResponse > responses ) { List < String > list = new ArrayList < > ( responses . size ( ) ) ; for ( HttpResponse response : responses ) { list . add ( response . headers ( ) . get ( <str> ) ) ; } return list ; } private final ClientBootstrap clientBootstrap ; public NettyHttpClient ( ) { clientBootstrap = new ClientBootstrap ( new NioClientSocketChannelFactory ( ) ) ; ; } public synchronized Collection < HttpResponse > sendRequests ( SocketAddress remoteAddress , String . . . uris ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( uris . length ) ; final Collection < HttpResponse > content = Collections . synchronizedList ( new ArrayList < HttpResponse > ( uris . length ) ) ; clientBootstrap . setPipelineFactory ( new CountDownLatchPipelineFactory ( latch , content ) ) ; ChannelFuture channelFuture = null ; try { channelFuture = clientBootstrap . connect ( remoteAddress ) ; channelFuture . await ( <int> ) ; for ( int i = <int> ; i < uris . length ; i + + ) { final HttpRequest httpRequest = new DefaultHttpRequest ( HTTP_1_1 , HttpMethod . GET , uris [ i ] ) ; httpRequest . headers ( ) . add ( HOST , <str> ) ; httpRequest . headers ( ) . add ( <str> , String . valueOf ( i ) ) ; channelFuture . getChannel ( ) . write ( httpRequest ) ; } latch . await ( ) ; } finally { if ( channelFuture ! = null ) { channelFuture . getChannel ( ) . close ( ) ; } } return content ; } @Override public void close ( ) { clientBootstrap . shutdown ( ) ; clientBootstrap . releaseExternalResources ( ) ; } public static class CountDownLatchPipelineFactory implements ChannelPipelineFactory { private final CountDownLatch latch ; private final Collection < HttpResponse > content ; public CountDownLatchPipelineFactory ( CountDownLatch latch , Collection < HttpResponse > content ) { this . latch = latch ; this . content = content ; } @Override public ChannelPipeline getPipeline ( ) throws Exception { final int maxBytes = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) . bytesAsInt ( ) ; return Channels . pipeline ( new HttpClientCodec ( ) , new HttpChunkAggregator ( maxBytes ) , new SimpleChannelUpstreamHandler ( ) { @Override public void messageReceived ( final ChannelHandlerContext ctx , final MessageEvent e ) { final Object message = e . getMessage ( ) ; if ( message instanceof HttpResponse ) { HttpResponse response = ( HttpResponse ) message ; content . add ( response ) ; } latch . countDown ( ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { super . exceptionCaught ( ctx , e ) ; latch . countDown ( ) ; } } ) ; } } } 
