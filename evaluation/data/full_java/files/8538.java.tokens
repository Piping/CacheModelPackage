package org . elasticsearch . search . suggest . completion ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . search . suggest . document . ContextSuggestField ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . search . suggest . completion . context . CategoryContextMapping ; import org . elasticsearch . search . suggest . completion . context . CategoryQueryContext ; import org . elasticsearch . search . suggest . completion . context . ContextBuilder ; import org . elasticsearch . search . suggest . completion . context . ContextMapping ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . * ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . isIn ; public class CategoryContextMappingTests extends ESSingleNodeTestCase { public void testIndexingWithNoContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . array ( <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . array ( <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithSimpleContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithContextList ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> , <str> , <str> ) . startObject ( <str> ) . array ( <str> , <str> , <str> , <str> ) . endObject ( ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithMultipleContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . startObject ( <str> ) . array ( <str> , <str> , <str> , <str> ) . array ( <str> , <str> , <str> ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , builder . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testQueryContextParsingBasic ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . value ( <str> ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( false ) ) ; } public void testQueryContextParsingArray ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startArray ( ) . value ( <str> ) . value ( <str> ) . endArray ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( false ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( false ) ) ; } public void testQueryContextParsingObject ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , true ) . endObject ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( true ) ) ; } public void testQueryContextParsingObjectArray ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startArray ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , true ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , false ) . endObject ( ) . endArray ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( true ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( false ) ) ; } public void testQueryContextParsingMixed ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startArray ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , true ) . endObject ( ) . value ( <str> ) . endArray ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( true ) ) ; assertThat ( queryContexts . get ( <int> ) . context , equalTo ( <str> ) ) ; assertThat ( queryContexts . get ( <int> ) . boost , equalTo ( <int> ) ) ; assertThat ( queryContexts . get ( <int> ) . isPrefix , equalTo ( false ) ) ; } public void testParsingContextFromDocument ( ) throws Exception { CategoryContextMapping mapping = ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ; ParseContext . Document document = new ParseContext . Document ( ) ; document . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; Set < CharSequence > context = mapping . parseContext ( document ) ; assertThat ( context . size ( ) , equalTo ( <int> ) ) ; assertTrue ( context . contains ( <str> ) ) ; } static void assertContextSuggestFields ( IndexableField [ ] fields , int expected ) { int actualFieldCount = <int> ; for ( IndexableField field : fields ) { if ( field instanceof ContextSuggestField ) { actualFieldCount + + ; } } assertThat ( actualFieldCount , equalTo ( expected ) ) ; } } 
