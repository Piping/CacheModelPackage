package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkElementIndex ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . SortedLists . KeyAbsentBehavior . NEXT_LOWER ; import static com . google . common . collect . SortedLists . KeyPresentBehavior . ANY_PRESENT ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . SortedLists . KeyAbsentBehavior ; import com . google . common . collect . SortedLists . KeyPresentBehavior ; import com . google . common . primitives . Ints ; import java . io . Serializable ; import java . util . Collections ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . Set ; import javax . annotation . Nullable ; @Beta public final class ImmutableRangeSet < C extends Comparable > extends AbstractRangeSet < C > implements Serializable { private static final ImmutableRangeSet < Comparable < ? > > EMPTY = new ImmutableRangeSet < Comparable < ? > > ( ImmutableList . < Range < Comparable < ? > > > of ( ) ) ; private static final ImmutableRangeSet < Comparable < ? > > ALL = new ImmutableRangeSet < Comparable < ? > > ( ImmutableList . of ( Range . < Comparable < ? > > all ( ) ) ) ; @SuppressWarnings ( <str> ) public static < C extends Comparable > ImmutableRangeSet < C > of ( ) { return ( ImmutableRangeSet < C > ) EMPTY ; } @SuppressWarnings ( <str> ) static < C extends Comparable > ImmutableRangeSet < C > all ( ) { return ( ImmutableRangeSet < C > ) ALL ; } public static < C extends Comparable > ImmutableRangeSet < C > of ( Range < C > range ) { checkNotNull ( range ) ; if ( range . isEmpty ( ) ) { return of ( ) ; } else if ( range . equals ( Range . all ( ) ) ) { return all ( ) ; } else { return new ImmutableRangeSet < C > ( ImmutableList . of ( range ) ) ; } } public static < C extends Comparable > ImmutableRangeSet < C > copyOf ( RangeSet < C > rangeSet ) { checkNotNull ( rangeSet ) ; if ( rangeSet . isEmpty ( ) ) { return of ( ) ; } else if ( rangeSet . encloses ( Range . < C > all ( ) ) ) { return all ( ) ; } if ( rangeSet instanceof ImmutableRangeSet ) { ImmutableRangeSet < C > immutableRangeSet = ( ImmutableRangeSet < C > ) rangeSet ; if ( ! immutableRangeSet . isPartialView ( ) ) { return immutableRangeSet ; } } return new ImmutableRangeSet < C > ( ImmutableList . copyOf ( rangeSet . asRanges ( ) ) ) ; } ImmutableRangeSet ( ImmutableList < Range < C > > ranges ) { this . ranges = ranges ; } private ImmutableRangeSet ( ImmutableList < Range < C > > ranges , ImmutableRangeSet < C > complement ) { this . ranges = ranges ; this . complement = complement ; } private transient final ImmutableList < Range < C > > ranges ; @Override public boolean encloses ( Range < C > otherRange ) { int index = SortedLists . binarySearch ( ranges , Range . < C > lowerBoundFn ( ) , otherRange . lowerBound , Ordering . natural ( ) , ANY_PRESENT , NEXT_LOWER ) ; return index ! = - <int> & & ranges . get ( index ) . encloses ( otherRange ) ; } @Override public Range < C > rangeContaining ( C value ) { int index = SortedLists . binarySearch ( ranges , Range . < C > lowerBoundFn ( ) , Cut . belowValue ( value ) , Ordering . natural ( ) , ANY_PRESENT , NEXT_LOWER ) ; if ( index ! = - <int> ) { Range < C > range = ranges . get ( index ) ; return range . contains ( value ) ? range : null ; } return null ; } @Override public Range < C > span ( ) { if ( ranges . isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } return Range . create ( ranges . get ( <int> ) . lowerBound , ranges . get ( ranges . size ( ) - <int> ) . upperBound ) ; } @Override public boolean isEmpty ( ) { return ranges . isEmpty ( ) ; } @Override public void add ( Range < C > range ) { throw new UnsupportedOperationException ( ) ; } @Override public void addAll ( RangeSet < C > other ) { throw new UnsupportedOperationException ( ) ; } @Override public void remove ( Range < C > range ) { throw new UnsupportedOperationException ( ) ; } @Override public void removeAll ( RangeSet < C > other ) { throw new UnsupportedOperationException ( ) ; } @Override public ImmutableSet < Range < C > > asRanges ( ) { if ( ranges . isEmpty ( ) ) { return ImmutableSet . of ( ) ; } return new RegularImmutableSortedSet < Range < C > > ( ranges , Range . RANGE_LEX_ORDERING ) ; } @Override public ImmutableSet < Range < C > > asDescendingSetOfRanges ( ) { if ( ranges . isEmpty ( ) ) { return ImmutableSet . of ( ) ; } return new RegularImmutableSortedSet < Range < C > > ( ranges . reverse ( ) , Range . RANGE_LEX_ORDERING . reverse ( ) ) ; } private transient ImmutableRangeSet < C > complement ; private final class ComplementRanges extends ImmutableList < Range < C > > { private final boolean positiveBoundedBelow ; private final boolean positiveBoundedAbove ; private final int size ; ComplementRanges ( ) { this . positiveBoundedBelow = ranges . get ( <int> ) . hasLowerBound ( ) ; this . positiveBoundedAbove = Iterables . getLast ( ranges ) . hasUpperBound ( ) ; int size = ranges . size ( ) - <int> ; if ( positiveBoundedBelow ) { size + + ; } if ( positiveBoundedAbove ) { size + + ; } this . size = size ; } @Override public int size ( ) { return size ; } @Override public Range < C > get ( int index ) { checkElementIndex ( index , size ) ; Cut < C > lowerBound ; if ( positiveBoundedBelow ) { lowerBound = ( index = = <int> ) ? Cut . < C > belowAll ( ) : ranges . get ( index - <int> ) . upperBound ; } else { lowerBound = ranges . get ( index ) . upperBound ; } Cut < C > upperBound ; if ( positiveBoundedAbove & & index = = size - <int> ) { upperBound = Cut . < C > aboveAll ( ) ; } else { upperBound = ranges . get ( index + ( positiveBoundedBelow ? <int> : <int> ) ) . lowerBound ; } return Range . create ( lowerBound , upperBound ) ; } @Override boolean isPartialView ( ) { return true ; } } @Override public ImmutableRangeSet < C > complement ( ) { ImmutableRangeSet < C > result = complement ; if ( result ! = null ) { return result ; } else if ( ranges . isEmpty ( ) ) { return complement = all ( ) ; } else if ( ranges . size ( ) = = <int> & & ranges . get ( <int> ) . equals ( Range . all ( ) ) ) { return complement = of ( ) ; } else { ImmutableList < Range < C > > complementRanges = new ComplementRanges ( ) ; result = complement = new ImmutableRangeSet < C > ( complementRanges , this ) ; } return result ; } private ImmutableList < Range < C > > intersectRanges ( final Range < C > range ) { if ( ranges . isEmpty ( ) | | range . isEmpty ( ) ) { return ImmutableList . of ( ) ; } else if ( range . encloses ( span ( ) ) ) { return ranges ; } final int fromIndex ; if ( range . hasLowerBound ( ) ) { fromIndex = SortedLists . binarySearch ( ranges , Range . < C > upperBoundFn ( ) , range . lowerBound , KeyPresentBehavior . FIRST_AFTER , KeyAbsentBehavior . NEXT_HIGHER ) ; } else { fromIndex = <int> ; } int toIndex ; if ( range . hasUpperBound ( ) ) { toIndex = SortedLists . binarySearch ( ranges , Range . < C > lowerBoundFn ( ) , range . upperBound , KeyPresentBehavior . FIRST_PRESENT , KeyAbsentBehavior . NEXT_HIGHER ) ; } else { toIndex = ranges . size ( ) ; } final int length = toIndex - fromIndex ; if ( length = = <int> ) { return ImmutableList . of ( ) ; } else { return new ImmutableList < Range < C > > ( ) { @Override public int size ( ) { return length ; } @Override public Range < C > get ( int index ) { checkElementIndex ( index , length ) ; if ( index = = <int> | | index = = length - <int> ) { return ranges . get ( index + fromIndex ) . intersection ( range ) ; } else { return ranges . get ( index + fromIndex ) ; } } @Override boolean isPartialView ( ) { return true ; } } ; } } @Override public ImmutableRangeSet < C > subRangeSet ( Range < C > range ) { if ( ! isEmpty ( ) ) { Range < C > span = span ( ) ; if ( range . encloses ( span ) ) { return this ; } else if ( range . isConnected ( span ) ) { return new ImmutableRangeSet < C > ( intersectRanges ( range ) ) ; } } return of ( ) ; } public ImmutableSortedSet < C > asSet ( DiscreteDomain < C > domain ) { checkNotNull ( domain ) ; if ( isEmpty ( ) ) { return ImmutableSortedSet . of ( ) ; } Range < C > span = span ( ) . canonical ( domain ) ; if ( ! span . hasLowerBound ( ) ) { throw new IllegalArgumentException ( <str> ) ; } else if ( ! span . hasUpperBound ( ) ) { try { domain . maxValue ( ) ; } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( <str> ) ; } } return new AsSet ( domain ) ; } private final class AsSet extends ImmutableSortedSet < C > { private final DiscreteDomain < C > domain ; AsSet ( DiscreteDomain < C > domain ) { super ( Ordering . natural ( ) ) ; this . domain = domain ; } private transient Integer size ; @Override public int size ( ) { Integer result = size ; if ( result = = null ) { long total = <int> ; for ( Range < C > range : ranges ) { total + = ContiguousSet . create ( range , domain ) . size ( ) ; if ( total > = Integer . MAX_VALUE ) { break ; } } result = size = Ints . saturatedCast ( total ) ; } return result . intValue ( ) ; } @Override public UnmodifiableIterator < C > iterator ( ) { return new AbstractIterator < C > ( ) { final Iterator < Range < C > > rangeItr = ranges . iterator ( ) ; Iterator < C > elemItr = Iterators . emptyIterator ( ) ; @Override protected C computeNext ( ) { while ( ! elemItr . hasNext ( ) ) { if ( rangeItr . hasNext ( ) ) { elemItr = ContiguousSet . create ( rangeItr . next ( ) , domain ) . iterator ( ) ; } else { return endOfData ( ) ; } } return elemItr . next ( ) ; } } ; } @Override @GwtIncompatible ( <str> ) public UnmodifiableIterator < C > descendingIterator ( ) { return new AbstractIterator < C > ( ) { final Iterator < Range < C > > rangeItr = ranges . reverse ( ) . iterator ( ) ; Iterator < C > elemItr = Iterators . emptyIterator ( ) ; @Override protected C computeNext ( ) { while ( ! elemItr . hasNext ( ) ) { if ( rangeItr . hasNext ( ) ) { elemItr = ContiguousSet . create ( rangeItr . next ( ) , domain ) . descendingIterator ( ) ; } else { return endOfData ( ) ; } } return elemItr . next ( ) ; } } ; } ImmutableSortedSet < C > subSet ( Range < C > range ) { return subRangeSet ( range ) . asSet ( domain ) ; } @Override ImmutableSortedSet < C > headSetImpl ( C toElement , boolean inclusive ) { return subSet ( Range . upTo ( toElement , BoundType . forBoolean ( inclusive ) ) ) ; } @Override ImmutableSortedSet < C > subSetImpl ( C fromElement , boolean fromInclusive , C toElement , boolean toInclusive ) { if ( ! fromInclusive & & ! toInclusive & & Range . compareOrThrow ( fromElement , toElement ) = = <int> ) { return ImmutableSortedSet . of ( ) ; } return subSet ( Range . range ( fromElement , BoundType . forBoolean ( fromInclusive ) , toElement , BoundType . forBoolean ( toInclusive ) ) ) ; } @Override ImmutableSortedSet < C > tailSetImpl ( C fromElement , boolean inclusive ) { return subSet ( Range . downTo ( fromElement , BoundType . forBoolean ( inclusive ) ) ) ; } @Override public boolean contains ( @Nullable Object o ) { if ( o = = null ) { return false ; } try { @SuppressWarnings ( <str> ) C c = ( C ) o ; return ImmutableRangeSet . this . contains ( c ) ; } catch ( ClassCastException e ) { return false ; } } @Override int indexOf ( Object target ) { if ( contains ( target ) ) { @SuppressWarnings ( <str> ) C c = ( C ) target ; long total = <int> ; for ( Range < C > range : ranges ) { if ( range . contains ( c ) ) { return Ints . saturatedCast ( total + ContiguousSet . create ( range , domain ) . indexOf ( c ) ) ; } else { total + = ContiguousSet . create ( range , domain ) . size ( ) ; } } throw new AssertionError ( <str> ) ; } return - <int> ; } @Override boolean isPartialView ( ) { return ranges . isPartialView ( ) ; } @Override public String toString ( ) { return ranges . toString ( ) ; } @Override Object writeReplace ( ) { return new AsSetSerializedForm < C > ( ranges , domain ) ; } } private static class AsSetSerializedForm < C extends Comparable > implements Serializable { private final ImmutableList < Range < C > > ranges ; private final DiscreteDomain < C > domain ; AsSetSerializedForm ( ImmutableList < Range < C > > ranges , DiscreteDomain < C > domain ) { this . ranges = ranges ; this . domain = domain ; } Object readResolve ( ) { return new ImmutableRangeSet < C > ( ranges ) . asSet ( domain ) ; } } boolean isPartialView ( ) { return ranges . isPartialView ( ) ; } public static < C extends Comparable < ? > > Builder < C > builder ( ) { return new Builder < C > ( ) ; } public static class Builder < C extends Comparable < ? > > { private final RangeSet < C > rangeSet ; public Builder ( ) { this . rangeSet = TreeRangeSet . create ( ) ; } public Builder < C > add ( Range < C > range ) { if ( range . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + range ) ; } else if ( ! rangeSet . complement ( ) . encloses ( range ) ) { for ( Range < C > currentRange : rangeSet . asRanges ( ) ) { checkArgument ( ! currentRange . isConnected ( range ) | | currentRange . intersection ( range ) . isEmpty ( ) , <str> , currentRange , range ) ; } throw new AssertionError ( <str> ) ; } rangeSet . add ( range ) ; return this ; } public Builder < C > addAll ( RangeSet < C > ranges ) { for ( Range < C > range : ranges . asRanges ( ) ) { add ( range ) ; } return this ; } public ImmutableRangeSet < C > build ( ) { return copyOf ( rangeSet ) ; } } private static final class SerializedForm < C extends Comparable > implements Serializable { private final ImmutableList < Range < C > > ranges ; SerializedForm ( ImmutableList < Range < C > > ranges ) { this . ranges = ranges ; } Object readResolve ( ) { if ( ranges . isEmpty ( ) ) { return of ( ) ; } else if ( ranges . equals ( ImmutableList . of ( Range . all ( ) ) ) ) { return all ( ) ; } else { return new ImmutableRangeSet < C > ( ranges ) ; } } } Object writeReplace ( ) { return new SerializedForm < C > ( ranges ) ; } } 
