package org . elasticsearch . common . io ; import java . io . IOException ; import java . io . Writer ; import java . util . Arrays ; public class FastCharArrayWriter extends Writer { protected char buf [ ] ; protected int count ; public FastCharArrayWriter ( ) { this ( <int> ) ; } public FastCharArrayWriter ( int initialSize ) { if ( initialSize < <int> ) { throw new IllegalArgumentException ( <str> + initialSize ) ; } buf = new char [ initialSize ] ; } @Override public void write ( int c ) { int newcount = count + <int> ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length < < <int> , newcount ) ) ; } buf [ count ] = ( char ) c ; count = newcount ; } @Override public void write ( char c [ ] , int off , int len ) { if ( ( off < <int> ) | | ( off > c . length ) | | ( len < <int> ) | | ( ( off + len ) > c . length ) | | ( ( off + len ) < <int> ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len = = <int> ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length < < <int> , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; } @Override public void write ( String str , int off , int len ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length < < <int> , newcount ) ) ; } str . getChars ( off , off + len , buf , count ) ; count = newcount ; } public void writeTo ( Writer out ) throws IOException { out . write ( buf , <int> , count ) ; } @Override public FastCharArrayWriter append ( CharSequence csq ) { String s = ( csq = = null ? <str> : csq . toString ( ) ) ; write ( s , <int> , s . length ( ) ) ; return this ; } @Override public FastCharArrayWriter append ( CharSequence csq , int start , int end ) { String s = ( csq = = null ? <str> : csq ) . subSequence ( start , end ) . toString ( ) ; write ( s , <int> , s . length ( ) ) ; return this ; } @Override public FastCharArrayWriter append ( char c ) { write ( c ) ; return this ; } public void reset ( ) { count = <int> ; } public char toCharArray ( ) [ ] { return Arrays . copyOf ( buf , count ) ; } public char [ ] unsafeCharArray ( ) { return buf ; } public int size ( ) { return count ; } @Override public String toString ( ) { return new String ( buf , <int> , count ) ; } public String toStringTrim ( ) { int st = <int> ; int len = count ; char [ ] val = buf ; while ( ( st < len ) & & ( val [ st ] < = <str> ) ) { st + + ; len - - ; } while ( ( st < len ) & & ( val [ len - <int> ] < = <str> ) ) { len - - ; } return new String ( buf , st , len ) ; } @Override public void flush ( ) { } @Override public void close ( ) { } } 
