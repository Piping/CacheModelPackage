package org . elasticsearch . search . aggregations . bucket . range . ipv4 ; import org . elasticsearch . common . network . Cidrs ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . mapper . ip . IpFieldMapper ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . bucket . range . RangeAggregator ; import org . elasticsearch . search . aggregations . support . ValueType ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class IpRangeParser implements Aggregator . Parser { @Override public String type ( ) { return InternalIPv4Range . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { ValuesSourceParser < ValuesSource . Numeric > vsParser = ValuesSourceParser . numeric ( aggregationName , InternalIPv4Range . TYPE , context ) . targetValueType ( ValueType . IP ) . formattable ( false ) . build ( ) ; List < RangeAggregator . Range > ranges = null ; boolean keyed = false ; XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( vsParser . token ( currentFieldName , token , parser ) ) { continue ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { ranges = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { double from = Double . NEGATIVE_INFINITY ; String fromAsStr = null ; double to = Double . POSITIVE_INFINITY ; String toAsStr = null ; String key = null ; String mask = null ; String toOrFromOrMaskOrKey = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { toOrFromOrMaskOrKey = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { from = parser . doubleValue ( ) ; } else if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { to = parser . doubleValue ( ) ; } } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { fromAsStr = parser . text ( ) ; } else if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { toAsStr = parser . text ( ) ; } else if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { key = parser . text ( ) ; } else if ( <str> . equals ( toOrFromOrMaskOrKey ) ) { mask = parser . text ( ) ; } } } RangeAggregator . Range range = new RangeAggregator . Range ( key , from , fromAsStr , to , toAsStr ) ; if ( mask ! = null ) { parseMaskRange ( mask , range , aggregationName , context ) ; } ranges . add ( range ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { if ( <str> . equals ( currentFieldName ) ) { keyed = parser . booleanValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( ranges = = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } return new RangeAggregator . Factory ( aggregationName , vsParser . config ( ) , InternalIPv4Range . FACTORY , ranges , keyed ) ; } private static void parseMaskRange ( String cidr , RangeAggregator . Range range , String aggregationName , SearchContext ctx ) { long [ ] fromTo ; try { fromTo = Cidrs . cidrMaskToMinMax ( cidr ) ; } catch ( IllegalArgumentException e ) { throw new SearchParseException ( ctx , <str> + cidr + <str> + aggregationName + <str> , null , e ) ; } range . from = fromTo [ <int> ] = = <int> ? Double . NEGATIVE_INFINITY : fromTo [ <int> ] ; range . to = fromTo [ <int> ] = = InternalIPv4Range . MAX_IP ? Double . POSITIVE_INFINITY : fromTo [ <int> ] ; if ( range . key = = null ) { range . key = cidr ; } } } 
