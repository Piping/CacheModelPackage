package org . apache . cassandra . schema ; import java . util . * ; import com . google . common . collect . ImmutableMap ; import org . apache . cassandra . config . Schema ; import static com . google . common . collect . Iterables . filter ; public class Indexes implements Iterable < IndexMetadata > { private final ImmutableMap < String , IndexMetadata > indexesByName ; private final ImmutableMap < UUID , IndexMetadata > indexesById ; private Indexes ( Builder builder ) { indexesByName = builder . indexesByName . build ( ) ; indexesById = builder . indexesById . build ( ) ; } public static Builder builder ( ) { return new Builder ( ) ; } public static Indexes none ( ) { return builder ( ) . build ( ) ; } public Iterator < IndexMetadata > iterator ( ) { return indexesByName . values ( ) . iterator ( ) ; } public int size ( ) { return indexesByName . size ( ) ; } public boolean isEmpty ( ) { return indexesByName . isEmpty ( ) ; } public Optional < IndexMetadata > get ( String name ) { return Optional . ofNullable ( indexesByName . get ( name ) ) ; } public boolean has ( String name ) { return indexesByName . containsKey ( name ) ; } public Optional < IndexMetadata > get ( UUID id ) { return Optional . ofNullable ( indexesById . get ( id ) ) ; } public boolean has ( UUID id ) { return indexesById . containsKey ( id ) ; } public Indexes with ( IndexMetadata index ) { if ( get ( index . name ) . isPresent ( ) ) throw new IllegalStateException ( String . format ( <str> , index . name ) ) ; return builder ( ) . add ( this ) . add ( index ) . build ( ) ; } public Indexes without ( String name ) { IndexMetadata index = get ( name ) . orElseThrow ( ( ) - > new IllegalStateException ( String . format ( <str> , name ) ) ) ; return builder ( ) . add ( filter ( this , v - > v ! = index ) ) . build ( ) ; } public Indexes replace ( IndexMetadata index ) { return without ( index . name ) . with ( index ) ; } @Override public boolean equals ( Object o ) { return this = = o | | ( o instanceof Indexes & & indexesByName . equals ( ( ( Indexes ) o ) . indexesByName ) ) ; } @Override public int hashCode ( ) { return indexesByName . hashCode ( ) ; } @Override public String toString ( ) { return indexesByName . values ( ) . toString ( ) ; } public static String getAvailableIndexName ( String ksName , String cfName , String indexNameRoot ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; Set < String > existingNames = ksm = = null ? new HashSet < > ( ) : ksm . existingIndexNames ( null ) ; String baseName = IndexMetadata . getDefaultIndexName ( cfName , indexNameRoot ) ; String acceptedName = baseName ; int i = <int> ; while ( existingNames . contains ( acceptedName ) ) acceptedName = baseName + <str> + ( + + i ) ; return acceptedName ; } public static final class Builder { final ImmutableMap . Builder < String , IndexMetadata > indexesByName = new ImmutableMap . Builder < > ( ) ; final ImmutableMap . Builder < UUID , IndexMetadata > indexesById = new ImmutableMap . Builder < > ( ) ; private Builder ( ) { } public Indexes build ( ) { return new Indexes ( this ) ; } public Builder add ( IndexMetadata index ) { indexesByName . put ( index . name , index ) ; indexesById . put ( index . id , index ) ; return this ; } public Builder add ( Iterable < IndexMetadata > indexes ) { indexes . forEach ( this : : add ) ; return this ; } } } 
