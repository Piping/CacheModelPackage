package com . google . common . math ; import static com . google . common . math . StatsTesting . assertDiagonalLinearTransformation ; import static com . google . common . math . StatsTesting . assertHorizontalLinearTransformation ; import static com . google . common . math . StatsTesting . assertLinearTransformationNaN ; import static com . google . common . math . StatsTesting . assertVerticalLinearTransformation ; import static com . google . common . truth . Truth . assertThat ; import junit . framework . TestCase ; public class LinearTransformationTest extends TestCase { private static final double ALLOWED_ERROR = <float> ; public void testMappingAnd_regular ( ) { double x1 = <float> ; double y1 = <float> ; double xDelta = <float> ; double yDelta = <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y1 ) . and ( x1 + xDelta , y1 + yDelta ) ; assertDiagonalLinearTransformation ( transformation , x1 , y1 , xDelta , yDelta ) ; } public void testMappingAnd_horizontal ( ) { double x1 = <float> ; double xDelta = <float> ; double y = <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y ) . and ( x1 + xDelta , y ) ; assertHorizontalLinearTransformation ( transformation , y ) ; } public void testMappingAnd_vertical ( ) { double x = <float> ; double y1 = <float> ; double yDelta = <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x , y1 ) . and ( x , y1 + yDelta ) ; assertVerticalLinearTransformation ( transformation , x ) ; } public void testMapping_infiniteX1 ( ) { try { LinearTransformation . mapping ( Double . POSITIVE_INFINITY , <float> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMapping_infiniteY1 ( ) { try { LinearTransformation . mapping ( <float> , Double . NEGATIVE_INFINITY ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingAnd_infiniteX2 ( ) { try { LinearTransformation . mapping ( <float> , <float> ) . and ( Double . NEGATIVE_INFINITY , <float> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingAnd_infiniteY2 ( ) { try { LinearTransformation . mapping ( <float> , <float> ) . and ( <float> , Double . POSITIVE_INFINITY ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMapping_nanX1 ( ) { try { LinearTransformation . mapping ( Double . NaN , <float> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMapping_nanY1 ( ) { try { LinearTransformation . mapping ( <float> , Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingAnd_nanX2 ( ) { try { LinearTransformation . mapping ( <float> , <float> ) . and ( Double . NaN , <float> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingAnd_nanY2 ( ) { try { LinearTransformation . mapping ( <float> , <float> ) . and ( <float> , Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingAnd_samePointTwice ( ) { try { double x = <float> ; double y = <float> ; LinearTransformation . mapping ( x , y ) . and ( x , y ) ; fail ( <str> + <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testMappingWithSlope_regular ( ) { double x1 = <float> ; double y1 = <float> ; double xDelta = - <float> ; double slope = - <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y1 ) . withSlope ( slope ) ; assertDiagonalLinearTransformation ( transformation , x1 , y1 , xDelta , xDelta * slope ) ; } public void testMappingWithSlope_horizontal ( ) { double x1 = <float> ; double y = <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y ) . withSlope ( <float> ) ; assertHorizontalLinearTransformation ( transformation , y ) ; } public void testMappingWithSlope_vertical ( ) { double x = <float> ; double y1 = <float> ; LinearTransformation transformation = LinearTransformation . mapping ( x , y1 ) . withSlope ( Double . POSITIVE_INFINITY ) ; assertVerticalLinearTransformation ( transformation , x ) ; } public void testMappingWithSlope_minimalSlope ( ) { double x1 = <float> ; double y1 = <float> ; double slope = Double . MIN_VALUE ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y1 ) . withSlope ( slope ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . slope ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( slope ) ; } public void testMappingWithSlope_maximalSlope ( ) { double x1 = <float> ; double y1 = <float> ; double slope = Double . MAX_VALUE ; LinearTransformation transformation = LinearTransformation . mapping ( x1 , y1 ) . withSlope ( slope ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . slope ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( slope ) ; } public void testMappingWithSlope_nanSlope ( ) { try { LinearTransformation . mapping ( <float> , <float> ) . withSlope ( Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testVertical_regular ( ) { double x = <float> ; LinearTransformation transformation = LinearTransformation . vertical ( x ) ; assertVerticalLinearTransformation ( transformation , x ) ; } public void testVertical_infiniteX ( ) { try { LinearTransformation . vertical ( Double . NEGATIVE_INFINITY ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testVertical_nanX ( ) { try { LinearTransformation . vertical ( Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testHorizontal_regular ( ) { double y = <float> ; LinearTransformation transformation = LinearTransformation . horizontal ( y ) ; assertHorizontalLinearTransformation ( transformation , y ) ; } public void testHorizontal_infiniteY ( ) { try { LinearTransformation . horizontal ( Double . POSITIVE_INFINITY ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testHorizontal_nanY ( ) { try { LinearTransformation . horizontal ( Double . NaN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testForNaN ( ) { LinearTransformation transformation = LinearTransformation . forNaN ( ) ; assertLinearTransformationNaN ( transformation ) ; } } 
