package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . testing . IteratorFeature ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . PriorityQueue ; import java . util . Random ; import java . util . SortedMap ; import java . util . concurrent . atomic . AtomicInteger ; public class MinMaxPriorityQueueTest extends TestCase { private Ordering < Integer > SOME_COMPARATOR = Ordering . natural ( ) . reverse ( ) ; public void testCreation_simple ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; checkNatural ( queue ) ; } public void testCreation_comparator ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; } public void testCreation_expectedSize ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . expectedSize ( <int> ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; checkNatural ( queue ) ; } public void testCreation_expectedSize_comparator ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . expectedSize ( <int> ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; } public void testCreation_maximumSize ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . maximumSize ( <int> ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; assertEquals ( <int> , queue . maximumSize ) ; checkNatural ( queue ) ; } public void testCreation_comparator_maximumSize ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . maximumSize ( <int> ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; assertEquals ( <int> , queue . maximumSize ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; } public void testCreation_expectedSize_maximumSize ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . expectedSize ( <int> ) . maximumSize ( <int> ) . create ( ) ; assertEquals ( <int> , queue . capacity ( ) ) ; assertEquals ( <int> , queue . maximumSize ) ; checkNatural ( queue ) ; } private static final List < Integer > NUMBERS = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ; public void testCreation_withContents ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . create ( NUMBERS ) ; assertEquals ( <int> , queue . size ( ) ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; checkNatural ( queue ) ; } public void testCreation_comparator_withContents ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . create ( NUMBERS ) ; assertEquals ( <int> , queue . size ( ) ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; } public void testCreation_expectedSize_withContents ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . expectedSize ( <int> ) . create ( NUMBERS ) ; assertEquals ( <int> , queue . size ( ) ) ; assertEquals ( <int> , queue . capacity ( ) ) ; checkUnbounded ( queue ) ; checkNatural ( queue ) ; } public void testCreation_maximumSize_withContents ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . maximumSize ( <int> ) . create ( NUMBERS ) ; assertEquals ( <int> , queue . size ( ) ) ; assertEquals ( <int> , queue . capacity ( ) ) ; assertEquals ( <int> , queue . maximumSize ) ; checkNatural ( queue ) ; } public void testCreation_allOptions ( ) { MinMaxPriorityQueue < Integer > queue = MinMaxPriorityQueue . orderedBy ( SOME_COMPARATOR ) . expectedSize ( <int> ) . maximumSize ( <int> ) . create ( NUMBERS ) ; assertEquals ( <int> , queue . size ( ) ) ; assertEquals ( <int> , queue . capacity ( ) ) ; assertEquals ( <int> , queue . maximumSize ) ; assertSame ( SOME_COMPARATOR , queue . comparator ( ) ) ; } private static void checkNatural ( MinMaxPriorityQueue < Integer > queue ) { assertSame ( Ordering . natural ( ) , queue . comparator ( ) ) ; } private static void checkUnbounded ( MinMaxPriorityQueue < Integer > queue ) { assertEquals ( Integer . MAX_VALUE , queue . maximumSize ) ; } public void testHeapIntact ( ) { Random random = new Random ( <int> ) ; int heapSize = <int> ; int numberOfModifications = <int> ; MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . expectedSize ( heapSize ) . create ( ) ; SortedMap < Integer , AtomicInteger > replica = Maps . newTreeMap ( ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; for ( int i = <int> ; i < heapSize ; i + + ) { int randomInt = random . nextInt ( ) ; mmHeap . offer ( randomInt ) ; insertIntoReplica ( replica , randomInt ) ; } assertTrue ( <str> + heapSize + <str> , mmHeap . isIntact ( ) ) ; assertEquals ( heapSize , mmHeap . size ( ) ) ; int currentHeapSize = heapSize ; for ( int i = <int> ; i < numberOfModifications ; i + + ) { if ( random . nextBoolean ( ) ) { int randomInt = random . nextInt ( ) ; mmHeap . offer ( randomInt ) ; insertIntoReplica ( replica , randomInt ) ; currentHeapSize + + ; } else { if ( random . nextBoolean ( ) ) { removeMinFromReplica ( replica , mmHeap . poll ( ) ) ; } else { removeMaxFromReplica ( replica , mmHeap . pollLast ( ) ) ; } for ( Integer v : replica . keySet ( ) ) { assertTrue ( <str> + v , mmHeap . contains ( v ) ) ; } assertTrue ( mmHeap . isIntact ( ) ) ; currentHeapSize - - ; assertEquals ( currentHeapSize , mmHeap . size ( ) ) ; } } assertEquals ( currentHeapSize , mmHeap . size ( ) ) ; assertTrue ( <str> + numberOfModifications + <str> , mmHeap . isIntact ( ) ) ; } public void testSmall ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . add ( <int> ) ; mmHeap . add ( <int> ) ; mmHeap . add ( <int> ) ; mmHeap . add ( <int> ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; assertNull ( mmHeap . peek ( ) ) ; assertNull ( mmHeap . peekLast ( ) ) ; assertNull ( mmHeap . pollLast ( ) ) ; } public void testSmallMinHeap ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . add ( <int> ) ; mmHeap . add ( <int> ) ; mmHeap . add ( <int> ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . poll ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . poll ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . poll ( ) ) ; assertNull ( mmHeap . peekLast ( ) ) ; assertNull ( mmHeap . peek ( ) ) ; assertNull ( mmHeap . poll ( ) ) ; } public void testRemove ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; mmHeap . remove ( <int> ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . pollLast ( ) ) ; mmHeap . removeAll ( Lists . newArrayList ( <int> , <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; } public void testContains ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertFalse ( <str> , mmHeap . contains ( null ) ) ; assertFalse ( <str> , mmHeap . contains ( <int> ) ) ; assertFalse ( <str> , mmHeap . remove ( <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertTrue ( <str> , mmHeap . contains ( <int> ) ) ; assertTrue ( <str> , mmHeap . remove ( <int> ) ) ; assertTrue ( <str> , mmHeap . contains ( <int> ) ) ; assertTrue ( <str> , mmHeap . remove ( <int> ) ) ; assertFalse ( <str> , mmHeap . contains ( <int> ) ) ; assertTrue ( <str> , mmHeap . remove ( <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertFalse ( <str> , mmHeap . contains ( <int> ) ) ; assertFalse ( <str> , mmHeap . remove ( <int> ) ) ; } public void testIteratorPastEndException ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertTrue ( <str> , it . hasNext ( ) ) ; it . next ( ) ; it . next ( ) ; try { it . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } } public void testIteratorConcurrentModification ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> , <int> ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertTrue ( <str> , it . hasNext ( ) ) ; it . next ( ) ; it . next ( ) ; mmHeap . remove ( <int> ) ; try { it . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException e ) { } } public void testIteratorRegressionChildlessUncle ( ) { final ArrayList < Integer > initial = Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( initial ) ; assertTrue ( <str> + Arrays . toString ( q . toArray ( ) ) , q . isIntact ( ) ) ; q . remove ( <int> ) ; q . remove ( <int> ) ; q . remove ( <int> ) ; List < Integer > result = Lists . newArrayListWithCapacity ( initial . size ( ) ) ; for ( Iterator < Integer > iter = q . iterator ( ) ; iter . hasNext ( ) ; ) { Integer value = iter . next ( ) ; result . add ( value ) ; if ( value = = <int> ) { iter . remove ( ) ; } } assertTrue ( q . isIntact ( ) ) ; assertThat ( result ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) ; } public void testInvalidatingRemove ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; mmHeap . remove ( <int> ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; } public void testInvalidatingRemove2 ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; List < Integer > values = Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; mmHeap . addAll ( values ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; mmHeap . remove ( <int> ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; values . removeAll ( Lists . newArrayList ( <int> ) ) ; assertEquals ( values . size ( ) , mmHeap . size ( ) ) ; assertTrue ( values . containsAll ( mmHeap ) ) ; assertTrue ( mmHeap . containsAll ( values ) ) ; } public void testIteratorInvalidatingIteratorRemove ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; it . remove ( ) ; assertFalse ( mmHeap . contains ( <int> ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertFalse ( it . hasNext ( ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertFalse ( mmHeap . contains ( <int> ) ) ; Integer lastItem = <int> ; for ( Integer tmp : mmHeap ) { lastItem = tmp ; } assertEquals ( ( Integer ) <int> , lastItem ) ; } public void testIteratorInvalidatingIteratorRemove2 ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . create ( ) ; mmHeap . addAll ( Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; Iterator < Integer > it = mmHeap . iterator ( ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; it . remove ( ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; it . remove ( ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; assertEquals ( ( Integer ) <int> , it . next ( ) ) ; } public void testRemoveFromStringHeap ( ) { MinMaxPriorityQueue < String > mmHeap = MinMaxPriorityQueue . expectedSize ( <int> ) . create ( ) ; Collections . addAll ( mmHeap , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( <str> , mmHeap . peek ( ) ) ; assertEquals ( <str> , mmHeap . peekLast ( ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertTrue ( <str> , mmHeap . remove ( <str> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; assertFalse ( <str> , mmHeap . contains ( <str> ) ) ; assertTrue ( <str> , mmHeap . contains ( <str> ) ) ; assertTrue ( <str> , mmHeap . removeAll ( Lists . newArrayList ( <str> , <str> ) ) ) ; assertFalse ( <str> , mmHeap . remove ( <str> ) ) ; assertEquals ( <int> , mmHeap . size ( ) ) ; } public void testCreateWithOrdering ( ) { MinMaxPriorityQueue < String > mmHeap = MinMaxPriorityQueue . orderedBy ( Ordering . natural ( ) . reverse ( ) ) . create ( ) ; Collections . addAll ( mmHeap , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( <str> , mmHeap . peek ( ) ) ; assertEquals ( <str> , mmHeap . peekLast ( ) ) ; } public void testCreateWithCapacityAndOrdering ( ) { MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . orderedBy ( Ordering . natural ( ) . reverse ( ) ) . expectedSize ( <int> ) . create ( ) ; Collections . addAll ( mmHeap , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertTrue ( <str> , mmHeap . isIntact ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peek ( ) ) ; assertEquals ( <int> , ( int ) mmHeap . peekLast ( ) ) ; } private < T extends Comparable < T > > void runIterator ( final List < T > values , int steps ) throws Exception { IteratorTester < T > tester = new IteratorTester < T > ( steps , IteratorFeature . MODIFIABLE , Lists . newLinkedList ( values ) , IteratorTester . KnownOrder . UNKNOWN_ORDER ) { private MinMaxPriorityQueue < T > mmHeap ; @Override protected Iterator < T > newTargetIterator ( ) { mmHeap = MinMaxPriorityQueue . create ( values ) ; return mmHeap . iterator ( ) ; } @Override protected void verify ( List < T > elements ) { assertEquals ( Sets . newHashSet ( elements ) , Sets . newHashSet ( mmHeap . iterator ( ) ) ) ; assertTrue ( <str> + mmHeap , mmHeap . isIntact ( ) ) ; } } ; tester . test ( ) ; } public void testIteratorTester ( ) throws Exception { Random random = new Random ( <int> ) ; List < Integer > list = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { list . add ( random . nextInt ( ) ) ; } runIterator ( list , <int> ) ; } public void testIteratorTesterLarger ( ) throws Exception { runIterator ( Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , <int> ) ; } public void testRemoveAt ( ) { long seed = new Random ( ) . nextLong ( ) ; Random random = new Random ( seed ) ; int heapSize = <int> ; int numberOfModifications = <int> ; MinMaxPriorityQueue < Integer > mmHeap = MinMaxPriorityQueue . expectedSize ( heapSize ) . create ( ) ; for ( int i = <int> ; i < heapSize ; i + + ) { mmHeap . add ( random . nextInt ( ) ) ; } for ( int i = <int> ; i < numberOfModifications ; i + + ) { mmHeap . removeAt ( random . nextInt ( mmHeap . size ( ) ) ) ; assertTrue ( <str> + i + <str> + seed , mmHeap . isIntact ( ) ) ; mmHeap . add ( random . nextInt ( ) ) ; assertTrue ( <str> + i + <str> + seed , mmHeap . isIntact ( ) ) ; } } public void testRemoveAt_exhaustive ( ) { int size = <int> ; List < Integer > expected = createOrderedList ( size ) ; for ( Collection < Integer > perm : Collections2 . permutations ( expected ) ) { for ( int i = <int> ; i < perm . size ( ) ; i + + ) { MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( perm ) ; q . removeAt ( i ) ; assertTrue ( <str> + i + <str> + perm , q . isIntact ( ) ) ; } } } public void testCorrectOrdering_regression ( ) { MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> ) ) ; List < Integer > expected = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> ) ; List < Integer > actual = new ArrayList < Integer > ( <int> ) ; for ( int i = <int> ; i < expected . size ( ) ; i + + ) { actual . add ( q . pollFirst ( ) ) ; } assertEquals ( expected , actual ) ; } public void testCorrectOrdering_smallHeapsPollFirst ( ) { for ( int size = <int> ; size < <int> ; size + + ) { for ( int attempts = <int> ; attempts < size * ( size - <int> ) ; attempts + + ) { ArrayList < Integer > elements = createOrderedList ( size ) ; List < Integer > expected = ImmutableList . copyOf ( elements ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; long seed = insertRandomly ( elements , q ) ; while ( ! q . isEmpty ( ) ) { elements . add ( q . pollFirst ( ) ) ; } assertEquals ( <str> + seed , expected , elements ) ; } } } public void testCorrectOrdering_smallHeapsPollLast ( ) { for ( int size = <int> ; size < <int> ; size + + ) { for ( int attempts = <int> ; attempts < size * ( size - <int> ) ; attempts + + ) { ArrayList < Integer > elements = createOrderedList ( size ) ; List < Integer > expected = ImmutableList . copyOf ( elements ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; long seed = insertRandomly ( elements , q ) ; while ( ! q . isEmpty ( ) ) { elements . add ( <int> , q . pollLast ( ) ) ; } assertEquals ( <str> + seed , expected , elements ) ; } } } public void testCorrectOrdering_mediumHeapsPollFirst ( ) { for ( int attempts = <int> ; attempts < <int> ; attempts + + ) { int size = new Random ( ) . nextInt ( <int> ) + <int> ; ArrayList < Integer > elements = createOrderedList ( size ) ; List < Integer > expected = ImmutableList . copyOf ( elements ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; long seed = insertRandomly ( elements , q ) ; while ( ! q . isEmpty ( ) ) { elements . add ( q . pollFirst ( ) ) ; } assertEquals ( <str> + seed , expected , elements ) ; } } public void testCorrectOrdering_73ElementBug ( ) { int size = <int> ; long seed = <int> ; ArrayList < Integer > elements = createOrderedList ( size ) ; List < Integer > expected = ImmutableList . copyOf ( elements ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; insertRandomly ( elements , q , new Random ( seed ) ) ; assertTrue ( q . isIntact ( ) ) ; while ( ! q . isEmpty ( ) ) { elements . add ( q . pollFirst ( ) ) ; assertTrue ( <str> + Arrays . toString ( q . toArray ( ) ) , q . isIntact ( ) ) ; } assertEquals ( <str> + seed , expected , elements ) ; } public void testCorrectOrdering_mediumHeapsPollLast ( ) { for ( int attempts = <int> ; attempts < <int> ; attempts + + ) { int size = new Random ( ) . nextInt ( <int> ) + <int> ; ArrayList < Integer > elements = createOrderedList ( size ) ; List < Integer > expected = ImmutableList . copyOf ( elements ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; long seed = insertRandomly ( elements , q ) ; while ( ! q . isEmpty ( ) ) { elements . add ( <int> , q . pollLast ( ) ) ; } assertEquals ( <str> + seed , expected , elements ) ; } } public void testCorrectOrdering_randomAccess ( ) { long seed = new Random ( ) . nextLong ( ) ; Random random = new Random ( seed ) ; PriorityQueue < Integer > control = new PriorityQueue < Integer > ( ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { Integer element = random . nextInt ( ) ; control . add ( element ) ; assertTrue ( q . add ( element ) ) ; } assertTrue ( <str> + Arrays . toString ( q . toArray ( ) ) , q . isIntact ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { if ( random . nextBoolean ( ) ) { Integer element = random . nextInt ( ) ; control . add ( element ) ; q . add ( element ) ; } else { assertEquals ( <str> + seed , control . poll ( ) , q . pollFirst ( ) ) ; } } while ( ! control . isEmpty ( ) ) { assertEquals ( <str> + seed , control . poll ( ) , q . pollFirst ( ) ) ; } assertTrue ( q . isEmpty ( ) ) ; } public void testExhaustive_pollAndPush ( ) { int size = <int> ; List < Integer > expected = createOrderedList ( size ) ; for ( Collection < Integer > perm : Collections2 . permutations ( expected ) ) { MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( perm ) ; List < Integer > elements = Lists . newArrayListWithCapacity ( size ) ; while ( ! q . isEmpty ( ) ) { Integer next = q . pollFirst ( ) ; for ( int i = <int> ; i < = size ; i + + ) { assertTrue ( q . add ( i ) ) ; assertTrue ( q . add ( next ) ) ; assertTrue ( q . remove ( i ) ) ; assertEquals ( next , q . poll ( ) ) ; } elements . add ( next ) ; } assertEquals ( <str> + perm , expected , elements ) ; } } public void testRegression_dataCorruption ( ) { int size = <int> ; List < Integer > expected = createOrderedList ( size ) ; MinMaxPriorityQueue < Integer > q = MinMaxPriorityQueue . create ( expected ) ; List < Integer > contents = Lists . newArrayList ( expected ) ; List < Integer > elements = Lists . newArrayListWithCapacity ( size ) ; while ( ! q . isEmpty ( ) ) { assertThat ( q ) . containsExactlyElementsIn ( contents ) ; Integer next = q . pollFirst ( ) ; contents . remove ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; for ( int i = <int> ; i < = size ; i + + ) { q . add ( i ) ; contents . add ( i ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; q . add ( next ) ; contents . add ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; q . remove ( i ) ; assertTrue ( contents . remove ( Integer . valueOf ( i ) ) ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; assertEquals ( next , q . poll ( ) ) ; contents . remove ( next ) ; assertThat ( q ) . containsExactlyElementsIn ( contents ) ; } elements . add ( next ) ; } assertEquals ( expected , elements ) ; } private long insertRandomly ( ArrayList < Integer > elements , MinMaxPriorityQueue < Integer > q ) { long seed = new Random ( ) . nextLong ( ) ; Random random = new Random ( seed ) ; insertRandomly ( elements , q , random ) ; return seed ; } private static void insertRandomly ( ArrayList < Integer > elements , MinMaxPriorityQueue < Integer > q , Random random ) { while ( ! elements . isEmpty ( ) ) { int selectedIndex = random . nextInt ( elements . size ( ) ) ; q . offer ( elements . remove ( selectedIndex ) ) ; } } private ArrayList < Integer > createOrderedList ( int size ) { ArrayList < Integer > elements = new ArrayList < Integer > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { elements . add ( i ) ; } return elements ; } public void testIsEvenLevel ( ) { assertTrue ( MinMaxPriorityQueue . isEvenLevel ( <int> ) ) ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( <int> ) ) ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( <int> ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( <int> ) ) ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( ( <int> < < <int> ) - <int> ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( ( <int> < < <int> ) - <int> ) ) ; int i = <int> < < <int> ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( i - <int> ) ) ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( i - <int> ) ) ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( i ) ) ; i = <int> < < <int> ; assertFalse ( MinMaxPriorityQueue . isEvenLevel ( i - <int> ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( i - <int> ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( i ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( ( <int> < < <int> ) - <int> ) ) ; assertTrue ( MinMaxPriorityQueue . isEvenLevel ( Integer . MAX_VALUE - <int> ) ) ; try { MinMaxPriorityQueue . isEvenLevel ( ( <int> < < <int> ) - <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } try { MinMaxPriorityQueue . isEvenLevel ( Integer . MAX_VALUE ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } try { MinMaxPriorityQueue . isEvenLevel ( <int> < < <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } try { MinMaxPriorityQueue . isEvenLevel ( Integer . MIN_VALUE ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } } public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicConstructors ( MinMaxPriorityQueue . class ) ; tester . testAllPublicStaticMethods ( MinMaxPriorityQueue . class ) ; tester . testAllPublicInstanceMethods ( MinMaxPriorityQueue . < String > create ( ) ) ; } private static void insertIntoReplica ( Map < Integer , AtomicInteger > replica , int newValue ) { if ( replica . containsKey ( newValue ) ) { replica . get ( newValue ) . incrementAndGet ( ) ; } else { replica . put ( newValue , new AtomicInteger ( <int> ) ) ; } } private static void removeMinFromReplica ( SortedMap < Integer , AtomicInteger > replica , int minValue ) { Integer replicatedMinValue = replica . firstKey ( ) ; assertEquals ( replicatedMinValue , ( Integer ) minValue ) ; removeFromReplica ( replica , replicatedMinValue ) ; } private static void removeMaxFromReplica ( SortedMap < Integer , AtomicInteger > replica , int maxValue ) { Integer replicatedMaxValue = replica . lastKey ( ) ; assertTrue ( <str> , replicatedMaxValue = = maxValue ) ; removeFromReplica ( replica , replicatedMaxValue ) ; } private static void removeFromReplica ( Map < Integer , AtomicInteger > replica , int value ) { AtomicInteger numOccur = replica . get ( value ) ; if ( numOccur . decrementAndGet ( ) = = <int> ) { replica . remove ( value ) ; } } } 
