package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Preconditions ; import junit . framework . TestCase ; import org . mockito . Mockito ; import java . util . concurrent . CancellationException ; import java . util . concurrent . Executor ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class FutureCallbackTest extends TestCase { public void testSameThreadSuccess ( ) { SettableFuture < String > f = SettableFuture . create ( ) ; MockCallback callback = new MockCallback ( <str> ) ; Futures . addCallback ( f , callback ) ; f . set ( <str> ) ; } public void testExecutorSuccess ( ) { CountingSameThreadExecutor ex = new CountingSameThreadExecutor ( ) ; SettableFuture < String > f = SettableFuture . create ( ) ; MockCallback callback = new MockCallback ( <str> ) ; Futures . addCallback ( f , callback , ex ) ; f . set ( <str> ) ; assertEquals ( <int> , ex . runCount ) ; } public void testSameThreadExecutionException ( ) { SettableFuture < String > f = SettableFuture . create ( ) ; Exception e = new IllegalArgumentException ( <str> ) ; MockCallback callback = new MockCallback ( e ) ; Futures . addCallback ( f , callback ) ; f . setException ( e ) ; } public void testCancel ( ) { SettableFuture < String > f = SettableFuture . create ( ) ; FutureCallback < String > callback = new FutureCallback < String > ( ) { private boolean called = false ; @Override public void onSuccess ( String result ) { fail ( <str> ) ; } @Override public synchronized void onFailure ( Throwable t ) { assertFalse ( called ) ; assertThat ( t ) . isInstanceOf ( CancellationException . class ) ; called = true ; } } ; Futures . addCallback ( f , callback ) ; f . cancel ( true ) ; } public void testThrowErrorFromGet ( ) { Error error = new AssertionError ( <str> ) ; ListenableFuture < String > f = ThrowingFuture . throwingError ( error ) ; MockCallback callback = new MockCallback ( error ) ; Futures . addCallback ( f , callback ) ; } public void testRuntimeExeceptionFromGet ( ) { RuntimeException e = new IllegalArgumentException ( <str> ) ; ListenableFuture < String > f = ThrowingFuture . throwingRuntimeException ( e ) ; MockCallback callback = new MockCallback ( e ) ; Futures . addCallback ( f , callback ) ; } @GwtIncompatible ( <str> ) public void testOnSuccessThrowsRuntimeException ( ) throws Exception { RuntimeException exception = new RuntimeException ( ) ; String result = <str> ; SettableFuture < String > future = SettableFuture . create ( ) ; @SuppressWarnings ( <str> ) FutureCallback < String > callback = Mockito . mock ( FutureCallback . class ) ; Futures . addCallback ( future , callback ) ; Mockito . doThrow ( exception ) . when ( callback ) . onSuccess ( result ) ; future . set ( result ) ; assertEquals ( result , future . get ( ) ) ; Mockito . verify ( callback ) . onSuccess ( result ) ; Mockito . verifyNoMoreInteractions ( callback ) ; } @GwtIncompatible ( <str> ) public void testOnSuccessThrowsError ( ) throws Exception { class TestError extends Error { } TestError error = new TestError ( ) ; String result = <str> ; SettableFuture < String > future = SettableFuture . create ( ) ; @SuppressWarnings ( <str> ) FutureCallback < String > callback = Mockito . mock ( FutureCallback . class ) ; Futures . addCallback ( future , callback ) ; Mockito . doThrow ( error ) . when ( callback ) . onSuccess ( result ) ; try { future . set ( result ) ; fail ( <str> ) ; } catch ( TestError e ) { assertSame ( error , e ) ; } assertEquals ( result , future . get ( ) ) ; Mockito . verify ( callback ) . onSuccess ( result ) ; Mockito . verifyNoMoreInteractions ( callback ) ; } public void testWildcardFuture ( ) { SettableFuture < String > settable = SettableFuture . create ( ) ; ListenableFuture < ? > f = settable ; FutureCallback < Object > callback = new FutureCallback < Object > ( ) { @Override public void onSuccess ( Object result ) { } @Override public void onFailure ( Throwable t ) { } } ; Futures . addCallback ( f , callback ) ; } private class CountingSameThreadExecutor implements Executor { int runCount = <int> ; @Override public void execute ( Runnable command ) { command . run ( ) ; runCount + + ; } } private static class ThrowingFuture < V > implements ListenableFuture < V > { private final Error error ; private final RuntimeException runtime ; public static < V > ListenableFuture < V > throwingError ( Error error ) { return new ThrowingFuture < V > ( error ) ; } public static < V > ListenableFuture < V > throwingRuntimeException ( RuntimeException e ) { return new ThrowingFuture < V > ( e ) ; } private ThrowingFuture ( Error error ) { this . error = Preconditions . checkNotNull ( error ) ; this . runtime = null ; } public ThrowingFuture ( RuntimeException e ) { this . runtime = Preconditions . checkNotNull ( e ) ; this . error = null ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; } @Override public boolean isCancelled ( ) { return false ; } @Override public boolean isDone ( ) { return true ; } @Override public V get ( ) { throwOnGet ( ) ; throw new AssertionError ( <str> ) ; } @Override public V get ( long timeout , TimeUnit unit ) { throwOnGet ( ) ; throw new AssertionError ( <str> ) ; } @Override public void addListener ( Runnable listener , Executor executor ) { executor . execute ( listener ) ; } private void throwOnGet ( ) { if ( error ! = null ) { throw error ; } else { throw runtime ; } } } private final class MockCallback implements FutureCallback < String > { @Nullable private String value = null ; @Nullable private Throwable failure = null ; private boolean wasCalled = false ; MockCallback ( String expectedValue ) { this . value = expectedValue ; } public MockCallback ( Throwable expectedFailure ) { this . failure = expectedFailure ; } @Override public synchronized void onSuccess ( String result ) { assertFalse ( wasCalled ) ; wasCalled = true ; assertEquals ( value , result ) ; } @Override public synchronized void onFailure ( Throwable t ) { assertFalse ( wasCalled ) ; wasCalled = true ; assertEquals ( failure , t ) ; } } } 
