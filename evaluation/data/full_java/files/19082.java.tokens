package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . stream . ChunkedInput ; public class HttpChunkedInput implements ChunkedInput < HttpContent > { private final ChunkedInput < ByteBuf > input ; private final LastHttpContent lastHttpContent ; private boolean sentLastChunk ; public HttpChunkedInput ( ChunkedInput < ByteBuf > input ) { this . input = input ; lastHttpContent = LastHttpContent . EMPTY_LAST_CONTENT ; } public HttpChunkedInput ( ChunkedInput < ByteBuf > input , LastHttpContent lastHttpContent ) { this . input = input ; this . lastHttpContent = lastHttpContent ; } @Override public boolean isEndOfInput ( ) throws Exception { if ( input . isEndOfInput ( ) ) { return sentLastChunk ; } else { return false ; } } @Override public void close ( ) throws Exception { input . close ( ) ; } @Override public HttpContent readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( input . isEndOfInput ( ) ) { if ( sentLastChunk ) { return null ; } else { sentLastChunk = true ; return lastHttpContent ; } } else { ByteBuf buf = input . readChunk ( ctx ) ; return new DefaultHttpContent ( buf ) ; } } @Override public long length ( ) { return input . length ( ) ; } @Override public long progress ( ) { return input . progress ( ) ; } } 
