package org . apache . cassandra . gms ; import java . net . InetAddress ; import java . util . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . net . IVerbHandler ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; public class GossipDigestSynVerbHandler implements IVerbHandler < GossipDigestSyn > { private static final Logger logger = LoggerFactory . getLogger ( GossipDigestSynVerbHandler . class ) ; public void doVerb ( MessageIn < GossipDigestSyn > message , int id ) { InetAddress from = message . from ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , from ) ; if ( ! Gossiper . instance . isEnabled ( ) ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> ) ; return ; } GossipDigestSyn gDigestMessage = message . payload ; if ( ! gDigestMessage . clusterId . equals ( DatabaseDescriptor . getClusterName ( ) ) ) { logger . warn ( <str> , from , gDigestMessage . clusterId , DatabaseDescriptor . getClusterName ( ) ) ; return ; } if ( gDigestMessage . partioner ! = null & & ! gDigestMessage . partioner . equals ( DatabaseDescriptor . getPartitionerName ( ) ) ) { logger . warn ( <str> , from , gDigestMessage . partioner , DatabaseDescriptor . getPartitionerName ( ) ) ; return ; } List < GossipDigest > gDigestList = gDigestMessage . getGossipDigests ( ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( GossipDigest gDigest : gDigestList ) { sb . append ( gDigest ) ; sb . append ( <str> ) ; } logger . trace ( <str> , sb ) ; } doSort ( gDigestList ) ; List < GossipDigest > deltaGossipDigestList = new ArrayList < GossipDigest > ( ) ; Map < InetAddress , EndpointState > deltaEpStateMap = new HashMap < InetAddress , EndpointState > ( ) ; Gossiper . instance . examineGossiper ( gDigestList , deltaGossipDigestList , deltaEpStateMap ) ; logger . trace ( <str> , deltaGossipDigestList . size ( ) , deltaEpStateMap . size ( ) ) ; MessageOut < GossipDigestAck > gDigestAckMessage = new MessageOut < GossipDigestAck > ( MessagingService . Verb . GOSSIP_DIGEST_ACK , new GossipDigestAck ( deltaGossipDigestList , deltaEpStateMap ) , GossipDigestAck . serializer ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , from ) ; MessagingService . instance ( ) . sendOneWay ( gDigestAckMessage , from ) ; } private void doSort ( List < GossipDigest > gDigestList ) { Map < InetAddress , GossipDigest > epToDigestMap = new HashMap < InetAddress , GossipDigest > ( ) ; for ( GossipDigest gDigest : gDigestList ) { epToDigestMap . put ( gDigest . getEndpoint ( ) , gDigest ) ; } List < GossipDigest > diffDigests = new ArrayList < GossipDigest > ( gDigestList . size ( ) ) ; for ( GossipDigest gDigest : gDigestList ) { InetAddress ep = gDigest . getEndpoint ( ) ; EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( ep ) ; int version = ( epState ! = null ) ? Gossiper . instance . getMaxEndpointStateVersion ( epState ) : <int> ; int diffVersion = Math . abs ( version - gDigest . getMaxVersion ( ) ) ; diffDigests . add ( new GossipDigest ( ep , gDigest . getGeneration ( ) , diffVersion ) ) ; } gDigestList . clear ( ) ; Collections . sort ( diffDigests ) ; int size = diffDigests . size ( ) ; for ( int i = size - <int> ; i > = <int> ; - - i ) { gDigestList . add ( epToDigestMap . get ( diffDigests . get ( i ) . getEndpoint ( ) ) ) ; } } } 
