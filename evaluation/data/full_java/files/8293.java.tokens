package org . elasticsearch . index . shard ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . * ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . store . Directory ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . lucene . index . ElasticsearchDirectoryReader ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . engine . EngineException ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . Collections ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicInteger ; public class IndexSearcherWrapperTests extends ESTestCase { public void testReaderCloseListenerIsCalled ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new StringField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; DirectoryReader open = ElasticsearchDirectoryReader . wrap ( DirectoryReader . open ( writer , true ) , new ShardId ( <str> , <int> ) ) ; IndexSearcher searcher = new IndexSearcher ( open ) ; assertEquals ( <int> , searcher . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits ) ; final AtomicInteger closeCalls = new AtomicInteger ( <int> ) ; IndexSearcherWrapper wrapper = new IndexSearcherWrapper ( ) { @Override public DirectoryReader wrap ( DirectoryReader reader ) throws IOException { return new FieldMaskingReader ( <str> , reader , closeCalls ) ; } @Override public IndexSearcher wrap ( IndexSearcher searcher ) throws EngineException { return searcher ; } } ; final int sourceRefCount = open . getRefCount ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; final AtomicInteger outerCount = new AtomicInteger ( ) ; try ( Engine . Searcher engineSearcher = new Engine . Searcher ( <str> , searcher ) ) { final Engine . Searcher wrap = wrapper . wrap ( engineSearcher ) ; assertEquals ( <int> , wrap . reader ( ) . getRefCount ( ) ) ; ElasticsearchDirectoryReader . addReaderCloseListener ( wrap . getDirectoryReader ( ) , reader - > { if ( reader = = open ) { count . incrementAndGet ( ) ; } outerCount . incrementAndGet ( ) ; } ) ; assertEquals ( <int> , wrap . searcher ( ) . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits ) ; wrap . close ( ) ; assertFalse ( <str> , wrap . reader ( ) . tryIncRef ( ) ) ; assertEquals ( sourceRefCount , open . getRefCount ( ) ) ; } assertEquals ( <int> , closeCalls . get ( ) ) ; IOUtils . close ( open , writer , dir ) ; assertEquals ( <int> , outerCount . get ( ) ) ; assertEquals ( <int> , count . get ( ) ) ; assertEquals ( <int> , open . getRefCount ( ) ) ; assertEquals ( <int> , closeCalls . get ( ) ) ; } public void testIsCacheable ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new StringField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; DirectoryReader open = ElasticsearchDirectoryReader . wrap ( DirectoryReader . open ( writer , true ) , new ShardId ( <str> , <int> ) ) ; IndexSearcher searcher = new IndexSearcher ( open ) ; assertEquals ( <int> , searcher . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits ) ; searcher . setSimilarity ( iwc . getSimilarity ( ) ) ; final AtomicInteger closeCalls = new AtomicInteger ( <int> ) ; IndexSearcherWrapper wrapper = new IndexSearcherWrapper ( ) { @Override public DirectoryReader wrap ( DirectoryReader reader ) throws IOException { return new FieldMaskingReader ( <str> , reader , closeCalls ) ; } @Override public IndexSearcher wrap ( IndexSearcher searcher ) throws EngineException { return searcher ; } } ; final ConcurrentHashMap < Object , TopDocs > cache = new ConcurrentHashMap < > ( ) ; try ( Engine . Searcher engineSearcher = new Engine . Searcher ( <str> , searcher ) ) { try ( final Engine . Searcher wrap = wrapper . wrap ( engineSearcher ) ) { ElasticsearchDirectoryReader . addReaderCloseListener ( wrap . getDirectoryReader ( ) , reader - > { cache . remove ( reader . getCoreCacheKey ( ) ) ; } ) ; TopDocs search = wrap . searcher ( ) . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) ; cache . put ( wrap . reader ( ) . getCoreCacheKey ( ) , search ) ; } } assertEquals ( <int> , closeCalls . get ( ) ) ; assertEquals ( <int> , cache . size ( ) ) ; IOUtils . close ( open , writer , dir ) ; assertEquals ( <int> , cache . size ( ) ) ; assertEquals ( <int> , closeCalls . get ( ) ) ; } public void testNoWrap ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new StringField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; DirectoryReader open = ElasticsearchDirectoryReader . wrap ( DirectoryReader . open ( writer , true ) , new ShardId ( <str> , <int> ) ) ; IndexSearcher searcher = new IndexSearcher ( open ) ; assertEquals ( <int> , searcher . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits ) ; searcher . setSimilarity ( iwc . getSimilarity ( ) ) ; IndexSearcherWrapper wrapper = new IndexSearcherWrapper ( ) ; try ( Engine . Searcher engineSearcher = new Engine . Searcher ( <str> , searcher ) ) { final Engine . Searcher wrap = wrapper . wrap ( engineSearcher ) ; assertSame ( wrap , engineSearcher ) ; } IOUtils . close ( open , writer , dir ) ; } public void testWrappedReaderMustDelegateCoreCacheKey ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new StringField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; DirectoryReader open = ElasticsearchDirectoryReader . wrap ( DirectoryReader . open ( writer , true ) , new ShardId ( <str> , <int> ) ) ; IndexSearcher searcher = new IndexSearcher ( open ) ; assertEquals ( <int> , searcher . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits ) ; searcher . setSimilarity ( iwc . getSimilarity ( ) ) ; IndexSearcherWrapper wrapper = new IndexSearcherWrapper ( ) { @Override protected DirectoryReader wrap ( DirectoryReader reader ) throws IOException { return new BrokenWrapper ( reader , false ) ; } } ; try ( Engine . Searcher engineSearcher = new Engine . Searcher ( <str> , searcher ) ) { try { wrapper . wrap ( engineSearcher ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } wrapper = new IndexSearcherWrapper ( ) { @Override protected DirectoryReader wrap ( DirectoryReader reader ) throws IOException { return new BrokenWrapper ( reader , true ) ; } } ; try ( Engine . Searcher engineSearcher = new Engine . Searcher ( <str> , searcher ) ) { try { wrapper . wrap ( engineSearcher ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } IOUtils . close ( open , writer , dir ) ; } private static class FieldMaskingReader extends FilterDirectoryReader { private final String field ; private final AtomicInteger closeCalls ; public FieldMaskingReader ( String field , DirectoryReader in , AtomicInteger closeCalls ) throws IOException { super ( in , new SubReaderWrapper ( ) { @Override public LeafReader wrap ( LeafReader reader ) { return new FieldFilterLeafReader ( reader , Collections . singleton ( field ) , true ) ; } } ) ; this . closeCalls = closeCalls ; this . field = field ; } @Override protected DirectoryReader doWrapDirectoryReader ( DirectoryReader in ) throws IOException { return new FieldMaskingReader ( field , in , closeCalls ) ; } @Override public Object getCoreCacheKey ( ) { return in . getCoreCacheKey ( ) ; } @Override protected void doClose ( ) throws IOException { super . doClose ( ) ; closeCalls . incrementAndGet ( ) ; } } private static class BrokenWrapper extends FilterDirectoryReader { private final boolean hideDelegate ; public BrokenWrapper ( DirectoryReader in , boolean hideDelegate ) throws IOException { super ( in , new SubReaderWrapper ( ) { @Override public LeafReader wrap ( LeafReader reader ) { return reader ; } } ) ; this . hideDelegate = hideDelegate ; } @Override protected DirectoryReader doWrapDirectoryReader ( DirectoryReader in ) throws IOException { return new BrokenWrapper ( in , hideDelegate ) ; } @Override public DirectoryReader getDelegate ( ) { if ( hideDelegate ) { try { return ElasticsearchDirectoryReader . wrap ( super . getDelegate ( ) , new ShardId ( <str> , <int> ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return super . getDelegate ( ) ; } @Override public Object getCoreCacheKey ( ) { if ( hideDelegate = = false ) { return super . getCoreCacheKey ( ) ; } else { return in . getCoreCacheKey ( ) ; } } } } 
