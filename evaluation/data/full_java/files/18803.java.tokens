package io . netty . buffer ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import java . util . Random ; import org . junit . Assert ; import org . junit . Test ; import java . nio . charset . Charset ; public class ByteBufUtilTest { @Test public void equalsBufferSubsections ( ) { byte [ ] b1 = new byte [ <int> ] ; byte [ ] b2 = new byte [ <int> ] ; Random rand = new Random ( ) ; rand . nextBytes ( b1 ) ; rand . nextBytes ( b2 ) ; final int iB1 = b1 . length / <int> ; final int iB2 = iB1 + b1 . length ; final int length = b1 . length - iB1 ; System . arraycopy ( b1 , iB1 , b2 , iB2 , length ) ; assertTrue ( ByteBufUtil . equals ( Unpooled . wrappedBuffer ( b1 ) , iB1 , Unpooled . wrappedBuffer ( b2 ) , iB2 , length ) ) ; } private static int random ( Random r , int min , int max ) { return r . nextInt ( ( max - min ) + <int> ) + min ; } @Test public void notEqualsBufferSubsections ( ) { byte [ ] b1 = new byte [ <int> ] ; byte [ ] b2 = new byte [ <int> ] ; Random rand = new Random ( ) ; rand . nextBytes ( b1 ) ; rand . nextBytes ( b2 ) ; final int iB1 = b1 . length / <int> ; final int iB2 = iB1 + b1 . length ; final int length = b1 . length - iB1 ; System . arraycopy ( b1 , iB1 , b2 , iB2 , length ) ; int diffIndex = random ( rand , iB1 , iB1 + length - <int> ) ; + + b1 [ diffIndex ] ; assertFalse ( ByteBufUtil . equals ( Unpooled . wrappedBuffer ( b1 ) , iB1 , Unpooled . wrappedBuffer ( b2 ) , iB2 , length ) ) ; } @Test public void notEqualsBufferOverflow ( ) { byte [ ] b1 = new byte [ <int> ] ; byte [ ] b2 = new byte [ <int> ] ; Random rand = new Random ( ) ; rand . nextBytes ( b1 ) ; rand . nextBytes ( b2 ) ; final int iB1 = b1 . length / <int> ; final int iB2 = iB1 + b1 . length ; final int length = b1 . length - iB1 ; System . arraycopy ( b1 , iB1 , b2 , iB2 , length - <int> ) ; assertFalse ( ByteBufUtil . equals ( Unpooled . wrappedBuffer ( b1 ) , iB1 , Unpooled . wrappedBuffer ( b2 ) , iB2 , Math . max ( b1 . length , b2 . length ) * <int> ) ) ; } @Test ( expected = IllegalArgumentException . class ) public void notEqualsBufferUnderflow ( ) { byte [ ] b1 = new byte [ <int> ] ; byte [ ] b2 = new byte [ <int> ] ; Random rand = new Random ( ) ; rand . nextBytes ( b1 ) ; rand . nextBytes ( b2 ) ; final int iB1 = b1 . length / <int> ; final int iB2 = iB1 + b1 . length ; final int length = b1 . length - iB1 ; System . arraycopy ( b1 , iB1 , b2 , iB2 , length - <int> ) ; assertFalse ( ByteBufUtil . equals ( Unpooled . wrappedBuffer ( b1 ) , iB1 , Unpooled . wrappedBuffer ( b2 ) , iB2 , - <int> ) ) ; } @Test public void testWriteUsAscii ( ) { String usAscii = <str> ; ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; buf . writeBytes ( usAscii . getBytes ( CharsetUtil . US_ASCII ) ) ; ByteBuf buf2 = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; ByteBufUtil . writeAscii ( buf2 , usAscii ) ; Assert . assertEquals ( buf , buf2 ) ; } @Test public void testWriteUsAsciiWrapped ( ) { String usAscii = <str> ; ByteBuf buf = Unpooled . unreleasableBuffer ( ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ) ; assertWrapped ( buf ) ; buf . writeBytes ( usAscii . getBytes ( CharsetUtil . US_ASCII ) ) ; ByteBuf buf2 = Unpooled . unreleasableBuffer ( ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ) ; assertWrapped ( buf2 ) ; ByteBufUtil . writeAscii ( buf2 , usAscii ) ; Assert . assertEquals ( buf , buf2 ) ; } @Test public void testWriteUtf8 ( ) { String usAscii = <str> ; ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; buf . writeBytes ( usAscii . getBytes ( CharsetUtil . UTF_8 ) ) ; ByteBuf buf2 = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; ByteBufUtil . writeUtf8 ( buf2 , usAscii ) ; Assert . assertEquals ( buf , buf2 ) ; } @Test public void testWriteUsAsciiString ( ) { AsciiString usAscii = new AsciiString ( <str> ) ; ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; buf . writeBytes ( usAscii . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; ByteBuf buf2 = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; ByteBufUtil . writeAscii ( buf2 , usAscii ) ; Assert . assertEquals ( buf , buf2 ) ; } @Test public void testWriteUtf8Wrapped ( ) { String usAscii = <str> ; ByteBuf buf = Unpooled . unreleasableBuffer ( ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ) ; assertWrapped ( buf ) ; buf . writeBytes ( usAscii . getBytes ( CharsetUtil . UTF_8 ) ) ; ByteBuf buf2 = Unpooled . unreleasableBuffer ( ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ) ; assertWrapped ( buf2 ) ; ByteBufUtil . writeUtf8 ( buf2 , usAscii ) ; Assert . assertEquals ( buf , buf2 ) ; } private static void assertWrapped ( ByteBuf buf ) { assertTrue ( buf instanceof WrappedByteBuf ) ; } @Test public void testDecodeUsAscii ( ) { testDecodeString ( <str> , CharsetUtil . US_ASCII ) ; } @Test public void testDecodeUtf8 ( ) { testDecodeString ( <str> , CharsetUtil . UTF_8 ) ; } private static void testDecodeString ( String text , Charset charset ) { ByteBuf buffer = Unpooled . copiedBuffer ( text , charset ) ; Assert . assertEquals ( text , ByteBufUtil . decodeString ( buffer , <int> , buffer . readableBytes ( ) , charset ) ) ; buffer . release ( ) ; } } 
