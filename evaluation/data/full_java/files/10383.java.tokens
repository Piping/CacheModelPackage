package com . google . common . collect ; import static com . google . common . collect . Lists . newArrayList ; import static com . google . common . collect . Sets . newHashSet ; import static com . google . common . collect . Sets . newLinkedHashSet ; import static com . google . common . collect . testing . Helpers . mapEntry ; import static com . google . common . collect . testing . IteratorFeature . MODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . SetMultimapTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringSetMultimapGenerator ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Arrays ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; @GwtCompatible ( emulated = true ) public class LinkedHashMultimapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SetMultimapTestSuiteBuilder . using ( new TestStringSetMultimapGenerator ( ) { @Override protected SetMultimap < String , String > create ( Entry < String , String > [ ] entries ) { SetMultimap < String , String > multimap = LinkedHashMultimap . create ( ) ; for ( Entry < String , String > entry : entries ) { multimap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return multimap ; } } ) . named ( <str> ) . withFeatures ( MapFeature . ALLOWS_NULL_KEYS , MapFeature . ALLOWS_NULL_VALUES , MapFeature . ALLOWS_ANY_NULL_QUERIES , MapFeature . GENERAL_PURPOSE , MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTestSuite ( LinkedHashMultimapTest . class ) ; return suite ; } public void testValueSetHashTableExpansion ( ) { LinkedHashMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; for ( int z = <int> ; z < = <int> ; z + + ) { multimap . put ( <str> , z ) ; @SuppressWarnings ( <str> ) LinkedHashMultimap < String , Integer > . ValueSet valueSet = ( LinkedHashMultimap . ValueSet ) multimap . backingMap ( ) . get ( <str> ) ; assertEquals ( z , valueSet . size ( ) ) ; assertFalse ( Hashing . needsResizing ( valueSet . size ( ) , valueSet . hashTable . length , LinkedHashMultimap . VALUE_SET_LOAD_FACTOR ) ) ; } } private Multimap < String , Integer > initializeMultimap5 ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; return multimap ; } public void testToString ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . putAll ( <str> , Arrays . asList ( - <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> ) ) ; multimap . put ( <str> , <int> ) ; assertEquals ( <str> , multimap . toString ( ) ) ; } public void testOrderingReadOnly ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; assertOrderingReadOnly ( multimap ) ; } public void testOrderingUnmodifiable ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; assertOrderingReadOnly ( Multimaps . unmodifiableMultimap ( multimap ) ) ; } public void testOrderingSynchronized ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; assertOrderingReadOnly ( Multimaps . synchronizedMultimap ( multimap ) ) ; } @GwtIncompatible ( <str> ) public void testSerializationOrdering ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; Multimap < String , Integer > copy = SerializableTester . reserializeAndAssert ( multimap ) ; assertOrderingReadOnly ( copy ) ; } @GwtIncompatible ( <str> ) public void testSerializationOrderingKeysAndEntries ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . remove ( <str> , <int> ) ; multimap = SerializableTester . reserializeAndAssert ( multimap ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( multimap . entries ( ) ) . containsExactly ( mapEntry ( <str> , <int> ) , mapEntry ( <str> , <int> ) , mapEntry ( <str> , <int> ) ) . inOrder ( ) ; } private void assertOrderingReadOnly ( Multimap < String , Integer > multimap ) { assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . contains ( <int> ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; Iterator < Map . Entry < String , Integer > > entryIterator = multimap . entries ( ) . iterator ( ) ; assertEquals ( Maps . immutableEntry ( <str> , <int> ) , entryIterator . next ( ) ) ; assertEquals ( Maps . immutableEntry ( <str> , <int> ) , entryIterator . next ( ) ) ; assertEquals ( Maps . immutableEntry ( <str> , <int> ) , entryIterator . next ( ) ) ; assertEquals ( Maps . immutableEntry ( <str> , <int> ) , entryIterator . next ( ) ) ; assertEquals ( Maps . immutableEntry ( <str> , <int> ) , entryIterator . next ( ) ) ; Iterator < Map . Entry < String , Collection < Integer > > > collectionIterator = multimap . asMap ( ) . entrySet ( ) . iterator ( ) ; Map . Entry < String , Collection < Integer > > entry = collectionIterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; entry = collectionIterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; entry = collectionIterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . contains ( <int> ) ; } public void testOrderingUpdates ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; assertThat ( multimap . replaceValues ( <str> , asList ( <int> , <int> ) ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( multimap . removeAll ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertTrue ( multimap . remove ( <str> , <int> ) ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertTrue ( multimap . remove ( <str> , <int> ) ) ; assertThat ( multimap . keySet ( ) ) . contains ( <str> ) ; multimap . put ( <str> , <int> ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testToStringNullExact ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , - <int> ) ; multimap . put ( null , null ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( null , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , null ) ; multimap . put ( <str> , null ) ; multimap . put ( <str> , <int> ) ; multimap . put ( null , - <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertEquals ( <str> , multimap . toString ( ) ) ; } public void testPutMultimapOrdered ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( initializeMultimap5 ( ) ) ; assertOrderingReadOnly ( multimap ) ; } public void testKeysToString_ordering ( ) { Multimap < String , Integer > multimap = initializeMultimap5 ( ) ; assertEquals ( <str> , multimap . keys ( ) . toString ( ) ) ; } public void testCreate ( ) { LinkedHashMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertEquals ( ImmutableSet . of ( <int> , <int> ) , multimap . get ( <str> ) ) ; } public void testCreateFromMultimap ( ) { Multimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; LinkedHashMultimap < String , Integer > copy = LinkedHashMultimap . create ( multimap ) ; new EqualsTester ( ) . addEqualityGroup ( multimap , copy ) . testEquals ( ) ; } public void testCreateFromSizes ( ) { LinkedHashMultimap < String , Integer > multimap = LinkedHashMultimap . create ( <int> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertEquals ( ImmutableSet . of ( <int> , <int> ) , multimap . get ( <str> ) ) ; } public void testCreateFromIllegalSizes ( ) { try { LinkedHashMultimap . create ( - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { LinkedHashMultimap . create ( <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testGetIteration ( ) { new IteratorTester < Integer > ( <int> , MODIFIABLE , newLinkedHashSet ( asList ( <int> , <int> , <int> , <int> , <int> ) ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Integer > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; return multimap . get ( <str> ) . iterator ( ) ; } @Override protected void verify ( List < Integer > elements ) { assertEquals ( newHashSet ( elements ) , multimap . get ( <str> ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testEntriesIteration ( ) { @SuppressWarnings ( <str> ) Set < Entry < String , Integer > > set = Sets . newLinkedHashSet ( asList ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) ) ; new IteratorTester < Entry < String , Integer > > ( <int> , MODIFIABLE , set , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Entry < String , Integer > > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; return multimap . entries ( ) . iterator ( ) ; } @Override protected void verify ( List < Entry < String , Integer > > elements ) { assertEquals ( newHashSet ( elements ) , multimap . entries ( ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testKeysIteration ( ) { new IteratorTester < String > ( <int> , MODIFIABLE , newArrayList ( <str> , <str> , <str> , <str> , <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < String > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; return multimap . keys ( ) . iterator ( ) ; } @Override protected void verify ( List < String > elements ) { assertEquals ( elements , Lists . newArrayList ( multimap . keys ( ) ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testValuesIteration ( ) { new IteratorTester < Integer > ( <int> , MODIFIABLE , newArrayList ( <int> , <int> , <int> , <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Integer > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; return multimap . values ( ) . iterator ( ) ; } @Override protected void verify ( List < Integer > elements ) { assertEquals ( elements , Lists . newArrayList ( multimap . values ( ) ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testKeySetIteration ( ) { new IteratorTester < String > ( <int> , MODIFIABLE , newLinkedHashSet ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < String > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> ) ) ; return multimap . keySet ( ) . iterator ( ) ; } @Override protected void verify ( List < String > elements ) { assertEquals ( newHashSet ( elements ) , multimap . keySet ( ) ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testAsSetIteration ( ) { @SuppressWarnings ( <str> ) Set < Entry < String , Collection < Integer > > > set = newLinkedHashSet ( asList ( Maps . immutableEntry ( <str> , ( Collection < Integer > ) Sets . newHashSet ( <int> , <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) Sets . newHashSet ( <int> , <int> , <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) Sets . newHashSet ( <int> , <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) Sets . newHashSet ( <int> ) ) , Maps . immutableEntry ( <str> , ( Collection < Integer > ) Sets . newHashSet ( <int> , <int> , <int> ) ) ) ) ; new IteratorTester < Entry < String , Collection < Integer > > > ( <int> , MODIFIABLE , set , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Entry < String , Collection < Integer > > > newTargetIterator ( ) { multimap = LinkedHashMultimap . create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> ) ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> ) ) ; return multimap . asMap ( ) . entrySet ( ) . iterator ( ) ; } @Override protected void verify ( List < Entry < String , Collection < Integer > > > elements ) { assertEquals ( newHashSet ( elements ) , multimap . asMap ( ) . entrySet ( ) ) ; } } . test ( ) ; } } 
