package org . elasticsearch . index . snapshots . blobstore ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . xcontent . FromXContentBuilder ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . snapshots . blobstore . BlobStoreIndexShardSnapshot . FileInfo ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class BlobStoreIndexShardSnapshots implements Iterable < SnapshotFiles > , ToXContent , FromXContentBuilder < BlobStoreIndexShardSnapshots > { public static final BlobStoreIndexShardSnapshots PROTO = new BlobStoreIndexShardSnapshots ( ) ; private final List < SnapshotFiles > shardSnapshots ; private final Map < String , FileInfo > files ; private final Map < String , List < FileInfo > > physicalFiles ; public BlobStoreIndexShardSnapshots ( List < SnapshotFiles > shardSnapshots ) { this . shardSnapshots = Collections . unmodifiableList ( new ArrayList < > ( shardSnapshots ) ) ; Map < String , FileInfo > newFiles = new HashMap < > ( ) ; Map < String , List < FileInfo > > physicalFiles = new HashMap < > ( ) ; for ( SnapshotFiles snapshot : shardSnapshots ) { for ( FileInfo fileInfo : snapshot . indexFiles ( ) ) { FileInfo oldFile = newFiles . put ( fileInfo . name ( ) , fileInfo ) ; assert oldFile = = null | | oldFile . isSame ( fileInfo ) ; } for ( FileInfo fileInfo : snapshot . indexFiles ( ) ) { List < FileInfo > physicalFileList = physicalFiles . get ( fileInfo . physicalName ( ) ) ; if ( physicalFileList = = null ) { physicalFileList = new ArrayList < > ( ) ; physicalFiles . put ( fileInfo . physicalName ( ) , physicalFileList ) ; } physicalFileList . add ( newFiles . get ( fileInfo . name ( ) ) ) ; } } Map < String , List < FileInfo > > mapBuilder = new HashMap < > ( ) ; for ( Map . Entry < String , List < FileInfo > > entry : physicalFiles . entrySet ( ) ) { mapBuilder . put ( entry . getKey ( ) , Collections . unmodifiableList ( new ArrayList < > ( entry . getValue ( ) ) ) ) ; } this . physicalFiles = unmodifiableMap ( mapBuilder ) ; this . files = unmodifiableMap ( newFiles ) ; } private BlobStoreIndexShardSnapshots ( Map < String , FileInfo > files , List < SnapshotFiles > shardSnapshots ) { this . shardSnapshots = shardSnapshots ; this . files = files ; Map < String , List < FileInfo > > physicalFiles = new HashMap < > ( ) ; for ( SnapshotFiles snapshot : shardSnapshots ) { for ( FileInfo fileInfo : snapshot . indexFiles ( ) ) { List < FileInfo > physicalFileList = physicalFiles . get ( fileInfo . physicalName ( ) ) ; if ( physicalFileList = = null ) { physicalFileList = new ArrayList < > ( ) ; physicalFiles . put ( fileInfo . physicalName ( ) , physicalFileList ) ; } physicalFileList . add ( files . get ( fileInfo . name ( ) ) ) ; } } Map < String , List < FileInfo > > mapBuilder = new HashMap < > ( ) ; for ( Map . Entry < String , List < FileInfo > > entry : physicalFiles . entrySet ( ) ) { mapBuilder . put ( entry . getKey ( ) , Collections . unmodifiableList ( new ArrayList < > ( entry . getValue ( ) ) ) ) ; } this . physicalFiles = unmodifiableMap ( mapBuilder ) ; } private BlobStoreIndexShardSnapshots ( ) { shardSnapshots = Collections . emptyList ( ) ; files = Collections . emptyMap ( ) ; physicalFiles = Collections . emptyMap ( ) ; } public List < SnapshotFiles > snapshots ( ) { return this . shardSnapshots ; } public List < FileInfo > findPhysicalIndexFiles ( String physicalName ) { return physicalFiles . get ( physicalName ) ; } public FileInfo findNameFile ( String name ) { return files . get ( name ) ; } @Override public Iterator < SnapshotFiles > iterator ( ) { return shardSnapshots . iterator ( ) ; } static final class Fields { static final XContentBuilderString FILES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SNAPSHOTS = new XContentBuilderString ( <str> ) ; } static final class ParseFields { static final ParseField FILES = new ParseField ( <str> ) ; static final ParseField SNAPSHOTS = new ParseField ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startArray ( Fields . FILES ) ; for ( Map . Entry < String , FileInfo > entry : files . entrySet ( ) ) { FileInfo . toXContent ( entry . getValue ( ) , builder , params ) ; } builder . endArray ( ) ; builder . startObject ( Fields . SNAPSHOTS ) ; for ( SnapshotFiles snapshot : shardSnapshots ) { builder . startObject ( snapshot . snapshot ( ) , XContentBuilder . FieldCaseConversion . NONE ) ; builder . startArray ( Fields . FILES ) ; for ( FileInfo fileInfo : snapshot . indexFiles ( ) ) { builder . value ( fileInfo . name ( ) ) ; } builder . endArray ( ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return builder ; } @Override public BlobStoreIndexShardSnapshots fromXContent ( XContentParser parser , ParseFieldMatcher parseFieldMatcher ) throws IOException { XContentParser . Token token = parser . currentToken ( ) ; if ( token = = null ) { token = parser . nextToken ( ) ; } Map < String , List < String > > snapshotsMap = new HashMap < > ( ) ; Map < String , FileInfo > files = new HashMap < > ( ) ; if ( token = = XContentParser . Token . START_OBJECT ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new ElasticsearchParseException ( <str> , token ) ; } String currentFieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseFieldMatcher . match ( currentFieldName , ParseFields . FILES ) = = false ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } while ( parser . nextToken ( ) ! = XContentParser . Token . END_ARRAY ) { FileInfo fileInfo = FileInfo . fromXContent ( parser ) ; files . put ( fileInfo . name ( ) , fileInfo ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( parseFieldMatcher . match ( currentFieldName , ParseFields . SNAPSHOTS ) = = false ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } String snapshot = parser . currentName ( ) ; if ( parser . nextToken ( ) ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; if ( parser . nextToken ( ) = = XContentParser . Token . START_ARRAY ) { if ( parseFieldMatcher . match ( currentFieldName , ParseFields . FILES ) = = false ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } List < String > fileNames = new ArrayList < > ( ) ; while ( parser . nextToken ( ) ! = XContentParser . Token . END_ARRAY ) { fileNames . add ( parser . text ( ) ) ; } snapshotsMap . put ( snapshot , fileNames ) ; } } } } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } } List < SnapshotFiles > snapshots = new ArrayList < > ( ) ; for ( Map . Entry < String , List < String > > entry : snapshotsMap . entrySet ( ) ) { List < FileInfo > fileInfosBuilder = new ArrayList < > ( ) ; for ( String file : entry . getValue ( ) ) { FileInfo fileInfo = files . get ( file ) ; assert fileInfo ! = null ; fileInfosBuilder . add ( fileInfo ) ; } snapshots . add ( new SnapshotFiles ( entry . getKey ( ) , Collections . unmodifiableList ( fileInfosBuilder ) ) ) ; } return new BlobStoreIndexShardSnapshots ( files , Collections . unmodifiableList ( snapshots ) ) ; } } 
