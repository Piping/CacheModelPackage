package org . elasticsearch . test ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . cache . recycler . PageCacheRecycler ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . node . Node ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . threadpool . ThreadPool ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public abstract class ESSingleNodeTestCase extends ESTestCase { private static Node NODE = null ; private static void reset ( ) { assert NODE ! = null ; stopNode ( ) ; startNode ( ) ; } private static void startNode ( ) { assert NODE = = null ; NODE = newNode ( ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . get ( ) ; assertFalse ( clusterHealthResponse . isTimedOut ( ) ) ; } private static void stopNode ( ) { Node node = NODE ; NODE = null ; Releasables . close ( node ) ; } static void cleanup ( boolean resetNode ) { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ) ; if ( resetNode ) { reset ( ) ; } MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; assertThat ( <str> + metaData . persistentSettings ( ) . getAsMap ( ) , metaData . persistentSettings ( ) . getAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> + metaData . transientSettings ( ) . getAsMap ( ) , metaData . transientSettings ( ) . getAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; } @After public void tearDown ( ) throws Exception { logger . info ( <str> , getTestClass ( ) . getSimpleName ( ) , getTestName ( ) ) ; super . tearDown ( ) ; cleanup ( resetNodeAfterTest ( ) ) ; } @BeforeClass public static void setUpClass ( ) throws Exception { stopNode ( ) ; startNode ( ) ; } @AfterClass public static void tearDownClass ( ) { stopNode ( ) ; } protected boolean resetNodeAfterTest ( ) { return false ; } private static Node newNode ( ) { Node build = new Node ( Settings . builder ( ) . put ( ClusterName . SETTING , InternalTestCluster . clusterName ( <str> , randomLong ( ) ) ) . put ( <str> , createTempDir ( ) ) . put ( <str> , createTempDir ( ) . getParent ( ) ) . put ( <str> , nodeName ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( EsExecutors . PROCESSORS , <int> ) . put ( <str> , false ) . put ( <str> , true ) . put ( <str> , true ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . build ( ) ) ; build . start ( ) ; assertThat ( DiscoveryNode . localNode ( build . settings ( ) ) , is ( true ) ) ; return build ; } public static Client client ( ) { return NODE . client ( ) ; } public static String nodeName ( ) { return <str> ; } protected static Node node ( ) { return NODE ; } protected static < T > T getInstanceFromNode ( Class < T > clazz ) { return NODE . injector ( ) . getInstance ( clazz ) ; } protected static IndexService createIndex ( String index ) { return createIndex ( index , Settings . EMPTY ) ; } protected static IndexService createIndex ( String index , Settings settings ) { return createIndex ( index , settings , null , ( XContentBuilder ) null ) ; } protected static IndexService createIndex ( String index , Settings settings , String type , XContentBuilder mappings ) { CreateIndexRequestBuilder createIndexRequestBuilder = client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . setSettings ( settings ) ; if ( type ! = null & & mappings ! = null ) { createIndexRequestBuilder . addMapping ( type , mappings ) ; } return createIndex ( index , createIndexRequestBuilder ) ; } protected static IndexService createIndex ( String index , Settings settings , String type , Object . . . mappings ) { CreateIndexRequestBuilder createIndexRequestBuilder = client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . setSettings ( settings ) ; if ( type ! = null & & mappings ! = null ) { createIndexRequestBuilder . addMapping ( type , mappings ) ; } return createIndex ( index , createIndexRequestBuilder ) ; } protected static IndexService createIndex ( String index , CreateIndexRequestBuilder createIndexRequestBuilder ) { assertAcked ( createIndexRequestBuilder . get ( ) ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . health ( Requests . clusterHealthRequest ( index ) . waitForYellowStatus ( ) . waitForEvents ( Priority . LANGUID ) . waitForRelocatingShards ( <int> ) ) . actionGet ( ) ; assertThat ( health . getStatus ( ) , lessThanOrEqualTo ( ClusterHealthStatus . YELLOW ) ) ; assertThat ( <str> , health . getNumberOfDataNodes ( ) , equalTo ( <int> ) ) ; IndicesService instanceFromNode = getInstanceFromNode ( IndicesService . class ) ; return instanceFromNode . indexServiceSafe ( index ) ; } protected static SearchContext createSearchContext ( IndexService indexService ) { BigArrays bigArrays = indexService . getIndexServices ( ) . getBigArrays ( ) ; ThreadPool threadPool = indexService . getIndexServices ( ) . getThreadPool ( ) ; PageCacheRecycler pageCacheRecycler = node ( ) . injector ( ) . getInstance ( PageCacheRecycler . class ) ; ScriptService scriptService = node ( ) . injector ( ) . getInstance ( ScriptService . class ) ; return new TestSearchContext ( threadPool , pageCacheRecycler , bigArrays , scriptService , indexService ) ; } public ClusterHealthStatus ensureGreen ( String . . . indices ) { return ensureGreen ( TimeValue . timeValueSeconds ( <int> ) , indices ) ; } public ClusterHealthStatus ensureGreen ( TimeValue timeout , String . . . indices ) { ClusterHealthResponse actionGet = client ( ) . admin ( ) . cluster ( ) . health ( Requests . clusterHealthRequest ( indices ) . timeout ( timeout ) . waitForGreenStatus ( ) . waitForEvents ( Priority . LANGUID ) . waitForRelocatingShards ( <int> ) ) . actionGet ( ) ; if ( actionGet . isTimedOut ( ) ) { logger . info ( <str> , client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . prettyPrint ( ) , client ( ) . admin ( ) . cluster ( ) . preparePendingClusterTasks ( ) . get ( ) . prettyPrint ( ) ) ; assertThat ( <str> , actionGet . isTimedOut ( ) , equalTo ( false ) ) ; } assertThat ( actionGet . getStatus ( ) , equalTo ( ClusterHealthStatus . GREEN ) ) ; logger . debug ( <str> , indices . length = = <int> ? <str> : indices ) ; return actionGet . getStatus ( ) ; } } 
