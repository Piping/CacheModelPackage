package org . apache . cassandra . utils . memory ; import java . nio . ByteBuffer ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . concurrent . OpOrder ; import sun . nio . ch . DirectBuffer ; public class SlabAllocator extends MemtableBufferAllocator { private static final Logger logger = LoggerFactory . getLogger ( SlabAllocator . class ) ; private final static int REGION_SIZE = <int> * <int> ; private final static int MAX_CLONED_SIZE = <int> * <int> ; private static final ConcurrentLinkedQueue < Region > RACE_ALLOCATED = new ConcurrentLinkedQueue < > ( ) ; private final AtomicReference < Region > currentRegion = new AtomicReference < > ( ) ; private final AtomicInteger regionCount = new AtomicInteger ( <int> ) ; private final ConcurrentLinkedQueue < Region > offHeapRegions = new ConcurrentLinkedQueue < > ( ) ; private AtomicLong unslabbedSize = new AtomicLong ( <int> ) ; private final boolean allocateOnHeapOnly ; SlabAllocator ( SubAllocator onHeap , SubAllocator offHeap , boolean allocateOnHeapOnly ) { super ( onHeap , offHeap ) ; this . allocateOnHeapOnly = allocateOnHeapOnly ; } public ByteBuffer allocate ( int size ) { return allocate ( size , null ) ; } public ByteBuffer allocate ( int size , OpOrder . Group opGroup ) { assert size > = <int> ; if ( size = = <int> ) return ByteBufferUtil . EMPTY_BYTE_BUFFER ; ( allocateOnHeapOnly ? onHeap ( ) : offHeap ( ) ) . allocate ( size , opGroup ) ; if ( size > MAX_CLONED_SIZE ) { unslabbedSize . addAndGet ( size ) ; if ( allocateOnHeapOnly ) return ByteBuffer . allocate ( size ) ; Region region = new Region ( ByteBuffer . allocateDirect ( size ) ) ; offHeapRegions . add ( region ) ; return region . allocate ( size ) ; } while ( true ) { Region region = getRegion ( ) ; ByteBuffer cloned = region . allocate ( size ) ; if ( cloned ! = null ) return cloned ; currentRegion . compareAndSet ( region , null ) ; } } public DataReclaimer reclaimer ( ) { return NO_OP ; } public void setDiscarded ( ) { for ( Region region : offHeapRegions ) ( ( DirectBuffer ) region . data ) . cleaner ( ) . clean ( ) ; super . setDiscarded ( ) ; } private Region getRegion ( ) { while ( true ) { Region region = currentRegion . get ( ) ; if ( region ! = null ) return region ; region = RACE_ALLOCATED . poll ( ) ; if ( region = = null ) region = new Region ( allocateOnHeapOnly ? ByteBuffer . allocate ( REGION_SIZE ) : ByteBuffer . allocateDirect ( REGION_SIZE ) ) ; if ( currentRegion . compareAndSet ( null , region ) ) { if ( ! allocateOnHeapOnly ) offHeapRegions . add ( region ) ; regionCount . incrementAndGet ( ) ; logger . trace ( <str> , regionCount , this ) ; return region ; } RACE_ALLOCATED . add ( region ) ; } } protected AbstractAllocator allocator ( OpOrder . Group writeOp ) { return new ContextAllocator ( writeOp , this ) ; } private static class Region { private ByteBuffer data ; private AtomicInteger nextFreeOffset = new AtomicInteger ( <int> ) ; private AtomicInteger allocCount = new AtomicInteger ( ) ; private Region ( ByteBuffer buffer ) { data = buffer ; } public ByteBuffer allocate ( int size ) { while ( true ) { int oldOffset = nextFreeOffset . get ( ) ; if ( oldOffset + size > data . capacity ( ) ) return null ; if ( nextFreeOffset . compareAndSet ( oldOffset , oldOffset + size ) ) { allocCount . incrementAndGet ( ) ; return ( ByteBuffer ) data . duplicate ( ) . position ( oldOffset ) . limit ( oldOffset + size ) ; } } } @Override public String toString ( ) { return <str> + System . identityHashCode ( this ) + <str> + allocCount . get ( ) + <str> + ( data . capacity ( ) - nextFreeOffset . get ( ) ) ; } } } 
