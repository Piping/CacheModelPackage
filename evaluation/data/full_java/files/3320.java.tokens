package org . nd4j . linalg . jcublas ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . BaseNDArrayFactory ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . jcublas . blas . JcublasLapack ; import org . nd4j . linalg . jcublas . blas . JcublasLevel1 ; import org . nd4j . linalg . jcublas . blas . JcublasLevel2 ; import org . nd4j . linalg . jcublas . blas . JcublasLevel3 ; import org . nd4j . linalg . jcublas . complex . ComplexDouble ; import org . nd4j . linalg . jcublas . complex . ComplexFloat ; import org . nd4j . linalg . jcublas . complex . JCublasComplexNDArray ; import org . nd4j . linalg . util . ArrayUtil ; import java . util . List ; public class JCublasNDArrayFactory extends BaseNDArrayFactory { public JCublasNDArrayFactory ( ) { } public JCublasNDArrayFactory ( DataBuffer . Type dtype , Character order ) { super ( dtype , order ) ; } public JCublasNDArrayFactory ( DataBuffer . Type dtype , char order ) { super ( dtype , order ) ; } @Override public void createLevel1 ( ) { level1 = new JcublasLevel1 ( ) ; } @Override public void createLevel2 ( ) { level2 = new JcublasLevel2 ( ) ; } @Override public void createLevel3 ( ) { level3 = new JcublasLevel3 ( ) ; } @Override public void createLapack ( ) { lapack = new JcublasLapack ( ) ; } @Override public INDArray create ( int [ ] shape , DataBuffer buffer ) { return new JCublasNDArray ( shape , buffer ) ; } @Override public IComplexFloat createFloat ( float real , float imag ) { return new ComplexFloat ( real , imag ) ; } @Override public IComplexDouble createDouble ( double real , double imag ) { return new ComplexDouble ( real , imag ) ; } @Override public INDArray create ( double [ ] [ ] data ) { return new JCublasNDArray ( data ) ; } @Override public INDArray create ( double [ ] [ ] data , char ordering ) { return new JCublasNDArray ( data , ordering ) ; } @Override public IComplexNDArray createComplex ( INDArray arr ) { return new JCublasComplexNDArray ( arr ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape ) { return new JCublasComplexNDArray ( data , shape , Nd4j . getComplexStrides ( shape , Nd4j . order ( ) ) ) ; } @Override public IComplexNDArray createComplex ( List < IComplexNDArray > arrs , int [ ] shape ) { return new JCublasComplexNDArray ( arrs , shape ) ; } @Override public INDArray create ( DataBuffer data ) { return new JCublasNDArray ( data ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data ) { return new JCublasComplexNDArray ( data ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data , int rows , int columns , int [ ] stride , int offset ) { return new JCublasComplexNDArray ( data , new int [ ] { rows , columns } , stride , offset ) ; } @Override public INDArray create ( DataBuffer data , int rows , int columns , int [ ] stride , int offset ) { return new JCublasNDArray ( data , new int [ ] { rows , columns } , stride , offset ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasComplexNDArray ( data , shape , stride , offset ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasComplexNDArray ( data , shape , stride , offset ) ; } @Override public INDArray create ( int [ ] shape , char ordering ) { return new JCublasNDArray ( shape , ordering ) ; } @Override public INDArray create ( DataBuffer data , int [ ] newShape , int [ ] newStride , int offset , char ordering ) { return new JCublasNDArray ( data , newShape , newStride , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data , int [ ] newDims , int [ ] newStrides , int offset , char ordering ) { return new JCublasComplexNDArray ( data , newDims , newStrides , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , Character order ) { return new JCublasComplexNDArray ( data , order ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int offset , Character order ) { return new JCublasNDArray ( data , shape , offset , order ) ; } @Override public INDArray create ( float [ ] data , int rows , int columns , int [ ] stride , int offset , char ordering ) { return new JCublasNDArray ( data , new int [ ] { rows , columns } , stride , offset , ordering ) ; } @Override public INDArray create ( double [ ] data , int [ ] shape , char ordering ) { return new JCublasNDArray ( data , shape , ordering ) ; } @Override public INDArray create ( List < INDArray > list , int [ ] shape , char ordering ) { return new JCublasNDArray ( list , shape , ordering ) ; } @Override public INDArray create ( double [ ] data , int [ ] shape , int offset ) { return new JCublasNDArray ( data , shape , ( char ) offset ) ; } @Override public INDArray create ( double [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) { return new JCublasNDArray ( data , shape , stride , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasComplexNDArray ( data , shape , stride , offset ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) { return new JCublasComplexNDArray ( data , shape , stride , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape , int [ ] stride , char ordering ) { return new JCublasComplexNDArray ( data , shape , stride , ordering ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape , int offset , char ordering ) { return new JCublasComplexNDArray ( data , shape , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape , char ordering ) { return new JCublasComplexNDArray ( data , shape , ordering ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasNDArray ( data , shape , stride , offset ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasComplexNDArray ( ArrayUtil . floatCopyOf ( data ) , shape , stride , offset ) ; } @Override public INDArray create ( double [ ] data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasNDArray ( data , shape , stride , offset ) ; } @Override public INDArray create ( DataBuffer data , int [ ] shape ) { return new JCublasNDArray ( data , shape ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data , int [ ] shape ) { return new JCublasComplexNDArray ( data , shape ) ; } @Override public IComplexNDArray createComplex ( DataBuffer data , int [ ] shape , int [ ] stride ) { return new JCublasComplexNDArray ( data , shape , stride ) ; } @Override public INDArray create ( DataBuffer data , int [ ] shape , int [ ] stride , int offset ) { return new JCublasNDArray ( data , shape , stride , offset ) ; } @Override public INDArray create ( List < INDArray > list , int [ ] shape ) { if ( order = = FORTRAN ) return new JCublasNDArray ( list , shape , ArrayUtil . calcStridesFortran ( shape ) ) ; else return new JCublasNDArray ( list , shape ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) { return new JCublasComplexNDArray ( ArrayUtil . floatCopyOf ( data ) , shape , stride , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int offset , char ordering ) { return new JCublasComplexNDArray ( ArrayUtil . floatCopyOf ( data ) , shape , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( DataBuffer buffer , int [ ] shape , int offset , char ordering ) { return new JCublasComplexNDArray ( buffer , shape , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int offset ) { return new JCublasComplexNDArray ( ArrayUtil . floatCopyOf ( data ) , shape , offset ) ; } @Override public IComplexNDArray createComplex ( DataBuffer buffer , int [ ] shape , int offset ) { return new JCublasComplexNDArray ( buffer , shape , offset ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int offset ) { return new JCublasNDArray ( data , shape , offset ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int offset , char ordering ) { return new JCublasComplexNDArray ( data , shape , Nd4j . getComplexStrides ( shape , ordering ) , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int offset ) { return new JCublasComplexNDArray ( data , shape , offset ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) { return new JCublasComplexNDArray ( data , shape , stride , offset , ordering ) ; } @Override public INDArray create ( float [ ] [ ] floats ) { return new JCublasNDArray ( floats ) ; } @Override public INDArray create ( float [ ] [ ] data , char ordering ) { return new JCublasNDArray ( data , ordering ) ; } @Override public IComplexNDArray createComplex ( float [ ] dim ) { if ( dim . length % <int> ! = <int> ) throw new IllegalArgumentException ( <str> ) ; IComplexNDArray ret = Nd4j . createComplex ( dim . length / <int> ) ; int count = <int> ; for ( int i = <int> ; i < dim . length - <int> ; i + = <int> ) { ret . putScalar ( count + + , Nd4j . createDouble ( dim [ i ] , dim [ i + <int> ] ) ) ; } return ret ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) { return new JCublasNDArray ( data , shape , stride , offset , ordering ) ; } @Override public INDArray create ( DataBuffer buffer , int [ ] shape , int offset ) { return new JCublasNDArray ( buffer , shape , offset ) ; } } 
