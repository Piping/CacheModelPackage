package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . path . PathHierarchyTokenizer ; import org . apache . lucene . analysis . path . ReversePathHierarchyTokenizer ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . IndexSettings ; public class PathHierarchyTokenizerFactory extends AbstractTokenizerFactory { private final int bufferSize ; private final char delimiter ; private final char replacement ; private final int skip ; private final boolean reverse ; public PathHierarchyTokenizerFactory ( IndexSettings indexSettings , Environment environment , String name , Settings settings ) { super ( indexSettings , name , settings ) ; bufferSize = settings . getAsInt ( <str> , <int> ) ; String delimiter = settings . get ( <str> ) ; if ( delimiter = = null ) { this . delimiter = PathHierarchyTokenizer . DEFAULT_DELIMITER ; } else if ( delimiter . length ( ) > <int> ) { throw new IllegalArgumentException ( <str> ) ; } else { this . delimiter = delimiter . charAt ( <int> ) ; } String replacement = settings . get ( <str> ) ; if ( replacement = = null ) { this . replacement = this . delimiter ; } else if ( replacement . length ( ) > <int> ) { throw new IllegalArgumentException ( <str> ) ; } else { this . replacement = replacement . charAt ( <int> ) ; } this . skip = settings . getAsInt ( <str> , PathHierarchyTokenizer . DEFAULT_SKIP ) ; this . reverse = settings . getAsBoolean ( <str> , false ) ; } @Override public Tokenizer create ( ) { if ( reverse ) { return new ReversePathHierarchyTokenizer ( bufferSize , delimiter , replacement , skip ) ; } return new PathHierarchyTokenizer ( bufferSize , delimiter , replacement , skip ) ; } } 
