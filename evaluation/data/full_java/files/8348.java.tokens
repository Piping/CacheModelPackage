package org . elasticsearch . indices . recovery ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . cluster . snapshots . create . CreateSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . restore . RestoreSnapshotResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . recovery . RecoveryResponse ; import org . elasticsearch . action . admin . indices . stats . CommonStatsFlags ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . decider . FilterAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . discovery . DiscoveryService ; import org . elasticsearch . index . recovery . RecoveryStats ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . recovery . RecoveryState . Stage ; import org . elasticsearch . indices . recovery . RecoveryState . Type ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . snapshots . SnapshotState ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . store . MockFSDirectoryService ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . Transport ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . not ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class IndexRecoveryIT extends ESIntegTestCase { private static final String INDEX_NAME = <str> ; private static final String INDEX_TYPE = <str> ; private static final String REPO_NAME = <str> ; private static final String SNAP_NAME = <str> ; private static final int MIN_DOC_COUNT = <int> ; private static final int MAX_DOC_COUNT = <int> ; private static final int SHARD_COUNT = <int> ; private static final int REPLICA_COUNT = <int> ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } private void assertRecoveryStateWithoutStage ( RecoveryState state , int shardId , Type type , String sourceNode , String targetNode , boolean hasRestoreSource ) { assertThat ( state . getShardId ( ) . getId ( ) , equalTo ( shardId ) ) ; assertThat ( state . getType ( ) , equalTo ( type ) ) ; if ( sourceNode = = null ) { assertNull ( state . getSourceNode ( ) ) ; } else { assertNotNull ( state . getSourceNode ( ) ) ; assertThat ( state . getSourceNode ( ) . getName ( ) , equalTo ( sourceNode ) ) ; } if ( targetNode = = null ) { assertNull ( state . getTargetNode ( ) ) ; } else { assertNotNull ( state . getTargetNode ( ) ) ; assertThat ( state . getTargetNode ( ) . getName ( ) , equalTo ( targetNode ) ) ; } if ( hasRestoreSource ) { assertNotNull ( state . getRestoreSource ( ) ) ; } else { assertNull ( state . getRestoreSource ( ) ) ; } } private void assertRecoveryState ( RecoveryState state , int shardId , Type type , Stage stage , String sourceNode , String targetNode , boolean hasRestoreSource ) { assertRecoveryStateWithoutStage ( state , shardId , type , sourceNode , targetNode , hasRestoreSource ) ; assertThat ( state . getStage ( ) , equalTo ( stage ) ) ; } private void assertOnGoingRecoveryState ( RecoveryState state , int shardId , Type type , String sourceNode , String targetNode , boolean hasRestoreSource ) { assertRecoveryStateWithoutStage ( state , shardId , type , sourceNode , targetNode , hasRestoreSource ) ; assertThat ( state . getStage ( ) , not ( equalTo ( Stage . DONE ) ) ) ; } private void slowDownRecovery ( ByteSizeValue shardSize ) { long chunkSize = Math . max ( <int> , shardSize . bytes ( ) / <int> ) ; for ( RecoverySettings settings : internalCluster ( ) . getInstances ( RecoverySettings . class ) ) { setChunkSize ( settings , new ByteSizeValue ( chunkSize , ByteSizeUnit . BYTES ) ) ; } assertTrue ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( RecoverySettings . INDICES_RECOVERY_MAX_BYTES_PER_SEC , chunkSize , ByteSizeUnit . BYTES ) ) . get ( ) . isAcknowledged ( ) ) ; } private void restoreRecoverySpeed ( ) { for ( RecoverySettings settings : internalCluster ( ) . getInstances ( RecoverySettings . class ) ) { setChunkSize ( settings , RecoverySettings . DEFAULT_CHUNK_SIZE ) ; } assertTrue ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( RecoverySettings . INDICES_RECOVERY_MAX_BYTES_PER_SEC , <str> ) ) . get ( ) . isAcknowledged ( ) ) ; } public void testGatewayRecovery ( ) throws Exception { logger . info ( <str> ) ; String node = internalCluster ( ) . startNode ( ) ; createAndPopulateIndex ( INDEX_NAME , <int> , SHARD_COUNT , REPLICA_COUNT ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; RecoveryResponse response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; assertThat ( response . shardRecoveryStates ( ) . size ( ) , equalTo ( SHARD_COUNT ) ) ; assertThat ( response . shardRecoveryStates ( ) . get ( INDEX_NAME ) . size ( ) , equalTo ( <int> ) ) ; List < RecoveryState > recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; assertThat ( recoveryStates . size ( ) , equalTo ( <int> ) ) ; RecoveryState recoveryState = recoveryStates . get ( <int> ) ; assertRecoveryState ( recoveryState , <int> , Type . STORE , Stage . DONE , node , node , false ) ; validateIndexRecoveryState ( recoveryState . getIndex ( ) ) ; } public void testGatewayRecoveryTestActiveOnly ( ) throws Exception { logger . info ( <str> ) ; internalCluster ( ) . startNode ( ) ; createAndPopulateIndex ( INDEX_NAME , <int> , SHARD_COUNT , REPLICA_COUNT ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; RecoveryResponse response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . setActiveOnly ( true ) . execute ( ) . actionGet ( ) ; List < RecoveryState > recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; assertThat ( recoveryStates . size ( ) , equalTo ( <int> ) ) ; } public void testReplicaRecovery ( ) throws Exception { logger . info ( <str> ) ; String nodeA = internalCluster ( ) . startNode ( ) ; logger . info ( <str> , nodeA ) ; createAndPopulateIndex ( INDEX_NAME , <int> , SHARD_COUNT , REPLICA_COUNT ) ; logger . info ( <str> ) ; String nodeB = internalCluster ( ) . startNode ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( INDEX_NAME ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; RecoveryResponse response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; List < RecoveryState > recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; assertThat ( recoveryStates . size ( ) , equalTo ( <int> ) ) ; List < RecoveryState > nodeAResponses = findRecoveriesForTargetNode ( nodeA , recoveryStates ) ; assertThat ( nodeAResponses . size ( ) , equalTo ( <int> ) ) ; List < RecoveryState > nodeBResponses = findRecoveriesForTargetNode ( nodeB , recoveryStates ) ; assertThat ( nodeBResponses . size ( ) , equalTo ( <int> ) ) ; RecoveryState nodeARecoveryState = nodeAResponses . get ( <int> ) ; assertRecoveryState ( nodeARecoveryState , <int> , Type . STORE , Stage . DONE , nodeA , nodeA , false ) ; validateIndexRecoveryState ( nodeARecoveryState . getIndex ( ) ) ; RecoveryState nodeBRecoveryState = nodeBResponses . get ( <int> ) ; assertRecoveryState ( nodeBRecoveryState , <int> , Type . REPLICA , Stage . DONE , nodeA , nodeB , false ) ; validateIndexRecoveryState ( nodeBRecoveryState . getIndex ( ) ) ; } @TestLogging ( <str> ) public void testRerouteRecovery ( ) throws Exception { logger . info ( <str> ) ; final String nodeA = internalCluster ( ) . startNode ( ) ; logger . info ( <str> , nodeA ) ; ByteSizeValue shardSize = createAndPopulateIndex ( INDEX_NAME , <int> , SHARD_COUNT , REPLICA_COUNT ) . getShards ( ) [ <int> ] . getStats ( ) . getStore ( ) . size ( ) ; logger . info ( <str> ) ; final String nodeB = internalCluster ( ) . startNode ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; slowDownRecovery ( shardSize ) ; logger . info ( <str> , nodeA , nodeB ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( INDEX_NAME , <int> ) , nodeA , nodeB ) ) . execute ( ) . actionGet ( ) . getState ( ) ; logger . info ( <str> ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { IndicesService indicesService = internalCluster ( ) . getInstance ( IndicesService . class , nodeA ) ; assertThat ( indicesService . indexServiceSafe ( INDEX_NAME ) . getShard ( <int> ) . recoveryStats ( ) . currentAsSource ( ) , equalTo ( <int> ) ) ; indicesService = internalCluster ( ) . getInstance ( IndicesService . class , nodeB ) ; assertThat ( indicesService . indexServiceSafe ( INDEX_NAME ) . getShard ( <int> ) . recoveryStats ( ) . currentAsTarget ( ) , equalTo ( <int> ) ) ; } } ) ; logger . info ( <str> ) ; RecoveryResponse response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; List < RecoveryState > recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; List < RecoveryState > nodeARecoveryStates = findRecoveriesForTargetNode ( nodeA , recoveryStates ) ; assertThat ( nodeARecoveryStates . size ( ) , equalTo ( <int> ) ) ; List < RecoveryState > nodeBRecoveryStates = findRecoveriesForTargetNode ( nodeB , recoveryStates ) ; assertThat ( nodeBRecoveryStates . size ( ) , equalTo ( <int> ) ) ; assertRecoveryState ( nodeARecoveryStates . get ( <int> ) , <int> , Type . STORE , Stage . DONE , nodeA , nodeA , false ) ; validateIndexRecoveryState ( nodeARecoveryStates . get ( <int> ) . getIndex ( ) ) ; assertOnGoingRecoveryState ( nodeBRecoveryStates . get ( <int> ) , <int> , Type . RELOCATION , nodeA , nodeB , false ) ; validateIndexRecoveryState ( nodeBRecoveryStates . get ( <int> ) . getIndex ( ) ) ; logger . info ( <str> ) ; NodesStatsResponse statsResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setIndices ( new CommonStatsFlags ( CommonStatsFlags . Flag . Recovery ) ) . get ( ) ; long nodeAThrottling = Long . MAX_VALUE ; long nodeBThrottling = Long . MAX_VALUE ; for ( NodeStats nodeStats : statsResponse . getNodes ( ) ) { final RecoveryStats recoveryStats = nodeStats . getIndices ( ) . getRecoveryStats ( ) ; if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeA ) ) { assertThat ( <str> , recoveryStats . currentAsSource ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , recoveryStats . currentAsTarget ( ) , equalTo ( <int> ) ) ; nodeAThrottling = recoveryStats . throttleTime ( ) . millis ( ) ; } if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeB ) ) { assertThat ( <str> , recoveryStats . currentAsSource ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , recoveryStats . currentAsTarget ( ) , equalTo ( <int> ) ) ; nodeBThrottling = recoveryStats . throttleTime ( ) . millis ( ) ; } } logger . info ( <str> ) ; final long finalNodeAThrottling = nodeAThrottling ; final long finalNodeBThrottling = nodeBThrottling ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { NodesStatsResponse statsResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setIndices ( new CommonStatsFlags ( CommonStatsFlags . Flag . Recovery ) ) . get ( ) ; assertThat ( statsResponse . getNodes ( ) , arrayWithSize ( <int> ) ) ; for ( NodeStats nodeStats : statsResponse . getNodes ( ) ) { final RecoveryStats recoveryStats = nodeStats . getIndices ( ) . getRecoveryStats ( ) ; if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeA ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( finalNodeAThrottling ) ) ; } if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeB ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( finalNodeBThrottling ) ) ; } } } } ) ; logger . info ( <str> ) ; restoreRecoverySpeed ( ) ; ensureGreen ( ) ; response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; assertThat ( recoveryStates . size ( ) , equalTo ( <int> ) ) ; assertRecoveryState ( recoveryStates . get ( <int> ) , <int> , Type . RELOCATION , Stage . DONE , nodeA , nodeB , false ) ; validateIndexRecoveryState ( recoveryStates . get ( <int> ) . getIndex ( ) ) ; statsResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setIndices ( new CommonStatsFlags ( CommonStatsFlags . Flag . Recovery ) ) . get ( ) ; assertThat ( statsResponse . getNodes ( ) , arrayWithSize ( <int> ) ) ; for ( NodeStats nodeStats : statsResponse . getNodes ( ) ) { final RecoveryStats recoveryStats = nodeStats . getIndices ( ) . getRecoveryStats ( ) ; assertThat ( recoveryStats . currentAsSource ( ) , equalTo ( <int> ) ) ; assertThat ( recoveryStats . currentAsTarget ( ) , equalTo ( <int> ) ) ; if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeA ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( <int> l ) ) ; } if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeB ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( <int> l ) ) ; } } logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( INDEX_NAME ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; statsResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setIndices ( new CommonStatsFlags ( CommonStatsFlags . Flag . Recovery ) ) . get ( ) ; assertThat ( statsResponse . getNodes ( ) , arrayWithSize ( <int> ) ) ; for ( NodeStats nodeStats : statsResponse . getNodes ( ) ) { final RecoveryStats recoveryStats = nodeStats . getIndices ( ) . getRecoveryStats ( ) ; assertThat ( recoveryStats . currentAsSource ( ) , equalTo ( <int> ) ) ; assertThat ( recoveryStats . currentAsTarget ( ) , equalTo ( <int> ) ) ; if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeA ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( <int> l ) ) ; } if ( nodeStats . getNode ( ) . name ( ) . equals ( nodeB ) ) { assertThat ( <str> , recoveryStats . throttleTime ( ) . millis ( ) , greaterThan ( <int> l ) ) ; } } logger . info ( <str> ) ; String nodeC = internalCluster ( ) . startNode ( ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; logger . info ( <str> ) ; slowDownRecovery ( shardSize ) ; logger . info ( <str> , nodeA , nodeC ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( INDEX_NAME , <int> ) , nodeA , nodeC ) ) . execute ( ) . actionGet ( ) . getState ( ) ; response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; nodeARecoveryStates = findRecoveriesForTargetNode ( nodeA , recoveryStates ) ; assertThat ( nodeARecoveryStates . size ( ) , equalTo ( <int> ) ) ; nodeBRecoveryStates = findRecoveriesForTargetNode ( nodeB , recoveryStates ) ; assertThat ( nodeBRecoveryStates . size ( ) , equalTo ( <int> ) ) ; List < RecoveryState > nodeCRecoveryStates = findRecoveriesForTargetNode ( nodeC , recoveryStates ) ; assertThat ( nodeCRecoveryStates . size ( ) , equalTo ( <int> ) ) ; assertRecoveryState ( nodeARecoveryStates . get ( <int> ) , <int> , Type . REPLICA , Stage . DONE , nodeB , nodeA , false ) ; validateIndexRecoveryState ( nodeARecoveryStates . get ( <int> ) . getIndex ( ) ) ; assertRecoveryState ( nodeBRecoveryStates . get ( <int> ) , <int> , Type . RELOCATION , Stage . DONE , nodeA , nodeB , false ) ; validateIndexRecoveryState ( nodeBRecoveryStates . get ( <int> ) . getIndex ( ) ) ; assertOnGoingRecoveryState ( nodeCRecoveryStates . get ( <int> ) , <int> , Type . REPLICA , nodeB , nodeC , false ) ; validateIndexRecoveryState ( nodeCRecoveryStates . get ( <int> ) . getIndex ( ) ) ; logger . info ( <str> ) ; restoreRecoverySpeed ( ) ; ensureGreen ( ) ; response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; recoveryStates = response . shardRecoveryStates ( ) . get ( INDEX_NAME ) ; nodeARecoveryStates = findRecoveriesForTargetNode ( nodeA , recoveryStates ) ; assertThat ( nodeARecoveryStates . size ( ) , equalTo ( <int> ) ) ; nodeBRecoveryStates = findRecoveriesForTargetNode ( nodeB , recoveryStates ) ; assertThat ( nodeBRecoveryStates . size ( ) , equalTo ( <int> ) ) ; nodeCRecoveryStates = findRecoveriesForTargetNode ( nodeC , recoveryStates ) ; assertThat ( nodeCRecoveryStates . size ( ) , equalTo ( <int> ) ) ; assertRecoveryState ( nodeBRecoveryStates . get ( <int> ) , <int> , Type . RELOCATION , Stage . DONE , nodeA , nodeB , false ) ; validateIndexRecoveryState ( nodeBRecoveryStates . get ( <int> ) . getIndex ( ) ) ; assertRecoveryState ( nodeCRecoveryStates . get ( <int> ) , <int> , Type . REPLICA , Stage . DONE , nodeB , nodeC , false ) ; validateIndexRecoveryState ( nodeCRecoveryStates . get ( <int> ) . getIndex ( ) ) ; } public void testSnapshotRecovery ( ) throws Exception { logger . info ( <str> ) ; String nodeA = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( REPO_NAME ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) . put ( <str> , false ) ) . get ( ) ) ; ensureGreen ( ) ; logger . info ( <str> , nodeA ) ; createAndPopulateIndex ( INDEX_NAME , <int> , SHARD_COUNT , REPLICA_COUNT ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( REPO_NAME , SNAP_NAME ) . setWaitForCompletion ( true ) . setIndices ( INDEX_NAME ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( REPO_NAME ) . setSnapshots ( SNAP_NAME ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( REPO_NAME , SNAP_NAME ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; int totalShards = restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) ; assertThat ( totalShards , greaterThan ( <int> ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; RecoveryResponse response = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; for ( Map . Entry < String , List < RecoveryState > > indexRecoveryStates : response . shardRecoveryStates ( ) . entrySet ( ) ) { assertThat ( indexRecoveryStates . getKey ( ) , equalTo ( INDEX_NAME ) ) ; List < RecoveryState > recoveryStates = indexRecoveryStates . getValue ( ) ; assertThat ( recoveryStates . size ( ) , equalTo ( totalShards ) ) ; for ( RecoveryState recoveryState : recoveryStates ) { assertRecoveryState ( recoveryState , <int> , Type . SNAPSHOT , Stage . DONE , null , nodeA , true ) ; validateIndexRecoveryState ( recoveryState . getIndex ( ) ) ; } } } private List < RecoveryState > findRecoveriesForTargetNode ( String nodeName , List < RecoveryState > recoveryStates ) { List < RecoveryState > nodeResponses = new ArrayList < > ( ) ; for ( RecoveryState recoveryState : recoveryStates ) { if ( recoveryState . getTargetNode ( ) . getName ( ) . equals ( nodeName ) ) { nodeResponses . add ( recoveryState ) ; } } return nodeResponses ; } private IndicesStatsResponse createAndPopulateIndex ( String name , int nodeCount , int shardCount , int replicaCount ) throws ExecutionException , InterruptedException { logger . info ( <str> , name ) ; assertAcked ( prepareCreate ( name , nodeCount , settingsBuilder ( ) . put ( <str> , shardCount ) . put ( <str> , replicaCount ) . put ( Store . INDEX_STORE_STATS_REFRESH_INTERVAL , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; final int numDocs = between ( MIN_DOC_COUNT , MAX_DOC_COUNT ) ; final IndexRequestBuilder [ ] docs = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( INDEX_NAME , INDEX_TYPE ) . setSource ( <str> , randomInt ( ) , <str> , randomAsciiOfLength ( <int> ) , <str> , randomFloat ( ) ) ; } indexRandom ( true , docs ) ; flush ( ) ; assertThat ( client ( ) . prepareSearch ( INDEX_NAME ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( ( long ) numDocs ) ) ; return client ( ) . admin ( ) . indices ( ) . prepareStats ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; } private void validateIndexRecoveryState ( RecoveryState . Index indexState ) { assertThat ( indexState . time ( ) , greaterThanOrEqualTo ( <int> L ) ) ; assertThat ( indexState . recoveredFilesPercent ( ) , greaterThanOrEqualTo ( <float> ) ) ; assertThat ( indexState . recoveredFilesPercent ( ) , lessThanOrEqualTo ( <float> ) ) ; assertThat ( indexState . recoveredBytesPercent ( ) , greaterThanOrEqualTo ( <float> ) ) ; assertThat ( indexState . recoveredBytesPercent ( ) , lessThanOrEqualTo ( <float> ) ) ; } public void testDisconnectsWhileRecovering ( ) throws Exception { final String indexName = <str> ; final Settings nodeSettings = Settings . builder ( ) . put ( RecoverySettings . INDICES_RECOVERY_RETRY_DELAY_NETWORK , <str> ) . put ( RecoverySettings . INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT , <str> ) . put ( MockFSDirectoryService . RANDOM_PREVENT_DOUBLE_WRITE , false ) . build ( ) ; internalCluster ( ) . startNode ( nodeSettings ) ; InternalTestCluster . Async < String > blueFuture = internalCluster ( ) . startNodeAsync ( Settings . builder ( ) . put ( <str> , <str> ) . put ( nodeSettings ) . build ( ) ) ; InternalTestCluster . Async < String > redFuture = internalCluster ( ) . startNodeAsync ( Settings . builder ( ) . put ( <str> , <str> ) . put ( nodeSettings ) . build ( ) ) ; final String blueNodeName = blueFuture . get ( ) ; final String redNodeName = redFuture . get ( ) ; ClusterHealthResponse response = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( response . isTimedOut ( ) , is ( false ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( indexName ) . setSettings ( Settings . builder ( ) . put ( FilterAllocationDecider . INDEX_ROUTING_INCLUDE_GROUP + <str> , <str> ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) . get ( ) ; List < IndexRequestBuilder > requests = new ArrayList < > ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { requests . add ( client ( ) . prepareIndex ( indexName , <str> ) . setCreate ( true ) . setSource ( <str> ) ) ; } indexRandom ( true , requests ) ; ensureSearchable ( indexName ) ; ClusterStateResponse stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; final String blueNodeId = internalCluster ( ) . getInstance ( DiscoveryService . class , blueNodeName ) . localNode ( ) . id ( ) ; assertFalse ( stateResponse . getState ( ) . getRoutingNodes ( ) . node ( blueNodeId ) . isEmpty ( ) ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( indexName ) . get ( ) ; assertHitCount ( searchResponse , numDocs ) ; String [ ] recoveryActions = new String [ ] { RecoverySource . Actions . START_RECOVERY , RecoveryTarget . Actions . FILES_INFO , RecoveryTarget . Actions . FILE_CHUNK , RecoveryTarget . Actions . CLEAN_FILES , RecoveryTarget . Actions . PREPARE_TRANSLOG , RecoveryTarget . Actions . FINALIZE } ; final String recoveryActionToBlock = randomFrom ( recoveryActions ) ; final boolean dropRequests = randomBoolean ( ) ; logger . info ( <str> , dropRequests ? <str> : <str> , recoveryActionToBlock ) ; MockTransportService blueMockTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , blueNodeName ) ; MockTransportService redMockTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , redNodeName ) ; TransportService redTransportService = internalCluster ( ) . getInstance ( TransportService . class , redNodeName ) ; TransportService blueTransportService = internalCluster ( ) . getInstance ( TransportService . class , blueNodeName ) ; final CountDownLatch requestBlocked = new CountDownLatch ( <int> ) ; blueMockTransportService . addDelegate ( redTransportService , new RecoveryActionBlocker ( dropRequests , recoveryActionToBlock , blueMockTransportService . original ( ) , requestBlocked ) ) ; redMockTransportService . addDelegate ( blueTransportService , new RecoveryActionBlocker ( dropRequests , recoveryActionToBlock , redMockTransportService . original ( ) , requestBlocked ) ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( indexName ) . setSettings ( Settings . builder ( ) . put ( FilterAllocationDecider . INDEX_ROUTING_INCLUDE_GROUP + <str> , <str> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) . get ( ) ; requestBlocked . await ( ) ; logger . info ( <str> ) ; blueMockTransportService . clearAllRules ( ) ; redMockTransportService . clearAllRules ( ) ; ensureGreen ( ) ; searchResponse = client ( redNodeName ) . prepareSearch ( indexName ) . setPreference ( <str> ) . get ( ) ; assertHitCount ( searchResponse , numDocs ) ; } private class RecoveryActionBlocker extends MockTransportService . DelegateTransport { private final boolean dropRequests ; private final String recoveryActionToBlock ; private final CountDownLatch requestBlocked ; public RecoveryActionBlocker ( boolean dropRequests , String recoveryActionToBlock , Transport delegate , CountDownLatch requestBlocked ) { super ( delegate ) ; this . dropRequests = dropRequests ; this . recoveryActionToBlock = recoveryActionToBlock ; this . requestBlocked = requestBlocked ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( recoveryActionToBlock . equals ( action ) | | requestBlocked . getCount ( ) = = <int> ) { logger . info ( <str> , action ) ; requestBlocked . countDown ( ) ; if ( dropRequests ) { return ; } throw new ConnectTransportException ( node , <str> + action + <str> ) ; } transport . sendRequest ( node , requestId , action , request , options ) ; } } public static void setChunkSize ( RecoverySettings recoverySettings , ByteSizeValue chunksSize ) { recoverySettings . setChunkSize ( chunksSize ) ; } } 
