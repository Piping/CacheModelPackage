package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . apache . commons . compress . compressors . bzip2 . BZip2CompressorOutputStream ; import org . junit . Test ; import java . io . ByteArrayOutputStream ; import java . util . Arrays ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; public class Bzip2DecoderTest extends AbstractDecoderTest { private static final byte [ ] DATA = { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , <hex> } ; public Bzip2DecoderTest ( ) throws Exception { } @Override public void initChannel ( ) { channel = new EmbeddedChannel ( new Bzip2Decoder ( ) ) ; } @Test public void testUnexpectedStreamIdentifier ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; ByteBuf in = Unpooled . buffer ( ) ; in . writeLong ( <int> ) ; channel . writeInbound ( in ) ; } @Test public void testInvalidBlockSize ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; ByteBuf in = Unpooled . buffer ( ) ; in . writeMedium ( MAGIC_NUMBER ) ; in . writeByte ( <str> ) ; channel . writeInbound ( in ) ; } @Test public void testBadBlockHeader ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; ByteBuf in = Unpooled . buffer ( ) ; in . writeMedium ( MAGIC_NUMBER ) ; in . writeByte ( <str> ) ; in . writeMedium ( <int> ) ; in . writeMedium ( <int> ) ; in . writeInt ( <int> ) ; channel . writeInbound ( in ) ; } @Test public void testStreamCrcErrorOfEmptyBlock ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; ByteBuf in = Unpooled . buffer ( ) ; in . writeMedium ( MAGIC_NUMBER ) ; in . writeByte ( <str> ) ; in . writeMedium ( END_OF_STREAM_MAGIC_1 ) ; in . writeMedium ( END_OF_STREAM_MAGIC_2 ) ; in . writeInt ( <int> ) ; channel . writeInbound ( in ) ; } @Test public void testStreamCrcError ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = ( byte ) <hex> ; tryDecodeAndCatchBufLeaks ( channel , Unpooled . wrappedBuffer ( data ) ) ; } @Test public void testIncorrectHuffmanGroupsNumber ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testIncorrectSelectorsNumber ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testBlockCrcError ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testStartPointerInvalid ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = ( byte ) <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Override protected byte [ ] compress ( byte [ ] data ) throws Exception { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream ( os , MIN_BLOCK_SIZE ) ; bZip2Os . write ( data ) ; bZip2Os . close ( ) ; return os . toByteArray ( ) ; } } 
