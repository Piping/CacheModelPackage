package org . apache . cassandra . transport . messages ; import java . util . List ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . CodecException ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Predicate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . cql3 . functions . FunctionName ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . WriteType ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . transport . * ; import org . apache . cassandra . utils . MD5Digest ; public class ErrorMessage extends Message . Response { private static final Logger logger = LoggerFactory . getLogger ( ErrorMessage . class ) ; public static final Message . Codec < ErrorMessage > codec = new Message . Codec < ErrorMessage > ( ) { public ErrorMessage decode ( ByteBuf body , int version ) { ExceptionCode code = ExceptionCode . fromValue ( body . readInt ( ) ) ; String msg = CBUtil . readString ( body ) ; TransportException te = null ; switch ( code ) { case SERVER_ERROR : te = new ServerError ( msg ) ; break ; case PROTOCOL_ERROR : te = new ProtocolException ( msg ) ; break ; case BAD_CREDENTIALS : te = new AuthenticationException ( msg ) ; break ; case UNAVAILABLE : { ConsistencyLevel cl = CBUtil . readConsistencyLevel ( body ) ; int required = body . readInt ( ) ; int alive = body . readInt ( ) ; te = new UnavailableException ( cl , required , alive ) ; } break ; case OVERLOADED : te = new OverloadedException ( msg ) ; break ; case IS_BOOTSTRAPPING : te = new IsBootstrappingException ( ) ; break ; case TRUNCATE_ERROR : te = new TruncateException ( msg ) ; break ; case WRITE_FAILURE : case READ_FAILURE : { ConsistencyLevel cl = CBUtil . readConsistencyLevel ( body ) ; int received = body . readInt ( ) ; int blockFor = body . readInt ( ) ; int failure = body . readInt ( ) ; if ( code = = ExceptionCode . WRITE_FAILURE ) { WriteType writeType = Enum . valueOf ( WriteType . class , CBUtil . readString ( body ) ) ; te = new WriteFailureException ( cl , received , failure , blockFor , writeType ) ; } else { byte dataPresent = body . readByte ( ) ; te = new ReadFailureException ( cl , received , failure , blockFor , dataPresent ! = <int> ) ; } } break ; case WRITE_TIMEOUT : case READ_TIMEOUT : ConsistencyLevel cl = CBUtil . readConsistencyLevel ( body ) ; int received = body . readInt ( ) ; int blockFor = body . readInt ( ) ; if ( code = = ExceptionCode . WRITE_TIMEOUT ) { WriteType writeType = Enum . valueOf ( WriteType . class , CBUtil . readString ( body ) ) ; te = new WriteTimeoutException ( writeType , cl , received , blockFor ) ; } else { byte dataPresent = body . readByte ( ) ; te = new ReadTimeoutException ( cl , received , blockFor , dataPresent ! = <int> ) ; } break ; case FUNCTION_FAILURE : String fKeyspace = CBUtil . readString ( body ) ; String fName = CBUtil . readString ( body ) ; List < String > argTypes = CBUtil . readStringList ( body ) ; te = new FunctionExecutionException ( new FunctionName ( fKeyspace , fName ) , argTypes , msg ) ; break ; case UNPREPARED : { MD5Digest id = MD5Digest . wrap ( CBUtil . readBytes ( body ) ) ; te = new PreparedQueryNotFoundException ( id ) ; } break ; case SYNTAX_ERROR : te = new SyntaxException ( msg ) ; break ; case UNAUTHORIZED : te = new UnauthorizedException ( msg ) ; break ; case INVALID : te = new InvalidRequestException ( msg ) ; break ; case CONFIG_ERROR : te = new ConfigurationException ( msg ) ; break ; case ALREADY_EXISTS : String ksName = CBUtil . readString ( body ) ; String cfName = CBUtil . readString ( body ) ; if ( cfName . isEmpty ( ) ) te = new AlreadyExistsException ( ksName ) ; else te = new AlreadyExistsException ( ksName , cfName ) ; break ; } return new ErrorMessage ( te ) ; } public void encode ( ErrorMessage msg , ByteBuf dest , int version ) { final TransportException err = getBackwardsCompatibleException ( msg , version ) ; dest . writeInt ( err . code ( ) . value ) ; CBUtil . writeString ( err . getMessage ( ) , dest ) ; switch ( err . code ( ) ) { case UNAVAILABLE : UnavailableException ue = ( UnavailableException ) err ; CBUtil . writeConsistencyLevel ( ue . consistency , dest ) ; dest . writeInt ( ue . required ) ; dest . writeInt ( ue . alive ) ; break ; case WRITE_FAILURE : case READ_FAILURE : { RequestFailureException rfe = ( RequestFailureException ) err ; boolean isWrite = err . code ( ) = = ExceptionCode . WRITE_FAILURE ; CBUtil . writeConsistencyLevel ( rfe . consistency , dest ) ; dest . writeInt ( rfe . received ) ; dest . writeInt ( rfe . blockFor ) ; dest . writeInt ( rfe . failures ) ; if ( isWrite ) CBUtil . writeString ( ( ( WriteFailureException ) rfe ) . writeType . toString ( ) , dest ) ; else dest . writeByte ( ( byte ) ( ( ( ReadFailureException ) rfe ) . dataPresent ? <int> : <int> ) ) ; } break ; case WRITE_TIMEOUT : case READ_TIMEOUT : RequestTimeoutException rte = ( RequestTimeoutException ) err ; boolean isWrite = err . code ( ) = = ExceptionCode . WRITE_TIMEOUT ; CBUtil . writeConsistencyLevel ( rte . consistency , dest ) ; dest . writeInt ( rte . received ) ; dest . writeInt ( rte . blockFor ) ; if ( isWrite ) CBUtil . writeString ( ( ( WriteTimeoutException ) rte ) . writeType . toString ( ) , dest ) ; else dest . writeByte ( ( byte ) ( ( ( ReadTimeoutException ) rte ) . dataPresent ? <int> : <int> ) ) ; break ; case FUNCTION_FAILURE : FunctionExecutionException fee = ( FunctionExecutionException ) msg . error ; CBUtil . writeString ( fee . functionName . keyspace , dest ) ; CBUtil . writeString ( fee . functionName . name , dest ) ; CBUtil . writeStringList ( fee . argTypes , dest ) ; break ; case UNPREPARED : PreparedQueryNotFoundException pqnfe = ( PreparedQueryNotFoundException ) err ; CBUtil . writeBytes ( pqnfe . id . bytes , dest ) ; break ; case ALREADY_EXISTS : AlreadyExistsException aee = ( AlreadyExistsException ) err ; CBUtil . writeString ( aee . ksName , dest ) ; CBUtil . writeString ( aee . cfName , dest ) ; break ; } } public int encodedSize ( ErrorMessage msg , int version ) { final TransportException err = getBackwardsCompatibleException ( msg , version ) ; int size = <int> + CBUtil . sizeOfString ( err . getMessage ( ) ) ; switch ( err . code ( ) ) { case UNAVAILABLE : UnavailableException ue = ( UnavailableException ) err ; size + = CBUtil . sizeOfConsistencyLevel ( ue . consistency ) + <int> ; break ; case WRITE_FAILURE : case READ_FAILURE : { RequestFailureException rfe = ( RequestFailureException ) err ; boolean isWrite = err . code ( ) = = ExceptionCode . WRITE_FAILURE ; size + = CBUtil . sizeOfConsistencyLevel ( rfe . consistency ) + <int> + <int> + <int> ; size + = isWrite ? CBUtil . sizeOfString ( ( ( WriteFailureException ) rfe ) . writeType . toString ( ) ) : <int> ; } break ; case WRITE_TIMEOUT : case READ_TIMEOUT : RequestTimeoutException rte = ( RequestTimeoutException ) err ; boolean isWrite = err . code ( ) = = ExceptionCode . WRITE_TIMEOUT ; size + = CBUtil . sizeOfConsistencyLevel ( rte . consistency ) + <int> ; size + = isWrite ? CBUtil . sizeOfString ( ( ( WriteTimeoutException ) rte ) . writeType . toString ( ) ) : <int> ; break ; case FUNCTION_FAILURE : FunctionExecutionException fee = ( FunctionExecutionException ) msg . error ; size + = CBUtil . sizeOfString ( fee . functionName . keyspace ) ; size + = CBUtil . sizeOfString ( fee . functionName . name ) ; size + = CBUtil . sizeOfStringList ( fee . argTypes ) ; break ; case UNPREPARED : PreparedQueryNotFoundException pqnfe = ( PreparedQueryNotFoundException ) err ; size + = CBUtil . sizeOfBytes ( pqnfe . id . bytes ) ; break ; case ALREADY_EXISTS : AlreadyExistsException aee = ( AlreadyExistsException ) err ; size + = CBUtil . sizeOfString ( aee . ksName ) ; size + = CBUtil . sizeOfString ( aee . cfName ) ; break ; } return size ; } } ; private static TransportException getBackwardsCompatibleException ( ErrorMessage msg , int version ) { if ( version < Server . VERSION_4 ) { switch ( msg . error . code ( ) ) { case READ_FAILURE : ReadFailureException rfe = ( ReadFailureException ) msg . error ; return new ReadTimeoutException ( rfe . consistency , rfe . received , rfe . blockFor , rfe . dataPresent ) ; case WRITE_FAILURE : WriteFailureException wfe = ( WriteFailureException ) msg . error ; return new WriteTimeoutException ( wfe . writeType , wfe . consistency , wfe . received , wfe . blockFor ) ; case FUNCTION_FAILURE : return new InvalidRequestException ( msg . toString ( ) ) ; } } return msg . error ; } public final TransportException error ; private ErrorMessage ( TransportException error ) { super ( Message . Type . ERROR ) ; this . error = error ; } private ErrorMessage ( TransportException error , int streamId ) { this ( error ) ; setStreamId ( streamId ) ; } public static ErrorMessage fromException ( Throwable e ) { return fromException ( e , null ) ; } public static ErrorMessage fromException ( Throwable e , Predicate < Throwable > unexpectedExceptionHandler ) { int streamId = <int> ; if ( e instanceof CodecException ) { Throwable cause = e . getCause ( ) ; if ( cause ! = null ) { if ( cause instanceof WrappedException ) { streamId = ( ( WrappedException ) cause ) . streamId ; e = cause . getCause ( ) ; } else if ( cause instanceof TransportException ) { e = cause ; } } } else if ( e instanceof WrappedException ) { streamId = ( ( WrappedException ) e ) . streamId ; e = e . getCause ( ) ; } if ( e instanceof TransportException ) return new ErrorMessage ( ( TransportException ) e , streamId ) ; if ( unexpectedExceptionHandler = = null | | ! unexpectedExceptionHandler . apply ( e ) ) logger . error ( <str> , e ) ; return new ErrorMessage ( new ServerError ( e ) , streamId ) ; } @Override public String toString ( ) { return <str> + error . code ( ) + <str> + error . getMessage ( ) ; } public static RuntimeException wrap ( Throwable t , int streamId ) { return new WrappedException ( t , streamId ) ; } public static class WrappedException extends RuntimeException { private final int streamId ; public WrappedException ( Throwable cause , int streamId ) { super ( cause ) ; this . streamId = streamId ; } @VisibleForTesting public int getStreamId ( ) { return this . streamId ; } } } 
