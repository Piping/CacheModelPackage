package org . elasticsearch . action . admin . cluster . node . info ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . nodes . BaseNodeRequest ; import org . elasticsearch . action . support . nodes . TransportNodesAction ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicReferenceArray ; public class TransportNodesInfoAction extends TransportNodesAction < NodesInfoRequest , NodesInfoResponse , TransportNodesInfoAction . NodeInfoRequest , NodeInfo > { private final NodeService nodeService ; @Inject public TransportNodesInfoAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , NodeService nodeService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , NodesInfoAction . NAME , clusterName , threadPool , clusterService , transportService , actionFilters , indexNameExpressionResolver , NodesInfoRequest : : new , NodeInfoRequest : : new , ThreadPool . Names . MANAGEMENT ) ; this . nodeService = nodeService ; } @Override protected NodesInfoResponse newResponse ( NodesInfoRequest nodesInfoRequest , AtomicReferenceArray responses ) { final List < NodeInfo > nodesInfos = new ArrayList < > ( ) ; for ( int i = <int> ; i < responses . length ( ) ; i + + ) { Object resp = responses . get ( i ) ; if ( resp instanceof NodeInfo ) { nodesInfos . add ( ( NodeInfo ) resp ) ; } } return new NodesInfoResponse ( clusterName , nodesInfos . toArray ( new NodeInfo [ nodesInfos . size ( ) ] ) ) ; } @Override protected NodeInfoRequest newNodeRequest ( String nodeId , NodesInfoRequest request ) { return new NodeInfoRequest ( nodeId , request ) ; } @Override protected NodeInfo newNodeResponse ( ) { return new NodeInfo ( ) ; } @Override protected NodeInfo nodeOperation ( NodeInfoRequest nodeRequest ) { NodesInfoRequest request = nodeRequest . request ; return nodeService . info ( request . settings ( ) , request . os ( ) , request . process ( ) , request . jvm ( ) , request . threadPool ( ) , request . transport ( ) , request . http ( ) , request . plugins ( ) ) ; } @Override protected boolean accumulateExceptions ( ) { return false ; } public static class NodeInfoRequest extends BaseNodeRequest { NodesInfoRequest request ; public NodeInfoRequest ( ) { } NodeInfoRequest ( String nodeId , NodesInfoRequest request ) { super ( request , nodeId ) ; this . request = request ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; request = new NodesInfoRequest ( ) ; request . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; request . writeTo ( out ) ; } } } 
