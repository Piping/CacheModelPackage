package org . elasticsearch . common . xcontent . support ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . emptyMap ; import static java . util . Collections . singletonMap ; import static org . hamcrest . Matchers . hasEntry ; import static org . hamcrest . Matchers . hasKey ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . nullValue ; import static org . hamcrest . core . IsEqual . equalTo ; public class XContentMapValuesTests extends ESTestCase { public void testFilter ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ; Map < String , Object > source ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { source = parser . map ( ) ; } Map < String , Object > filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . size ( ) , equalTo ( <int> ) ) ; assertThat ( filter . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . size ( ) , equalTo ( <int> ) ) ; assertThat ( filter . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( filter . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; filter = XContentMapValues . filter ( source , Strings . EMPTY_ARRAY , new String [ ] { <str> } ) ; assertThat ( filter . size ( ) , equalTo ( <int> ) ) ; assertThat ( filter . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( filter . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . field ( <str> , <str> ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { source = parser . map ( ) ; } filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . size ( ) , equalTo ( <int> ) ) ; filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . get ( <str> ) , equalTo ( source . get ( <str> ) ) ) ; assertThat ( filter . containsKey ( <str> ) , equalTo ( false ) ) ; filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . get ( <str> ) , equalTo ( source . get ( <str> ) ) ) ; assertThat ( filter . containsKey ( <str> ) , equalTo ( false ) ) ; filter = XContentMapValues . filter ( source , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filter . get ( <str> ) , equalTo ( source . get ( <str> ) ) ) ; assertThat ( filter . containsKey ( <str> ) , equalTo ( false ) ) ; } @SuppressWarnings ( { <str> } ) public void testExtractValue ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; Map < String , Object > map ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractValue ( <str> , map ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( XContentMapValues . extractValue ( <str> , map ) , nullValue ( ) ) ; assertThat ( XContentMapValues . extractValue ( <str> , map ) , nullValue ( ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractValue ( <str> , map ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( XContentMapValues . extractValue ( <str> , map ) , nullValue ( ) ) ; assertThat ( XContentMapValues . extractValue ( <str> , map ) , nullValue ( ) ) ; Object extValue = XContentMapValues . extractValue ( <str> , map ) ; assertThat ( extValue , instanceOf ( Map . class ) ) ; Map < String , Object > extMapValue = ( Map < String , Object > ) extValue ; assertThat ( extMapValue , hasEntry ( <str> , ( Object ) <str> ) ) ; extValue = XContentMapValues . extractValue ( <str> , map ) ; assertThat ( extValue , instanceOf ( Map . class ) ) ; extMapValue = ( Map < String , Object > ) extValue ; assertThat ( extMapValue . containsKey ( <str> ) , equalTo ( true ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> , <str> ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } extValue = XContentMapValues . extractValue ( <str> , map ) ; assertThat ( extValue , instanceOf ( List . class ) ) ; List extListValue = ( List ) extValue ; assertThat ( extListValue . size ( ) , equalTo ( <int> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } extValue = XContentMapValues . extractValue ( <str> , map ) ; assertThat ( extValue , instanceOf ( List . class ) ) ; extListValue = ( List ) extValue ; assertThat ( extListValue . size ( ) , equalTo ( <int> ) ) ; assertThat ( extListValue . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( extListValue . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractValue ( <str> , map ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractValue ( <str> , map ) . toString ( ) , equalTo ( <str> ) ) ; } public void testExtractRawValue ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; Map < String , Object > map ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractRawValues ( <str> , map ) . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractRawValues ( <str> , map ) . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractRawValues ( <str> , map ) . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { map = parser . map ( ) ; } assertThat ( XContentMapValues . extractRawValues ( <str> , map ) . get ( <int> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testPrefixedNamesFilteringTest ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; map . put ( <str> , <str> ) ; Map < String , Object > filterdMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filterdMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( String ) filterdMap . get ( <str> ) , equalTo ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testNestedFiltering ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; map . put ( <str> , Arrays . asList ( <int> , new HashMap < String , Object > ( ) { { put ( <str> , <int> ) ; put ( <str> , <int> ) ; } } ) ) ; Map < String , Object > falteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( falteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) ( ( List ) falteredMap . get ( <str> ) ) . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) ( ( List ) falteredMap . get ( <str> ) ) . get ( <int> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) ( ( Map < String , Object > ) ( ( List ) falteredMap . get ( <str> ) ) . get ( <int> ) ) . get ( <str> ) , equalTo ( <int> ) ) ; falteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( falteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) ( ( List ) falteredMap . get ( <str> ) ) . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) ( ( List ) falteredMap . get ( <str> ) ) . get ( <int> ) ) . size ( ) , equalTo ( <int> ) ) ; map . clear ( ) ; map . put ( <str> , <str> ) ; map . put ( <str> , new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <str> ) ; } } ) ; falteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( falteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) falteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( String ) ( ( Map < String , Object > ) falteredMap . get ( <str> ) ) . get ( <str> ) , equalTo ( <str> ) ) ; falteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( falteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) falteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( String ) ( ( Map < String , Object > ) falteredMap . get ( <str> ) ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( ( String ) ( ( Map < String , Object > ) falteredMap . get ( <str> ) ) . get ( <str> ) , equalTo ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testCompleteObjectFiltering ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; map . put ( <str> , new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <str> ) ; } } ) ; map . put ( <str> , Arrays . asList ( <int> , new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <str> ) ; } } ) ) ; Map < String , Object > filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , new String [ ] { <str> } ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , new String [ ] { } ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( List ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) ( ( List ) filteredMap . get ( <str> ) ) . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) ( ( List ) filteredMap . get ( <str> ) ) . get ( <int> ) ) . size ( ) , equalTo ( <int> ) ) ; filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , new String [ ] { <str> } ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( List ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) ( ( List ) filteredMap . get ( <str> ) ) . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) ( ( List ) filteredMap . get ( <str> ) ) . get ( <int> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) ( ( List ) filteredMap . get ( <str> ) ) . get ( <int> ) ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testFilterIncludesUsingStarPrefix ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; map . put ( <str> , new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <str> ) ; } } ) ; map . put ( <str> , new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <str> ) ; } } ) ; Map < String , Object > filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) , hasKey ( <str> ) ) ; filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; filteredMap = XContentMapValues . filter ( map , new String [ ] { <str> } , new String [ ] { <str> } ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) , hasKey ( <str> ) ) ; assertThat ( filteredMap , hasKey ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredMap . get ( <str> ) ) , hasKey ( <str> ) ) ; } public void testFilterWithEmptyIncludesExcludes ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; Map < String , Object > filteredMap = XContentMapValues . filter ( map , Strings . EMPTY_ARRAY , Strings . EMPTY_ARRAY ) ; assertThat ( filteredMap . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredMap . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testThatFilterIncludesEmptyObjectWhenUsingIncludes ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) ; Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( builder . bytes ( ) , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( mapTuple . v2 ( ) , equalTo ( filteredSource ) ) ; } public void testThatFilterIncludesEmptyObjectWhenUsingExcludes ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) ; Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( builder . bytes ( ) , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , Strings . EMPTY_ARRAY , new String [ ] { <str> } ) ; assertThat ( mapTuple . v2 ( ) , equalTo ( filteredSource ) ) ; } public void testNotOmittingObjectsWithExcludedProperties ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( builder . bytes ( ) , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , Strings . EMPTY_ARRAY , new String [ ] { <str> } ) ; assertThat ( filteredSource . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredSource , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) filteredSource . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; } @SuppressWarnings ( { <str> } ) public void testNotOmittingObjectWithNestedExcludedObject ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( builder . bytes ( ) , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , Strings . EMPTY_ARRAY , new String [ ] { <str> } ) ; assertThat ( filteredSource . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredSource , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) filteredSource . get ( <str> ) ) . size ( ) , Matchers . equalTo ( <int> ) ) ; filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , new String [ ] { <str> } , new String [ ] { <str> } ) ; assertThat ( filteredSource . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredSource , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) filteredSource . get ( <str> ) ) . size ( ) , Matchers . equalTo ( <int> ) ) ; filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , new String [ ] { <str> } , new String [ ] { <str> } ) ; assertThat ( filteredSource . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredSource , hasKey ( <str> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredSource . get ( <str> ) ) , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) ( ( Map ) filteredSource . get ( <str> ) ) . get ( <str> ) ) . size ( ) , Matchers . equalTo ( <int> ) ) ; } @SuppressWarnings ( { <str> } ) public void testIncludingObjectWithNestedIncludedObject ( ) throws Exception { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; Tuple < XContentType , Map < String , Object > > mapTuple = XContentHelper . convertToMap ( builder . bytes ( ) , true ) ; Map < String , Object > filteredSource = XContentMapValues . filter ( mapTuple . v2 ( ) , new String [ ] { <str> } , Strings . EMPTY_ARRAY ) ; assertThat ( filteredSource . size ( ) , equalTo ( <int> ) ) ; assertThat ( filteredSource , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) filteredSource . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Object > ) filteredSource . get ( <str> ) ) , hasKey ( <str> ) ) ; assertThat ( ( ( Map ) ( ( Map ) filteredSource . get ( <str> ) ) . get ( <str> ) ) . size ( ) , equalTo ( <int> ) ) ; } public void testEmptyList ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . endArray ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { assertEquals ( XContentParser . Token . START_OBJECT , parser . nextToken ( ) ) ; assertEquals ( XContentParser . Token . FIELD_NAME , parser . nextToken ( ) ) ; assertEquals ( <str> , parser . currentName ( ) ) ; if ( random ( ) . nextBoolean ( ) ) { assertEquals ( XContentParser . Token . START_ARRAY , parser . nextToken ( ) ) ; } assertEquals ( Collections . emptyList ( ) , parser . list ( ) ) ; } } public void testSimpleList ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . value ( <int> ) . value ( <int> ) . endArray ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { assertEquals ( XContentParser . Token . START_OBJECT , parser . nextToken ( ) ) ; assertEquals ( XContentParser . Token . FIELD_NAME , parser . nextToken ( ) ) ; assertEquals ( <str> , parser . currentName ( ) ) ; if ( random ( ) . nextBoolean ( ) ) { assertEquals ( XContentParser . Token . START_ARRAY , parser . nextToken ( ) ) ; } assertEquals ( Arrays . asList ( <int> , <int> , <int> ) , parser . list ( ) ) ; } } public void testNestedList ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startArray ( ) . endArray ( ) . startArray ( ) . value ( <int> ) . value ( <int> ) . endArray ( ) . startArray ( ) . value ( <int> ) . endArray ( ) . endArray ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { assertEquals ( XContentParser . Token . START_OBJECT , parser . nextToken ( ) ) ; assertEquals ( XContentParser . Token . FIELD_NAME , parser . nextToken ( ) ) ; assertEquals ( <str> , parser . currentName ( ) ) ; if ( random ( ) . nextBoolean ( ) ) { assertEquals ( XContentParser . Token . START_ARRAY , parser . nextToken ( ) ) ; } assertEquals ( Arrays . asList ( Collections . < Integer > emptyList ( ) , Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> ) ) , parser . list ( ) ) ; } } public void testNestedMapInList ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . string ( ) ) ) { assertEquals ( XContentParser . Token . START_OBJECT , parser . nextToken ( ) ) ; assertEquals ( XContentParser . Token . FIELD_NAME , parser . nextToken ( ) ) ; assertEquals ( <str> , parser . currentName ( ) ) ; if ( random ( ) . nextBoolean ( ) ) { assertEquals ( XContentParser . Token . START_ARRAY , parser . nextToken ( ) ) ; } assertEquals ( Arrays . asList ( singletonMap ( <str> , <str> ) , emptyMap ( ) ) , parser . list ( ) ) ; } } } 
