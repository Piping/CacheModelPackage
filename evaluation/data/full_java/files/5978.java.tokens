package org . elasticsearch . common . lucene . all ; import org . elasticsearch . common . io . FastCharArrayWriter ; import org . elasticsearch . common . io . FastStringReader ; import java . io . IOException ; import java . io . Reader ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; public class AllEntries extends Reader { public static class Entry { private final String name ; private final FastStringReader reader ; private final int startOffset ; private final float boost ; public Entry ( String name , FastStringReader reader , int startOffset , float boost ) { this . name = name ; this . reader = reader ; this . startOffset = startOffset ; this . boost = boost ; } public int startOffset ( ) { return startOffset ; } public String name ( ) { return this . name ; } public float boost ( ) { return this . boost ; } public FastStringReader reader ( ) { return this . reader ; } } private final List < Entry > entries = new ArrayList < > ( ) ; private Entry current ; private Iterator < Entry > it ; private boolean itsSeparatorTime = false ; private boolean customBoost = false ; public void addText ( String name , String text , float boost ) { if ( boost ! = <float> ) { customBoost = true ; } final int lastStartOffset ; if ( entries . isEmpty ( ) ) { lastStartOffset = - <int> ; } else { final Entry last = entries . get ( entries . size ( ) - <int> ) ; lastStartOffset = last . startOffset ( ) + last . reader ( ) . length ( ) ; } final int startOffset = lastStartOffset + <int> ; Entry entry = new Entry ( name , new FastStringReader ( text ) , startOffset , boost ) ; entries . add ( entry ) ; } public boolean customBoost ( ) { return customBoost ; } public void clear ( ) { this . entries . clear ( ) ; this . current = null ; this . it = null ; itsSeparatorTime = false ; } @Override public void reset ( ) { try { for ( Entry entry : entries ) { entry . reader ( ) . reset ( ) ; } } catch ( IOException e ) { throw new IllegalStateException ( <str> ) ; } it = entries . iterator ( ) ; if ( it . hasNext ( ) ) { current = it . next ( ) ; itsSeparatorTime = true ; } } public String buildText ( ) { reset ( ) ; FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; for ( Entry entry : entries ) { writer . append ( entry . reader ( ) ) ; writer . append ( <str> ) ; } reset ( ) ; return writer . toString ( ) ; } public List < Entry > entries ( ) { return this . entries ; } public Set < String > fields ( ) { Set < String > fields = new HashSet < > ( ) ; for ( Entry entry : entries ) { fields . add ( entry . name ( ) ) ; } return fields ; } public float boost ( int startOffset ) { if ( ! entries . isEmpty ( ) ) { int lo = <int> , hi = entries . size ( ) - <int> ; while ( lo < = hi ) { final int mid = ( lo + hi ) > > > <int> ; final int midOffset = entries . get ( mid ) . startOffset ( ) ; if ( startOffset < midOffset ) { hi = mid - <int> ; } else { lo = mid + <int> ; } } final int index = Math . max ( <int> , hi ) ; assert entries . get ( index ) . startOffset ( ) < = startOffset ; assert index = = entries . size ( ) - <int> | | entries . get ( index + <int> ) . startOffset ( ) > startOffset ; return entries . get ( index ) . boost ( ) ; } return <float> ; } @Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { if ( current = = null ) { return - <int> ; } if ( customBoost ) { int result = current . reader ( ) . read ( cbuf , off , len ) ; if ( result = = - <int> ) { if ( itsSeparatorTime ) { itsSeparatorTime = false ; cbuf [ off ] = <str> ; return <int> ; } itsSeparatorTime = true ; if ( it . hasNext ( ) ) { current = it . next ( ) ; } else { current = null ; } return read ( cbuf , off , len ) ; } return result ; } else { int read = <int> ; while ( len > <int> ) { int result = current . reader ( ) . read ( cbuf , off , len ) ; if ( result = = - <int> ) { if ( it . hasNext ( ) ) { current = it . next ( ) ; } else { current = null ; if ( read = = <int> ) { return - <int> ; } return read ; } cbuf [ off + + ] = <str> ; read + + ; len - - ; } else { read + = result ; off + = result ; len - = result ; } } return read ; } } @Override public void close ( ) { if ( current ! = null ) { current = null ; } } @Override public boolean ready ( ) throws IOException { return ( current ! = null ) & & current . reader ( ) . ready ( ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Entry entry : entries ) { sb . append ( entry . name ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } } 
