package org . apache . cassandra . hints ; import java . io . File ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Supplier ; import com . google . common . util . concurrent . RateLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . service . StorageService ; final class HintsDispatchExecutor { private static final Logger logger = LoggerFactory . getLogger ( HintsDispatchExecutor . class ) ; private final File hintsDirectory ; private final ExecutorService executor ; private final AtomicBoolean isPaused ; private final Map < UUID , Future > scheduledDispatches ; HintsDispatchExecutor ( File hintsDirectory , int maxThreads , AtomicBoolean isPaused ) { this . hintsDirectory = hintsDirectory ; this . isPaused = isPaused ; scheduledDispatches = new ConcurrentHashMap < > ( ) ; executor = new JMXEnabledThreadPoolExecutor ( <int> , maxThreads , <int> , TimeUnit . MINUTES , new LinkedBlockingQueue < > ( ) , new NamedThreadFactory ( <str> , Thread . MIN_PRIORITY ) , <str> ) ; } void shutdownBlocking ( ) { scheduledDispatches . clear ( ) ; executor . shutdownNow ( ) ; } boolean isScheduled ( HintsStore store ) { return scheduledDispatches . containsKey ( store . hostId ) ; } Future dispatch ( HintsStore store ) { return dispatch ( store , store . hostId ) ; } Future dispatch ( HintsStore store , UUID hostId ) { return scheduledDispatches . computeIfAbsent ( hostId , uuid - > executor . submit ( new DispatchHintsTask ( store , hostId ) ) ) ; } Future transfer ( HintsCatalog catalog , Supplier < UUID > hostIdSupplier ) { return executor . submit ( new TransferHintsTask ( catalog , hostIdSupplier ) ) ; } void completeDispatchBlockingly ( HintsStore store ) { Future future = scheduledDispatches . get ( store . hostId ) ; try { if ( future ! = null ) future . get ( ) ; } catch ( ExecutionException | InterruptedException e ) { throw new RuntimeException ( e ) ; } } private final class TransferHintsTask implements Runnable { private final HintsCatalog catalog ; private final Supplier < UUID > hostIdSupplier ; private TransferHintsTask ( HintsCatalog catalog , Supplier < UUID > hostIdSupplier ) { this . catalog = catalog ; this . hostIdSupplier = hostIdSupplier ; } @Override public void run ( ) { UUID hostId = hostIdSupplier . get ( ) ; logger . info ( <str> , hostId ) ; if ( transfer ( hostId ) ) return ; logger . warn ( <str> , hostId , <int> ) ; try { TimeUnit . SECONDS . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } hostId = hostIdSupplier . get ( ) ; logger . info ( <str> , hostId ) ; if ( ! transfer ( hostId ) ) { logger . error ( <str> , hostId ) ; throw new RuntimeException ( <str> + hostId ) ; } } private boolean transfer ( UUID hostId ) { catalog . stores ( ) . map ( store - > new DispatchHintsTask ( store , hostId ) ) . forEach ( Runnable : : run ) ; return ! catalog . hasFiles ( ) ; } } private final class DispatchHintsTask implements Runnable { private final HintsStore store ; private final UUID hostId ; private final RateLimiter rateLimiter ; DispatchHintsTask ( HintsStore store , UUID hostId ) { this . store = store ; this . hostId = hostId ; int nodesCount = Math . max ( <int> , StorageService . instance . getTokenMetadata ( ) . getAllEndpoints ( ) . size ( ) - <int> ) ; int throttleInKB = DatabaseDescriptor . getHintedHandoffThrottleInKB ( ) / nodesCount ; this . rateLimiter = RateLimiter . create ( throttleInKB = = <int> ? Double . MAX_VALUE : throttleInKB * <int> ) ; } public void run ( ) { try { dispatch ( ) ; } finally { scheduledDispatches . remove ( hostId ) ; } } private void dispatch ( ) { while ( true ) { if ( isPaused . get ( ) ) break ; HintsDescriptor descriptor = store . poll ( ) ; if ( descriptor = = null ) break ; try { if ( ! dispatch ( descriptor ) ) break ; } catch ( FSReadError e ) { logger . error ( <str> , descriptor . fileName ( ) , e ) ; store . cleanUp ( descriptor ) ; store . blacklist ( descriptor ) ; throw e ; } } } private boolean dispatch ( HintsDescriptor descriptor ) { logger . trace ( <str> , descriptor . fileName ( ) ) ; File file = new File ( hintsDirectory , descriptor . fileName ( ) ) ; Long offset = store . getDispatchOffset ( descriptor ) . orElse ( null ) ; try ( HintsDispatcher dispatcher = HintsDispatcher . create ( file , rateLimiter , hostId , descriptor . hostId , isPaused ) ) { if ( offset ! = null ) dispatcher . seek ( offset ) ; if ( dispatcher . dispatch ( ) ) { if ( ! file . delete ( ) ) logger . error ( <str> , descriptor . fileName ( ) ) ; store . cleanUp ( descriptor ) ; logger . info ( <str> , descriptor . fileName ( ) , hostId ) ; return true ; } else { store . markDispatchOffset ( descriptor , dispatcher . dispatchOffset ( ) ) ; store . offerFirst ( descriptor ) ; logger . info ( <str> , descriptor . fileName ( ) , hostId ) ; return false ; } } } } } 
