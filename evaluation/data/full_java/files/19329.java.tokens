package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . CONNECTION_STREAM_ID ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_WINDOW_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MAX_INITIAL_WINDOW_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MIN_INITIAL_WINDOW_SIZE ; import static io . netty . handler . codec . http2 . Http2Error . FLOW_CONTROL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . handler . codec . http2 . Http2Exception . streamError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . max ; import static java . lang . Math . min ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . http2 . Http2Exception . CompositeStreamException ; import io . netty . handler . codec . http2 . Http2Exception . StreamException ; import io . netty . util . internal . PlatformDependent ; public class DefaultHttp2LocalFlowController implements Http2LocalFlowController { public static final float DEFAULT_WINDOW_UPDATE_RATIO = <float> ; private final Http2Connection connection ; private final Http2Connection . PropertyKey stateKey ; private Http2FrameWriter frameWriter ; private ChannelHandlerContext ctx ; private float windowUpdateRatio ; private int initialWindowSize = DEFAULT_WINDOW_SIZE ; public DefaultHttp2LocalFlowController ( Http2Connection connection ) { this ( connection , DEFAULT_WINDOW_UPDATE_RATIO , false ) ; } public DefaultHttp2LocalFlowController ( Http2Connection connection , float windowUpdateRatio , boolean autoRefillConnectionWindow ) { this . connection = checkNotNull ( connection , <str> ) ; windowUpdateRatio ( windowUpdateRatio ) ; stateKey = connection . newKey ( ) ; FlowState connectionState = autoRefillConnectionWindow ? new AutoRefillState ( connection . connectionStream ( ) , initialWindowSize ) : new DefaultState ( connection . connectionStream ( ) , initialWindowSize ) ; connection . connectionStream ( ) . setProperty ( stateKey , connectionState ) ; connection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamAdded ( Http2Stream stream ) { stream . setProperty ( stateKey , REDUCED_FLOW_STATE ) ; } @Override public void onStreamActive ( Http2Stream stream ) { stream . setProperty ( stateKey , new DefaultState ( stream , initialWindowSize ) ) ; } @Override public void onStreamClosed ( Http2Stream stream ) { try { FlowState state = state ( stream ) ; int unconsumedBytes = state . unconsumedBytes ( ) ; if ( ctx ! = null & & unconsumedBytes > <int> ) { connectionState ( ) . consumeBytes ( unconsumedBytes ) ; state . consumeBytes ( unconsumedBytes ) ; } } catch ( Http2Exception e ) { PlatformDependent . throwException ( e ) ; } finally { stream . setProperty ( stateKey , REDUCED_FLOW_STATE ) ; } } } ) ; } @Override public DefaultHttp2LocalFlowController frameWriter ( Http2FrameWriter frameWriter ) { this . frameWriter = checkNotNull ( frameWriter , <str> ) ; return this ; } @Override public void channelHandlerContext ( ChannelHandlerContext ctx ) { this . ctx = checkNotNull ( ctx , <str> ) ; } @Override public void initialWindowSize ( int newWindowSize ) throws Http2Exception { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; int delta = newWindowSize - initialWindowSize ; initialWindowSize = newWindowSize ; WindowUpdateVisitor visitor = new WindowUpdateVisitor ( delta ) ; connection . forEachActiveStream ( visitor ) ; visitor . throwIfError ( ) ; } @Override public int initialWindowSize ( ) { return initialWindowSize ; } @Override public int windowSize ( Http2Stream stream ) { return state ( stream ) . windowSize ( ) ; } @Override public int initialWindowSize ( Http2Stream stream ) { return state ( stream ) . initialWindowSize ( ) ; } @Override public void incrementWindowSize ( Http2Stream stream , int delta ) throws Http2Exception { assert ctx ! = null & & ctx . executor ( ) . inEventLoop ( ) ; FlowState state = state ( stream ) ; state . incrementInitialStreamWindow ( delta ) ; state . writeWindowUpdateIfNeeded ( ) ; } @Override public boolean consumeBytes ( Http2Stream stream , int numBytes ) throws Http2Exception { assert ctx ! = null & & ctx . executor ( ) . inEventLoop ( ) ; if ( numBytes < <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( numBytes = = <int> ) { return false ; } if ( stream ! = null & & ! isClosed ( stream ) ) { if ( stream . id ( ) = = CONNECTION_STREAM_ID ) { throw new UnsupportedOperationException ( <str> ) ; } boolean windowUpdateSent = connectionState ( ) . consumeBytes ( numBytes ) ; windowUpdateSent | = state ( stream ) . consumeBytes ( numBytes ) ; return windowUpdateSent ; } return false ; } @Override public int unconsumedBytes ( Http2Stream stream ) { return state ( stream ) . unconsumedBytes ( ) ; } private static void checkValidRatio ( float ratio ) { if ( Double . compare ( ratio , <float> ) < = <int> | | Double . compare ( ratio , <float> ) > = <int> ) { throw new IllegalArgumentException ( <str> + ratio ) ; } } public void windowUpdateRatio ( float ratio ) { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; checkValidRatio ( ratio ) ; windowUpdateRatio = ratio ; } public float windowUpdateRatio ( ) { return windowUpdateRatio ; } public void windowUpdateRatio ( Http2Stream stream , float ratio ) throws Http2Exception { assert ctx ! = null & & ctx . executor ( ) . inEventLoop ( ) ; checkValidRatio ( ratio ) ; FlowState state = state ( stream ) ; state . windowUpdateRatio ( ratio ) ; state . writeWindowUpdateIfNeeded ( ) ; } public float windowUpdateRatio ( Http2Stream stream ) throws Http2Exception { return state ( stream ) . windowUpdateRatio ( ) ; } @Override public void receiveFlowControlledFrame ( Http2Stream stream , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { assert ctx ! = null & & ctx . executor ( ) . inEventLoop ( ) ; int dataLength = data . readableBytes ( ) + padding ; FlowState connectionState = connectionState ( ) ; connectionState . receiveFlowControlledFrame ( dataLength ) ; if ( stream ! = null & & ! isClosed ( stream ) ) { FlowState state = state ( stream ) ; state . endOfStream ( endOfStream ) ; state . receiveFlowControlledFrame ( dataLength ) ; } else if ( dataLength > <int> ) { connectionState . consumeBytes ( dataLength ) ; } } private FlowState connectionState ( ) { return connection . connectionStream ( ) . getProperty ( stateKey ) ; } private FlowState state ( Http2Stream stream ) { checkNotNull ( stream , <str> ) ; return stream . getProperty ( stateKey ) ; } private static boolean isClosed ( Http2Stream stream ) { return stream . state ( ) = = Http2Stream . State . CLOSED ; } private final class AutoRefillState extends DefaultState { public AutoRefillState ( Http2Stream stream , int initialWindowSize ) { super ( stream , initialWindowSize ) ; } @Override public void receiveFlowControlledFrame ( int dataLength ) throws Http2Exception { super . receiveFlowControlledFrame ( dataLength ) ; super . consumeBytes ( dataLength ) ; } @Override public boolean consumeBytes ( int numBytes ) throws Http2Exception { return false ; } } private class DefaultState implements FlowState { private final Http2Stream stream ; private int window ; private int processedWindow ; private int initialStreamWindowSize ; private float streamWindowUpdateRatio ; private int lowerBound ; private boolean endOfStream ; public DefaultState ( Http2Stream stream , int initialWindowSize ) { this . stream = stream ; window ( initialWindowSize ) ; streamWindowUpdateRatio = windowUpdateRatio ; } @Override public void window ( int initialWindowSize ) { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; window = processedWindow = initialStreamWindowSize = initialWindowSize ; } @Override public int windowSize ( ) { return window ; } @Override public int initialWindowSize ( ) { return initialStreamWindowSize ; } @Override public void endOfStream ( boolean endOfStream ) { this . endOfStream = endOfStream ; } @Override public float windowUpdateRatio ( ) { return streamWindowUpdateRatio ; } @Override public void windowUpdateRatio ( float ratio ) { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; streamWindowUpdateRatio = ratio ; } @Override public void incrementInitialStreamWindow ( int delta ) { int newValue = ( int ) min ( MAX_INITIAL_WINDOW_SIZE , max ( MIN_INITIAL_WINDOW_SIZE , initialStreamWindowSize + ( long ) delta ) ) ; delta = newValue - initialStreamWindowSize ; initialStreamWindowSize + = delta ; } @Override public void incrementFlowControlWindows ( int delta ) throws Http2Exception { if ( delta > <int> & & window > MAX_INITIAL_WINDOW_SIZE - delta ) { throw streamError ( stream . id ( ) , FLOW_CONTROL_ERROR , <str> , stream . id ( ) ) ; } window + = delta ; processedWindow + = delta ; lowerBound = delta < <int> ? delta : <int> ; } @Override public void receiveFlowControlledFrame ( int dataLength ) throws Http2Exception { assert dataLength > = <int> ; window - = dataLength ; if ( window < lowerBound ) { throw streamError ( stream . id ( ) , FLOW_CONTROL_ERROR , <str> , stream . id ( ) ) ; } } private void returnProcessedBytes ( int delta ) throws Http2Exception { if ( processedWindow - delta < window ) { throw streamError ( stream . id ( ) , INTERNAL_ERROR , <str> , stream . id ( ) ) ; } processedWindow - = delta ; } @Override public boolean consumeBytes ( int numBytes ) throws Http2Exception { returnProcessedBytes ( numBytes ) ; return writeWindowUpdateIfNeeded ( ) ; } @Override public int unconsumedBytes ( ) { return processedWindow - window ; } @Override public boolean writeWindowUpdateIfNeeded ( ) throws Http2Exception { if ( endOfStream | | initialStreamWindowSize < = <int> ) { return false ; } int threshold = ( int ) ( initialStreamWindowSize * streamWindowUpdateRatio ) ; if ( processedWindow < = threshold ) { writeWindowUpdate ( ) ; return true ; } return false ; } private void writeWindowUpdate ( ) throws Http2Exception { int deltaWindowSize = initialStreamWindowSize - processedWindow ; try { incrementFlowControlWindows ( deltaWindowSize ) ; } catch ( Throwable t ) { throw connectionError ( INTERNAL_ERROR , t , <str> , stream . id ( ) ) ; } frameWriter . writeWindowUpdate ( ctx , stream . id ( ) , deltaWindowSize , ctx . newPromise ( ) ) ; } } private static final FlowState REDUCED_FLOW_STATE = new FlowState ( ) { @Override public int windowSize ( ) { return <int> ; } @Override public int initialWindowSize ( ) { return <int> ; } @Override public void window ( int initialWindowSize ) { throw new UnsupportedOperationException ( ) ; } @Override public void incrementInitialStreamWindow ( int delta ) { } @Override public boolean writeWindowUpdateIfNeeded ( ) throws Http2Exception { throw new UnsupportedOperationException ( ) ; } @Override public boolean consumeBytes ( int numBytes ) throws Http2Exception { return false ; } @Override public int unconsumedBytes ( ) { return <int> ; } @Override public float windowUpdateRatio ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void windowUpdateRatio ( float ratio ) { throw new UnsupportedOperationException ( ) ; } @Override public void receiveFlowControlledFrame ( int dataLength ) throws Http2Exception { throw new UnsupportedOperationException ( ) ; } @Override public void incrementFlowControlWindows ( int delta ) throws Http2Exception { } @Override public void endOfStream ( boolean endOfStream ) { throw new UnsupportedOperationException ( ) ; } } ; private interface FlowState { int windowSize ( ) ; int initialWindowSize ( ) ; void window ( int initialWindowSize ) ; void incrementInitialStreamWindow ( int delta ) ; boolean writeWindowUpdateIfNeeded ( ) throws Http2Exception ; boolean consumeBytes ( int numBytes ) throws Http2Exception ; int unconsumedBytes ( ) ; float windowUpdateRatio ( ) ; void windowUpdateRatio ( float ratio ) ; void receiveFlowControlledFrame ( int dataLength ) throws Http2Exception ; void incrementFlowControlWindows ( int delta ) throws Http2Exception ; void endOfStream ( boolean endOfStream ) ; } private final class WindowUpdateVisitor implements Http2StreamVisitor { private CompositeStreamException compositeException ; private final int delta ; public WindowUpdateVisitor ( int delta ) { this . delta = delta ; } @Override public boolean visit ( Http2Stream stream ) throws Http2Exception { try { FlowState state = state ( stream ) ; state . incrementFlowControlWindows ( delta ) ; state . incrementInitialStreamWindow ( delta ) ; } catch ( StreamException e ) { if ( compositeException = = null ) { compositeException = new CompositeStreamException ( e . error ( ) , <int> ) ; } compositeException . add ( e ) ; } return true ; } public void throwIfError ( ) throws CompositeStreamException { if ( compositeException ! = null ) { throw compositeException ; } } } } 
