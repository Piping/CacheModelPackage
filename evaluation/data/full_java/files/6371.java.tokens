package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . miscellaneous . StemmerOverrideFilter ; import org . apache . lucene . analysis . miscellaneous . StemmerOverrideFilter . StemmerOverrideMap ; import org . elasticsearch . common . Strings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexSettings ; import java . io . IOException ; import java . util . List ; public class StemmerOverrideTokenFilterFactory extends AbstractTokenFilterFactory { private final StemmerOverrideMap overrideMap ; public StemmerOverrideTokenFilterFactory ( IndexSettings indexSettings , Environment env , String name , Settings settings ) throws IOException { super ( indexSettings , name , settings ) ; List < String > rules = Analysis . getWordList ( env , settings , <str> ) ; if ( rules = = null ) { throw new IllegalArgumentException ( <str> ) ; } StemmerOverrideFilter . Builder builder = new StemmerOverrideFilter . Builder ( false ) ; parseRules ( rules , builder , <str> ) ; overrideMap = builder . build ( ) ; } @Override public TokenStream create ( TokenStream tokenStream ) { return new StemmerOverrideFilter ( tokenStream , overrideMap ) ; } static void parseRules ( List < String > rules , StemmerOverrideFilter . Builder builder , String mappingSep ) { for ( String rule : rules ) { String key , override ; List < String > mapping = Strings . splitSmart ( rule , mappingSep , false ) ; if ( mapping . size ( ) = = <int> ) { key = mapping . get ( <int> ) . trim ( ) ; override = mapping . get ( <int> ) . trim ( ) ; } else { throw new RuntimeException ( <str> + rule ) ; } if ( key . isEmpty ( ) | | override . isEmpty ( ) ) { throw new RuntimeException ( <str> + rule ) ; } else { builder . add ( key , override ) ; } } } } 
