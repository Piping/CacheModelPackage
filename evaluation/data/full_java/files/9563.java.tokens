package com . google . common . util . concurrent ; import static java . lang . Math . min ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . math . LongMath ; import java . util . concurrent . TimeUnit ; abstract class SmoothRateLimiter extends RateLimiter { static final class SmoothWarmingUp extends SmoothRateLimiter { private final long warmupPeriodMicros ; private double slope ; private double thresholdPermits ; private double coldFactor ; SmoothWarmingUp ( SleepingStopwatch stopwatch , long warmupPeriod , TimeUnit timeUnit , double coldFactor ) { super ( stopwatch ) ; this . warmupPeriodMicros = timeUnit . toMicros ( warmupPeriod ) ; this . coldFactor = coldFactor ; } @Override void doSetRate ( double permitsPerSecond , double stableIntervalMicros ) { double oldMaxPermits = maxPermits ; double coldIntervalMicros = stableIntervalMicros * coldFactor ; thresholdPermits = <float> * warmupPeriodMicros / stableIntervalMicros ; maxPermits = thresholdPermits + <float> * warmupPeriodMicros / ( stableIntervalMicros + coldIntervalMicros ) ; slope = ( coldIntervalMicros - stableIntervalMicros ) / ( maxPermits - thresholdPermits ) ; if ( oldMaxPermits = = Double . POSITIVE_INFINITY ) { storedPermits = <float> ; } else { storedPermits = ( oldMaxPermits = = <float> ) ? maxPermits : storedPermits * maxPermits / oldMaxPermits ; } } @Override long storedPermitsToWaitTime ( double storedPermits , double permitsToTake ) { double availablePermitsAboveThreshold = storedPermits - thresholdPermits ; long micros = <int> ; if ( availablePermitsAboveThreshold > <float> ) { double permitsAboveThresholdToTake = min ( availablePermitsAboveThreshold , permitsToTake ) ; micros = ( long ) ( permitsAboveThresholdToTake * ( permitsToTime ( availablePermitsAboveThreshold ) + permitsToTime ( availablePermitsAboveThreshold - permitsAboveThresholdToTake ) ) / <float> ) ; permitsToTake - = permitsAboveThresholdToTake ; } micros + = ( stableIntervalMicros * permitsToTake ) ; return micros ; } private double permitsToTime ( double permits ) { return stableIntervalMicros + permits * slope ; } @Override double coolDownIntervalMicros ( ) { return warmupPeriodMicros / maxPermits ; } } static final class SmoothBursty extends SmoothRateLimiter { final double maxBurstSeconds ; SmoothBursty ( SleepingStopwatch stopwatch , double maxBurstSeconds ) { super ( stopwatch ) ; this . maxBurstSeconds = maxBurstSeconds ; } @Override void doSetRate ( double permitsPerSecond , double stableIntervalMicros ) { double oldMaxPermits = this . maxPermits ; maxPermits = maxBurstSeconds * permitsPerSecond ; if ( oldMaxPermits = = Double . POSITIVE_INFINITY ) { storedPermits = maxPermits ; } else { storedPermits = ( oldMaxPermits = = <float> ) ? <float> : storedPermits * maxPermits / oldMaxPermits ; } } @Override long storedPermitsToWaitTime ( double storedPermits , double permitsToTake ) { return <int> L ; } @Override double coolDownIntervalMicros ( ) { return stableIntervalMicros ; } } double storedPermits ; double maxPermits ; double stableIntervalMicros ; private long nextFreeTicketMicros = <int> L ; private SmoothRateLimiter ( SleepingStopwatch stopwatch ) { super ( stopwatch ) ; } @Override final void doSetRate ( double permitsPerSecond , long nowMicros ) { resync ( nowMicros ) ; double stableIntervalMicros = SECONDS . toMicros ( <int> ) / permitsPerSecond ; this . stableIntervalMicros = stableIntervalMicros ; doSetRate ( permitsPerSecond , stableIntervalMicros ) ; } abstract void doSetRate ( double permitsPerSecond , double stableIntervalMicros ) ; @Override final double doGetRate ( ) { return SECONDS . toMicros ( <int> ) / stableIntervalMicros ; } @Override final long queryEarliestAvailable ( long nowMicros ) { return nextFreeTicketMicros ; } @Override final long reserveEarliestAvailable ( int requiredPermits , long nowMicros ) { resync ( nowMicros ) ; long returnValue = nextFreeTicketMicros ; double storedPermitsToSpend = min ( requiredPermits , this . storedPermits ) ; double freshPermits = requiredPermits - storedPermitsToSpend ; long waitMicros = storedPermitsToWaitTime ( this . storedPermits , storedPermitsToSpend ) + ( long ) ( freshPermits * stableIntervalMicros ) ; try { this . nextFreeTicketMicros = LongMath . checkedAdd ( nextFreeTicketMicros , waitMicros ) ; } catch ( ArithmeticException e ) { this . nextFreeTicketMicros = Long . MAX_VALUE ; } this . storedPermits - = storedPermitsToSpend ; return returnValue ; } abstract long storedPermitsToWaitTime ( double storedPermits , double permitsToTake ) ; abstract double coolDownIntervalMicros ( ) ; void resync ( long nowMicros ) { if ( nowMicros > nextFreeTicketMicros ) { storedPermits = min ( maxPermits , storedPermits + ( nowMicros - nextFreeTicketMicros ) / coolDownIntervalMicros ( ) ) ; nextFreeTicketMicros = nowMicros ; } } } 
