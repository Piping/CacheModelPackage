package com . badlogic . gdx . math ; import java . io . Serializable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . NumberUtils ; public class Vector2 implements Serializable , Vector < Vector2 > { private static final long serialVersionUID = <int> ; public final static Vector2 X = new Vector2 ( <int> , <int> ) ; public final static Vector2 Y = new Vector2 ( <int> , <int> ) ; public final static Vector2 Zero = new Vector2 ( <int> , <int> ) ; public float x ; public float y ; public Vector2 ( ) { } public Vector2 ( float x , float y ) { this . x = x ; this . y = y ; } public Vector2 ( Vector2 v ) { set ( v ) ; } @Override public Vector2 cpy ( ) { return new Vector2 ( this ) ; } public static float len ( float x , float y ) { return ( float ) Math . sqrt ( x * x + y * y ) ; } @Override public float len ( ) { return ( float ) Math . sqrt ( x * x + y * y ) ; } public static float len2 ( float x , float y ) { return x * x + y * y ; } @Override public float len2 ( ) { return x * x + y * y ; } @Override public Vector2 set ( Vector2 v ) { x = v . x ; y = v . y ; return this ; } public Vector2 set ( float x , float y ) { this . x = x ; this . y = y ; return this ; } @Override public Vector2 sub ( Vector2 v ) { x - = v . x ; y - = v . y ; return this ; } public Vector2 sub ( float x , float y ) { this . x - = x ; this . y - = y ; return this ; } @Override public Vector2 nor ( ) { float len = len ( ) ; if ( len ! = <int> ) { x / = len ; y / = len ; } return this ; } @Override public Vector2 add ( Vector2 v ) { x + = v . x ; y + = v . y ; return this ; } public Vector2 add ( float x , float y ) { this . x + = x ; this . y + = y ; return this ; } public static float dot ( float x1 , float y1 , float x2 , float y2 ) { return x1 * x2 + y1 * y2 ; } @Override public float dot ( Vector2 v ) { return x * v . x + y * v . y ; } public float dot ( float ox , float oy ) { return x * ox + y * oy ; } @Override public Vector2 scl ( float scalar ) { x * = scalar ; y * = scalar ; return this ; } public Vector2 scl ( float x , float y ) { this . x * = x ; this . y * = y ; return this ; } @Override public Vector2 scl ( Vector2 v ) { this . x * = v . x ; this . y * = v . y ; return this ; } @Override public Vector2 mulAdd ( Vector2 vec , float scalar ) { this . x + = vec . x * scalar ; this . y + = vec . y * scalar ; return this ; } @Override public Vector2 mulAdd ( Vector2 vec , Vector2 mulVec ) { this . x + = vec . x * mulVec . x ; this . y + = vec . y * mulVec . y ; return this ; } public static float dst ( float x1 , float y1 , float x2 , float y2 ) { final float x_d = x2 - x1 ; final float y_d = y2 - y1 ; return ( float ) Math . sqrt ( x_d * x_d + y_d * y_d ) ; } @Override public float dst ( Vector2 v ) { final float x_d = v . x - x ; final float y_d = v . y - y ; return ( float ) Math . sqrt ( x_d * x_d + y_d * y_d ) ; } public float dst ( float x , float y ) { final float x_d = x - this . x ; final float y_d = y - this . y ; return ( float ) Math . sqrt ( x_d * x_d + y_d * y_d ) ; } public static float dst2 ( float x1 , float y1 , float x2 , float y2 ) { final float x_d = x2 - x1 ; final float y_d = y2 - y1 ; return x_d * x_d + y_d * y_d ; } @Override public float dst2 ( Vector2 v ) { final float x_d = v . x - x ; final float y_d = v . y - y ; return x_d * x_d + y_d * y_d ; } public float dst2 ( float x , float y ) { final float x_d = x - this . x ; final float y_d = y - this . y ; return x_d * x_d + y_d * y_d ; } @Override public Vector2 limit ( float limit ) { return limit2 ( limit * limit ) ; } @Override public Vector2 limit2 ( float limit2 ) { float len2 = len2 ( ) ; if ( len2 > limit2 ) { return scl ( ( float ) Math . sqrt ( limit2 / len2 ) ) ; } return this ; } @Override public Vector2 clamp ( float min , float max ) { final float len2 = len2 ( ) ; if ( len2 = = <float> ) return this ; float max2 = max * max ; if ( len2 > max2 ) return scl ( ( float ) Math . sqrt ( max2 / len2 ) ) ; float min2 = min * min ; if ( len2 < min2 ) return scl ( ( float ) Math . sqrt ( min2 / len2 ) ) ; return this ; } @Override public Vector2 setLength ( float len ) { return setLength2 ( len * len ) ; } @Override public Vector2 setLength2 ( float len2 ) { float oldLen2 = len2 ( ) ; return ( oldLen2 = = <int> | | oldLen2 = = len2 ) ? this : scl ( ( float ) Math . sqrt ( len2 / oldLen2 ) ) ; } @Override public String toString ( ) { return <str> + x + <str> + y + <str> ; } public Vector2 fromString ( String v ) { int s = v . indexOf ( <str> , <int> ) ; if ( s ! = - <int> & & v . charAt ( <int> ) = = <str> & & v . charAt ( v . length ( ) - <int> ) = = <str> ) { try { float x = Float . parseFloat ( v . substring ( <int> , s ) ) ; float y = Float . parseFloat ( v . substring ( s + <int> , v . length ( ) - <int> ) ) ; return this . set ( x , y ) ; } catch ( NumberFormatException ex ) { } } throw new GdxRuntimeException ( <str> + v ) ; } public Vector2 mul ( Matrix3 mat ) { float x = this . x * mat . val [ <int> ] + this . y * mat . val [ <int> ] + mat . val [ <int> ] ; float y = this . x * mat . val [ <int> ] + this . y * mat . val [ <int> ] + mat . val [ <int> ] ; this . x = x ; this . y = y ; return this ; } public float crs ( Vector2 v ) { return this . x * v . y - this . y * v . x ; } public float crs ( float x , float y ) { return this . x * y - this . y * x ; } public float angle ( ) { float angle = ( float ) Math . atan2 ( y , x ) * MathUtils . radiansToDegrees ; if ( angle < <int> ) angle + = <int> ; return angle ; } public float angle ( Vector2 reference ) { return ( float ) Math . atan2 ( crs ( reference ) , dot ( reference ) ) * MathUtils . radiansToDegrees ; } public float angleRad ( ) { return ( float ) Math . atan2 ( y , x ) ; } public float angleRad ( Vector2 reference ) { return ( float ) Math . atan2 ( crs ( reference ) , dot ( reference ) ) ; } public Vector2 setAngle ( float degrees ) { return setAngleRad ( degrees * MathUtils . degreesToRadians ) ; } public Vector2 setAngleRad ( float radians ) { this . set ( len ( ) , <float> ) ; this . rotateRad ( radians ) ; return this ; } public Vector2 rotate ( float degrees ) { return rotateRad ( degrees * MathUtils . degreesToRadians ) ; } public Vector2 rotateRad ( float radians ) { float cos = ( float ) Math . cos ( radians ) ; float sin = ( float ) Math . sin ( radians ) ; float newX = this . x * cos - this . y * sin ; float newY = this . x * sin + this . y * cos ; this . x = newX ; this . y = newY ; return this ; } public Vector2 rotate90 ( int dir ) { float x = this . x ; if ( dir > = <int> ) { this . x = - y ; y = x ; } else { this . x = y ; y = - x ; } return this ; } @Override public Vector2 lerp ( Vector2 target , float alpha ) { final float invAlpha = <float> - alpha ; this . x = ( x * invAlpha ) + ( target . x * alpha ) ; this . y = ( y * invAlpha ) + ( target . y * alpha ) ; return this ; } @Override public Vector2 interpolate ( Vector2 target , float alpha , Interpolation interpolation ) { return lerp ( target , interpolation . apply ( alpha ) ) ; } @Override public Vector2 setToRandomDirection ( ) { float theta = MathUtils . random ( <float> , MathUtils . PI2 ) ; return this . set ( MathUtils . cos ( theta ) , MathUtils . sin ( theta ) ) ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + NumberUtils . floatToIntBits ( x ) ; result = prime * result + NumberUtils . floatToIntBits ( y ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Vector2 other = ( Vector2 ) obj ; if ( NumberUtils . floatToIntBits ( x ) ! = NumberUtils . floatToIntBits ( other . x ) ) return false ; if ( NumberUtils . floatToIntBits ( y ) ! = NumberUtils . floatToIntBits ( other . y ) ) return false ; return true ; } @Override public boolean epsilonEquals ( Vector2 other , float epsilon ) { if ( other = = null ) return false ; if ( Math . abs ( other . x - x ) > epsilon ) return false ; if ( Math . abs ( other . y - y ) > epsilon ) return false ; return true ; } public boolean epsilonEquals ( float x , float y , float epsilon ) { if ( Math . abs ( x - this . x ) > epsilon ) return false ; if ( Math . abs ( y - this . y ) > epsilon ) return false ; return true ; } @Override public boolean isUnit ( ) { return isUnit ( <float> ) ; } @Override public boolean isUnit ( final float margin ) { return Math . abs ( len2 ( ) - <float> ) < margin ; } @Override public boolean isZero ( ) { return x = = <int> & & y = = <int> ; } @Override public boolean isZero ( final float margin ) { return len2 ( ) < margin ; } @Override public boolean isOnLine ( Vector2 other ) { return MathUtils . isZero ( x * other . y - y * other . x ) ; } @Override public boolean isOnLine ( Vector2 other , float epsilon ) { return MathUtils . isZero ( x * other . y - y * other . x , epsilon ) ; } @Override public boolean isCollinear ( Vector2 other , float epsilon ) { return isOnLine ( other , epsilon ) & & dot ( other ) > <float> ; } @Override public boolean isCollinear ( Vector2 other ) { return isOnLine ( other ) & & dot ( other ) > <float> ; } @Override public boolean isCollinearOpposite ( Vector2 other , float epsilon ) { return isOnLine ( other , epsilon ) & & dot ( other ) < <float> ; } @Override public boolean isCollinearOpposite ( Vector2 other ) { return isOnLine ( other ) & & dot ( other ) < <float> ; } @Override public boolean isPerpendicular ( Vector2 vector ) { return MathUtils . isZero ( dot ( vector ) ) ; } @Override public boolean isPerpendicular ( Vector2 vector , float epsilon ) { return MathUtils . isZero ( dot ( vector ) , epsilon ) ; } @Override public boolean hasSameDirection ( Vector2 vector ) { return dot ( vector ) > <int> ; } @Override public boolean hasOppositeDirection ( Vector2 vector ) { return dot ( vector ) < <int> ; } @Override public Vector2 setZero ( ) { this . x = <int> ; this . y = <int> ; return this ; } } 
