package org . elasticsearch . script . expression ; import org . apache . lucene . expressions . Bindings ; import org . apache . lucene . expressions . Expression ; import org . apache . lucene . expressions . SimpleBindings ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . queries . function . FunctionValues ; import org . apache . lucene . queries . function . ValueSource ; import org . apache . lucene . search . Scorer ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . LeafSearchScript ; import org . elasticsearch . script . ScriptException ; import org . elasticsearch . script . SearchScript ; import java . io . IOException ; import java . util . Collections ; import java . util . Map ; class ExpressionSearchScript implements SearchScript { final CompiledScript compiledScript ; final SimpleBindings bindings ; final ValueSource source ; final ReplaceableConstValueSource specialValue ; final boolean needsScores ; Scorer scorer ; int docid ; ExpressionSearchScript ( CompiledScript c , SimpleBindings b , ReplaceableConstValueSource v , boolean needsScores ) { compiledScript = c ; bindings = b ; source = ( ( Expression ) compiledScript . compiled ( ) ) . getValueSource ( bindings ) ; specialValue = v ; this . needsScores = needsScores ; } @Override public boolean needsScores ( ) { return needsScores ; } @Override public LeafSearchScript getLeafSearchScript ( final LeafReaderContext leaf ) throws IOException { return new LeafSearchScript ( ) { FunctionValues values = source . getValues ( Collections . singletonMap ( <str> , Lucene . illegalScorer ( <str> ) ) , leaf ) ; double evaluate ( ) { try { return values . doubleVal ( docid ) ; } catch ( Exception exception ) { throw new ScriptException ( <str> + compiledScript , exception ) ; } } @Override public Object run ( ) { return new Double ( evaluate ( ) ) ; } @Override public float runAsFloat ( ) { return ( float ) evaluate ( ) ; } @Override public long runAsLong ( ) { return ( long ) evaluate ( ) ; } @Override public double runAsDouble ( ) { return evaluate ( ) ; } @Override public Object unwrap ( Object value ) { return value ; } @Override public void setDocument ( int d ) { docid = d ; } @Override public void setScorer ( Scorer s ) { scorer = s ; try { values = source . getValues ( Collections . singletonMap ( <str> , scorer ) , leaf ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> + compiledScript , e ) ; } } @Override public void setSource ( Map < String , Object > source ) { } @Override public void setNextVar ( String name , Object value ) { assert ( specialValue ! = null ) ; assert ( name . equals ( <str> ) ) ; if ( value instanceof Number ) { specialValue . setValue ( ( ( Number ) value ) . doubleValue ( ) ) ; } else { throw new ScriptException ( <str> + compiledScript ) ; } } } ; } } 
