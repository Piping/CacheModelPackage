package com . badlogic . gdx . utils ; import java . util . Arrays ; public class StringBuilder implements Appendable , CharSequence { static final int INITIAL_CAPACITY = <int> ; public char [ ] chars ; public int length ; private static final char [ ] digits = new char [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public static int numChars ( int value , int radix ) { int result = ( value < <int> ) ? <int> : <int> ; while ( ( value / = radix ) ! = <int> ) + + result ; return result ; } public static int numChars ( long value , int radix ) { int result = ( value < <int> ) ? <int> : <int> ; while ( ( value / = radix ) ! = <int> ) + + result ; return result ; } final char [ ] getValue ( ) { return chars ; } public StringBuilder ( ) { chars = new char [ INITIAL_CAPACITY ] ; } public StringBuilder ( int capacity ) { if ( capacity < <int> ) { throw new NegativeArraySizeException ( ) ; } chars = new char [ capacity ] ; } public StringBuilder ( CharSequence seq ) { this ( seq . toString ( ) ) ; } public StringBuilder ( StringBuilder builder ) { length = builder . length ; chars = new char [ length + INITIAL_CAPACITY ] ; System . arraycopy ( builder . chars , <int> , chars , <int> , length ) ; } public StringBuilder ( String string ) { length = string . length ( ) ; chars = new char [ length + INITIAL_CAPACITY ] ; string . getChars ( <int> , length , chars , <int> ) ; } private void enlargeBuffer ( int min ) { int newSize = ( chars . length > > <int> ) + chars . length + <int> ; char [ ] newData = new char [ min > newSize ? min : newSize ] ; System . arraycopy ( chars , <int> , newData , <int> , length ) ; chars = newData ; } final void appendNull ( ) { int newSize = length + <int> ; if ( newSize > chars . length ) { enlargeBuffer ( newSize ) ; } chars [ length + + ] = <str> ; chars [ length + + ] = <str> ; chars [ length + + ] = <str> ; chars [ length + + ] = <str> ; } final void append0 ( char [ ] value ) { int newSize = length + value . length ; if ( newSize > chars . length ) { enlargeBuffer ( newSize ) ; } System . arraycopy ( value , <int> , chars , length , value . length ) ; length = newSize ; } final void append0 ( char [ ] value , int offset , int length ) { if ( offset > value . length | | offset < <int> ) { throw new ArrayIndexOutOfBoundsException ( <str> + offset ) ; } if ( length < <int> | | value . length - offset < length ) { throw new ArrayIndexOutOfBoundsException ( <str> + length ) ; } int newSize = this . length + length ; if ( newSize > chars . length ) { enlargeBuffer ( newSize ) ; } System . arraycopy ( value , offset , chars , this . length , length ) ; this . length = newSize ; } final void append0 ( char ch ) { if ( length = = chars . length ) { enlargeBuffer ( length + <int> ) ; } chars [ length + + ] = ch ; } final void append0 ( String string ) { if ( string = = null ) { appendNull ( ) ; return ; } int adding = string . length ( ) ; int newSize = length + adding ; if ( newSize > chars . length ) { enlargeBuffer ( newSize ) ; } string . getChars ( <int> , adding , chars , length ) ; length = newSize ; } final void append0 ( CharSequence s , int start , int end ) { if ( s = = null ) { s = <str> ; } if ( start < <int> | | end < <int> | | start > end | | end > s . length ( ) ) { throw new IndexOutOfBoundsException ( ) ; } append0 ( s . subSequence ( start , end ) . toString ( ) ) ; } public int capacity ( ) { return chars . length ; } public char charAt ( int index ) { if ( index < <int> | | index > = length ) { throw new StringIndexOutOfBoundsException ( index ) ; } return chars [ index ] ; } final void delete0 ( int start , int end ) { if ( start > = <int> ) { if ( end > length ) { end = length ; } if ( end = = start ) { return ; } if ( end > start ) { int count = length - end ; if ( count > = <int> ) System . arraycopy ( chars , end , chars , start , count ) ; length - = end - start ; return ; } } throw new StringIndexOutOfBoundsException ( ) ; } final void deleteCharAt0 ( int location ) { if ( <int> > location | | location > = length ) { throw new StringIndexOutOfBoundsException ( location ) ; } int count = length - location - <int> ; if ( count > <int> ) { System . arraycopy ( chars , location + <int> , chars , location , count ) ; } length - - ; } public void ensureCapacity ( int min ) { if ( min > chars . length ) { int twice = ( chars . length < < <int> ) + <int> ; enlargeBuffer ( twice > min ? twice : min ) ; } } public void getChars ( int start , int end , char [ ] dest , int destStart ) { if ( start > length | | end > length | | start > end ) { throw new StringIndexOutOfBoundsException ( ) ; } System . arraycopy ( chars , start , dest , destStart , end - start ) ; } final void insert0 ( int index , char [ ] value ) { if ( <int> > index | | index > length ) { throw new StringIndexOutOfBoundsException ( index ) ; } if ( value . length ! = <int> ) { move ( value . length , index ) ; System . arraycopy ( value , <int> , value , index , value . length ) ; length + = value . length ; } } final void insert0 ( int index , char [ ] value , int start , int length ) { if ( <int> < = index & & index < = length ) { if ( start > = <int> & & <int> < = length & & length < = value . length - start ) { if ( length ! = <int> ) { move ( length , index ) ; System . arraycopy ( value , start , chars , index , length ) ; this . length + = length ; } return ; } throw new StringIndexOutOfBoundsException ( <str> + start + <str> + length + <str> + value . length ) ; } throw new StringIndexOutOfBoundsException ( index ) ; } final void insert0 ( int index , char ch ) { if ( <int> > index | | index > length ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } move ( <int> , index ) ; chars [ index ] = ch ; length + + ; } final void insert0 ( int index , String string ) { if ( <int> < = index & & index < = length ) { if ( string = = null ) { string = <str> ; } int min = string . length ( ) ; if ( min ! = <int> ) { move ( min , index ) ; string . getChars ( <int> , min , chars , index ) ; length + = min ; } } else { throw new StringIndexOutOfBoundsException ( index ) ; } } final void insert0 ( int index , CharSequence s , int start , int end ) { if ( s = = null ) { s = <str> ; } if ( index < <int> | | index > length | | start < <int> | | end < <int> | | start > end | | end > s . length ( ) ) { throw new IndexOutOfBoundsException ( ) ; } insert0 ( index , s . subSequence ( start , end ) . toString ( ) ) ; } public int length ( ) { return length ; } private void move ( int size , int index ) { if ( chars . length - length > = size ) { System . arraycopy ( chars , index , chars , index + size , length - index ) ; return ; } int a = length + size , b = ( chars . length < < <int> ) + <int> ; int newSize = a > b ? a : b ; char [ ] newData = new char [ newSize ] ; System . arraycopy ( chars , <int> , newData , <int> , index ) ; System . arraycopy ( chars , index , newData , index + size , length - index ) ; chars = newData ; } final void replace0 ( int start , int end , String string ) { if ( start > = <int> ) { if ( end > length ) { end = length ; } if ( end > start ) { int stringLength = string . length ( ) ; int diff = end - start - stringLength ; if ( diff > <int> ) { System . arraycopy ( chars , end , chars , start + stringLength , length - end ) ; } else if ( diff < <int> ) { move ( - diff , end ) ; } string . getChars ( <int> , stringLength , chars , start ) ; length - = diff ; return ; } if ( start = = end ) { if ( string = = null ) { throw new NullPointerException ( ) ; } insert0 ( start , string ) ; return ; } } throw new StringIndexOutOfBoundsException ( ) ; } final void reverse0 ( ) { if ( length < <int> ) { return ; } int end = length - <int> ; char frontHigh = chars [ <int> ] ; char endLow = chars [ end ] ; boolean allowFrontSur = true , allowEndSur = true ; for ( int i = <int> , mid = length / <int> ; i < mid ; i + + , - - end ) { char frontLow = chars [ i + <int> ] ; char endHigh = chars [ end - <int> ] ; boolean surAtFront = allowFrontSur & & frontLow > = <hex> & & frontLow < = <hex> & & frontHigh > = <hex> & & frontHigh < = <hex> ; if ( surAtFront & & length < <int> ) { return ; } boolean surAtEnd = allowEndSur & & endHigh > = <hex> & & endHigh < = <hex> & & endLow > = <hex> & & endLow < = <hex> ; allowFrontSur = allowEndSur = true ; if ( surAtFront = = surAtEnd ) { if ( surAtFront ) { chars [ end ] = frontLow ; chars [ end - <int> ] = frontHigh ; chars [ i ] = endHigh ; chars [ i + <int> ] = endLow ; frontHigh = chars [ i + <int> ] ; endLow = chars [ end - <int> ] ; i + + ; end - - ; } else { chars [ end ] = frontHigh ; chars [ i ] = endLow ; frontHigh = frontLow ; endLow = endHigh ; } } else { if ( surAtFront ) { chars [ end ] = frontLow ; chars [ i ] = endLow ; endLow = endHigh ; allowFrontSur = false ; } else { chars [ end ] = frontHigh ; chars [ i ] = endHigh ; frontHigh = frontLow ; allowEndSur = false ; } } } if ( ( length & <int> ) = = <int> & & ( ! allowFrontSur | | ! allowEndSur ) ) { chars [ end ] = allowFrontSur ? endLow : frontHigh ; } } public void setCharAt ( int index , char ch ) { if ( <int> > index | | index > = length ) { throw new StringIndexOutOfBoundsException ( index ) ; } chars [ index ] = ch ; } public void setLength ( int newLength ) { if ( newLength < <int> ) { throw new StringIndexOutOfBoundsException ( newLength ) ; } if ( newLength > chars . length ) { enlargeBuffer ( newLength ) ; } else { if ( length < newLength ) { Arrays . fill ( chars , length , newLength , ( char ) <int> ) ; } } length = newLength ; } public String substring ( int start ) { if ( <int> < = start & & start < = length ) { if ( start = = length ) { return <str> ; } return new String ( chars , start , length - start ) ; } throw new StringIndexOutOfBoundsException ( start ) ; } public String substring ( int start , int end ) { if ( <int> < = start & & start < = end & & end < = length ) { if ( start = = end ) { return <str> ; } return new String ( chars , start , end - start ) ; } throw new StringIndexOutOfBoundsException ( ) ; } @Override public String toString ( ) { if ( length = = <int> ) return <str> ; return new String ( chars , <int> , length ) ; } public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; } public int indexOf ( String string ) { return indexOf ( string , <int> ) ; } public int indexOf ( String subString , int start ) { if ( start < <int> ) { start = <int> ; } int subCount = subString . length ( ) ; if ( subCount > <int> ) { if ( subCount + start > length ) { return - <int> ; } char firstChar = subString . charAt ( <int> ) ; while ( true ) { int i = start ; boolean found = false ; for ( ; i < length ; i + + ) { if ( chars [ i ] = = firstChar ) { found = true ; break ; } } if ( ! found | | subCount + i > length ) { return - <int> ; } int o1 = i , o2 = <int> ; while ( + + o2 < subCount & & chars [ + + o1 ] = = subString . charAt ( o2 ) ) { } if ( o2 = = subCount ) { return i ; } start = i + <int> ; } } return start < length | | start = = <int> ? start : length ; } public int lastIndexOf ( String string ) { return lastIndexOf ( string , length ) ; } public int lastIndexOf ( String subString , int start ) { int subCount = subString . length ( ) ; if ( subCount < = length & & start > = <int> ) { if ( subCount > <int> ) { if ( start > length - subCount ) { start = length - subCount ; } char firstChar = subString . charAt ( <int> ) ; while ( true ) { int i = start ; boolean found = false ; for ( ; i > = <int> ; - - i ) { if ( chars [ i ] = = firstChar ) { found = true ; break ; } } if ( ! found ) { return - <int> ; } int o1 = i , o2 = <int> ; while ( + + o2 < subCount & & chars [ + + o1 ] = = subString . charAt ( o2 ) ) { } if ( o2 = = subCount ) { return i ; } start = i - <int> ; } } return start < length ? start : length ; } return - <int> ; } public void trimToSize ( ) { if ( length < chars . length ) { char [ ] newValue = new char [ length ] ; System . arraycopy ( chars , <int> , newValue , <int> , length ) ; chars = newValue ; } } public int codePointAt ( int index ) { if ( index < <int> | | index > = length ) { throw new StringIndexOutOfBoundsException ( index ) ; } return Character . codePointAt ( chars , index , length ) ; } public int codePointBefore ( int index ) { if ( index < <int> | | index > length ) { throw new StringIndexOutOfBoundsException ( index ) ; } return Character . codePointBefore ( chars , index ) ; } public int codePointCount ( int beginIndex , int endIndex ) { if ( beginIndex < <int> | | endIndex > length | | beginIndex > endIndex ) { throw new StringIndexOutOfBoundsException ( ) ; } return Character . codePointCount ( chars , beginIndex , endIndex - beginIndex ) ; } public int offsetByCodePoints ( int index , int codePointOffset ) { return Character . offsetByCodePoints ( chars , <int> , length , index , codePointOffset ) ; } public StringBuilder append ( boolean b ) { append0 ( b ? <str> : <str> ) ; return this ; } public StringBuilder append ( char c ) { append0 ( c ) ; return this ; } public StringBuilder append ( int value ) { return append ( value , <int> ) ; } public StringBuilder append ( int value , int minLength ) { return append ( value , minLength , <str> ) ; } public StringBuilder append ( int value , final int minLength , final char prefix ) { if ( value = = Integer . MIN_VALUE ) { append0 ( <str> ) ; return this ; } if ( value < <int> ) { append0 ( <str> ) ; value = - value ; } if ( minLength > <int> ) { for ( int j = minLength - numChars ( value , <int> ) ; j > <int> ; - - j ) append ( prefix ) ; } if ( value > = <int> ) { if ( value > = <int> ) append0 ( digits [ ( int ) ( ( long ) value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; append0 ( digits [ value % <int> / <int> ] ) ; } if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; if ( value > = <int> ) append0 ( digits [ value % <int> / <int> ] ) ; append0 ( digits [ value % <int> ] ) ; return this ; } public StringBuilder append ( long value ) { return append ( value , <int> ) ; } public StringBuilder append ( long value , int minLength ) { return append ( value , minLength , <str> ) ; } public StringBuilder append ( long value , int minLength , char prefix ) { if ( value = = Long . MIN_VALUE ) { append0 ( <str> ) ; return this ; } if ( value < <int> L ) { append0 ( <str> ) ; value = - value ; } if ( minLength > <int> ) { for ( int j = minLength - numChars ( value , <int> ) ; j > <int> ; - - j ) append ( prefix ) ; } if ( value > = <int> ) { if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> D / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; } if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; if ( value > = <int> ) append0 ( digits [ ( int ) ( value % <int> / <int> ) ] ) ; append0 ( digits [ ( int ) ( value % <int> ) ] ) ; return this ; } public StringBuilder append ( float f ) { append0 ( Float . toString ( f ) ) ; return this ; } public StringBuilder append ( double d ) { append0 ( Double . toString ( d ) ) ; return this ; } public StringBuilder append ( Object obj ) { if ( obj = = null ) { appendNull ( ) ; } else { append0 ( obj . toString ( ) ) ; } return this ; } public StringBuilder append ( String str ) { append0 ( str ) ; return this ; } public StringBuilder append ( char [ ] ch ) { append0 ( ch ) ; return this ; } public StringBuilder append ( char [ ] str , int offset , int len ) { append0 ( str , offset , len ) ; return this ; } public StringBuilder append ( CharSequence csq ) { if ( csq = = null ) { appendNull ( ) ; } else if ( csq instanceof StringBuilder ) { StringBuilder builder = ( StringBuilder ) csq ; append0 ( builder . chars , <int> , builder . length ) ; } else { append0 ( csq . toString ( ) ) ; } return this ; } public StringBuilder append ( StringBuilder builder ) { if ( builder = = null ) appendNull ( ) ; else append0 ( builder . chars , <int> , builder . length ) ; return this ; } public StringBuilder append ( CharSequence csq , int start , int end ) { append0 ( csq , start , end ) ; return this ; } public StringBuilder append ( StringBuilder builder , int start , int end ) { if ( builder = = null ) appendNull ( ) ; else append0 ( builder . chars , start , end ) ; return this ; } public StringBuilder appendCodePoint ( int codePoint ) { append0 ( Character . toChars ( codePoint ) ) ; return this ; } public StringBuilder delete ( int start , int end ) { delete0 ( start , end ) ; return this ; } public StringBuilder deleteCharAt ( int index ) { deleteCharAt0 ( index ) ; return this ; } public StringBuilder insert ( int offset , boolean b ) { insert0 ( offset , b ? <str> : <str> ) ; return this ; } public StringBuilder insert ( int offset , char c ) { insert0 ( offset , c ) ; return this ; } public StringBuilder insert ( int offset , int i ) { insert0 ( offset , Integer . toString ( i ) ) ; return this ; } public StringBuilder insert ( int offset , long l ) { insert0 ( offset , Long . toString ( l ) ) ; return this ; } public StringBuilder insert ( int offset , float f ) { insert0 ( offset , Float . toString ( f ) ) ; return this ; } public StringBuilder insert ( int offset , double d ) { insert0 ( offset , Double . toString ( d ) ) ; return this ; } public StringBuilder insert ( int offset , Object obj ) { insert0 ( offset , obj = = null ? <str> : obj . toString ( ) ) ; return this ; } public StringBuilder insert ( int offset , String str ) { insert0 ( offset , str ) ; return this ; } public StringBuilder insert ( int offset , char [ ] ch ) { insert0 ( offset , ch ) ; return this ; } public StringBuilder insert ( int offset , char [ ] str , int strOffset , int strLen ) { insert0 ( offset , str , strOffset , strLen ) ; return this ; } public StringBuilder insert ( int offset , CharSequence s ) { insert0 ( offset , s = = null ? <str> : s . toString ( ) ) ; return this ; } public StringBuilder insert ( int offset , CharSequence s , int start , int end ) { insert0 ( offset , s , start , end ) ; return this ; } public StringBuilder replace ( int start , int end , String str ) { replace0 ( start , end , str ) ; return this ; } public StringBuilder replace ( String find , String replace ) { int findLength = find . length ( ) , replaceLength = replace . length ( ) ; int index = <int> ; while ( true ) { index = indexOf ( find , index ) ; if ( index = = - <int> ) break ; replace0 ( index , index + findLength , replace ) ; index + = replaceLength ; } return this ; } public StringBuilder replace ( char find , String replace ) { int replaceLength = replace . length ( ) ; int index = <int> ; while ( true ) { while ( true ) { if ( index = = length ) return this ; if ( chars [ index ] = = find ) break ; index + + ; } replace0 ( index , index + <int> , replace ) ; index + = replaceLength ; } } public StringBuilder reverse ( ) { reverse0 ( ) ; return this ; } public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime + length ; result = prime * result + Arrays . hashCode ( chars ) ; return result ; } public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; StringBuilder other = ( StringBuilder ) obj ; int length = this . length ; if ( length ! = other . length ) return false ; char [ ] chars = this . chars ; char [ ] chars2 = other . chars ; if ( chars = = chars2 ) return true ; if ( chars = = null | | chars2 = = null ) return false ; for ( int i = <int> ; i < length ; i + + ) if ( chars [ i ] ! = chars2 [ i ] ) return false ; return true ; } } 
