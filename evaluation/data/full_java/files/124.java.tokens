package org . apache . cassandra . config ; import java . beans . IntrospectionException ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . net . URL ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import com . google . common . base . Joiner ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . google . common . io . ByteStreams ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . yaml . snakeyaml . TypeDescription ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . error . YAMLException ; import org . yaml . snakeyaml . introspector . MissingProperty ; import org . yaml . snakeyaml . introspector . Property ; import org . yaml . snakeyaml . introspector . PropertyUtils ; public class YamlConfigurationLoader implements ConfigurationLoader { private static final Logger logger = LoggerFactory . getLogger ( YamlConfigurationLoader . class ) ; private final static String DEFAULT_CONFIGURATION = <str> ; private static URL getStorageConfigURL ( ) throws ConfigurationException { String configUrl = System . getProperty ( <str> ) ; if ( configUrl = = null ) configUrl = DEFAULT_CONFIGURATION ; URL url ; try { url = new URL ( configUrl ) ; url . openStream ( ) . close ( ) ; } catch ( Exception e ) { ClassLoader loader = DatabaseDescriptor . class . getClassLoader ( ) ; url = loader . getResource ( configUrl ) ; if ( url = = null ) { String required = <str> + File . separator + File . separator ; if ( ! configUrl . startsWith ( required ) ) throw new ConfigurationException ( String . format ( <str> + <str> + <str> , configUrl , required , File . separator , required , File . separator ) ) ; throw new ConfigurationException ( <str> + configUrl + <str> + required + File . separator + <str> ) ; } } logger . info ( <str> , url ) ; return url ; } private static final URL storageConfigURL = getStorageConfigURL ( ) ; @Override public Config loadConfig ( ) throws ConfigurationException { return loadConfig ( storageConfigURL ) ; } public Config loadConfig ( URL url ) throws ConfigurationException { try { logger . debug ( <str> , url ) ; byte [ ] configBytes ; try ( InputStream is = url . openStream ( ) ) { configBytes = ByteStreams . toByteArray ( is ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } logConfig ( configBytes ) ; Constructor constructor = new CustomConstructor ( Config . class ) ; MissingPropertiesChecker propertiesChecker = new MissingPropertiesChecker ( ) ; constructor . setPropertyUtils ( propertiesChecker ) ; Yaml yaml = new Yaml ( constructor ) ; Config result = yaml . loadAs ( new ByteArrayInputStream ( configBytes ) , Config . class ) ; propertiesChecker . check ( ) ; return result ; } catch ( YAMLException e ) { throw new ConfigurationException ( <str> + url , e ) ; } } static class CustomConstructor extends Constructor { CustomConstructor ( Class < ? > theRoot ) { super ( theRoot ) ; TypeDescription seedDesc = new TypeDescription ( ParameterizedClass . class ) ; seedDesc . putMapPropertyType ( <str> , String . class , String . class ) ; addTypeDescription ( seedDesc ) ; } @Override protected List < Object > createDefaultList ( int initSize ) { return Lists . newCopyOnWriteArrayList ( ) ; } @Override protected Map < Object , Object > createDefaultMap ( ) { return Maps . newConcurrentMap ( ) ; } @Override protected Set < Object > createDefaultSet ( int initSize ) { return Sets . newConcurrentHashSet ( ) ; } @Override protected Set < Object > createDefaultSet ( ) { return Sets . newConcurrentHashSet ( ) ; } } private void logConfig ( byte [ ] configBytes ) { Map < Object , Object > configMap = new TreeMap < > ( ( Map < ? , ? > ) new Yaml ( ) . load ( new ByteArrayInputStream ( configBytes ) ) ) ; for ( String sensitiveKey : new String [ ] { <str> , <str> } ) { if ( configMap . containsKey ( sensitiveKey ) ) { configMap . put ( sensitiveKey , <str> ) ; } } logger . info ( <str> , Joiner . on ( <str> ) . join ( configMap . entrySet ( ) ) ) ; } private static class MissingPropertiesChecker extends PropertyUtils { private final Set < String > missingProperties = new HashSet < > ( ) ; public MissingPropertiesChecker ( ) { setSkipMissingProperties ( true ) ; } @Override public Property getProperty ( Class < ? extends Object > type , String name ) throws IntrospectionException { Property result = super . getProperty ( type , name ) ; if ( result instanceof MissingProperty ) { missingProperties . add ( result . getName ( ) ) ; } return result ; } public void check ( ) throws ConfigurationException { if ( ! missingProperties . isEmpty ( ) ) { throw new ConfigurationException ( <str> + missingProperties + <str> ) ; } } } } 
