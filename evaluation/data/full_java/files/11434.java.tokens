package org . gradle . api . internal . classpath ; import org . gradle . api . UncheckedIOException ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . internal . classloader . ClasspathUtil ; import java . io . File ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; public class EffectiveClassPath extends DefaultClassPath { public EffectiveClassPath ( ClassLoader classLoader ) { super ( findAvailableClasspathFiles ( classLoader ) ) ; } private static List < File > findAvailableClasspathFiles ( ClassLoader classLoader ) { List < URL > rawClasspath = ClasspathUtil . getClasspath ( classLoader ) ; List < File > classpathFiles = new ArrayList < File > ( ) ; for ( URL url : rawClasspath ) { if ( url . getProtocol ( ) . equals ( <str> ) ) { try { File classpathFile = new File ( url . toURI ( ) ) ; addClasspathFile ( classpathFile , classpathFiles ) ; } catch ( URISyntaxException e ) { throw new UncheckedIOException ( e ) ; } } } if ( classLoader = = ClassLoader . getSystemClassLoader ( ) ) { for ( String value : System . getProperty ( <str> ) . split ( File . pathSeparator ) ) { addClasspathFile ( new File ( value ) , classpathFiles ) ; } } return classpathFiles ; } private static void addClasspathFile ( File classpathFile , List < File > classpathFiles ) { if ( classpathFile . exists ( ) & & ! classpathFiles . contains ( classpathFile ) ) { classpathFiles . add ( classpathFile ) ; addManifestClasspathFiles ( classpathFile , classpathFiles ) ; } } private static void addManifestClasspathFiles ( File classpathFile , List < File > classpathFiles ) { List < URI > classpathUris = ManifestUtil . parseManifestClasspath ( classpathFile ) ; for ( URI classpathUri : classpathUris ) { addClasspathFile ( new File ( classpathUri ) , classpathFiles ) ; } } } 
