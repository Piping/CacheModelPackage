package org . elasticsearch . cluster ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . tasks . PendingClusterTasksResponse ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . service . InternalClusterService ; import org . elasticsearch . cluster . service . PendingClusterTask ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . component . LifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Singleton ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . MockLogAppender ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . * ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) @ESIntegTestCase.SuppressLocalMode public class ClusterServiceIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( TestPlugin . class ) ; } public void testTimeoutUpdateTask ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService1 = internalCluster ( ) . getInstance ( ClusterService . class ) ; final CountDownLatch block = new CountDownLatch ( <int> ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { try { block . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { throw new RuntimeException ( t ) ; } } ) ; final CountDownLatch timedOut = new CountDownLatch ( <int> ) ; final AtomicBoolean executeCalled = new AtomicBoolean ( ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public TimeValue timeout ( ) { return TimeValue . timeValueMillis ( <int> ) ; } @Override public void onFailure ( String source , Throwable t ) { timedOut . countDown ( ) ; } @Override public ClusterState execute ( ClusterState currentState ) { executeCalled . set ( true ) ; return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { } } ) ; timedOut . await ( ) ; block . countDown ( ) ; final CountDownLatch allProcessed = new CountDownLatch ( <int> ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public void onFailure ( String source , Throwable t ) { throw new RuntimeException ( t ) ; } @Override public ClusterState execute ( ClusterState currentState ) { allProcessed . countDown ( ) ; return currentState ; } } ) ; allProcessed . await ( ) ; assertThat ( executeCalled . get ( ) , equalTo ( false ) ) ; } public void testAckedUpdateTask ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; final AtomicBoolean allNodesAcked = new AtomicBoolean ( false ) ; final AtomicBoolean ackTimeout = new AtomicBoolean ( false ) ; final AtomicBoolean onFailure = new AtomicBoolean ( false ) ; final AtomicBoolean executed = new AtomicBoolean ( false ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CountDownLatch processedLatch = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < Void > ( null , null ) { @Override protected Void newResponse ( boolean acknowledged ) { return null ; } @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return true ; } @Override public void onAllNodesAcked ( @Nullable Throwable t ) { allNodesAcked . set ( true ) ; latch . countDown ( ) ; } @Override public void onAckTimeout ( ) { ackTimeout . set ( true ) ; latch . countDown ( ) ; } @Override public TimeValue ackTimeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public TimeValue timeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { processedLatch . countDown ( ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { executed . set ( true ) ; return ClusterState . builder ( currentState ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; onFailure . set ( true ) ; latch . countDown ( ) ; } } ) ; ensureGreen ( ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; assertThat ( allNodesAcked . get ( ) , equalTo ( true ) ) ; assertThat ( ackTimeout . get ( ) , equalTo ( false ) ) ; assertThat ( executed . get ( ) , equalTo ( true ) ) ; assertThat ( onFailure . get ( ) , equalTo ( false ) ) ; assertThat ( processedLatch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } public void testAckedUpdateTaskSameClusterState ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; final AtomicBoolean allNodesAcked = new AtomicBoolean ( false ) ; final AtomicBoolean ackTimeout = new AtomicBoolean ( false ) ; final AtomicBoolean onFailure = new AtomicBoolean ( false ) ; final AtomicBoolean executed = new AtomicBoolean ( false ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CountDownLatch processedLatch = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < Void > ( null , null ) { @Override protected Void newResponse ( boolean acknowledged ) { return null ; } @Override public void onAllNodesAcked ( @Nullable Throwable t ) { allNodesAcked . set ( true ) ; latch . countDown ( ) ; } @Override public void onAckTimeout ( ) { ackTimeout . set ( true ) ; latch . countDown ( ) ; } @Override public TimeValue ackTimeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public TimeValue timeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { processedLatch . countDown ( ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { executed . set ( true ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; onFailure . set ( true ) ; latch . countDown ( ) ; } } ) ; ensureGreen ( ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; assertThat ( allNodesAcked . get ( ) , equalTo ( true ) ) ; assertThat ( ackTimeout . get ( ) , equalTo ( false ) ) ; assertThat ( executed . get ( ) , equalTo ( true ) ) ; assertThat ( onFailure . get ( ) , equalTo ( false ) ) ; assertThat ( processedLatch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } public void testMasterAwareExecution ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; InternalTestCluster . Async < String > master = internalCluster ( ) . startNodeAsync ( settings ) ; InternalTestCluster . Async < String > nonMaster = internalCluster ( ) . startNodeAsync ( settingsBuilder ( ) . put ( settings ) . put ( <str> , false ) . build ( ) ) ; master . get ( ) ; ensureGreen ( ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class , nonMaster . get ( ) ) ; final boolean [ ] taskFailed = { false } ; final CountDownLatch latch1 = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { latch1 . countDown ( ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { taskFailed [ <int> ] = true ; latch1 . countDown ( ) ; } } ) ; latch1 . await ( ) ; assertTrue ( <str> , taskFailed [ <int> ] ) ; taskFailed [ <int> ] = true ; final CountDownLatch latch2 = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { taskFailed [ <int> ] = false ; latch2 . countDown ( ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { taskFailed [ <int> ] = true ; latch2 . countDown ( ) ; } } ) ; latch2 . await ( ) ; assertFalse ( <str> , taskFailed [ <int> ] ) ; } public void testAckedUpdateTaskNoAckExpected ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; final AtomicBoolean allNodesAcked = new AtomicBoolean ( false ) ; final AtomicBoolean ackTimeout = new AtomicBoolean ( false ) ; final AtomicBoolean onFailure = new AtomicBoolean ( false ) ; final AtomicBoolean executed = new AtomicBoolean ( false ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < Void > ( null , null ) { @Override protected Void newResponse ( boolean acknowledged ) { return null ; } @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return false ; } @Override public void onAllNodesAcked ( @Nullable Throwable t ) { allNodesAcked . set ( true ) ; latch . countDown ( ) ; } @Override public void onAckTimeout ( ) { ackTimeout . set ( true ) ; latch . countDown ( ) ; } @Override public TimeValue ackTimeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public TimeValue timeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { executed . set ( true ) ; return ClusterState . builder ( currentState ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; onFailure . set ( true ) ; latch . countDown ( ) ; } } ) ; ensureGreen ( ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; assertThat ( allNodesAcked . get ( ) , equalTo ( true ) ) ; assertThat ( ackTimeout . get ( ) , equalTo ( false ) ) ; assertThat ( executed . get ( ) , equalTo ( true ) ) ; assertThat ( onFailure . get ( ) , equalTo ( false ) ) ; } public void testAckedUpdateTaskTimeoutZero ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; final AtomicBoolean allNodesAcked = new AtomicBoolean ( false ) ; final AtomicBoolean ackTimeout = new AtomicBoolean ( false ) ; final AtomicBoolean onFailure = new AtomicBoolean ( false ) ; final AtomicBoolean executed = new AtomicBoolean ( false ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CountDownLatch processedLatch = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < Void > ( null , null ) { @Override protected Void newResponse ( boolean acknowledged ) { return null ; } @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return false ; } @Override public void onAllNodesAcked ( @Nullable Throwable t ) { allNodesAcked . set ( true ) ; latch . countDown ( ) ; } @Override public void onAckTimeout ( ) { ackTimeout . set ( true ) ; latch . countDown ( ) ; } @Override public TimeValue ackTimeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public TimeValue timeout ( ) { return TimeValue . timeValueSeconds ( <int> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { processedLatch . countDown ( ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { executed . set ( true ) ; return ClusterState . builder ( currentState ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; onFailure . set ( true ) ; latch . countDown ( ) ; } } ) ; ensureGreen ( ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; assertThat ( allNodesAcked . get ( ) , equalTo ( false ) ) ; assertThat ( ackTimeout . get ( ) , equalTo ( true ) ) ; assertThat ( executed . get ( ) , equalTo ( true ) ) ; assertThat ( onFailure . get ( ) , equalTo ( false ) ) ; assertThat ( processedLatch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } public void testPendingUpdateTask ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; String node_0 = internalCluster ( ) . startNode ( settings ) ; internalCluster ( ) . startNodeClient ( settings ) ; final ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class , node_0 ) ; final CountDownLatch block1 = new CountDownLatch ( <int> ) ; final CountDownLatch invoked1 = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { invoked1 . countDown ( ) ; try { block1 . await ( ) ; } catch ( InterruptedException e ) { fail ( ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { invoked1 . countDown ( ) ; fail ( ) ; } } ) ; invoked1 . await ( ) ; final CountDownLatch invoked2 = new CountDownLatch ( <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) { clusterService . submitStateUpdateTask ( Integer . toString ( i ) , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { return currentState ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { invoked2 . countDown ( ) ; } } ) ; } Set < String > controlSources = new HashSet < > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; List < PendingClusterTask > pendingClusterTasks = clusterService . pendingTasks ( ) ; assertThat ( pendingClusterTasks . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( pendingClusterTasks . get ( <int> ) . getSource ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( pendingClusterTasks . get ( <int> ) . isExecuting ( ) , equalTo ( true ) ) ; for ( PendingClusterTask task : pendingClusterTasks ) { controlSources . remove ( task . getSource ( ) . string ( ) ) ; } assertTrue ( controlSources . isEmpty ( ) ) ; controlSources = new HashSet < > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; PendingClusterTasksResponse response = internalCluster ( ) . clientNodeClient ( ) . admin ( ) . cluster ( ) . preparePendingClusterTasks ( ) . execute ( ) . actionGet ( ) ; assertThat ( response . pendingTasks ( ) . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( response . pendingTasks ( ) . get ( <int> ) . getSource ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( response . pendingTasks ( ) . get ( <int> ) . isExecuting ( ) , equalTo ( true ) ) ; for ( PendingClusterTask task : response ) { controlSources . remove ( task . getSource ( ) . string ( ) ) ; } assertTrue ( controlSources . isEmpty ( ) ) ; block1 . countDown ( ) ; invoked2 . await ( ) ; assertTrue ( awaitBusy ( ( ) - > clusterService . pendingTasks ( ) . isEmpty ( ) ) ) ; waitNoPendingTasksOnAll ( ) ; final CountDownLatch block2 = new CountDownLatch ( <int> ) ; final CountDownLatch invoked3 = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { invoked3 . countDown ( ) ; try { block2 . await ( ) ; } catch ( InterruptedException e ) { fail ( ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { invoked3 . countDown ( ) ; fail ( ) ; } } ) ; invoked3 . await ( ) ; for ( int i = <int> ; i < = <int> ; i + + ) { clusterService . submitStateUpdateTask ( Integer . toString ( i ) , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { return currentState ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; } Thread . sleep ( <int> ) ; pendingClusterTasks = clusterService . pendingTasks ( ) ; assertThat ( pendingClusterTasks . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; controlSources = new HashSet < > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ) ; for ( PendingClusterTask task : pendingClusterTasks ) { controlSources . remove ( task . getSource ( ) . string ( ) ) ; } assertTrue ( controlSources . isEmpty ( ) ) ; response = internalCluster ( ) . clientNodeClient ( ) . admin ( ) . cluster ( ) . preparePendingClusterTasks ( ) . get ( ) ; assertThat ( response . pendingTasks ( ) . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; controlSources = new HashSet < > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ) ; for ( PendingClusterTask task : response ) { if ( controlSources . remove ( task . getSource ( ) . string ( ) ) ) { assertThat ( task . getTimeInQueueInMillis ( ) , greaterThan ( <int> l ) ) ; } } assertTrue ( controlSources . isEmpty ( ) ) ; block2 . countDown ( ) ; } public void testLocalNodeMasterListenerCallbacks ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) . build ( ) ; String node_0 = internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; MasterAwareService testService = internalCluster ( ) . getInstance ( MasterAwareService . class ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterService . state ( ) . nodes ( ) . masterNode ( ) , notNullValue ( ) ) ; assertThat ( clusterService . state ( ) . nodes ( ) . localNodeMaster ( ) , is ( true ) ) ; assertThat ( testService . master ( ) , is ( true ) ) ; String node_1 = internalCluster ( ) . startNode ( settings ) ; final ClusterService clusterService1 = internalCluster ( ) . getInstance ( ClusterService . class , node_1 ) ; MasterAwareService testService1 = internalCluster ( ) . getInstance ( MasterAwareService . class , node_1 ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterService1 . state ( ) . nodes ( ) . localNodeMaster ( ) , is ( false ) ) ; assertThat ( testService1 . master ( ) , is ( false ) ) ; internalCluster ( ) . stopCurrentMasterNode ( ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterService1 . state ( ) . nodes ( ) . localNodeMaster ( ) , is ( true ) ) ; assertThat ( testService1 . master ( ) , is ( true ) ) ; internalCluster ( ) . startNode ( Settings . builder ( ) . put ( settings ) ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; Settings transientSettings = settingsBuilder ( ) . put ( <str> , <int> ) . build ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( transientSettings ) . get ( ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; awaitBusy ( ( ) - > clusterService1 . state ( ) . nodes ( ) . masterNode ( ) = = null & & clusterService1 . state ( ) . status ( ) = = ClusterState . ClusterStateStatus . APPLIED ) ; assertThat ( testService1 . master ( ) , is ( false ) ) ; String node_2 = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( settings ) . put ( transientSettings ) ) ; ClusterService clusterService2 = internalCluster ( ) . getInstance ( ClusterService . class , node_2 ) ; MasterAwareService testService2 = internalCluster ( ) . getInstance ( MasterAwareService . class , node_2 ) ; assertThat ( internalCluster ( ) . client ( node_1 ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setLocal ( true ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) , is ( false ) ) ; assertThat ( internalCluster ( ) . client ( node_2 ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setLocal ( true ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) , is ( false ) ) ; assertThat ( clusterService2 . state ( ) . nodes ( ) . masterNode ( ) , is ( notNullValue ( ) ) ) ; if ( node_2 . equals ( clusterService2 . state ( ) . nodes ( ) . masterNode ( ) . name ( ) ) ) { assertThat ( testService1 . master ( ) , is ( false ) ) ; assertThat ( testService2 . master ( ) , is ( true ) ) ; } else { assertThat ( testService1 . master ( ) , is ( true ) ) ; assertThat ( testService2 . master ( ) , is ( false ) ) ; } } public void testPrioritizedTasks ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; BlockingTask block = new BlockingTask ( Priority . IMMEDIATE ) ; clusterService . submitStateUpdateTask ( <str> , block ) ; int taskCount = randomIntBetween ( <int> , <int> ) ; Priority [ ] priorities = Priority . values ( ) ; List < PrioritizedTask > tasks = new ArrayList < > ( taskCount ) ; CountDownLatch latch = new CountDownLatch ( taskCount ) ; for ( int i = <int> ; i < taskCount ; i + + ) { Priority priority = priorities [ randomIntBetween ( <int> , priorities . length - <int> ) ] ; clusterService . submitStateUpdateTask ( <str> , new PrioritizedTask ( priority , latch , tasks ) ) ; } block . release ( ) ; latch . await ( ) ; Priority prevPriority = null ; for ( PrioritizedTask task : tasks ) { if ( prevPriority = = null ) { prevPriority = task . priority ( ) ; } else { assertThat ( task . priority ( ) . sameOrAfter ( prevPriority ) , is ( true ) ) ; } } } public void testClusterStateBatchedUpdates ( ) throws InterruptedException { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService = internalCluster ( ) . getInstance ( ClusterService . class ) ; AtomicInteger counter = new AtomicInteger ( ) ; class Task { private AtomicBoolean state = new AtomicBoolean ( ) ; public void execute ( ) { if ( ! state . compareAndSet ( false , true ) ) { throw new IllegalStateException ( ) ; } else { counter . incrementAndGet ( ) ; } } } class TaskExecutor implements ClusterStateTaskExecutor < Task > { private AtomicInteger counter = new AtomicInteger ( ) ; @Override public BatchResult < Task > execute ( ClusterState currentState , List < Task > tasks ) throws Exception { tasks . forEach ( task - > task . execute ( ) ) ; counter . addAndGet ( tasks . size ( ) ) ; return BatchResult . < Task > builder ( ) . successes ( tasks ) . build ( currentState ) ; } @Override public boolean runOnlyOnMaster ( ) { return false ; } } int numberOfThreads = randomIntBetween ( <int> , <int> ) ; int tasksSubmittedPerThread = randomIntBetween ( <int> , <int> ) ; ConcurrentMap < String , AtomicInteger > counters = new ConcurrentHashMap < > ( ) ; CountDownLatch updateLatch = new CountDownLatch ( numberOfThreads * tasksSubmittedPerThread ) ; ClusterStateTaskListener listener = new ClusterStateTaskListener ( ) { @Override public void onFailure ( String source , Throwable t ) { assert false ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { counters . computeIfAbsent ( source , key - > new AtomicInteger ( ) ) . incrementAndGet ( ) ; updateLatch . countDown ( ) ; } } ; int numberOfExecutors = Math . max ( <int> , numberOfThreads / <int> ) ; List < TaskExecutor > executors = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfExecutors ; i + + ) { executors . add ( new TaskExecutor ( ) ) ; } List < TaskExecutor > assignments = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { for ( int j = <int> ; j < tasksSubmittedPerThread ; j + + ) { assignments . add ( randomFrom ( executors ) ) ; } } Map < TaskExecutor , Integer > counts = new HashMap < > ( ) ; for ( TaskExecutor executor : assignments ) { counts . merge ( executor , <int> , ( previous , one ) - > previous + one ) ; } CountDownLatch startingGun = new CountDownLatch ( <int> + numberOfThreads ) ; List < Thread > threads = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { final int index = i ; Thread thread = new Thread ( ( ) - > { startingGun . countDown ( ) ; for ( int j = <int> ; j < tasksSubmittedPerThread ; j + + ) { ClusterStateTaskExecutor < Task > executor = assignments . get ( index * tasksSubmittedPerThread + j ) ; clusterService . submitStateUpdateTask ( Thread . currentThread ( ) . getName ( ) , new Task ( ) , ClusterStateTaskConfig . build ( randomFrom ( Priority . values ( ) ) ) , executor , listener ) ; } } ) ; threads . add ( thread ) ; thread . start ( ) ; } startingGun . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } updateLatch . await ( ) ; assertEquals ( numberOfThreads * tasksSubmittedPerThread , counter . get ( ) ) ; for ( TaskExecutor executor : executors ) { if ( counts . containsKey ( executor ) ) { assertEquals ( ( int ) counts . get ( executor ) , executor . counter . get ( ) ) ; } } for ( Map . Entry < String , AtomicInteger > entry : counters . entrySet ( ) ) { assertEquals ( entry . getValue ( ) . get ( ) , tasksSubmittedPerThread ) ; } } @TestLogging ( <str> ) public void testClusterStateUpdateLogging ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService1 = internalCluster ( ) . getInstance ( ClusterService . class ) ; MockLogAppender mockAppender = new MockLogAppender ( ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . DEBUG , <str> ) ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . TRACE , <str> ) ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . DEBUG , <str> ) ) ; Logger rootLogger = Logger . getRootLogger ( ) ; rootLogger . addAppender ( mockAppender ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { throw new IllegalArgumentException ( <str> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { fail ( ) ; } @Override public void onFailure ( String source , Throwable t ) { latch . countDown ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { return ClusterState . builder ( currentState ) . incrementVersion ( ) . build ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } finally { rootLogger . removeAppender ( mockAppender ) ; } mockAppender . assertAllExpectationsMatched ( ) ; } @TestLogging ( <str> ) public void testLongClusterStateUpdateLogging ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( InternalClusterService . SETTING_CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; ClusterService clusterService1 = internalCluster ( ) . getInstance ( ClusterService . class ) ; MockLogAppender mockAppender = new MockLogAppender ( ) ; mockAppender . addExpectation ( new MockLogAppender . UnseenEventExpectation ( <str> , <str> , Level . WARN , <str> ) ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . WARN , <str> ) ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . WARN , <str> ) ) ; mockAppender . addExpectation ( new MockLogAppender . SeenEventExpectation ( <str> , <str> , Level . WARN , <str> ) ) ; Logger rootLogger = Logger . getRootLogger ( ) ; rootLogger . addAppender ( mockAppender ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CountDownLatch processedFirstTask = new CountDownLatch ( <int> ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { Thread . sleep ( <int> ) ; return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; processedFirstTask . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; processedFirstTask . await ( <int> , TimeUnit . SECONDS ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( InternalClusterService . SETTING_CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD , <str> ) ) ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { Thread . sleep ( <int> ) ; throw new IllegalArgumentException ( <str> ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { fail ( ) ; } @Override public void onFailure ( String source , Throwable t ) { latch . countDown ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { Thread . sleep ( <int> ) ; return ClusterState . builder ( currentState ) . incrementVersion ( ) . build ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { Thread . sleep ( <int> ) ; return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; clusterService1 . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public void onFailure ( String source , Throwable t ) { fail ( ) ; } } ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } finally { rootLogger . removeAppender ( mockAppender ) ; } mockAppender . assertAllExpectationsMatched ( ) ; } private static class BlockingTask extends ClusterStateUpdateTask { private final CountDownLatch latch = new CountDownLatch ( <int> ) ; public BlockingTask ( Priority priority ) { super ( priority ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { latch . await ( ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { } public void release ( ) { latch . countDown ( ) ; } } private static class PrioritizedTask extends ClusterStateUpdateTask { private final CountDownLatch latch ; private final List < PrioritizedTask > tasks ; private PrioritizedTask ( Priority priority , CountDownLatch latch , List < PrioritizedTask > tasks ) { super ( priority ) ; this . latch = latch ; this . tasks = tasks ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { tasks . add ( this ) ; latch . countDown ( ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { latch . countDown ( ) ; } } public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } @Override public Collection < Class < ? extends LifecycleComponent > > nodeServices ( ) { List < Class < ? extends LifecycleComponent > > services = new ArrayList < > ( <int> ) ; services . add ( MasterAwareService . class ) ; return services ; } } @Singleton public static class MasterAwareService extends AbstractLifecycleComponent < MasterAwareService > implements LocalNodeMasterListener { private final ClusterService clusterService ; private volatile boolean master ; @Inject public MasterAwareService ( Settings settings , ClusterService clusterService ) { super ( settings ) ; clusterService . add ( this ) ; this . clusterService = clusterService ; logger . info ( <str> ) ; } @Override public void onMaster ( ) { logger . info ( <str> + clusterService . localNode ( ) + <str> ) ; master = true ; } @Override public void offMaster ( ) { logger . info ( <str> + clusterService . localNode ( ) + <str> ) ; master = false ; } public boolean master ( ) { return master ; } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { } @Override public String executorName ( ) { return ThreadPool . Names . SAME ; } } } 
