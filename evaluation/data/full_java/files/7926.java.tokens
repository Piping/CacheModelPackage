package org . elasticsearch . common . io . stream ; import org . apache . lucene . util . Constants ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . lucene . BytesRefs ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . Objects ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class BytesStreamsTests extends ESTestCase { public void testEmpty ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; assertEquals ( <int> , out . size ( ) ) ; assertEquals ( <int> , out . bytes ( ) . toBytes ( ) . length ) ; out . close ( ) ; } public void testSingleByte ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; assertEquals ( <int> , out . size ( ) ) ; int expectedSize = <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; out . writeByte ( expectedData [ <int> ] ) ; assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSingleShortPage ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; for ( int i = <int> ; i < expectedSize ; i + + ) { out . writeByte ( expectedData [ i ] ) ; } assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testIllegalBulkWrite ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; try { out . writeBytes ( new byte [ ] { } , <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException iax1 ) { } out . close ( ) ; } public void testSingleShortPageBulkWrite ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; out . writeBytes ( expectedData ) ; assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; expectedSize = <int> ; expectedData = randomizedByteArrayWithSize ( expectedSize ) ; out . writeBytes ( expectedData ) ; assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSingleFullPageBulkWrite ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = BigArrays . BYTE_PAGE_SIZE ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; out . writeBytes ( expectedData ) ; assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSingleFullPageBulkWriteWithOffset ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int initialOffset = <int> ; int additionalLength = BigArrays . BYTE_PAGE_SIZE ; byte [ ] expectedData = randomizedByteArrayWithSize ( initialOffset + additionalLength ) ; out . writeBytes ( expectedData , <int> , initialOffset ) ; assertEquals ( initialOffset , out . size ( ) ) ; out . writeBytes ( expectedData , initialOffset , additionalLength ) ; assertEquals ( expectedData . length , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSingleFullPageBulkWriteWithOffsetCrossover ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int initialOffset = <int> ; int additionalLength = BigArrays . BYTE_PAGE_SIZE * <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( initialOffset + additionalLength ) ; out . writeBytes ( expectedData , <int> , initialOffset ) ; assertEquals ( initialOffset , out . size ( ) ) ; out . writeBytes ( expectedData , initialOffset , additionalLength ) ; assertEquals ( expectedData . length , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSingleFullPage ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = BigArrays . BYTE_PAGE_SIZE ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; for ( int i = <int> ; i < expectedSize ; i + + ) { out . writeByte ( expectedData [ i ] ) ; } assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testOneFullOneShortPage ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = BigArrays . BYTE_PAGE_SIZE + <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; for ( int i = <int> ; i < expectedSize ; i + + ) { out . writeByte ( expectedData [ i ] ) ; } assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testTwoFullOneShortPage ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int expectedSize = ( BigArrays . BYTE_PAGE_SIZE * <int> ) + <int> ; byte [ ] expectedData = randomizedByteArrayWithSize ( expectedSize ) ; for ( int i = <int> ; i < expectedSize ; i + + ) { out . writeByte ( expectedData [ i ] ) ; } assertEquals ( expectedSize , out . size ( ) ) ; assertArrayEquals ( expectedData , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testSeek ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int position = <int> ; assertEquals ( position , out . position ( ) ) ; out . seek ( position + = <int> ) ; out . seek ( position + = BigArrays . BYTE_PAGE_SIZE ) ; out . seek ( position + = BigArrays . BYTE_PAGE_SIZE + <int> ) ; out . seek ( position + = BigArrays . BYTE_PAGE_SIZE * <int> ) ; assertEquals ( position , out . position ( ) ) ; assertEquals ( position , out . bytes ( ) . toBytes ( ) . length ) ; out . close ( ) ; } public void testSkip ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; int position = <int> ; assertEquals ( position , out . position ( ) ) ; int forward = <int> ; out . skip ( forward ) ; assertEquals ( position + forward , out . position ( ) ) ; out . close ( ) ; } public void testSimpleStreams ( ) throws Exception { assumeTrue ( <str> , Constants . JRE_IS_64BIT ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeBoolean ( false ) ; out . writeByte ( ( byte ) <int> ) ; out . writeShort ( ( short ) - <int> ) ; out . writeInt ( - <int> ) ; out . writeVInt ( <int> ) ; out . writeLong ( - <int> ) ; out . writeVLong ( <int> ) ; out . writeFloat ( <float> ) ; out . writeDouble ( <float> ) ; int [ ] intArray = { <int> , <int> , <int> } ; out . writeGenericValue ( intArray ) ; int [ ] vIntArray = { <int> , <int> , <int> } ; out . writeVIntArray ( vIntArray ) ; long [ ] longArray = { <int> , <int> , <int> } ; out . writeGenericValue ( longArray ) ; long [ ] vLongArray = { <int> , <int> , <int> } ; out . writeVLongArray ( vLongArray ) ; float [ ] floatArray = { <float> , <float> , <float> } ; out . writeGenericValue ( floatArray ) ; double [ ] doubleArray = { <float> , <float> , <float> } ; out . writeGenericValue ( doubleArray ) ; out . writeString ( <str> ) ; out . writeString ( <str> ) ; out . writeGenericValue ( BytesRefs . toBytesRef ( <str> ) ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) . toBytes ( ) ) ; assertThat ( in . readBoolean ( ) , equalTo ( false ) ) ; assertThat ( in . readByte ( ) , equalTo ( ( byte ) <int> ) ) ; assertThat ( in . readShort ( ) , equalTo ( ( short ) - <int> ) ) ; assertThat ( in . readInt ( ) , equalTo ( - <int> ) ) ; assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; assertThat ( in . readLong ( ) , equalTo ( ( long ) - <int> ) ) ; assertThat ( in . readVLong ( ) , equalTo ( ( long ) <int> ) ) ; assertThat ( ( double ) in . readFloat ( ) , closeTo ( <float> , <float> ) ) ; assertThat ( in . readDouble ( ) , closeTo ( <float> , <float> ) ) ; assertThat ( in . readGenericValue ( ) , equalTo ( ( Object ) intArray ) ) ; assertThat ( in . readVIntArray ( ) , equalTo ( vIntArray ) ) ; assertThat ( in . readGenericValue ( ) , equalTo ( ( Object ) longArray ) ) ; assertThat ( in . readVLongArray ( ) , equalTo ( vLongArray ) ) ; assertThat ( in . readGenericValue ( ) , equalTo ( ( Object ) floatArray ) ) ; assertThat ( in . readGenericValue ( ) , equalTo ( ( Object ) doubleArray ) ) ; assertThat ( in . readString ( ) , equalTo ( <str> ) ) ; assertThat ( in . readString ( ) , equalTo ( <str> ) ) ; assertThat ( in . readGenericValue ( ) , equalTo ( ( Object ) BytesRefs . toBytesRef ( <str> ) ) ) ; in . close ( ) ; out . close ( ) ; } public void testNamedWriteable ( ) throws IOException { BytesStreamOutput out = new BytesStreamOutput ( ) ; NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry ( ) ; namedWriteableRegistry . registerPrototype ( BaseNamedWriteable . class , new TestNamedWriteable ( null , null ) ) ; TestNamedWriteable namedWriteableIn = new TestNamedWriteable ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ; out . writeNamedWriteable ( namedWriteableIn ) ; StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( out . bytes ( ) . toBytes ( ) ) , namedWriteableRegistry ) ; BaseNamedWriteable namedWriteableOut = in . readNamedWriteable ( BaseNamedWriteable . class ) ; assertEquals ( namedWriteableOut , namedWriteableIn ) ; } public void testNamedWriteableDuplicates ( ) throws IOException { NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry ( ) ; namedWriteableRegistry . registerPrototype ( BaseNamedWriteable . class , new TestNamedWriteable ( null , null ) ) ; try { namedWriteableRegistry . registerPrototype ( BaseNamedWriteable . class , new TestNamedWriteable ( null , null ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + TestNamedWriteable . class . getName ( ) + <str> + TestNamedWriteable . NAME + <str> + TestNamedWriteable . class . getName ( ) + <str> + BaseNamedWriteable . class . getName ( ) + <str> ) ) ; } } public void testNamedWriteableUnknownCategory ( ) throws IOException { BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeNamedWriteable ( new TestNamedWriteable ( <str> , <str> ) ) ; StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( out . bytes ( ) . toBytes ( ) ) , new NamedWriteableRegistry ( ) ) ; try { in . readNamedWriteable ( BaseNamedWriteable . class ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + BaseNamedWriteable . class . getName ( ) + <str> ) ) ; } } public void testNamedWriteableUnknownNamedWriteable ( ) throws IOException { NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry ( ) ; namedWriteableRegistry . registerPrototype ( BaseNamedWriteable . class , new TestNamedWriteable ( null , null ) ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeNamedWriteable ( new NamedWriteable ( ) { @Override public String getWriteableName ( ) { return <str> ; } @Override public void writeTo ( StreamOutput out ) throws IOException { } @Override public Object readFrom ( StreamInput in ) throws IOException { return null ; } } ) ; StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( out . bytes ( ) . toBytes ( ) ) , namedWriteableRegistry ) ; try { in . readNamedWriteable ( BaseNamedWriteable . class ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + BaseNamedWriteable . class . getName ( ) + <str> ) ) ; } } public void testNamedWriteableNotSupportedWithoutWrapping ( ) throws IOException { BytesStreamOutput out = new BytesStreamOutput ( ) ; TestNamedWriteable testNamedWriteable = new TestNamedWriteable ( <str> , <str> ) ; out . writeNamedWriteable ( testNamedWriteable ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) . toBytes ( ) ) ; try { in . readNamedWriteable ( BaseNamedWriteable . class ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } private static abstract class BaseNamedWriteable < T > implements NamedWriteable < T > { } private static class TestNamedWriteable extends BaseNamedWriteable < TestNamedWriteable > { private static final String NAME = <str> ; private final String field1 ; private final String field2 ; TestNamedWriteable ( String field1 , String field2 ) { this . field1 = field1 ; this . field2 = field2 ; } @Override public String getWriteableName ( ) { return NAME ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( field1 ) ; out . writeString ( field2 ) ; } @Override public TestNamedWriteable readFrom ( StreamInput in ) throws IOException { return new TestNamedWriteable ( in . readString ( ) , in . readString ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; TestNamedWriteable that = ( TestNamedWriteable ) o ; return Objects . equals ( field1 , that . field1 ) & & Objects . equals ( field2 , that . field2 ) ; } @Override public int hashCode ( ) { return Objects . hash ( field1 , field2 ) ; } } @AwaitsFix ( bugUrl = <str> ) public void testAccessAfterClose ( ) throws Exception { BytesStreamOutput out = new BytesStreamOutput ( ) ; out . close ( ) ; assertEquals ( - <int> , out . size ( ) ) ; assertEquals ( - <int> , out . position ( ) ) ; try { out . writeByte ( ( byte ) <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException iex1 ) { } try { out . writeBytes ( new byte [ <int> ] , <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException iex1 ) { } try { out . bytes ( ) . toBytes ( ) ; fail ( <str> ) ; } catch ( IllegalStateException iex1 ) { } } protected byte [ ] randomizedByteArrayWithSize ( int size ) { byte [ ] data = new byte [ size ] ; getRandom ( ) . nextBytes ( data ) ; return data ; } public void testReadWriteGeoPoint ( ) throws IOException { { BytesStreamOutput out = new BytesStreamOutput ( ) ; GeoPoint geoPoint = new GeoPoint ( randomDouble ( ) , randomDouble ( ) ) ; out . writeGenericValue ( geoPoint ) ; StreamInput wrap = StreamInput . wrap ( out . bytes ( ) ) ; GeoPoint point = ( GeoPoint ) wrap . readGenericValue ( ) ; assertEquals ( point , geoPoint ) ; } { BytesStreamOutput out = new BytesStreamOutput ( ) ; GeoPoint geoPoint = new GeoPoint ( randomDouble ( ) , randomDouble ( ) ) ; out . writeGeoPoint ( geoPoint ) ; StreamInput wrap = StreamInput . wrap ( out . bytes ( ) ) ; GeoPoint point = wrap . readGeoPoint ( ) ; assertEquals ( point , geoPoint ) ; } } } 
