package org . gradle . api . internal . tasks . scala ; import com . google . common . base . Joiner ; import com . google . common . collect . Lists ; import org . gradle . api . internal . file . collections . SimpleFileCollection ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . internal . tasks . compile . CompilationFailedException ; import org . gradle . api . internal . tasks . compile . JavaCompilerArgumentsBuilder ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . tasks . WorkResult ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; public class NormalizingScalaCompiler implements Compiler < ScalaJavaJointCompileSpec > { private static final Logger LOGGER = Logging . getLogger ( NormalizingScalaCompiler . class ) ; private final Compiler < ScalaJavaJointCompileSpec > delegate ; public NormalizingScalaCompiler ( Compiler < ScalaJavaJointCompileSpec > delegate ) { this . delegate = delegate ; } public WorkResult execute ( ScalaJavaJointCompileSpec spec ) { resolveAndFilterSourceFiles ( spec ) ; resolveClasspath ( spec ) ; resolveNonStringsInCompilerArgs ( spec ) ; logSourceFiles ( spec ) ; logCompilerArguments ( spec ) ; return delegateAndHandleErrors ( spec ) ; } private void resolveAndFilterSourceFiles ( final ScalaJavaJointCompileSpec spec ) { spec . setSource ( new SimpleFileCollection ( spec . getSource ( ) . getFiles ( ) ) ) ; } private void resolveClasspath ( ScalaJavaJointCompileSpec spec ) { ArrayList < File > classPath = Lists . newArrayList ( spec . getClasspath ( ) ) ; classPath . add ( spec . getDestinationDir ( ) ) ; spec . setClasspath ( classPath ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( <str> , spec . getClasspath ( ) ) ; } } private void resolveNonStringsInCompilerArgs ( ScalaJavaJointCompileSpec spec ) { spec . getCompileOptions ( ) . setCompilerArgs ( CollectionUtils . toStringList ( spec . getCompileOptions ( ) . getCompilerArgs ( ) ) ) ; } private void logSourceFiles ( ScalaJavaJointCompileSpec spec ) { if ( ! spec . getScalaCompileOptions ( ) . isListFiles ( ) ) { return ; } StringBuilder builder = new StringBuilder ( ) ; builder . append ( <str> ) ; for ( File file : spec . getSource ( ) ) { builder . append ( <str> ) ; builder . append ( file ) ; } LOGGER . quiet ( builder . toString ( ) ) ; } private void logCompilerArguments ( ScalaJavaJointCompileSpec spec ) { if ( ! LOGGER . isDebugEnabled ( ) ) { return ; } List < String > compilerArgs = new JavaCompilerArgumentsBuilder ( spec ) . includeLauncherOptions ( true ) . includeSourceFiles ( true ) . build ( ) ; String joinedArgs = Joiner . on ( <str> ) . join ( compilerArgs ) ; LOGGER . debug ( <str> , joinedArgs ) ; } private WorkResult delegateAndHandleErrors ( ScalaJavaJointCompileSpec spec ) { try { return delegate . execute ( spec ) ; } catch ( CompilationFailedException e ) { if ( spec . getScalaCompileOptions ( ) . isFailOnError ( ) ) { throw e ; } LOGGER . debug ( <str> ) ; return new SimpleWorkResult ( false ) ; } } } 
