package io . netty . microbench . internal ; import io . netty . microbench . util . AbstractMicrobenchmark ; import io . netty . util . internal . PlatformDependent ; import java . util . Arrays ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . BenchmarkMode ; import org . openjdk . jmh . annotations . Level ; import org . openjdk . jmh . annotations . Mode ; import org . openjdk . jmh . annotations . Param ; import org . openjdk . jmh . annotations . Scope ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . annotations . State ; import org . openjdk . jmh . annotations . Threads ; @Threads ( <int> ) @State ( Scope . Benchmark ) public class PlatformDependentBenchmark extends AbstractMicrobenchmark { @Param ( { <str> , <str> , <str> , <str> , <str> , <str> } ) private int size ; private byte [ ] bytes1 ; private byte [ ] bytes2 ; @Setup ( Level . Trial ) public void setup ( ) { bytes1 = new byte [ size ] ; bytes2 = new byte [ size ] ; for ( int i = <int> ; i < size ; i + + ) { bytes1 [ i ] = bytes2 [ i ] = ( byte ) i ; } } @Benchmark @BenchmarkMode ( Mode . Throughput ) public boolean unsafeBytesEqual ( ) { return PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ; } @Benchmark @BenchmarkMode ( Mode . Throughput ) public boolean arraysBytesEqual ( ) { return Arrays . equals ( bytes1 , bytes2 ) ; } } 
