package clojure . lang ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . concurrent . atomic . AtomicReference ; public class PersistentVector extends APersistentVector implements IObj , IEditableCollection , IReduce , IKVReduce { public static class Node implements Serializable { transient public final AtomicReference < Thread > edit ; public final Object [ ] array ; public Node ( AtomicReference < Thread > edit , Object [ ] array ) { this . edit = edit ; this . array = array ; } Node ( AtomicReference < Thread > edit ) { this . edit = edit ; this . array = new Object [ <int> ] ; } } final static AtomicReference < Thread > NOEDIT = new AtomicReference < Thread > ( null ) ; public final static Node EMPTY_NODE = new Node ( NOEDIT , new Object [ <int> ] ) ; final int cnt ; public final int shift ; public final Node root ; public final Object [ ] tail ; final IPersistentMap _meta ; public final static PersistentVector EMPTY = new PersistentVector ( <int> , <int> , EMPTY_NODE , new Object [ ] { } ) ; private static final IFn TRANSIENT_VECTOR_CONJ = new AFn ( ) { public Object invoke ( Object coll , Object val ) { return ( ( ITransientVector ) coll ) . conj ( val ) ; } public Object invoke ( Object coll ) { return coll ; } } ; static public PersistentVector adopt ( Object [ ] items ) { return new PersistentVector ( items . length , <int> , EMPTY_NODE , items ) ; } static public PersistentVector create ( IReduceInit items ) { TransientVector ret = EMPTY . asTransient ( ) ; items . reduce ( TRANSIENT_VECTOR_CONJ , ret ) ; return ret . persistent ( ) ; } static public PersistentVector create ( ISeq items ) { Object [ ] arr = new Object [ <int> ] ; int i = <int> ; for ( ; items ! = null & & i < <int> ; items = items . next ( ) ) arr [ i + + ] = items . first ( ) ; if ( items ! = null ) { PersistentVector start = new PersistentVector ( <int> , <int> , EMPTY_NODE , arr ) ; TransientVector ret = start . asTransient ( ) ; for ( ; items ! = null ; items = items . next ( ) ) ret = ret . conj ( items . first ( ) ) ; return ret . persistent ( ) ; } else if ( i = = <int> ) { return new PersistentVector ( <int> , <int> , EMPTY_NODE , arr ) ; } else { Object [ ] arr2 = new Object [ i ] ; System . arraycopy ( arr , <int> , arr2 , <int> , i ) ; return new PersistentVector ( i , <int> , EMPTY_NODE , arr2 ) ; } } static public PersistentVector create ( List list ) { int size = list . size ( ) ; if ( size < = <int> ) return new PersistentVector ( size , <int> , PersistentVector . EMPTY_NODE , list . toArray ( ) ) ; TransientVector ret = EMPTY . asTransient ( ) ; for ( int i = <int> ; i < size ; i + + ) ret = ret . conj ( list . get ( i ) ) ; return ret . persistent ( ) ; } static public PersistentVector create ( Iterable items ) { if ( items instanceof ArrayList ) return create ( ( ArrayList ) items ) ; Iterator iter = items . iterator ( ) ; TransientVector ret = EMPTY . asTransient ( ) ; while ( iter . hasNext ( ) ) ret = ret . conj ( iter . next ( ) ) ; return ret . persistent ( ) ; } static public PersistentVector create ( Object . . . items ) { TransientVector ret = EMPTY . asTransient ( ) ; for ( Object item : items ) ret = ret . conj ( item ) ; return ret . persistent ( ) ; } PersistentVector ( int cnt , int shift , Node root , Object [ ] tail ) { this . _meta = null ; this . cnt = cnt ; this . shift = shift ; this . root = root ; this . tail = tail ; } PersistentVector ( IPersistentMap meta , int cnt , int shift , Node root , Object [ ] tail ) { this . _meta = meta ; this . cnt = cnt ; this . shift = shift ; this . root = root ; this . tail = tail ; } public TransientVector asTransient ( ) { return new TransientVector ( this ) ; } final int tailoff ( ) { if ( cnt < <int> ) return <int> ; return ( ( cnt - <int> ) > > > <int> ) < < <int> ; } public Object [ ] arrayFor ( int i ) { if ( i > = <int> & & i < cnt ) { if ( i > = tailoff ( ) ) return tail ; Node node = root ; for ( int level = shift ; level > <int> ; level - = <int> ) node = ( Node ) node . array [ ( i > > > level ) & <hex> ] ; return node . array ; } throw new IndexOutOfBoundsException ( ) ; } public Object nth ( int i ) { Object [ ] node = arrayFor ( i ) ; return node [ i & <hex> ] ; } public Object nth ( int i , Object notFound ) { if ( i > = <int> & & i < cnt ) return nth ( i ) ; return notFound ; } public PersistentVector assocN ( int i , Object val ) { if ( i > = <int> & & i < cnt ) { if ( i > = tailoff ( ) ) { Object [ ] newTail = new Object [ tail . length ] ; System . arraycopy ( tail , <int> , newTail , <int> , tail . length ) ; newTail [ i & <hex> ] = val ; return new PersistentVector ( meta ( ) , cnt , shift , root , newTail ) ; } return new PersistentVector ( meta ( ) , cnt , shift , doAssoc ( shift , root , i , val ) , tail ) ; } if ( i = = cnt ) return cons ( val ) ; throw new IndexOutOfBoundsException ( ) ; } private static Node doAssoc ( int level , Node node , int i , Object val ) { Node ret = new Node ( node . edit , node . array . clone ( ) ) ; if ( level = = <int> ) { ret . array [ i & <hex> ] = val ; } else { int subidx = ( i > > > level ) & <hex> ; ret . array [ subidx ] = doAssoc ( level - <int> , ( Node ) node . array [ subidx ] , i , val ) ; } return ret ; } public int count ( ) { return cnt ; } public PersistentVector withMeta ( IPersistentMap meta ) { return new PersistentVector ( meta , cnt , shift , root , tail ) ; } public IPersistentMap meta ( ) { return _meta ; } public PersistentVector cons ( Object val ) { if ( cnt - tailoff ( ) < <int> ) { Object [ ] newTail = new Object [ tail . length + <int> ] ; System . arraycopy ( tail , <int> , newTail , <int> , tail . length ) ; newTail [ tail . length ] = val ; return new PersistentVector ( meta ( ) , cnt + <int> , shift , root , newTail ) ; } Node newroot ; Node tailnode = new Node ( root . edit , tail ) ; int newshift = shift ; if ( ( cnt > > > <int> ) > ( <int> < < shift ) ) { newroot = new Node ( root . edit ) ; newroot . array [ <int> ] = root ; newroot . array [ <int> ] = newPath ( root . edit , shift , tailnode ) ; newshift + = <int> ; } else newroot = pushTail ( shift , root , tailnode ) ; return new PersistentVector ( meta ( ) , cnt + <int> , newshift , newroot , new Object [ ] { val } ) ; } private Node pushTail ( int level , Node parent , Node tailnode ) { int subidx = ( ( cnt - <int> ) > > > level ) & <hex> ; Node ret = new Node ( parent . edit , parent . array . clone ( ) ) ; Node nodeToInsert ; if ( level = = <int> ) { nodeToInsert = tailnode ; } else { Node child = ( Node ) parent . array [ subidx ] ; nodeToInsert = ( child ! = null ) ? pushTail ( level - <int> , child , tailnode ) : newPath ( root . edit , level - <int> , tailnode ) ; } ret . array [ subidx ] = nodeToInsert ; return ret ; } private static Node newPath ( AtomicReference < Thread > edit , int level , Node node ) { if ( level = = <int> ) return node ; Node ret = new Node ( edit ) ; ret . array [ <int> ] = newPath ( edit , level - <int> , node ) ; return ret ; } public IChunkedSeq chunkedSeq ( ) { if ( count ( ) = = <int> ) return null ; return new ChunkedSeq ( this , <int> , <int> ) ; } public ISeq seq ( ) { return chunkedSeq ( ) ; } @Override Iterator rangedIterator ( final int start , final int end ) { return new Iterator ( ) { int i = start ; int base = i - ( i % <int> ) ; Object [ ] array = ( start < count ( ) ) ? arrayFor ( i ) : null ; public boolean hasNext ( ) { return i < end ; } public Object next ( ) { if ( i < end ) { if ( i - base = = <int> ) { array = arrayFor ( i ) ; base + = <int> ; } return array [ i + + & <hex> ] ; } else { throw new NoSuchElementException ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public Iterator iterator ( ) { return rangedIterator ( <int> , count ( ) ) ; } public Object reduce ( IFn f ) { Object init ; if ( cnt > <int> ) init = arrayFor ( <int> ) [ <int> ] ; else return f . invoke ( ) ; int step = <int> ; for ( int i = <int> ; i < cnt ; i + = step ) { Object [ ] array = arrayFor ( i ) ; for ( int j = ( i = = <int> ) ? <int> : <int> ; j < array . length ; + + j ) { init = f . invoke ( init , array [ j ] ) ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; } step = array . length ; } return init ; } public Object reduce ( IFn f , Object init ) { int step = <int> ; for ( int i = <int> ; i < cnt ; i + = step ) { Object [ ] array = arrayFor ( i ) ; for ( int j = <int> ; j < array . length ; + + j ) { init = f . invoke ( init , array [ j ] ) ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; } step = array . length ; } return init ; } public Object kvreduce ( IFn f , Object init ) { int step = <int> ; for ( int i = <int> ; i < cnt ; i + = step ) { Object [ ] array = arrayFor ( i ) ; for ( int j = <int> ; j < array . length ; + + j ) { init = f . invoke ( init , j + i , array [ j ] ) ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; } step = array . length ; } return init ; } static public final class ChunkedSeq extends ASeq implements IChunkedSeq , Counted { public final PersistentVector vec ; final Object [ ] node ; final int i ; public final int offset ; public ChunkedSeq ( PersistentVector vec , int i , int offset ) { this . vec = vec ; this . i = i ; this . offset = offset ; this . node = vec . arrayFor ( i ) ; } ChunkedSeq ( IPersistentMap meta , PersistentVector vec , Object [ ] node , int i , int offset ) { super ( meta ) ; this . vec = vec ; this . node = node ; this . i = i ; this . offset = offset ; } ChunkedSeq ( PersistentVector vec , Object [ ] node , int i , int offset ) { this . vec = vec ; this . node = node ; this . i = i ; this . offset = offset ; } public IChunk chunkedFirst ( ) { return new ArrayChunk ( node , offset ) ; } public ISeq chunkedNext ( ) { if ( i + node . length < vec . cnt ) return new ChunkedSeq ( vec , i + node . length , <int> ) ; return null ; } public ISeq chunkedMore ( ) { ISeq s = chunkedNext ( ) ; if ( s = = null ) return PersistentList . EMPTY ; return s ; } public Obj withMeta ( IPersistentMap meta ) { if ( meta = = this . _meta ) return this ; return new ChunkedSeq ( meta , vec , node , i , offset ) ; } public Object first ( ) { return node [ offset ] ; } public ISeq next ( ) { if ( offset + <int> < node . length ) return new ChunkedSeq ( vec , node , i , offset + <int> ) ; return chunkedNext ( ) ; } public int count ( ) { return vec . cnt - ( i + offset ) ; } } public IPersistentCollection empty ( ) { return EMPTY . withMeta ( meta ( ) ) ; } public PersistentVector pop ( ) { if ( cnt = = <int> ) throw new IllegalStateException ( <str> ) ; if ( cnt = = <int> ) return EMPTY . withMeta ( meta ( ) ) ; if ( cnt - tailoff ( ) > <int> ) { Object [ ] newTail = new Object [ tail . length - <int> ] ; System . arraycopy ( tail , <int> , newTail , <int> , newTail . length ) ; return new PersistentVector ( meta ( ) , cnt - <int> , shift , root , newTail ) ; } Object [ ] newtail = arrayFor ( cnt - <int> ) ; Node newroot = popTail ( shift , root ) ; int newshift = shift ; if ( newroot = = null ) { newroot = EMPTY_NODE ; } if ( shift > <int> & & newroot . array [ <int> ] = = null ) { newroot = ( Node ) newroot . array [ <int> ] ; newshift - = <int> ; } return new PersistentVector ( meta ( ) , cnt - <int> , newshift , newroot , newtail ) ; } private Node popTail ( int level , Node node ) { int subidx = ( ( cnt - <int> ) > > > level ) & <hex> ; if ( level > <int> ) { Node newchild = popTail ( level - <int> , ( Node ) node . array [ subidx ] ) ; if ( newchild = = null & & subidx = = <int> ) return null ; else { Node ret = new Node ( root . edit , node . array . clone ( ) ) ; ret . array [ subidx ] = newchild ; return ret ; } } else if ( subidx = = <int> ) return null ; else { Node ret = new Node ( root . edit , node . array . clone ( ) ) ; ret . array [ subidx ] = null ; return ret ; } } static final class TransientVector extends AFn implements ITransientVector , Counted { volatile int cnt ; volatile int shift ; volatile Node root ; volatile Object [ ] tail ; TransientVector ( int cnt , int shift , Node root , Object [ ] tail ) { this . cnt = cnt ; this . shift = shift ; this . root = root ; this . tail = tail ; } TransientVector ( PersistentVector v ) { this ( v . cnt , v . shift , editableRoot ( v . root ) , editableTail ( v . tail ) ) ; } public int count ( ) { ensureEditable ( ) ; return cnt ; } Node ensureEditable ( Node node ) { if ( node . edit = = root . edit ) return node ; return new Node ( root . edit , node . array . clone ( ) ) ; } void ensureEditable ( ) { if ( root . edit . get ( ) = = null ) throw new IllegalAccessError ( <str> ) ; } static Node editableRoot ( Node node ) { return new Node ( new AtomicReference < Thread > ( Thread . currentThread ( ) ) , node . array . clone ( ) ) ; } public PersistentVector persistent ( ) { ensureEditable ( ) ; root . edit . set ( null ) ; Object [ ] trimmedTail = new Object [ cnt - tailoff ( ) ] ; System . arraycopy ( tail , <int> , trimmedTail , <int> , trimmedTail . length ) ; return new PersistentVector ( cnt , shift , root , trimmedTail ) ; } static Object [ ] editableTail ( Object [ ] tl ) { Object [ ] ret = new Object [ <int> ] ; System . arraycopy ( tl , <int> , ret , <int> , tl . length ) ; return ret ; } public TransientVector conj ( Object val ) { ensureEditable ( ) ; int i = cnt ; if ( i - tailoff ( ) < <int> ) { tail [ i & <hex> ] = val ; + + cnt ; return this ; } Node newroot ; Node tailnode = new Node ( root . edit , tail ) ; tail = new Object [ <int> ] ; tail [ <int> ] = val ; int newshift = shift ; if ( ( cnt > > > <int> ) > ( <int> < < shift ) ) { newroot = new Node ( root . edit ) ; newroot . array [ <int> ] = root ; newroot . array [ <int> ] = newPath ( root . edit , shift , tailnode ) ; newshift + = <int> ; } else newroot = pushTail ( shift , root , tailnode ) ; root = newroot ; shift = newshift ; + + cnt ; return this ; } private Node pushTail ( int level , Node parent , Node tailnode ) { parent = ensureEditable ( parent ) ; int subidx = ( ( cnt - <int> ) > > > level ) & <hex> ; Node ret = parent ; Node nodeToInsert ; if ( level = = <int> ) { nodeToInsert = tailnode ; } else { Node child = ( Node ) parent . array [ subidx ] ; nodeToInsert = ( child ! = null ) ? pushTail ( level - <int> , child , tailnode ) : newPath ( root . edit , level - <int> , tailnode ) ; } ret . array [ subidx ] = nodeToInsert ; return ret ; } final private int tailoff ( ) { if ( cnt < <int> ) return <int> ; return ( ( cnt - <int> ) > > > <int> ) < < <int> ; } private Object [ ] arrayFor ( int i ) { if ( i > = <int> & & i < cnt ) { if ( i > = tailoff ( ) ) return tail ; Node node = root ; for ( int level = shift ; level > <int> ; level - = <int> ) node = ( Node ) node . array [ ( i > > > level ) & <hex> ] ; return node . array ; } throw new IndexOutOfBoundsException ( ) ; } private Object [ ] editableArrayFor ( int i ) { if ( i > = <int> & & i < cnt ) { if ( i > = tailoff ( ) ) return tail ; Node node = root ; for ( int level = shift ; level > <int> ; level - = <int> ) node = ensureEditable ( ( Node ) node . array [ ( i > > > level ) & <hex> ] ) ; return node . array ; } throw new IndexOutOfBoundsException ( ) ; } public Object valAt ( Object key ) { return valAt ( key , null ) ; } public Object valAt ( Object key , Object notFound ) { ensureEditable ( ) ; if ( Util . isInteger ( key ) ) { int i = ( ( Number ) key ) . intValue ( ) ; if ( i > = <int> & & i < cnt ) return nth ( i ) ; } return notFound ; } public Object invoke ( Object arg1 ) { if ( Util . isInteger ( arg1 ) ) return nth ( ( ( Number ) arg1 ) . intValue ( ) ) ; throw new IllegalArgumentException ( <str> ) ; } public Object nth ( int i ) { ensureEditable ( ) ; Object [ ] node = arrayFor ( i ) ; return node [ i & <hex> ] ; } public Object nth ( int i , Object notFound ) { if ( i > = <int> & & i < count ( ) ) return nth ( i ) ; return notFound ; } public TransientVector assocN ( int i , Object val ) { ensureEditable ( ) ; if ( i > = <int> & & i < cnt ) { if ( i > = tailoff ( ) ) { tail [ i & <hex> ] = val ; return this ; } root = doAssoc ( shift , root , i , val ) ; return this ; } if ( i = = cnt ) return conj ( val ) ; throw new IndexOutOfBoundsException ( ) ; } public TransientVector assoc ( Object key , Object val ) { if ( Util . isInteger ( key ) ) { int i = ( ( Number ) key ) . intValue ( ) ; return assocN ( i , val ) ; } throw new IllegalArgumentException ( <str> ) ; } private Node doAssoc ( int level , Node node , int i , Object val ) { node = ensureEditable ( node ) ; Node ret = node ; if ( level = = <int> ) { ret . array [ i & <hex> ] = val ; } else { int subidx = ( i > > > level ) & <hex> ; ret . array [ subidx ] = doAssoc ( level - <int> , ( Node ) node . array [ subidx ] , i , val ) ; } return ret ; } public TransientVector pop ( ) { ensureEditable ( ) ; if ( cnt = = <int> ) throw new IllegalStateException ( <str> ) ; if ( cnt = = <int> ) { cnt = <int> ; return this ; } int i = cnt - <int> ; if ( ( i & <hex> ) > <int> ) { - - cnt ; return this ; } Object [ ] newtail = editableArrayFor ( cnt - <int> ) ; Node newroot = popTail ( shift , root ) ; int newshift = shift ; if ( newroot = = null ) { newroot = new Node ( root . edit ) ; } if ( shift > <int> & & newroot . array [ <int> ] = = null ) { newroot = ensureEditable ( ( Node ) newroot . array [ <int> ] ) ; newshift - = <int> ; } root = newroot ; shift = newshift ; - - cnt ; tail = newtail ; return this ; } private Node popTail ( int level , Node node ) { node = ensureEditable ( node ) ; int subidx = ( ( cnt - <int> ) > > > level ) & <hex> ; if ( level > <int> ) { Node newchild = popTail ( level - <int> , ( Node ) node . array [ subidx ] ) ; if ( newchild = = null & & subidx = = <int> ) return null ; else { Node ret = node ; ret . array [ subidx ] = newchild ; return ret ; } } else if ( subidx = = <int> ) return null ; else { Node ret = node ; ret . array [ subidx ] = null ; return ret ; } } } } 
