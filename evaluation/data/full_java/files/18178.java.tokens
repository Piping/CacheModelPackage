package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . Array ; public class BSpline < T extends Vector < T > > implements Path < T > { private final static float d6 = <float> / <float> ; public static < T extends Vector < T > > T cubic ( final T out , final float t , final T [ ] points , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - <int> ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return cubic ( out , i , u , points , continuous , tmp ) ; } public static < T extends Vector < T > > T cubic_derivative ( final T out , final float t , final T [ ] points , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - <int> ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return cubic ( out , i , u , points , continuous , tmp ) ; } public static < T extends Vector < T > > T cubic ( final T out , final int i , final float u , final T [ ] points , final boolean continuous , final T tmp ) { final int n = points . length ; final float dt = <float> - u ; final float t2 = u * u ; final float t3 = t2 * u ; out . set ( points [ i ] ) . scl ( ( <float> * t3 - <float> * t2 + <float> ) * d6 ) ; if ( continuous | | i > <int> ) out . add ( tmp . set ( points [ ( n + i - <int> ) % n ] ) . scl ( dt * dt * dt * d6 ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( ( - <float> * t3 + <float> * t2 + <float> * u + <float> ) * d6 ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( t3 * d6 ) ) ; return out ; } public static < T extends Vector < T > > T cubic_derivative ( final T out , final int i , final float u , final T [ ] points , final boolean continuous , final T tmp ) { final int n = points . length ; final float dt = <float> - u ; final float t2 = u * u ; final float t3 = t2 * u ; out . set ( points [ i ] ) . scl ( <float> * t2 - <int> * u ) ; if ( continuous | | i > <int> ) out . add ( tmp . set ( points [ ( n + i - <int> ) % n ] ) . scl ( <float> * ( <int> - u ) * ( <int> - u ) ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( - <float> * t2 + u + <float> ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( <float> * t2 ) ) ; return out ; } public static < T extends Vector < T > > T calculate ( final T out , final float t , final T [ ] points , final int degree , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - degree ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return calculate ( out , i , u , points , degree , continuous , tmp ) ; } public static < T extends Vector < T > > T derivative ( final T out , final float t , final T [ ] points , final int degree , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - degree ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return derivative ( out , i , u , points , degree , continuous , tmp ) ; } public static < T extends Vector < T > > T calculate ( final T out , final int i , final float u , final T [ ] points , final int degree , final boolean continuous , final T tmp ) { switch ( degree ) { case <int> : return cubic ( out , i , u , points , continuous , tmp ) ; } return out ; } public static < T extends Vector < T > > T derivative ( final T out , final int i , final float u , final T [ ] points , final int degree , final boolean continuous , final T tmp ) { switch ( degree ) { case <int> : return cubic_derivative ( out , i , u , points , continuous , tmp ) ; } return out ; } public T [ ] controlPoints ; public Array < T > knots ; public int degree ; public boolean continuous ; public int spanCount ; private T tmp ; private T tmp2 ; private T tmp3 ; public BSpline ( ) { } public BSpline ( final T [ ] controlPoints , final int degree , final boolean continuous ) { set ( controlPoints , degree , continuous ) ; } public BSpline set ( final T [ ] controlPoints , final int degree , final boolean continuous ) { if ( tmp = = null ) tmp = controlPoints [ <int> ] . cpy ( ) ; if ( tmp2 = = null ) tmp2 = controlPoints [ <int> ] . cpy ( ) ; if ( tmp3 = = null ) tmp3 = controlPoints [ <int> ] . cpy ( ) ; this . controlPoints = controlPoints ; this . degree = degree ; this . continuous = continuous ; this . spanCount = continuous ? controlPoints . length : controlPoints . length - degree ; if ( knots = = null ) knots = new Array < T > ( spanCount ) ; else { knots . clear ( ) ; knots . ensureCapacity ( spanCount ) ; } for ( int i = <int> ; i < spanCount ; i + + ) knots . add ( calculate ( controlPoints [ <int> ] . cpy ( ) , continuous ? i : ( int ) ( i + <float> * degree ) , <float> , controlPoints , degree , continuous , tmp ) ) ; return this ; } @Override public T valueAt ( T out , float t ) { final int n = spanCount ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return valueAt ( out , i , u ) ; } public T valueAt ( final T out , final int span , final float u ) { return calculate ( out , continuous ? span : ( span + ( int ) ( degree * <float> ) ) , u , controlPoints , degree , continuous , tmp ) ; } @Override public T derivativeAt ( final T out , final float t ) { final int n = spanCount ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return derivativeAt ( out , i , u ) ; } public T derivativeAt ( final T out , final int span , final float u ) { return derivative ( out , continuous ? span : ( span + ( int ) ( degree * <float> ) ) , u , controlPoints , degree , continuous , tmp ) ; } public int nearest ( final T in ) { return nearest ( in , <int> , spanCount ) ; } public int nearest ( final T in , int start , final int count ) { while ( start < <int> ) start + = spanCount ; int result = start % spanCount ; float dst = in . dst2 ( knots . get ( result ) ) ; for ( int i = <int> ; i < count ; i + + ) { final int idx = ( start + i ) % spanCount ; final float d = in . dst2 ( knots . get ( idx ) ) ; if ( d < dst ) { dst = d ; result = idx ; } } return result ; } @Override public float approximate ( T v ) { return approximate ( v , nearest ( v ) ) ; } public float approximate ( final T in , int start , final int count ) { return approximate ( in , nearest ( in , start , count ) ) ; } public float approximate ( final T in , final int near ) { int n = near ; final T nearest = knots . get ( n ) ; final T previous = knots . get ( n > <int> ? n - <int> : spanCount - <int> ) ; final T next = knots . get ( ( n + <int> ) % spanCount ) ; final float dstPrev2 = in . dst2 ( previous ) ; final float dstNext2 = in . dst2 ( next ) ; T P1 , P2 , P3 ; if ( dstNext2 < dstPrev2 ) { P1 = nearest ; P2 = next ; P3 = in ; } else { P1 = previous ; P2 = nearest ; P3 = in ; n = n > <int> ? n - <int> : spanCount - <int> ; } float L1Sqr = P1 . dst2 ( P2 ) ; float L2Sqr = P3 . dst2 ( P2 ) ; float L3Sqr = P3 . dst2 ( P1 ) ; float L1 = ( float ) Math . sqrt ( L1Sqr ) ; float s = ( L2Sqr + L1Sqr - L3Sqr ) / ( <int> * L1 ) ; float u = MathUtils . clamp ( ( L1 - s ) / L1 , <float> , <float> ) ; return ( n + u ) / spanCount ; } @Override public float locate ( T v ) { return approximate ( v ) ; } @Override public float approxLength ( int samples ) { float tempLength = <int> ; for ( int i = <int> ; i < samples ; + + i ) { tmp2 . set ( tmp3 ) ; valueAt ( tmp3 , ( i ) / ( ( float ) samples - <int> ) ) ; if ( i > <int> ) tempLength + = tmp2 . dst ( tmp3 ) ; } return tempLength ; } } 
