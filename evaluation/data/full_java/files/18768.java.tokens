package io . netty . buffer ; import io . netty . util . Recycler ; import io . netty . util . Recycler . Handle ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; abstract class PooledByteBuf < T > extends AbstractReferenceCountedByteBuf { private final Recycler . Handle < PooledByteBuf < T > > recyclerHandle ; protected PoolChunk < T > chunk ; protected long handle ; protected T memory ; protected int offset ; protected int length ; int maxLength ; PoolThreadCache cache ; private ByteBuffer tmpNioBuf ; @SuppressWarnings ( <str> ) protected PooledByteBuf ( Recycler . Handle < ? extends PooledByteBuf < T > > recyclerHandle , int maxCapacity ) { super ( maxCapacity ) ; this . recyclerHandle = ( Handle < PooledByteBuf < T > > ) recyclerHandle ; } void init ( PoolChunk < T > chunk , long handle , int offset , int length , int maxLength , PoolThreadCache cache ) { assert handle > = <int> ; assert chunk ! = null ; this . chunk = chunk ; this . handle = handle ; memory = chunk . memory ; this . offset = offset ; this . length = length ; this . maxLength = maxLength ; tmpNioBuf = null ; this . cache = cache ; } void initUnpooled ( PoolChunk < T > chunk , int length ) { assert chunk ! = null ; this . chunk = chunk ; handle = <int> ; memory = chunk . memory ; offset = <int> ; this . length = maxLength = length ; tmpNioBuf = null ; cache = null ; } final void reuse ( int maxCapacity ) { maxCapacity ( maxCapacity ) ; setRefCnt ( <int> ) ; setIndex0 ( <int> , <int> ) ; discardMarks ( ) ; } @Override public final int capacity ( ) { return length ; } @Override public final ByteBuf capacity ( int newCapacity ) { ensureAccessible ( ) ; if ( chunk . unpooled ) { if ( newCapacity = = length ) { return this ; } } else { if ( newCapacity > length ) { if ( newCapacity < = maxLength ) { length = newCapacity ; return this ; } } else if ( newCapacity < length ) { if ( newCapacity > maxLength > > > <int> ) { if ( maxLength < = <int> ) { if ( newCapacity > maxLength - <int> ) { length = newCapacity ; setIndex ( Math . min ( readerIndex ( ) , newCapacity ) , Math . min ( writerIndex ( ) , newCapacity ) ) ; return this ; } } else { length = newCapacity ; setIndex ( Math . min ( readerIndex ( ) , newCapacity ) , Math . min ( writerIndex ( ) , newCapacity ) ) ; return this ; } } } else { return this ; } } chunk . arena . reallocate ( this , newCapacity , true ) ; return this ; } @Override public final ByteBufAllocator alloc ( ) { return chunk . arena . parent ; } @Override public final ByteOrder order ( ) { return ByteOrder . BIG_ENDIAN ; } @Override public final ByteBuf unwrap ( ) { return null ; } protected final ByteBuffer internalNioBuffer ( ) { ByteBuffer tmpNioBuf = this . tmpNioBuf ; if ( tmpNioBuf = = null ) { this . tmpNioBuf = tmpNioBuf = newInternalNioBuffer ( memory ) ; } return tmpNioBuf ; } protected abstract ByteBuffer newInternalNioBuffer ( T memory ) ; @Override protected final void deallocate ( ) { if ( handle > = <int> ) { final long handle = this . handle ; this . handle = - <int> ; memory = null ; chunk . arena . free ( chunk , handle , maxLength , cache ) ; recycle ( ) ; } } private void recycle ( ) { recyclerHandle . recycle ( this ) ; } protected final int idx ( int index ) { return offset + index ; } } 
