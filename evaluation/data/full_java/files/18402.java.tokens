package com . badlogic . gdx . utils . compression . lz ; import java . io . IOException ; public class BinTree extends InWindow { int _cyclicBufferPos ; int _cyclicBufferSize = <int> ; int _matchMaxLen ; int [ ] _son ; int [ ] _hash ; int _cutValue = <hex> ; int _hashMask ; int _hashSizeSum = <int> ; boolean HASH_ARRAY = true ; static final int kHash2Size = <int> < < <int> ; static final int kHash3Size = <int> < < <int> ; static final int kBT2HashSize = <int> < < <int> ; static final int kStartMaxLen = <int> ; static final int kHash3Offset = kHash2Size ; static final int kEmptyHashValue = <int> ; static final int kMaxValForNormalize = ( <int> < < <int> ) - <int> ; int kNumHashDirectBytes = <int> ; int kMinMatchCheck = <int> ; int kFixHashSize = kHash2Size + kHash3Size ; public void SetType ( int numHashBytes ) { HASH_ARRAY = ( numHashBytes > <int> ) ; if ( HASH_ARRAY ) { kNumHashDirectBytes = <int> ; kMinMatchCheck = <int> ; kFixHashSize = kHash2Size + kHash3Size ; } else { kNumHashDirectBytes = <int> ; kMinMatchCheck = <int> + <int> ; kFixHashSize = <int> ; } } public void Init ( ) throws IOException { super . Init ( ) ; for ( int i = <int> ; i < _hashSizeSum ; i + + ) _hash [ i ] = kEmptyHashValue ; _cyclicBufferPos = <int> ; ReduceOffsets ( - <int> ) ; } public void MovePos ( ) throws IOException { if ( + + _cyclicBufferPos > = _cyclicBufferSize ) _cyclicBufferPos = <int> ; super . MovePos ( ) ; if ( _pos = = kMaxValForNormalize ) Normalize ( ) ; } public boolean Create ( int historySize , int keepAddBufferBefore , int matchMaxLen , int keepAddBufferAfter ) { if ( historySize > kMaxValForNormalize - <int> ) return false ; _cutValue = <int> + ( matchMaxLen > > <int> ) ; int windowReservSize = ( historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter ) / <int> + <int> ; super . Create ( historySize + keepAddBufferBefore , matchMaxLen + keepAddBufferAfter , windowReservSize ) ; _matchMaxLen = matchMaxLen ; int cyclicBufferSize = historySize + <int> ; if ( _cyclicBufferSize ! = cyclicBufferSize ) _son = new int [ ( _cyclicBufferSize = cyclicBufferSize ) * <int> ] ; int hs = kBT2HashSize ; if ( HASH_ARRAY ) { hs = historySize - <int> ; hs | = ( hs > > <int> ) ; hs | = ( hs > > <int> ) ; hs | = ( hs > > <int> ) ; hs | = ( hs > > <int> ) ; hs > > = <int> ; hs | = <hex> ; if ( hs > ( <int> < < <int> ) ) hs > > = <int> ; _hashMask = hs ; hs + + ; hs + = kFixHashSize ; } if ( hs ! = _hashSizeSum ) _hash = new int [ _hashSizeSum = hs ] ; return true ; } public int GetMatches ( int [ ] distances ) throws IOException { int lenLimit ; if ( _pos + _matchMaxLen < = _streamPos ) lenLimit = _matchMaxLen ; else { lenLimit = _streamPos - _pos ; if ( lenLimit < kMinMatchCheck ) { MovePos ( ) ; return <int> ; } } int offset = <int> ; int matchMinPos = ( _pos > _cyclicBufferSize ) ? ( _pos - _cyclicBufferSize ) : <int> ; int cur = _bufferOffset + _pos ; int maxLen = kStartMaxLen ; int hashValue , hash2Value = <int> , hash3Value = <int> ; if ( HASH_ARRAY ) { int temp = CrcTable [ _bufferBase [ cur ] & <hex> ] ^ ( _bufferBase [ cur + <int> ] & <hex> ) ; hash2Value = temp & ( kHash2Size - <int> ) ; temp ^ = ( ( int ) ( _bufferBase [ cur + <int> ] & <hex> ) < < <int> ) ; hash3Value = temp & ( kHash3Size - <int> ) ; hashValue = ( temp ^ ( CrcTable [ _bufferBase [ cur + <int> ] & <hex> ] < < <int> ) ) & _hashMask ; } else hashValue = ( ( _bufferBase [ cur ] & <hex> ) ^ ( ( int ) ( _bufferBase [ cur + <int> ] & <hex> ) < < <int> ) ) ; int curMatch = _hash [ kFixHashSize + hashValue ] ; if ( HASH_ARRAY ) { int curMatch2 = _hash [ hash2Value ] ; int curMatch3 = _hash [ kHash3Offset + hash3Value ] ; _hash [ hash2Value ] = _pos ; _hash [ kHash3Offset + hash3Value ] = _pos ; if ( curMatch2 > matchMinPos ) if ( _bufferBase [ _bufferOffset + curMatch2 ] = = _bufferBase [ cur ] ) { distances [ offset + + ] = maxLen = <int> ; distances [ offset + + ] = _pos - curMatch2 - <int> ; } if ( curMatch3 > matchMinPos ) if ( _bufferBase [ _bufferOffset + curMatch3 ] = = _bufferBase [ cur ] ) { if ( curMatch3 = = curMatch2 ) offset - = <int> ; distances [ offset + + ] = maxLen = <int> ; distances [ offset + + ] = _pos - curMatch3 - <int> ; curMatch2 = curMatch3 ; } if ( offset ! = <int> & & curMatch2 = = curMatch ) { offset - = <int> ; maxLen = kStartMaxLen ; } } _hash [ kFixHashSize + hashValue ] = _pos ; int ptr0 = ( _cyclicBufferPos < < <int> ) + <int> ; int ptr1 = ( _cyclicBufferPos < < <int> ) ; int len0 , len1 ; len0 = len1 = kNumHashDirectBytes ; if ( kNumHashDirectBytes ! = <int> ) { if ( curMatch > matchMinPos ) { if ( _bufferBase [ _bufferOffset + curMatch + kNumHashDirectBytes ] ! = _bufferBase [ cur + kNumHashDirectBytes ] ) { distances [ offset + + ] = maxLen = kNumHashDirectBytes ; distances [ offset + + ] = _pos - curMatch - <int> ; } } } int count = _cutValue ; while ( true ) { if ( curMatch < = matchMinPos | | count - - = = <int> ) { _son [ ptr0 ] = _son [ ptr1 ] = kEmptyHashValue ; break ; } int delta = _pos - curMatch ; int cyclicPos = ( ( delta < = _cyclicBufferPos ) ? ( _cyclicBufferPos - delta ) : ( _cyclicBufferPos - delta + _cyclicBufferSize ) ) < < <int> ; int pby1 = _bufferOffset + curMatch ; int len = Math . min ( len0 , len1 ) ; if ( _bufferBase [ pby1 + len ] = = _bufferBase [ cur + len ] ) { while ( + + len ! = lenLimit ) if ( _bufferBase [ pby1 + len ] ! = _bufferBase [ cur + len ] ) break ; if ( maxLen < len ) { distances [ offset + + ] = maxLen = len ; distances [ offset + + ] = delta - <int> ; if ( len = = lenLimit ) { _son [ ptr1 ] = _son [ cyclicPos ] ; _son [ ptr0 ] = _son [ cyclicPos + <int> ] ; break ; } } } if ( ( _bufferBase [ pby1 + len ] & <hex> ) < ( _bufferBase [ cur + len ] & <hex> ) ) { _son [ ptr1 ] = curMatch ; ptr1 = cyclicPos + <int> ; curMatch = _son [ ptr1 ] ; len1 = len ; } else { _son [ ptr0 ] = curMatch ; ptr0 = cyclicPos ; curMatch = _son [ ptr0 ] ; len0 = len ; } } MovePos ( ) ; return offset ; } public void Skip ( int num ) throws IOException { do { int lenLimit ; if ( _pos + _matchMaxLen < = _streamPos ) lenLimit = _matchMaxLen ; else { lenLimit = _streamPos - _pos ; if ( lenLimit < kMinMatchCheck ) { MovePos ( ) ; continue ; } } int matchMinPos = ( _pos > _cyclicBufferSize ) ? ( _pos - _cyclicBufferSize ) : <int> ; int cur = _bufferOffset + _pos ; int hashValue ; if ( HASH_ARRAY ) { int temp = CrcTable [ _bufferBase [ cur ] & <hex> ] ^ ( _bufferBase [ cur + <int> ] & <hex> ) ; int hash2Value = temp & ( kHash2Size - <int> ) ; _hash [ hash2Value ] = _pos ; temp ^ = ( ( int ) ( _bufferBase [ cur + <int> ] & <hex> ) < < <int> ) ; int hash3Value = temp & ( kHash3Size - <int> ) ; _hash [ kHash3Offset + hash3Value ] = _pos ; hashValue = ( temp ^ ( CrcTable [ _bufferBase [ cur + <int> ] & <hex> ] < < <int> ) ) & _hashMask ; } else hashValue = ( ( _bufferBase [ cur ] & <hex> ) ^ ( ( int ) ( _bufferBase [ cur + <int> ] & <hex> ) < < <int> ) ) ; int curMatch = _hash [ kFixHashSize + hashValue ] ; _hash [ kFixHashSize + hashValue ] = _pos ; int ptr0 = ( _cyclicBufferPos < < <int> ) + <int> ; int ptr1 = ( _cyclicBufferPos < < <int> ) ; int len0 , len1 ; len0 = len1 = kNumHashDirectBytes ; int count = _cutValue ; while ( true ) { if ( curMatch < = matchMinPos | | count - - = = <int> ) { _son [ ptr0 ] = _son [ ptr1 ] = kEmptyHashValue ; break ; } int delta = _pos - curMatch ; int cyclicPos = ( ( delta < = _cyclicBufferPos ) ? ( _cyclicBufferPos - delta ) : ( _cyclicBufferPos - delta + _cyclicBufferSize ) ) < < <int> ; int pby1 = _bufferOffset + curMatch ; int len = Math . min ( len0 , len1 ) ; if ( _bufferBase [ pby1 + len ] = = _bufferBase [ cur + len ] ) { while ( + + len ! = lenLimit ) if ( _bufferBase [ pby1 + len ] ! = _bufferBase [ cur + len ] ) break ; if ( len = = lenLimit ) { _son [ ptr1 ] = _son [ cyclicPos ] ; _son [ ptr0 ] = _son [ cyclicPos + <int> ] ; break ; } } if ( ( _bufferBase [ pby1 + len ] & <hex> ) < ( _bufferBase [ cur + len ] & <hex> ) ) { _son [ ptr1 ] = curMatch ; ptr1 = cyclicPos + <int> ; curMatch = _son [ ptr1 ] ; len1 = len ; } else { _son [ ptr0 ] = curMatch ; ptr0 = cyclicPos ; curMatch = _son [ ptr0 ] ; len0 = len ; } } MovePos ( ) ; } while ( - - num ! = <int> ) ; } void NormalizeLinks ( int [ ] items , int numItems , int subValue ) { for ( int i = <int> ; i < numItems ; i + + ) { int value = items [ i ] ; if ( value < = subValue ) value = kEmptyHashValue ; else value - = subValue ; items [ i ] = value ; } } void Normalize ( ) { int subValue = _pos - _cyclicBufferSize ; NormalizeLinks ( _son , _cyclicBufferSize * <int> , subValue ) ; NormalizeLinks ( _hash , _hashSizeSum , subValue ) ; ReduceOffsets ( subValue ) ; } public void SetCutValue ( int cutValue ) { _cutValue = cutValue ; } private static final int [ ] CrcTable = new int [ <int> ] ; static { for ( int i = <int> ; i < <int> ; i + + ) { int r = i ; for ( int j = <int> ; j < <int> ; j + + ) if ( ( r & <int> ) ! = <int> ) r = ( r > > > <int> ) ^ <hex> ; else r > > > = <int> ; CrcTable [ i ] = r ; } } } 
