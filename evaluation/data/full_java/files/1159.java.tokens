package org . apache . cassandra . transport ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . List ; import com . google . common . annotations . VisibleForTesting ; import io . netty . buffer . ByteBuf ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . utils . Pair ; public enum DataType implements OptionCodec . Codecable < DataType > { CUSTOM ( <int> , null , <int> ) , ASCII ( <int> , AsciiType . instance , <int> ) , BIGINT ( <int> , LongType . instance , <int> ) , BLOB ( <int> , BytesType . instance , <int> ) , BOOLEAN ( <int> , BooleanType . instance , <int> ) , COUNTER ( <int> , CounterColumnType . instance , <int> ) , DECIMAL ( <int> , DecimalType . instance , <int> ) , DOUBLE ( <int> , DoubleType . instance , <int> ) , FLOAT ( <int> , FloatType . instance , <int> ) , INT ( <int> , Int32Type . instance , <int> ) , TEXT ( <int> , UTF8Type . instance , <int> ) , TIMESTAMP ( <int> , TimestampType . instance , <int> ) , UUID ( <int> , UUIDType . instance , <int> ) , VARCHAR ( <int> , UTF8Type . instance , <int> ) , VARINT ( <int> , IntegerType . instance , <int> ) , TIMEUUID ( <int> , TimeUUIDType . instance , <int> ) , INET ( <int> , InetAddressType . instance , <int> ) , DATE ( <int> , SimpleDateType . instance , <int> ) , TIME ( <int> , TimeType . instance , <int> ) , SMALLINT ( <int> , ShortType . instance , <int> ) , BYTE ( <int> , ByteType . instance , <int> ) , LIST ( <int> , null , <int> ) , MAP ( <int> , null , <int> ) , SET ( <int> , null , <int> ) , UDT ( <int> , null , <int> ) , TUPLE ( <int> , null , <int> ) ; public static final OptionCodec < DataType > codec = new OptionCodec < DataType > ( DataType . class ) ; private final int id ; private final int protocolVersion ; private final AbstractType type ; private static final Map < AbstractType , DataType > dataTypeMap = new HashMap < AbstractType , DataType > ( ) ; static { for ( DataType type : DataType . values ( ) ) { if ( type . type ! = null ) dataTypeMap . put ( type . type , type ) ; } } DataType ( int id , AbstractType type , int protocolVersion ) { this . id = id ; this . type = type ; this . protocolVersion = protocolVersion ; } public int getId ( int version ) { if ( version < protocolVersion ) return DataType . CUSTOM . getId ( version ) ; return id ; } public Object readValue ( ByteBuf cb , int version ) { switch ( this ) { case CUSTOM : return CBUtil . readString ( cb ) ; case LIST : return DataType . toType ( codec . decodeOne ( cb , version ) ) ; case SET : return DataType . toType ( codec . decodeOne ( cb , version ) ) ; case MAP : List < AbstractType > l = new ArrayList < AbstractType > ( <int> ) ; l . add ( DataType . toType ( codec . decodeOne ( cb , version ) ) ) ; l . add ( DataType . toType ( codec . decodeOne ( cb , version ) ) ) ; return l ; case UDT : String ks = CBUtil . readString ( cb ) ; ByteBuffer name = UTF8Type . instance . decompose ( CBUtil . readString ( cb ) ) ; int n = cb . readUnsignedShort ( ) ; List < ByteBuffer > fieldNames = new ArrayList < > ( n ) ; List < AbstractType < ? > > fieldTypes = new ArrayList < > ( n ) ; for ( int i = <int> ; i < n ; i + + ) { fieldNames . add ( UTF8Type . instance . decompose ( CBUtil . readString ( cb ) ) ) ; fieldTypes . add ( DataType . toType ( codec . decodeOne ( cb , version ) ) ) ; } return new UserType ( ks , name , fieldNames , fieldTypes ) ; case TUPLE : n = cb . readUnsignedShort ( ) ; List < AbstractType < ? > > types = new ArrayList < > ( n ) ; for ( int i = <int> ; i < n ; i + + ) types . add ( DataType . toType ( codec . decodeOne ( cb , version ) ) ) ; return new TupleType ( types ) ; default : return null ; } } public void writeValue ( Object value , ByteBuf cb , int version ) { if ( version < protocolVersion ) { CBUtil . writeString ( value . toString ( ) , cb ) ; return ; } switch ( this ) { case CUSTOM : assert value instanceof String ; CBUtil . writeString ( ( String ) value , cb ) ; break ; case LIST : codec . writeOne ( DataType . fromType ( ( AbstractType ) value , version ) , cb , version ) ; break ; case SET : codec . writeOne ( DataType . fromType ( ( AbstractType ) value , version ) , cb , version ) ; break ; case MAP : List < AbstractType > l = ( List < AbstractType > ) value ; codec . writeOne ( DataType . fromType ( l . get ( <int> ) , version ) , cb , version ) ; codec . writeOne ( DataType . fromType ( l . get ( <int> ) , version ) , cb , version ) ; break ; case UDT : UserType udt = ( UserType ) value ; CBUtil . writeString ( udt . keyspace , cb ) ; CBUtil . writeString ( UTF8Type . instance . compose ( udt . name ) , cb ) ; cb . writeShort ( udt . size ( ) ) ; for ( int i = <int> ; i < udt . size ( ) ; i + + ) { CBUtil . writeString ( UTF8Type . instance . compose ( udt . fieldName ( i ) ) , cb ) ; codec . writeOne ( DataType . fromType ( udt . fieldType ( i ) , version ) , cb , version ) ; } break ; case TUPLE : TupleType tt = ( TupleType ) value ; cb . writeShort ( tt . size ( ) ) ; for ( int i = <int> ; i < tt . size ( ) ; i + + ) codec . writeOne ( DataType . fromType ( tt . type ( i ) , version ) , cb , version ) ; break ; } } public int serializedValueSize ( Object value , int version ) { if ( version < protocolVersion ) return CBUtil . sizeOfString ( value . toString ( ) ) ; switch ( this ) { case CUSTOM : return CBUtil . sizeOfString ( ( String ) value ) ; case LIST : case SET : return codec . oneSerializedSize ( DataType . fromType ( ( AbstractType ) value , version ) , version ) ; case MAP : List < AbstractType > l = ( List < AbstractType > ) value ; int s = <int> ; s + = codec . oneSerializedSize ( DataType . fromType ( l . get ( <int> ) , version ) , version ) ; s + = codec . oneSerializedSize ( DataType . fromType ( l . get ( <int> ) , version ) , version ) ; return s ; case UDT : UserType udt = ( UserType ) value ; int size = <int> ; size + = CBUtil . sizeOfString ( udt . keyspace ) ; size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . name ) ) ; size + = <int> ; for ( int i = <int> ; i < udt . size ( ) ; i + + ) { size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . fieldName ( i ) ) ) ; size + = codec . oneSerializedSize ( DataType . fromType ( udt . fieldType ( i ) , version ) , version ) ; } return size ; case TUPLE : TupleType tt = ( TupleType ) value ; size = <int> ; for ( int i = <int> ; i < tt . size ( ) ; i + + ) size + = codec . oneSerializedSize ( DataType . fromType ( tt . type ( i ) , version ) , version ) ; return size ; default : return <int> ; } } public static Pair < DataType , Object > fromType ( AbstractType type , int version ) { if ( type instanceof ReversedType ) type = ( ( ReversedType ) type ) . baseType ; if ( type instanceof DateType ) type = TimestampType . instance ; DataType dt = dataTypeMap . get ( type ) ; if ( dt = = null ) { if ( type . isCollection ( ) ) { if ( type instanceof ListType ) { return Pair . < DataType , Object > create ( LIST , ( ( ListType ) type ) . getElementsType ( ) ) ; } else if ( type instanceof MapType ) { MapType mt = ( MapType ) type ; return Pair . < DataType , Object > create ( MAP , Arrays . asList ( mt . getKeysType ( ) , mt . getValuesType ( ) ) ) ; } else if ( type instanceof SetType ) { return Pair . < DataType , Object > create ( SET , ( ( SetType ) type ) . getElementsType ( ) ) ; } throw new AssertionError ( ) ; } if ( type instanceof UserType & & version > = UDT . protocolVersion ) return Pair . < DataType , Object > create ( UDT , type ) ; if ( type instanceof TupleType & & version > = TUPLE . protocolVersion ) return Pair . < DataType , Object > create ( TUPLE , type ) ; return Pair . < DataType , Object > create ( CUSTOM , type . toString ( ) ) ; } else { if ( version < dt . protocolVersion ) return Pair . < DataType , Object > create ( CUSTOM , type . toString ( ) ) ; return Pair . create ( dt , null ) ; } } public static AbstractType toType ( Pair < DataType , Object > entry ) { try { switch ( entry . left ) { case CUSTOM : return TypeParser . parse ( ( String ) entry . right ) ; case LIST : return ListType . getInstance ( ( AbstractType ) entry . right , true ) ; case SET : return SetType . getInstance ( ( AbstractType ) entry . right , true ) ; case MAP : List < AbstractType > l = ( List < AbstractType > ) entry . right ; return MapType . getInstance ( l . get ( <int> ) , l . get ( <int> ) , true ) ; case UDT : return ( AbstractType ) entry . right ; case TUPLE : return ( AbstractType ) entry . right ; default : return entry . left . type ; } } catch ( RequestValidationException e ) { throw new ProtocolException ( e . getMessage ( ) ) ; } } @VisibleForTesting public int getProtocolVersion ( ) { return protocolVersion ; } } 
