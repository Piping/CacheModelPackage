package org . elasticsearch . search . suggest . phrase ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . script . Template ; import org . elasticsearch . search . suggest . SuggestBuilder . SuggestionBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public final class PhraseSuggestionBuilder extends SuggestionBuilder < PhraseSuggestionBuilder > { private Float maxErrors ; private String separator ; private Float realWordErrorLikelihood ; private Float confidence ; private final Map < String , List < CandidateGenerator > > generators = new HashMap < > ( ) ; private Integer gramSize ; private SmoothingModel model ; private Boolean forceUnigrams ; private Integer tokenLimit ; private String preTag ; private String postTag ; private Template collateQuery ; private Map < String , Object > collateParams ; private Boolean collatePrune ; public PhraseSuggestionBuilder ( String name ) { super ( name , <str> ) ; } public PhraseSuggestionBuilder gramSize ( int gramSize ) { if ( gramSize < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . gramSize = gramSize ; return this ; } public PhraseSuggestionBuilder maxErrors ( Float maxErrors ) { this . maxErrors = maxErrors ; return this ; } public PhraseSuggestionBuilder separator ( String separator ) { this . separator = separator ; return this ; } public PhraseSuggestionBuilder realWordErrorLikelihood ( Float realWordErrorLikelihood ) { this . realWordErrorLikelihood = realWordErrorLikelihood ; return this ; } public PhraseSuggestionBuilder confidence ( Float confidence ) { this . confidence = confidence ; return this ; } public PhraseSuggestionBuilder addCandidateGenerator ( CandidateGenerator generator ) { List < CandidateGenerator > list = this . generators . get ( generator . getType ( ) ) ; if ( list = = null ) { list = new ArrayList < > ( ) ; this . generators . put ( generator . getType ( ) , list ) ; } list . add ( generator ) ; return this ; } public PhraseSuggestionBuilder clearCandidateGenerators ( ) { this . generators . clear ( ) ; return this ; } public PhraseSuggestionBuilder forceUnigrams ( boolean forceUnigrams ) { this . forceUnigrams = forceUnigrams ; return this ; } public PhraseSuggestionBuilder smoothingModel ( SmoothingModel model ) { this . model = model ; return this ; } public PhraseSuggestionBuilder tokenLimit ( int tokenLimit ) { this . tokenLimit = tokenLimit ; return this ; } public PhraseSuggestionBuilder highlight ( String preTag , String postTag ) { if ( ( preTag = = null ) ! = ( postTag = = null ) ) { throw new IllegalArgumentException ( <str> ) ; } this . preTag = preTag ; this . postTag = postTag ; return this ; } public PhraseSuggestionBuilder collateQuery ( String collateQuery ) { this . collateQuery = new Template ( collateQuery ) ; return this ; } public PhraseSuggestionBuilder collateQuery ( Template collateQueryTemplate ) { this . collateQuery = collateQueryTemplate ; return this ; } public PhraseSuggestionBuilder collateParams ( Map < String , Object > collateParams ) { this . collateParams = collateParams ; return this ; } public PhraseSuggestionBuilder collatePrune ( boolean collatePrune ) { this . collatePrune = collatePrune ; return this ; } @Override public XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { if ( realWordErrorLikelihood ! = null ) { builder . field ( <str> , realWordErrorLikelihood ) ; } if ( confidence ! = null ) { builder . field ( <str> , confidence ) ; } if ( separator ! = null ) { builder . field ( <str> , separator ) ; } if ( maxErrors ! = null ) { builder . field ( <str> , maxErrors ) ; } if ( gramSize ! = null ) { builder . field ( <str> , gramSize ) ; } if ( forceUnigrams ! = null ) { builder . field ( <str> , forceUnigrams ) ; } if ( tokenLimit ! = null ) { builder . field ( <str> , tokenLimit ) ; } if ( ! generators . isEmpty ( ) ) { Set < Entry < String , List < CandidateGenerator > > > entrySet = generators . entrySet ( ) ; for ( Entry < String , List < CandidateGenerator > > entry : entrySet ) { builder . startArray ( entry . getKey ( ) ) ; for ( CandidateGenerator generator : entry . getValue ( ) ) { generator . toXContent ( builder , params ) ; } builder . endArray ( ) ; } } if ( model ! = null ) { builder . startObject ( <str> ) ; model . toXContent ( builder , params ) ; builder . endObject ( ) ; } if ( preTag ! = null ) { builder . startObject ( <str> ) ; builder . field ( <str> , preTag ) ; builder . field ( <str> , postTag ) ; builder . endObject ( ) ; } if ( collateQuery ! = null ) { builder . startObject ( <str> ) ; builder . field ( <str> , collateQuery ) ; if ( collateParams ! = null ) { builder . field ( <str> , collateParams ) ; } if ( collatePrune ! = null ) { builder . field ( <str> , collatePrune . booleanValue ( ) ) ; } builder . endObject ( ) ; } return builder ; } public static DirectCandidateGenerator candidateGenerator ( String field ) { return new DirectCandidateGenerator ( field ) ; } public static final class StupidBackoff extends SmoothingModel { private final double discount ; public StupidBackoff ( double discount ) { super ( <str> ) ; this . discount = discount ; } @Override protected XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( <str> , discount ) ; return builder ; } } public static final class Laplace extends SmoothingModel { private final double alpha ; public Laplace ( double alpha ) { super ( <str> ) ; this . alpha = alpha ; } @Override protected XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( <str> , alpha ) ; return builder ; } } public static abstract class SmoothingModel implements ToXContent { private final String type ; protected SmoothingModel ( String type ) { this . type = type ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( type ) ; innerToXContent ( builder , params ) ; builder . endObject ( ) ; return builder ; } protected abstract XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException ; } public static final class LinearInterpolation extends SmoothingModel { private final double trigramLambda ; private final double bigramLambda ; private final double unigramLambda ; public LinearInterpolation ( double trigramLambda , double bigramLambda , double unigramLambda ) { super ( <str> ) ; this . trigramLambda = trigramLambda ; this . bigramLambda = bigramLambda ; this . unigramLambda = unigramLambda ; } @Override protected XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( <str> , trigramLambda ) ; builder . field ( <str> , bigramLambda ) ; builder . field ( <str> , unigramLambda ) ; return builder ; } } public static abstract class CandidateGenerator implements ToXContent { private final String type ; public CandidateGenerator ( String type ) { this . type = type ; } public String getType ( ) { return type ; } } public static final class DirectCandidateGenerator extends CandidateGenerator { private final String field ; private String preFilter ; private String postFilter ; private String suggestMode ; private Float accuracy ; private Integer size ; private String sort ; private String stringDistance ; private Integer maxEdits ; private Integer maxInspections ; private Float maxTermFreq ; private Integer prefixLength ; private Integer minWordLength ; private Float minDocFreq ; public DirectCandidateGenerator ( String field ) { super ( <str> ) ; this . field = field ; } public DirectCandidateGenerator suggestMode ( String suggestMode ) { this . suggestMode = suggestMode ; return this ; } public DirectCandidateGenerator accuracy ( float accuracy ) { this . accuracy = accuracy ; return this ; } public DirectCandidateGenerator size ( int size ) { if ( size < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . size = size ; return this ; } public DirectCandidateGenerator sort ( String sort ) { this . sort = sort ; return this ; } public DirectCandidateGenerator stringDistance ( String stringDistance ) { this . stringDistance = stringDistance ; return this ; } public DirectCandidateGenerator maxEdits ( Integer maxEdits ) { this . maxEdits = maxEdits ; return this ; } public DirectCandidateGenerator maxInspections ( Integer maxInspections ) { this . maxInspections = maxInspections ; return this ; } public DirectCandidateGenerator maxTermFreq ( float maxTermFreq ) { this . maxTermFreq = maxTermFreq ; return this ; } public DirectCandidateGenerator prefixLength ( int prefixLength ) { this . prefixLength = prefixLength ; return this ; } public DirectCandidateGenerator minWordLength ( int minWordLength ) { this . minWordLength = minWordLength ; return this ; } public DirectCandidateGenerator minDocFreq ( float minDocFreq ) { this . minDocFreq = minDocFreq ; return this ; } public DirectCandidateGenerator preFilter ( String preFilter ) { this . preFilter = preFilter ; return this ; } public DirectCandidateGenerator postFilter ( String postFilter ) { this . postFilter = postFilter ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( field ! = null ) { builder . field ( <str> , field ) ; } if ( suggestMode ! = null ) { builder . field ( <str> , suggestMode ) ; } if ( accuracy ! = null ) { builder . field ( <str> , accuracy ) ; } if ( size ! = null ) { builder . field ( <str> , size ) ; } if ( sort ! = null ) { builder . field ( <str> , sort ) ; } if ( stringDistance ! = null ) { builder . field ( <str> , stringDistance ) ; } if ( maxEdits ! = null ) { builder . field ( <str> , maxEdits ) ; } if ( maxInspections ! = null ) { builder . field ( <str> , maxInspections ) ; } if ( maxTermFreq ! = null ) { builder . field ( <str> , maxTermFreq ) ; } if ( prefixLength ! = null ) { builder . field ( <str> , prefixLength ) ; } if ( minWordLength ! = null ) { builder . field ( <str> , minWordLength ) ; } if ( minDocFreq ! = null ) { builder . field ( <str> , minDocFreq ) ; } if ( preFilter ! = null ) { builder . field ( <str> , preFilter ) ; } if ( postFilter ! = null ) { builder . field ( <str> , postFilter ) ; } builder . endObject ( ) ; return builder ; } } } 
