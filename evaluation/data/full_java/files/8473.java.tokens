package org . elasticsearch . search . aggregations . metrics . cardinality ; import com . carrotsearch . hppc . BitMixer ; import com . carrotsearch . hppc . IntHashSet ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . test . ESTestCase ; import static org . elasticsearch . search . aggregations . metrics . cardinality . HyperLogLogPlusPlus . MAX_PRECISION ; import static org . elasticsearch . search . aggregations . metrics . cardinality . HyperLogLogPlusPlus . MIN_PRECISION ; import static org . hamcrest . Matchers . closeTo ; public class HyperLogLogPlusPlusTests extends ESTestCase { public void testEncodeDecode ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; + + i ) { final int p1 = randomIntBetween ( <int> , <int> ) ; final long hash = randomLong ( ) ; testEncodeDecode ( p1 , hash ) ; } for ( int p1 = MIN_PRECISION ; p1 < = MAX_PRECISION ; + + p1 ) { testEncodeDecode ( p1 , <int> ) ; testEncodeDecode ( p1 , <int> ) ; testEncodeDecode ( p1 , ~ <int> L ) ; } } private void testEncodeDecode ( int p1 , long hash ) { final long index = HyperLogLogPlusPlus . index ( hash , p1 ) ; final int runLen = HyperLogLogPlusPlus . runLen ( hash , p1 ) ; final int encoded = HyperLogLogPlusPlus . encodeHash ( hash , p1 ) ; assertEquals ( index , HyperLogLogPlusPlus . decodeIndex ( encoded , p1 ) ) ; assertEquals ( runLen , HyperLogLogPlusPlus . decodeRunLen ( encoded , p1 ) ) ; } public void testAccuracy ( ) { final long bucket = randomInt ( <int> ) ; final int numValues = randomIntBetween ( <int> , <int> ) ; final int maxValue = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : <int> ) ; final int p = randomIntBetween ( <int> , MAX_PRECISION ) ; IntHashSet set = new IntHashSet ( ) ; HyperLogLogPlusPlus e = new HyperLogLogPlusPlus ( p , BigArrays . NON_RECYCLING_INSTANCE , <int> ) ; for ( int i = <int> ; i < numValues ; + + i ) { final int n = randomInt ( maxValue ) ; set . add ( n ) ; final long hash = BitMixer . mix64 ( n ) ; e . collect ( bucket , hash ) ; if ( randomInt ( <int> ) = = <int> ) { assertThat ( ( double ) e . cardinality ( bucket ) , closeTo ( set . size ( ) , <float> * set . size ( ) ) ) ; } } assertThat ( ( double ) e . cardinality ( bucket ) , closeTo ( set . size ( ) , <float> * set . size ( ) ) ) ; } public void testMerge ( ) { final int p = randomIntBetween ( MIN_PRECISION , MAX_PRECISION ) ; final HyperLogLogPlusPlus single = new HyperLogLogPlusPlus ( p , BigArrays . NON_RECYCLING_INSTANCE , <int> ) ; final HyperLogLogPlusPlus [ ] multi = new HyperLogLogPlusPlus [ randomIntBetween ( <int> , <int> ) ] ; final long [ ] bucketOrds = new long [ multi . length ] ; for ( int i = <int> ; i < multi . length ; + + i ) { bucketOrds [ i ] = randomInt ( <int> ) ; multi [ i ] = new HyperLogLogPlusPlus ( p , BigArrays . NON_RECYCLING_INSTANCE , <int> ) ; } final int numValues = randomIntBetween ( <int> , <int> ) ; final int maxValue = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : <int> ) ; for ( int i = <int> ; i < numValues ; + + i ) { final int n = randomInt ( maxValue ) ; final long hash = BitMixer . mix64 ( n ) ; single . collect ( <int> , hash ) ; final int index = ( int ) ( Math . pow ( randomDouble ( ) , <int> ) ) ; multi [ index ] . collect ( bucketOrds [ index ] , hash ) ; if ( randomInt ( <int> ) = = <int> ) { HyperLogLogPlusPlus merged = new HyperLogLogPlusPlus ( p , BigArrays . NON_RECYCLING_INSTANCE , <int> ) ; for ( int j = <int> ; j < multi . length ; + + j ) { merged . merge ( <int> , multi [ j ] , bucketOrds [ j ] ) ; } assertEquals ( single . cardinality ( <int> ) , merged . cardinality ( <int> ) ) ; } } } public void testFakeHashes ( ) { final int p = randomIntBetween ( MIN_PRECISION , MAX_PRECISION ) ; final HyperLogLogPlusPlus counts = new HyperLogLogPlusPlus ( p , BigArrays . NON_RECYCLING_INSTANCE , <int> ) ; counts . collect ( <int> , <int> ) ; assertEquals ( <int> , counts . cardinality ( <int> ) ) ; if ( randomBoolean ( ) ) { counts . collect ( <int> , <int> ) ; assertEquals ( <int> , counts . cardinality ( <int> ) ) ; } counts . upgradeToHll ( <int> ) ; assertEquals ( <int> , counts . cardinality ( <int> ) ) ; } public void testPrecisionFromThreshold ( ) { assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; assertEquals ( <int> , HyperLogLogPlusPlus . precisionFromThreshold ( <int> ) ) ; } } 
