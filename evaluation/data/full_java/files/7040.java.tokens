package org . elasticsearch . rest . action . explain ; import org . apache . lucene . search . Explanation ; import org . elasticsearch . action . explain . ExplainRequest ; import org . elasticsearch . action . explain . ExplainResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . index . get . GetResult ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import java . io . IOException ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestRequest . Method . POST ; import static org . elasticsearch . rest . RestStatus . NOT_FOUND ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestExplainAction extends BaseRestHandler { private final IndicesQueriesRegistry indicesQueriesRegistry ; @Inject public RestExplainAction ( Settings settings , RestController controller , Client client , IndicesQueriesRegistry indicesQueriesRegistry ) { super ( settings , controller , client ) ; this . indicesQueriesRegistry = indicesQueriesRegistry ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final ExplainRequest explainRequest = new ExplainRequest ( request . param ( <str> ) , request . param ( <str> ) , request . param ( <str> ) ) ; explainRequest . parent ( request . param ( <str> ) ) ; explainRequest . routing ( request . param ( <str> ) ) ; explainRequest . preference ( request . param ( <str> ) ) ; String queryString = request . param ( <str> ) ; if ( RestActions . hasBodyContent ( request ) ) { BytesReference restContent = RestActions . getRestContent ( request ) ; explainRequest . query ( RestActions . getQueryContent ( restContent , indicesQueriesRegistry , parseFieldMatcher ) ) ; } else if ( queryString ! = null ) { QueryBuilder < ? > query = RestActions . urlParamsToQueryBuilder ( request ) ; explainRequest . query ( query ) ; } String sField = request . param ( <str> ) ; if ( sField ! = null ) { String [ ] sFields = Strings . splitStringByCommaToArray ( sField ) ; if ( sFields ! = null ) { explainRequest . fields ( sFields ) ; } } explainRequest . fetchSourceContext ( FetchSourceContext . parseFromRestRequest ( request ) ) ; client . explain ( explainRequest , new RestBuilderListener < ExplainResponse > ( channel ) { @Override public RestResponse buildResponse ( ExplainResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; builder . field ( Fields . _INDEX , response . getIndex ( ) ) . field ( Fields . _TYPE , response . getType ( ) ) . field ( Fields . _ID , response . getId ( ) ) . field ( Fields . MATCHED , response . isMatch ( ) ) ; if ( response . hasExplanation ( ) ) { builder . startObject ( Fields . EXPLANATION ) ; buildExplanation ( builder , response . getExplanation ( ) ) ; builder . endObject ( ) ; } GetResult getResult = response . getGetResult ( ) ; if ( getResult ! = null ) { builder . startObject ( Fields . GET ) ; response . getGetResult ( ) . toXContentEmbedded ( builder , request ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return new BytesRestResponse ( response . isExists ( ) ? OK : NOT_FOUND , builder ) ; } private void buildExplanation ( XContentBuilder builder , Explanation explanation ) throws IOException { builder . field ( Fields . VALUE , explanation . getValue ( ) ) ; builder . field ( Fields . DESCRIPTION , explanation . getDescription ( ) ) ; Explanation [ ] innerExps = explanation . getDetails ( ) ; if ( innerExps ! = null ) { builder . startArray ( Fields . DETAILS ) ; for ( Explanation exp : innerExps ) { builder . startObject ( ) ; buildExplanation ( builder , exp ) ; builder . endObject ( ) ; } builder . endArray ( ) ; } } } ) ; } static class Fields { static final XContentBuilderString _INDEX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString _TYPE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString _ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MATCHED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString EXPLANATION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VALUE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DESCRIPTION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DETAILS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString GET = new XContentBuilderString ( <str> ) ; } } 
