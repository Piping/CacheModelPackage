package org . gradle . messaging . remote . internal ; import org . gradle . messaging . remote . internal . protocol . ConsumerAvailable ; import org . gradle . messaging . remote . internal . protocol . ConsumerUnavailable ; import org . gradle . messaging . remote . internal . protocol . Request ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . TimeUnit ; public class BroadcastSendProtocol implements Protocol < Message > { private static final Logger LOGGER = LoggerFactory . getLogger ( BroadcastSendProtocol . class ) ; private ProtocolContext < Message > context ; private final Set < Object > consumers = new HashSet < Object > ( ) ; private final List < Object > queue = new ArrayList < Object > ( ) ; private boolean stopping ; public void start ( ProtocolContext < Message > context ) { this . context = context ; } public void handleOutgoing ( Message message ) { if ( message instanceof Request ) { Request request = ( Request ) message ; if ( consumers . isEmpty ( ) ) { queue . add ( request . getPayload ( ) ) ; } else { for ( Object consumer : consumers ) { context . dispatchOutgoing ( new Request ( consumer , request . getPayload ( ) ) ) ; } } } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } public void handleIncoming ( Message message ) { if ( message instanceof ConsumerAvailable ) { ConsumerAvailable consumerAvailable = ( ConsumerAvailable ) message ; consumers . add ( consumerAvailable . getId ( ) ) ; if ( ! queue . isEmpty ( ) ) { for ( Object queued : queue ) { context . dispatchOutgoing ( new Request ( consumerAvailable . getId ( ) , queued ) ) ; } queue . clear ( ) ; if ( stopping ) { LOGGER . debug ( <str> ) ; context . stopped ( ) ; } } } else if ( message instanceof ConsumerUnavailable ) { ConsumerUnavailable consumerUnavailable = ( ConsumerUnavailable ) message ; consumers . remove ( consumerUnavailable . getId ( ) ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } public void stopRequested ( ) { if ( queue . isEmpty ( ) ) { LOGGER . debug ( <str> ) ; context . stopped ( ) ; return ; } LOGGER . debug ( <str> ) ; stopping = true ; context . stopLater ( ) ; context . callbackLater ( <int> , TimeUnit . SECONDS , new Runnable ( ) { public void run ( ) { LOGGER . debug ( <str> ) ; queue . clear ( ) ; context . stopped ( ) ; } } ) ; } } 
