package org . gradle . api . internal . project ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . specs . Spec ; import org . gradle . util . GUtil ; import java . io . File ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class DefaultProjectRegistry < T extends ProjectIdentifier > implements ProjectRegistry < T > { private Map < String , T > projects = new HashMap < String , T > ( ) ; private Map < String , Set < T > > subProjects = new HashMap < String , Set < T > > ( ) ; public void addProject ( T project ) { projects . put ( project . getPath ( ) , project ) ; subProjects . put ( project . getPath ( ) , new HashSet < T > ( ) ) ; addProjectToParentSubProjects ( project ) ; } public T removeProject ( String path ) { T project = projects . remove ( path ) ; assert project ! = null ; subProjects . remove ( path ) ; ProjectIdentifier loopProject = project . getParentIdentifier ( ) ; while ( loopProject ! = null ) { subProjects . get ( loopProject . getPath ( ) ) . remove ( project ) ; loopProject = loopProject . getParentIdentifier ( ) ; } return project ; } private void addProjectToParentSubProjects ( T project ) { ProjectIdentifier loopProject = project . getParentIdentifier ( ) ; while ( loopProject ! = null ) { subProjects . get ( loopProject . getPath ( ) ) . add ( project ) ; loopProject = loopProject . getParentIdentifier ( ) ; } } public Set < T > getAllProjects ( ) { return new HashSet < T > ( projects . values ( ) ) ; } public T getProject ( String path ) { return projects . get ( path ) ; } public T getProject ( final File projectDir ) { Set < T > projects = findAll ( new Spec < T > ( ) { public boolean isSatisfiedBy ( T element ) { return element . getProjectDir ( ) . equals ( projectDir ) ; } } ) ; if ( projects . size ( ) > <int> ) { throw new InvalidUserDataException ( String . format ( <str> , projectDir , projects ) ) ; } return projects . size ( ) = = <int> ? projects . iterator ( ) . next ( ) : null ; } public Set < T > getAllProjects ( String path ) { Set < T > result = new HashSet < T > ( getSubProjects ( path ) ) ; if ( projects . get ( path ) ! = null ) { result . add ( projects . get ( path ) ) ; } return result ; } public Set < T > getSubProjects ( String path ) { return GUtil . elvis ( subProjects . get ( path ) , new HashSet < T > ( ) ) ; } public Set < T > findAll ( Spec < ? super T > constraint ) { Set < T > matches = new HashSet < T > ( ) ; for ( T project : projects . values ( ) ) { if ( constraint . isSatisfiedBy ( project ) ) { matches . add ( project ) ; } } return matches ; } } 
