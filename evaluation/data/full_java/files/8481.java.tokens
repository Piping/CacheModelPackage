package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . metrics . percentiles . Percentile ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . search . aggregations . pipeline . bucketmetrics . percentile . PercentilesBucket ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . percentilesBucket ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class PercentilesBucketIT extends ESIntegTestCase { private static final String SINGLE_VALUED_FIELD_NAME = <str> ; private static final Double [ ] PERCENTS = { <float> , <float> , <float> , <float> , <float> } ; static int numDocs ; static int interval ; static int minRandomValue ; static int maxRandomValue ; static int numValueBuckets ; static long [ ] valueCounts ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; numDocs = randomIntBetween ( <int> , <int> ) ; interval = randomIntBetween ( <int> , <int> ) ; minRandomValue = <int> ; maxRandomValue = <int> ; numValueBuckets = ( ( maxRandomValue - minRandomValue ) / interval ) + <int> ; valueCounts = new long [ numValueBuckets ] ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { int fieldValue = randomIntBetween ( minRandomValue , maxRandomValue ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , fieldValue ) . field ( <str> , <str> + ( i % interval ) ) . endObject ( ) ) ) ; final int bucket = ( fieldValue / interval ) ; valueCounts [ bucket ] + + ; } assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , i * <int> ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testDocCountopLevel ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; double [ ] values = new double [ numValueBuckets ] ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; values [ i ] = bucket . getDocCount ( ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } public void testDocCountAsSubAgg ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) ) . subAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > termsBuckets = terms . getBuckets ( ) ; assertThat ( termsBuckets . size ( ) , equalTo ( interval ) ) ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket termsBucket = termsBuckets . get ( i ) ; assertThat ( termsBucket , notNullValue ( ) ) ; assertThat ( ( String ) termsBucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; Histogram histo = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; double [ ] values = new double [ numValueBuckets ] ; for ( int j = <int> ; j < numValueBuckets ; + + j ) { Histogram . Bucket bucket = buckets . get ( j ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) j * interval ) ) ; values [ j ] = bucket . getDocCount ( ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } } public void testMetricTopLevel ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = terms . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( interval ) ) ; double [ ] values = new double [ interval ] ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( String ) bucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; assertThat ( bucket . getDocCount ( ) , greaterThan ( <int> l ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; values [ i ] = sum . value ( ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } public void testMetricTopLevelDefaultPercents ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = terms . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( interval ) ) ; double [ ] values = new double [ interval ] ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( String ) bucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; assertThat ( bucket . getDocCount ( ) , greaterThan ( <int> l ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; values [ i ] = sum . value ( ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Percentile p : percentilesBucketValue ) { double expected = values [ ( int ) ( ( p . getPercent ( ) / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p . getPercent ( ) ) , equalTo ( expected ) ) ; assertThat ( p . getValue ( ) , equalTo ( expected ) ) ; } } public void testMetricAsSubAgg ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . subAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > termsBuckets = terms . getBuckets ( ) ; assertThat ( termsBuckets . size ( ) , equalTo ( interval ) ) ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket termsBucket = termsBuckets . get ( i ) ; assertThat ( termsBucket , notNullValue ( ) ) ; assertThat ( ( String ) termsBucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; Histogram histo = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; List < Double > values = new ArrayList < > ( numValueBuckets ) ; for ( int j = <int> ; j < numValueBuckets ; + + j ) { Histogram . Bucket bucket = buckets . get ( j ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) j * interval ) ) ; if ( bucket . getDocCount ( ) ! = <int> ) { Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; values . add ( sum . value ( ) ) ; } } Collections . sort ( values ) ; PercentilesBucket percentilesBucketValue = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values . get ( ( int ) ( ( p / <int> ) * values . size ( ) ) ) ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } } public void testMetricAsSubAggWithInsertZeros ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . subAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( BucketHelpers . GapPolicy . INSERT_ZEROS ) . percents ( PERCENTS ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > termsBuckets = terms . getBuckets ( ) ; assertThat ( termsBuckets . size ( ) , equalTo ( interval ) ) ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket termsBucket = termsBuckets . get ( i ) ; assertThat ( termsBucket , notNullValue ( ) ) ; assertThat ( ( String ) termsBucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; Histogram histo = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; double [ ] values = new double [ numValueBuckets ] ; for ( int j = <int> ; j < numValueBuckets ; + + j ) { Histogram . Bucket bucket = buckets . get ( j ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) j * interval ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; values [ j ] = sum . value ( ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } } public void testNoBuckets ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . exclude ( <str> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = terms . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( Double . NaN ) ) ; } } public void testWrongPercents ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . exclude ( <str> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = terms . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; try { percentilesBucketValue . percentile ( <float> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException exception ) { } } public void testBadPercents ( ) throws Exception { Double [ ] badPercents = { - <float> , <float> } ; try { client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( badPercents ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { ElasticsearchException [ ] rootCauses = exception . guessRootCauses ( ) ; assertThat ( rootCauses . length , equalTo ( <int> ) ) ; ElasticsearchException rootCause = rootCauses [ <int> ] ; assertThat ( rootCause . getMessage ( ) , containsString ( <str> ) ) ; } } public void testBadPercents_asSubAgg ( ) throws Exception { Double [ ] badPercents = { - <float> , <float> } ; try { client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) ) . subAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( badPercents ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { ElasticsearchException [ ] rootCauses = exception . guessRootCauses ( ) ; assertThat ( rootCauses . length , equalTo ( <int> ) ) ; ElasticsearchException rootCause = rootCauses [ <int> ] ; assertThat ( rootCause . getMessage ( ) , containsString ( <str> ) ) ; } } public void testNested ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) ) . subAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( PERCENTS ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > termsBuckets = terms . getBuckets ( ) ; assertThat ( termsBuckets . size ( ) , equalTo ( interval ) ) ; double [ ] values = new double [ termsBuckets . size ( ) ] ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket termsBucket = termsBuckets . get ( i ) ; assertThat ( termsBucket , notNullValue ( ) ) ; assertThat ( ( String ) termsBucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; Histogram histo = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; double [ ] innerValues = new double [ numValueBuckets ] ; for ( int j = <int> ; j < numValueBuckets ; + + j ) { Histogram . Bucket bucket = buckets . get ( j ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) j * interval ) ) ; innerValues [ j ] = bucket . getDocCount ( ) ; } Arrays . sort ( innerValues ) ; PercentilesBucket percentilesBucketValue = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = innerValues [ ( int ) ( ( p / <int> ) * innerValues . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } values [ i ] = percentilesBucketValue . percentile ( <float> ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : PERCENTS ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } public void testNestedWithDecimal ( ) throws Exception { Double [ ] percent = { <float> } ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . term ( true ) ) . subAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) minRandomValue , ( long ) maxRandomValue ) ) . subAggregation ( percentilesBucket ( <str> ) . percents ( percent ) . setBucketsPaths ( <str> ) ) ) . addAggregation ( percentilesBucket ( <str> ) . setBucketsPaths ( <str> ) . percents ( percent ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > termsBuckets = terms . getBuckets ( ) ; assertThat ( termsBuckets . size ( ) , equalTo ( interval ) ) ; double [ ] values = new double [ termsBuckets . size ( ) ] ; for ( int i = <int> ; i < interval ; + + i ) { Terms . Bucket termsBucket = termsBuckets . get ( i ) ; assertThat ( termsBucket , notNullValue ( ) ) ; assertThat ( ( String ) termsBucket . getKey ( ) , equalTo ( <str> + ( i % interval ) ) ) ; Histogram histo = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Histogram . Bucket > buckets = histo . getBuckets ( ) ; double [ ] innerValues = new double [ numValueBuckets ] ; for ( int j = <int> ; j < numValueBuckets ; + + j ) { Histogram . Bucket bucket = buckets . get ( j ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) j * interval ) ) ; innerValues [ j ] = bucket . getDocCount ( ) ; } Arrays . sort ( innerValues ) ; PercentilesBucket percentilesBucketValue = termsBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : percent ) { double expected = innerValues [ ( int ) ( ( p / <int> ) * innerValues . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } values [ i ] = percentilesBucketValue . percentile ( <float> ) ; } Arrays . sort ( values ) ; PercentilesBucket percentilesBucketValue = response . getAggregations ( ) . get ( <str> ) ; assertThat ( percentilesBucketValue , notNullValue ( ) ) ; assertThat ( percentilesBucketValue . getName ( ) , equalTo ( <str> ) ) ; for ( Double p : percent ) { double expected = values [ ( int ) ( ( p / <int> ) * values . length ) ] ; assertThat ( percentilesBucketValue . percentile ( p ) , equalTo ( expected ) ) ; } } } 
