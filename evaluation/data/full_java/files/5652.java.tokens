package org . elasticsearch . common ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . util . Enumeration ; public class MacAddressProvider { private static final ESLogger logger = Loggers . getLogger ( MacAddressProvider . class ) ; private static byte [ ] getMacAddress ( ) throws SocketException { Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; if ( en ! = null ) { while ( en . hasMoreElements ( ) ) { NetworkInterface nint = en . nextElement ( ) ; if ( ! nint . isLoopback ( ) ) { byte [ ] address = nint . getHardwareAddress ( ) ; if ( isValidAddress ( address ) ) { return address ; } } } } return null ; } private static boolean isValidAddress ( byte [ ] address ) { if ( address = = null | | address . length ! = <int> ) { return false ; } for ( byte b : address ) { if ( b ! = <hex> ) { return true ; } } return false ; } public static byte [ ] getSecureMungedAddress ( ) { byte [ ] address = null ; try { address = getMacAddress ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } if ( ! isValidAddress ( address ) ) { logger . warn ( <str> ) ; address = constructDummyMulticastAddress ( ) ; } byte [ ] mungedBytes = new byte [ <int> ] ; SecureRandomHolder . INSTANCE . nextBytes ( mungedBytes ) ; for ( int i = <int> ; i < <int> ; + + i ) { mungedBytes [ i ] ^ = address [ i ] ; } return mungedBytes ; } private static byte [ ] constructDummyMulticastAddress ( ) { byte [ ] dummy = new byte [ <int> ] ; SecureRandomHolder . INSTANCE . nextBytes ( dummy ) ; dummy [ <int> ] | = ( byte ) <hex> ; return dummy ; } } 
