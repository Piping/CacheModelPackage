package org . apache . cassandra . auth ; import java . util . * ; import java . util . concurrent . TimeUnit ; import com . google . common . base . Predicate ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . statements . BatchStatement ; import org . apache . cassandra . cql3 . statements . ModificationStatement ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . serializers . SetSerializer ; import org . apache . cassandra . serializers . UTF8Serializer ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; public class CassandraAuthorizer implements IAuthorizer { private static final Logger logger = LoggerFactory . getLogger ( CassandraAuthorizer . class ) ; private static final String ROLE = <str> ; private static final String RESOURCE = <str> ; private static final String PERMISSIONS = <str> ; public static final String USERNAME = <str> ; public static final String USER_PERMISSIONS = <str> ; private SelectStatement authorizeRoleStatement ; private SelectStatement legacyAuthorizeRoleStatement ; public CassandraAuthorizer ( ) { } public Set < Permission > authorize ( AuthenticatedUser user , IResource resource ) { if ( user . isSuper ( ) ) return resource . applicablePermissions ( ) ; Set < Permission > permissions = EnumSet . noneOf ( Permission . class ) ; try { for ( RoleResource role : user . getRoles ( ) ) addPermissionsForRole ( permissions , resource , role ) ; } catch ( RequestValidationException e ) { throw new AssertionError ( e ) ; } catch ( RequestExecutionException e ) { logger . warn ( <str> , user , resource ) ; throw new RuntimeException ( e ) ; } return permissions ; } public void grant ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { modifyRolePermissions ( permissions , resource , grantee , <str> ) ; addLookupEntry ( resource , grantee ) ; } public void revoke ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource revokee ) throws RequestValidationException , RequestExecutionException { modifyRolePermissions ( permissions , resource , revokee , <str> ) ; removeLookupEntry ( resource , revokee ) ; } public void revokeAllFrom ( RoleResource revokee ) { try { UntypedResultSet rows = process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS , escape ( revokee . getRoleName ( ) ) ) ) ; List < CQLStatement > statements = new ArrayList < > ( ) ; for ( UntypedResultSet . Row row : rows ) { statements . add ( QueryProcessor . getStatement ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX , escape ( row . getString ( <str> ) ) , escape ( revokee . getRoleName ( ) ) ) , ClientState . forInternalCalls ( ) ) . statement ) ; } statements . add ( QueryProcessor . getStatement ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS , escape ( revokee . getRoleName ( ) ) ) , ClientState . forInternalCalls ( ) ) . statement ) ; executeLoggedBatch ( statements ) ; } catch ( RequestExecutionException | RequestValidationException e ) { logger . warn ( <str> , revokee . getRoleName ( ) , e ) ; } } public void revokeAllOn ( IResource droppedResource ) { try { UntypedResultSet rows = process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX , escape ( droppedResource . getName ( ) ) ) ) ; List < CQLStatement > statements = new ArrayList < > ( ) ; for ( UntypedResultSet . Row row : rows ) { statements . add ( QueryProcessor . getStatement ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS , escape ( row . getString ( <str> ) ) , escape ( droppedResource . getName ( ) ) ) , ClientState . forInternalCalls ( ) ) . statement ) ; } statements . add ( QueryProcessor . getStatement ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX , escape ( droppedResource . getName ( ) ) ) , ClientState . forInternalCalls ( ) ) . statement ) ; executeLoggedBatch ( statements ) ; } catch ( RequestExecutionException | RequestValidationException e ) { logger . warn ( <str> , droppedResource , e ) ; return ; } } private void executeLoggedBatch ( List < CQLStatement > statements ) throws RequestExecutionException , RequestValidationException { BatchStatement batch = new BatchStatement ( <int> , BatchStatement . Type . LOGGED , Lists . newArrayList ( Iterables . filter ( statements , ModificationStatement . class ) ) , Attributes . none ( ) ) ; QueryProcessor . instance . processBatch ( batch , QueryState . forInternalCalls ( ) , BatchQueryOptions . withoutPerStatementVariables ( QueryOptions . DEFAULT ) ) ; } private void addPermissionsForRole ( Set < Permission > permissions , IResource resource , RoleResource role ) throws RequestExecutionException , RequestValidationException { QueryOptions options = QueryOptions . forInternalCalls ( ConsistencyLevel . LOCAL_ONE , Lists . newArrayList ( ByteBufferUtil . bytes ( role . getRoleName ( ) ) , ByteBufferUtil . bytes ( resource . getName ( ) ) ) ) ; SelectStatement statement = Schema . instance . getCFMetaData ( AuthKeyspace . NAME , USER_PERMISSIONS ) = = null ? authorizeRoleStatement : legacyAuthorizeRoleStatement ; ResultMessage . Rows rows = statement . execute ( QueryState . forInternalCalls ( ) , options ) ; UntypedResultSet result = UntypedResultSet . create ( rows . result ) ; if ( ! result . isEmpty ( ) & & result . one ( ) . has ( PERMISSIONS ) ) { for ( String perm : result . one ( ) . getSet ( PERMISSIONS , UTF8Type . instance ) ) { permissions . add ( Permission . valueOf ( perm ) ) ; } } } private void modifyRolePermissions ( Set < Permission > permissions , IResource resource , RoleResource role , String op ) throws RequestExecutionException { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS , op , <str> + StringUtils . join ( permissions , <str> ) + <str> , escape ( role . getRoleName ( ) ) , escape ( resource . getName ( ) ) ) ) ; } private void removeLookupEntry ( IResource resource , RoleResource role ) throws RequestExecutionException { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX , escape ( resource . getName ( ) ) , escape ( role . getRoleName ( ) ) ) ) ; } private void addLookupEntry ( IResource resource , RoleResource role ) throws RequestExecutionException { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX , escape ( resource . getName ( ) ) , escape ( role . getRoleName ( ) ) ) ) ; } public Set < PermissionDetails > list ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { if ( ! performer . isSuper ( ) & & ! performer . getRoles ( ) . contains ( grantee ) ) throw new UnauthorizedException ( String . format ( <str> , grantee = = null ? <str> : grantee . getRoleName ( ) ) ) ; if ( null = = grantee ) return listPermissionsForRole ( permissions , resource , grantee ) ; Set < RoleResource > roles = DatabaseDescriptor . getRoleManager ( ) . getRoles ( grantee , true ) ; Set < PermissionDetails > details = new HashSet < > ( ) ; for ( RoleResource role : roles ) details . addAll ( listPermissionsForRole ( permissions , resource , role ) ) ; return details ; } private Set < PermissionDetails > listPermissionsForRole ( Set < Permission > permissions , IResource resource , RoleResource role ) throws RequestExecutionException { Set < PermissionDetails > details = new HashSet < > ( ) ; boolean useLegacyTable = Schema . instance . getCFMetaData ( AuthKeyspace . NAME , USER_PERMISSIONS ) ! = null ; String entityColumnName = useLegacyTable ? USERNAME : ROLE ; for ( UntypedResultSet . Row row : process ( buildListQuery ( resource , role , useLegacyTable ) ) ) { if ( row . has ( PERMISSIONS ) ) { for ( String p : row . getSet ( PERMISSIONS , UTF8Type . instance ) ) { Permission permission = Permission . valueOf ( p ) ; if ( permissions . contains ( permission ) ) details . add ( new PermissionDetails ( row . getString ( entityColumnName ) , Resources . fromName ( row . getString ( RESOURCE ) ) , permission ) ) ; } } } return details ; } private String buildListQuery ( IResource resource , RoleResource grantee , boolean useLegacyTable ) { String tableName = useLegacyTable ? USER_PERMISSIONS : AuthKeyspace . ROLE_PERMISSIONS ; String entityName = useLegacyTable ? USERNAME : ROLE ; List < String > vars = Lists . newArrayList ( AuthKeyspace . NAME , tableName ) ; List < String > conditions = new ArrayList < > ( ) ; if ( resource ! = null ) { conditions . add ( <str> ) ; vars . add ( escape ( resource . getName ( ) ) ) ; } if ( grantee ! = null ) { conditions . add ( entityName + <str> ) ; vars . add ( escape ( grantee . getRoleName ( ) ) ) ; } String query = <str> + entityName + <str> ; if ( ! conditions . isEmpty ( ) ) query + = <str> + StringUtils . join ( conditions , <str> ) ; if ( resource ! = null & & grantee = = null ) query + = <str> ; return String . format ( query , vars . toArray ( ) ) ; } public Set < DataResource > protectedResources ( ) { return ImmutableSet . of ( DataResource . table ( AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS ) ) ; } public void validateConfiguration ( ) throws ConfigurationException { } public void setup ( ) { authorizeRoleStatement = prepare ( ROLE , AuthKeyspace . ROLE_PERMISSIONS ) ; if ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , <str> ) ! = null ) { legacyAuthorizeRoleStatement = prepare ( USERNAME , USER_PERMISSIONS ) ; ScheduledExecutors . optionalTasks . schedule ( new Runnable ( ) { public void run ( ) { convertLegacyData ( ) ; } } , AuthKeyspace . SUPERUSER_SETUP_DELAY , TimeUnit . MILLISECONDS ) ; } } private SelectStatement prepare ( String entityname , String permissionsTable ) { String query = String . format ( <str> , AuthKeyspace . NAME , permissionsTable , entityname ) ; return ( SelectStatement ) QueryProcessor . getStatement ( query , ClientState . forInternalCalls ( ) ) . statement ; } private void convertLegacyData ( ) { try { if ( Schema . instance . getCFMetaData ( <str> , <str> ) ! = null ) { logger . info ( <str> ) ; CQLStatement insertStatement = QueryProcessor . getStatement ( String . format ( <str> + <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_PERMISSIONS ) , ClientState . forInternalCalls ( ) ) . statement ; CQLStatement indexStatement = QueryProcessor . getStatement ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . RESOURCE_ROLE_INDEX ) , ClientState . forInternalCalls ( ) ) . statement ; UntypedResultSet permissions = process ( <str> ) ; for ( UntypedResultSet . Row row : permissions ) { final IResource resource = Resources . fromName ( row . getString ( <str> ) ) ; Predicate < String > isApplicable = new Predicate < String > ( ) { public boolean apply ( String s ) { return resource . applicablePermissions ( ) . contains ( Permission . valueOf ( s ) ) ; } } ; SetSerializer < String > serializer = SetSerializer . getInstance ( UTF8Serializer . instance , UTF8Type . instance ) ; Set < String > originalPerms = serializer . deserialize ( row . getBytes ( <str> ) ) ; Set < String > filteredPerms = ImmutableSet . copyOf ( Iterables . filter ( originalPerms , isApplicable ) ) ; insertStatement . execute ( QueryState . forInternalCalls ( ) , QueryOptions . forInternalCalls ( ConsistencyLevel . ONE , Lists . newArrayList ( row . getBytes ( <str> ) , row . getBytes ( <str> ) , serializer . serialize ( filteredPerms ) ) ) ) ; indexStatement . execute ( QueryState . forInternalCalls ( ) , QueryOptions . forInternalCalls ( ConsistencyLevel . ONE , Lists . newArrayList ( row . getBytes ( <str> ) , row . getBytes ( <str> ) ) ) ) ; } logger . info ( <str> ) ; } } catch ( Exception e ) { logger . info ( <str> + <str> ) ; logger . trace ( <str> , e ) ; } } private String escape ( String name ) { return StringUtils . replace ( name , <str> , <str> ) ; } private UntypedResultSet process ( String query ) throws RequestExecutionException { return QueryProcessor . process ( query , ConsistencyLevel . LOCAL_ONE ) ; } } 
