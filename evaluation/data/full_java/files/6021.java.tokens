package org . elasticsearch . common . network ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Locale ; public class InetAddresses { private static int IPV4_PART_COUNT = <int> ; private static int IPV6_PART_COUNT = <int> ; public static boolean isInetAddress ( String ipString ) { return ipStringToBytes ( ipString ) ! = null ; } private static byte [ ] ipStringToBytes ( String ipString ) { boolean hasColon = false ; boolean hasDot = false ; for ( int i = <int> ; i < ipString . length ( ) ; i + + ) { char c = ipString . charAt ( i ) ; if ( c = = <str> ) { hasDot = true ; } else if ( c = = <str> ) { if ( hasDot ) { return null ; } hasColon = true ; } else if ( Character . digit ( c , <int> ) = = - <int> ) { return null ; } } if ( hasColon ) { if ( hasDot ) { ipString = convertDottedQuadToHex ( ipString ) ; if ( ipString = = null ) { return null ; } } return textToNumericFormatV6 ( ipString ) ; } else if ( hasDot ) { return textToNumericFormatV4 ( ipString ) ; } return null ; } private static String convertDottedQuadToHex ( String ipString ) { int lastColon = ipString . lastIndexOf ( <str> ) ; String initialPart = ipString . substring ( <int> , lastColon + <int> ) ; String dottedQuad = ipString . substring ( lastColon + <int> ) ; byte [ ] quad = textToNumericFormatV4 ( dottedQuad ) ; if ( quad = = null ) { return null ; } String penultimate = Integer . toHexString ( ( ( quad [ <int> ] & <hex> ) < < <int> ) | ( quad [ <int> ] & <hex> ) ) ; String ultimate = Integer . toHexString ( ( ( quad [ <int> ] & <hex> ) < < <int> ) | ( quad [ <int> ] & <hex> ) ) ; return initialPart + penultimate + <str> + ultimate ; } private static byte [ ] textToNumericFormatV4 ( String ipString ) { String [ ] address = ipString . split ( <str> , IPV4_PART_COUNT + <int> ) ; if ( address . length ! = IPV4_PART_COUNT ) { return null ; } byte [ ] bytes = new byte [ IPV4_PART_COUNT ] ; try { for ( int i = <int> ; i < bytes . length ; i + + ) { bytes [ i ] = parseOctet ( address [ i ] ) ; } } catch ( NumberFormatException ex ) { return null ; } return bytes ; } private static byte parseOctet ( String ipPart ) { int octet = Integer . parseInt ( ipPart ) ; if ( octet > <int> | | ( ipPart . startsWith ( <str> ) & & ipPart . length ( ) > <int> ) ) { throw new NumberFormatException ( ) ; } return ( byte ) octet ; } private static byte [ ] textToNumericFormatV6 ( String ipString ) { String [ ] parts = ipString . split ( <str> , IPV6_PART_COUNT + <int> ) ; if ( parts . length < <int> | | parts . length > IPV6_PART_COUNT + <int> ) { return null ; } int skipIndex = - <int> ; for ( int i = <int> ; i < parts . length - <int> ; i + + ) { if ( parts [ i ] . length ( ) = = <int> ) { if ( skipIndex > = <int> ) { return null ; } skipIndex = i ; } } int partsHi ; int partsLo ; if ( skipIndex > = <int> ) { partsHi = skipIndex ; partsLo = parts . length - skipIndex - <int> ; if ( parts [ <int> ] . length ( ) = = <int> & & - - partsHi ! = <int> ) { return null ; } if ( parts [ parts . length - <int> ] . length ( ) = = <int> & & - - partsLo ! = <int> ) { return null ; } } else { partsHi = parts . length ; partsLo = <int> ; } int partsSkipped = IPV6_PART_COUNT - ( partsHi + partsLo ) ; if ( ! ( skipIndex > = <int> ? partsSkipped > = <int> : partsSkipped = = <int> ) ) { return null ; } ByteBuffer rawBytes = ByteBuffer . allocate ( <int> * IPV6_PART_COUNT ) ; try { for ( int i = <int> ; i < partsHi ; i + + ) { rawBytes . putShort ( parseHextet ( parts [ i ] ) ) ; } for ( int i = <int> ; i < partsSkipped ; i + + ) { rawBytes . putShort ( ( short ) <int> ) ; } for ( int i = partsLo ; i > <int> ; i - - ) { rawBytes . putShort ( parseHextet ( parts [ parts . length - i ] ) ) ; } } catch ( NumberFormatException ex ) { return null ; } return rawBytes . array ( ) ; } private static short parseHextet ( String ipPart ) { int hextet = Integer . parseInt ( ipPart , <int> ) ; if ( hextet > <hex> ) { throw new NumberFormatException ( ) ; } return ( short ) hextet ; } public static String toUriString ( InetAddress ip ) { if ( ip instanceof Inet6Address ) { return <str> + toAddrString ( ip ) + <str> ; } return toAddrString ( ip ) ; } public static String toAddrString ( InetAddress ip ) { if ( ip = = null ) { throw new NullPointerException ( <str> ) ; } if ( ip instanceof Inet4Address ) { byte [ ] bytes = ip . getAddress ( ) ; return ( bytes [ <int> ] & <hex> ) + <str> + ( bytes [ <int> ] & <hex> ) + <str> + ( bytes [ <int> ] & <hex> ) + <str> + ( bytes [ <int> ] & <hex> ) ; } if ( ! ( ip instanceof Inet6Address ) ) { throw new IllegalArgumentException ( <str> ) ; } byte [ ] bytes = ip . getAddress ( ) ; int [ ] hextets = new int [ IPV6_PART_COUNT ] ; for ( int i = <int> ; i < hextets . length ; i + + ) { hextets [ i ] = ( bytes [ <int> * i ] & <int> ) < < <int> | bytes [ <int> * i + <int> ] & <int> ; } compressLongestRunOfZeroes ( hextets ) ; return hextetsToIPv6String ( hextets ) ; } private static void compressLongestRunOfZeroes ( int [ ] hextets ) { int bestRunStart = - <int> ; int bestRunLength = - <int> ; int runStart = - <int> ; for ( int i = <int> ; i < hextets . length + <int> ; i + + ) { if ( i < hextets . length & & hextets [ i ] = = <int> ) { if ( runStart < <int> ) { runStart = i ; } } else if ( runStart > = <int> ) { int runLength = i - runStart ; if ( runLength > bestRunLength ) { bestRunStart = runStart ; bestRunLength = runLength ; } runStart = - <int> ; } } if ( bestRunLength > = <int> ) { Arrays . fill ( hextets , bestRunStart , bestRunStart + bestRunLength , - <int> ) ; } } private static String hextetsToIPv6String ( int [ ] hextets ) { StringBuilder buf = new StringBuilder ( <int> ) ; boolean lastWasNumber = false ; for ( int i = <int> ; i < hextets . length ; i + + ) { boolean thisIsNumber = hextets [ i ] > = <int> ; if ( thisIsNumber ) { if ( lastWasNumber ) { buf . append ( <str> ) ; } buf . append ( Integer . toHexString ( hextets [ i ] ) ) ; } else { if ( i = = <int> | | lastWasNumber ) { buf . append ( <str> ) ; } } lastWasNumber = thisIsNumber ; } return buf . toString ( ) ; } public static InetAddress forString ( String ipString ) { byte [ ] addr = ipStringToBytes ( ipString ) ; if ( addr = = null ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , ipString ) ) ; } return bytesToInetAddress ( addr ) ; } private static InetAddress bytesToInetAddress ( byte [ ] addr ) { try { return InetAddress . getByAddress ( addr ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } 
