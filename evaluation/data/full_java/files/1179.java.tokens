package org . apache . cassandra . transport . messages ; import java . util . UUID ; import com . google . common . collect . ImmutableMap ; import io . netty . buffer . ByteBuf ; import org . apache . cassandra . cql3 . CQLStatement ; import org . apache . cassandra . cql3 . QueryHandler ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . statements . ParsedStatement ; import org . apache . cassandra . exceptions . PreparedQueryNotFoundException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . transport . * ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . MD5Digest ; import org . apache . cassandra . utils . UUIDGen ; public class ExecuteMessage extends Message . Request { public static final Message . Codec < ExecuteMessage > codec = new Message . Codec < ExecuteMessage > ( ) { public ExecuteMessage decode ( ByteBuf body , int version ) { byte [ ] id = CBUtil . readBytes ( body ) ; return new ExecuteMessage ( MD5Digest . wrap ( id ) , QueryOptions . codec . decode ( body , version ) ) ; } public void encode ( ExecuteMessage msg , ByteBuf dest , int version ) { CBUtil . writeBytes ( msg . statementId . bytes , dest ) ; if ( version = = <int> ) { CBUtil . writeValueList ( msg . options . getValues ( ) , dest ) ; CBUtil . writeConsistencyLevel ( msg . options . getConsistency ( ) , dest ) ; } else { QueryOptions . codec . encode ( msg . options , dest , version ) ; } } public int encodedSize ( ExecuteMessage msg , int version ) { int size = <int> ; size + = CBUtil . sizeOfBytes ( msg . statementId . bytes ) ; if ( version = = <int> ) { size + = CBUtil . sizeOfValueList ( msg . options . getValues ( ) ) ; size + = CBUtil . sizeOfConsistencyLevel ( msg . options . getConsistency ( ) ) ; } else { size + = QueryOptions . codec . encodedSize ( msg . options , version ) ; } return size ; } } ; public final MD5Digest statementId ; public final QueryOptions options ; public ExecuteMessage ( MD5Digest statementId , QueryOptions options ) { super ( Message . Type . EXECUTE ) ; this . statementId = statementId ; this . options = options ; } public Message . Response execute ( QueryState state ) { try { QueryHandler handler = ClientState . getCQLQueryHandler ( ) ; ParsedStatement . Prepared prepared = handler . getPrepared ( statementId ) ; if ( prepared = = null ) throw new PreparedQueryNotFoundException ( statementId ) ; options . prepare ( prepared . boundNames ) ; CQLStatement statement = prepared . statement ; if ( options . getPageSize ( ) = = <int> ) throw new ProtocolException ( <str> ) ; UUID tracingId = null ; if ( isTracingRequested ( ) ) { tracingId = UUIDGen . getTimeUUID ( ) ; state . prepareTracingSession ( tracingId ) ; } if ( state . traceNextQuery ( ) ) { state . createTracingSession ( ) ; ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; if ( options . getPageSize ( ) > <int> ) builder . put ( <str> , Integer . toString ( options . getPageSize ( ) ) ) ; if ( options . getConsistency ( ) ! = null ) builder . put ( <str> , options . getConsistency ( ) . name ( ) ) ; if ( options . getSerialConsistency ( ) ! = null ) builder . put ( <str> , options . getSerialConsistency ( ) . name ( ) ) ; Tracing . instance . begin ( <str> , state . getClientAddress ( ) , builder . build ( ) ) ; } QueryOptions queryOptions = QueryOptions . addColumnSpecifications ( options , prepared . boundNames ) ; Message . Response response = handler . processPrepared ( statement , state , queryOptions , getCustomPayload ( ) ) ; if ( options . skipMetadata ( ) & & response instanceof ResultMessage . Rows ) ( ( ResultMessage . Rows ) response ) . result . metadata . setSkipMetadata ( ) ; if ( tracingId ! = null ) response . setTracingId ( tracingId ) ; return response ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; return ErrorMessage . fromException ( e ) ; } finally { Tracing . instance . stopSession ( ) ; } } @Override public String toString ( ) { return <str> + statementId + <str> + options . getValues ( ) . size ( ) + <str> + options . getConsistency ( ) ; } } 
