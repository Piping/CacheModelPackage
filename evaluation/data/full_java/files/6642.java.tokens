package org . elasticsearch . index . query ; import org . apache . lucene . queryparser . classic . QueryParser ; import org . apache . lucene . search . BooleanClause ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . util . CollectionUtils ; import java . io . IOException ; import java . util . Locale ; public enum Operator implements Writeable < Operator > { OR , AND ; private static final Operator PROTOTYPE = OR ; public BooleanClause . Occur toBooleanClauseOccur ( ) { switch ( this ) { case OR : return BooleanClause . Occur . SHOULD ; case AND : return BooleanClause . Occur . MUST ; default : throw Operator . newOperatorException ( this . toString ( ) ) ; } } public QueryParser . Operator toQueryParserOperator ( ) { switch ( this ) { case OR : return QueryParser . Operator . OR ; case AND : return QueryParser . Operator . AND ; default : throw Operator . newOperatorException ( this . toString ( ) ) ; } } @Override public Operator readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; if ( ordinal < <int> | | ordinal > = values ( ) . length ) { throw new IOException ( <str> + ordinal + <str> ) ; } return values ( ) [ ordinal ] ; } public static Operator readOperatorFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } public static Operator fromString ( String op ) { return valueOf ( op . toUpperCase ( Locale . ROOT ) ) ; } private static IllegalArgumentException newOperatorException ( String op ) { return new IllegalArgumentException ( <str> + CollectionUtils . arrayAsArrayList ( values ( ) ) + <str> + op + <str> ) ; } } 
