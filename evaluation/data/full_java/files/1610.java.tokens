package org . apache . cassandra . serializers ; import org . apache . cassandra . db . marshal . SimpleDateType ; import org . apache . cassandra . utils . Pair ; import org . junit . Test ; import java . nio . ByteBuffer ; import java . sql . Timestamp ; import java . text . SimpleDateFormat ; import java . util . * ; public class SimpleDateSerializerTest { private static final long millisPerDay = <int> * <int> * <int> * <int> ; private String dates [ ] = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static GregorianCalendar testCalendar = new GregorianCalendar ( ) ; private static SimpleDateFormat dateFormatUTC = new SimpleDateFormat ( <str> ) ; { testCalendar . setGregorianChange ( new Date ( Long . MIN_VALUE ) ) ; testCalendar . setTimeZone ( TimeZone . getTimeZone ( <str> ) ) ; dateFormatUTC . setCalendar ( testCalendar ) ; dateFormatUTC . setLenient ( false ) ; } @Test public void testDateStringToTimestamp ( ) { List < String > unparsedDates = new ArrayList < > ( ) ; List < String > badParseResults = new ArrayList < > ( ) ; for ( String date : dates ) { try { Integer days = SimpleDateSerializer . dateStringToDays ( date ) ; ByteBuffer value = SimpleDateSerializer . instance . serialize ( days ) ; Integer deserialized = SimpleDateSerializer . instance . deserialize ( value ) ; String toStringValue = SimpleDateSerializer . instance . toString ( deserialized ) ; if ( ! date . equals ( toStringValue ) ) { badParseResults . add ( String . format ( <str> , date , toStringValue ) ) ; } } catch ( MarshalException e ) { System . err . println ( <str> + e ) ; unparsedDates . add ( date ) ; } } assert unparsedDates . isEmpty ( ) : <str> + unparsedDates ; assert badParseResults . isEmpty ( ) : <str> + badParseResults ; } @Test public void testDaysStringToInt ( ) { Integer value = SimpleDateSerializer . dateStringToDays ( <str> ) ; assert value . compareTo ( <int> ) = = <int> : String . format ( <str> , <int> , value ) ; } @Test public void testProlepticRange ( ) { for ( int i = <int> ; i < <int> ; + + i ) { String date = <str> ; if ( i < <int> ) date + = <str> ; date + = i ; Integer days = SimpleDateSerializer . dateStringToDays ( date ) ; ByteBuffer value = SimpleDateType . instance . fromString ( days . toString ( ) ) ; Integer deserialized = SimpleDateSerializer . instance . deserialize ( value ) ; deserialized - = Integer . MIN_VALUE ; Timestamp ts = new Timestamp ( deserialized * millisPerDay ) ; testCalendar . setTime ( ts ) ; Date newDate = testCalendar . getTime ( ) ; assert ( dateFormatUTC . format ( newDate ) ) . equals ( date ) : String . format ( <str> , date , dateFormatUTC . format ( newDate ) . toString ( ) ) ; } } @Test ( expected = MarshalException . class ) public void testOutOfBoundsLow ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( new Date ( Integer . MIN_VALUE * millisPerDay - millisPerDay ) . toString ( ) ) ; } @Test ( expected = MarshalException . class ) public void testOutOfBoundsHigh ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( new Date ( Integer . MAX_VALUE * millisPerDay + millisPerDay ) . toString ( ) ) ; } @Test ( expected = MarshalException . class ) public void testBadInput ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( <str> ) ; } @Test ( expected = MarshalException . class ) public void testBadMonth ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( <str> ) ; } @Test ( expected = MarshalException . class ) public void testBadDay ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( <str> ) ; } @Test ( expected = MarshalException . class ) public void testBadDayToMonth ( ) { Integer days = SimpleDateSerializer . dateStringToDays ( <str> ) ; } } 
