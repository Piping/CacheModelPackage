package com . google . common . testing ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import junit . framework . TestCase ; import java . util . EnumSet ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; @GwtCompatible ( emulated = true ) public class FakeTickerTest extends TestCase { @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( new FakeTicker ( ) ) ; } public void testAdvance ( ) { FakeTicker ticker = new FakeTicker ( ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertSame ( ticker , ticker . advance ( <int> ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; ticker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , ticker . read ( ) ) ; } public void testAutoIncrementStep_returnsSameInstance ( ) { FakeTicker ticker = new FakeTicker ( ) ; assertSame ( ticker , ticker . setAutoIncrementStep ( <int> , TimeUnit . NANOSECONDS ) ) ; } public void testAutoIncrementStep_nanos ( ) { FakeTicker ticker = new FakeTicker ( ) . setAutoIncrementStep ( <int> , TimeUnit . NANOSECONDS ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; } public void testAutoIncrementStep_millis ( ) { FakeTicker ticker = new FakeTicker ( ) . setAutoIncrementStep ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; } public void testAutoIncrementStep_seconds ( ) { FakeTicker ticker = new FakeTicker ( ) . setAutoIncrementStep ( <int> , TimeUnit . SECONDS ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; } public void testAutoIncrementStep_resetToZero ( ) { FakeTicker ticker = new FakeTicker ( ) . setAutoIncrementStep ( <int> , TimeUnit . NANOSECONDS ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; assertEquals ( <int> , ticker . read ( ) ) ; for ( TimeUnit timeUnit : EnumSet . allOf ( TimeUnit . class ) ) { ticker . setAutoIncrementStep ( <int> , timeUnit ) ; assertEquals ( <str> + timeUnit , <int> , ticker . read ( ) ) ; } } public void testAutoIncrement_negative ( ) { FakeTicker ticker = new FakeTicker ( ) ; try { ticker . setAutoIncrementStep ( - <int> , TimeUnit . NANOSECONDS ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testConcurrentAdvance ( ) throws Exception { final FakeTicker ticker = new FakeTicker ( ) ; int numberOfThreads = <int> ; runConcurrentTest ( numberOfThreads , new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { ticker . advance ( <int> ) ; Thread . sleep ( <int> ) ; ticker . advance ( <int> ) ; return null ; } } ) ; assertEquals ( numberOfThreads * <int> , ticker . read ( ) ) ; } @GwtIncompatible ( <str> ) public void testConcurrentAutoIncrementStep ( ) throws Exception { int incrementByNanos = <int> ; final FakeTicker ticker = new FakeTicker ( ) . setAutoIncrementStep ( incrementByNanos , TimeUnit . NANOSECONDS ) ; int numberOfThreads = <int> ; runConcurrentTest ( numberOfThreads , new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { ticker . read ( ) ; return null ; } } ) ; assertEquals ( incrementByNanos * numberOfThreads , ticker . read ( ) ) ; } @GwtIncompatible ( <str> ) private void runConcurrentTest ( int numberOfThreads , final Callable < Void > callable ) throws Exception { ExecutorService executorService = Executors . newFixedThreadPool ( numberOfThreads ) ; final CountDownLatch startLatch = new CountDownLatch ( numberOfThreads ) ; final CountDownLatch doneLatch = new CountDownLatch ( numberOfThreads ) ; for ( int i = numberOfThreads ; i > <int> ; i - - ) { executorService . submit ( new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { startLatch . countDown ( ) ; startLatch . await ( ) ; callable . call ( ) ; doneLatch . countDown ( ) ; return null ; } } ) ; } doneLatch . await ( ) ; } } 
