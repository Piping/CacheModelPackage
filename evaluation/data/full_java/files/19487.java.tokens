package io . netty . handler . codec . socks ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socks . SocksAuthRequestDecoder . State ; import io . netty . util . CharsetUtil ; import java . util . List ; public class SocksAuthRequestDecoder extends ReplayingDecoder < State > { private SocksSubnegotiationVersion version ; private int fieldLength ; private String username ; private String password ; private SocksRequest msg = SocksCommonUtils . UNKNOWN_SOCKS_REQUEST ; public SocksAuthRequestDecoder ( ) { super ( State . CHECK_PROTOCOL_VERSION ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf byteBuf , List < Object > out ) throws Exception { switch ( state ( ) ) { case CHECK_PROTOCOL_VERSION : { version = SocksSubnegotiationVersion . valueOf ( byteBuf . readByte ( ) ) ; if ( version ! = SocksSubnegotiationVersion . AUTH_PASSWORD ) { break ; } checkpoint ( State . READ_USERNAME ) ; } case READ_USERNAME : { fieldLength = byteBuf . readByte ( ) ; username = byteBuf . readBytes ( fieldLength ) . toString ( CharsetUtil . US_ASCII ) ; checkpoint ( State . READ_PASSWORD ) ; } case READ_PASSWORD : { fieldLength = byteBuf . readByte ( ) ; password = byteBuf . readBytes ( fieldLength ) . toString ( CharsetUtil . US_ASCII ) ; msg = new SocksAuthRequest ( username , password ) ; } } ctx . pipeline ( ) . remove ( this ) ; out . add ( msg ) ; } enum State { CHECK_PROTOCOL_VERSION , READ_USERNAME , READ_PASSWORD } } 
