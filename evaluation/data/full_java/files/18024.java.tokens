package com . badlogic . gdx . graphics . g3d . model ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . utils . ArrayMap ; public class NodePart { public MeshPart meshPart ; public Material material ; public ArrayMap < Node , Matrix4 > invBoneBindTransforms ; public Matrix4 [ ] bones ; public boolean enabled = true ; public NodePart ( ) { } public NodePart ( final MeshPart meshPart , final Material material ) { this . meshPart = meshPart ; this . material = material ; } public Renderable setRenderable ( final Renderable out ) { out . material = material ; out . meshPart . set ( meshPart ) ; out . bones = bones ; return out ; } public NodePart copy ( ) { return new NodePart ( ) . set ( this ) ; } protected NodePart set ( NodePart other ) { meshPart = new MeshPart ( other . meshPart ) ; material = other . material ; enabled = other . enabled ; if ( other . invBoneBindTransforms = = null ) { invBoneBindTransforms = null ; bones = null ; } else { if ( invBoneBindTransforms = = null ) invBoneBindTransforms = new ArrayMap < Node , Matrix4 > ( true , other . invBoneBindTransforms . size , Node . class , Matrix4 . class ) ; else invBoneBindTransforms . clear ( ) ; invBoneBindTransforms . putAll ( other . invBoneBindTransforms ) ; if ( bones = = null | | bones . length ! = invBoneBindTransforms . size ) bones = new Matrix4 [ invBoneBindTransforms . size ] ; for ( int i = <int> ; i < bones . length ; i + + ) { if ( bones [ i ] = = null ) bones [ i ] = new Matrix4 ( ) ; } } return this ; } } 
