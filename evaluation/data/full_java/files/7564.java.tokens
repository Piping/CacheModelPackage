package org . elasticsearch . search . sort ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . NumericDocValues ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . FieldComparator ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . SortField ; import org . apache . lucene . search . join . BitSetProducer ; import org . apache . lucene . util . BitSet ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoDistance . FixedSourceDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . fielddata . IndexGeoPointFieldData ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import org . elasticsearch . index . fielddata . NumericDoubleValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . index . query . support . NestedInnerQueryParseSupport ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class GeoDistanceSortParser implements SortParser { @Override public String [ ] names ( ) { return new String [ ] { <str> , <str> } ; } @Override public SortField parse ( XContentParser parser , SearchContext context ) throws Exception { String fieldName = null ; List < GeoPoint > geoPoints = new ArrayList < > ( ) ; DistanceUnit unit = DistanceUnit . DEFAULT ; GeoDistance geoDistance = GeoDistance . DEFAULT ; boolean reverse = false ; MultiValueMode sortMode = null ; NestedInnerQueryParseSupport nestedHelper = null ; final boolean indexCreatedBeforeV2_0 = context . indexShard ( ) . getIndexSettings ( ) . getIndexVersionCreated ( ) . before ( Version . V_2_0_0 ) ; boolean coerce = false ; boolean ignoreMalformed = false ; XContentParser . Token token ; String currentName = parser . currentName ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { parseGeoPoints ( parser , geoPoints ) ; fieldName = currentName ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentName ) | | <str> . equals ( currentName ) ) { if ( nestedHelper = = null ) { nestedHelper = new NestedInnerQueryParseSupport ( parser , context ) ; } nestedHelper . filter ( ) ; } else { fieldName = currentName ; GeoPoint point = new GeoPoint ( ) ; GeoUtils . parseGeoPoint ( parser , point ) ; geoPoints . add ( point ) ; } } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentName ) ) { reverse = parser . booleanValue ( ) ; } else if ( <str> . equals ( currentName ) ) { reverse = <str> . equals ( parser . text ( ) ) ; } else if ( currentName . equals ( <str> ) ) { unit = DistanceUnit . fromString ( parser . text ( ) ) ; } else if ( currentName . equals ( <str> ) | | currentName . equals ( <str> ) ) { geoDistance = GeoDistance . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( currentName ) | | ( indexCreatedBeforeV2_0 & & <str> . equals ( currentName ) ) ) { coerce = parser . booleanValue ( ) ; if ( coerce = = true ) { ignoreMalformed = true ; } } else if ( <str> . equals ( currentName ) & & coerce = = false ) { ignoreMalformed = parser . booleanValue ( ) ; } else if ( <str> . equals ( currentName ) | | <str> . equals ( currentName ) | | <str> . equals ( currentName ) ) { sortMode = MultiValueMode . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( currentName ) | | <str> . equals ( currentName ) ) { if ( nestedHelper = = null ) { nestedHelper = new NestedInnerQueryParseSupport ( parser , context ) ; } nestedHelper . setPath ( parser . text ( ) ) ; } else { GeoPoint point = new GeoPoint ( ) ; point . resetFromString ( parser . text ( ) ) ; geoPoints . add ( point ) ; fieldName = currentName ; } } } if ( ! indexCreatedBeforeV2_0 & & ! ignoreMalformed ) { for ( GeoPoint point : geoPoints ) { if ( point . lat ( ) > <float> | | point . lat ( ) < - <float> ) { throw new ElasticsearchParseException ( <str> , point . lat ( ) ) ; } if ( point . lon ( ) > <float> | | point . lon ( ) < - <int> ) { throw new ElasticsearchParseException ( <str> , point . lon ( ) ) ; } } } if ( coerce ) { for ( GeoPoint point : geoPoints ) { GeoUtils . normalizePoint ( point , coerce , coerce ) ; } } if ( sortMode = = null ) { sortMode = reverse ? MultiValueMode . MAX : MultiValueMode . MIN ; } if ( sortMode = = MultiValueMode . SUM ) { throw new IllegalArgumentException ( <str> ) ; } MappedFieldType fieldType = context . smartNameFieldType ( fieldName ) ; if ( fieldType = = null ) { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } final MultiValueMode finalSortMode = sortMode ; final IndexGeoPointFieldData geoIndexFieldData = context . fieldData ( ) . getForField ( fieldType ) ; final FixedSourceDistance [ ] distances = new FixedSourceDistance [ geoPoints . size ( ) ] ; for ( int i = <int> ; i < geoPoints . size ( ) ; i + + ) { distances [ i ] = geoDistance . fixedSourceDistance ( geoPoints . get ( i ) . lat ( ) , geoPoints . get ( i ) . lon ( ) , unit ) ; } final Nested nested ; if ( nestedHelper ! = null & & nestedHelper . getPath ( ) ! = null ) { BitSetProducer rootDocumentsFilter = context . bitsetFilterCache ( ) . getBitSetProducer ( Queries . newNonNestedFilter ( ) ) ; Query innerDocumentsFilter ; if ( nestedHelper . filterFound ( ) ) { innerDocumentsFilter = nestedHelper . getInnerFilter ( ) ; } else { innerDocumentsFilter = nestedHelper . getNestedObjectMapper ( ) . nestedTypeFilter ( ) ; } nested = new Nested ( rootDocumentsFilter , context . searcher ( ) . createNormalizedWeight ( innerDocumentsFilter , false ) ) ; } else { nested = null ; } IndexFieldData . XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData . XFieldComparatorSource ( ) { @Override public SortField . Type reducedType ( ) { return SortField . Type . DOUBLE ; } @Override public FieldComparator < ? > newComparator ( String fieldname , int numHits , int sortPos , boolean reversed ) throws IOException { return new FieldComparator . DoubleComparator ( numHits , null , null ) { @Override protected NumericDocValues getNumericDocValues ( LeafReaderContext context , String field ) throws IOException { final MultiGeoPointValues geoPointValues = geoIndexFieldData . load ( context ) . getGeoPointValues ( ) ; final SortedNumericDoubleValues distanceValues = GeoDistance . distanceValues ( geoPointValues , distances ) ; final NumericDoubleValues selectedValues ; if ( nested = = null ) { selectedValues = finalSortMode . select ( distanceValues , Double . MAX_VALUE ) ; } else { final BitSet rootDocs = nested . rootDocs ( context ) ; final DocIdSetIterator innerDocs = nested . innerDocs ( context ) ; selectedValues = finalSortMode . select ( distanceValues , Double . MAX_VALUE , rootDocs , innerDocs , context . reader ( ) . maxDoc ( ) ) ; } return selectedValues . getRawDoubleValues ( ) ; } } ; } } ; return new SortField ( fieldName , geoDistanceComparatorSource , reverse ) ; } private void parseGeoPoints ( XContentParser parser , List < GeoPoint > geoPoints ) throws IOException { while ( ! parser . nextToken ( ) . equals ( XContentParser . Token . END_ARRAY ) ) { if ( parser . currentToken ( ) = = XContentParser . Token . VALUE_NUMBER ) { double lon = parser . doubleValue ( ) ; parser . nextToken ( ) ; if ( ! parser . currentToken ( ) . equals ( XContentParser . Token . VALUE_NUMBER ) ) { throw new ElasticsearchParseException ( <str> , parser . currentToken ( ) ) ; } double lat = parser . doubleValue ( ) ; GeoPoint point = new GeoPoint ( ) ; point . reset ( lat , lon ) ; geoPoints . add ( point ) ; } else { GeoPoint point = new GeoPoint ( ) ; GeoUtils . parseGeoPoint ( parser , point ) ; geoPoints . add ( point ) ; } } } } 
