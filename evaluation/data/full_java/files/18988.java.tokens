package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import org . junit . After ; import org . junit . Test ; import static io . netty . handler . codec . compression . Snappy . * ; import static org . junit . Assert . * ; public class SnappyTest { private final Snappy snappy = new Snappy ( ) ; @After public void resetSnappy ( ) { snappy . reset ( ) ; } @Test public void testDecodeLiteral ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . decode ( in , out ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> } ) ; assertEquals ( <str> , expected , out ) ; } @Test public void testDecodeCopyWith1ByteOffset ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> < < <int> | <hex> , <hex> } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . decode ( in , out ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ; assertEquals ( <str> , expected , out ) ; } @Test ( expected = DecompressionException . class ) public void testDecodeCopyWithTinyOffset ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> < < <int> | <hex> , <hex> } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . decode ( in , out ) ; } @Test ( expected = DecompressionException . class ) public void testDecodeCopyWithOffsetBeforeChunk ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> < < <int> | <hex> , <hex> } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . decode ( in , out ) ; } @Test ( expected = DecompressionException . class ) public void testDecodeWithOverlyLongPreamble ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { - <hex> , - <hex> , - <hex> , - <hex> , <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> , } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . decode ( in , out ) ; } @Test public void encodeShortTextIsLiteral ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> } ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . encode ( in , out , <int> ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { <hex> , <hex> < < <int> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ; assertEquals ( <str> , expected , out ) ; } @Test public void encodeLongTextUsesCopy ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( ( <str> + <str> + <str> + <str> ) . getBytes ( <str> ) ) ; ByteBuf out = Unpooled . buffer ( <int> ) ; snappy . encode ( in , out , in . readableBytes ( ) ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { - <hex> , <hex> , - <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , - <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ; assertEquals ( <str> , expected , out ) ; } @Test public void testCalculateChecksum ( ) { ByteBuf input = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> } ) ; assertEquals ( maskChecksum ( <hex> ) , calculateChecksum ( input ) ) ; } @Test public void testValidateChecksumMatches ( ) { ByteBuf input = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> } ) ; validateChecksum ( maskChecksum ( <hex> ) , input ) ; } @Test ( expected = DecompressionException . class ) public void testValidateChecksumFails ( ) { ByteBuf input = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> } ) ; validateChecksum ( maskChecksum ( <hex> ) , input ) ; } } 
