package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Objects ; import com . google . common . base . Predicate ; import com . google . common . hash . BloomFilterStrategies . BitArray ; import com . google . common . primitives . SignedBytes ; import com . google . common . primitives . UnsignedBytes ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Serializable ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta public final class BloomFilter < T > implements Predicate < T > , Serializable { interface Strategy extends java . io . Serializable { < T > boolean put ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) ; < T > boolean mightContain ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) ; int ordinal ( ) ; } private final BitArray bits ; private final int numHashFunctions ; private final Funnel < ? super T > funnel ; private final Strategy strategy ; private BloomFilter ( BitArray bits , int numHashFunctions , Funnel < ? super T > funnel , Strategy strategy ) { checkArgument ( numHashFunctions > <int> , <str> , numHashFunctions ) ; checkArgument ( numHashFunctions < = <int> , <str> , numHashFunctions ) ; this . bits = checkNotNull ( bits ) ; this . numHashFunctions = numHashFunctions ; this . funnel = checkNotNull ( funnel ) ; this . strategy = checkNotNull ( strategy ) ; } @CheckReturnValue public BloomFilter < T > copy ( ) { return new BloomFilter < T > ( bits . copy ( ) , numHashFunctions , funnel , strategy ) ; } @CheckReturnValue public boolean mightContain ( T object ) { return strategy . mightContain ( object , funnel , numHashFunctions , bits ) ; } @Deprecated @Override @CheckReturnValue public boolean apply ( T input ) { return mightContain ( input ) ; } public boolean put ( T object ) { return strategy . put ( object , funnel , numHashFunctions , bits ) ; } @CheckReturnValue public double expectedFpp ( ) { return Math . pow ( ( double ) bits . bitCount ( ) / bitSize ( ) , numHashFunctions ) ; } @VisibleForTesting long bitSize ( ) { return bits . bitSize ( ) ; } @CheckReturnValue public boolean isCompatible ( BloomFilter < T > that ) { checkNotNull ( that ) ; return ( this ! = that ) & & ( this . numHashFunctions = = that . numHashFunctions ) & & ( this . bitSize ( ) = = that . bitSize ( ) ) & & ( this . strategy . equals ( that . strategy ) ) & & ( this . funnel . equals ( that . funnel ) ) ; } public void putAll ( BloomFilter < T > that ) { checkNotNull ( that ) ; checkArgument ( this ! = that , <str> ) ; checkArgument ( this . numHashFunctions = = that . numHashFunctions , <str> , this . numHashFunctions , that . numHashFunctions ) ; checkArgument ( this . bitSize ( ) = = that . bitSize ( ) , <str> , this . bitSize ( ) , that . bitSize ( ) ) ; checkArgument ( this . strategy . equals ( that . strategy ) , <str> , this . strategy , that . strategy ) ; checkArgument ( this . funnel . equals ( that . funnel ) , <str> , this . funnel , that . funnel ) ; this . bits . putAll ( that . bits ) ; } @Override public boolean equals ( @Nullable Object object ) { if ( object = = this ) { return true ; } if ( object instanceof BloomFilter ) { BloomFilter < ? > that = ( BloomFilter < ? > ) object ; return this . numHashFunctions = = that . numHashFunctions & & this . funnel . equals ( that . funnel ) & & this . bits . equals ( that . bits ) & & this . strategy . equals ( that . strategy ) ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( numHashFunctions , funnel , strategy , bits ) ; } @CheckReturnValue public static < T > BloomFilter < T > create ( Funnel < ? super T > funnel , int expectedInsertions , double fpp ) { return create ( funnel , ( long ) expectedInsertions , fpp ) ; } @CheckReturnValue public static < T > BloomFilter < T > create ( Funnel < ? super T > funnel , long expectedInsertions , double fpp ) { return create ( funnel , expectedInsertions , fpp , BloomFilterStrategies . MURMUR128_MITZ_64 ) ; } @VisibleForTesting static < T > BloomFilter < T > create ( Funnel < ? super T > funnel , long expectedInsertions , double fpp , Strategy strategy ) { checkNotNull ( funnel ) ; checkArgument ( expectedInsertions > = <int> , <str> , expectedInsertions ) ; checkArgument ( fpp > <float> , <str> , fpp ) ; checkArgument ( fpp < <float> , <str> , fpp ) ; checkNotNull ( strategy ) ; if ( expectedInsertions = = <int> ) { expectedInsertions = <int> ; } long numBits = optimalNumOfBits ( expectedInsertions , fpp ) ; int numHashFunctions = optimalNumOfHashFunctions ( expectedInsertions , numBits ) ; try { return new BloomFilter < T > ( new BitArray ( numBits ) , numHashFunctions , funnel , strategy ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + numBits + <str> , e ) ; } } @CheckReturnValue public static < T > BloomFilter < T > create ( Funnel < ? super T > funnel , int expectedInsertions ) { return create ( funnel , ( long ) expectedInsertions ) ; } @CheckReturnValue public static < T > BloomFilter < T > create ( Funnel < ? super T > funnel , long expectedInsertions ) { return create ( funnel , expectedInsertions , <float> ) ; } @VisibleForTesting static int optimalNumOfHashFunctions ( long n , long m ) { return Math . max ( <int> , ( int ) Math . round ( ( double ) m / n * Math . log ( <int> ) ) ) ; } @VisibleForTesting static long optimalNumOfBits ( long n , double p ) { if ( p = = <int> ) { p = Double . MIN_VALUE ; } return ( long ) ( - n * Math . log ( p ) / ( Math . log ( <int> ) * Math . log ( <int> ) ) ) ; } private Object writeReplace ( ) { return new SerialForm < T > ( this ) ; } private static class SerialForm < T > implements Serializable { final long [ ] data ; final int numHashFunctions ; final Funnel < ? super T > funnel ; final Strategy strategy ; SerialForm ( BloomFilter < T > bf ) { this . data = bf . bits . data ; this . numHashFunctions = bf . numHashFunctions ; this . funnel = bf . funnel ; this . strategy = bf . strategy ; } Object readResolve ( ) { return new BloomFilter < T > ( new BitArray ( data ) , numHashFunctions , funnel , strategy ) ; } private static final long serialVersionUID = <int> ; } public void writeTo ( OutputStream out ) throws IOException { DataOutputStream dout = new DataOutputStream ( out ) ; dout . writeByte ( SignedBytes . checkedCast ( strategy . ordinal ( ) ) ) ; dout . writeByte ( UnsignedBytes . checkedCast ( numHashFunctions ) ) ; dout . writeInt ( bits . data . length ) ; for ( long value : bits . data ) { dout . writeLong ( value ) ; } } @CheckReturnValue public static < T > BloomFilter < T > readFrom ( InputStream in , Funnel < T > funnel ) throws IOException { checkNotNull ( in , <str> ) ; checkNotNull ( funnel , <str> ) ; int strategyOrdinal = - <int> ; int numHashFunctions = - <int> ; int dataLength = - <int> ; try { DataInputStream din = new DataInputStream ( in ) ; strategyOrdinal = din . readByte ( ) ; numHashFunctions = UnsignedBytes . toInt ( din . readByte ( ) ) ; dataLength = din . readInt ( ) ; Strategy strategy = BloomFilterStrategies . values ( ) [ strategyOrdinal ] ; long [ ] data = new long [ dataLength ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = din . readLong ( ) ; } return new BloomFilter < T > ( new BitArray ( data ) , numHashFunctions , funnel , strategy ) ; } catch ( RuntimeException e ) { IOException ioException = new IOException ( <str> + <str> + strategyOrdinal + <str> + numHashFunctions + <str> + dataLength ) ; ioException . initCause ( e ) ; throw ioException ; } } } 
