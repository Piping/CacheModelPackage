package com . badlogic . gdx . graphics . g3d . particles . values ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; public final class RectangleSpawnShapeValue extends PrimitiveSpawnShapeValue { public RectangleSpawnShapeValue ( RectangleSpawnShapeValue value ) { super ( value ) ; load ( value ) ; } public RectangleSpawnShapeValue ( ) { } @Override public void spawnAux ( Vector3 vector , float percent ) { float width = spawnWidth + ( spawnWidthDiff * spawnWidthValue . getScale ( percent ) ) ; float height = spawnHeight + ( spawnHeightDiff * spawnHeightValue . getScale ( percent ) ) ; float depth = spawnDepth + ( spawnDepthDiff * spawnDepthValue . getScale ( percent ) ) ; if ( edges ) { int a = MathUtils . random ( - <int> , <int> ) ; float tx = <int> , ty = <int> , tz = <int> ; if ( a = = - <int> ) { tx = MathUtils . random ( <int> ) = = <int> ? - width / <int> : width / <int> ; if ( tx = = <int> ) { ty = MathUtils . random ( <int> ) = = <int> ? - height / <int> : height / <int> ; tz = MathUtils . random ( <int> ) = = <int> ? - depth / <int> : depth / <int> ; } else { ty = MathUtils . random ( height ) - height / <int> ; tz = MathUtils . random ( depth ) - depth / <int> ; } } else if ( a = = <int> ) { tz = MathUtils . random ( <int> ) = = <int> ? - depth / <int> : depth / <int> ; if ( tz = = <int> ) { ty = MathUtils . random ( <int> ) = = <int> ? - height / <int> : height / <int> ; tx = MathUtils . random ( <int> ) = = <int> ? - width / <int> : width / <int> ; } else { ty = MathUtils . random ( height ) - height / <int> ; tx = MathUtils . random ( width ) - width / <int> ; } } else { ty = MathUtils . random ( <int> ) = = <int> ? - height / <int> : height / <int> ; if ( ty = = <int> ) { tx = MathUtils . random ( <int> ) = = <int> ? - width / <int> : width / <int> ; tz = MathUtils . random ( <int> ) = = <int> ? - depth / <int> : depth / <int> ; } else { tx = MathUtils . random ( width ) - width / <int> ; tz = MathUtils . random ( depth ) - depth / <int> ; } } vector . x = tx ; vector . y = ty ; vector . z = tz ; } else { vector . x = MathUtils . random ( width ) - width / <int> ; vector . y = MathUtils . random ( height ) - height / <int> ; vector . z = MathUtils . random ( depth ) - depth / <int> ; } } @Override public SpawnShapeValue copy ( ) { return new RectangleSpawnShapeValue ( this ) ; } } 
