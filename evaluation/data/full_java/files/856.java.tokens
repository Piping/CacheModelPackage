package org . apache . cassandra . repair ; import java . util . List ; import com . google . common . util . concurrent . AbstractFuture ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . MerkleTrees ; public abstract class SyncTask extends AbstractFuture < SyncStat > implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SyncTask . class ) ; protected final RepairJobDesc desc ; protected final TreeResponse r1 ; protected final TreeResponse r2 ; protected volatile SyncStat stat ; public SyncTask ( RepairJobDesc desc , TreeResponse r1 , TreeResponse r2 ) { this . desc = desc ; this . r1 = r1 ; this . r2 = r2 ; } public void run ( ) { List < Range < Token > > differences = MerkleTrees . difference ( r1 . trees , r2 . trees ) ; stat = new SyncStat ( new NodePair ( r1 . endpoint , r2 . endpoint ) , differences . size ( ) ) ; String format = String . format ( <str> , desc . sessionId , r1 . endpoint , r2 . endpoint , desc . columnFamily ) ; if ( differences . isEmpty ( ) ) { logger . info ( String . format ( format , <str> ) ) ; Tracing . traceRepair ( <str> , r1 . endpoint , r2 . endpoint , desc . columnFamily ) ; set ( stat ) ; return ; } logger . info ( String . format ( format , <str> + differences . size ( ) + <str> ) ) ; Tracing . traceRepair ( <str> , r1 . endpoint , differences . size ( ) , r2 . endpoint , desc . columnFamily ) ; startSync ( differences ) ; } public SyncStat getCurrentStat ( ) { return stat ; } protected abstract void startSync ( List < Range < Token > > differences ) ; } 
