package io . netty . buffer ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; public class ByteBufInputStream extends InputStream implements DataInput { private final ByteBuf buffer ; private final int startIndex ; private final int endIndex ; public ByteBufInputStream ( ByteBuf buffer ) { this ( buffer , buffer . readableBytes ( ) ) ; } public ByteBufInputStream ( ByteBuf buffer , int length ) { if ( buffer = = null ) { throw new NullPointerException ( <str> ) ; } if ( length < <int> ) { throw new IllegalArgumentException ( <str> + length ) ; } if ( length > buffer . readableBytes ( ) ) { throw new IndexOutOfBoundsException ( <str> + length + <str> + buffer . readableBytes ( ) ) ; } this . buffer = buffer ; startIndex = buffer . readerIndex ( ) ; endIndex = startIndex + length ; buffer . markReaderIndex ( ) ; } public int readBytes ( ) { return buffer . readerIndex ( ) - startIndex ; } @Override public int available ( ) throws IOException { return endIndex - buffer . readerIndex ( ) ; } @Override public void mark ( int readlimit ) { buffer . markReaderIndex ( ) ; } @Override public boolean markSupported ( ) { return true ; } @Override public int read ( ) throws IOException { if ( ! buffer . isReadable ( ) ) { return - <int> ; } return buffer . readByte ( ) & <hex> ; } @Override public int read ( byte [ ] b , int off , int len ) throws IOException { int available = available ( ) ; if ( available = = <int> ) { return - <int> ; } len = Math . min ( available , len ) ; buffer . readBytes ( b , off , len ) ; return len ; } @Override public void reset ( ) throws IOException { buffer . resetReaderIndex ( ) ; } @Override public long skip ( long n ) throws IOException { if ( n > Integer . MAX_VALUE ) { return skipBytes ( Integer . MAX_VALUE ) ; } else { return skipBytes ( ( int ) n ) ; } } @Override public boolean readBoolean ( ) throws IOException { checkAvailable ( <int> ) ; return read ( ) ! = <int> ; } @Override public byte readByte ( ) throws IOException { if ( ! buffer . isReadable ( ) ) { throw new EOFException ( ) ; } return buffer . readByte ( ) ; } @Override public char readChar ( ) throws IOException { return ( char ) readShort ( ) ; } @Override public double readDouble ( ) throws IOException { return Double . longBitsToDouble ( readLong ( ) ) ; } @Override public float readFloat ( ) throws IOException { return Float . intBitsToFloat ( readInt ( ) ) ; } @Override public void readFully ( byte [ ] b ) throws IOException { readFully ( b , <int> , b . length ) ; } @Override public void readFully ( byte [ ] b , int off , int len ) throws IOException { checkAvailable ( len ) ; buffer . readBytes ( b , off , len ) ; } @Override public int readInt ( ) throws IOException { checkAvailable ( <int> ) ; return buffer . readInt ( ) ; } private final StringBuilder lineBuf = new StringBuilder ( ) ; @Override public String readLine ( ) throws IOException { lineBuf . setLength ( <int> ) ; loop: while ( true ) { if ( ! buffer . isReadable ( ) ) { return lineBuf . length ( ) > <int> ? lineBuf . toString ( ) : null ; } int c = buffer . readUnsignedByte ( ) ; switch ( c ) { case <str> : break loop ; case <str> : if ( buffer . isReadable ( ) & & ( char ) buffer . getUnsignedByte ( buffer . readerIndex ( ) ) = = <str> ) { buffer . skipBytes ( <int> ) ; } break loop ; default: lineBuf . append ( ( char ) c ) ; } } return lineBuf . toString ( ) ; } @Override public long readLong ( ) throws IOException { checkAvailable ( <int> ) ; return buffer . readLong ( ) ; } @Override public short readShort ( ) throws IOException { checkAvailable ( <int> ) ; return buffer . readShort ( ) ; } @Override public String readUTF ( ) throws IOException { return DataInputStream . readUTF ( this ) ; } @Override public int readUnsignedByte ( ) throws IOException { return readByte ( ) & <hex> ; } @Override public int readUnsignedShort ( ) throws IOException { return readShort ( ) & <hex> ; } @Override public int skipBytes ( int n ) throws IOException { int nBytes = Math . min ( available ( ) , n ) ; buffer . skipBytes ( nBytes ) ; return nBytes ; } private void checkAvailable ( int fieldSize ) throws IOException { if ( fieldSize < <int> ) { throw new IndexOutOfBoundsException ( <str> ) ; } if ( fieldSize > available ( ) ) { throw new EOFException ( <str> + fieldSize + <str> + available ( ) ) ; } } } 
