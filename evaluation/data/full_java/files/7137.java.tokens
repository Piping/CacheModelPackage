package org . elasticsearch . search . aggregations ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import java . util . List ; import java . util . Map ; public abstract class InternalMultiBucketAggregation < A extends InternalMultiBucketAggregation , B extends InternalMultiBucketAggregation . InternalBucket > extends InternalAggregation implements MultiBucketsAggregation { public InternalMultiBucketAggregation ( ) { } public InternalMultiBucketAggregation ( String name , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; } public abstract A create ( List < B > buckets ) ; public abstract B createBucket ( InternalAggregations aggregations , B prototype ) ; @Override public Object getProperty ( List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } else { List < ? extends Bucket > buckets = getBuckets ( ) ; Object [ ] propertyArray = new Object [ buckets . size ( ) ] ; for ( int i = <int> ; i < buckets . size ( ) ; i + + ) { propertyArray [ i ] = buckets . get ( i ) . getProperty ( getName ( ) , path ) ; } return propertyArray ; } } public static abstract class InternalBucket implements Bucket { @Override public Object getProperty ( String containingAggName , List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } Aggregations aggregations = getAggregations ( ) ; String aggName = path . get ( <int> ) ; if ( aggName . equals ( <str> ) ) { if ( path . size ( ) > <int> ) { throw new InvalidAggregationPathException ( <str> ) ; } return getDocCount ( ) ; } else if ( aggName . equals ( <str> ) ) { if ( path . size ( ) > <int> ) { throw new InvalidAggregationPathException ( <str> ) ; } return getKey ( ) ; } InternalAggregation aggregation = aggregations . get ( aggName ) ; if ( aggregation = = null ) { throw new InvalidAggregationPathException ( <str> + aggName + <str> + containingAggName + <str> ) ; } return aggregation . getProperty ( path . subList ( <int> , path . size ( ) ) ) ; } } } 
