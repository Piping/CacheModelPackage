package org . elasticsearch . search . sort ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Sort ; import org . apache . lucene . search . SortField ; import org . apache . lucene . search . join . BitSetProducer ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . index . query . support . NestedInnerQueryParseSupport ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class SortParseElement implements SearchParseElement { public static final SortField SORT_SCORE = new SortField ( null , SortField . Type . SCORE ) ; private static final SortField SORT_SCORE_REVERSE = new SortField ( null , SortField . Type . SCORE , true ) ; private static final SortField SORT_DOC = new SortField ( null , SortField . Type . DOC ) ; private static final SortField SORT_DOC_REVERSE = new SortField ( null , SortField . Type . DOC , true ) ; public static final ParseField IGNORE_UNMAPPED = new ParseField ( <str> ) ; public static final ParseField UNMAPPED_TYPE = new ParseField ( <str> ) ; public static final String SCORE_FIELD_NAME = <str> ; public static final String DOC_FIELD_NAME = <str> ; private static final Map < String , SortParser > PARSERS ; static { Map < String , SortParser > parsers = new HashMap < > ( ) ; addParser ( parsers , new ScriptSortParser ( ) ) ; addParser ( parsers , new GeoDistanceSortParser ( ) ) ; PARSERS = unmodifiableMap ( parsers ) ; } private static void addParser ( Map < String , SortParser > parsers , SortParser parser ) { for ( String name : parser . names ( ) ) { parsers . put ( name , parser ) ; } } @Override public void parse ( XContentParser parser , SearchContext context ) throws Exception { XContentParser . Token token = parser . currentToken ( ) ; List < SortField > sortFields = new ArrayList < > ( <int> ) ; if ( token = = XContentParser . Token . START_ARRAY ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . START_OBJECT ) { addCompoundSortField ( parser , context , sortFields ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { addSortField ( context , sortFields , parser . text ( ) , false , null , null , null , null ) ; } else { throw new IllegalArgumentException ( <str> ) ; } } } else if ( token = = XContentParser . Token . VALUE_STRING ) { addSortField ( context , sortFields , parser . text ( ) , false , null , null , null , null ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { addCompoundSortField ( parser , context , sortFields ) ; } else { throw new IllegalArgumentException ( <str> ) ; } if ( ! sortFields . isEmpty ( ) ) { boolean sort ; if ( sortFields . size ( ) > <int> ) { sort = true ; } else { SortField sortField = sortFields . get ( <int> ) ; if ( sortField . getType ( ) = = SortField . Type . SCORE & & ! sortField . getReverse ( ) ) { sort = false ; } else { sort = true ; } } if ( sort ) { context . sort ( new Sort ( sortFields . toArray ( new SortField [ sortFields . size ( ) ] ) ) ) ; } } } private void addCompoundSortField ( XContentParser parser , SearchContext context , List < SortField > sortFields ) throws Exception { XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String fieldName = parser . currentName ( ) ; boolean reverse = false ; String missing = null ; String innerJsonName = null ; String unmappedType = null ; MultiValueMode sortMode = null ; NestedInnerQueryParseSupport nestedFilterParseHelper = null ; token = parser . nextToken ( ) ; if ( token = = XContentParser . Token . VALUE_STRING ) { String direction = parser . text ( ) ; if ( direction . equals ( <str> ) ) { reverse = SCORE_FIELD_NAME . equals ( fieldName ) ; } else if ( direction . equals ( <str> ) ) { reverse = ! SCORE_FIELD_NAME . equals ( fieldName ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } addSortField ( context , sortFields , fieldName , reverse , unmappedType , missing , sortMode , nestedFilterParseHelper ) ; } else { if ( PARSERS . containsKey ( fieldName ) ) { sortFields . add ( PARSERS . get ( fieldName ) . parse ( parser , context ) ) ; } else { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { innerJsonName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( innerJsonName ) ) { reverse = parser . booleanValue ( ) ; } else if ( <str> . equals ( innerJsonName ) ) { if ( <str> . equals ( parser . text ( ) ) ) { reverse = SCORE_FIELD_NAME . equals ( fieldName ) ; } else if ( <str> . equals ( parser . text ( ) ) ) { reverse = ! SCORE_FIELD_NAME . equals ( fieldName ) ; } } else if ( <str> . equals ( innerJsonName ) ) { missing = parser . textOrNull ( ) ; } else if ( context . parseFieldMatcher ( ) . match ( innerJsonName , IGNORE_UNMAPPED ) ) { if ( unmappedType = = null & & parser . booleanValue ( ) ) { unmappedType = LongFieldMapper . CONTENT_TYPE ; } } else if ( context . parseFieldMatcher ( ) . match ( innerJsonName , UNMAPPED_TYPE ) ) { unmappedType = parser . textOrNull ( ) ; } else if ( <str> . equals ( innerJsonName ) ) { sortMode = MultiValueMode . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( innerJsonName ) | | <str> . equals ( innerJsonName ) ) { if ( nestedFilterParseHelper = = null ) { nestedFilterParseHelper = new NestedInnerQueryParseSupport ( parser , context ) ; } nestedFilterParseHelper . setPath ( parser . text ( ) ) ; } else { throw new IllegalArgumentException ( <str> + innerJsonName + <str> ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( innerJsonName ) | | <str> . equals ( innerJsonName ) ) { if ( nestedFilterParseHelper = = null ) { nestedFilterParseHelper = new NestedInnerQueryParseSupport ( parser , context ) ; } nestedFilterParseHelper . filter ( ) ; } else { throw new IllegalArgumentException ( <str> + innerJsonName + <str> ) ; } } } addSortField ( context , sortFields , fieldName , reverse , unmappedType , missing , sortMode , nestedFilterParseHelper ) ; } } } } } private void addSortField ( SearchContext context , List < SortField > sortFields , String fieldName , boolean reverse , String unmappedType , @Nullable final String missing , MultiValueMode sortMode , NestedInnerQueryParseSupport nestedHelper ) throws IOException { if ( SCORE_FIELD_NAME . equals ( fieldName ) ) { if ( reverse ) { sortFields . add ( SORT_SCORE_REVERSE ) ; } else { sortFields . add ( SORT_SCORE ) ; } } else if ( DOC_FIELD_NAME . equals ( fieldName ) ) { if ( reverse ) { sortFields . add ( SORT_DOC_REVERSE ) ; } else { sortFields . add ( SORT_DOC ) ; } } else { MappedFieldType fieldType = context . smartNameFieldType ( fieldName ) ; if ( fieldType = = null ) { if ( unmappedType ! = null ) { fieldType = context . mapperService ( ) . unmappedFieldType ( unmappedType ) ; } else { throw new SearchParseException ( context , <str> + fieldName + <str> , null ) ; } } if ( ! fieldType . isSortable ( ) ) { throw new SearchParseException ( context , <str> + fieldName + <str> , null ) ; } if ( fieldType . isNumeric ( ) = = false & & ( sortMode = = MultiValueMode . SUM | | sortMode = = MultiValueMode . AVG ) ) { sortMode = null ; } if ( sortMode = = null ) { sortMode = resolveDefaultSortMode ( reverse ) ; } final Nested nested ; if ( nestedHelper ! = null & & nestedHelper . getPath ( ) ! = null ) { BitSetProducer rootDocumentsFilter = context . bitsetFilterCache ( ) . getBitSetProducer ( Queries . newNonNestedFilter ( ) ) ; Query innerDocumentsFilter ; if ( nestedHelper . filterFound ( ) ) { innerDocumentsFilter = nestedHelper . getInnerFilter ( ) ; } else { innerDocumentsFilter = nestedHelper . getNestedObjectMapper ( ) . nestedTypeFilter ( ) ; } nested = new Nested ( rootDocumentsFilter , context . searcher ( ) . createNormalizedWeight ( innerDocumentsFilter , false ) ) ; } else { nested = null ; } IndexFieldData . XFieldComparatorSource fieldComparatorSource = context . fieldData ( ) . getForField ( fieldType ) . comparatorSource ( missing , sortMode , nested ) ; sortFields . add ( new SortField ( fieldType . names ( ) . indexName ( ) , fieldComparatorSource , reverse ) ) ; } } private static MultiValueMode resolveDefaultSortMode ( boolean reverse ) { return reverse ? MultiValueMode . MAX : MultiValueMode . MIN ; } } 
