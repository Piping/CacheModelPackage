package io . netty . test . udt . nio ; import com . yammer . metrics . Metrics ; import com . yammer . metrics . core . Meter ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . udt . nio . NioUdtByteRendezvousChannel ; import io . netty . channel . udt . nio . NioUdtProvider ; import io . netty . test . udt . util . EchoByteHandler ; import io . netty . test . udt . util . UnitHelp ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import static org . junit . Assert . * ; public class NioUdtByteRendezvousChannelTest extends AbstractUdtTest { private static final InternalLogger log = InternalLoggerFactory . getInstance ( NioUdtByteAcceptorChannelTest . class ) ; @Test public void metadata ( ) throws Exception { assertFalse ( new NioUdtByteRendezvousChannel ( ) . metadata ( ) . hasDisconnect ( ) ) ; } @Test ( timeout = <int> * <int> ) public void basicEcho ( ) throws Exception { final int messageSize = <int> * <int> ; final int transferLimit = messageSize * <int> ; final Meter rate1 = Metrics . newMeter ( NioUdtMessageRendezvousChannelTest . class , <str> , <str> , TimeUnit . SECONDS ) ; final Meter rate2 = Metrics . newMeter ( NioUdtMessageRendezvousChannelTest . class , <str> , <str> , TimeUnit . SECONDS ) ; final InetSocketAddress addr1 = UnitHelp . localSocketAddress ( ) ; final InetSocketAddress addr2 = UnitHelp . localSocketAddress ( ) ; final EchoByteHandler handler1 = new EchoByteHandler ( rate1 , messageSize ) ; final EchoByteHandler handler2 = new EchoByteHandler ( rate2 , messageSize ) ; final NioEventLoopGroup group1 = new NioEventLoopGroup ( <int> , Executors . defaultThreadFactory ( ) , NioUdtProvider . BYTE_PROVIDER ) ; final NioEventLoopGroup group2 = new NioEventLoopGroup ( <int> , Executors . defaultThreadFactory ( ) , NioUdtProvider . BYTE_PROVIDER ) ; final Bootstrap boot1 = new Bootstrap ( ) ; boot1 . group ( group1 ) . channelFactory ( NioUdtProvider . BYTE_RENDEZVOUS ) . localAddress ( addr1 ) . remoteAddress ( addr2 ) . handler ( handler1 ) ; final Bootstrap boot2 = new Bootstrap ( ) ; boot2 . group ( group1 ) . channelFactory ( NioUdtProvider . BYTE_RENDEZVOUS ) . localAddress ( addr2 ) . remoteAddress ( addr1 ) . handler ( handler2 ) ; final ChannelFuture connectFuture1 = boot1 . connect ( ) ; final ChannelFuture connectFuture2 = boot2 . connect ( ) ; while ( handler1 . meter ( ) . count ( ) < transferLimit & & handler2 . meter ( ) . count ( ) < transferLimit ) { log . info ( <str> , handler1 . meter ( ) . count ( ) , handler2 . meter ( ) . count ( ) ) ; Thread . sleep ( <int> ) ; } connectFuture1 . channel ( ) . close ( ) . sync ( ) ; connectFuture2 . channel ( ) . close ( ) . sync ( ) ; log . info ( <str> , handler1 . meter ( ) . count ( ) ) ; log . info ( <str> , handler2 . meter ( ) . count ( ) ) ; assertTrue ( handler1 . meter ( ) . count ( ) > = transferLimit ) ; assertTrue ( handler2 . meter ( ) . count ( ) > = transferLimit ) ; assertEquals ( handler1 . meter ( ) . count ( ) , handler2 . meter ( ) . count ( ) ) ; group1 . shutdownGracefully ( ) ; group2 . shutdownGracefully ( ) ; group1 . terminationFuture ( ) . sync ( ) ; group2 . terminationFuture ( ) . sync ( ) ; } } 
