package org . elasticsearch . test ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . store . * ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import java . util . Random ; import static org . apache . lucene . util . LuceneTestCase . assumeTrue ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; public final class CorruptionUtils { private static ESLogger logger = ESLoggerFactory . getLogger ( <str> ) ; private CorruptionUtils ( ) { } public static void corruptFile ( Random random , Path . . . files ) throws IOException { assertTrue ( <str> , files . length > <int> ) ; final Path fileToCorrupt = RandomPicks . randomFrom ( random , files ) ; assertTrue ( fileToCorrupt + <str> , Files . isRegularFile ( fileToCorrupt ) ) ; try ( Directory dir = FSDirectory . open ( fileToCorrupt . toAbsolutePath ( ) . getParent ( ) ) ) { long checksumBeforeCorruption ; try ( IndexInput input = dir . openInput ( fileToCorrupt . getFileName ( ) . toString ( ) , IOContext . DEFAULT ) ) { checksumBeforeCorruption = CodecUtil . retrieveChecksum ( input ) ; } try ( FileChannel raf = FileChannel . open ( fileToCorrupt , StandardOpenOption . READ , StandardOpenOption . WRITE ) ) { raf . position ( random . nextInt ( ( int ) Math . min ( Integer . MAX_VALUE , raf . size ( ) ) ) ) ; long filePointer = raf . position ( ) ; ByteBuffer bb = ByteBuffer . wrap ( new byte [ <int> ] ) ; raf . read ( bb ) ; bb . flip ( ) ; byte oldValue = bb . get ( <int> ) ; byte newValue = ( byte ) ( oldValue + <int> ) ; bb . put ( <int> , newValue ) ; raf . position ( filePointer ) ; raf . write ( bb ) ; logger . info ( <str> , filePointer , Integer . toHexString ( oldValue ) , Integer . toHexString ( newValue ) , fileToCorrupt . getFileName ( ) ) ; } long checksumAfterCorruption ; long actualChecksumAfterCorruption ; try ( ChecksumIndexInput input = dir . openChecksumInput ( fileToCorrupt . getFileName ( ) . toString ( ) , IOContext . DEFAULT ) ) { assertThat ( input . getFilePointer ( ) , is ( <int> l ) ) ; input . seek ( input . length ( ) - <int> ) ; checksumAfterCorruption = input . getChecksum ( ) ; actualChecksumAfterCorruption = input . readLong ( ) ; } StringBuilder msg = new StringBuilder ( ) ; msg . append ( <str> ) . append ( checksumBeforeCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( checksumAfterCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( actualChecksumAfterCorruption ) . append ( <str> ) ; msg . append ( <str> ) . append ( fileToCorrupt . getFileName ( ) ) . append ( <str> ) . append ( dir . fileLength ( fileToCorrupt . getFileName ( ) . toString ( ) ) ) ; logger . info ( msg . toString ( ) ) ; assumeTrue ( <str> + msg . toString ( ) , checksumAfterCorruption ! = checksumBeforeCorruption | | actualChecksumAfterCorruption ! = checksumBeforeCorruption ) ; assertThat ( <str> , fileToCorrupt , notNullValue ( ) ) ; } } } 
