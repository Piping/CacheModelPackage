package org . apache . cassandra . cql3 ; import static org . apache . cassandra . cql3 . Constants . UNSET_VALUE ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import java . util . stream . Collectors ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . db . marshal . ListType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . serializers . CollectionSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; public abstract class Lists { private Lists ( ) { } public static ColumnSpecification indexSpecOf ( ColumnSpecification column ) { return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( <str> + column . name + <str> , true ) , Int32Type . instance ) ; } public static ColumnSpecification valueSpecOf ( ColumnSpecification column ) { return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( <str> + column . name + <str> , true ) , ( ( ListType ) column . type ) . getElementsType ( ) ) ; } public static class Literal extends Term . Raw { private final List < Term . Raw > elements ; public Literal ( List < Term . Raw > elements ) { this . elements = elements ; } public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { validateAssignableTo ( keyspace , receiver ) ; ColumnSpecification valueSpec = Lists . valueSpecOf ( receiver ) ; List < Term > values = new ArrayList < > ( elements . size ( ) ) ; boolean allTerminal = true ; for ( Term . Raw rt : elements ) { Term t = rt . prepare ( keyspace , valueSpec ) ; if ( t . containsBindMarker ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; if ( t instanceof Term . NonTerminal ) allTerminal = false ; values . add ( t ) ; } DelayedValue value = new DelayedValue ( values ) ; return allTerminal ? value . bind ( QueryOptions . DEFAULT ) : value ; } private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof ListType ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; ColumnSpecification valueSpec = Lists . valueSpecOf ( receiver ) ; for ( Term . Raw rt : elements ) { if ( ! rt . testAssignment ( keyspace , valueSpec ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , rt , valueSpec . type . asCQL3Type ( ) ) ) ; } } public AssignmentTestable . TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { if ( ! ( receiver . type instanceof ListType ) ) return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; if ( elements . isEmpty ( ) ) return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; ColumnSpecification valueSpec = Lists . valueSpecOf ( receiver ) ; return AssignmentTestable . TestResult . testAll ( keyspace , valueSpec , elements ) ; } public String getText ( ) { return elements . stream ( ) . map ( Term . Raw : : getText ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } } public static class Value extends Term . MultiItemTerminal { public final List < ByteBuffer > elements ; public Value ( List < ByteBuffer > elements ) { this . elements = elements ; } public static Value fromSerialized ( ByteBuffer value , ListType type , int version ) throws InvalidRequestException { try { List < ? > l = type . getSerializer ( ) . deserializeForNativeProtocol ( value , version ) ; List < ByteBuffer > elements = new ArrayList < > ( l . size ( ) ) ; for ( Object element : l ) elements . add ( element = = null ? null : type . getElementsType ( ) . decompose ( element ) ) ; return new Value ( elements ) ; } catch ( MarshalException e ) { throw new InvalidRequestException ( e . getMessage ( ) ) ; } } public ByteBuffer get ( int protocolVersion ) { return CollectionSerializer . pack ( elements , elements . size ( ) , protocolVersion ) ; } public boolean equals ( ListType lt , Value v ) { if ( elements . size ( ) ! = v . elements . size ( ) ) return false ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) if ( lt . getElementsType ( ) . compare ( elements . get ( i ) , v . elements . get ( i ) ) ! = <int> ) return false ; return true ; } public List < ByteBuffer > getElements ( ) { return elements ; } } public static class DelayedValue extends Term . NonTerminal { private final List < Term > elements ; public DelayedValue ( List < Term > elements ) { this . elements = elements ; } public boolean containsBindMarker ( ) { return false ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { } public Terminal bind ( QueryOptions options ) throws InvalidRequestException { List < ByteBuffer > buffers = new ArrayList < ByteBuffer > ( elements . size ( ) ) ; for ( Term t : elements ) { ByteBuffer bytes = t . bindAndGet ( options ) ; if ( bytes = = null ) throw new InvalidRequestException ( <str> ) ; if ( bytes = = ByteBufferUtil . UNSET_BYTE_BUFFER ) return UNSET_VALUE ; buffers . add ( bytes ) ; } return new Value ( buffers ) ; } public Iterable < Function > getFunctions ( ) { return Terms . getFunctions ( elements ) ; } } public static class Marker extends AbstractMarker { protected Marker ( int bindIndex , ColumnSpecification receiver ) { super ( bindIndex , receiver ) ; assert receiver . type instanceof ListType ; } public Terminal bind ( QueryOptions options ) throws InvalidRequestException { ByteBuffer value = options . getValues ( ) . get ( bindIndex ) ; if ( value = = null ) return null ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) return UNSET_VALUE ; return Value . fromSerialized ( value , ( ListType ) receiver . type , options . getProtocolVersion ( ) ) ; } } private static class PrecisionTime { private static final long REFERENCE_TIME = <int> ; private static final AtomicReference < PrecisionTime > last = new AtomicReference < > ( new PrecisionTime ( Long . MAX_VALUE , <int> ) ) ; public final long millis ; public final int nanos ; PrecisionTime ( long millis , int nanos ) { this . millis = millis ; this . nanos = nanos ; } static PrecisionTime getNext ( long millis ) { while ( true ) { PrecisionTime current = last . get ( ) ; assert millis < = current . millis ; PrecisionTime next = millis < current . millis ? new PrecisionTime ( millis , <int> ) : new PrecisionTime ( millis , Math . max ( <int> , current . nanos - <int> ) ) ; if ( last . compareAndSet ( current , next ) ) return next ; } } } public static class Setter extends Operation { public Setter ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { Term . Terminal value = t . bind ( params . options ) ; if ( value = = UNSET_VALUE ) return ; if ( column . type . isMultiCell ( ) ) params . setComplexDeletionTimeForOverwrite ( column ) ; Appender . doAppend ( value , column , params ) ; } } private static int existingSize ( Row row , ColumnDefinition column ) { if ( row = = null ) return <int> ; ComplexColumnData complexData = row . getComplexColumnData ( column ) ; return complexData = = null ? <int> : complexData . cellsCount ( ) ; } public static class SetterByIndex extends Operation { private final Term idx ; public SetterByIndex ( ColumnDefinition column , Term idx , Term t ) { super ( column , t ) ; this . idx = idx ; } @Override public boolean requiresRead ( ) { return true ; } @Override public void collectMarkerSpecification ( VariableSpecifications boundNames ) { super . collectMarkerSpecification ( boundNames ) ; idx . collectMarkerSpecification ( boundNames ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; ByteBuffer index = idx . bindAndGet ( params . options ) ; ByteBuffer value = t . bindAndGet ( params . options ) ; if ( index = = null ) throw new InvalidRequestException ( <str> ) ; if ( index = = ByteBufferUtil . UNSET_BYTE_BUFFER ) throw new InvalidRequestException ( <str> ) ; Row existingRow = params . getPrefetchedRow ( partitionKey , params . currentClustering ( ) ) ; int existingSize = existingSize ( existingRow , column ) ; int idx = ByteBufferUtil . toInt ( index ) ; if ( existingSize = = <int> ) throw new InvalidRequestException ( <str> ) ; if ( idx < <int> | | idx > = existingSize ) throw new InvalidRequestException ( String . format ( <str> , idx , existingSize ) ) ; CellPath elementPath = existingRow . getComplexColumnData ( column ) . getCellByIndex ( idx ) . path ( ) ; if ( value = = null ) { params . addTombstone ( column ) ; } else if ( value ! = ByteBufferUtil . UNSET_BYTE_BUFFER ) { params . addCell ( column , elementPath , value ) ; } } } public static class Appender extends Operation { public Appender ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal value = t . bind ( params . options ) ; doAppend ( value , column , params ) ; } static void doAppend ( Term . Terminal value , ColumnDefinition column , UpdateParameters params ) throws InvalidRequestException { if ( column . type . isMultiCell ( ) ) { if ( value = = null ) return ; for ( ByteBuffer buffer : ( ( Value ) value ) . elements ) { ByteBuffer uuid = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ; params . addCell ( column , CellPath . create ( uuid ) , buffer ) ; } } else { if ( value = = null ) params . addTombstone ( column ) ; else params . addCell ( column , value . get ( Server . CURRENT_VERSION ) ) ; } } } public static class Prepender extends Operation { public Prepender ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal value = t . bind ( params . options ) ; if ( value = = null | | value = = UNSET_VALUE ) return ; long time = PrecisionTime . REFERENCE_TIME - ( System . currentTimeMillis ( ) - PrecisionTime . REFERENCE_TIME ) ; List < ByteBuffer > toAdd = ( ( Value ) value ) . elements ; for ( int i = toAdd . size ( ) - <int> ; i > = <int> ; i - - ) { PrecisionTime pt = PrecisionTime . getNext ( time ) ; ByteBuffer uuid = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( pt . millis , pt . nanos ) ) ; params . addCell ( column , CellPath . create ( uuid ) , toAdd . get ( i ) ) ; } } } public static class Discarder extends Operation { public Discarder ( ColumnDefinition column , Term t ) { super ( column , t ) ; } @Override public boolean requiresRead ( ) { return true ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal value = t . bind ( params . options ) ; Row existingRow = params . getPrefetchedRow ( partitionKey , params . currentClustering ( ) ) ; ComplexColumnData complexData = existingRow = = null ? null : existingRow . getComplexColumnData ( column ) ; if ( value = = null | | value = = UNSET_VALUE | | complexData = = null ) return ; List < ByteBuffer > toDiscard = ( ( Value ) value ) . elements ; for ( Cell cell : complexData ) { if ( toDiscard . contains ( cell . value ( ) ) ) params . addTombstone ( column , cell . path ( ) ) ; } } } public static class DiscarderByIndex extends Operation { public DiscarderByIndex ( ColumnDefinition column , Term idx ) { super ( column , idx ) ; } @Override public boolean requiresRead ( ) { return true ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal index = t . bind ( params . options ) ; if ( index = = null ) throw new InvalidRequestException ( <str> ) ; if ( index = = Constants . UNSET_VALUE ) return ; Row existingRow = params . getPrefetchedRow ( partitionKey , params . currentClustering ( ) ) ; int existingSize = existingSize ( existingRow , column ) ; int idx = ByteBufferUtil . toInt ( index . get ( params . options . getProtocolVersion ( ) ) ) ; if ( existingSize = = <int> ) throw new InvalidRequestException ( <str> ) ; if ( idx < <int> | | idx > = existingSize ) throw new InvalidRequestException ( String . format ( <str> , idx , existingSize ) ) ; params . addTombstone ( column , existingRow . getComplexColumnData ( column ) . getCellByIndex ( idx ) . path ( ) ) ; } } } 
