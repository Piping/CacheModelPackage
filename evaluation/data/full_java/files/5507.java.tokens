package org . elasticsearch . client . transport ; import org . elasticsearch . Version ; import org . elasticsearch . action . Action ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionModule ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestBuilder ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . cache . recycler . PageCacheRecycler ; import org . elasticsearch . client . support . AbstractClient ; import org . elasticsearch . client . support . Headers ; import org . elasticsearch . client . transport . support . TransportProxyClient ; import org . elasticsearch . cluster . ClusterNameModule ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . LifecycleComponent ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . network . NetworkModule ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . settings . SettingsModule ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . EnvironmentModule ; import org . elasticsearch . indices . breaker . CircuitBreakerModule ; import org . elasticsearch . monitor . MonitorService ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . plugins . PluginsModule ; import org . elasticsearch . plugins . PluginsService ; import org . elasticsearch . search . SearchModule ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolModule ; import org . elasticsearch . transport . TransportModule ; import org . elasticsearch . transport . TransportService ; import org . elasticsearch . transport . netty . NettyTransport ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class TransportClient extends AbstractClient { public static Builder builder ( ) { return new Builder ( ) ; } public static class Builder { private Settings settings = Settings . EMPTY ; private List < Class < ? extends Plugin > > pluginClasses = new ArrayList < > ( ) ; public Builder settings ( Settings . Builder settings ) { return settings ( settings . build ( ) ) ; } public Builder settings ( Settings settings ) { this . settings = settings ; return this ; } public Builder addPlugin ( Class < ? extends Plugin > pluginClass ) { pluginClasses . add ( pluginClass ) ; return this ; } public TransportClient build ( ) { Settings settings = InternalSettingsPreparer . prepareSettings ( this . settings ) ; settings = settingsBuilder ( ) . put ( NettyTransport . PING_SCHEDULE , <str> ) . put ( settings ) . put ( <str> , false ) . put ( <str> , true ) . put ( CLIENT_TYPE_SETTING , CLIENT_TYPE ) . build ( ) ; PluginsService pluginsService = new PluginsService ( settings , null , null , pluginClasses ) ; this . settings = pluginsService . updatedSettings ( ) ; Version version = Version . CURRENT ; final ThreadPool threadPool = new ThreadPool ( settings ) ; final NetworkService networkService = new NetworkService ( settings ) ; final SettingsFilter settingsFilter = new SettingsFilter ( settings ) ; boolean success = false ; try { ModulesBuilder modules = new ModulesBuilder ( ) ; modules . add ( new Version . Module ( version ) ) ; for ( Module pluginModule : pluginsService . nodeModules ( ) ) { modules . add ( pluginModule ) ; } modules . add ( new PluginsModule ( pluginsService ) ) ; modules . add ( new SettingsModule ( this . settings , settingsFilter ) ) ; modules . add ( new NetworkModule ( networkService ) ) ; modules . add ( new ClusterNameModule ( this . settings ) ) ; modules . add ( new ThreadPoolModule ( threadPool ) ) ; modules . add ( new TransportModule ( this . settings ) ) ; modules . add ( new SearchModule ( ) { @Override protected void configure ( ) { } } ) ; modules . add ( new ActionModule ( true ) ) ; modules . add ( new ClientTransportModule ( ) ) ; modules . add ( new CircuitBreakerModule ( this . settings ) ) ; pluginsService . processModules ( modules ) ; Injector injector = modules . createInjector ( ) ; injector . getInstance ( TransportService . class ) . start ( ) ; TransportClient transportClient = new TransportClient ( injector ) ; success = true ; return transportClient ; } finally { if ( ! success ) { ThreadPool . terminate ( threadPool , <int> , TimeUnit . SECONDS ) ; } } } } public static final String CLIENT_TYPE = <str> ; final Injector injector ; private final TransportClientNodesService nodesService ; private final TransportProxyClient proxy ; private TransportClient ( Injector injector ) { super ( injector . getInstance ( Settings . class ) , injector . getInstance ( ThreadPool . class ) , injector . getInstance ( Headers . class ) ) ; this . injector = injector ; nodesService = injector . getInstance ( TransportClientNodesService . class ) ; proxy = injector . getInstance ( TransportProxyClient . class ) ; } TransportClientNodesService nodeService ( ) { return nodesService ; } public List < TransportAddress > transportAddresses ( ) { return nodesService . transportAddresses ( ) ; } public List < DiscoveryNode > connectedNodes ( ) { return nodesService . connectedNodes ( ) ; } public List < DiscoveryNode > filteredNodes ( ) { return nodesService . filteredNodes ( ) ; } public List < DiscoveryNode > listedNodes ( ) { return nodesService . listedNodes ( ) ; } public TransportClient addTransportAddress ( TransportAddress transportAddress ) { nodesService . addTransportAddresses ( transportAddress ) ; return this ; } public TransportClient addTransportAddresses ( TransportAddress . . . transportAddress ) { nodesService . addTransportAddresses ( transportAddress ) ; return this ; } public TransportClient removeTransportAddress ( TransportAddress transportAddress ) { nodesService . removeTransportAddress ( transportAddress ) ; return this ; } @Override public void close ( ) { injector . getInstance ( TransportClientNodesService . class ) . close ( ) ; injector . getInstance ( TransportService . class ) . close ( ) ; try { injector . getInstance ( MonitorService . class ) . close ( ) ; } catch ( Exception e ) { } for ( Class < ? extends LifecycleComponent > plugin : injector . getInstance ( PluginsService . class ) . nodeServices ( ) ) { injector . getInstance ( plugin ) . close ( ) ; } try { ThreadPool . terminate ( injector . getInstance ( ThreadPool . class ) , <int> , TimeUnit . SECONDS ) ; } catch ( Exception e ) { } injector . getInstance ( PageCacheRecycler . class ) . close ( ) ; } @Override protected < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > void doExecute ( Action < Request , Response , RequestBuilder > action , Request request , ActionListener < Response > listener ) { proxy . execute ( action , request , listener ) ; } } 
