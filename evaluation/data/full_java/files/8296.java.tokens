package org . elasticsearch . index . shard ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . AllocationId ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import java . io . IOException ; import java . nio . file . Path ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . is ; public class ShardPathTests extends ESTestCase { public void testLoadShardPath ( ) throws IOException { try ( final NodeEnvironment env = newNodeEnvironment ( settingsBuilder ( ) . build ( ) ) ) { Settings . Builder builder = settingsBuilder ( ) . put ( IndexMetaData . SETTING_INDEX_UUID , <str> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) ; Settings settings = builder . build ( ) ; ShardId shardId = new ShardId ( <str> , <int> ) ; Path [ ] paths = env . availableShardPaths ( shardId ) ; Path path = randomFrom ( paths ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( <int> , true , <str> , AllocationId . newInitializing ( ) ) , <int> , path ) ; ShardPath shardPath = ShardPath . loadShardPath ( logger , env , shardId , IndexSettingsModule . newIndexSettings ( shardId . index ( ) , settings ) ) ; assertEquals ( path , shardPath . getDataPath ( ) ) ; assertEquals ( <str> , shardPath . getIndexUUID ( ) ) ; assertEquals ( <str> , shardPath . getShardId ( ) . getIndex ( ) ) ; assertEquals ( path . resolve ( <str> ) , shardPath . resolveTranslog ( ) ) ; assertEquals ( path . resolve ( <str> ) , shardPath . resolveIndex ( ) ) ; } } public void testFailLoadShardPathOnMultiState ( ) throws IOException { try ( final NodeEnvironment env = newNodeEnvironment ( settingsBuilder ( ) . build ( ) ) ) { Settings . Builder builder = settingsBuilder ( ) . put ( IndexMetaData . SETTING_INDEX_UUID , <str> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) ; Settings settings = builder . build ( ) ; ShardId shardId = new ShardId ( <str> , <int> ) ; Path [ ] paths = env . availableShardPaths ( shardId ) ; assumeTrue ( <str> , paths . length > <int> ) ; int id = randomIntBetween ( <int> , <int> ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( id , true , <str> , AllocationId . newInitializing ( ) ) , id , paths ) ; ShardPath . loadShardPath ( logger , env , shardId , IndexSettingsModule . newIndexSettings ( shardId . index ( ) , settings ) ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testFailLoadShardPathIndexUUIDMissmatch ( ) throws IOException { try ( final NodeEnvironment env = newNodeEnvironment ( settingsBuilder ( ) . build ( ) ) ) { Settings . Builder builder = settingsBuilder ( ) . put ( IndexMetaData . SETTING_INDEX_UUID , <str> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) ; Settings settings = builder . build ( ) ; ShardId shardId = new ShardId ( <str> , <int> ) ; Path [ ] paths = env . availableShardPaths ( shardId ) ; Path path = randomFrom ( paths ) ; int id = randomIntBetween ( <int> , <int> ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( id , true , <str> , AllocationId . newInitializing ( ) ) , id , path ) ; ShardPath . loadShardPath ( logger , env , shardId , IndexSettingsModule . newIndexSettings ( shardId . index ( ) , settings ) ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testIllegalCustomDataPath ( ) { final Path path = createTempDir ( ) . resolve ( <str> ) . resolve ( <str> ) ; try { new ShardPath ( true , path , path , <str> , new ShardId ( <str> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testValidCtor ( ) { final Path path = createTempDir ( ) . resolve ( <str> ) . resolve ( <str> ) ; ShardPath shardPath = new ShardPath ( false , path , path , <str> , new ShardId ( <str> , <int> ) ) ; assertFalse ( shardPath . isCustomDataPath ( ) ) ; assertEquals ( shardPath . getDataPath ( ) , path ) ; assertEquals ( shardPath . getShardStatePath ( ) , path ) ; } public void testGetRootPaths ( ) throws IOException { boolean useCustomDataPath = randomBoolean ( ) ; final Settings indexSetttings ; final Settings nodeSettings ; Settings . Builder indexSettingsBuilder = settingsBuilder ( ) . put ( IndexMetaData . SETTING_INDEX_UUID , <str> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) ; final Path customPath ; if ( useCustomDataPath ) { final Path path = createTempDir ( ) ; final boolean includeNodeId = randomBoolean ( ) ; indexSetttings = indexSettingsBuilder . put ( IndexMetaData . SETTING_DATA_PATH , <str> ) . build ( ) ; nodeSettings = settingsBuilder ( ) . put ( <str> , path . toAbsolutePath ( ) . toAbsolutePath ( ) ) . put ( NodeEnvironment . ADD_NODE_ID_TO_CUSTOM_PATH , includeNodeId ) . build ( ) ; if ( includeNodeId ) { customPath = path . resolve ( <str> ) . resolve ( <str> ) ; } else { customPath = path . resolve ( <str> ) ; } } else { customPath = null ; indexSetttings = indexSettingsBuilder . build ( ) ; nodeSettings = Settings . EMPTY ; } try ( final NodeEnvironment env = newNodeEnvironment ( nodeSettings ) ) { ShardId shardId = new ShardId ( <str> , <int> ) ; Path [ ] paths = env . availableShardPaths ( shardId ) ; Path path = randomFrom ( paths ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( <int> , true , <str> , AllocationId . newInitializing ( ) ) , <int> , path ) ; ShardPath shardPath = ShardPath . loadShardPath ( logger , env , shardId , IndexSettingsModule . newIndexSettings ( shardId . index ( ) , indexSetttings ) ) ; boolean found = false ; for ( Path p : env . nodeDataPaths ( ) ) { if ( p . equals ( shardPath . getRootStatePath ( ) ) ) { found = true ; break ; } } assertTrue ( <str> + shardPath . getRootStatePath ( ) , found ) ; found = false ; if ( useCustomDataPath ) { assertNotEquals ( shardPath . getRootDataPath ( ) , shardPath . getRootStatePath ( ) ) ; assertEquals ( customPath , shardPath . getRootDataPath ( ) ) ; } else { assertNull ( customPath ) ; for ( Path p : env . nodeDataPaths ( ) ) { if ( p . equals ( shardPath . getRootDataPath ( ) ) ) { found = true ; break ; } } assertTrue ( <str> + shardPath . getRootDataPath ( ) , found ) ; } } } } 
