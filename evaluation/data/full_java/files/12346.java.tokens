package org . gradle . util ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . Project ; import java . util . Arrays ; import java . util . Comparator ; public class Path implements Comparable < Path > { private static final Comparator < String > STRING_COMPARATOR = GUtil . caseInsensitive ( ) ; private final String prefix ; private final String [ ] segments ; private final boolean absolute ; public static final Path ROOT = new Path ( Project . PATH_SEPARATOR ) ; private final String fullPath ; public Path ( String path ) { this ( StringUtils . split ( path , Project . PATH_SEPARATOR ) , path . startsWith ( Project . PATH_SEPARATOR ) , path . length ( ) > <int> & & path . endsWith ( Project . PATH_SEPARATOR ) ? path . substring ( <int> , path . length ( ) - <int> ) : path ) ; } private Path ( String [ ] segments , boolean absolute ) { this ( segments , absolute , createFullPath ( segments , absolute ) ) ; } private Path ( String [ ] segments , boolean absolute , String fullPath ) { this . segments = segments ; this . absolute = absolute ; this . fullPath = fullPath ; this . prefix = fullPath . endsWith ( Project . PATH_SEPARATOR ) ? fullPath : fullPath + Project . PATH_SEPARATOR ; } public static Path path ( String path ) { return path . equals ( Project . PATH_SEPARATOR ) ? ROOT : new Path ( path ) ; } @Override public String toString ( ) { return getPath ( ) ; } public String getPath ( ) { return fullPath ; } private static String createFullPath ( String [ ] segments , boolean absolute ) { StringBuilder path = new StringBuilder ( ) ; if ( absolute ) { path . append ( Project . PATH_SEPARATOR ) ; } for ( int i = <int> ; i < segments . length ; i + + ) { if ( i > <int> ) { path . append ( Project . PATH_SEPARATOR ) ; } String segment = segments [ i ] ; path . append ( segment ) ; } return path . toString ( ) ; } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null | | obj . getClass ( ) ! = getClass ( ) ) { return false ; } Path other = ( Path ) obj ; return Arrays . equals ( segments , other . segments ) ; } @Override public int hashCode ( ) { return Arrays . hashCode ( segments ) ; } public int compareTo ( Path other ) { if ( absolute & & ! other . absolute ) { return <int> ; } if ( ! absolute & & other . absolute ) { return - <int> ; } for ( int i = <int> ; i < Math . min ( segments . length , other . segments . length ) ; i + + ) { int diff = STRING_COMPARATOR . compare ( segments [ i ] , other . segments [ i ] ) ; if ( diff ! = <int> ) { return diff ; } } int lenDiff = segments . length - other . segments . length ; if ( lenDiff > <int> ) { return <int> ; } if ( lenDiff < <int> ) { return - <int> ; } return <int> ; } public Path getParent ( ) { if ( segments . length = = <int> ) { return null ; } if ( segments . length = = <int> ) { return absolute ? ROOT : null ; } String [ ] parentPath = new String [ segments . length - <int> ] ; System . arraycopy ( segments , <int> , parentPath , <int> , parentPath . length ) ; return new Path ( parentPath , absolute ) ; } public String getName ( ) { if ( segments . length = = <int> ) { return null ; } return segments [ segments . length - <int> ] ; } public Path resolve ( String path ) { return new Path ( absolutePath ( path ) ) ; } public String absolutePath ( String path ) { if ( ! isAbsolutePath ( path ) ) { return prefix + path ; } return path ; } public String relativePath ( String path ) { if ( path . startsWith ( prefix ) & & path . length ( ) > prefix . length ( ) ) { return path . substring ( prefix . length ( ) ) ; } return path ; } private boolean isAbsolutePath ( String path ) { if ( ! GUtil . isTrue ( path ) ) { throw new InvalidUserDataException ( <str> ) ; } return path . startsWith ( Project . PATH_SEPARATOR ) ; } } 
