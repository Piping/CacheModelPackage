package org . gradle . api . plugins ; import com . beust . jcommander . internal . Lists ; import org . gradle . api . * ; import org . gradle . api . artifacts . Configuration ; import org . gradle . api . artifacts . ConfigurationContainer ; import org . gradle . api . file . SourceDirectorySet ; import org . gradle . api . internal . ConventionMapping ; import org . gradle . api . internal . IConventionAware ; import org . gradle . api . internal . java . DefaultJavaSourceSet ; import org . gradle . api . internal . java . DefaultJvmResourceSet ; import org . gradle . api . internal . jvm . ClassDirectoryBinarySpecInternal ; import org . gradle . api . internal . jvm . DefaultClassDirectoryBinarySpec ; import org . gradle . api . internal . plugins . DslObject ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . internal . project . taskfactory . ITaskFactory ; import org . gradle . api . internal . tasks . SourceSetCompileClasspath ; import org . gradle . api . internal . tasks . testing . NoMatchingTestsReporter ; import org . gradle . api . reporting . ReportingExtension ; import org . gradle . api . tasks . Copy ; import org . gradle . api . tasks . SourceSet ; import org . gradle . api . tasks . compile . AbstractCompile ; import org . gradle . api . tasks . compile . JavaCompile ; import org . gradle . api . tasks . javadoc . Javadoc ; import org . gradle . api . tasks . testing . Test ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . jvm . Classpath ; import org . gradle . jvm . platform . internal . DefaultJavaPlatform ; import org . gradle . jvm . toolchain . JavaToolChain ; import org . gradle . language . base . ProjectSourceSet ; import org . gradle . language . base . plugins . LanguageBasePlugin ; import org . gradle . language . base . plugins . LifecycleBasePlugin ; import org . gradle . language . jvm . JvmResourceSet ; import org . gradle . language . jvm . tasks . ProcessResources ; import org . gradle . model . ModelMap ; import org . gradle . model . Mutate ; import org . gradle . model . Path ; import org . gradle . model . RuleSource ; import org . gradle . model . internal . core . ModelReference ; import org . gradle . model . internal . core . ModelRegistrations ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . internal . BinarySpecInternal ; import org . gradle . util . WrapUtil ; import javax . inject . Inject ; import java . io . File ; import java . util . List ; import java . util . concurrent . Callable ; public class JavaBasePlugin implements Plugin < ProjectInternal > { public static final String CHECK_TASK_NAME = LifecycleBasePlugin . CHECK_TASK_NAME ; public static final String VERIFICATION_GROUP = LifecycleBasePlugin . VERIFICATION_GROUP ; public static final String BUILD_TASK_NAME = LifecycleBasePlugin . BUILD_TASK_NAME ; public static final String BUILD_DEPENDENTS_TASK_NAME = <str> ; public static final String BUILD_NEEDED_TASK_NAME = <str> ; public static final String DOCUMENTATION_GROUP = <str> ; private final Instantiator instantiator ; private final JavaToolChain javaToolChain ; private final ITaskFactory taskFactory ; private final ModelRegistry modelRegistry ; @Inject public JavaBasePlugin ( Instantiator instantiator , JavaToolChain javaToolChain , ITaskFactory taskFactory , ModelRegistry modelRegistry ) { this . instantiator = instantiator ; this . javaToolChain = javaToolChain ; this . taskFactory = taskFactory ; this . modelRegistry = modelRegistry ; } public void apply ( ProjectInternal project ) { project . getPluginManager ( ) . apply ( BasePlugin . class ) ; project . getPluginManager ( ) . apply ( ReportingBasePlugin . class ) ; project . getPluginManager ( ) . apply ( LanguageBasePlugin . class ) ; JavaPluginConvention javaConvention = new JavaPluginConvention ( project , instantiator ) ; project . getConvention ( ) . getPlugins ( ) . put ( <str> , javaConvention ) ; configureCompileDefaults ( project , javaConvention ) ; BridgedBinaries binaries = configureSourceSetDefaults ( javaConvention ) ; modelRegistry . register ( ModelRegistrations . bridgedInstance ( ModelReference . of ( <str> , BridgedBinaries . class ) , binaries ) . descriptor ( <str> ) . hidden ( true ) . build ( ) ) ; configureJavaDoc ( project , javaConvention ) ; configureTest ( project , javaConvention ) ; configureBuildNeeded ( project ) ; configureBuildDependents ( project ) ; } private BridgedBinaries configureSourceSetDefaults ( final JavaPluginConvention pluginConvention ) { final Project project = pluginConvention . getProject ( ) ; final List < ClassDirectoryBinarySpecInternal > binaries = Lists . newArrayList ( ) ; pluginConvention . getSourceSets ( ) . all ( new Action < SourceSet > ( ) { public void execute ( final SourceSet sourceSet ) { ConventionMapping outputConventionMapping = ( ( IConventionAware ) sourceSet . getOutput ( ) ) . getConventionMapping ( ) ; ConfigurationContainer configurations = project . getConfigurations ( ) ; defineConfigurationsForSourceSet ( sourceSet , configurations ) ; definePathsForSourceSet ( sourceSet , outputConventionMapping , project ) ; createProcessResourcesTaskForBinary ( sourceSet , sourceSet . getResources ( ) , project ) ; createCompileJavaTaskForBinary ( sourceSet , sourceSet . getJava ( ) , project ) ; createBinaryLifecycleTask ( sourceSet , project ) ; ClassDirectoryBinarySpecInternal binary = instantiator . newInstance ( DefaultClassDirectoryBinarySpec . class , String . format ( <str> , sourceSet . getName ( ) ) , sourceSet , javaToolChain , DefaultJavaPlatform . current ( ) , instantiator , taskFactory ) ; Classpath compileClasspath = new SourceSetCompileClasspath ( sourceSet ) ; DefaultJavaSourceSet javaSourceSet = instantiator . newInstance ( DefaultJavaSourceSet . class , <str> , sourceSet . getName ( ) , sourceSet . getJava ( ) , compileClasspath ) ; JvmResourceSet resourceSet = instantiator . newInstance ( DefaultJvmResourceSet . class , <str> , sourceSet . getName ( ) , sourceSet . getResources ( ) ) ; binary . addSourceSet ( javaSourceSet ) ; binary . addSourceSet ( resourceSet ) ; attachTasksToBinary ( binary , sourceSet , project ) ; binaries . add ( binary ) ; } } ) ; return new BridgedBinaries ( binaries ) ; } private void createCompileJavaTaskForBinary ( final SourceSet sourceSet , SourceDirectorySet javaSourceSet , Project target ) { JavaCompile compileTask = target . getTasks ( ) . create ( sourceSet . getCompileJavaTaskName ( ) , JavaCompile . class ) ; compileTask . setDescription ( String . format ( <str> , javaSourceSet ) ) ; compileTask . setSource ( javaSourceSet ) ; ConventionMapping conventionMapping = compileTask . getConventionMapping ( ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return sourceSet . getCompileClasspath ( ) ; } } ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return sourceSet . getOutput ( ) . getClassesDir ( ) ; } } ) ; } private void createProcessResourcesTaskForBinary ( final SourceSet sourceSet , SourceDirectorySet resourceSet , final Project target ) { Copy resourcesTask = target . getTasks ( ) . create ( sourceSet . getProcessResourcesTaskName ( ) , ProcessResources . class ) ; resourcesTask . setDescription ( String . format ( <str> , resourceSet ) ) ; new DslObject ( resourcesTask ) . getConventionMapping ( ) . map ( <str> , new Callable < File > ( ) { public File call ( ) throws Exception { return sourceSet . getOutput ( ) . getResourcesDir ( ) ; } } ) ; resourcesTask . from ( resourceSet ) ; } private void createBinaryLifecycleTask ( SourceSet sourceSet , Project target ) { sourceSet . compiledBy ( sourceSet . getClassesTaskName ( ) ) ; Task binaryLifecycleTask = target . task ( sourceSet . getClassesTaskName ( ) ) ; binaryLifecycleTask . setGroup ( LifecycleBasePlugin . BUILD_GROUP ) ; binaryLifecycleTask . setDescription ( String . format ( <str> , sourceSet . getOutput ( ) ) ) ; binaryLifecycleTask . dependsOn ( sourceSet . getOutput ( ) . getDirs ( ) ) ; binaryLifecycleTask . dependsOn ( sourceSet . getCompileJavaTaskName ( ) ) ; binaryLifecycleTask . dependsOn ( sourceSet . getProcessResourcesTaskName ( ) ) ; } private void attachTasksToBinary ( ClassDirectoryBinarySpecInternal binary , SourceSet sourceSet , Project target ) { Task compileTask = target . getTasks ( ) . getByPath ( sourceSet . getCompileJavaTaskName ( ) ) ; Task resourcesTask = target . getTasks ( ) . getByPath ( sourceSet . getProcessResourcesTaskName ( ) ) ; Task classesTask = target . getTasks ( ) . getByPath ( sourceSet . getClassesTaskName ( ) ) ; binary . getTasks ( ) . add ( compileTask ) ; binary . getTasks ( ) . add ( resourcesTask ) ; binary . getTasks ( ) . add ( classesTask ) ; binary . setBuildTask ( classesTask ) ; } private void definePathsForSourceSet ( final SourceSet sourceSet , ConventionMapping outputConventionMapping , final Project project ) { outputConventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { String classesDirName = String . format ( <str> , sourceSet . getName ( ) ) ; return new File ( project . getBuildDir ( ) , classesDirName ) ; } } ) ; outputConventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { String classesDirName = String . format ( <str> , sourceSet . getName ( ) ) ; return new File ( project . getBuildDir ( ) , classesDirName ) ; } } ) ; sourceSet . getJava ( ) . srcDir ( String . format ( <str> , sourceSet . getName ( ) ) ) ; sourceSet . getResources ( ) . srcDir ( String . format ( <str> , sourceSet . getName ( ) ) ) ; } private void defineConfigurationsForSourceSet ( SourceSet sourceSet , ConfigurationContainer configurations ) { Configuration compileConfiguration = configurations . findByName ( sourceSet . getCompileConfigurationName ( ) ) ; if ( compileConfiguration = = null ) { compileConfiguration = configurations . create ( sourceSet . getCompileConfigurationName ( ) ) ; } compileConfiguration . setVisible ( false ) ; compileConfiguration . setDescription ( String . format ( <str> , sourceSet ) ) ; Configuration runtimeConfiguration = configurations . findByName ( sourceSet . getRuntimeConfigurationName ( ) ) ; if ( runtimeConfiguration = = null ) { runtimeConfiguration = configurations . create ( sourceSet . getRuntimeConfigurationName ( ) ) ; } runtimeConfiguration . setVisible ( false ) ; runtimeConfiguration . extendsFrom ( compileConfiguration ) ; runtimeConfiguration . setDescription ( String . format ( <str> , sourceSet ) ) ; sourceSet . setCompileClasspath ( compileConfiguration ) ; sourceSet . setRuntimeClasspath ( sourceSet . getOutput ( ) . plus ( runtimeConfiguration ) ) ; } public void configureForSourceSet ( final SourceSet sourceSet , AbstractCompile compile ) { ConventionMapping conventionMapping ; compile . setDescription ( String . format ( <str> , sourceSet . getJava ( ) ) ) ; conventionMapping = compile . getConventionMapping ( ) ; compile . setSource ( sourceSet . getJava ( ) ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return sourceSet . getCompileClasspath ( ) ; } } ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return sourceSet . getOutput ( ) . getClassesDir ( ) ; } } ) ; } private void configureCompileDefaults ( final Project project , final JavaPluginConvention javaConvention ) { project . getTasks ( ) . withType ( AbstractCompile . class , new Action < AbstractCompile > ( ) { public void execute ( final AbstractCompile compile ) { ConventionMapping conventionMapping = compile . getConventionMapping ( ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return javaConvention . getSourceCompatibility ( ) . toString ( ) ; } } ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return javaConvention . getTargetCompatibility ( ) . toString ( ) ; } } ) ; } } ) ; project . getTasks ( ) . withType ( JavaCompile . class , new Action < JavaCompile > ( ) { public void execute ( final JavaCompile compile ) { ConventionMapping conventionMapping = compile . getConventionMapping ( ) ; conventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return javaConvention . getDependencyCacheDir ( ) ; } } ) ; } } ) ; } private void configureJavaDoc ( final Project project , final JavaPluginConvention convention ) { project . getTasks ( ) . withType ( Javadoc . class , new Action < Javadoc > ( ) { public void execute ( Javadoc javadoc ) { javadoc . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return new File ( convention . getDocsDir ( ) , <str> ) ; } } ) ; javadoc . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return project . getExtensions ( ) . getByType ( ReportingExtension . class ) . getApiDocTitle ( ) ; } } ) ; } } ) ; } private void configureBuildNeeded ( Project project ) { DefaultTask buildTask = project . getTasks ( ) . create ( BUILD_NEEDED_TASK_NAME , DefaultTask . class ) ; buildTask . setDescription ( <str> ) ; buildTask . setGroup ( BasePlugin . BUILD_GROUP ) ; buildTask . dependsOn ( BUILD_TASK_NAME ) ; } private void configureBuildDependents ( Project project ) { DefaultTask buildTask = project . getTasks ( ) . create ( BUILD_DEPENDENTS_TASK_NAME , DefaultTask . class ) ; buildTask . setDescription ( <str> ) ; buildTask . setGroup ( BasePlugin . BUILD_GROUP ) ; buildTask . dependsOn ( BUILD_TASK_NAME ) ; } private void configureTest ( final Project project , final JavaPluginConvention convention ) { project . getTasks ( ) . withType ( Test . class , new Action < Test > ( ) { public void execute ( Test test ) { configureTestDefaults ( test , project , convention ) ; } } ) ; project . afterEvaluate ( new Action < Project > ( ) { public void execute ( Project project ) { project . getTasks ( ) . withType ( Test . class , new Action < Test > ( ) { public void execute ( Test test ) { configureBasedOnSingleProperty ( test ) ; overwriteDebugIfDebugPropertyIsSet ( test ) ; } } ) ; } } ) ; } private void overwriteDebugIfDebugPropertyIsSet ( Test test ) { String debugProp = getTaskPrefixedProperty ( test , <str> ) ; if ( debugProp ! = null ) { test . prependParallelSafeAction ( new Action < Task > ( ) { public void execute ( Task task ) { task . getLogger ( ) . info ( <str> ) ; } } ) ; test . setDebug ( true ) ; } } private void configureBasedOnSingleProperty ( final Test test ) { String singleTest = getTaskPrefixedProperty ( test , <str> ) ; if ( singleTest = = null ) { test . getInputs ( ) . source ( test . getCandidateClassFiles ( ) ) ; return ; } test . prependParallelSafeAction ( new Action < Task > ( ) { public void execute ( Task task ) { test . getLogger ( ) . info ( <str> , test . getIncludes ( ) ) ; } } ) ; test . setIncludes ( WrapUtil . toSet ( String . format ( <str> , singleTest ) ) ) ; test . addTestListener ( new NoMatchingTestsReporter ( <str> + singleTest ) ) ; } private String getTaskPrefixedProperty ( Task task , String propertyName ) { String suffix = <str> + propertyName ; String value = System . getProperty ( task . getPath ( ) + suffix ) ; if ( value = = null ) { return System . getProperty ( task . getName ( ) + suffix ) ; } return value ; } private void configureTestDefaults ( final Test test , Project project , final JavaPluginConvention convention ) { DslObject htmlReport = new DslObject ( test . getReports ( ) . getHtml ( ) ) ; DslObject xmlReport = new DslObject ( test . getReports ( ) . getJunitXml ( ) ) ; xmlReport . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return convention . getTestResultsDir ( ) ; } } ) ; htmlReport . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return convention . getTestReportDir ( ) ; } } ) ; test . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return new File ( convention . getTestResultsDir ( ) , String . format ( <str> , test . getName ( ) ) ) ; } } ) ; test . workingDir ( project . getProjectDir ( ) ) ; } static class BridgedBinaries { final List < ClassDirectoryBinarySpecInternal > binaries ; public BridgedBinaries ( List < ClassDirectoryBinarySpecInternal > binaries ) { this . binaries = binaries ; } } static class Rules extends RuleSource { @Mutate void attachBridgedSourceSets ( ProjectSourceSet projectSourceSet , @Path ( <str> ) BridgedBinaries bridgedBinaries ) { for ( ClassDirectoryBinarySpecInternal binary : bridgedBinaries . binaries ) { projectSourceSet . addAll ( binary . getInputs ( ) ) ; } } @Mutate void attachBridgedBinaries ( ModelMap < BinarySpec > binaries , @Path ( <str> ) BridgedBinaries bridgedBinaries ) { for ( BinarySpecInternal binary : bridgedBinaries . binaries ) { binaries . put ( binary . getProjectScopedName ( ) , binary ) ; } } } } 
