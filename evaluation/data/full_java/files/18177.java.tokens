package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; public class Bresenham2 { private final Array < GridPoint2 > points = new Array < GridPoint2 > ( ) ; private final Pool < GridPoint2 > pool = new Pool < GridPoint2 > ( ) { @Override protected GridPoint2 newObject ( ) { return new GridPoint2 ( ) ; } } ; public Array < GridPoint2 > line ( GridPoint2 start , GridPoint2 end ) { return line ( start . x , start . y , end . x , end . y ) ; } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY ) { pool . freeAll ( points ) ; points . clear ( ) ; return line ( startX , startY , endX , endY , pool , points ) ; } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY , Pool < GridPoint2 > pool , Array < GridPoint2 > output ) { int w = endX - startX ; int h = endY - startY ; int dx1 = <int> , dy1 = <int> , dx2 = <int> , dy2 = <int> ; if ( w < <int> ) { dx1 = - <int> ; dx2 = - <int> ; } else if ( w > <int> ) { dx1 = <int> ; dx2 = <int> ; } if ( h < <int> ) dy1 = - <int> ; else if ( h > <int> ) dy1 = <int> ; int longest = Math . abs ( w ) ; int shortest = Math . abs ( h ) ; if ( longest < = shortest ) { longest = Math . abs ( h ) ; shortest = Math . abs ( w ) ; if ( h < <int> ) dy2 = - <int> ; else if ( h > <int> ) dy2 = <int> ; dx2 = <int> ; } int numerator = longest > > <int> ; for ( int i = <int> ; i < = longest ; i + + ) { GridPoint2 point = pool . obtain ( ) ; point . set ( startX , startY ) ; output . add ( point ) ; numerator + = shortest ; if ( numerator > longest ) { numerator - = longest ; startX + = dx1 ; startY + = dy1 ; } else { startX + = dx2 ; startY + = dy2 ; } } return output ; } } 
