package org . elasticsearch . common ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . FastStringReader ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Properties ; import java . util . Random ; import java . util . Set ; import java . util . StringTokenizer ; import java . util . TreeSet ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; public class Strings { public static final String [ ] EMPTY_ARRAY = new String [ <int> ] ; private static final String FOLDER_SEPARATOR = <str> ; private static final String WINDOWS_FOLDER_SEPARATOR = <str> ; private static final String TOP_PATH = <str> ; private static final String CURRENT_PATH = <str> ; private static final RandomBasedUUIDGenerator RANDOM_UUID_GENERATOR = new RandomBasedUUIDGenerator ( ) ; private static final UUIDGenerator TIME_UUID_GENERATOR = new TimeBasedUUIDGenerator ( ) ; public static void spaceify ( int spaces , String from , StringBuilder to ) throws Exception { try ( BufferedReader reader = new BufferedReader ( new FastStringReader ( from ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) ! = null ) { for ( int i = <int> ; i < spaces ; i + + ) { to . append ( <str> ) ; } to . append ( line ) . append ( <str> ) ; } } } public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( <int> ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = <int> , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > <int> ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos + = separator . length ( ) ; continue ; } char ch = s . charAt ( pos + + ) ; if ( ch = = <str> ) { if ( ! decode ) sb . append ( ch ) ; if ( pos > = end ) break ; ch = s . charAt ( pos + + ) ; if ( decode ) { switch ( ch ) { case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > <int> ) { lst . add ( sb . toString ( ) ) ; } return lst ; } public static boolean hasLength ( CharSequence str ) { return ( str ! = null & & str . length ( ) > <int> ) ; } public static boolean hasLength ( BytesReference bytesReference ) { return ( bytesReference ! = null & & bytesReference . length ( ) > <int> ) ; } public static boolean hasLength ( String str ) { return hasLength ( ( CharSequence ) str ) ; } public static boolean isEmpty ( CharSequence str ) { return ! hasLength ( str ) ; } public static boolean hasText ( CharSequence str ) { if ( ! hasLength ( str ) ) { return false ; } int strLen = str . length ( ) ; for ( int i = <int> ; i < strLen ; i + + ) { if ( ! Character . isWhitespace ( str . charAt ( i ) ) ) { return true ; } } return false ; } public static boolean hasText ( String str ) { return hasText ( ( CharSequence ) str ) ; } public static boolean containsWhitespace ( CharSequence str ) { if ( ! hasLength ( str ) ) { return false ; } int strLen = str . length ( ) ; for ( int i = <int> ; i < strLen ; i + + ) { if ( Character . isWhitespace ( str . charAt ( i ) ) ) { return true ; } } return false ; } public static String trimLeadingWhitespace ( String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > <int> & & Character . isWhitespace ( sb . charAt ( <int> ) ) ) { sb . deleteCharAt ( <int> ) ; } return sb . toString ( ) ; } public static String trimLeadingCharacter ( String str , char leadingCharacter ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > <int> & & sb . charAt ( <int> ) = = leadingCharacter ) { sb . deleteCharAt ( <int> ) ; } return sb . toString ( ) ; } public static boolean substringMatch ( CharSequence str , int index , CharSequence substring ) { for ( int j = <int> ; j < substring . length ( ) ; j + + ) { int i = index + j ; if ( i > = str . length ( ) | | str . charAt ( i ) ! = substring . charAt ( j ) ) { return false ; } } return true ; } public static int countOccurrencesOf ( String str , String sub ) { if ( str = = null | | sub = = null | | str . length ( ) = = <int> | | sub . length ( ) = = <int> ) { return <int> ; } int count = <int> ; int pos = <int> ; int idx ; while ( ( idx = str . indexOf ( sub , pos ) ) ! = - <int> ) { + + count ; pos = idx + sub . length ( ) ; } return count ; } public static String replace ( String inString , String oldPattern , String newPattern ) { if ( ! hasLength ( inString ) | | ! hasLength ( oldPattern ) | | newPattern = = null ) { return inString ; } StringBuilder sb = new StringBuilder ( ) ; int pos = <int> ; int index = inString . indexOf ( oldPattern ) ; int patLen = oldPattern . length ( ) ; while ( index > = <int> ) { sb . append ( inString . substring ( pos , index ) ) ; sb . append ( newPattern ) ; pos = index + patLen ; index = inString . indexOf ( oldPattern , pos ) ; } sb . append ( inString . substring ( pos ) ) ; return sb . toString ( ) ; } public static String delete ( String inString , String pattern ) { return replace ( inString , pattern , <str> ) ; } public static String deleteAny ( String inString , String charsToDelete ) { if ( ! hasLength ( inString ) | | ! hasLength ( charsToDelete ) ) { return inString ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < inString . length ( ) ; i + + ) { char c = inString . charAt ( i ) ; if ( charsToDelete . indexOf ( c ) = = - <int> ) { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String quote ( String str ) { return ( str ! = null ? <str> + str + <str> : null ) ; } public static String unqualify ( String qualifiedName , char separator ) { return qualifiedName . substring ( qualifiedName . lastIndexOf ( separator ) + <int> ) ; } public static String capitalize ( String str ) { return changeFirstCharacterCase ( str , true ) ; } private static String changeFirstCharacterCase ( String str , boolean capitalize ) { if ( str = = null | | str . length ( ) = = <int> ) { return str ; } StringBuilder sb = new StringBuilder ( str . length ( ) ) ; if ( capitalize ) { sb . append ( Character . toUpperCase ( str . charAt ( <int> ) ) ) ; } else { sb . append ( Character . toLowerCase ( str . charAt ( <int> ) ) ) ; } sb . append ( str . substring ( <int> ) ) ; return sb . toString ( ) ; } public static final Set < Character > INVALID_FILENAME_CHARS = unmodifiableSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; public static boolean validFileName ( String fileName ) { for ( int i = <int> ; i < fileName . length ( ) ; i + + ) { char c = fileName . charAt ( i ) ; if ( INVALID_FILENAME_CHARS . contains ( c ) ) { return false ; } } return true ; } public static boolean validFileNameExcludingAstrix ( String fileName ) { for ( int i = <int> ; i < fileName . length ( ) ; i + + ) { char c = fileName . charAt ( i ) ; if ( c ! = <str> & & INVALID_FILENAME_CHARS . contains ( c ) ) { return false ; } } return true ; } public static String cleanPath ( String path ) { if ( path = = null ) { return null ; } String pathToUse = replace ( path , WINDOWS_FOLDER_SEPARATOR , FOLDER_SEPARATOR ) ; int prefixIndex = pathToUse . indexOf ( <str> ) ; String prefix = <str> ; if ( prefixIndex ! = - <int> ) { prefix = pathToUse . substring ( <int> , prefixIndex + <int> ) ; pathToUse = pathToUse . substring ( prefixIndex + <int> ) ; } if ( pathToUse . startsWith ( FOLDER_SEPARATOR ) ) { prefix = prefix + FOLDER_SEPARATOR ; pathToUse = pathToUse . substring ( <int> ) ; } String [ ] pathArray = delimitedListToStringArray ( pathToUse , FOLDER_SEPARATOR ) ; List < String > pathElements = new LinkedList < > ( ) ; int tops = <int> ; for ( int i = pathArray . length - <int> ; i > = <int> ; i - - ) { String element = pathArray [ i ] ; if ( CURRENT_PATH . equals ( element ) ) { } else if ( TOP_PATH . equals ( element ) ) { tops + + ; } else { if ( tops > <int> ) { tops - - ; } else { pathElements . add ( <int> , element ) ; } } } for ( int i = <int> ; i < tops ; i + + ) { pathElements . add ( <int> , TOP_PATH ) ; } return prefix + collectionToDelimitedString ( pathElements , FOLDER_SEPARATOR ) ; } public static String [ ] toStringArray ( Collection < String > collection ) { if ( collection = = null ) { return null ; } return collection . toArray ( new String [ collection . size ( ) ] ) ; } public static Set < String > splitStringByCommaToSet ( final String s ) { return splitStringToSet ( s , <str> ) ; } public static String [ ] splitStringByCommaToArray ( final String s ) { return splitStringToArray ( s , <str> ) ; } public static Set < String > splitStringToSet ( final String s , final char c ) { final char [ ] chars = s . toCharArray ( ) ; int count = <int> ; for ( final char x : chars ) { if ( x = = c ) { count + + ; } } final Set < String > result = new HashSet < > ( count ) ; final int len = chars . length ; int start = <int> ; int pos = <int> ; for ( ; pos < len ; pos + + ) { if ( chars [ pos ] = = c ) { int size = pos - start ; if ( size > <int> ) { result . add ( new String ( chars , start , size ) ) ; } start = pos + <int> ; } } int size = pos - start ; if ( size > <int> ) { result . add ( new String ( chars , start , size ) ) ; } return result ; } public static String [ ] splitStringToArray ( final CharSequence s , final char c ) { if ( s = = null | | s . length ( ) = = <int> ) { return Strings . EMPTY_ARRAY ; } int count = <int> ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { if ( s . charAt ( i ) = = c ) { count + + ; } } final String [ ] result = new String [ count ] ; final StringBuilder builder = new StringBuilder ( ) ; int res = <int> ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { if ( s . charAt ( i ) = = c ) { if ( builder . length ( ) > <int> ) { result [ res + + ] = builder . toString ( ) ; builder . setLength ( <int> ) ; } } else { builder . append ( s . charAt ( i ) ) ; } } if ( builder . length ( ) > <int> ) { result [ res + + ] = builder . toString ( ) ; } if ( res ! = count ) { String [ ] result1 = new String [ res ] ; System . arraycopy ( result , <int> , result1 , <int> , res ) ; return result1 ; } return result ; } public static String [ ] split ( String toSplit , String delimiter ) { if ( ! hasLength ( toSplit ) | | ! hasLength ( delimiter ) ) { return null ; } int offset = toSplit . indexOf ( delimiter ) ; if ( offset < <int> ) { return null ; } String beforeDelimiter = toSplit . substring ( <int> , offset ) ; String afterDelimiter = toSplit . substring ( offset + delimiter . length ( ) ) ; return new String [ ] { beforeDelimiter , afterDelimiter } ; } public static Properties splitArrayElementsIntoProperties ( String [ ] array , String delimiter , String charsToDelete ) { if ( isEmpty ( array ) ) { return null ; } Properties result = new Properties ( ) ; for ( String element : array ) { if ( charsToDelete ! = null ) { element = deleteAny ( element , charsToDelete ) ; } String [ ] splittedElement = split ( element , delimiter ) ; if ( splittedElement = = null ) { continue ; } result . setProperty ( splittedElement [ <int> ] . trim ( ) , splittedElement [ <int> ] . trim ( ) ) ; } return result ; } public static String [ ] tokenizeToStringArray ( String str , String delimiters ) { return tokenizeToStringArray ( str , delimiters , true , true ) ; } public static String [ ] tokenizeToStringArray ( String str , String delimiters , boolean trimTokens , boolean ignoreEmptyTokens ) { if ( str = = null ) { return null ; } StringTokenizer st = new StringTokenizer ( str , delimiters ) ; List < String > tokens = new ArrayList < > ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( trimTokens ) { token = token . trim ( ) ; } if ( ! ignoreEmptyTokens | | token . length ( ) > <int> ) { tokens . add ( token ) ; } } return toStringArray ( tokens ) ; } public static String [ ] delimitedListToStringArray ( String str , String delimiter ) { return delimitedListToStringArray ( str , delimiter , null ) ; } public static String [ ] delimitedListToStringArray ( String str , String delimiter , String charsToDelete ) { if ( str = = null ) { return new String [ <int> ] ; } if ( delimiter = = null ) { return new String [ ] { str } ; } List < String > result = new ArrayList < > ( ) ; if ( <str> . equals ( delimiter ) ) { for ( int i = <int> ; i < str . length ( ) ; i + + ) { result . add ( deleteAny ( str . substring ( i , i + <int> ) , charsToDelete ) ) ; } } else { int pos = <int> ; int delPos ; while ( ( delPos = str . indexOf ( delimiter , pos ) ) ! = - <int> ) { result . add ( deleteAny ( str . substring ( pos , delPos ) , charsToDelete ) ) ; pos = delPos + delimiter . length ( ) ; } if ( str . length ( ) > <int> & & pos < = str . length ( ) ) { result . add ( deleteAny ( str . substring ( pos ) , charsToDelete ) ) ; } } return toStringArray ( result ) ; } public static String [ ] commaDelimitedListToStringArray ( String str ) { return delimitedListToStringArray ( str , <str> ) ; } public static Set < String > commaDelimitedListToSet ( String str ) { Set < String > set = new TreeSet < > ( ) ; String [ ] tokens = commaDelimitedListToStringArray ( str ) ; set . addAll ( Arrays . asList ( tokens ) ) ; return set ; } public static String collectionToDelimitedString ( Iterable < ? > coll , String delim , String prefix , String suffix ) { return collectionToDelimitedString ( coll , delim , prefix , suffix , new StringBuilder ( ) ) ; } public static String collectionToDelimitedString ( Iterable < ? > coll , String delim , String prefix , String suffix , StringBuilder sb ) { Iterator < ? > it = coll . iterator ( ) ; while ( it . hasNext ( ) ) { sb . append ( prefix ) . append ( it . next ( ) ) . append ( suffix ) ; if ( it . hasNext ( ) ) { sb . append ( delim ) ; } } return sb . toString ( ) ; } public static String collectionToDelimitedString ( Iterable < ? > coll , String delim ) { return collectionToDelimitedString ( coll , delim , <str> , <str> ) ; } public static String collectionToCommaDelimitedString ( Iterable < ? > coll ) { return collectionToDelimitedString ( coll , <str> ) ; } public static String arrayToDelimitedString ( Object [ ] arr , String delim ) { return arrayToDelimitedString ( arr , delim , new StringBuilder ( ) ) ; } public static String arrayToDelimitedString ( Object [ ] arr , String delim , StringBuilder sb ) { if ( isEmpty ( arr ) ) { return <str> ; } for ( int i = <int> ; i < arr . length ; i + + ) { if ( i > <int> ) { sb . append ( delim ) ; } sb . append ( arr [ i ] ) ; } return sb . toString ( ) ; } public static String arrayToCommaDelimitedString ( Object [ ] arr ) { return arrayToDelimitedString ( arr , <str> ) ; } public static String format1Decimals ( double value , String suffix ) { String p = String . valueOf ( value ) ; int ix = p . indexOf ( <str> ) + <int> ; int ex = p . indexOf ( <str> ) ; char fraction = p . charAt ( ix ) ; if ( fraction = = <str> ) { if ( ex ! = - <int> ) { return p . substring ( <int> , ix - <int> ) + p . substring ( ex ) + suffix ; } else { return p . substring ( <int> , ix - <int> ) + suffix ; } } else { if ( ex ! = - <int> ) { return p . substring ( <int> , ix ) + fraction + p . substring ( ex ) + suffix ; } else { return p . substring ( <int> , ix ) + fraction + suffix ; } } } public static String toCamelCase ( String value ) { return toCamelCase ( value , null ) ; } public static String toCamelCase ( String value , StringBuilder sb ) { boolean changed = false ; for ( int i = <int> ; i < value . length ( ) ; i + + ) { char c = value . charAt ( i ) ; if ( c = = <str> & & i > <int> ) { if ( ! changed ) { if ( sb ! = null ) { sb . setLength ( <int> ) ; } else { sb = new StringBuilder ( ) ; } for ( int j = <int> ; j < i ; j + + ) { sb . append ( value . charAt ( j ) ) ; } changed = true ; } if ( i < value . length ( ) - <int> ) { sb . append ( Character . toUpperCase ( value . charAt ( + + i ) ) ) ; } } else { if ( changed ) { sb . append ( c ) ; } } } if ( ! changed ) { return value ; } return sb . toString ( ) ; } public static String toUnderscoreCase ( String value ) { return toUnderscoreCase ( value , null ) ; } public static String toUnderscoreCase ( String value , StringBuilder sb ) { boolean changed = false ; for ( int i = <int> ; i < value . length ( ) ; i + + ) { char c = value . charAt ( i ) ; if ( Character . isUpperCase ( c ) ) { if ( ! changed ) { if ( sb ! = null ) { sb . setLength ( <int> ) ; } else { sb = new StringBuilder ( ) ; } for ( int j = <int> ; j < i ; j + + ) { sb . append ( value . charAt ( j ) ) ; } changed = true ; if ( i = = <int> ) { sb . append ( Character . toLowerCase ( c ) ) ; } else { sb . append ( <str> ) ; sb . append ( Character . toLowerCase ( c ) ) ; } } else { sb . append ( <str> ) ; sb . append ( Character . toLowerCase ( c ) ) ; } } else { if ( changed ) { sb . append ( c ) ; } } } if ( ! changed ) { return value ; } return sb . toString ( ) ; } private static boolean isEmpty ( Object [ ] array ) { return ( array = = null | | array . length = = <int> ) ; } private Strings ( ) { } public static byte [ ] toUTF8Bytes ( CharSequence charSequence ) { return toUTF8Bytes ( charSequence , new BytesRefBuilder ( ) ) ; } public static byte [ ] toUTF8Bytes ( CharSequence charSequence , BytesRefBuilder spare ) { spare . copyChars ( charSequence ) ; return Arrays . copyOf ( spare . bytes ( ) , spare . length ( ) ) ; } public static String substring ( String s , int beginIndex , int endIndex ) { if ( s = = null ) { return s ; } int realEndIndex = s . length ( ) > <int> ? s . length ( ) - <int> : <int> ; if ( endIndex > realEndIndex ) { return s . substring ( beginIndex ) ; } else { return s . substring ( beginIndex , endIndex ) ; } } public static boolean isAllOrWildcard ( String [ ] data ) { return CollectionUtils . isEmpty ( data ) | | data . length = = <int> & & ( <str> . equals ( data [ <int> ] ) | | <str> . equals ( data [ <int> ] ) ) ; } public static String randomBase64UUID ( ) { return RANDOM_UUID_GENERATOR . getBase64UUID ( ) ; } public static String randomBase64UUID ( Random random ) { return RANDOM_UUID_GENERATOR . getBase64UUID ( random ) ; } public static String base64UUID ( ) { return TIME_UUID_GENERATOR . getBase64UUID ( ) ; } public static String toString ( ToXContent toXContent ) { try { XContentBuilder builder = JsonXContent . contentBuilder ( ) ; toXContent . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; return builder . string ( ) ; } catch ( IOException e ) { throw new AssertionError ( <str> , e ) ; } } public static String cleanTruncate ( String s , int length ) { if ( s = = null ) { return s ; } if ( length = = <int> ) { return <str> ; } if ( length > = s . length ( ) ) { return s ; } if ( Character . isHighSurrogate ( s . charAt ( length - <int> ) ) ) { length - - ; } return s . substring ( <int> , length ) ; } public static boolean isNullOrEmpty ( @Nullable String s ) { return s = = null | | s . isEmpty ( ) ; } public static String coalesceToEmpty ( @Nullable String s ) { return s = = null ? <str> : s ; } public static String padStart ( String s , int minimumLength , char c ) { if ( s = = null ) { throw new NullPointerException ( <str> ) ; } if ( s . length ( ) > = minimumLength ) { return s ; } else { StringBuilder sb = new StringBuilder ( minimumLength ) ; for ( int i = s . length ( ) ; i < minimumLength ; i + + ) { sb . append ( c ) ; } sb . append ( s ) ; return sb . toString ( ) ; } } } 
