package org . elasticsearch . indices . recovery ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportService ; import java . util . * ; public class RecoverySource extends AbstractComponent implements IndexEventListener { public static class Actions { public static final String START_RECOVERY = <str> ; } private final TransportService transportService ; private final IndicesService indicesService ; private final RecoverySettings recoverySettings ; private final ClusterService clusterService ; private final OngoingRecoveres ongoingRecoveries = new OngoingRecoveres ( ) ; @Inject public RecoverySource ( Settings settings , TransportService transportService , IndicesService indicesService , RecoverySettings recoverySettings , ClusterService clusterService ) { super ( settings ) ; this . transportService = transportService ; this . indicesService = indicesService ; this . clusterService = clusterService ; this . recoverySettings = recoverySettings ; transportService . registerRequestHandler ( Actions . START_RECOVERY , StartRecoveryRequest : : new , ThreadPool . Names . GENERIC , new StartRecoveryTransportRequestHandler ( ) ) ; } @Override public void beforeIndexShardClosed ( ShardId shardId , @Nullable IndexShard indexShard , Settings indexSettings ) { if ( indexShard ! = null ) { ongoingRecoveries . cancel ( indexShard , <str> ) ; } } private RecoveryResponse recover ( final StartRecoveryRequest request ) { final IndexService indexService = indicesService . indexServiceSafe ( request . shardId ( ) . index ( ) . name ( ) ) ; final IndexShard shard = indexService . getShard ( request . shardId ( ) . id ( ) ) ; RoutingNode node = clusterService . state ( ) . getRoutingNodes ( ) . node ( request . targetNode ( ) . id ( ) ) ; if ( node = = null ) { logger . debug ( <str> , request . shardId ( ) , request . targetNode ( ) ) ; throw new DelayRecoveryException ( <str> + request . targetNode ( ) + <str> ) ; } ShardRouting targetShardRouting = null ; for ( ShardRouting shardRouting : node ) { if ( shardRouting . shardId ( ) . equals ( request . shardId ( ) ) ) { targetShardRouting = shardRouting ; break ; } } if ( targetShardRouting = = null ) { logger . debug ( <str> , request . shardId ( ) , request . targetNode ( ) ) ; throw new DelayRecoveryException ( <str> ) ; } if ( ! targetShardRouting . initializing ( ) ) { logger . debug ( <str> , request . shardId ( ) , request . targetNode ( ) , targetShardRouting . state ( ) ) ; throw new DelayRecoveryException ( <str> + targetShardRouting . state ( ) + <str> ) ; } logger . trace ( <str> , request . shardId ( ) . index ( ) . name ( ) , request . shardId ( ) . id ( ) , request . targetNode ( ) , request . markAsRelocated ( ) ) ; final RecoverySourceHandler handler ; if ( shard . indexSettings ( ) . isOnSharedFilesystem ( ) ) { handler = new SharedFSRecoverySourceHandler ( shard , request , recoverySettings , transportService , logger ) ; } else { handler = new RecoverySourceHandler ( shard , request , recoverySettings , transportService , logger ) ; } ongoingRecoveries . add ( shard , handler ) ; try { return handler . recoverToTarget ( ) ; } finally { ongoingRecoveries . remove ( shard , handler ) ; } } class StartRecoveryTransportRequestHandler implements TransportRequestHandler < StartRecoveryRequest > { @Override public void messageReceived ( final StartRecoveryRequest request , final TransportChannel channel ) throws Exception { RecoveryResponse response = recover ( request ) ; channel . sendResponse ( response ) ; } } private static final class OngoingRecoveres { private final Map < IndexShard , Set < RecoverySourceHandler > > ongoingRecoveries = new HashMap < > ( ) ; synchronized void add ( IndexShard shard , RecoverySourceHandler handler ) { Set < RecoverySourceHandler > shardRecoveryHandlers = ongoingRecoveries . get ( shard ) ; if ( shardRecoveryHandlers = = null ) { shardRecoveryHandlers = new HashSet < > ( ) ; ongoingRecoveries . put ( shard , shardRecoveryHandlers ) ; } assert shardRecoveryHandlers . contains ( handler ) = = false : <str> + handler + <str> ; shardRecoveryHandlers . add ( handler ) ; shard . recoveryStats ( ) . incCurrentAsSource ( ) ; } synchronized void remove ( IndexShard shard , RecoverySourceHandler handler ) { final Set < RecoverySourceHandler > shardRecoveryHandlers = ongoingRecoveries . get ( shard ) ; assert shardRecoveryHandlers ! = null : <str> + shard + <str> ; boolean remove = shardRecoveryHandlers . remove ( handler ) ; assert remove : <str> + handler + <str> ; if ( remove ) { shard . recoveryStats ( ) . decCurrentAsSource ( ) ; } if ( shardRecoveryHandlers . isEmpty ( ) ) { ongoingRecoveries . remove ( shard ) ; } } synchronized void cancel ( IndexShard shard , String reason ) { final Set < RecoverySourceHandler > shardRecoveryHandlers = ongoingRecoveries . get ( shard ) ; if ( shardRecoveryHandlers ! = null ) { final List < Exception > failures = new ArrayList < > ( ) ; for ( RecoverySourceHandler handlers : shardRecoveryHandlers ) { try { handlers . cancel ( reason ) ; } catch ( Exception ex ) { failures . add ( ex ) ; } finally { shard . recoveryStats ( ) . decCurrentAsSource ( ) ; } } ExceptionsHelper . maybeThrowRuntimeAndSuppress ( failures ) ; } } } } 
