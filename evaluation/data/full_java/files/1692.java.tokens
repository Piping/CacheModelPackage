package org . apache . cassandra . stress . generate ; import java . util . Arrays ; import java . util . Random ; import org . apache . cassandra . stress . Stress ; public class DistributionQuantized extends Distribution { final Distribution delegate ; final long [ ] bounds ; final Random random = new Random ( ) ; public DistributionQuantized ( Distribution delegate , int quantas ) { this . delegate = delegate ; this . bounds = new long [ quantas + <int> ] ; bounds [ <int> ] = delegate . minValue ( ) ; bounds [ quantas ] = delegate . maxValue ( ) + <int> ; for ( int i = <int> ; i < quantas ; i + + ) bounds [ i ] = delegate . inverseCumProb ( i / ( double ) quantas ) ; } @Override public long next ( ) { int quanta = quanta ( delegate . next ( ) ) ; return bounds [ quanta ] + ( long ) ( random . nextDouble ( ) * ( ( bounds [ quanta + <int> ] - bounds [ quanta ] ) ) ) ; } public double nextDouble ( ) { throw new UnsupportedOperationException ( ) ; } @Override public long inverseCumProb ( double cumProb ) { long val = delegate . inverseCumProb ( cumProb ) ; int quanta = quanta ( val ) ; if ( quanta < <int> ) return bounds [ <int> ] ; if ( quanta > = bounds . length - <int> ) return bounds [ bounds . length - <int> ] - <int> ; cumProb - = ( quanta / ( ( double ) bounds . length - <int> ) ) ; cumProb * = ( double ) bounds . length - <int> ; return bounds [ quanta ] + ( long ) ( cumProb * ( bounds [ quanta + <int> ] - bounds [ quanta ] ) ) ; } int quanta ( long val ) { int i = Arrays . binarySearch ( bounds , val ) ; if ( i < <int> ) return - <int> - i ; return i - <int> ; } public void setSeed ( long seed ) { delegate . setSeed ( seed ) ; } public static void main ( String [ ] args ) throws Exception { Stress . main ( new String [ ] { <str> , <str> } ) ; } } 
