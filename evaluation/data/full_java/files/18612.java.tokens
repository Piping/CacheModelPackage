package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalShadowLight ; import com . badlogic . gdx . graphics . g3d . loader . ObjLoader ; import com . badlogic . gdx . graphics . g3d . utils . DepthShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . Ray ; import com . badlogic . gdx . physics . bullet . Bullet ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; import com . badlogic . gdx . physics . bullet . linearmath . LinearMath ; import com . badlogic . gdx . physics . bullet . linearmath . btIDebugDraw . DebugDrawModes ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; public class BaseBulletTest extends BulletTest { private final static String customDesktopLib = null ; private static boolean initialized = false ; public static boolean shadows = true ; public static void init ( ) { if ( initialized ) return ; if ( Gdx . app . getType ( ) = = ApplicationType . Desktop & & customDesktopLib ! = null ) { System . load ( customDesktopLib ) ; } else Bullet . init ( ) ; Gdx . app . log ( <str> , <str> + LinearMath . btGetVersion ( ) ) ; initialized = true ; } public Environment environment ; public DirectionalLight light ; public ModelBatch shadowBatch ; public BulletWorld world ; public ObjLoader objLoader = new ObjLoader ( ) ; public ModelBuilder modelBuilder = new ModelBuilder ( ) ; public ModelBatch modelBatch ; public Array < Disposable > disposables = new Array < Disposable > ( ) ; private int debugMode = DebugDrawModes . DBG_NoDebug ; protected final static Vector3 tmpV1 = new Vector3 ( ) , tmpV2 = new Vector3 ( ) ; public BulletWorld createWorld ( ) { return new BulletWorld ( ) ; } @Override public void create ( ) { init ( ) ; environment = new Environment ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; light = shadows ? new DirectionalShadowLight ( <int> , <int> , <int> f , <int> f , <float> , <int> f ) : new DirectionalLight ( ) ; light . set ( <float> , <float> , <float> , - <float> , - <float> , <float> ) ; environment . add ( light ) ; if ( shadows ) environment . shadowMap = ( DirectionalShadowLight ) light ; shadowBatch = new ModelBatch ( new DepthShaderProvider ( ) ) ; modelBatch = new ModelBatch ( ) ; world = createWorld ( ) ; world . performanceCounter = performanceCounter ; final float width = Gdx . graphics . getWidth ( ) ; final float height = Gdx . graphics . getHeight ( ) ; if ( width > height ) camera = new PerspectiveCamera ( <int> f , <float> * width / height , <float> ) ; else camera = new PerspectiveCamera ( <int> f , <float> , <float> * height / width ) ; camera . position . set ( <int> f , <int> f , <int> f ) ; camera . lookAt ( <int> , <int> , <int> ) ; camera . update ( ) ; final Model groundModel = modelBuilder . createRect ( <int> f , <float> , - <int> f , - <int> f , <float> , - <int> f , - <int> f , <float> , <int> f , <int> f , <float> , <int> f , <int> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) ) , Usage . Position | Usage . Normal ) ; disposables . add ( groundModel ) ; final Model boxModel = modelBuilder . createBox ( <float> , <float> , <float> , new Material ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) ) , Usage . Position | Usage . Normal ) ; disposables . add ( boxModel ) ; world . addConstructor ( <str> , new BulletConstructor ( groundModel , <float> ) ) ; world . addConstructor ( <str> , new BulletConstructor ( boxModel , <float> ) ) ; world . addConstructor ( <str> , new BulletConstructor ( boxModel , <float> ) ) ; } @Override public void dispose ( ) { world . dispose ( ) ; world = null ; for ( Disposable disposable : disposables ) disposable . dispose ( ) ; disposables . clear ( ) ; modelBatch . dispose ( ) ; modelBatch = null ; shadowBatch . dispose ( ) ; shadowBatch = null ; if ( shadows ) ( ( DirectionalShadowLight ) light ) . dispose ( ) ; light = null ; super . dispose ( ) ; } @Override public void render ( ) { render ( true ) ; } public void render ( boolean update ) { fpsCounter . put ( Gdx . graphics . getFramesPerSecond ( ) ) ; if ( update ) update ( ) ; beginRender ( true ) ; renderWorld ( ) ; Gdx . gl . glDisable ( GL20 . GL_DEPTH_TEST ) ; if ( debugMode ! = DebugDrawModes . DBG_NoDebug ) world . setDebugMode ( debugMode ) ; Gdx . gl . glEnable ( GL20 . GL_DEPTH_TEST ) ; performance . setLength ( <int> ) ; performance . append ( <str> ) . append ( fpsCounter . value ) . append ( <str> ) . append ( ( int ) ( performanceCounter . load . value * <int> f ) ) . append ( <str> ) ; } protected void beginRender ( boolean lighting ) { Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; camera . update ( ) ; } protected void renderWorld ( ) { if ( shadows ) { ( ( DirectionalShadowLight ) light ) . begin ( Vector3 . Zero , camera . direction ) ; shadowBatch . begin ( ( ( DirectionalShadowLight ) light ) . getCamera ( ) ) ; world . render ( shadowBatch , null ) ; shadowBatch . end ( ) ; ( ( DirectionalShadowLight ) light ) . end ( ) ; } modelBatch . begin ( camera ) ; world . render ( modelBatch , environment ) ; modelBatch . end ( ) ; } public void update ( ) { world . update ( ) ; } public BulletEntity shoot ( final float x , final float y ) { return shoot ( x , y , <int> f ) ; } public BulletEntity shoot ( final float x , final float y , final float impulse ) { return shoot ( <str> , x , y , impulse ) ; } public BulletEntity shoot ( final String what , final float x , final float y , final float impulse ) { Ray ray = camera . getPickRay ( x , y ) ; BulletEntity entity = world . add ( what , ray . origin . x , ray . origin . y , ray . origin . z ) ; entity . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; ( ( btRigidBody ) entity . body ) . applyCentralImpulse ( ray . direction . scl ( impulse ) ) ; return entity ; } public void setDebugMode ( final int mode ) { world . setDebugMode ( debugMode = mode ) ; } public void toggleDebugMode ( ) { if ( world . getDebugMode ( ) = = DebugDrawModes . DBG_NoDebug ) setDebugMode ( DebugDrawModes . DBG_DrawWireframe | DebugDrawModes . DBG_DrawFeaturesText | DebugDrawModes . DBG_DrawText | DebugDrawModes . DBG_DrawContactPoints ) ; else if ( world . renderMeshes ) world . renderMeshes = false ; else { world . renderMeshes = true ; setDebugMode ( DebugDrawModes . DBG_NoDebug ) ; } } @Override public boolean longPress ( float x , float y ) { toggleDebugMode ( ) ; return true ; } @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . ENTER ) { toggleDebugMode ( ) ; return true ; } return super . keyUp ( keycode ) ; } } 
