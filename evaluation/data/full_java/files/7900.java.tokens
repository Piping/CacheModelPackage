package org . elasticsearch . common . bytes ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . ReleasableBytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . ByteArray ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import org . jboss . netty . buffer . ChannelBuffer ; import org . junit . After ; import org . junit . Before ; import java . io . EOFException ; import java . io . IOException ; import java . nio . channels . FileChannel ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import java . util . Arrays ; public class PagedBytesReferenceTests extends ESTestCase { private static final int PAGE_SIZE = BigArrays . BYTE_PAGE_SIZE ; private BigArrays bigarrays ; @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; bigarrays = new BigArrays ( null , new NoneCircuitBreakerService ( ) ) ; } @Override @After public void tearDown ( ) throws Exception { super . tearDown ( ) ; } public void testGet ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * <int> ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , length / <int> ) ; int sliceLength = Math . max ( <int> , length - sliceOffset - <int> ) ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; assertEquals ( pbr . get ( sliceOffset ) , slice . get ( <int> ) ) ; assertEquals ( pbr . get ( sliceOffset + sliceLength - <int> ) , slice . get ( sliceLength - <int> ) ) ; } public void testLength ( ) { int [ ] sizes = { <int> , randomInt ( PAGE_SIZE ) , PAGE_SIZE , randomInt ( PAGE_SIZE * <int> ) } ; for ( int i = <int> ; i < sizes . length ; i + + ) { BytesReference pbr = getRandomizedPagedBytesReference ( sizes [ i ] ) ; assertEquals ( sizes [ i ] , pbr . length ( ) ) ; } } public void testSlice ( ) { int length = randomInt ( PAGE_SIZE * <int> ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , length / <int> ) ; int sliceLength = Math . max ( <int> , length - sliceOffset - <int> ) ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; assertEquals ( sliceLength , slice . length ( ) ) ; if ( slice . hasArray ( ) ) { assertEquals ( sliceOffset , slice . arrayOffset ( ) ) ; } else { try { slice . arrayOffset ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } } } public void testStreamInput ( ) throws IOException { int length = randomIntBetween ( <int> , scaledRandomIntBetween ( PAGE_SIZE * <int> , PAGE_SIZE * <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; StreamInput si = pbr . streamInput ( ) ; assertNotNull ( si ) ; assertEquals ( pbr . get ( <int> ) , si . readByte ( ) ) ; assertEquals ( pbr . get ( <int> ) , si . readByte ( ) ) ; assertEquals ( pbr . get ( <int> ) , si . readByte ( ) ) ; si . reset ( ) ; byte [ ] origBuf = new byte [ length ] ; getRandom ( ) . nextBytes ( origBuf ) ; byte [ ] targetBuf = Arrays . copyOf ( origBuf , origBuf . length ) ; si . readBytes ( targetBuf , <int> , <int> ) ; assertEquals ( origBuf [ <int> ] , targetBuf [ <int> ] ) ; si . reset ( ) ; int bytesToRead = randomIntBetween ( <int> , length / <int> ) ; for ( int i = <int> ; i < bytesToRead ; i + + ) { int b = si . read ( ) ; assertEquals ( pbr . get ( i ) , b ) ; } si . reset ( ) ; si . readFully ( targetBuf ) ; assertArrayEquals ( pbr . toBytes ( ) , targetBuf ) ; try { si . readByte ( ) ; fail ( <str> ) ; } catch ( EOFException eof ) { } si . reset ( ) ; try { si . readBytes ( targetBuf , <int> , length * <int> ) ; fail ( <str> ) ; } catch ( IndexOutOfBoundsException ioob ) { } } public void testStreamInputBulkReadWithOffset ( ) throws IOException { int length = randomIntBetween ( <int> , scaledRandomIntBetween ( PAGE_SIZE * <int> , PAGE_SIZE * <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; StreamInput si = pbr . streamInput ( ) ; assertNotNull ( si ) ; int offset = randomIntBetween ( <int> , length / <int> ) ; for ( int i = <int> ; i < offset ; i + + ) { assertEquals ( pbr . get ( i ) , si . readByte ( ) ) ; } byte [ ] pbrBytesWithOffset = Arrays . copyOfRange ( pbr . toBytes ( ) , offset , length ) ; byte [ ] targetBytes = new byte [ pbrBytesWithOffset . length ] ; getRandom ( ) . nextBytes ( targetBytes ) ; si . readFully ( targetBytes ) ; assertArrayEquals ( pbrBytesWithOffset , targetBytes ) ; } public void testRandomReads ( ) throws IOException { int length = randomIntBetween ( <int> , scaledRandomIntBetween ( PAGE_SIZE * <int> , PAGE_SIZE * <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; StreamInput streamInput = pbr . streamInput ( ) ; BytesRefBuilder target = new BytesRefBuilder ( ) ; while ( target . length ( ) < pbr . length ( ) ) { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : case <int> : target . append ( new BytesRef ( new byte [ ] { streamInput . readByte ( ) } ) ) ; break ; case <int> : case <int> : BytesRef bytesRef = streamInput . readBytesRef ( scaledRandomIntBetween ( <int> , pbr . length ( ) - target . length ( ) ) ) ; target . append ( bytesRef ) ; break ; default : byte [ ] buffer = new byte [ scaledRandomIntBetween ( <int> , pbr . length ( ) - target . length ( ) ) ] ; int offset = scaledRandomIntBetween ( <int> , buffer . length - <int> ) ; int read = streamInput . read ( buffer , offset , buffer . length - offset ) ; target . append ( new BytesRef ( buffer , offset , read ) ) ; break ; } } assertEquals ( pbr . length ( ) , target . length ( ) ) ; BytesRef targetBytes = target . get ( ) ; assertArrayEquals ( pbr . toBytes ( ) , Arrays . copyOfRange ( targetBytes . bytes , targetBytes . offset , targetBytes . length ) ) ; } public void testSliceStreamInput ( ) throws IOException { int length = randomIntBetween ( <int> , scaledRandomIntBetween ( PAGE_SIZE * <int> , PAGE_SIZE * <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , length / <int> ) ; int sliceLength = length - sliceOffset ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; StreamInput sliceInput = slice . streamInput ( ) ; assertEquals ( slice . get ( <int> ) , sliceInput . readByte ( ) ) ; assertEquals ( slice . get ( <int> ) , sliceInput . readByte ( ) ) ; assertEquals ( slice . get ( <int> ) , sliceInput . readByte ( ) ) ; sliceInput . reset ( ) ; byte [ ] sliceBytes = new byte [ sliceLength ] ; sliceInput . readFully ( sliceBytes ) ; byte [ ] pbrSliceBytes = Arrays . copyOfRange ( pbr . toBytes ( ) , sliceOffset , length ) ; assertArrayEquals ( pbrSliceBytes , sliceBytes ) ; byte [ ] sliceToBytes = slice . toBytes ( ) ; assertEquals ( sliceBytes . length , sliceToBytes . length ) ; assertArrayEquals ( sliceBytes , sliceToBytes ) ; sliceInput . reset ( ) ; byte [ ] buffer = new byte [ sliceLength + scaledRandomIntBetween ( <int> , <int> ) ] ; int offset = scaledRandomIntBetween ( <int> , Math . max ( <int> , buffer . length - sliceLength - <int> ) ) ; int read = sliceInput . read ( buffer , offset , sliceLength / <int> ) ; sliceInput . read ( buffer , offset + read , sliceLength ) ; assertArrayEquals ( sliceBytes , Arrays . copyOfRange ( buffer , offset , offset + sliceLength ) ) ; } public void testWriteToOutputStream ( ) throws IOException { int length = randomIntBetween ( <int> , PAGE_SIZE * <int> ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; pbr . writeTo ( out ) ; assertEquals ( pbr . length ( ) , out . size ( ) ) ; assertArrayEquals ( pbr . toBytes ( ) , out . bytes ( ) . toBytes ( ) ) ; out . close ( ) ; } public void testWriteToChannel ( ) throws IOException { int length = randomIntBetween ( <int> , PAGE_SIZE * <int> ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; Path tFile = createTempFile ( ) ; try ( FileChannel channel = FileChannel . open ( tFile , StandardOpenOption . WRITE ) ) { pbr . writeTo ( channel ) ; assertEquals ( pbr . length ( ) , channel . position ( ) ) ; } assertArrayEquals ( pbr . toBytes ( ) , Files . readAllBytes ( tFile ) ) ; } public void testSliceWriteToOutputStream ( ) throws IOException { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , length / <int> ) ; int sliceLength = length - sliceOffset ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; BytesStreamOutput sliceOut = new BytesStreamOutput ( sliceLength ) ; slice . writeTo ( sliceOut ) ; assertEquals ( slice . length ( ) , sliceOut . size ( ) ) ; assertArrayEquals ( slice . toBytes ( ) , sliceOut . bytes ( ) . toBytes ( ) ) ; sliceOut . close ( ) ; } public void testSliceWriteToChannel ( ) throws IOException { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , length / <int> ) ; int sliceLength = length - sliceOffset ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; Path tFile = createTempFile ( ) ; try ( FileChannel channel = FileChannel . open ( tFile , StandardOpenOption . WRITE ) ) { slice . writeTo ( channel ) ; assertEquals ( slice . length ( ) , channel . position ( ) ) ; } assertArrayEquals ( slice . toBytes ( ) , Files . readAllBytes ( tFile ) ) ; } public void testToBytes ( ) { int [ ] sizes = { <int> , randomInt ( PAGE_SIZE ) , PAGE_SIZE , randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) } ; for ( int i = <int> ; i < sizes . length ; i + + ) { BytesReference pbr = getRandomizedPagedBytesReference ( sizes [ i ] ) ; byte [ ] bytes = pbr . toBytes ( ) ; assertEquals ( sizes [ i ] , bytes . length ) ; if ( sizes [ i ] < = PAGE_SIZE ) { assertSame ( bytes , pbr . toBytes ( ) ) ; } else { assertNotSame ( bytes , pbr . toBytes ( ) ) ; } } } public void testToBytesArraySharedPage ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesArray ba = pbr . toBytesArray ( ) ; BytesArray ba2 = pbr . toBytesArray ( ) ; assertNotNull ( ba ) ; assertNotNull ( ba2 ) ; assertEquals ( pbr . length ( ) , ba . length ( ) ) ; assertEquals ( ba . length ( ) , ba2 . length ( ) ) ; assertSame ( ba . array ( ) , ba2 . array ( ) ) ; } public void testToBytesArrayMaterializedPages ( ) { int length = <int> ; while ( ( length % PAGE_SIZE ) = = <int> ) { length = randomIntBetween ( PAGE_SIZE , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; } BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesArray ba = pbr . toBytesArray ( ) ; BytesArray ba2 = pbr . toBytesArray ( ) ; assertNotNull ( ba ) ; assertNotNull ( ba2 ) ; assertEquals ( pbr . length ( ) , ba . length ( ) ) ; assertEquals ( ba . length ( ) , ba2 . length ( ) ) ; assertNotSame ( ba . array ( ) , ba2 . array ( ) ) ; } public void testCopyBytesArray ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesArray ba = pbr . copyBytesArray ( ) ; BytesArray ba2 = pbr . copyBytesArray ( ) ; assertNotNull ( ba ) ; assertNotSame ( ba , ba2 ) ; assertNotSame ( ba . array ( ) , ba2 . array ( ) ) ; } public void testSliceCopyBytesArray ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceOffset , pbr . length ( ) - sliceOffset ) ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; BytesArray ba1 = slice . copyBytesArray ( ) ; BytesArray ba2 = slice . copyBytesArray ( ) ; assertNotNull ( ba1 ) ; assertNotNull ( ba2 ) ; assertNotSame ( ba1 . array ( ) , ba2 . array ( ) ) ; assertArrayEquals ( slice . toBytes ( ) , ba1 . array ( ) ) ; assertArrayEquals ( slice . toBytes ( ) , ba2 . array ( ) ) ; assertArrayEquals ( ba1 . array ( ) , ba2 . array ( ) ) ; } public void testToChannelBuffer ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; ChannelBuffer cb = pbr . toChannelBuffer ( ) ; assertNotNull ( cb ) ; byte [ ] bufferBytes = new byte [ length ] ; cb . getBytes ( <int> , bufferBytes ) ; assertArrayEquals ( pbr . toBytes ( ) , bufferBytes ) ; } public void testEmptyToChannelBuffer ( ) { BytesReference pbr = getRandomizedPagedBytesReference ( <int> ) ; ChannelBuffer cb = pbr . toChannelBuffer ( ) ; assertNotNull ( cb ) ; assertEquals ( <int> , pbr . length ( ) ) ; assertEquals ( <int> , cb . capacity ( ) ) ; } public void testSliceToChannelBuffer ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceOffset , pbr . length ( ) - sliceOffset ) ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; ChannelBuffer cbSlice = slice . toChannelBuffer ( ) ; assertNotNull ( cbSlice ) ; byte [ ] sliceBufferBytes = new byte [ sliceLength ] ; cbSlice . getBytes ( <int> , sliceBufferBytes ) ; assertArrayEquals ( slice . toBytes ( ) , sliceBufferBytes ) ; } public void testHasArray ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; assertEquals ( length < = PAGE_SIZE , pbr . hasArray ( ) ) ; } public void testArray ( ) { int [ ] sizes = { <int> , randomInt ( PAGE_SIZE ) , PAGE_SIZE , randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) } ; for ( int i = <int> ; i < sizes . length ; i + + ) { BytesReference pbr = getRandomizedPagedBytesReference ( sizes [ i ] ) ; if ( sizes [ i ] < = PAGE_SIZE ) { byte [ ] array = pbr . array ( ) ; assertNotNull ( array ) ; assertEquals ( sizes [ i ] , array . length ) ; assertSame ( array , pbr . array ( ) ) ; } else { try { pbr . array ( ) ; fail ( <str> ) ; } catch ( IllegalStateException isx ) { } } } } public void testArrayOffset ( ) { int length = randomInt ( PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; if ( pbr . hasArray ( ) ) { assertEquals ( <int> , pbr . arrayOffset ( ) ) ; } else { try { pbr . arrayOffset ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } } } public void testSliceArrayOffset ( ) { int length = randomInt ( PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceOffset , pbr . length ( ) - sliceOffset ) ; BytesReference slice = pbr . slice ( sliceOffset , sliceLength ) ; if ( slice . hasArray ( ) ) { assertEquals ( sliceOffset , slice . arrayOffset ( ) ) ; } else { try { slice . arrayOffset ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } } } public void testToUtf8 ( ) throws IOException { BytesReference pbr = getRandomizedPagedBytesReference ( <int> ) ; assertEquals ( <str> , pbr . toUtf8 ( ) ) ; } public void testToBytesRef ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesRef ref = pbr . toBytesRef ( ) ; assertNotNull ( ref ) ; assertEquals ( pbr . arrayOffset ( ) , ref . offset ) ; assertEquals ( pbr . length ( ) , ref . length ) ; } public void testSliceToBytesRef ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; int sliceOffset = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceOffset , pbr . length ( ) - sliceOffset ) ; BytesRef sliceRef = pbr . slice ( sliceOffset , sliceLength ) . toBytesRef ( ) ; assertEquals ( sliceOffset , sliceRef . offset ) ; assertEquals ( sliceLength , sliceRef . length ) ; } public void testCopyBytesRef ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesRef ref = pbr . copyBytesRef ( ) ; assertNotNull ( ref ) ; assertEquals ( pbr . length ( ) , ref . length ) ; } public void testHashCode ( ) { BytesReference pbr = getRandomizedPagedBytesReference ( <int> ) ; assertEquals ( Arrays . hashCode ( BytesRef . EMPTY_BYTES ) , pbr . hashCode ( ) ) ; pbr = getRandomizedPagedBytesReference ( randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ) ; int jdkHash = Arrays . hashCode ( pbr . toBytes ( ) ) ; int pbrHash = pbr . hashCode ( ) ; assertEquals ( jdkHash , pbrHash ) ; int sliceFrom = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceFrom , pbr . length ( ) - sliceFrom ) ; BytesReference slice = pbr . slice ( sliceFrom , sliceLength ) ; int sliceJdkHash = Arrays . hashCode ( slice . toBytes ( ) ) ; int sliceHash = slice . hashCode ( ) ; assertEquals ( sliceJdkHash , sliceHash ) ; } public void testEquals ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; ByteArray ba1 = bigarrays . newByteArray ( length , false ) ; ByteArray ba2 = bigarrays . newByteArray ( length , false ) ; for ( long i = <int> ; i < length ; i + + ) { ba2 . set ( i , ba1 . get ( i ) ) ; } BytesReference pbr = new PagedBytesReference ( bigarrays , ba1 , length ) ; BytesReference pbr2 = new PagedBytesReference ( bigarrays , ba2 , length ) ; assertEquals ( pbr , pbr2 ) ; } public void testEqualsPeerClass ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; BytesReference pbr = getRandomizedPagedBytesReference ( length ) ; BytesReference ba = new BytesArray ( pbr . toBytes ( ) ) ; assertEquals ( pbr , ba ) ; } public void testSliceEquals ( ) { int length = randomIntBetween ( <int> , PAGE_SIZE * randomIntBetween ( <int> , <int> ) ) ; ByteArray ba1 = bigarrays . newByteArray ( length , false ) ; BytesReference pbr = new PagedBytesReference ( bigarrays , ba1 , length ) ; int sliceFrom = randomIntBetween ( <int> , pbr . length ( ) ) ; int sliceLength = randomIntBetween ( pbr . length ( ) - sliceFrom , pbr . length ( ) - sliceFrom ) ; BytesReference slice1 = pbr . slice ( sliceFrom , sliceLength ) ; BytesReference slice2 = pbr . slice ( sliceFrom , sliceLength ) ; assertArrayEquals ( slice1 . toBytes ( ) , slice2 . toBytes ( ) ) ; if ( sliceLength > <int> ) { BytesReference slice3 = pbr . slice ( sliceFrom , sliceLength / <int> ) ; assertFalse ( Arrays . equals ( slice1 . toBytes ( ) , slice3 . toBytes ( ) ) ) ; } } private BytesReference getRandomizedPagedBytesReference ( int length ) { ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput ( length , bigarrays ) ; try { for ( int i = <int> ; i < length ; i + + ) { out . writeByte ( ( byte ) getRandom ( ) . nextInt ( <int> < < <int> ) ) ; } } catch ( IOException e ) { fail ( <str> + e . getMessage ( ) ) ; } assertThat ( out . size ( ) , Matchers . equalTo ( length ) ) ; BytesReference ref = out . bytes ( ) ; assertThat ( ref . length ( ) , Matchers . equalTo ( length ) ) ; assertThat ( ref , Matchers . instanceOf ( PagedBytesReference . class ) ) ; return ref ; } } 
