package org . gradle . tooling . internal . consumer ; import org . gradle . tooling . BuildAction ; import org . gradle . tooling . BuildActionExecuter ; import org . gradle . tooling . GradleConnectionException ; import org . gradle . tooling . ResultHandler ; import org . gradle . tooling . internal . consumer . async . AsyncConsumerActionExecutor ; import org . gradle . tooling . internal . consumer . connection . ConsumerAction ; import org . gradle . tooling . internal . consumer . connection . ConsumerConnection ; import org . gradle . tooling . internal . consumer . parameters . ConsumerOperationParameters ; class DefaultBuildActionExecuter < T > extends AbstractLongRunningOperation < DefaultBuildActionExecuter < T > > implements BuildActionExecuter < T > { private final BuildAction < T > buildAction ; private final AsyncConsumerActionExecutor connection ; public DefaultBuildActionExecuter ( BuildAction < T > buildAction , AsyncConsumerActionExecutor connection , ConnectionParameters parameters ) { super ( parameters ) ; operationParamsBuilder . setEntryPoint ( <str> ) ; this . buildAction = buildAction ; this . connection = connection ; } @Override protected DefaultBuildActionExecuter < T > getThis ( ) { return this ; } public T run ( ) throws GradleConnectionException { BlockingResultHandler < Object > handler = new BlockingResultHandler < Object > ( Object . class ) ; run ( handler ) ; return ( T ) handler . getResult ( ) ; } public void run ( ResultHandler < ? super T > handler ) throws IllegalStateException { final ConsumerOperationParameters operationParameters = getConsumerOperationParameters ( ) ; connection . run ( new ConsumerAction < T > ( ) { public ConsumerOperationParameters getParameters ( ) { return operationParameters ; } public T run ( ConsumerConnection connection ) { T result = connection . run ( buildAction , operationParameters ) ; return result ; } } , new ResultHandlerAdapter < T > ( handler ) { @Override protected String connectionFailureMessage ( Throwable failure ) { return String . format ( <str> , connection . getDisplayName ( ) ) ; } } ) ; } } 
