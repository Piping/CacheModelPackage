package org . jbox2d . dynamics ; import org . jbox2d . collision . AABB ; import org . jbox2d . collision . RayCastInput ; import org . jbox2d . collision . RayCastOutput ; import org . jbox2d . collision . broadphase . BroadPhase ; import org . jbox2d . collision . shapes . MassData ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . collision . shapes . ShapeType ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . contacts . Contact ; import org . jbox2d . dynamics . contacts . ContactEdge ; public class Fixture { public float m_density ; public Fixture m_next ; public Body m_body ; public Shape m_shape ; public float m_friction ; public float m_restitution ; public FixtureProxy [ ] m_proxies ; public int m_proxyCount ; public final Filter m_filter ; public boolean m_isSensor ; public Object m_userData ; public Fixture ( ) { m_userData = null ; m_body = null ; m_next = null ; m_proxies = null ; m_proxyCount = <int> ; m_shape = null ; m_filter = new Filter ( ) ; } public ShapeType getType ( ) { return m_shape . getType ( ) ; } public Shape getShape ( ) { return m_shape ; } public boolean isSensor ( ) { return m_isSensor ; } public void setSensor ( boolean sensor ) { if ( sensor ! = m_isSensor ) { m_body . setAwake ( true ) ; m_isSensor = sensor ; } } public void setFilterData ( final Filter filter ) { m_filter . set ( filter ) ; refilter ( ) ; } public Filter getFilterData ( ) { return m_filter ; } public void refilter ( ) { if ( m_body = = null ) { return ; } ContactEdge edge = m_body . getContactList ( ) ; while ( edge ! = null ) { Contact contact = edge . contact ; Fixture fixtureA = contact . getFixtureA ( ) ; Fixture fixtureB = contact . getFixtureB ( ) ; if ( fixtureA = = this | | fixtureB = = this ) { contact . flagForFiltering ( ) ; } edge = edge . next ; } World world = m_body . getWorld ( ) ; if ( world = = null ) { return ; } BroadPhase broadPhase = world . m_contactManager . m_broadPhase ; for ( int i = <int> ; i < m_proxyCount ; + + i ) { broadPhase . touchProxy ( m_proxies [ i ] . proxyId ) ; } } public Body getBody ( ) { return m_body ; } public Fixture getNext ( ) { return m_next ; } public void setDensity ( float density ) { assert ( density > = <float> ) ; m_density = density ; } public float getDensity ( ) { return m_density ; } public Object getUserData ( ) { return m_userData ; } public void setUserData ( Object data ) { m_userData = data ; } public boolean testPoint ( final Vec2 p ) { return m_shape . testPoint ( m_body . m_xf , p ) ; } public boolean raycast ( RayCastOutput output , RayCastInput input , int childIndex ) { return m_shape . raycast ( output , input , m_body . m_xf , childIndex ) ; } public void getMassData ( MassData massData ) { m_shape . computeMass ( massData , m_density ) ; } public float getFriction ( ) { return m_friction ; } public void setFriction ( float friction ) { m_friction = friction ; } public float getRestitution ( ) { return m_restitution ; } public void setRestitution ( float restitution ) { m_restitution = restitution ; } public AABB getAABB ( int childIndex ) { assert ( childIndex > = <int> & & childIndex < m_proxyCount ) ; return m_proxies [ childIndex ] . aabb ; } public float computeDistance ( Vec2 p , int childIndex , Vec2 normalOut ) { return m_shape . computeDistanceToOut ( m_body . getTransform ( ) , p , childIndex , normalOut ) ; } public void create ( Body body , FixtureDef def ) { m_userData = def . userData ; m_friction = def . friction ; m_restitution = def . restitution ; m_body = body ; m_next = null ; m_filter . set ( def . filter ) ; m_isSensor = def . isSensor ; m_shape = def . shape . clone ( ) ; int childCount = m_shape . getChildCount ( ) ; if ( m_proxies = = null ) { m_proxies = new FixtureProxy [ childCount ] ; for ( int i = <int> ; i < childCount ; i + + ) { m_proxies [ i ] = new FixtureProxy ( ) ; m_proxies [ i ] . fixture = null ; m_proxies [ i ] . proxyId = BroadPhase . NULL_PROXY ; } } if ( m_proxies . length < childCount ) { FixtureProxy [ ] old = m_proxies ; int newLen = MathUtils . max ( old . length * <int> , childCount ) ; m_proxies = new FixtureProxy [ newLen ] ; System . arraycopy ( old , <int> , m_proxies , <int> , old . length ) ; for ( int i = <int> ; i < newLen ; i + + ) { if ( i > = old . length ) { m_proxies [ i ] = new FixtureProxy ( ) ; } m_proxies [ i ] . fixture = null ; m_proxies [ i ] . proxyId = BroadPhase . NULL_PROXY ; } } m_proxyCount = <int> ; m_density = def . density ; } public void destroy ( ) { assert ( m_proxyCount = = <int> ) ; m_shape = null ; m_proxies = null ; m_next = null ; } public void createProxies ( BroadPhase broadPhase , final Transform xf ) { assert ( m_proxyCount = = <int> ) ; m_proxyCount = m_shape . getChildCount ( ) ; for ( int i = <int> ; i < m_proxyCount ; + + i ) { FixtureProxy proxy = m_proxies [ i ] ; m_shape . computeAABB ( proxy . aabb , xf , i ) ; proxy . proxyId = broadPhase . createProxy ( proxy . aabb , proxy ) ; proxy . fixture = this ; proxy . childIndex = i ; } } public void destroyProxies ( BroadPhase broadPhase ) { for ( int i = <int> ; i < m_proxyCount ; + + i ) { FixtureProxy proxy = m_proxies [ i ] ; broadPhase . destroyProxy ( proxy . proxyId ) ; proxy . proxyId = BroadPhase . NULL_PROXY ; } m_proxyCount = <int> ; } private final AABB pool1 = new AABB ( ) ; private final AABB pool2 = new AABB ( ) ; private final Vec2 displacement = new Vec2 ( ) ; protected void synchronize ( BroadPhase broadPhase , final Transform transform1 , final Transform transform2 ) { if ( m_proxyCount = = <int> ) { return ; } for ( int i = <int> ; i < m_proxyCount ; + + i ) { FixtureProxy proxy = m_proxies [ i ] ; final AABB aabb1 = pool1 ; final AABB aab = pool2 ; m_shape . computeAABB ( aabb1 , transform1 , proxy . childIndex ) ; m_shape . computeAABB ( aab , transform2 , proxy . childIndex ) ; proxy . aabb . lowerBound . x = aabb1 . lowerBound . x < aab . lowerBound . x ? aabb1 . lowerBound . x : aab . lowerBound . x ; proxy . aabb . lowerBound . y = aabb1 . lowerBound . y < aab . lowerBound . y ? aabb1 . lowerBound . y : aab . lowerBound . y ; proxy . aabb . upperBound . x = aabb1 . upperBound . x > aab . upperBound . x ? aabb1 . upperBound . x : aab . upperBound . x ; proxy . aabb . upperBound . y = aabb1 . upperBound . y > aab . upperBound . y ? aabb1 . upperBound . y : aab . upperBound . y ; displacement . x = transform2 . p . x - transform1 . p . x ; displacement . y = transform2 . p . y - transform1 . p . y ; broadPhase . moveProxy ( proxy . proxyId , proxy . aabb , displacement ) ; } } } 
