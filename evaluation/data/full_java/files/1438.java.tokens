package org . apache . cassandra . db ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import org . apache . commons . lang3 . StringUtils ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Config . DiskFailurePolicy ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . Directories . DataDirectory ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class DirectoriesTest { private static File tempDataDir ; private static final String KS = <str> ; private static final String [ ] TABLES = new String [ ] { <str> , <str> } ; private static final Set < CFMetaData > CFM = new HashSet < > ( TABLES . length ) ; private static final Map < String , List < File > > files = new HashMap < > ( ) ; @BeforeClass public static void beforeClass ( ) throws IOException { for ( String table : TABLES ) { UUID tableID = CFMetaData . generateLegacyCfId ( KS , table ) ; CFM . add ( CFMetaData . Builder . create ( KS , table ) . withId ( tableID ) . addPartitionKey ( <str> , UTF8Type . instance ) . addClusteringColumn ( <str> , UTF8Type . instance ) . build ( ) ) ; } tempDataDir = File . createTempFile ( <str> , <str> ) ; tempDataDir . delete ( ) ; tempDataDir . mkdir ( ) ; Directories . overrideDataDirectoriesForTest ( tempDataDir . getPath ( ) ) ; createTestFiles ( ) ; } @AfterClass public static void afterClass ( ) { Directories . resetDataDirectoriesAfterTest ( ) ; FileUtils . deleteRecursive ( tempDataDir ) ; } private static void createTestFiles ( ) throws IOException { for ( CFMetaData cfm : CFM ) { List < File > fs = new ArrayList < > ( ) ; files . put ( cfm . cfName , fs ) ; File dir = cfDir ( cfm ) ; dir . mkdirs ( ) ; createFakeSSTable ( dir , cfm . cfName , <int> , fs ) ; createFakeSSTable ( dir , cfm . cfName , <int> , fs ) ; File backupDir = new File ( dir , Directories . BACKUPS_SUBDIR ) ; backupDir . mkdir ( ) ; createFakeSSTable ( backupDir , cfm . cfName , <int> , fs ) ; File snapshotDir = new File ( dir , Directories . SNAPSHOT_SUBDIR + File . separator + <str> ) ; snapshotDir . mkdirs ( ) ; createFakeSSTable ( snapshotDir , cfm . cfName , <int> , fs ) ; } } private static void createFakeSSTable ( File dir , String cf , int gen , List < File > addTo ) throws IOException { Descriptor desc = new Descriptor ( dir , KS , cf , gen ) ; for ( Component c : new Component [ ] { Component . DATA , Component . PRIMARY_INDEX , Component . FILTER } ) { File f = new File ( desc . filenameFor ( c ) ) ; f . createNewFile ( ) ; addTo . add ( f ) ; } } private static File cfDir ( CFMetaData metadata ) { String cfId = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( metadata . cfId ) ) ; int idx = metadata . cfName . indexOf ( Directories . SECONDARY_INDEX_NAME_SEPARATOR ) ; if ( idx > = <int> ) { return new File ( tempDataDir , metadata . ksName + File . separator + metadata . cfName . substring ( <int> , idx ) + <str> + cfId + File . separator + metadata . cfName . substring ( idx ) ) ; } else { return new File ( tempDataDir , metadata . ksName + File . separator + metadata . cfName + <str> + cfId ) ; } } @Test public void testStandardDirs ( ) { for ( CFMetaData cfm : CFM ) { Directories directories = new Directories ( cfm ) ; assertEquals ( cfDir ( cfm ) , directories . getDirectoryForNewSSTables ( ) ) ; Descriptor desc = new Descriptor ( cfDir ( cfm ) , KS , cfm . cfName , <int> ) ; File snapshotDir = new File ( cfDir ( cfm ) , File . separator + Directories . SNAPSHOT_SUBDIR + File . separator + <str> ) ; assertEquals ( snapshotDir , Directories . getSnapshotDirectory ( desc , <str> ) ) ; File backupsDir = new File ( cfDir ( cfm ) , File . separator + Directories . BACKUPS_SUBDIR ) ; assertEquals ( backupsDir , Directories . getBackupsDirectory ( desc ) ) ; } } @Test public void testSecondaryIndexDirectories ( ) { UUID tableID = CFMetaData . generateLegacyCfId ( KS , <str> ) ; CFMetaData PARENT_CFM = CFMetaData . Builder . create ( KS , <str> ) . withId ( tableID ) . addPartitionKey ( <str> , UTF8Type . instance ) . addClusteringColumn ( <str> , UTF8Type . instance ) . build ( ) ; ColumnDefinition col = PARENT_CFM . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; IndexMetadata indexDef = IndexMetadata . fromIndexTargets ( PARENT_CFM , Collections . singletonList ( new IndexTarget ( col . name , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . KEYS , Collections . emptyMap ( ) ) ; PARENT_CFM . indexes ( PARENT_CFM . getIndexes ( ) . with ( indexDef ) ) ; CFMetaData INDEX_CFM = CassandraIndex . indexCfsMetadata ( PARENT_CFM , indexDef ) ; Directories parentDirectories = new Directories ( PARENT_CFM ) ; Directories indexDirectories = new Directories ( INDEX_CFM ) ; for ( File dir : indexDirectories . getCFDirectories ( ) ) { assertEquals ( cfDir ( INDEX_CFM ) , dir ) ; } Descriptor parentDesc = new Descriptor ( parentDirectories . getDirectoryForNewSSTables ( ) , KS , PARENT_CFM . cfName , <int> ) ; Descriptor indexDesc = new Descriptor ( indexDirectories . getDirectoryForNewSSTables ( ) , KS , INDEX_CFM . cfName , <int> ) ; File parentSnapshotDirectory = Directories . getSnapshotDirectory ( parentDesc , <str> ) ; File indexSnapshotDirectory = Directories . getSnapshotDirectory ( indexDesc , <str> ) ; assertEquals ( parentSnapshotDirectory , indexSnapshotDirectory . getParentFile ( ) ) ; parentSnapshotDirectory . mkdirs ( ) ; assertTrue ( parentDirectories . snapshotExists ( <str> ) ) ; assertTrue ( indexDirectories . snapshotExists ( <str> ) ) ; assertEquals ( parentDirectories . snapshotCreationTime ( <str> ) , indexDirectories . snapshotCreationTime ( <str> ) ) ; Descriptor parentSnapshot = new Descriptor ( parentSnapshotDirectory , KS , PARENT_CFM . cfName , <int> ) ; createFile ( parentSnapshot . filenameFor ( Component . DATA ) , <int> ) ; Descriptor indexSnapshot = new Descriptor ( indexSnapshotDirectory , KS , INDEX_CFM . cfName , <int> ) ; createFile ( indexSnapshot . filenameFor ( Component . DATA ) , <int> ) ; assertEquals ( <int> , parentDirectories . trueSnapshotsSize ( ) ) ; assertEquals ( <int> , indexDirectories . trueSnapshotsSize ( ) ) ; Map < String , Pair < Long , Long > > parentSnapshotDetail = parentDirectories . getSnapshotDetails ( ) ; assertTrue ( parentSnapshotDetail . containsKey ( <str> ) ) ; assertEquals ( <int> , parentSnapshotDetail . get ( <str> ) . right . longValue ( ) ) ; Map < String , Pair < Long , Long > > indexSnapshotDetail = indexDirectories . getSnapshotDetails ( ) ; assertTrue ( indexSnapshotDetail . containsKey ( <str> ) ) ; assertEquals ( <int> , indexSnapshotDetail . get ( <str> ) . right . longValue ( ) ) ; File parentBackupDirectory = Directories . getBackupsDirectory ( parentDesc ) ; File indexBackupDirectory = Directories . getBackupsDirectory ( indexDesc ) ; assertEquals ( parentBackupDirectory , indexBackupDirectory . getParentFile ( ) ) ; } private File createFile ( String fileName , int size ) { File newFile = new File ( fileName ) ; try ( FileOutputStream writer = new FileOutputStream ( newFile ) ) { writer . write ( new byte [ size ] ) ; writer . flush ( ) ; } catch ( IOException ignore ) { } return newFile ; } @Test public void testSSTableLister ( ) { for ( CFMetaData cfm : CFM ) { Directories directories = new Directories ( cfm ) ; Directories . SSTableLister lister ; Set < File > listed ; lister = directories . sstableLister ( Directories . OnTxnErr . THROW ) ; listed = new HashSet < > ( lister . listFiles ( ) ) ; for ( File f : files . get ( cfm . cfName ) ) { if ( f . getPath ( ) . contains ( Directories . SNAPSHOT_SUBDIR ) | | f . getPath ( ) . contains ( Directories . BACKUPS_SUBDIR ) ) assert ! listed . contains ( f ) : f + <str> ; else assert listed . contains ( f ) : f + <str> ; } lister = directories . sstableLister ( Directories . OnTxnErr . THROW ) . includeBackups ( true ) ; listed = new HashSet < > ( lister . listFiles ( ) ) ; for ( File f : files . get ( cfm . cfName ) ) { if ( f . getPath ( ) . contains ( Directories . SNAPSHOT_SUBDIR ) ) assert ! listed . contains ( f ) : f + <str> ; else assert listed . contains ( f ) : f + <str> ; } lister = directories . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) ; listed = new HashSet < > ( lister . listFiles ( ) ) ; for ( File f : files . get ( cfm . cfName ) ) { if ( f . getPath ( ) . contains ( Directories . SNAPSHOT_SUBDIR ) | | f . getPath ( ) . contains ( Directories . BACKUPS_SUBDIR ) ) assert ! listed . contains ( f ) : f + <str> ; else if ( f . getName ( ) . contains ( <str> ) ) assert ! listed . contains ( f ) : f + <str> ; else assert listed . contains ( f ) : f + <str> ; } } } @Test public void testDiskFailurePolicy_best_effort ( ) { DiskFailurePolicy origPolicy = DatabaseDescriptor . getDiskFailurePolicy ( ) ; try { DatabaseDescriptor . setDiskFailurePolicy ( DiskFailurePolicy . best_effort ) ; if ( Directories . dataDirectories . length > <int> ) { String [ ] path = new String [ ] { KS , <str> } ; File dir = new File ( Directories . dataDirectories [ <int> ] . location , StringUtils . join ( path , File . separator ) ) ; FileUtils . handleFSError ( new FSWriteError ( new IOException ( <str> + dir ) , dir ) ) ; } for ( DataDirectory dd : Directories . dataDirectories ) { File file = new File ( dd . location , new File ( KS , <str> ) . getPath ( ) ) ; assertTrue ( BlacklistedDirectories . isUnwritable ( file ) ) ; } } finally { DatabaseDescriptor . setDiskFailurePolicy ( origPolicy ) ; } } @Test public void testMTSnapshots ( ) throws Exception { for ( final CFMetaData cfm : CFM ) { final Directories directories = new Directories ( cfm ) ; assertEquals ( cfDir ( cfm ) , directories . getDirectoryForNewSSTables ( ) ) ; final String n = Long . toString ( System . nanoTime ( ) ) ; Callable < File > directoryGetter = new Callable < File > ( ) { public File call ( ) throws Exception { Descriptor desc = new Descriptor ( cfDir ( cfm ) , KS , cfm . cfName , <int> ) ; return Directories . getSnapshotDirectory ( desc , n ) ; } } ; List < Future < File > > invoked = Executors . newFixedThreadPool ( <int> ) . invokeAll ( Arrays . asList ( directoryGetter , directoryGetter ) ) ; for ( Future < File > fut : invoked ) { assertTrue ( fut . get ( ) . exists ( ) ) ; } } } @Test public void testDiskFreeSpace ( ) { DataDirectory [ ] dataDirectories = new DataDirectory [ ] { new DataDirectory ( new File ( <str> ) ) { public long getAvailableSpace ( ) { return <int> ; } } , new DataDirectory ( new File ( <str> ) ) { public long getAvailableSpace ( ) { return <int> ; } } , new DataDirectory ( new File ( <str> ) ) { public long getAvailableSpace ( ) { return <int> ; } } , new DataDirectory ( new File ( <str> ) ) { public long getAvailableSpace ( ) { return <int> ; } } , new DataDirectory ( new File ( <str> ) ) { public long getAvailableSpace ( ) { return <int> ; } } } ; List < Directories . DataDirectoryCandidate > candidates = getWriteableDirectories ( dataDirectories , <int> L ) ; assertSame ( dataDirectories [ <int> ] , candidates . get ( <int> ) . dataDirectory ) ; assertSame ( dataDirectories [ <int> ] , candidates . get ( <int> ) . dataDirectory ) ; assertSame ( dataDirectories [ <int> ] , candidates . get ( <int> ) . dataDirectory ) ; assertSame ( dataDirectories [ <int> ] , candidates . get ( <int> ) . dataDirectory ) ; Map < DataDirectory , DataDirectory > testMap = new IdentityHashMap < > ( ) ; for ( int i = <int> ; ; i + + ) { candidates = getWriteableDirectories ( dataDirectories , <int> ) ; assertEquals ( <int> , candidates . size ( ) ) ; DataDirectory dir = Directories . pickWriteableDirectory ( candidates ) ; testMap . put ( dir , dir ) ; assertFalse ( testMap . size ( ) > <int> ) ; if ( testMap . size ( ) = = <int> ) { if ( i > = <int> ) break ; } if ( i > = <int> ) fail ( ) ; } testMap . clear ( ) ; for ( int i = <int> ; ; i + + ) { candidates = getWriteableDirectories ( dataDirectories , <int> ) ; assertEquals ( <int> , candidates . size ( ) ) ; for ( Directories . DataDirectoryCandidate candidate : candidates ) assertTrue ( candidate . dataDirectory . getAvailableSpace ( ) > = <int> ) ; DataDirectory dir = Directories . pickWriteableDirectory ( candidates ) ; testMap . put ( dir , dir ) ; assertFalse ( testMap . size ( ) > <int> ) ; if ( testMap . size ( ) = = <int> ) { if ( i > = <int> ) break ; } if ( i > = <int> ) fail ( ) ; } } private List < Directories . DataDirectoryCandidate > getWriteableDirectories ( DataDirectory [ ] dataDirectories , long writeSize ) { List < Directories . DataDirectoryCandidate > candidates = new ArrayList < > ( ) ; long totalAvailable = <int> L ; for ( DataDirectory dataDir : dataDirectories ) { Directories . DataDirectoryCandidate candidate = new Directories . DataDirectoryCandidate ( dataDir ) ; if ( candidate . availableSpace < writeSize ) continue ; candidates . add ( candidate ) ; totalAvailable + = candidate . availableSpace ; } Directories . sortWriteableCandidates ( candidates , totalAvailable ) ; return candidates ; } } 
