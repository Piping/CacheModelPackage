package org . apache . cassandra . db . filter ; import java . io . IOException ; import java . util . * ; import com . google . common . collect . SortedSetMultimap ; import com . google . common . collect . TreeMultimap ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public class ColumnFilter { public static final Serializer serializer = new Serializer ( ) ; private final boolean isFetchAll ; private final CFMetaData metadata ; private final PartitionColumns selection ; private final SortedSetMultimap < ColumnIdentifier , ColumnSubselection > subSelections ; private ColumnFilter ( boolean isFetchAll , CFMetaData metadata , PartitionColumns columns , SortedSetMultimap < ColumnIdentifier , ColumnSubselection > subSelections ) { this . isFetchAll = isFetchAll ; this . metadata = metadata ; this . selection = columns ; this . subSelections = subSelections ; } public static ColumnFilter all ( CFMetaData metadata ) { return new ColumnFilter ( true , metadata , null , null ) ; } public static ColumnFilter selection ( PartitionColumns columns ) { return new ColumnFilter ( false , null , columns , null ) ; } public PartitionColumns fetchedColumns ( ) { return isFetchAll ? metadata . partitionColumns ( ) : selection ; } public boolean includesAllColumns ( ) { return isFetchAll ; } public boolean includes ( ColumnDefinition column ) { return isFetchAll | | selection . contains ( column ) ; } public boolean canSkipValue ( ColumnDefinition column ) { return false ; } public boolean includes ( Cell cell ) { if ( isFetchAll | | subSelections = = null | | ! cell . column ( ) . isComplex ( ) ) return true ; SortedSet < ColumnSubselection > s = subSelections . get ( cell . column ( ) . name ) ; if ( s . isEmpty ( ) ) return true ; for ( ColumnSubselection subSel : s ) if ( subSel . compareInclusionOf ( cell . path ( ) ) = = <int> ) return true ; return false ; } public boolean canSkipValue ( ColumnDefinition column , CellPath path ) { if ( ! isFetchAll | | subSelections = = null | | ! column . isComplex ( ) ) return false ; SortedSet < ColumnSubselection > s = subSelections . get ( column . name ) ; if ( s . isEmpty ( ) ) return false ; for ( ColumnSubselection subSel : s ) if ( subSel . compareInclusionOf ( path ) = = <int> ) return false ; return true ; } public Tester newTester ( ColumnDefinition column ) { if ( subSelections = = null | | ! column . isComplex ( ) ) return null ; SortedSet < ColumnSubselection > s = subSelections . get ( column . name ) ; if ( s . isEmpty ( ) ) return null ; return new Tester ( isFetchAll , s . iterator ( ) ) ; } public static Builder allColumnsBuilder ( CFMetaData metadata ) { return new Builder ( metadata ) ; } public static Builder selectionBuilder ( ) { return new Builder ( null ) ; } public static class Tester { private final boolean isFetchAll ; private ColumnSubselection current ; private final Iterator < ColumnSubselection > iterator ; private Tester ( boolean isFetchAll , Iterator < ColumnSubselection > iterator ) { this . isFetchAll = isFetchAll ; this . iterator = iterator ; } public boolean includes ( CellPath path ) { return isFetchAll | | includedBySubselection ( path ) ; } public boolean canSkipValue ( CellPath path ) { return isFetchAll & & ! includedBySubselection ( path ) ; } private boolean includedBySubselection ( CellPath path ) { while ( current ! = null | | iterator . hasNext ( ) ) { if ( current = = null ) current = iterator . next ( ) ; int cmp = current . compareInclusionOf ( path ) ; if ( cmp = = <int> ) return true ; else if ( cmp < <int> ) return false ; current = null ; } return false ; } } public static class Builder { private final CFMetaData metadata ; private PartitionColumns . Builder selection ; private List < ColumnSubselection > subSelections ; private Builder ( CFMetaData metadata ) { this . metadata = metadata ; } public Builder add ( ColumnDefinition c ) { if ( selection = = null ) selection = PartitionColumns . builder ( ) ; selection . add ( c ) ; return this ; } public Builder addAll ( Iterable < ColumnDefinition > columns ) { if ( selection = = null ) selection = PartitionColumns . builder ( ) ; selection . addAll ( columns ) ; return this ; } private Builder addSubSelection ( ColumnSubselection subSelection ) { add ( subSelection . column ( ) ) ; if ( subSelections = = null ) subSelections = new ArrayList < > ( ) ; subSelections . add ( subSelection ) ; return this ; } public Builder slice ( ColumnDefinition c , CellPath from , CellPath to ) { return addSubSelection ( ColumnSubselection . slice ( c , from , to ) ) ; } public Builder select ( ColumnDefinition c , CellPath elt ) { return addSubSelection ( ColumnSubselection . element ( c , elt ) ) ; } public ColumnFilter build ( ) { boolean isFetchAll = metadata ! = null ; PartitionColumns selectedColumns = selection = = null ? null : selection . build ( ) ; if ( ! isFetchAll & & selectedColumns = = null ) selectedColumns = PartitionColumns . NONE ; SortedSetMultimap < ColumnIdentifier , ColumnSubselection > s = null ; if ( subSelections ! = null ) { s = TreeMultimap . create ( Comparator . < ColumnIdentifier > naturalOrder ( ) , Comparator . < ColumnSubselection > naturalOrder ( ) ) ; for ( ColumnSubselection subSelection : subSelections ) s . put ( subSelection . column ( ) . name , subSelection ) ; } return new ColumnFilter ( isFetchAll , metadata , selectedColumns , s ) ; } } @Override public String toString ( ) { if ( isFetchAll ) return <str> ; if ( selection . isEmpty ( ) ) return <str> ; Iterator < ColumnDefinition > defs = selection . selectOrderIterator ( ) ; if ( ! defs . hasNext ( ) ) return <str> ; StringBuilder sb = new StringBuilder ( ) ; while ( defs . hasNext ( ) ) { appendColumnDef ( sb , defs . next ( ) ) ; if ( defs . hasNext ( ) ) sb . append ( <str> ) ; } return sb . toString ( ) ; } private void appendColumnDef ( StringBuilder sb , ColumnDefinition column ) { if ( subSelections = = null ) { sb . append ( column . name ) ; return ; } SortedSet < ColumnSubselection > s = subSelections . get ( column . name ) ; if ( s . isEmpty ( ) ) { sb . append ( column . name ) ; return ; } int i = <int> ; for ( ColumnSubselection subSel : s ) sb . append ( i + + = = <int> ? <str> : <str> ) . append ( column . name ) . append ( subSel ) ; } public static class Serializer { private static final int IS_FETCH_ALL_MASK = <hex> ; private static final int HAS_SELECTION_MASK = <hex> ; private static final int HAS_SUB_SELECTIONS_MASK = <hex> ; private static int makeHeaderByte ( ColumnFilter selection ) { return ( selection . isFetchAll ? IS_FETCH_ALL_MASK : <int> ) | ( selection . selection ! = null ? HAS_SELECTION_MASK : <int> ) | ( selection . subSelections ! = null ? HAS_SUB_SELECTIONS_MASK : <int> ) ; } public void serialize ( ColumnFilter selection , DataOutputPlus out , int version ) throws IOException { out . writeByte ( makeHeaderByte ( selection ) ) ; if ( selection . selection ! = null ) { Columns . serializer . serialize ( selection . selection . statics , out ) ; Columns . serializer . serialize ( selection . selection . regulars , out ) ; } if ( selection . subSelections ! = null ) { out . writeUnsignedVInt ( selection . subSelections . size ( ) ) ; for ( ColumnSubselection subSel : selection . subSelections . values ( ) ) ColumnSubselection . serializer . serialize ( subSel , out , version ) ; } } public ColumnFilter deserialize ( DataInputPlus in , int version , CFMetaData metadata ) throws IOException { int header = in . readUnsignedByte ( ) ; boolean isFetchAll = ( header & IS_FETCH_ALL_MASK ) ! = <int> ; boolean hasSelection = ( header & HAS_SELECTION_MASK ) ! = <int> ; boolean hasSubSelections = ( header & HAS_SUB_SELECTIONS_MASK ) ! = <int> ; PartitionColumns selection = null ; if ( hasSelection ) { Columns statics = Columns . serializer . deserialize ( in , metadata ) ; Columns regulars = Columns . serializer . deserialize ( in , metadata ) ; selection = new PartitionColumns ( statics , regulars ) ; } SortedSetMultimap < ColumnIdentifier , ColumnSubselection > subSelections = null ; if ( hasSubSelections ) { subSelections = TreeMultimap . create ( Comparator . < ColumnIdentifier > naturalOrder ( ) , Comparator . < ColumnSubselection > naturalOrder ( ) ) ; int size = ( int ) in . readUnsignedVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { ColumnSubselection subSel = ColumnSubselection . serializer . deserialize ( in , version , metadata ) ; subSelections . put ( subSel . column ( ) . name , subSel ) ; } } return new ColumnFilter ( isFetchAll , isFetchAll ? metadata : null , selection , subSelections ) ; } public long serializedSize ( ColumnFilter selection , int version ) { long size = <int> ; if ( selection . selection ! = null ) { size + = Columns . serializer . serializedSize ( selection . selection . statics ) ; size + = Columns . serializer . serializedSize ( selection . selection . regulars ) ; } if ( selection . subSelections ! = null ) { size + = TypeSizes . sizeofUnsignedVInt ( selection . subSelections . size ( ) ) ; for ( ColumnSubselection subSel : selection . subSelections . values ( ) ) size + = ColumnSubselection . serializer . serializedSize ( subSel , version ) ; } return size ; } } } 
