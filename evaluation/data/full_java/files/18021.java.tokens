package com . badlogic . gdx . graphics . g3d . model ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class Node { public String id ; public boolean inheritTransform = true ; public boolean isAnimated ; public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( <int> , <int> , <int> , <int> ) ; public final Vector3 scale = new Vector3 ( <int> , <int> , <int> ) ; public final Matrix4 localTransform = new Matrix4 ( ) ; public final Matrix4 globalTransform = new Matrix4 ( ) ; public Array < NodePart > parts = new Array < NodePart > ( <int> ) ; protected Node parent ; private final Array < Node > children = new Array < Node > ( <int> ) ; public Matrix4 calculateLocalTransform ( ) { if ( ! isAnimated ) localTransform . set ( translation , rotation , scale ) ; return localTransform ; } public Matrix4 calculateWorldTransform ( ) { if ( inheritTransform & & parent ! = null ) globalTransform . set ( parent . globalTransform ) . mul ( localTransform ) ; else globalTransform . set ( localTransform ) ; return globalTransform ; } public void calculateTransforms ( boolean recursive ) { calculateLocalTransform ( ) ; calculateWorldTransform ( ) ; if ( recursive ) { for ( Node child : children ) { child . calculateTransforms ( true ) ; } } } public void calculateBoneTransforms ( boolean recursive ) { for ( final NodePart part : parts ) { if ( part . invBoneBindTransforms = = null | | part . bones = = null | | part . invBoneBindTransforms . size ! = part . bones . length ) continue ; final int n = part . invBoneBindTransforms . size ; for ( int i = <int> ; i < n ; i + + ) part . bones [ i ] . set ( part . invBoneBindTransforms . keys [ i ] . globalTransform ) . mul ( part . invBoneBindTransforms . values [ i ] ) ; } if ( recursive ) { for ( Node child : children ) { child . calculateBoneTransforms ( true ) ; } } } public BoundingBox calculateBoundingBox ( final BoundingBox out ) { out . inf ( ) ; return extendBoundingBox ( out ) ; } public BoundingBox calculateBoundingBox ( final BoundingBox out , boolean transform ) { out . inf ( ) ; return extendBoundingBox ( out , transform ) ; } public BoundingBox extendBoundingBox ( final BoundingBox out ) { return extendBoundingBox ( out , true ) ; } public BoundingBox extendBoundingBox ( final BoundingBox out , boolean transform ) { final int partCount = parts . size ; for ( int i = <int> ; i < partCount ; i + + ) { final NodePart part = parts . get ( i ) ; if ( part . enabled ) { final MeshPart meshPart = part . meshPart ; if ( transform ) meshPart . mesh . extendBoundingBox ( out , meshPart . offset , meshPart . size , globalTransform ) ; else meshPart . mesh . extendBoundingBox ( out , meshPart . offset , meshPart . size ) ; } } final int childCount = children . size ; for ( int i = <int> ; i < childCount ; i + + ) children . get ( i ) . extendBoundingBox ( out ) ; return out ; } public < T extends Node > void attachTo ( T parent ) { parent . addChild ( this ) ; } public void detach ( ) { if ( parent ! = null ) { parent . removeChild ( this ) ; parent = null ; } } public boolean hasChildren ( ) { return children ! = null & & children . size > <int> ; } public int getChildCount ( ) { return children . size ; } public Node getChild ( final int index ) { return children . get ( index ) ; } public Node getChild ( final String id , boolean recursive , boolean ignoreCase ) { return getNode ( children , id , recursive , ignoreCase ) ; } public < T extends Node > int addChild ( final T child ) { return insertChild ( - <int> , child ) ; } public < T extends Node > int addChildren ( final Iterable < T > nodes ) { return insertChildren ( - <int> , nodes ) ; } public < T extends Node > int insertChild ( int index , final T child ) { for ( Node p = this ; p ! = null ; p = p . getParent ( ) ) { if ( p = = child ) throw new GdxRuntimeException ( <str> ) ; } Node p = child . getParent ( ) ; if ( p ! = null & & ! p . removeChild ( child ) ) throw new GdxRuntimeException ( <str> ) ; if ( index < <int> | | index > = children . size ) { index = children . size ; children . add ( child ) ; } else children . insert ( index , child ) ; child . parent = this ; return index ; } public < T extends Node > int insertChildren ( int index , final Iterable < T > nodes ) { if ( index < <int> | | index > children . size ) index = children . size ; int i = index ; for ( T child : nodes ) insertChild ( i + + , child ) ; return index ; } public < T extends Node > boolean removeChild ( final T child ) { if ( ! children . removeValue ( child , true ) ) return false ; child . parent = null ; return true ; } public Iterable < Node > getChildren ( ) { return children ; } public Node getParent ( ) { return parent ; } public boolean hasParent ( ) { return parent ! = null ; } public Node copy ( ) { return new Node ( ) . set ( this ) ; } protected Node set ( Node other ) { detach ( ) ; id = other . id ; isAnimated = other . isAnimated ; inheritTransform = other . inheritTransform ; translation . set ( other . translation ) ; rotation . set ( other . rotation ) ; scale . set ( other . scale ) ; localTransform . set ( other . localTransform ) ; globalTransform . set ( other . globalTransform ) ; parts . clear ( ) ; for ( NodePart nodePart : other . parts ) { parts . add ( nodePart . copy ( ) ) ; } children . clear ( ) ; for ( Node child : other . getChildren ( ) ) { addChild ( child . copy ( ) ) ; } return this ; } public static Node getNode ( final Array < Node > nodes , final String id , boolean recursive , boolean ignoreCase ) { final int n = nodes . size ; Node node ; if ( ignoreCase ) { for ( int i = <int> ; i < n ; i + + ) if ( ( node = nodes . get ( i ) ) . id . equalsIgnoreCase ( id ) ) return node ; } else { for ( int i = <int> ; i < n ; i + + ) if ( ( node = nodes . get ( i ) ) . id . equals ( id ) ) return node ; } if ( recursive ) { for ( int i = <int> ; i < n ; i + + ) if ( ( node = getNode ( nodes . get ( i ) . children , id , true , ignoreCase ) ) ! = null ) return node ; } return null ; } } 
