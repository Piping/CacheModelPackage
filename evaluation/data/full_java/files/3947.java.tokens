package org . eclipse . debug . tests . viewer . model ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import junit . framework . TestCase ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class PopupTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public PopupTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell , SWT . POP_UP ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } protected IInternalTreeModelViewer getCTargetViewer ( ) { return ( IInternalTreeModelViewer ) fViewer ; } abstract protected ITreeModelViewer createViewer ( Display display , Shell shell , int style ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testRefreshStruct ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = model . getRootElement ( ) . getChildren ( ) [ <int> ] ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; TestElement [ ] newChildren = new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ; ModelDelta delta = model . setElementChildren ( elementPath , newChildren ) ; fListener . reset ( elementPath , element , - <int> , true , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testExpandAndSelect ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; TestElement element = model . getRootElement ( ) ; TreePath path_root = TreePath . EMPTY ; ModelDelta delta = new ModelDelta ( model . getRootElement ( ) , - <int> , IModelDelta . EXPAND , element . getChildren ( ) . length ) ; ModelDelta deltaRoot = delta ; element = element . getChildren ( ) [ <int> ] ; TreePath path_root_3 = path_root . createChildPath ( element ) ; delta . addNode ( element , <int> , IModelDelta . SELECT | IModelDelta . EXPAND , element . fChildren . length ) ; IInternalTreeModelViewer contentProviderViewer = ( IInternalTreeModelViewer ) fViewer ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; model . postDelta ( deltaRoot ) ; while ( true ) { if ( fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( fListener . isFinished ( CONTENT_SEQUENCE_STARTED ) ) { if ( fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { break ; } } else { break ; } } if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; ISelection selection = fViewer . getSelection ( ) ; if ( selection instanceof ITreeSelection ) { List < TreePath > selectionPathsList = Arrays . asList ( ( ( ITreeSelection ) selection ) . getPaths ( ) ) ; assertFalse ( selectionPathsList . contains ( path_root_3 ) ) ; } else { fail ( <str> ) ; } } public void testPreserveExpandedOnSubTreeContent ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setAutoExpandLevel ( <int> ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; model . addElementChild ( model . findElement ( <str> ) , null , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; TreePath elementPath = model . findElement ( <str> ) ; ModelDelta rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; ModelDelta elementDelta = model . getElementDelta ( rootDelta , elementPath , true ) ; elementDelta . setFlags ( IModelDelta . CONTENT ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getCTargetViewer ( ) , elementPath , model . getElement ( elementPath ) , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getCTargetViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getCTargetViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getCTargetViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getCTargetViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } private boolean areTreeSelectionsEqual ( ITreeSelection sel1 , ITreeSelection sel2 ) { Set < TreePath > sel1Set = new HashSet < TreePath > ( ) ; sel1Set . addAll ( Arrays . asList ( sel1 . getPaths ( ) ) ) ; Set < TreePath > sel2Set = new HashSet < TreePath > ( ) ; sel2Set . addAll ( Arrays . asList ( sel2 . getPaths ( ) ) ) ; return sel1Set . equals ( sel2Set ) ; } } 
