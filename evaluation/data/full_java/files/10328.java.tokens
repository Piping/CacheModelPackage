package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . NavigableSet ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; public class FilteredCollectionsTest extends TestCase { private static final Predicate < Integer > EVEN = new Predicate < Integer > ( ) { @Override public boolean apply ( Integer input ) { return input % <int> = = <int> ; } } ; private static final Predicate < Integer > PRIME_DIGIT = Predicates . in ( ImmutableSet . of ( <int> , <int> , <int> , <int> ) ) ; private static final ImmutableList < ? extends List < Integer > > SAMPLE_INPUTS = ImmutableList . of ( ImmutableList . < Integer > of ( ) , ImmutableList . of ( <int> ) , ImmutableList . of ( <int> ) , ImmutableList . of ( <int> , <int> ) , ImmutableList . of ( <int> , <int> ) , ImmutableList . of ( <int> , <int> ) , ImmutableList . of ( <int> , <int> ) , ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; public static abstract class AbstractFilteredIterableTest < C extends Iterable < Integer > > extends TestCase { abstract C createUnfiltered ( Iterable < Integer > contents ) ; abstract C filter ( C elements , Predicate < ? super Integer > predicate ) ; public void testIterationOrderPreserved ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C unfiltered = createUnfiltered ( contents ) ; C filtered = filter ( unfiltered , EVEN ) ; Iterator < Integer > filteredItr = filtered . iterator ( ) ; for ( Integer i : unfiltered ) { if ( EVEN . apply ( i ) ) { assertTrue ( filteredItr . hasNext ( ) ) ; assertEquals ( i , filteredItr . next ( ) ) ; } } assertFalse ( filteredItr . hasNext ( ) ) ; } } } public static abstract class AbstractFilteredCollectionTest < C extends Collection < Integer > > extends AbstractFilteredIterableTest < C > { public void testReadsThroughAdd ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C unfiltered = createUnfiltered ( contents ) ; C filterThenAdd = filter ( unfiltered , EVEN ) ; unfiltered . add ( <int> ) ; List < Integer > target = Lists . newArrayList ( contents ) ; target . add ( <int> ) ; C addThenFilter = filter ( createUnfiltered ( target ) , EVEN ) ; assertThat ( filterThenAdd ) . containsExactlyElementsIn ( addThenFilter ) ; } } public void testAdd ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int toAdd = <int> ; toAdd < <int> ; toAdd + + ) { boolean expectedResult = createUnfiltered ( contents ) . add ( toAdd ) ; C filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; try { assertEquals ( expectedResult , filtered . add ( toAdd ) ) ; assertTrue ( EVEN . apply ( toAdd ) ) ; } catch ( IllegalArgumentException e ) { assertFalse ( EVEN . apply ( toAdd ) ) ; } } } } public void testRemove ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int toRemove = <int> ; toRemove < <int> ; toRemove + + ) { assertEquals ( contents . contains ( toRemove ) & & EVEN . apply ( toRemove ) , filter ( createUnfiltered ( contents ) , EVEN ) . remove ( toRemove ) ) ; } } } public void testContains ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( EVEN . apply ( i ) & & contents . contains ( i ) , filter ( createUnfiltered ( contents ) , EVEN ) . contains ( i ) ) ; } } } public void testContainsOnDifferentType ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { assertFalse ( filter ( createUnfiltered ( contents ) , EVEN ) . contains ( new Object ( ) ) ) ; } } public void testAddAllFailsAtomically ( ) { ImmutableList < Integer > toAdd = ImmutableList . of ( <int> , <int> , <int> ) ; for ( List < Integer > contents : SAMPLE_INPUTS ) { C filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; C filteredToModify = filter ( createUnfiltered ( contents ) , EVEN ) ; try { filteredToModify . addAll ( toAdd ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertThat ( filteredToModify ) . containsExactlyElementsIn ( filtered ) ; } } public void testAddToFilterFiltered ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C unfiltered = createUnfiltered ( contents ) ; C filtered1 = filter ( unfiltered , EVEN ) ; C filtered2 = filter ( filtered1 , PRIME_DIGIT ) ; try { filtered2 . add ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { filtered2 . add ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } filtered2 . add ( <int> ) ; } } public void testClearFilterFiltered ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C unfiltered = createUnfiltered ( contents ) ; C filtered1 = filter ( unfiltered , EVEN ) ; C filtered2 = filter ( filtered1 , PRIME_DIGIT ) ; C inverseFiltered = filter ( createUnfiltered ( contents ) , Predicates . not ( Predicates . and ( EVEN , PRIME_DIGIT ) ) ) ; filtered2 . clear ( ) ; assertThat ( unfiltered ) . containsExactlyElementsIn ( inverseFiltered ) ; } } } public static abstract class AbstractFilteredSetTest < C extends Set < Integer > > extends AbstractFilteredCollectionTest < C > { public void testEqualsAndHashCode ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { Set < Integer > expected = Sets . newHashSet ( ) ; for ( Integer i : contents ) { if ( EVEN . apply ( i ) ) { expected . add ( i ) ; } } new EqualsTester ( ) . addEqualityGroup ( expected , filter ( createUnfiltered ( contents ) , EVEN ) ) . testEquals ( ) ; } } } public static abstract class AbstractFilteredSortedSetTest < C extends SortedSet < Integer > > extends AbstractFilteredSetTest < C > { public void testFirst ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; try { Integer first = filtered . first ( ) ; assertFalse ( filtered . isEmpty ( ) ) ; assertEquals ( Ordering . natural ( ) . min ( filtered ) , first ) ; } catch ( NoSuchElementException e ) { assertTrue ( filtered . isEmpty ( ) ) ; } } } public void testLast ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { C filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; try { Integer first = filtered . last ( ) ; assertFalse ( filtered . isEmpty ( ) ) ; assertEquals ( Ordering . natural ( ) . max ( filtered ) , first ) ; } catch ( NoSuchElementException e ) { assertTrue ( filtered . isEmpty ( ) ) ; } } } @SuppressWarnings ( <str> ) public void testHeadSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( filter ( ( C ) createUnfiltered ( contents ) . headSet ( i ) , EVEN ) , filter ( createUnfiltered ( contents ) , EVEN ) . headSet ( i ) ) ; } } } @SuppressWarnings ( <str> ) public void testTailSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( filter ( ( C ) createUnfiltered ( contents ) . tailSet ( i ) , EVEN ) , filter ( createUnfiltered ( contents ) , EVEN ) . tailSet ( i ) ) ; } } } @SuppressWarnings ( <str> ) public void testSubSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = i ; j < <int> ; j + + ) { assertEquals ( filter ( ( C ) createUnfiltered ( contents ) . subSet ( i , j ) , EVEN ) , filter ( createUnfiltered ( contents ) , EVEN ) . subSet ( i , j ) ) ; } } } } } public static abstract class AbstractFilteredNavigableSetTest extends AbstractFilteredSortedSetTest < NavigableSet < Integer > > { public void testNavigableHeadSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { for ( boolean inclusive : ImmutableList . of ( true , false ) ) { assertEquals ( filter ( createUnfiltered ( contents ) . headSet ( i , inclusive ) , EVEN ) , filter ( createUnfiltered ( contents ) , EVEN ) . headSet ( i , inclusive ) ) ; } } } } public void testNavigableTailSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { for ( boolean inclusive : ImmutableList . of ( true , false ) ) { assertEquals ( filter ( createUnfiltered ( contents ) . tailSet ( i , inclusive ) , EVEN ) , filter ( createUnfiltered ( contents ) , EVEN ) . tailSet ( i , inclusive ) ) ; } } } } public void testNavigableSubSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = i + <int> ; j < <int> ; j + + ) { for ( boolean fromInclusive : ImmutableList . of ( true , false ) ) { for ( boolean toInclusive : ImmutableList . of ( true , false ) ) { NavigableSet < Integer > filterSubset = filter ( createUnfiltered ( contents ) . subSet ( i , fromInclusive , j , toInclusive ) , EVEN ) ; NavigableSet < Integer > subsetFilter = filter ( createUnfiltered ( contents ) , EVEN ) . subSet ( i , fromInclusive , j , toInclusive ) ; assertEquals ( filterSubset , subsetFilter ) ; } } } } } } public void testDescendingSet ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { NavigableSet < Integer > filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; NavigableSet < Integer > unfiltered = createUnfiltered ( filtered ) ; assertThat ( filtered . descendingSet ( ) ) . containsExactlyElementsIn ( unfiltered . descendingSet ( ) ) . inOrder ( ) ; } } public void testPollFirst ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { NavigableSet < Integer > filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; NavigableSet < Integer > unfiltered = createUnfiltered ( filtered ) ; assertEquals ( unfiltered . pollFirst ( ) , filtered . pollFirst ( ) ) ; assertEquals ( unfiltered , filtered ) ; } } public void testPollLast ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { NavigableSet < Integer > filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; NavigableSet < Integer > unfiltered = createUnfiltered ( filtered ) ; assertEquals ( unfiltered . pollLast ( ) , filtered . pollLast ( ) ) ; assertEquals ( unfiltered , filtered ) ; } } public void testNavigation ( ) { for ( List < Integer > contents : SAMPLE_INPUTS ) { NavigableSet < Integer > filtered = filter ( createUnfiltered ( contents ) , EVEN ) ; NavigableSet < Integer > unfiltered = createUnfiltered ( filtered ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( unfiltered . lower ( i ) , filtered . lower ( i ) ) ; assertEquals ( unfiltered . floor ( i ) , filtered . floor ( i ) ) ; assertEquals ( unfiltered . ceiling ( i ) , filtered . ceiling ( i ) ) ; assertEquals ( unfiltered . higher ( i ) , filtered . higher ( i ) ) ; } } } } public static final class IterablesFilterArrayListTest extends AbstractFilteredIterableTest < Iterable < Integer > > { @Override Iterable < Integer > createUnfiltered ( Iterable < Integer > contents ) { return Lists . newArrayList ( contents ) ; } @Override Iterable < Integer > filter ( Iterable < Integer > elements , Predicate < ? super Integer > predicate ) { return Iterables . filter ( elements , predicate ) ; } } public static final class Collections2FilterArrayListTest extends AbstractFilteredCollectionTest < Collection < Integer > > { @Override Collection < Integer > createUnfiltered ( Iterable < Integer > contents ) { return Lists . newArrayList ( contents ) ; } @Override Collection < Integer > filter ( Collection < Integer > elements , Predicate < ? super Integer > predicate ) { return Collections2 . filter ( elements , predicate ) ; } } public static final class SetsFilterHashSetTest extends AbstractFilteredSetTest < Set < Integer > > { @Override Set < Integer > createUnfiltered ( Iterable < Integer > contents ) { return Sets . newHashSet ( contents ) ; } @Override Set < Integer > filter ( Set < Integer > elements , Predicate < ? super Integer > predicate ) { return Sets . filter ( elements , predicate ) ; } } public static final class SetsFilterSortedSetTest extends AbstractFilteredSortedSetTest < SortedSet < Integer > > { @Override SortedSet < Integer > createUnfiltered ( Iterable < Integer > contents ) { final TreeSet < Integer > result = Sets . newTreeSet ( contents ) ; return new ForwardingSortedSet < Integer > ( ) { @Override protected SortedSet < Integer > delegate ( ) { return result ; } } ; } @Override SortedSet < Integer > filter ( SortedSet < Integer > elements , Predicate < ? super Integer > predicate ) { return Sets . filter ( elements , predicate ) ; } } public static final class SetsFilterNavigableSetTest extends AbstractFilteredNavigableSetTest { @Override NavigableSet < Integer > createUnfiltered ( Iterable < Integer > contents ) { return Sets . newTreeSet ( contents ) ; } @Override NavigableSet < Integer > filter ( NavigableSet < Integer > elements , Predicate < ? super Integer > predicate ) { return Sets . filter ( elements , predicate ) ; } } public void testNoop ( ) { } } 
