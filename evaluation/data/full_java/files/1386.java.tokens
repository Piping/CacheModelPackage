package org . apache . cassandra . cql3 . validation . entities ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . TreeSet ; import java . util . UUID ; import org . junit . Assert ; import org . junit . Test ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . cql3 . functions . FunctionName ; import org . apache . cassandra . exceptions . FunctionExecutionException ; import org . apache . cassandra . utils . UUIDGen ; public class UFPureScriptTest extends CQLTester { @Test public void testJavascriptSimpleCollections ( ) throws Throwable { createTable ( <str> ) ; String fName1 = createFunction ( KEYSPACE_PER_TEST , <str> , <str> + <str> + <str> + <str> + <str> ) ; String fName2 = createFunction ( KEYSPACE_PER_TEST , <str> , <str> + <str> + <str> + <str> + <str> ) ; String fName3 = createFunction ( KEYSPACE_PER_TEST , <str> , <str> + <str> + <str> + <str> + <str> ) ; List < Double > list = Arrays . asList ( <float> , <float> , <float> ) ; Set < String > set = new TreeSet < > ( Arrays . asList ( <str> , <str> , <str> ) ) ; Map < Integer , Boolean > map = new TreeMap < > ( ) ; map . put ( <int> , true ) ; map . put ( <int> , false ) ; map . put ( <int> , true ) ; execute ( <str> , list , set , map ) ; assertRows ( execute ( <str> ) , row ( list , set , map ) ) ; assertRows ( execute ( <str> + fName1 + <str> + fName2 + <str> + fName3 + <str> ) , row ( list , set , map ) ) ; for ( int version : PROTOCOL_VERSIONS ) assertRowsNet ( version , executeNet ( version , <str> + fName1 + <str> + fName2 + <str> + fName3 + <str> ) , row ( list , set , map ) ) ; } @Test public void testJavascriptTupleType ( ) throws Throwable { createTable ( <str> ) ; String fName = createFunction ( KEYSPACE_PER_TEST , <str> , <str> + <str> + <str> + <str> + <str> ) ; Object t = tuple ( <float> , <str> , <int> , true ) ; execute ( <str> , t ) ; assertRows ( execute ( <str> ) , row ( t ) ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( t ) ) ; } @Test public void testJavascriptUserType ( ) throws Throwable { String type = createType ( <str> ) ; createTable ( <str> + type + <str> ) ; String fUdt1 = createFunction ( KEYSPACE , type , <str> + type + <str> + <str> + <str> + type + <str> + <str> + <str> + <str> ) ; String fUdt2 = createFunction ( KEYSPACE , type , <str> + type + <str> + <str> + <str> + <str> + <str> + <str> ) ; String fUdt3 = createFunction ( KEYSPACE , type , <str> + type + <str> + <str> + <str> + <str> + <str> + <str> ) ; execute ( <str> ) ; UntypedResultSet rows = execute ( <str> + fUdt1 + <str> ) ; Assert . assertEquals ( <int> , rows . size ( ) ) ; assertRows ( execute ( <str> + fUdt2 + <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> + fUdt3 + <str> ) , row ( <int> ) ) ; } @Test public void testJavascriptUTCollections ( ) throws Throwable { String type = createType ( <str> ) ; createTable ( String . format ( <str> + <str> , type , type , type ) ) ; String fName = createFunction ( KEYSPACE , <str> + type + <str> , <str> + type + <str> + <str> + <str> + <str> + <str> + <str> ) ; createFunctionOverload ( fName , <str> + type + <str> , <str> + type + <str> + <str> + <str> + <str> + <str> + <str> ) ; createFunctionOverload ( fName , <str> + type + <str> , <str> + type + <str> + <str> + <str> + <str> + <str> + <str> ) ; execute ( <str> + <str> + <str> + <str> ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( <str> ) ) ; String cqlSelect = <str> + fName + <str> + fName + <str> + fName + <str> ; assertRows ( execute ( cqlSelect ) , row ( <str> , <str> , <str> ) ) ; for ( int version : PROTOCOL_VERSIONS ) assertRowsNet ( version , executeNet ( version , cqlSelect ) , row ( <str> , <str> , <str> ) ) ; } @Test public void testJavascriptFunction ( ) throws Throwable { createTable ( <str> ) ; String functionBody = <str> + <str> ; String fName = createFunction ( KEYSPACE , <str> , <str> + <str> + <str> + <str> + <str> + functionBody + <str> ) ; FunctionName fNameName = parseFunctionName ( fName ) ; assertRows ( execute ( <str> , fNameName . keyspace , fNameName . name ) , row ( <str> , functionBody ) ) ; execute ( <str> , <int> , <float> ) ; execute ( <str> , <int> , <float> ) ; execute ( <str> , <int> , <float> ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( <int> , <float> , Math . sin ( <float> ) ) , row ( <int> , <float> , Math . sin ( <float> ) ) , row ( <int> , <float> , Math . sin ( <float> ) ) ) ; } @Test public void testJavascriptBadReturnType ( ) throws Throwable { createTable ( <str> ) ; String fName = createFunction ( KEYSPACE , <str> , <str> + <str> + <str> + <str> + <str> ) ; execute ( <str> , <int> , <float> ) ; assertInvalidMessage ( <str> , <str> + fName + <str> ) ; } @Test public void testJavascriptThrow ( ) throws Throwable { createTable ( <str> ) ; String fName = createFunction ( KEYSPACE , <str> , <str> + <str> + <str> + <str> + <str> ) ; execute ( <str> , <int> , <float> ) ; assertInvalidThrowMessage ( <str> , FunctionExecutionException . class , <str> + fName + <str> ) ; } @Test public void testScriptReturnTypeCasting ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> , <int> , <float> ) ; Object [ ] [ ] variations = { new Object [ ] { <str> , <str> , true } , new Object [ ] { <str> , <str> , false } , new Object [ ] { <str> , <str> , ( byte ) <int> } , new Object [ ] { <str> , <str> , ( byte ) <int> } , new Object [ ] { <str> , <str> , ( short ) <int> } , new Object [ ] { <str> , <str> , ( short ) <int> } , new Object [ ] { <str> , <str> , <int> } , new Object [ ] { <str> , <str> , <int> } , new Object [ ] { <str> , <str> , <int> d } , new Object [ ] { <str> , <str> , <int> d } , new Object [ ] { <str> , <str> , <int> } , new Object [ ] { <str> , <str> , <int> } , new Object [ ] { <str> , <str> , BigInteger . valueOf ( <int> ) } , new Object [ ] { <str> , <str> , BigInteger . valueOf ( <int> ) } , new Object [ ] { <str> , <str> , BigDecimal . valueOf ( <int> d ) } , new Object [ ] { <str> , <str> , BigDecimal . valueOf ( <int> d ) } , } ; for ( Object [ ] variation : variations ) { Object functionBody = variation [ <int> ] ; Object returnType = variation [ <int> ] ; Object expectedResult = variation [ <int> ] ; String fName = createFunction ( KEYSPACE , <str> , <str> + <str> + <str> + returnType + <str> + <str> + <str> + functionBody + <str> ) ; assertRows ( execute ( <str> + fName + <str> ) , row ( <int> , <float> , expectedResult ) ) ; } } @Test public void testScriptParamReturnTypes ( ) throws Throwable { UUID ruuid = UUID . randomUUID ( ) ; UUID tuuid = UUIDGen . getTimeUUID ( ) ; createTable ( <str> + <str> + <str> ) ; execute ( <str> + <str> , <int> , ( byte ) <int> , ( short ) <int> , <int> , <int> , <float> , <float> , BigInteger . valueOf ( <int> ) , BigDecimal . valueOf ( <float> ) , <int> , Integer . MAX_VALUE , new Date ( <int> ) , ruuid , tuuid ) ; Object [ ] [ ] variations = { new Object [ ] { <str> , <str> , ( byte ) <int> , ( byte ) <int> } , new Object [ ] { <str> , <str> , ( short ) <int> , ( short ) <int> } , new Object [ ] { <str> , <str> , <int> , <int> } , new Object [ ] { <str> , <str> , <int> , <int> } , new Object [ ] { <str> , <str> , <float> , <float> } , new Object [ ] { <str> , <str> , <float> , <float> } , new Object [ ] { <str> , <str> , BigInteger . valueOf ( <int> ) , BigInteger . valueOf ( <int> ) } , new Object [ ] { <str> , <str> , BigDecimal . valueOf ( <float> ) , BigDecimal . valueOf ( <float> ) } , new Object [ ] { <str> , <str> , <int> , <int> } , } ; for ( Object [ ] variation : variations ) { Object type = variation [ <int> ] ; Object col = variation [ <int> ] ; Object expected1 = variation [ <int> ] ; Object expected2 = variation [ <int> ] ; String fName = createFunction ( KEYSPACE , type . toString ( ) , <str> + type + <str> + <str> + <str> + type + <str> + <str> + <str> ) ; assertRows ( execute ( <str> + col + <str> + fName + <str> + col + <str> ) , row ( <int> , expected1 , expected2 ) ) ; } variations = new Object [ ] [ ] { new Object [ ] { <str> , <str> , new Date ( <int> ) , new Date ( <int> ) } , new Object [ ] { <str> , <str> , ruuid , ruuid } , new Object [ ] { <str> , <str> , tuuid , tuuid } , new Object [ ] { <str> , <str> , Integer . MAX_VALUE , Integer . MAX_VALUE } , } ; for ( Object [ ] variation : variations ) { Object type = variation [ <int> ] ; Object col = variation [ <int> ] ; Object expected1 = variation [ <int> ] ; Object expected2 = variation [ <int> ] ; String fName = createFunction ( KEYSPACE , type . toString ( ) , <str> + type + <str> + <str> + <str> + type + <str> + <str> + <str> ) ; assertRows ( execute ( <str> + col + <str> + fName + <str> + col + <str> ) , row ( <int> , expected1 , expected2 ) ) ; } } @Test public void testJavascriptDisabled ( ) throws Throwable { createTable ( <str> ) ; DatabaseDescriptor . enableScriptedUserDefinedFunctions ( false ) ; try { assertInvalid ( <str> , <str> + KEYSPACE + <str> + <str> + <str> + <str> + <str> ) ; } finally { DatabaseDescriptor . enableScriptedUserDefinedFunctions ( true ) ; } } } 
