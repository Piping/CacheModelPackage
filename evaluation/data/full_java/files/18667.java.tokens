package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . utils . MeshPartBuilder ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class MaterialTest extends GdxTest { float angleY = <int> ; Model model , backModel ; ModelInstance modelInstance ; ModelInstance background ; ModelBatch modelBatch ; TextureAttribute textureAttribute ; ColorAttribute colorAttribute ; BlendingAttribute blendingAttribute ; Material material ; Texture texture ; Camera camera ; @Override public void create ( ) { texture = new Texture ( Gdx . files . internal ( <str> ) , true ) ; textureAttribute = new TextureAttribute ( TextureAttribute . Diffuse , texture ) ; colorAttribute = new ColorAttribute ( ColorAttribute . Diffuse , Color . ORANGE ) ; blendingAttribute = new BlendingAttribute ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; ModelBuilder builder = new ModelBuilder ( ) ; model = builder . createBox ( <int> , <int> , <int> , new Material ( ) , Usage . Position | Usage . Normal | Usage . TextureCoordinates ) ; model . manageDisposable ( texture ) ; modelInstance = new ModelInstance ( model ) ; modelInstance . transform . rotate ( Vector3 . X , <int> ) ; material = modelInstance . materials . get ( <int> ) ; builder . begin ( ) ; MeshPartBuilder mpb = builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position | Usage . TextureCoordinates , new Material ( textureAttribute ) ) ; mpb . rect ( - <int> , - <int> , - <int> , <int> , - <int> , - <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , <int> ) ; backModel = builder . end ( ) ; background = new ModelInstance ( backModel ) ; modelBatch = new ModelBatch ( ) ; camera = new PerspectiveCamera ( <int> , <int> , <int> ) ; camera . position . set ( <int> , <int> , <int> ) ; camera . direction . set ( <int> , <int> , - <int> ) ; camera . update ( ) ; Gdx . input . setInputProcessor ( this ) ; } private float counter = <float> ; @Override public void render ( ) { counter = ( counter + Gdx . graphics . getDeltaTime ( ) ) % <float> ; blendingAttribute . opacity = <float> + Math . abs ( <float> - counter ) ; Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; modelInstance . transform . rotate ( Vector3 . Y , <int> * Gdx . graphics . getDeltaTime ( ) ) ; modelBatch . begin ( camera ) ; modelBatch . render ( background ) ; modelBatch . render ( modelInstance ) ; modelBatch . end ( ) ; } @Override public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { if ( ! material . has ( TextureAttribute . Diffuse ) ) material . set ( textureAttribute ) ; else if ( ! material . has ( ColorAttribute . Diffuse ) ) material . set ( colorAttribute ) ; else if ( ! material . has ( BlendingAttribute . Type ) ) material . set ( blendingAttribute ) ; else material . clear ( ) ; return super . touchUp ( screenX , screenY , pointer , button ) ; } @Override public void dispose ( ) { model . dispose ( ) ; backModel . dispose ( ) ; modelBatch . dispose ( ) ; } } 
