package org . elasticsearch . search . aggregations . pipeline . movavg . models ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . pipeline . movavg . MovAvgParser ; import java . io . IOException ; import java . text . ParseException ; import java . util . * ; public class HoltWintersModel extends MovAvgModel { protected static final ParseField NAME_FIELD = new ParseField ( <str> ) ; private final double alpha ; private final double beta ; private final double gamma ; private final int period ; private final SeasonalityType seasonalityType ; private final boolean pad ; private final double padding ; public enum SeasonalityType { ADDITIVE ( ( byte ) <int> , <str> ) , MULTIPLICATIVE ( ( byte ) <int> , <str> ) ; @Nullable public static SeasonalityType parse ( String text , ParseFieldMatcher parseFieldMatcher ) { if ( text = = null ) { return null ; } SeasonalityType result = null ; for ( SeasonalityType policy : values ( ) ) { if ( parseFieldMatcher . match ( text , policy . parseField ) ) { result = policy ; break ; } } if ( result = = null ) { final List < String > validNames = new ArrayList < > ( ) ; for ( SeasonalityType policy : values ( ) ) { validNames . add ( policy . getName ( ) ) ; } throw new ElasticsearchParseException ( <str> , text , validNames ) ; } return result ; } private final byte id ; private final ParseField parseField ; SeasonalityType ( byte id , String name ) { this . id = id ; this . parseField = new ParseField ( name ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeByte ( id ) ; } public static SeasonalityType readFrom ( StreamInput in ) throws IOException { byte id = in . readByte ( ) ; for ( SeasonalityType seasonalityType : values ( ) ) { if ( id = = seasonalityType . id ) { return seasonalityType ; } } throw new IllegalStateException ( <str> + id + <str> ) ; } public String getName ( ) { return parseField . getPreferredName ( ) ; } } public HoltWintersModel ( double alpha , double beta , double gamma , int period , SeasonalityType seasonalityType , boolean pad ) { this . alpha = alpha ; this . beta = beta ; this . gamma = gamma ; this . period = period ; this . seasonalityType = seasonalityType ; this . pad = pad ; this . padding = seasonalityType . equals ( SeasonalityType . MULTIPLICATIVE ) & & pad ? <float> : <int> ; } @Override public boolean minimizeByDefault ( ) { return true ; } @Override public boolean canBeMinimized ( ) { return true ; } @Override public MovAvgModel neighboringModel ( ) { double newValue = Math . random ( ) ; switch ( ( int ) ( Math . random ( ) * <int> ) ) { case <int> : return new HoltWintersModel ( newValue , beta , gamma , period , seasonalityType , pad ) ; case <int> : return new HoltWintersModel ( alpha , newValue , gamma , period , seasonalityType , pad ) ; case <int> : return new HoltWintersModel ( alpha , beta , newValue , period , seasonalityType , pad ) ; default : assert ( false ) : <str> ; return new HoltWintersModel ( newValue , beta , gamma , period , seasonalityType , pad ) ; } } @Override public MovAvgModel clone ( ) { return new HoltWintersModel ( alpha , beta , gamma , period , seasonalityType , pad ) ; } @Override public boolean hasValue ( int valuesAvailable ) { return valuesAvailable > = period * <int> ; } @Override protected < T extends Number > double [ ] doPredict ( Collection < T > values , int numPredictions ) { return next ( values , numPredictions ) ; } @Override public < T extends Number > double next ( Collection < T > values ) { return next ( values , <int> ) [ <int> ] ; } public < T extends Number > double [ ] next ( Collection < T > values , int numForecasts ) { if ( values . size ( ) < period * <int> ) { throw new AggregationExecutionException ( <str> + period + <str> + ( <int> * period ) + <str> + values . size ( ) + <str> ) ; } double s = <int> ; double last_s ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ values . size ( ) ] ; int counter = <int> ; double [ ] vs = new double [ values . size ( ) ] ; for ( T v : values ) { vs [ counter ] = v . doubleValue ( ) + padding ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = ( double ) period ; b / = ( double ) period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { if ( seasonalityType . equals ( SeasonalityType . MULTIPLICATIVE ) ) { s = alpha * ( vs [ i ] / seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; } else { s = alpha * ( vs [ i ] - seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; } b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; if ( seasonalityType . equals ( SeasonalityType . MULTIPLICATIVE ) ) { seasonal [ i ] = gamma * ( vs [ i ] / ( last_s + last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; } else { seasonal [ i ] = gamma * ( vs [ i ] - ( last_s - last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; } last_s = s ; last_b = b ; } double [ ] forecastValues = new double [ numForecasts ] ; for ( int i = <int> ; i < = numForecasts ; i + + ) { int idx = values . size ( ) - period + ( ( i - <int> ) % period ) ; if ( seasonalityType . equals ( SeasonalityType . MULTIPLICATIVE ) ) { forecastValues [ i - <int> ] = ( s + ( i * b ) ) * seasonal [ idx ] ; } else { forecastValues [ i - <int> ] = s + ( i * b ) + seasonal [ idx ] ; } } return forecastValues ; } public static final MovAvgModelStreams . Stream STREAM = new MovAvgModelStreams . Stream ( ) { @Override public MovAvgModel readResult ( StreamInput in ) throws IOException { double alpha = in . readDouble ( ) ; double beta = in . readDouble ( ) ; double gamma = in . readDouble ( ) ; int period = in . readVInt ( ) ; SeasonalityType type = SeasonalityType . readFrom ( in ) ; boolean pad = in . readBoolean ( ) ; return new HoltWintersModel ( alpha , beta , gamma , period , type , pad ) ; } @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } } ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; out . writeDouble ( alpha ) ; out . writeDouble ( beta ) ; out . writeDouble ( gamma ) ; out . writeVInt ( period ) ; seasonalityType . writeTo ( out ) ; out . writeBoolean ( pad ) ; } public static class HoltWintersModelParser extends AbstractModelParser { @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } @Override public MovAvgModel parse ( @Nullable Map < String , Object > settings , String pipelineName , int windowSize , ParseFieldMatcher parseFieldMatcher ) throws ParseException { double alpha = parseDoubleParam ( settings , <str> , <float> ) ; double beta = parseDoubleParam ( settings , <str> , <float> ) ; double gamma = parseDoubleParam ( settings , <str> , <float> ) ; int period = parseIntegerParam ( settings , <str> , <int> ) ; if ( windowSize < <int> * period ) { throw new ParseException ( <str> + <str> + windowSize + <str> + ( <int> * period ) , <int> ) ; } SeasonalityType seasonalityType = SeasonalityType . ADDITIVE ; if ( settings ! = null ) { Object value = settings . get ( <str> ) ; if ( value ! = null ) { if ( value instanceof String ) { seasonalityType = SeasonalityType . parse ( ( String ) value , parseFieldMatcher ) ; settings . remove ( <str> ) ; } else { throw new ParseException ( <str> + value . getClass ( ) . getSimpleName ( ) + <str> , <int> ) ; } } } boolean pad = parseBoolParam ( settings , <str> , seasonalityType . equals ( SeasonalityType . MULTIPLICATIVE ) ) ; checkUnrecognizedParams ( settings ) ; return new HoltWintersModel ( alpha , beta , gamma , period , seasonalityType , pad ) ; } } public static class HoltWintersModelBuilder implements MovAvgModelBuilder { private Double alpha ; private Double beta ; private Double gamma ; private Integer period ; private SeasonalityType seasonalityType ; private Boolean pad ; public HoltWintersModelBuilder alpha ( double alpha ) { this . alpha = alpha ; return this ; } public HoltWintersModelBuilder beta ( double beta ) { this . beta = beta ; return this ; } public HoltWintersModelBuilder gamma ( double gamma ) { this . gamma = gamma ; return this ; } public HoltWintersModelBuilder period ( int period ) { this . period = period ; return this ; } public HoltWintersModelBuilder seasonalityType ( SeasonalityType type ) { this . seasonalityType = type ; return this ; } public HoltWintersModelBuilder pad ( boolean pad ) { this . pad = pad ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( MovAvgParser . MODEL . getPreferredName ( ) , NAME_FIELD . getPreferredName ( ) ) ; builder . startObject ( MovAvgParser . SETTINGS . getPreferredName ( ) ) ; if ( alpha ! = null ) { builder . field ( <str> , alpha ) ; } if ( beta ! = null ) { builder . field ( <str> , beta ) ; } if ( gamma ! = null ) { builder . field ( <str> , gamma ) ; } if ( period ! = null ) { builder . field ( <str> , period ) ; } if ( pad ! = null ) { builder . field ( <str> , pad ) ; } if ( seasonalityType ! = null ) { builder . field ( <str> , seasonalityType . getName ( ) ) ; } builder . endObject ( ) ; return builder ; } } } 
