package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . util . concurrent . DefaultEventExecutorGroup ; import io . netty . util . concurrent . DefaultPromise ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Promise ; import org . junit . Test ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import static org . junit . Assert . * ; public class SocketBufReleaseTest extends AbstractSocketTest { private static final EventExecutor executor = new DefaultEventExecutorGroup ( <int> , new DefaultThreadFactory ( SocketBufReleaseTest . class , true ) ) . next ( ) ; @Test public void testBufRelease ( ) throws Throwable { run ( ) ; } public void testBufRelease ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { BufWriterHandler serverHandler = new BufWriterHandler ( ) ; BufWriterHandler clientHandler = new BufWriterHandler ( ) ; sb . childHandler ( serverHandler ) ; cb . handler ( clientHandler ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; serverHandler . channelFuture . sync ( ) ; sc . close ( ) . sync ( ) ; cc . close ( ) . sync ( ) ; serverHandler . check ( ) ; clientHandler . check ( ) ; serverHandler . release ( ) ; clientHandler . release ( ) ; } private static class BufWriterHandler extends SimpleChannelInboundHandler < Object > { private final Random random = new Random ( ) ; private final CountDownLatch latch = new CountDownLatch ( <int> ) ; private ByteBuf buf ; private final Promise < Channel > channelFuture = new DefaultPromise < Channel > ( executor ) ; @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { channelFuture . setSuccess ( ctx . channel ( ) ) ; } @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { byte [ ] data = new byte [ <int> ] ; random . nextBytes ( data ) ; buf = ctx . alloc ( ) . buffer ( ) ; buf . writeBytes ( data ) . retain ( ) ; ctx . channel ( ) . writeAndFlush ( buf ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { latch . countDown ( ) ; } } ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { } public void check ( ) throws InterruptedException { latch . await ( ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; } void release ( ) { buf . release ( ) ; } } } 
