package com . badlogic . gdx . graphics . glutils ; import java . nio . ByteBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class IndexBufferObject implements IndexData { ShortBuffer buffer ; ByteBuffer byteBuffer ; int bufferHandle ; final boolean isDirect ; boolean isDirty = true ; boolean isBound = false ; final int usage ; private final boolean empty ; public IndexBufferObject ( int maxIndices ) { this ( true , maxIndices ) ; } public IndexBufferObject ( boolean isStatic , int maxIndices ) { empty = maxIndices = = <int> ; if ( empty ) { maxIndices = <int> ; } byteBuffer = BufferUtils . newUnsafeByteBuffer ( maxIndices * <int> ) ; isDirect = true ; buffer = byteBuffer . asShortBuffer ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; bufferHandle = Gdx . gl20 . glGenBuffer ( ) ; usage = isStatic ? GL20 . GL_STATIC_DRAW : GL20 . GL_DYNAMIC_DRAW ; } public int getNumIndices ( ) { return empty ? <int> : buffer . limit ( ) ; } public int getNumMaxIndices ( ) { return empty ? <int> : buffer . capacity ( ) ; } public void setIndices ( short [ ] indices , int offset , int count ) { isDirty = true ; buffer . clear ( ) ; buffer . put ( indices , offset , count ) ; buffer . flip ( ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( count < < <int> ) ; if ( isBound ) { Gdx . gl20 . glBufferData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } } public void setIndices ( ShortBuffer indices ) { isDirty = true ; int pos = indices . position ( ) ; buffer . clear ( ) ; buffer . put ( indices ) ; buffer . flip ( ) ; indices . position ( pos ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( buffer . limit ( ) < < <int> ) ; if ( isBound ) { Gdx . gl20 . glBufferData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } } public ShortBuffer getBuffer ( ) { isDirty = true ; return buffer ; } public void bind ( ) { if ( bufferHandle = = <int> ) throw new GdxRuntimeException ( <str> ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , bufferHandle ) ; if ( isDirty ) { byteBuffer . limit ( buffer . limit ( ) * <int> ) ; Gdx . gl20 . glBufferData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } isBound = true ; } public void unbind ( ) { Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> ) ; isBound = false ; } public void invalidate ( ) { bufferHandle = Gdx . gl20 . glGenBuffer ( ) ; isDirty = true ; } public void dispose ( ) { Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> ) ; Gdx . gl20 . glDeleteBuffer ( bufferHandle ) ; bufferHandle = <int> ; BufferUtils . disposeUnsafeByteBuffer ( byteBuffer ) ; } } 
