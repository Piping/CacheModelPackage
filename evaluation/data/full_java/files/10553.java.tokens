package com . google . common . math ; import static com . google . common . math . MathTesting . ALL_BIGINTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . ALL_ROUNDING_MODES ; import static com . google . common . math . MathTesting . ALL_SAFE_ROUNDING_MODES ; import static com . google . common . math . MathTesting . NONZERO_BIGINTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . POSITIVE_BIGINTEGER_CANDIDATES ; import static java . math . BigInteger . ONE ; import static java . math . BigInteger . TEN ; import static java . math . BigInteger . ZERO ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . DOWN ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . HALF_DOWN ; import static java . math . RoundingMode . HALF_EVEN ; import static java . math . RoundingMode . HALF_UP ; import static java . math . RoundingMode . UNNECESSARY ; import static java . math . RoundingMode . UP ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible ( emulated = true ) public class BigIntegerMathTest extends TestCase { @GwtIncompatible ( <str> ) public void testConstantSqrt2PrecomputedBits ( ) { assertEquals ( BigIntegerMath . sqrt ( BigInteger . ZERO . setBit ( <int> * BigIntegerMath . SQRT2_PRECOMPUTE_THRESHOLD + <int> ) , FLOOR ) , BigIntegerMath . SQRT2_PRECOMPUTED_BITS ) ; } public void testIsPowerOfTwo ( ) { for ( BigInteger x : ALL_BIGINTEGER_CANDIDATES ) { boolean expected = x . signum ( ) > <int> & x . and ( x . subtract ( ONE ) ) . equals ( ZERO ) ; assertEquals ( expected , BigIntegerMath . isPowerOfTwo ( x ) ) ; } } public void testLog2ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . log2 ( ZERO , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testLog2NegativeAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . log2 ( BigInteger . valueOf ( - <int> ) , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testLog2Floor ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( FLOOR , DOWN ) ) { int result = BigIntegerMath . log2 ( x , mode ) ; assertTrue ( ZERO . setBit ( result ) . compareTo ( x ) < = <int> ) ; assertTrue ( ZERO . setBit ( result + <int> ) . compareTo ( x ) > <int> ) ; } } } public void testLog2Ceiling ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( CEILING , UP ) ) { int result = BigIntegerMath . log2 ( x , mode ) ; assertTrue ( ZERO . setBit ( result ) . compareTo ( x ) > = <int> ) ; assertTrue ( result = = <int> | | ZERO . setBit ( result - <int> ) . compareTo ( x ) < <int> ) ; } } } public void testLog2Exact ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { boolean isPowerOf2 = BigIntegerMath . isPowerOfTwo ( x ) ; try { assertEquals ( x , ZERO . setBit ( BigIntegerMath . log2 ( x , UNNECESSARY ) ) ) ; assertTrue ( isPowerOf2 ) ; } catch ( ArithmeticException e ) { assertFalse ( isPowerOf2 ) ; } } } public void testLog2HalfUp ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int result = BigIntegerMath . log2 ( x , HALF_UP ) ; BigInteger x2 = x . pow ( <int> ) ; assertTrue ( ZERO . setBit ( <int> * result + <int> ) . compareTo ( x2 ) > <int> ) ; assertTrue ( result = = <int> | | ZERO . setBit ( <int> * result - <int> ) . compareTo ( x2 ) < = <int> ) ; } } public void testLog2HalfDown ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int result = BigIntegerMath . log2 ( x , HALF_DOWN ) ; BigInteger x2 = x . pow ( <int> ) ; assertTrue ( ZERO . setBit ( <int> * result + <int> ) . compareTo ( x2 ) > = <int> ) ; assertTrue ( result = = <int> | | ZERO . setBit ( <int> * result - <int> ) . compareTo ( x2 ) < <int> ) ; } } public void testLog2HalfEven ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int halfEven = BigIntegerMath . log2 ( x , HALF_EVEN ) ; boolean floorWasEven = ( BigIntegerMath . log2 ( x , FLOOR ) & <int> ) = = <int> ; assertEquals ( BigIntegerMath . log2 ( x , floorWasEven ? HALF_DOWN : HALF_UP ) , halfEven ) ; } } @GwtIncompatible ( <str> ) public void testLog10ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . log10 ( ZERO , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testLog10NegativeAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . log10 ( BigInteger . valueOf ( - <int> ) , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testLog10Floor ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( FLOOR , DOWN ) ) { int result = BigIntegerMath . log10 ( x , mode ) ; assertTrue ( TEN . pow ( result ) . compareTo ( x ) < = <int> ) ; assertTrue ( TEN . pow ( result + <int> ) . compareTo ( x ) > <int> ) ; } } } @GwtIncompatible ( <str> ) public void testLog10Ceiling ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( CEILING , UP ) ) { int result = BigIntegerMath . log10 ( x , mode ) ; assertTrue ( TEN . pow ( result ) . compareTo ( x ) > = <int> ) ; assertTrue ( result = = <int> | | TEN . pow ( result - <int> ) . compareTo ( x ) < <int> ) ; } } } @GwtIncompatible ( <str> ) public void testLog10Exact ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int logFloor = BigIntegerMath . log10 ( x , FLOOR ) ; boolean expectSuccess = TEN . pow ( logFloor ) . equals ( x ) ; try { assertEquals ( logFloor , BigIntegerMath . log10 ( x , UNNECESSARY ) ) ; assertTrue ( expectSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( expectSuccess ) ; } } } @GwtIncompatible ( <str> ) public void testLog10HalfUp ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int result = BigIntegerMath . log10 ( x , HALF_UP ) ; BigInteger x2 = x . pow ( <int> ) ; assertTrue ( TEN . pow ( <int> * result + <int> ) . compareTo ( x2 ) > <int> ) ; assertTrue ( result = = <int> | | TEN . pow ( <int> * result - <int> ) . compareTo ( x2 ) < = <int> ) ; } } @GwtIncompatible ( <str> ) public void testLog10HalfDown ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int result = BigIntegerMath . log10 ( x , HALF_DOWN ) ; BigInteger x2 = x . pow ( <int> ) ; assertTrue ( TEN . pow ( <int> * result + <int> ) . compareTo ( x2 ) > = <int> ) ; assertTrue ( result = = <int> | | TEN . pow ( <int> * result - <int> ) . compareTo ( x2 ) < <int> ) ; } } @GwtIncompatible ( <str> ) public void testLog10HalfEven ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { int halfEven = BigIntegerMath . log10 ( x , HALF_EVEN ) ; boolean floorWasEven = ( BigIntegerMath . log10 ( x , FLOOR ) & <int> ) = = <int> ; assertEquals ( BigIntegerMath . log10 ( x , floorWasEven ? HALF_DOWN : HALF_UP ) , halfEven ) ; } } @GwtIncompatible ( <str> ) public void testLog10TrivialOnPowerOf10 ( ) { BigInteger x = BigInteger . TEN . pow ( <int> ) ; for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> , BigIntegerMath . log10 ( x , mode ) ) ; } } @GwtIncompatible ( <str> ) public void testSqrtZeroAlwaysZero ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( ZERO , BigIntegerMath . sqrt ( ZERO , mode ) ) ; } } @GwtIncompatible ( <str> ) public void testSqrtNegativeAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . sqrt ( BigInteger . valueOf ( - <int> ) , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testSqrtFloor ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( FLOOR , DOWN ) ) { BigInteger result = BigIntegerMath . sqrt ( x , mode ) ; assertTrue ( result . compareTo ( ZERO ) > <int> ) ; assertTrue ( result . pow ( <int> ) . compareTo ( x ) < = <int> ) ; assertTrue ( result . add ( ONE ) . pow ( <int> ) . compareTo ( x ) > <int> ) ; } } } @GwtIncompatible ( <str> ) public void testSqrtCeiling ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : asList ( CEILING , UP ) ) { BigInteger result = BigIntegerMath . sqrt ( x , mode ) ; assertTrue ( result . compareTo ( ZERO ) > <int> ) ; assertTrue ( result . pow ( <int> ) . compareTo ( x ) > = <int> ) ; assertTrue ( result . signum ( ) = = <int> | | result . subtract ( ONE ) . pow ( <int> ) . compareTo ( x ) < <int> ) ; } } } @GwtIncompatible ( <str> ) public void testSqrtExact ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger floor = BigIntegerMath . sqrt ( x , FLOOR ) ; boolean isPerfectSquare = floor . pow ( <int> ) . equals ( x ) ; try { assertEquals ( floor , BigIntegerMath . sqrt ( x , UNNECESSARY ) ) ; assertTrue ( isPerfectSquare ) ; } catch ( ArithmeticException e ) { assertFalse ( isPerfectSquare ) ; } } } @GwtIncompatible ( <str> ) public void testSqrtHalfUp ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger result = BigIntegerMath . sqrt ( x , HALF_UP ) ; BigInteger plusHalfSquared = result . pow ( <int> ) . add ( result ) . shiftLeft ( <int> ) . add ( ONE ) ; BigInteger x4 = x . shiftLeft ( <int> ) ; assertTrue ( x4 . compareTo ( plusHalfSquared ) < <int> ) ; BigInteger minusHalfSquared = result . pow ( <int> ) . subtract ( result ) . shiftLeft ( <int> ) . add ( ONE ) ; assertTrue ( result . equals ( ZERO ) | | x4 . compareTo ( minusHalfSquared ) > = <int> ) ; } } @GwtIncompatible ( <str> ) public void testSqrtHalfDown ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger result = BigIntegerMath . sqrt ( x , HALF_DOWN ) ; BigInteger plusHalfSquared = result . pow ( <int> ) . add ( result ) . shiftLeft ( <int> ) . add ( ONE ) ; BigInteger x4 = x . shiftLeft ( <int> ) ; assertTrue ( x4 . compareTo ( plusHalfSquared ) < = <int> ) ; BigInteger minusHalfSquared = result . pow ( <int> ) . subtract ( result ) . shiftLeft ( <int> ) . add ( ONE ) ; assertTrue ( result . equals ( ZERO ) | | x4 . compareTo ( minusHalfSquared ) > <int> ) ; } } @GwtIncompatible ( <str> ) public void testSqrtHalfEven ( ) { for ( BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES ) { BigInteger halfEven = BigIntegerMath . sqrt ( x , HALF_EVEN ) ; boolean floorWasOdd = BigIntegerMath . sqrt ( x , FLOOR ) . testBit ( <int> ) ; assertEquals ( BigIntegerMath . sqrt ( x , floorWasOdd ? HALF_UP : HALF_DOWN ) , halfEven ) ; } } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testDivNonZero ( ) { for ( BigInteger p : NONZERO_BIGINTEGER_CANDIDATES ) { for ( BigInteger q : NONZERO_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { BigInteger expected = new BigDecimal ( p ) . divide ( new BigDecimal ( q ) , <int> , mode ) . toBigIntegerExact ( ) ; assertEquals ( expected , BigIntegerMath . divide ( p , q , mode ) ) ; } } } } private static final BigInteger BAD_FOR_ANDROID_P = new BigInteger ( <str> ) ; private static final BigInteger BAD_FOR_ANDROID_Q = new BigInteger ( <str> ) ; private static final BigInteger BAD_FOR_GINGERBREAD_P = new BigInteger ( <str> ) ; private static final BigInteger BAD_FOR_GINGERBREAD_Q = new BigInteger ( <str> ) ; @GwtIncompatible ( <str> ) @AndroidIncompatible public void testDivNonZeroExact ( ) { boolean isAndroid = System . getProperties ( ) . getProperty ( <str> ) . contains ( <str> ) ; for ( BigInteger p : NONZERO_BIGINTEGER_CANDIDATES ) { for ( BigInteger q : NONZERO_BIGINTEGER_CANDIDATES ) { if ( isAndroid & & p . equals ( BAD_FOR_ANDROID_P ) & & q . equals ( BAD_FOR_ANDROID_Q ) ) { continue ; } if ( isAndroid & & p . equals ( BAD_FOR_GINGERBREAD_P ) & & q . equals ( BAD_FOR_GINGERBREAD_Q ) ) { continue ; } boolean dividesEvenly = p . remainder ( q ) . equals ( ZERO ) ; try { BigInteger quotient = BigIntegerMath . divide ( p , q , UNNECESSARY ) ; BigInteger undone = quotient . multiply ( q ) ; if ( ! p . equals ( undone ) ) { failFormat ( <str> , quotient , q , p , undone ) ; } assertTrue ( dividesEvenly ) ; } catch ( ArithmeticException e ) { assertFalse ( dividesEvenly ) ; } } } } @GwtIncompatible ( <str> ) public void testZeroDivIsAlwaysZero ( ) { for ( BigInteger q : NONZERO_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( ZERO , BigIntegerMath . divide ( ZERO , q , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testDivByZeroAlwaysFails ( ) { for ( BigInteger p : ALL_BIGINTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { BigIntegerMath . divide ( p , ZERO , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } public void testFactorial ( ) { BigInteger expected = BigInteger . ONE ; for ( int i = <int> ; i < = <int> ; i + + ) { expected = expected . multiply ( BigInteger . valueOf ( i ) ) ; assertEquals ( expected , BigIntegerMath . factorial ( i ) ) ; } } public void testFactorial0 ( ) { assertEquals ( BigInteger . ONE , BigIntegerMath . factorial ( <int> ) ) ; } public void testFactorialNegative ( ) { try { BigIntegerMath . factorial ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testBinomialSmall ( ) { runBinomialTest ( <int> , <int> ) ; } @GwtIncompatible ( <str> ) public void testBinomialLarge ( ) { runBinomialTest ( <int> , <int> ) ; } private static void runBinomialTest ( int firstN , int lastN ) { for ( int n = firstN ; n < = lastN ; n + + ) { for ( int k = <int> ; k < = n ; k + + ) { BigInteger expected = BigIntegerMath . factorial ( n ) . divide ( BigIntegerMath . factorial ( k ) ) . divide ( BigIntegerMath . factorial ( n - k ) ) ; assertEquals ( expected , BigIntegerMath . binomial ( n , k ) ) ; } } } public void testBinomialOutside ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { try { BigIntegerMath . binomial ( n , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { BigIntegerMath . binomial ( n , n + <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . setDefault ( BigInteger . class , ONE ) ; tester . setDefault ( int . class , <int> ) ; tester . setDefault ( long . class , <int> ) ; tester . testAllPublicStaticMethods ( BigIntegerMath . class ) ; } @GwtIncompatible ( <str> ) private static void failFormat ( String template , Object . . . args ) { fail ( String . format ( template , args ) ) ; } } 
