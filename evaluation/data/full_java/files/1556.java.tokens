package org . apache . cassandra . io . sstable ; import java . io . File ; import java . io . IOException ; import java . util . UUID ; import org . apache . commons . lang3 . StringUtils ; import org . junit . Assert ; import org . junit . Test ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; public class DescriptorTest { private final String ksname = <str> ; private final String cfname = <str> ; private final String cfId = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( UUID . randomUUID ( ) ) ) ; private final File tempDataDir ; public DescriptorTest ( ) throws IOException { tempDataDir = File . createTempFile ( <str> , null ) . getParentFile ( ) ; } @Test public void testFromFilename ( ) throws Exception { File cfIdDir = new File ( tempDataDir . getAbsolutePath ( ) + File . separator + ksname + File . separator + cfname + <str> + cfId ) ; testFromFilenameFor ( cfIdDir ) ; } @Test public void testFromFilenameInBackup ( ) throws Exception { File backupDir = new File ( StringUtils . join ( new String [ ] { tempDataDir . getAbsolutePath ( ) , ksname , cfname + <str> + cfId , Directories . BACKUPS_SUBDIR } , File . separator ) ) ; testFromFilenameFor ( backupDir ) ; } @Test public void testFromFilenameInSnapshot ( ) throws Exception { File snapshotDir = new File ( StringUtils . join ( new String [ ] { tempDataDir . getAbsolutePath ( ) , ksname , cfname + <str> + cfId , Directories . SNAPSHOT_SUBDIR , <str> } , File . separator ) ) ; testFromFilenameFor ( snapshotDir ) ; } @Test public void testFromFilenameInLegacyDirectory ( ) throws Exception { File cfDir = new File ( tempDataDir . getAbsolutePath ( ) + File . separator + ksname + File . separator + cfname ) ; testFromFilenameFor ( cfDir ) ; } private void testFromFilenameFor ( File dir ) { checkFromFilename ( new Descriptor ( dir , ksname , cfname , <int> ) , false ) ; checkFromFilename ( new Descriptor ( dir , ksname , cfname , <int> ) , true ) ; String idxName = <str> ; File idxDir = new File ( dir . getAbsolutePath ( ) + File . separator + Directories . SECONDARY_INDEX_NAME_SEPARATOR + idxName ) ; checkFromFilename ( new Descriptor ( idxDir , ksname , cfname + Directories . SECONDARY_INDEX_NAME_SEPARATOR + idxName , <int> ) , false ) ; checkFromFilename ( new Descriptor ( <str> , dir , ksname , cfname , <int> , SSTableFormat . Type . LEGACY ) , false ) ; checkFromFilename ( new Descriptor ( <str> , dir , ksname , cfname + Directories . SECONDARY_INDEX_NAME_SEPARATOR + idxName , <int> , SSTableFormat . Type . LEGACY ) , false ) ; } private void checkFromFilename ( Descriptor original , boolean skipComponent ) { File file = new File ( skipComponent ? original . baseFilename ( ) : original . filenameFor ( Component . DATA ) ) ; Pair < Descriptor , String > pair = Descriptor . fromFilename ( file . getParentFile ( ) , file . getName ( ) , skipComponent ) ; Descriptor desc = pair . left ; assertEquals ( original . directory , desc . directory ) ; assertEquals ( original . ksname , desc . ksname ) ; assertEquals ( original . cfname , desc . cfname ) ; assertEquals ( original . version , desc . version ) ; assertEquals ( original . generation , desc . generation ) ; if ( skipComponent ) { assertNull ( pair . right ) ; } else { assertEquals ( Component . DATA . name ( ) , pair . right ) ; } } @Test public void validateNames ( ) { String names [ ] = { <str> + SSTableFormat . Type . BIG . name + <str> } ; for ( String name : names ) { Descriptor d = Descriptor . fromFilename ( name ) ; } } @Test public void badNames ( ) { String names [ ] = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String name : names ) { try { Descriptor d = Descriptor . fromFilename ( name ) ; Assert . fail ( name ) ; } catch ( Throwable e ) { } } } } 
