package io . netty . handler . codec . http2 ; import static io . netty . buffer . Unpooled . directBuffer ; import static io . netty . buffer . Unpooled . unmodifiableBuffer ; import static io . netty . buffer . Unpooled . unreleasableBuffer ; import static io . netty . handler . codec . http2 . Http2CodecUtil . CONTINUATION_FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DATA_FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_MAX_FRAME_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . GO_AWAY_FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . HEADERS_FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . INT_FIELD_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MAX_UNSIGNED_BYTE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MAX_UNSIGNED_INT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MAX_WEIGHT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MIN_WEIGHT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . PING_FRAME_PAYLOAD_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . PRIORITY_ENTRY_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . PRIORITY_FRAME_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . PUSH_PROMISE_FRAME_HEADER_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . RST_STREAM_FRAME_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . SETTING_ENTRY_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . WINDOW_UPDATE_FRAME_LENGTH ; import static io . netty . handler . codec . http2 . Http2CodecUtil . isMaxFrameSizeValid ; import static io . netty . handler . codec . http2 . Http2CodecUtil . writeFrameHeaderInternal ; import static io . netty . handler . codec . http2 . Http2CodecUtil . writeUnsignedInt ; import static io . netty . handler . codec . http2 . Http2CodecUtil . writeUnsignedShort ; import static io . netty . handler . codec . http2 . Http2Error . FRAME_SIZE_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . handler . codec . http2 . Http2FrameTypes . CONTINUATION ; import static io . netty . handler . codec . http2 . Http2FrameTypes . DATA ; import static io . netty . handler . codec . http2 . Http2FrameTypes . GO_AWAY ; import static io . netty . handler . codec . http2 . Http2FrameTypes . HEADERS ; import static io . netty . handler . codec . http2 . Http2FrameTypes . PING ; import static io . netty . handler . codec . http2 . Http2FrameTypes . PRIORITY ; import static io . netty . handler . codec . http2 . Http2FrameTypes . PUSH_PROMISE ; import static io . netty . handler . codec . http2 . Http2FrameTypes . RST_STREAM ; import static io . netty . handler . codec . http2 . Http2FrameTypes . SETTINGS ; import static io . netty . handler . codec . http2 . Http2FrameTypes . WINDOW_UPDATE ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . max ; import static java . lang . Math . min ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http2 . Http2CodecUtil . SimpleChannelPromiseAggregator ; import io . netty . handler . codec . http2 . Http2FrameWriter . Configuration ; public class DefaultHttp2FrameWriter implements Http2FrameWriter , Http2FrameSizePolicy , Configuration { private static final String STREAM_ID = <str> ; private static final String STREAM_DEPENDENCY = <str> ; private static final ByteBuf ZERO_BUFFER = unmodifiableBuffer ( unreleasableBuffer ( directBuffer ( MAX_UNSIGNED_BYTE ) . writeZero ( MAX_UNSIGNED_BYTE ) ) ) ; private final Http2HeadersEncoder headersEncoder ; private int maxFrameSize ; public DefaultHttp2FrameWriter ( ) { this ( new DefaultHttp2HeadersEncoder ( ) ) ; } public DefaultHttp2FrameWriter ( Http2HeadersEncoder . SensitivityDetector headersSensativityDetector ) { this ( new DefaultHttp2HeadersEncoder ( Http2CodecUtil . DEFAULT_HEADER_TABLE_SIZE , headersSensativityDetector ) ) ; } public DefaultHttp2FrameWriter ( Http2HeadersEncoder headersEncoder ) { this . headersEncoder = headersEncoder ; maxFrameSize = DEFAULT_MAX_FRAME_SIZE ; } @Override public Configuration configuration ( ) { return this ; } @Override public Http2HeaderTable headerTable ( ) { return headersEncoder . configuration ( ) . headerTable ( ) ; } @Override public Http2FrameSizePolicy frameSizePolicy ( ) { return this ; } @Override public void maxFrameSize ( int max ) throws Http2Exception { if ( ! isMaxFrameSizeValid ( max ) ) { throw connectionError ( FRAME_SIZE_ERROR , <str> , max ) ; } maxFrameSize = max ; } @Override public int maxFrameSize ( ) { return maxFrameSize ; } @Override public void close ( ) { } @Override public ChannelFuture writeData ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endStream , ChannelPromise promise ) { final SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; final DataFrameHeader header = new DataFrameHeader ( ctx , streamId ) ; boolean needToReleaseHeaders = true ; boolean needToReleaseData = true ; try { verifyStreamId ( streamId , STREAM_ID ) ; verifyPadding ( padding ) ; boolean lastFrame ; int remainingData = data . readableBytes ( ) ; do { int frameDataBytes = min ( remainingData , maxFrameSize ) ; int framePaddingBytes = min ( padding , max ( <int> , ( maxFrameSize - <int> ) - frameDataBytes ) ) ; padding - = framePaddingBytes ; remainingData - = frameDataBytes ; lastFrame = remainingData = = <int> & & padding = = <int> ; ByteBuf frameHeader = header . slice ( frameDataBytes , framePaddingBytes , lastFrame & & endStream ) ; needToReleaseHeaders = ! lastFrame ; ctx . write ( lastFrame ? frameHeader : frameHeader . retain ( ) , promiseAggregator . newPromise ( ) ) ; ByteBuf frameData = data . readSlice ( frameDataBytes ) ; needToReleaseData = ! lastFrame ; ctx . write ( lastFrame ? frameData : frameData . retain ( ) , promiseAggregator . newPromise ( ) ) ; if ( framePaddingBytes > <int> ) { ctx . write ( ZERO_BUFFER . slice ( <int> , framePaddingBytes ) , promiseAggregator . newPromise ( ) ) ; } } while ( ! lastFrame ) ; return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { if ( needToReleaseHeaders ) { header . release ( ) ; } if ( needToReleaseData ) { data . release ( ) ; } return promiseAggregator . setFailure ( t ) ; } } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream , ChannelPromise promise ) { return writeHeadersInternal ( ctx , streamId , headers , padding , endStream , false , <int> , ( short ) <int> , false , promise ) ; } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream , ChannelPromise promise ) { return writeHeadersInternal ( ctx , streamId , headers , padding , endStream , true , streamDependency , weight , exclusive , promise ) ; } @Override public ChannelFuture writePriority ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive , ChannelPromise promise ) { try { verifyStreamId ( streamId , STREAM_ID ) ; verifyStreamId ( streamDependency , STREAM_DEPENDENCY ) ; verifyWeight ( weight ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( PRIORITY_FRAME_LENGTH ) ; writeFrameHeaderInternal ( buf , PRIORITY_ENTRY_LENGTH , PRIORITY , new Http2Flags ( ) , streamId ) ; long word1 = exclusive ? <hex> | streamDependency : streamDependency ; writeUnsignedInt ( word1 , buf ) ; buf . writeByte ( weight - <int> ) ; return ctx . write ( buf , promise ) ; } catch ( Throwable t ) { return promise . setFailure ( t ) ; } } @Override public ChannelFuture writeRstStream ( ChannelHandlerContext ctx , int streamId , long errorCode , ChannelPromise promise ) { try { verifyStreamId ( streamId , STREAM_ID ) ; verifyErrorCode ( errorCode ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( RST_STREAM_FRAME_LENGTH ) ; writeFrameHeaderInternal ( buf , INT_FIELD_LENGTH , RST_STREAM , new Http2Flags ( ) , streamId ) ; writeUnsignedInt ( errorCode , buf ) ; return ctx . write ( buf , promise ) ; } catch ( Throwable t ) { return promise . setFailure ( t ) ; } } @Override public ChannelFuture writeSettings ( ChannelHandlerContext ctx , Http2Settings settings , ChannelPromise promise ) { try { checkNotNull ( settings , <str> ) ; int payloadLength = SETTING_ENTRY_LENGTH * settings . size ( ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( FRAME_HEADER_LENGTH + settings . size ( ) * SETTING_ENTRY_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , SETTINGS , new Http2Flags ( ) , <int> ) ; for ( Http2Settings . PrimitiveEntry < Long > entry : settings . entries ( ) ) { writeUnsignedShort ( entry . key ( ) , buf ) ; writeUnsignedInt ( entry . value ( ) , buf ) ; } return ctx . write ( buf , promise ) ; } catch ( Throwable t ) { return promise . setFailure ( t ) ; } } @Override public ChannelFuture writeSettingsAck ( ChannelHandlerContext ctx , ChannelPromise promise ) { try { ByteBuf buf = ctx . alloc ( ) . buffer ( FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , <int> , SETTINGS , new Http2Flags ( ) . ack ( true ) , <int> ) ; return ctx . write ( buf , promise ) ; } catch ( Throwable t ) { return promise . setFailure ( t ) ; } } @Override public ChannelFuture writePing ( ChannelHandlerContext ctx , boolean ack , ByteBuf data , ChannelPromise promise ) { boolean releaseData = true ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { verifyPingPayload ( data ) ; Http2Flags flags = ack ? new Http2Flags ( ) . ack ( true ) : new Http2Flags ( ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , data . readableBytes ( ) , PING , flags , <int> ) ; ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; releaseData = false ; ctx . write ( data , promiseAggregator . newPromise ( ) ) ; return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { if ( releaseData ) { data . release ( ) ; } return promiseAggregator . setFailure ( t ) ; } } @Override public ChannelFuture writePushPromise ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding , ChannelPromise promise ) { ByteBuf headerBlock = null ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { verifyStreamId ( streamId , STREAM_ID ) ; verifyStreamId ( promisedStreamId , <str> ) ; verifyPadding ( padding ) ; headerBlock = ctx . alloc ( ) . buffer ( ) ; headersEncoder . encodeHeaders ( headers , headerBlock ) ; Http2Flags flags = new Http2Flags ( ) . paddingPresent ( padding > <int> ) ; int nonFragmentLength = INT_FIELD_LENGTH + padding + flags . getPaddingPresenceFieldLength ( ) ; int maxFragmentLength = maxFrameSize - nonFragmentLength ; ByteBuf fragment = headerBlock . readSlice ( min ( headerBlock . readableBytes ( ) , maxFragmentLength ) ) . retain ( ) ; flags . endOfHeaders ( ! headerBlock . isReadable ( ) ) ; int payloadLength = fragment . readableBytes ( ) + nonFragmentLength ; ByteBuf buf = ctx . alloc ( ) . buffer ( PUSH_PROMISE_FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , PUSH_PROMISE , flags , streamId ) ; writePaddingLength ( buf , padding ) ; buf . writeInt ( promisedStreamId ) ; ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; ctx . write ( fragment , promiseAggregator . newPromise ( ) ) ; if ( padding > <int> ) { ctx . write ( ZERO_BUFFER . slice ( <int> , padding ) , promiseAggregator . newPromise ( ) ) ; } if ( ! flags . endOfHeaders ( ) ) { writeContinuationFrames ( ctx , streamId , headerBlock , padding , promiseAggregator ) ; } return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { return promiseAggregator . setFailure ( t ) ; } finally { if ( headerBlock ! = null ) { headerBlock . release ( ) ; } } } @Override public ChannelFuture writeGoAway ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData , ChannelPromise promise ) { boolean releaseData = true ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { verifyStreamOrConnectionId ( lastStreamId , <str> ) ; verifyErrorCode ( errorCode ) ; int payloadLength = <int> + debugData . readableBytes ( ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( GO_AWAY_FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , GO_AWAY , new Http2Flags ( ) , <int> ) ; buf . writeInt ( lastStreamId ) ; writeUnsignedInt ( errorCode , buf ) ; ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; releaseData = false ; ctx . write ( debugData , promiseAggregator . newPromise ( ) ) ; return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { if ( releaseData ) { debugData . release ( ) ; } return promiseAggregator . setFailure ( t ) ; } } @Override public ChannelFuture writeWindowUpdate ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement , ChannelPromise promise ) { try { verifyStreamOrConnectionId ( streamId , STREAM_ID ) ; verifyWindowSizeIncrement ( windowSizeIncrement ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( WINDOW_UPDATE_FRAME_LENGTH ) ; writeFrameHeaderInternal ( buf , INT_FIELD_LENGTH , WINDOW_UPDATE , new Http2Flags ( ) , streamId ) ; buf . writeInt ( windowSizeIncrement ) ; return ctx . write ( buf , promise ) ; } catch ( Throwable t ) { return promise . setFailure ( t ) ; } } @Override public ChannelFuture writeFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload , ChannelPromise promise ) { boolean releaseData = true ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { verifyStreamOrConnectionId ( streamId , STREAM_ID ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payload . readableBytes ( ) , frameType , flags , streamId ) ; ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; releaseData = false ; ctx . write ( payload , promiseAggregator . newPromise ( ) ) ; return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { if ( releaseData ) { payload . release ( ) ; } return promiseAggregator . setFailure ( t ) ; } } private ChannelFuture writeHeadersInternal ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream , boolean hasPriority , int streamDependency , short weight , boolean exclusive , ChannelPromise promise ) { ByteBuf headerBlock = null ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { verifyStreamId ( streamId , STREAM_ID ) ; if ( hasPriority ) { verifyStreamOrConnectionId ( streamDependency , STREAM_DEPENDENCY ) ; verifyPadding ( padding ) ; verifyWeight ( weight ) ; } headerBlock = ctx . alloc ( ) . buffer ( ) ; headersEncoder . encodeHeaders ( headers , headerBlock ) ; Http2Flags flags = new Http2Flags ( ) . endOfStream ( endStream ) . priorityPresent ( hasPriority ) . paddingPresent ( padding > <int> ) ; int nonFragmentBytes = padding + flags . getNumPriorityBytes ( ) + flags . getPaddingPresenceFieldLength ( ) ; int maxFragmentLength = maxFrameSize - nonFragmentBytes ; ByteBuf fragment = headerBlock . readSlice ( min ( headerBlock . readableBytes ( ) , maxFragmentLength ) ) . retain ( ) ; flags . endOfHeaders ( ! headerBlock . isReadable ( ) ) ; int payloadLength = fragment . readableBytes ( ) + nonFragmentBytes ; ByteBuf buf = ctx . alloc ( ) . buffer ( HEADERS_FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , HEADERS , flags , streamId ) ; writePaddingLength ( buf , padding ) ; if ( hasPriority ) { long word1 = exclusive ? <hex> | streamDependency : streamDependency ; writeUnsignedInt ( word1 , buf ) ; buf . writeByte ( weight - <int> ) ; } ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; ctx . write ( fragment , promiseAggregator . newPromise ( ) ) ; if ( padding > <int> ) { ctx . write ( ZERO_BUFFER . slice ( <int> , padding ) , promiseAggregator . newPromise ( ) ) ; } if ( ! flags . endOfHeaders ( ) ) { writeContinuationFrames ( ctx , streamId , headerBlock , padding , promiseAggregator ) ; } return promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { return promiseAggregator . setFailure ( t ) ; } finally { if ( headerBlock ! = null ) { headerBlock . release ( ) ; } } } private ChannelFuture writeContinuationFrames ( ChannelHandlerContext ctx , int streamId , ByteBuf headerBlock , int padding , SimpleChannelPromiseAggregator promiseAggregator ) { Http2Flags flags = new Http2Flags ( ) . paddingPresent ( padding > <int> ) ; int nonFragmentLength = padding + flags . getPaddingPresenceFieldLength ( ) ; int maxFragmentLength = maxFrameSize - nonFragmentLength ; if ( maxFragmentLength < = <int> ) { return promiseAggregator . setFailure ( new IllegalArgumentException ( <str> + padding + <str> + maxFrameSize + <str> ) ) ; } if ( headerBlock . isReadable ( ) ) { int fragmentReadableBytes = min ( headerBlock . readableBytes ( ) , maxFragmentLength ) ; int payloadLength = fragmentReadableBytes + nonFragmentLength ; ByteBuf buf = ctx . alloc ( ) . buffer ( CONTINUATION_FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , CONTINUATION , flags , streamId ) ; writePaddingLength ( buf , padding ) ; do { fragmentReadableBytes = min ( headerBlock . readableBytes ( ) , maxFragmentLength ) ; ByteBuf fragment = headerBlock . readSlice ( fragmentReadableBytes ) . retain ( ) ; payloadLength = fragmentReadableBytes + nonFragmentLength ; if ( headerBlock . isReadable ( ) ) { ctx . write ( buf . retain ( ) , promiseAggregator . newPromise ( ) ) ; } else { flags = flags . endOfHeaders ( true ) ; buf . release ( ) ; buf = ctx . alloc ( ) . buffer ( CONTINUATION_FRAME_HEADER_LENGTH ) ; writeFrameHeaderInternal ( buf , payloadLength , CONTINUATION , flags , streamId ) ; writePaddingLength ( buf , padding ) ; ctx . write ( buf , promiseAggregator . newPromise ( ) ) ; } ctx . write ( fragment , promiseAggregator . newPromise ( ) ) ; if ( padding > <int> ) { ctx . write ( ZERO_BUFFER . slice ( <int> , padding ) , promiseAggregator . newPromise ( ) ) ; } } while ( headerBlock . isReadable ( ) ) ; } return promiseAggregator ; } private static void writePaddingLength ( ByteBuf buf , int paddingLength ) { if ( paddingLength > <int> ) { buf . writeByte ( paddingLength ) ; } } private static void verifyStreamId ( int streamId , String argumentName ) { if ( streamId < = <int> ) { throw new IllegalArgumentException ( argumentName + <str> ) ; } } private static void verifyStreamOrConnectionId ( int streamId , String argumentName ) { if ( streamId < <int> ) { throw new IllegalArgumentException ( argumentName + <str> ) ; } } private static void verifyPadding ( int padding ) { if ( padding < <int> | | padding > MAX_UNSIGNED_BYTE ) { throw new IllegalArgumentException ( <str> + padding ) ; } } private static void verifyWeight ( short weight ) { if ( weight < MIN_WEIGHT | | weight > MAX_WEIGHT ) { throw new IllegalArgumentException ( <str> + weight ) ; } } private static void verifyErrorCode ( long errorCode ) { if ( errorCode < <int> | | errorCode > MAX_UNSIGNED_INT ) { throw new IllegalArgumentException ( <str> + errorCode ) ; } } private static void verifyWindowSizeIncrement ( int windowSizeIncrement ) { if ( windowSizeIncrement < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } private static void verifyPingPayload ( ByteBuf data ) { if ( data = = null | | data . readableBytes ( ) ! = PING_FRAME_PAYLOAD_LENGTH ) { throw new IllegalArgumentException ( <str> + PING_FRAME_PAYLOAD_LENGTH + <str> ) ; } } private static final class DataFrameHeader { private final int streamId ; private final ByteBuf buffer ; private final Http2Flags flags = new Http2Flags ( ) ; private int prevData ; private int prevPadding ; private ByteBuf frameHeader ; DataFrameHeader ( ChannelHandlerContext ctx , int streamId ) { buffer = ctx . alloc ( ) . buffer ( <int> * DATA_FRAME_HEADER_LENGTH ) ; this . streamId = streamId ; } ByteBuf slice ( int data , int padding , boolean endOfStream ) { if ( data ! = prevData | | padding ! = prevPadding | | endOfStream ! = flags . endOfStream ( ) | | frameHeader = = null ) { prevData = data ; prevPadding = padding ; flags . paddingPresent ( padding > <int> ) ; flags . endOfStream ( endOfStream ) ; frameHeader = buffer . readSlice ( DATA_FRAME_HEADER_LENGTH ) . writerIndex ( <int> ) ; int payloadLength = data + padding + flags . getPaddingPresenceFieldLength ( ) ; writeFrameHeaderInternal ( frameHeader , payloadLength , DATA , flags , streamId ) ; writePaddingLength ( frameHeader , padding ) ; } return frameHeader . slice ( ) ; } void release ( ) { buffer . release ( ) ; } } } 
