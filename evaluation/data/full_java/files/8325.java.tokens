package org . elasticsearch . indices . analysis ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . elasticsearch . Version ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESBackcompatTestCase ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . SUITE ) @ESBackcompatTestCase.CompatibilityVersion ( version = Version . V_1_2_0_ID ) public class PreBuiltAnalyzerIntegrationIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( DummyAnalysisPlugin . class ) ; } public void testThatPreBuiltAnalyzersAreNotClosedOnIndexClose ( ) throws Exception { Map < PreBuiltAnalyzers , List < Version > > loadedAnalyzers = new HashMap < > ( ) ; List < String > indexNames = new ArrayList < > ( ) ; final int numIndices = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIndices ; i + + ) { String indexName = randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . ROOT ) ; indexNames . add ( indexName ) ; int randomInt = randomInt ( PreBuiltAnalyzers . values ( ) . length - <int> ) ; PreBuiltAnalyzers preBuiltAnalyzer = PreBuiltAnalyzers . values ( ) [ randomInt ] ; String name = preBuiltAnalyzer . name ( ) . toLowerCase ( Locale . ROOT ) ; Version randomVersion = randomVersion ( random ( ) ) ; if ( ! loadedAnalyzers . containsKey ( preBuiltAnalyzer ) ) { loadedAnalyzers . put ( preBuiltAnalyzer , new ArrayList < Version > ( ) ) ; } loadedAnalyzers . get ( preBuiltAnalyzer ) . add ( randomVersion ) ; final XContentBuilder mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , name ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; Settings versionSettings = settings ( randomVersion ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( indexName ) . addMapping ( <str> , mapping ) . setSettings ( versionSettings ) . get ( ) ; } ensureGreen ( ) ; final int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String randomIndex = indexNames . get ( randomInt ( indexNames . size ( ) - <int> ) ) ; String randomId = randomInt ( ) + <str> ; Map < String , Object > data = new HashMap < > ( ) ; data . put ( <str> , randomAsciiOfLength ( scaledRandomIntBetween ( <int> , <int> ) ) ) ; index ( randomIndex , <str> , randomId , data ) ; } refresh ( ) ; int amountOfIndicesToClose = randomInt ( numIndices - <int> ) ; for ( int i = <int> ; i < amountOfIndicesToClose ; i + + ) { String indexName = indexNames . get ( i ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( indexName ) . execute ( ) . actionGet ( ) ; } ensureGreen ( ) ; assertThatAnalyzersHaveBeenLoaded ( loadedAnalyzers ) ; assertLuceneAnalyzersAreNotClosed ( loadedAnalyzers ) ; } public void testThatPluginAnalyzersCanBeUpdated ( ) throws Exception { final XContentBuilder mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; Settings versionSettings = settings ( randomVersion ( random ( ) ) ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , mapping ) . setSettings ( versionSettings ) . get ( ) ; ensureGreen ( ) ; } private void assertThatAnalyzersHaveBeenLoaded ( Map < PreBuiltAnalyzers , List < Version > > expectedLoadedAnalyzers ) { for ( Map . Entry < PreBuiltAnalyzers , List < Version > > entry : expectedLoadedAnalyzers . entrySet ( ) ) { for ( Version version : entry . getValue ( ) ) { assertThat ( entry . getKey ( ) . getCache ( ) . get ( version ) , is ( notNullValue ( ) ) ) ; } } } private void assertLuceneAnalyzersAreNotClosed ( Map < PreBuiltAnalyzers , List < Version > > loadedAnalyzers ) throws IOException { for ( Map . Entry < PreBuiltAnalyzers , List < Version > > preBuiltAnalyzerEntry : loadedAnalyzers . entrySet ( ) ) { for ( Version version : preBuiltAnalyzerEntry . getValue ( ) ) { Analyzer analyzer = preBuiltAnalyzerEntry . getKey ( ) . getCache ( ) . get ( version ) ; try ( TokenStream stream = analyzer . tokenStream ( <str> , <str> ) ) { stream . reset ( ) ; while ( stream . incrementToken ( ) ) { } stream . end ( ) ; } } } } } 
