package org . gradle . launcher . daemon . server . exec ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . launcher . daemon . diagnostics . DaemonDiagnostics ; import org . gradle . launcher . daemon . protocol . Build ; import org . gradle . launcher . daemon . protocol . BuildStarted ; import org . gradle . launcher . daemon . protocol . DaemonUnavailable ; import org . gradle . launcher . daemon . protocol . Failure ; import org . gradle . launcher . daemon . server . api . DaemonCommandExecution ; import org . gradle . launcher . daemon . server . api . DaemonStateControl ; import org . gradle . launcher . daemon . server . api . DaemonStoppedException ; import org . gradle . launcher . daemon . server . api . DaemonUnavailableException ; public class StartBuildOrRespondWithBusy extends BuildCommandOnly { private static final Logger LOGGER = Logging . getLogger ( StartBuildOrRespondWithBusy . class ) ; private final DaemonDiagnostics diagnostics ; public StartBuildOrRespondWithBusy ( DaemonDiagnostics diagnostics ) { this . diagnostics = diagnostics ; } protected void doBuild ( final DaemonCommandExecution execution , final Build build ) { DaemonStateControl stateCoordinator = execution . getDaemonStateControl ( ) ; try { Runnable command = new Runnable ( ) { public void run ( ) { LOGGER . info ( <str> , build ) ; execution . getConnection ( ) . buildStarted ( new BuildStarted ( diagnostics ) ) ; execution . proceed ( ) ; } } ; stateCoordinator . runCommand ( command , execution . toString ( ) ) ; } catch ( DaemonUnavailableException e ) { LOGGER . info ( <str> , build , e . getMessage ( ) ) ; execution . getConnection ( ) . daemonUnavailable ( new DaemonUnavailable ( e . getMessage ( ) ) ) ; } catch ( DaemonStoppedException e ) { execution . getConnection ( ) . completed ( new Failure ( e ) ) ; } } } 
