package org . elasticsearch . search ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . apache . lucene . index . * ; import org . apache . lucene . util . BitSetIterator ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . FixedBitSet ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . index . fielddata . FieldData ; import org . elasticsearch . index . fielddata . NumericDoubleValues ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . Arrays ; import static org . hamcrest . Matchers . equalTo ; public class MultiValueModeTests extends ESTestCase { private static FixedBitSet randomRootDocs ( int maxDoc ) { FixedBitSet set = new FixedBitSet ( maxDoc ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { if ( randomBoolean ( ) ) { set . set ( i ) ; } } set . set ( maxDoc - <int> ) ; return set ; } private static FixedBitSet randomInnerDocs ( FixedBitSet rootDocs ) { FixedBitSet innerDocs = new FixedBitSet ( rootDocs . length ( ) ) ; for ( int i = <int> ; i < innerDocs . length ( ) ; + + i ) { if ( ! rootDocs . get ( i ) & & randomBoolean ( ) ) { innerDocs . set ( i ) ; } } return innerDocs ; } public void testSingleValuedLongs ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final long [ ] array = new long [ numDocs ] ; final FixedBitSet docsWithValue = randomBoolean ( ) ? null : new FixedBitSet ( numDocs ) ; for ( int i = <int> ; i < array . length ; + + i ) { if ( randomBoolean ( ) ) { array [ i ] = randomLong ( ) ; if ( docsWithValue ! = null ) { docsWithValue . set ( i ) ; } } else if ( docsWithValue ! = null & & randomBoolean ( ) ) { docsWithValue . set ( i ) ; } } final NumericDocValues singleValues = new NumericDocValues ( ) { @Override public long get ( int docID ) { return array [ docID ] ; } } ; final SortedNumericDocValues multiValues = DocValues . singleton ( singleValues , docsWithValue ) ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } public void testMultiValuedLongs ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final long [ ] [ ] array = new long [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final long [ ] values = new long [ randomInt ( <int> ) ] ; for ( int j = <int> ; j < values . length ; + + j ) { values [ j ] = randomLong ( ) ; } Arrays . sort ( values ) ; array [ i ] = values ; } final SortedNumericDocValues multiValues = new SortedNumericDocValues ( ) { int doc ; @Override public long valueAt ( int index ) { return array [ doc ] [ index ] ; } @Override public void setDocument ( int doc ) { this . doc = doc ; } @Override public int count ( ) { return array [ doc ] . length ; } } ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } private void verify ( SortedNumericDocValues values , int maxDoc ) { for ( long missingValue : new long [ ] { <int> , randomLong ( ) } ) { for ( MultiValueMode mode : MultiValueMode . values ( ) ) { final NumericDocValues selected = mode . select ( values , missingValue ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { final long actual = selected . get ( i ) ; long expected = <int> ; values . setDocument ( i ) ; int numValues = values . count ( ) ; if ( numValues = = <int> ) { expected = missingValue ; } else { if ( mode = = MultiValueMode . MAX ) { expected = Long . MIN_VALUE ; } else if ( mode = = MultiValueMode . MIN ) { expected = Long . MAX_VALUE ; } for ( int j = <int> ; j < numValues ; + + j ) { if ( mode = = MultiValueMode . SUM | | mode = = MultiValueMode . AVG ) { expected + = values . valueAt ( j ) ; } else if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , values . valueAt ( j ) ) ; } } if ( mode = = MultiValueMode . AVG ) { expected = numValues > <int> ? Math . round ( ( double ) expected / ( double ) numValues ) : expected ; } else if ( mode = = MultiValueMode . MEDIAN ) { int value = numValues / <int> ; if ( numValues % <int> = = <int> ) { expected = Math . round ( ( values . valueAt ( value - <int> ) + values . valueAt ( value ) ) / <float> ) ; } else { expected = values . valueAt ( value ) ; } } } assertEquals ( mode . toString ( ) + <str> + i , expected , actual ) ; } } } } private void verify ( SortedNumericDocValues values , int maxDoc , FixedBitSet rootDocs , FixedBitSet innerDocs ) throws IOException { for ( long missingValue : new long [ ] { <int> , randomLong ( ) } ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX , MultiValueMode . SUM , MultiValueMode . AVG } ) { final NumericDocValues selected = mode . select ( values , missingValue , rootDocs , new BitSetIterator ( innerDocs , <int> L ) , maxDoc ) ; int prevRoot = - <int> ; for ( int root = rootDocs . nextSetBit ( <int> ) ; root ! = - <int> ; root = root + <int> < maxDoc ? rootDocs . nextSetBit ( root + <int> ) : - <int> ) { final long actual = selected . get ( root ) ; long expected = <int> ; if ( mode = = MultiValueMode . MAX ) { expected = Long . MIN_VALUE ; } else if ( mode = = MultiValueMode . MIN ) { expected = Long . MAX_VALUE ; } int numValues = <int> ; for ( int child = innerDocs . nextSetBit ( prevRoot + <int> ) ; child ! = - <int> & & child < root ; child = innerDocs . nextSetBit ( child + <int> ) ) { values . setDocument ( child ) ; for ( int j = <int> ; j < values . count ( ) ; + + j ) { if ( mode = = MultiValueMode . SUM | | mode = = MultiValueMode . AVG ) { expected + = values . valueAt ( j ) ; } else if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , values . valueAt ( j ) ) ; } + + numValues ; } } if ( numValues = = <int> ) { expected = missingValue ; } else if ( mode = = MultiValueMode . AVG ) { expected = numValues > <int> ? Math . round ( ( double ) expected / ( double ) numValues ) : expected ; } assertEquals ( mode . toString ( ) + <str> + root , expected , actual ) ; prevRoot = root ; } } } } public void testSingleValuedDoubles ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final double [ ] array = new double [ numDocs ] ; final FixedBitSet docsWithValue = randomBoolean ( ) ? null : new FixedBitSet ( numDocs ) ; for ( int i = <int> ; i < array . length ; + + i ) { if ( randomBoolean ( ) ) { array [ i ] = randomDouble ( ) ; if ( docsWithValue ! = null ) { docsWithValue . set ( i ) ; } } else if ( docsWithValue ! = null & & randomBoolean ( ) ) { docsWithValue . set ( i ) ; } } final NumericDoubleValues singleValues = new NumericDoubleValues ( ) { @Override public double get ( int docID ) { return array [ docID ] ; } } ; final SortedNumericDoubleValues multiValues = FieldData . singleton ( singleValues , docsWithValue ) ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } public void testMultiValuedDoubles ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final double [ ] [ ] array = new double [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final double [ ] values = new double [ randomInt ( <int> ) ] ; for ( int j = <int> ; j < values . length ; + + j ) { values [ j ] = randomDouble ( ) ; } Arrays . sort ( values ) ; array [ i ] = values ; } final SortedNumericDoubleValues multiValues = new SortedNumericDoubleValues ( ) { int doc ; @Override public double valueAt ( int index ) { return array [ doc ] [ index ] ; } @Override public void setDocument ( int doc ) { this . doc = doc ; } @Override public int count ( ) { return array [ doc ] . length ; } } ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } private void verify ( SortedNumericDoubleValues values , int maxDoc ) { for ( long missingValue : new long [ ] { <int> , randomLong ( ) } ) { for ( MultiValueMode mode : MultiValueMode . values ( ) ) { if ( MultiValueMode . MEDIAN . equals ( mode ) ) { continue ; } final NumericDoubleValues selected = mode . select ( values , missingValue ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { final double actual = selected . get ( i ) ; double expected = <float> ; values . setDocument ( i ) ; int numValues = values . count ( ) ; if ( numValues = = <int> ) { expected = missingValue ; } else { if ( mode = = MultiValueMode . MAX ) { expected = Long . MIN_VALUE ; } else if ( mode = = MultiValueMode . MIN ) { expected = Long . MAX_VALUE ; } for ( int j = <int> ; j < numValues ; + + j ) { if ( mode = = MultiValueMode . SUM | | mode = = MultiValueMode . AVG ) { expected + = values . valueAt ( j ) ; } else if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , values . valueAt ( j ) ) ; } } if ( mode = = MultiValueMode . AVG ) { expected = expected / numValues ; } else if ( mode = = MultiValueMode . MEDIAN ) { int value = numValues / <int> ; if ( numValues % <int> = = <int> ) { expected = ( values . valueAt ( value - <int> ) + values . valueAt ( value ) ) / <float> ; } else { expected = values . valueAt ( value ) ; } } } assertEquals ( mode . toString ( ) + <str> + i , expected , actual , <float> ) ; } } } } private void verify ( SortedNumericDoubleValues values , int maxDoc , FixedBitSet rootDocs , FixedBitSet innerDocs ) throws IOException { for ( long missingValue : new long [ ] { <int> , randomLong ( ) } ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX , MultiValueMode . SUM , MultiValueMode . AVG } ) { final NumericDoubleValues selected = mode . select ( values , missingValue , rootDocs , new BitSetIterator ( innerDocs , <int> L ) , maxDoc ) ; int prevRoot = - <int> ; for ( int root = rootDocs . nextSetBit ( <int> ) ; root ! = - <int> ; root = root + <int> < maxDoc ? rootDocs . nextSetBit ( root + <int> ) : - <int> ) { final double actual = selected . get ( root ) ; double expected = <float> ; if ( mode = = MultiValueMode . MAX ) { expected = Long . MIN_VALUE ; } else if ( mode = = MultiValueMode . MIN ) { expected = Long . MAX_VALUE ; } int numValues = <int> ; for ( int child = innerDocs . nextSetBit ( prevRoot + <int> ) ; child ! = - <int> & & child < root ; child = innerDocs . nextSetBit ( child + <int> ) ) { values . setDocument ( child ) ; for ( int j = <int> ; j < values . count ( ) ; + + j ) { if ( mode = = MultiValueMode . SUM | | mode = = MultiValueMode . AVG ) { expected + = values . valueAt ( j ) ; } else if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , values . valueAt ( j ) ) ; } + + numValues ; } } if ( numValues = = <int> ) { expected = missingValue ; } else if ( mode = = MultiValueMode . AVG ) { expected = expected / numValues ; } assertEquals ( mode . toString ( ) + <str> + root , expected , actual , <float> ) ; prevRoot = root ; } } } } public void testSingleValuedStrings ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final BytesRef [ ] array = new BytesRef [ numDocs ] ; final FixedBitSet docsWithValue = randomBoolean ( ) ? null : new FixedBitSet ( numDocs ) ; for ( int i = <int> ; i < array . length ; + + i ) { if ( randomBoolean ( ) ) { array [ i ] = new BytesRef ( RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) ) ; if ( docsWithValue ! = null ) { docsWithValue . set ( i ) ; } } else { array [ i ] = new BytesRef ( ) ; if ( docsWithValue ! = null & & randomBoolean ( ) ) { docsWithValue . set ( i ) ; } } } final BinaryDocValues singleValues = new BinaryDocValues ( ) { @Override public BytesRef get ( int docID ) { return BytesRef . deepCopyOf ( array [ docID ] ) ; } } ; final SortedBinaryDocValues multiValues = FieldData . singleton ( singleValues , docsWithValue ) ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } public void testMultiValuedStrings ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final BytesRef [ ] [ ] array = new BytesRef [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final BytesRef [ ] values = new BytesRef [ randomInt ( <int> ) ] ; for ( int j = <int> ; j < values . length ; + + j ) { values [ j ] = new BytesRef ( RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) ) ; } Arrays . sort ( values ) ; array [ i ] = values ; } final SortedBinaryDocValues multiValues = new SortedBinaryDocValues ( ) { int doc ; @Override public BytesRef valueAt ( int index ) { return BytesRef . deepCopyOf ( array [ doc ] [ index ] ) ; } @Override public void setDocument ( int doc ) { this . doc = doc ; } @Override public int count ( ) { return array [ doc ] . length ; } } ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } private void verify ( SortedBinaryDocValues values , int maxDoc ) { for ( BytesRef missingValue : new BytesRef [ ] { new BytesRef ( ) , new BytesRef ( RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) ) } ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX } ) { final BinaryDocValues selected = mode . select ( values , missingValue ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { final BytesRef actual = selected . get ( i ) ; BytesRef expected = null ; values . setDocument ( i ) ; int numValues = values . count ( ) ; if ( numValues = = <int> ) { expected = missingValue ; } else { for ( int j = <int> ; j < numValues ; + + j ) { if ( expected = = null ) { expected = BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } else { if ( mode = = MultiValueMode . MIN ) { expected = expected . compareTo ( values . valueAt ( j ) ) < = <int> ? expected : BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = expected . compareTo ( values . valueAt ( j ) ) > <int> ? expected : BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } } } if ( expected = = null ) { expected = missingValue ; } } assertEquals ( mode . toString ( ) + <str> + i , expected , actual ) ; } } } } private void verify ( SortedBinaryDocValues values , int maxDoc , FixedBitSet rootDocs , FixedBitSet innerDocs ) throws IOException { for ( BytesRef missingValue : new BytesRef [ ] { new BytesRef ( ) , new BytesRef ( RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) ) } ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX } ) { final BinaryDocValues selected = mode . select ( values , missingValue , rootDocs , new BitSetIterator ( innerDocs , <int> L ) , maxDoc ) ; int prevRoot = - <int> ; for ( int root = rootDocs . nextSetBit ( <int> ) ; root ! = - <int> ; root = root + <int> < maxDoc ? rootDocs . nextSetBit ( root + <int> ) : - <int> ) { final BytesRef actual = selected . get ( root ) ; BytesRef expected = null ; for ( int child = innerDocs . nextSetBit ( prevRoot + <int> ) ; child ! = - <int> & & child < root ; child = innerDocs . nextSetBit ( child + <int> ) ) { values . setDocument ( child ) ; for ( int j = <int> ; j < values . count ( ) ; + + j ) { if ( expected = = null ) { expected = BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } else { if ( mode = = MultiValueMode . MIN ) { expected = expected . compareTo ( values . valueAt ( j ) ) < = <int> ? expected : BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = expected . compareTo ( values . valueAt ( j ) ) > <int> ? expected : BytesRef . deepCopyOf ( values . valueAt ( j ) ) ; } } } } if ( expected = = null ) { expected = missingValue ; } assertEquals ( mode . toString ( ) + <str> + root , expected , actual ) ; prevRoot = root ; } } } } public void testSingleValuedOrds ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final int [ ] array = new int [ numDocs ] ; for ( int i = <int> ; i < array . length ; + + i ) { if ( randomBoolean ( ) ) { array [ i ] = randomInt ( <int> ) ; } else { array [ i ] = - <int> ; } } final SortedDocValues singleValues = new SortedDocValues ( ) { @Override public int getOrd ( int docID ) { return array [ docID ] ; } @Override public BytesRef lookupOrd ( int ord ) { throw new UnsupportedOperationException ( ) ; } @Override public int getValueCount ( ) { return <int> < < <int> ; } } ; final RandomAccessOrds multiValues = ( RandomAccessOrds ) DocValues . singleton ( singleValues ) ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } public void testMultiValuedOrds ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final long [ ] [ ] array = new long [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final long [ ] values = new long [ randomInt ( <int> ) ] ; for ( int j = <int> ; j < values . length ; + + j ) { values [ j ] = j = = <int> ? randomInt ( <int> ) : values [ j - <int> ] + <int> + randomInt ( <int> ) ; } array [ i ] = values ; } final RandomAccessOrds multiValues = new RandomAccessOrds ( ) { int doc ; @Override public long ordAt ( int index ) { return array [ doc ] [ index ] ; } @Override public int cardinality ( ) { return array [ doc ] . length ; } @Override public long nextOrd ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void setDocument ( int docID ) { this . doc = docID ; } @Override public BytesRef lookupOrd ( long ord ) { throw new UnsupportedOperationException ( ) ; } @Override public long getValueCount ( ) { return <int> < < <int> ; } } ; verify ( multiValues , numDocs ) ; final FixedBitSet rootDocs = randomRootDocs ( numDocs ) ; final FixedBitSet innerDocs = randomInnerDocs ( rootDocs ) ; verify ( multiValues , numDocs , rootDocs , innerDocs ) ; } private void verify ( RandomAccessOrds values , int maxDoc ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX } ) { final SortedDocValues selected = mode . select ( values ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { final long actual = selected . getOrd ( i ) ; int expected = - <int> ; values . setDocument ( i ) ; for ( int j = <int> ; j < values . cardinality ( ) ; + + j ) { if ( expected = = - <int> ) { expected = ( int ) values . ordAt ( j ) ; } else { if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , ( int ) values . ordAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , ( int ) values . ordAt ( j ) ) ; } } } assertEquals ( mode . toString ( ) + <str> + i , expected , actual ) ; } } } private void verify ( RandomAccessOrds values , int maxDoc , FixedBitSet rootDocs , FixedBitSet innerDocs ) throws IOException { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX } ) { final SortedDocValues selected = mode . select ( values , rootDocs , new BitSetIterator ( innerDocs , <int> L ) ) ; int prevRoot = - <int> ; for ( int root = rootDocs . nextSetBit ( <int> ) ; root ! = - <int> ; root = root + <int> < maxDoc ? rootDocs . nextSetBit ( root + <int> ) : - <int> ) { final int actual = selected . getOrd ( root ) ; int expected = - <int> ; for ( int child = innerDocs . nextSetBit ( prevRoot + <int> ) ; child ! = - <int> & & child < root ; child = innerDocs . nextSetBit ( child + <int> ) ) { values . setDocument ( child ) ; for ( int j = <int> ; j < values . cardinality ( ) ; + + j ) { if ( expected = = - <int> ) { expected = ( int ) values . ordAt ( j ) ; } else { if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , ( int ) values . ordAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , ( int ) values . ordAt ( j ) ) ; } } } } assertEquals ( mode . toString ( ) + <str> + root , expected , actual ) ; prevRoot = root ; } } } public void testUnsortedSingleValuedDoubles ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final double [ ] array = new double [ numDocs ] ; final FixedBitSet docsWithValue = randomBoolean ( ) ? null : new FixedBitSet ( numDocs ) ; for ( int i = <int> ; i < array . length ; + + i ) { if ( randomBoolean ( ) ) { array [ i ] = randomDouble ( ) ; if ( docsWithValue ! = null ) { docsWithValue . set ( i ) ; } } else if ( docsWithValue ! = null & & randomBoolean ( ) ) { docsWithValue . set ( i ) ; } } final NumericDoubleValues singleValues = new NumericDoubleValues ( ) { @Override public double get ( int docID ) { return array [ docID ] ; } } ; final SortedNumericDoubleValues singletonValues = FieldData . singleton ( singleValues , docsWithValue ) ; final MultiValueMode . UnsortedNumericDoubleValues multiValues = new MultiValueMode . UnsortedNumericDoubleValues ( ) { @Override public int count ( ) { return singletonValues . count ( ) ; } @Override public void setDocument ( int doc ) { singletonValues . setDocument ( doc ) ; } @Override public double valueAt ( int index ) { return Math . cos ( singletonValues . valueAt ( index ) ) ; } } ; verify ( multiValues , numDocs ) ; } public void testUnsortedMultiValuedDoubles ( ) throws Exception { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final double [ ] [ ] array = new double [ numDocs ] [ ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final double [ ] values = new double [ randomInt ( <int> ) ] ; for ( int j = <int> ; j < values . length ; + + j ) { values [ j ] = randomDouble ( ) ; } Arrays . sort ( values ) ; array [ i ] = values ; } final MultiValueMode . UnsortedNumericDoubleValues multiValues = new MultiValueMode . UnsortedNumericDoubleValues ( ) { int doc ; @Override public int count ( ) { return array [ doc ] . length ; } @Override public void setDocument ( int doc ) { this . doc = doc ; } @Override public double valueAt ( int index ) { return Math . sin ( array [ doc ] [ index ] ) ; } } ; verify ( multiValues , numDocs ) ; } private void verify ( MultiValueMode . UnsortedNumericDoubleValues values , int maxDoc ) { for ( double missingValue : new double [ ] { <int> , randomDouble ( ) } ) { for ( MultiValueMode mode : new MultiValueMode [ ] { MultiValueMode . MIN , MultiValueMode . MAX , MultiValueMode . SUM , MultiValueMode . AVG } ) { final NumericDoubleValues selected = mode . select ( values , missingValue ) ; for ( int i = <int> ; i < maxDoc ; + + i ) { final double actual = selected . get ( i ) ; double expected = <float> ; values . setDocument ( i ) ; int numValues = values . count ( ) ; if ( numValues = = <int> ) { expected = missingValue ; } else { if ( mode = = MultiValueMode . MAX ) { expected = Long . MIN_VALUE ; } else if ( mode = = MultiValueMode . MIN ) { expected = Long . MAX_VALUE ; } for ( int j = <int> ; j < numValues ; + + j ) { if ( mode = = MultiValueMode . SUM | | mode = = MultiValueMode . AVG ) { expected + = values . valueAt ( j ) ; } else if ( mode = = MultiValueMode . MIN ) { expected = Math . min ( expected , values . valueAt ( j ) ) ; } else if ( mode = = MultiValueMode . MAX ) { expected = Math . max ( expected , values . valueAt ( j ) ) ; } } if ( mode = = MultiValueMode . AVG ) { expected = expected / numValues ; } } assertEquals ( mode . toString ( ) + <str> + i , expected , actual , <float> ) ; } } } } public void testValidOrdinals ( ) { assertThat ( MultiValueMode . SUM . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( MultiValueMode . AVG . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( MultiValueMode . MEDIAN . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( MultiValueMode . MIN . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( MultiValueMode . MAX . ordinal ( ) , equalTo ( <int> ) ) ; } public void testWriteTo ( ) throws Exception { try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { MultiValueMode . SUM . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { MultiValueMode . AVG . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { MultiValueMode . MEDIAN . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { MultiValueMode . MIN . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { MultiValueMode . MAX . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } } public void testReadFrom ( ) throws Exception { try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( MultiValueMode . readMultiValueModeFrom ( in ) , equalTo ( MultiValueMode . SUM ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( MultiValueMode . readMultiValueModeFrom ( in ) , equalTo ( MultiValueMode . AVG ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( MultiValueMode . readMultiValueModeFrom ( in ) , equalTo ( MultiValueMode . MEDIAN ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( MultiValueMode . readMultiValueModeFrom ( in ) , equalTo ( MultiValueMode . MIN ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( MultiValueMode . readMultiValueModeFrom ( in ) , equalTo ( MultiValueMode . MAX ) ) ; } } } public void testFromString ( ) { assertThat ( MultiValueMode . fromString ( <str> ) , equalTo ( MultiValueMode . SUM ) ) ; assertThat ( MultiValueMode . fromString ( <str> ) , equalTo ( MultiValueMode . AVG ) ) ; assertThat ( MultiValueMode . fromString ( <str> ) , equalTo ( MultiValueMode . MEDIAN ) ) ; assertThat ( MultiValueMode . fromString ( <str> ) , equalTo ( MultiValueMode . MIN ) ) ; assertThat ( MultiValueMode . fromString ( <str> ) , equalTo ( MultiValueMode . MAX ) ) ; } } 
