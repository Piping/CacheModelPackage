package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseNotifier ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . concurrent . EventExecutor ; import net . jpountz . lz4 . LZ4Compressor ; import net . jpountz . lz4 . LZ4Exception ; import net . jpountz . lz4 . LZ4Factory ; import net . jpountz . xxhash . XXHashFactory ; import java . util . concurrent . TimeUnit ; import java . util . zip . Checksum ; import static io . netty . handler . codec . compression . Lz4Constants . * ; public class Lz4FrameEncoder extends MessageToByteEncoder < ByteBuf > { private LZ4Compressor compressor ; private Checksum checksum ; private final int compressionLevel ; private byte [ ] buffer ; private int currentBlockLength ; private final int compressedBlockSize ; private volatile boolean finished ; private volatile ChannelHandlerContext ctx ; public Lz4FrameEncoder ( ) { this ( false ) ; } public Lz4FrameEncoder ( boolean highCompressor ) { this ( LZ4Factory . fastestInstance ( ) , highCompressor , DEFAULT_BLOCK_SIZE , XXHashFactory . fastestInstance ( ) . newStreamingHash32 ( DEFAULT_SEED ) . asChecksum ( ) ) ; } public Lz4FrameEncoder ( LZ4Factory factory , boolean highCompressor , int blockSize , Checksum checksum ) { super ( false ) ; if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } if ( checksum = = null ) { throw new NullPointerException ( <str> ) ; } compressor = highCompressor ? factory . highCompressor ( ) : factory . fastCompressor ( ) ; this . checksum = checksum ; compressionLevel = compressionLevel ( blockSize ) ; buffer = new byte [ blockSize ] ; currentBlockLength = <int> ; compressedBlockSize = HEADER_LENGTH + compressor . maxCompressedLength ( blockSize ) ; finished = false ; } private static int compressionLevel ( int blockSize ) { if ( blockSize < MIN_BLOCK_SIZE | | blockSize > MAX_BLOCK_SIZE ) { throw new IllegalArgumentException ( String . format ( <str> , blockSize , MIN_BLOCK_SIZE , MAX_BLOCK_SIZE ) ) ; } int compressionLevel = <int> - Integer . numberOfLeadingZeros ( blockSize - <int> ) ; compressionLevel = Math . max ( <int> , compressionLevel - COMPRESSION_LEVEL_BASE ) ; return compressionLevel ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { if ( finished ) { out . writeBytes ( in ) ; return ; } int length = in . readableBytes ( ) ; final byte [ ] buffer = this . buffer ; final int blockSize = buffer . length ; while ( currentBlockLength + length > = blockSize ) { final int tail = blockSize - currentBlockLength ; in . getBytes ( in . readerIndex ( ) , buffer , currentBlockLength , tail ) ; currentBlockLength = blockSize ; flushBufferedData ( out ) ; in . skipBytes ( tail ) ; length - = tail ; } in . readBytes ( buffer , currentBlockLength , length ) ; currentBlockLength + = length ; } private void flushBufferedData ( ByteBuf out ) { int currentBlockLength = this . currentBlockLength ; if ( currentBlockLength = = <int> ) { return ; } checksum . reset ( ) ; checksum . update ( buffer , <int> , currentBlockLength ) ; final int check = ( int ) checksum . getValue ( ) ; out . ensureWritable ( compressedBlockSize ) ; final int idx = out . writerIndex ( ) ; final byte [ ] dest = out . array ( ) ; final int destOff = out . arrayOffset ( ) + idx ; int compressedLength ; try { compressedLength = compressor . compress ( buffer , <int> , currentBlockLength , dest , destOff + HEADER_LENGTH ) ; } catch ( LZ4Exception e ) { throw new CompressionException ( e ) ; } final int blockType ; if ( compressedLength > = currentBlockLength ) { blockType = BLOCK_TYPE_NON_COMPRESSED ; compressedLength = currentBlockLength ; System . arraycopy ( buffer , <int> , dest , destOff + HEADER_LENGTH , currentBlockLength ) ; } else { blockType = BLOCK_TYPE_COMPRESSED ; } out . setLong ( idx , MAGIC_NUMBER ) ; dest [ destOff + TOKEN_OFFSET ] = ( byte ) ( blockType | compressionLevel ) ; writeIntLE ( compressedLength , dest , destOff + COMPRESSED_LENGTH_OFFSET ) ; writeIntLE ( currentBlockLength , dest , destOff + DECOMPRESSED_LENGTH_OFFSET ) ; writeIntLE ( check , dest , destOff + CHECKSUM_OFFSET ) ; out . writerIndex ( idx + HEADER_LENGTH + compressedLength ) ; currentBlockLength = <int> ; this . currentBlockLength = currentBlockLength ; } private ChannelFuture finishEncode ( final ChannelHandlerContext ctx , ChannelPromise promise ) { if ( finished ) { promise . setSuccess ( ) ; return promise ; } finished = true ; final ByteBuf footer = ctx . alloc ( ) . heapBuffer ( compressor . maxCompressedLength ( currentBlockLength ) + HEADER_LENGTH ) ; flushBufferedData ( footer ) ; final int idx = footer . writerIndex ( ) ; final byte [ ] dest = footer . array ( ) ; final int destOff = footer . arrayOffset ( ) + idx ; footer . setLong ( idx , MAGIC_NUMBER ) ; dest [ destOff + TOKEN_OFFSET ] = ( byte ) ( BLOCK_TYPE_NON_COMPRESSED | compressionLevel ) ; writeIntLE ( <int> , dest , destOff + COMPRESSED_LENGTH_OFFSET ) ; writeIntLE ( <int> , dest , destOff + DECOMPRESSED_LENGTH_OFFSET ) ; writeIntLE ( <int> , dest , destOff + CHECKSUM_OFFSET ) ; footer . writerIndex ( idx + HEADER_LENGTH ) ; compressor = null ; checksum = null ; buffer = null ; return ctx . writeAndFlush ( footer , promise ) ; } private static void writeIntLE ( int i , byte [ ] buf , int off ) { buf [ off + + ] = ( byte ) i ; buf [ off + + ] = ( byte ) ( i > > > <int> ) ; buf [ off + + ] = ( byte ) ( i > > > <int> ) ; buf [ off ] = ( byte ) ( i > > > <int> ) ; } public boolean isClosed ( ) { return finished ; } public ChannelFuture close ( ) { return close ( ctx ( ) . newPromise ( ) ) ; } public ChannelFuture close ( final ChannelPromise promise ) { ChannelHandlerContext ctx = ctx ( ) ; EventExecutor executor = ctx . executor ( ) ; if ( executor . inEventLoop ( ) ) { return finishEncode ( ctx , promise ) ; } else { executor . execute ( new Runnable ( ) { @Override public void run ( ) { ChannelFuture f = finishEncode ( ctx ( ) , promise ) ; f . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } ) ; return promise ; } } @Override public void close ( final ChannelHandlerContext ctx , final ChannelPromise promise ) throws Exception { ChannelFuture f = finishEncode ( ctx , ctx . newPromise ( ) ) ; f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture f ) throws Exception { ctx . close ( promise ) ; } } ) ; if ( ! f . isDone ( ) ) { ctx . executor ( ) . schedule ( new Runnable ( ) { @Override public void run ( ) { ctx . close ( promise ) ; } } , <int> , TimeUnit . SECONDS ) ; } } private ChannelHandlerContext ctx ( ) { ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( <str> ) ; } return ctx ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; } } 
