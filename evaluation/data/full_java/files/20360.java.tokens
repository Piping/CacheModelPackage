package io . netty . channel . epoll ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . CompositeByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ConnectTimeoutException ; import io . netty . channel . DefaultFileRegion ; import io . netty . channel . EventLoop ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . unix . FileDescriptor ; import io . netty . channel . unix . Socket ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . MpscLinkedQueueNode ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . net . SocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . ClosedChannelException ; import java . util . Queue ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import static io . netty . channel . unix . FileDescriptor . pipe ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public abstract class AbstractEpollStreamChannel extends AbstractEpollChannel { private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( DefaultFileRegion . class ) + <str> ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractEpollStreamChannel . class ) ; static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException ( ) ; static { CLOSED_CHANNEL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private ChannelPromise connectPromise ; private ScheduledFuture < ? > connectTimeoutFuture ; private SocketAddress requestedRemoteAddress ; private Queue < SpliceInTask > spliceQueue ; private FileDescriptor pipeIn ; private FileDescriptor pipeOut ; @Deprecated protected AbstractEpollStreamChannel ( Channel parent , int fd ) { this ( parent , new Socket ( fd ) ) ; } @Deprecated protected AbstractEpollStreamChannel ( int fd ) { this ( new Socket ( fd ) ) ; } @Deprecated protected AbstractEpollStreamChannel ( FileDescriptor fd ) { this ( new Socket ( fd . intValue ( ) ) ) ; } @Deprecated protected AbstractEpollStreamChannel ( Socket fd ) { this ( fd , fd . getSoError ( ) = = <int> ) ; } protected AbstractEpollStreamChannel ( Channel parent , Socket fd ) { super ( parent , fd , Native . EPOLLIN , true ) ; flags | = Native . EPOLLRDHUP ; } protected AbstractEpollStreamChannel ( Socket fd , boolean active ) { super ( null , fd , Native . EPOLLIN , active ) ; flags | = Native . EPOLLRDHUP ; } @Override protected AbstractEpollUnsafe newUnsafe ( ) { return new EpollStreamUnsafe ( ) ; } public final ChannelFuture spliceTo ( final AbstractEpollStreamChannel ch , final int len ) { return spliceTo ( ch , len , newPromise ( ) ) ; } public final ChannelFuture spliceTo ( final AbstractEpollStreamChannel ch , final int len , final ChannelPromise promise ) { if ( ch . eventLoop ( ) ! = eventLoop ( ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( len < <int> ) { throw new IllegalArgumentException ( <str> + len + <str> ) ; } if ( ch . config ( ) . getEpollMode ( ) ! = EpollMode . LEVEL_TRIGGERED | | config ( ) . getEpollMode ( ) ! = EpollMode . LEVEL_TRIGGERED ) { throw new IllegalStateException ( <str> + EpollMode . LEVEL_TRIGGERED ) ; } checkNotNull ( promise , <str> ) ; if ( ! isOpen ( ) ) { promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; } else { addToSpliceQueue ( new SpliceInChannelTask ( ch , len , promise ) ) ; failSpliceIfClosed ( promise ) ; } return promise ; } public final ChannelFuture spliceTo ( final FileDescriptor ch , final int offset , final int len ) { return spliceTo ( ch , offset , len , newPromise ( ) ) ; } public final ChannelFuture spliceTo ( final FileDescriptor ch , final int offset , final int len , final ChannelPromise promise ) { if ( len < <int> ) { throw new IllegalArgumentException ( <str> + len + <str> ) ; } if ( offset < <int> ) { throw new IllegalArgumentException ( <str> + offset ) ; } if ( config ( ) . getEpollMode ( ) ! = EpollMode . LEVEL_TRIGGERED ) { throw new IllegalStateException ( <str> + EpollMode . LEVEL_TRIGGERED ) ; } checkNotNull ( promise , <str> ) ; if ( ! isOpen ( ) ) { promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; } else { addToSpliceQueue ( new SpliceFdTask ( ch , offset , len , promise ) ) ; failSpliceIfClosed ( promise ) ; } return promise ; } private void failSpliceIfClosed ( ChannelPromise promise ) { if ( ! isOpen ( ) ) { if ( promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ) { eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { clearSpliceQueue ( ) ; } } ) ; } } } private boolean writeBytes ( ChannelOutboundBuffer in , ByteBuf buf , int writeSpinCount ) throws Exception { int readableBytes = buf . readableBytes ( ) ; if ( readableBytes = = <int> ) { in . remove ( ) ; return true ; } if ( buf . hasMemoryAddress ( ) | | buf . nioBufferCount ( ) = = <int> ) { int writtenBytes = doWriteBytes ( buf , writeSpinCount ) ; in . removeBytes ( writtenBytes ) ; return writtenBytes = = readableBytes ; } else { ByteBuffer [ ] nioBuffers = buf . nioBuffers ( ) ; return writeBytesMultiple ( in , nioBuffers , nioBuffers . length , readableBytes , writeSpinCount ) ; } } private boolean writeBytesMultiple ( ChannelOutboundBuffer in , IovArray array , int writeSpinCount ) throws IOException { long expectedWrittenBytes = array . size ( ) ; final long initialExpectedWrittenBytes = expectedWrittenBytes ; int cnt = array . count ( ) ; assert expectedWrittenBytes ! = <int> ; assert cnt ! = <int> ; boolean done = false ; int offset = <int> ; int end = offset + cnt ; for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { long localWrittenBytes = fd ( ) . writevAddresses ( array . memoryAddress ( offset ) , cnt ) ; if ( localWrittenBytes = = <int> ) { break ; } expectedWrittenBytes - = localWrittenBytes ; if ( expectedWrittenBytes = = <int> ) { done = true ; break ; } do { long bytes = array . processWritten ( offset , localWrittenBytes ) ; if ( bytes = = - <int> ) { break ; } else { offset + + ; cnt - - ; localWrittenBytes - = bytes ; } } while ( offset < end & & localWrittenBytes > <int> ) ; } in . removeBytes ( initialExpectedWrittenBytes - expectedWrittenBytes ) ; return done ; } private boolean writeBytesMultiple ( ChannelOutboundBuffer in , ByteBuffer [ ] nioBuffers , int nioBufferCnt , long expectedWrittenBytes , int writeSpinCount ) throws IOException { assert expectedWrittenBytes ! = <int> ; final long initialExpectedWrittenBytes = expectedWrittenBytes ; boolean done = false ; int offset = <int> ; int end = offset + nioBufferCnt ; for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { long localWrittenBytes = fd ( ) . writev ( nioBuffers , offset , nioBufferCnt ) ; if ( localWrittenBytes = = <int> ) { break ; } expectedWrittenBytes - = localWrittenBytes ; if ( expectedWrittenBytes = = <int> ) { done = true ; break ; } do { ByteBuffer buffer = nioBuffers [ offset ] ; int pos = buffer . position ( ) ; int bytes = buffer . limit ( ) - pos ; if ( bytes > localWrittenBytes ) { buffer . position ( pos + ( int ) localWrittenBytes ) ; break ; } else { offset + + ; nioBufferCnt - - ; localWrittenBytes - = bytes ; } } while ( offset < end & & localWrittenBytes > <int> ) ; } in . removeBytes ( initialExpectedWrittenBytes - expectedWrittenBytes ) ; return done ; } private boolean writeFileRegion ( ChannelOutboundBuffer in , DefaultFileRegion region , int writeSpinCount ) throws Exception { final long regionCount = region . count ( ) ; if ( region . transfered ( ) > = regionCount ) { in . remove ( ) ; return true ; } final long baseOffset = region . position ( ) ; boolean done = false ; long flushedAmount = <int> ; for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { final long offset = region . transfered ( ) ; final long localFlushedAmount = Native . sendfile ( fd ( ) . intValue ( ) , region , baseOffset , offset , regionCount - offset ) ; if ( localFlushedAmount = = <int> ) { break ; } flushedAmount + = localFlushedAmount ; if ( region . transfered ( ) > = regionCount ) { done = true ; break ; } } if ( flushedAmount > <int> ) { in . progress ( flushedAmount ) ; } if ( done ) { in . remove ( ) ; } return done ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { int writeSpinCount = config ( ) . getWriteSpinCount ( ) ; for ( ; ; ) { final int msgCount = in . size ( ) ; if ( msgCount = = <int> ) { clearFlag ( Native . EPOLLOUT ) ; return ; } if ( msgCount > <int> & & in . current ( ) instanceof ByteBuf ) { if ( ! doWriteMultiple ( in , writeSpinCount ) ) { break ; } } else { if ( ! doWriteSingle ( in , writeSpinCount ) ) { break ; } } } setFlag ( Native . EPOLLOUT ) ; } protected boolean doWriteSingle ( ChannelOutboundBuffer in , int writeSpinCount ) throws Exception { Object msg = in . current ( ) ; if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; if ( ! writeBytes ( in , buf , writeSpinCount ) ) { return false ; } } else if ( msg instanceof DefaultFileRegion ) { DefaultFileRegion region = ( DefaultFileRegion ) msg ; if ( ! writeFileRegion ( in , region , writeSpinCount ) ) { return false ; } } else if ( msg instanceof SpliceOutTask ) { if ( ! ( ( SpliceOutTask ) msg ) . spliceOut ( ) ) { return false ; } in . remove ( ) ; } else { throw new Error ( ) ; } return true ; } private boolean doWriteMultiple ( ChannelOutboundBuffer in , int writeSpinCount ) throws Exception { if ( PlatformDependent . hasUnsafe ( ) ) { IovArray array = ( ( EpollEventLoop ) eventLoop ( ) ) . cleanArray ( ) ; in . forEachFlushedMessage ( array ) ; int cnt = array . count ( ) ; if ( cnt > = <int> ) { if ( ! writeBytesMultiple ( in , array , writeSpinCount ) ) { return false ; } } else { in . removeBytes ( <int> ) ; } } else { ByteBuffer [ ] buffers = in . nioBuffers ( ) ; int cnt = in . nioBufferCount ( ) ; if ( cnt > = <int> ) { if ( ! writeBytesMultiple ( in , buffers , cnt , in . nioBufferSize ( ) , writeSpinCount ) ) { return false ; } } else { in . removeBytes ( <int> ) ; } } return true ; } @Override protected Object filterOutboundMessage ( Object msg ) { if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; if ( ! buf . hasMemoryAddress ( ) & & ( PlatformDependent . hasUnsafe ( ) | | ! buf . isDirect ( ) ) ) { if ( buf instanceof CompositeByteBuf ) { CompositeByteBuf comp = ( CompositeByteBuf ) buf ; if ( ! comp . isDirect ( ) | | comp . nioBufferCount ( ) > Native . IOV_MAX ) { buf = newDirectBuffer ( buf ) ; assert buf . hasMemoryAddress ( ) ; } } else { buf = newDirectBuffer ( buf ) ; assert buf . hasMemoryAddress ( ) ; } } return buf ; } if ( msg instanceof DefaultFileRegion | | msg instanceof SpliceOutTask ) { return msg ; } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } protected void shutdownOutput0 ( final ChannelPromise promise ) { try { fd ( ) . shutdown ( false , true ) ; promise . setSuccess ( ) ; } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } } @Override protected void doClose ( ) throws Exception { try { ChannelPromise promise = connectPromise ; if ( promise ! = null ) { promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; connectPromise = null ; } ScheduledFuture < ? > future = connectTimeoutFuture ; if ( future ! = null ) { future . cancel ( false ) ; connectTimeoutFuture = null ; } super . doClose ( ) ; } finally { safeClosePipe ( pipeIn ) ; safeClosePipe ( pipeOut ) ; clearSpliceQueue ( ) ; } } private void clearSpliceQueue ( ) { if ( spliceQueue = = null ) { return ; } for ( ; ; ) { SpliceInTask task = spliceQueue . poll ( ) ; if ( task = = null ) { break ; } task . promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; } } protected boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( localAddress ! = null ) { fd ( ) . bind ( localAddress ) ; } boolean success = false ; try { boolean connected = fd ( ) . connect ( remoteAddress ) ; if ( ! connected ) { setFlag ( Native . EPOLLOUT ) ; } success = true ; return connected ; } finally { if ( ! success ) { doClose ( ) ; } } } private void safeClosePipe ( FileDescriptor fd ) { if ( fd ! = null ) { try { fd . close ( ) ; } catch ( IOException e ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , e ) ; } } } } class EpollStreamUnsafe extends AbstractEpollUnsafe { private void handleReadException ( ChannelPipeline pipeline , ByteBuf byteBuf , Throwable cause , boolean close ) { if ( byteBuf ! = null ) { if ( byteBuf . isReadable ( ) ) { readPending = false ; pipeline . fireChannelRead ( byteBuf ) ; } else { byteBuf . release ( ) ; } } recvBufAllocHandle ( ) . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; pipeline . fireExceptionCaught ( cause ) ; if ( close | | cause instanceof IOException ) { shutdownInput ( ) ; } } @Override public void connect ( final SocketAddress remoteAddress , final SocketAddress localAddress , final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) | | ! ensureOpen ( promise ) ) { return ; } try { if ( connectPromise ! = null ) { throw new IllegalStateException ( <str> ) ; } boolean wasActive = isActive ( ) ; if ( doConnect ( remoteAddress , localAddress ) ) { fulfillConnectPromise ( promise , wasActive ) ; } else { connectPromise = promise ; requestedRemoteAddress = remoteAddress ; int connectTimeoutMillis = config ( ) . getConnectTimeoutMillis ( ) ; if ( connectTimeoutMillis > <int> ) { connectTimeoutFuture = eventLoop ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise connectPromise = AbstractEpollStreamChannel . this . connectPromise ; ConnectTimeoutException cause = new ConnectTimeoutException ( <str> + remoteAddress ) ; if ( connectPromise ! = null & & connectPromise . tryFailure ( cause ) ) { close ( voidPromise ( ) ) ; } } } , connectTimeoutMillis , TimeUnit . MILLISECONDS ) ; } promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( future . isCancelled ( ) ) { if ( connectTimeoutFuture ! = null ) { connectTimeoutFuture . cancel ( false ) ; } connectPromise = null ; close ( voidPromise ( ) ) ; } } } ) ; } } catch ( Throwable t ) { closeIfClosed ( ) ; promise . tryFailure ( annotateConnectException ( t , remoteAddress ) ) ; } } private void fulfillConnectPromise ( ChannelPromise promise , boolean wasActive ) { if ( promise = = null ) { return ; } active = true ; boolean promiseSet = promise . trySuccess ( ) ; if ( ! wasActive & & isActive ( ) ) { pipeline ( ) . fireChannelActive ( ) ; } if ( ! promiseSet ) { close ( voidPromise ( ) ) ; } } private void fulfillConnectPromise ( ChannelPromise promise , Throwable cause ) { if ( promise = = null ) { return ; } promise . tryFailure ( cause ) ; closeIfClosed ( ) ; } private void finishConnect ( ) { assert eventLoop ( ) . inEventLoop ( ) ; boolean connectStillInProgress = false ; try { boolean wasActive = isActive ( ) ; if ( ! doFinishConnect ( ) ) { connectStillInProgress = true ; return ; } fulfillConnectPromise ( connectPromise , wasActive ) ; } catch ( Throwable t ) { fulfillConnectPromise ( connectPromise , annotateConnectException ( t , requestedRemoteAddress ) ) ; } finally { if ( ! connectStillInProgress ) { if ( connectTimeoutFuture ! = null ) { connectTimeoutFuture . cancel ( false ) ; } connectPromise = null ; } } } @Override void epollOutReady ( ) { if ( connectPromise ! = null ) { finishConnect ( ) ; } else { super . epollOutReady ( ) ; } } boolean doFinishConnect ( ) throws Exception { if ( fd ( ) . finishConnect ( ) ) { clearFlag ( Native . EPOLLOUT ) ; return true ; } else { setFlag ( Native . EPOLLOUT ) ; return false ; } } @Override protected EpollRecvByteAllocatorHandle newEpollHandle ( RecvByteBufAllocator . Handle handle ) { return new EpollRecvByteAllocatorStreamingHandle ( handle , isFlagSet ( Native . EPOLLET ) ) ; } @Override void epollInReady ( ) { if ( fd ( ) . isInputShutdown ( ) ) { return ; } final ChannelConfig config = config ( ) ; boolean edgeTriggered = isFlagSet ( Native . EPOLLET ) ; if ( ! readPending & & ! edgeTriggered & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final ByteBufAllocator allocator = config . getAllocator ( ) ; final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; ByteBuf byteBuf = null ; boolean close = false ; try { do { if ( spliceQueue ! = null ) { SpliceInTask spliceTask = spliceQueue . peek ( ) ; if ( spliceTask ! = null ) { if ( spliceTask . spliceIn ( allocHandle ) ) { if ( isActive ( ) ) { spliceQueue . remove ( ) ; } continue ; } else { break ; } } } byteBuf = allocHandle . allocate ( allocator ) ; allocHandle . lastBytesRead ( doReadBytes ( byteBuf ) ) ; if ( allocHandle . lastBytesRead ( ) < = <int> ) { byteBuf . release ( ) ; byteBuf = null ; close = allocHandle . lastBytesRead ( ) < <int> ; break ; } readPending = false ; allocHandle . incMessagesRead ( <int> ) ; pipeline . fireChannelRead ( byteBuf ) ; byteBuf = null ; } while ( allocHandle . continueReading ( ) ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( close ) { shutdownInput ( ) ; close = false ; } } catch ( Throwable t ) { handleReadException ( pipeline , byteBuf , t , close ) ; checkResetEpollIn ( edgeTriggered ) ; } finally { if ( ! readPending & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; } } } } private void addToSpliceQueue ( final SpliceInTask task ) { EventLoop eventLoop = eventLoop ( ) ; if ( eventLoop . inEventLoop ( ) ) { addToSpliceQueue0 ( task ) ; } else { eventLoop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { addToSpliceQueue0 ( task ) ; } } ) ; } } private void addToSpliceQueue0 ( SpliceInTask task ) { if ( spliceQueue = = null ) { spliceQueue = PlatformDependent . newMpscQueue ( ) ; } spliceQueue . add ( task ) ; } protected abstract class SpliceInTask extends MpscLinkedQueueNode < SpliceInTask > { final ChannelPromise promise ; int len ; protected SpliceInTask ( int len , ChannelPromise promise ) { this . promise = promise ; this . len = len ; } @Override public SpliceInTask value ( ) { return this ; } abstract boolean spliceIn ( RecvByteBufAllocator . Handle handle ) throws IOException ; protected final int spliceIn ( FileDescriptor pipeOut , RecvByteBufAllocator . Handle handle ) throws IOException { int length = Math . min ( handle . guess ( ) , len ) ; int splicedIn = <int> ; for ( ; ; ) { int localSplicedIn = Native . splice ( fd ( ) . intValue ( ) , - <int> , pipeOut . intValue ( ) , - <int> , length ) ; if ( localSplicedIn = = <int> ) { break ; } splicedIn + = localSplicedIn ; length - = localSplicedIn ; } return splicedIn ; } } private final class SpliceInChannelTask extends SpliceInTask implements ChannelFutureListener { private final AbstractEpollStreamChannel ch ; SpliceInChannelTask ( AbstractEpollStreamChannel ch , int len , ChannelPromise promise ) { super ( len , promise ) ; this . ch = ch ; } @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { promise . setFailure ( future . cause ( ) ) ; } } @Override public boolean spliceIn ( RecvByteBufAllocator . Handle handle ) throws IOException { assert ch . eventLoop ( ) . inEventLoop ( ) ; if ( len = = <int> ) { promise . setSuccess ( ) ; return true ; } try { FileDescriptor pipeOut = ch . pipeOut ; if ( pipeOut = = null ) { FileDescriptor [ ] pipe = pipe ( ) ; ch . pipeIn = pipe [ <int> ] ; pipeOut = ch . pipeOut = pipe [ <int> ] ; } int splicedIn = spliceIn ( pipeOut , handle ) ; if ( splicedIn > <int> ) { if ( len ! = Integer . MAX_VALUE ) { len - = splicedIn ; } final ChannelPromise splicePromise ; if ( len = = <int> ) { splicePromise = promise ; } else { splicePromise = ch . newPromise ( ) . addListener ( this ) ; } boolean autoRead = config ( ) . isAutoRead ( ) ; ch . unsafe ( ) . write ( new SpliceOutTask ( ch , splicedIn , autoRead ) , splicePromise ) ; ch . unsafe ( ) . flush ( ) ; if ( autoRead & & ! splicePromise . isDone ( ) ) { config ( ) . setAutoRead ( false ) ; } } return len = = <int> ; } catch ( Throwable cause ) { promise . setFailure ( cause ) ; return true ; } } } private final class SpliceOutTask { private final AbstractEpollStreamChannel ch ; private final boolean autoRead ; private int len ; SpliceOutTask ( AbstractEpollStreamChannel ch , int len , boolean autoRead ) { this . ch = ch ; this . len = len ; this . autoRead = autoRead ; } public boolean spliceOut ( ) throws Exception { assert ch . eventLoop ( ) . inEventLoop ( ) ; try { int splicedOut = Native . splice ( ch . pipeIn . intValue ( ) , - <int> , ch . fd ( ) . intValue ( ) , - <int> , len ) ; len - = splicedOut ; if ( len = = <int> ) { if ( autoRead ) { config ( ) . setAutoRead ( true ) ; } return true ; } return false ; } catch ( IOException e ) { if ( autoRead ) { config ( ) . setAutoRead ( true ) ; } throw e ; } } } private final class SpliceFdTask extends SpliceInTask { private final FileDescriptor fd ; private final ChannelPromise promise ; private int offset ; SpliceFdTask ( FileDescriptor fd , int offset , int len , ChannelPromise promise ) { super ( len , promise ) ; this . fd = fd ; this . promise = promise ; this . offset = offset ; } @Override public SpliceFdTask value ( ) { return this ; } @Override public boolean spliceIn ( RecvByteBufAllocator . Handle handle ) throws IOException { assert eventLoop ( ) . inEventLoop ( ) ; if ( len = = <int> ) { promise . setSuccess ( ) ; return true ; } try { FileDescriptor [ ] pipe = pipe ( ) ; FileDescriptor pipeIn = pipe [ <int> ] ; FileDescriptor pipeOut = pipe [ <int> ] ; try { int splicedIn = spliceIn ( pipeOut , handle ) ; if ( splicedIn > <int> ) { if ( len ! = Integer . MAX_VALUE ) { len - = splicedIn ; } do { int splicedOut = Native . splice ( pipeIn . intValue ( ) , - <int> , fd . intValue ( ) , offset , splicedIn ) ; splicedIn - = splicedOut ; } while ( splicedIn > <int> ) ; if ( len = = <int> ) { promise . setSuccess ( ) ; return true ; } } return false ; } finally { safeClosePipe ( pipeIn ) ; safeClosePipe ( pipeOut ) ; } } catch ( Throwable cause ) { promise . setFailure ( cause ) ; return true ; } } } } 
