package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . LeafReaderContext ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . * ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; public final class DisabledIndexFieldData extends AbstractIndexFieldData < AtomicFieldData > { public static class Builder implements IndexFieldData . Builder { @Override public IndexFieldData < AtomicFieldData > build ( IndexSettings indexSettings , MappedFieldType fieldType , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService ) { return new DisabledIndexFieldData ( indexSettings , fieldType . names ( ) , fieldType . fieldDataType ( ) , cache ) ; } } public DisabledIndexFieldData ( IndexSettings indexSettings , Names fieldNames , FieldDataType fieldDataType , IndexFieldDataCache cache ) { super ( indexSettings , fieldNames , fieldDataType , cache ) ; } @Override public AtomicFieldData loadDirect ( LeafReaderContext context ) throws Exception { throw fail ( ) ; } @Override protected AtomicFieldData empty ( int maxDoc ) { throw fail ( ) ; } @Override public IndexFieldData . XFieldComparatorSource comparatorSource ( Object missingValue , MultiValueMode sortMode , Nested nested ) { throw fail ( ) ; } private IllegalStateException fail ( ) { return new IllegalStateException ( <str> + getFieldNames ( ) . fullName ( ) ) ; } } 
