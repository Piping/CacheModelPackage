package org . elasticsearch . common . xcontent . builder ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . io . FastCharArrayWriter ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentGenerator ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . test . ESTestCase ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . TimeZone ; import static org . elasticsearch . common . xcontent . XContentBuilder . FieldCaseConversion . CAMELCASE ; import static org . elasticsearch . common . xcontent . XContentBuilder . FieldCaseConversion . UNDERSCORE ; import static org . hamcrest . Matchers . equalTo ; public class XContentBuilderTests extends ESTestCase { public void testPrettyWithLfAtEnd ( ) throws Exception { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; XContentGenerator generator = XContentFactory . xContent ( XContentType . JSON ) . createGenerator ( os ) ; generator . usePrettyPrint ( ) ; generator . usePrintLineFeedAtEnd ( ) ; generator . writeStartObject ( ) ; generator . writeStringField ( <str> , <str> ) ; generator . writeEndObject ( ) ; generator . flush ( ) ; generator . close ( ) ; generator . close ( ) ; byte [ ] bytes = os . toByteArray ( ) ; assertThat ( ( char ) bytes [ bytes . length - <int> ] , equalTo ( <str> ) ) ; } public void testReuseJsonGenerator ( ) throws Exception { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; XContentGenerator generator = XContentFactory . xContent ( XContentType . JSON ) . createGenerator ( os ) ; generator . writeStartObject ( ) ; generator . writeStringField ( <str> , <str> ) ; generator . writeEndObject ( ) ; generator . flush ( ) ; assertThat ( new BytesRef ( os . toByteArray ( ) ) , equalTo ( new BytesRef ( <str> ) ) ) ; os . reset ( ) ; generator . writeStartObject ( ) ; generator . writeStringField ( <str> , <str> ) ; generator . writeEndObject ( ) ; generator . flush ( ) ; assertThat ( new BytesRef ( os . toByteArray ( ) ) , equalTo ( new BytesRef ( <str> ) ) ) ; } public void testRaw ( ) throws IOException { { XContentBuilder xContentBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; xContentBuilder . startObject ( ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . endObject ( ) ; assertThat ( xContentBuilder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } { XContentBuilder xContentBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; xContentBuilder . startObject ( ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . endObject ( ) ; assertThat ( xContentBuilder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } { XContentBuilder xContentBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; xContentBuilder . startObject ( ) ; xContentBuilder . field ( <str> , <str> ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . endObject ( ) ; assertThat ( xContentBuilder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } { XContentBuilder xContentBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; xContentBuilder . startObject ( ) ; xContentBuilder . field ( <str> , <str> ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . field ( <str> , <str> ) ; xContentBuilder . endObject ( ) ; assertThat ( xContentBuilder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } { XContentBuilder xContentBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; xContentBuilder . startObject ( ) ; xContentBuilder . field ( <str> , <str> ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . rawField ( <str> , new BytesArray ( <str> ) ) ; xContentBuilder . field ( <str> , <str> ) ; xContentBuilder . endObject ( ) ; assertThat ( xContentBuilder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } } public void testSimpleGenerator ( ) throws Exception { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> ) ) ; } public void testOverloadedList ( ) throws Exception { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , Arrays . asList ( <str> , <str> ) ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> ) ) ; } public void testWritingBinaryToStream ( ) throws Exception { BytesStreamOutput bos = new BytesStreamOutput ( ) ; XContentGenerator gen = XContentFactory . xContent ( XContentType . JSON ) . createGenerator ( bos ) ; gen . writeStartObject ( ) ; gen . writeStringField ( <str> , <str> ) ; gen . flush ( ) ; bos . write ( <str> . getBytes ( <str> ) ) ; gen . writeStringField ( <str> , <str> ) ; gen . writeEndObject ( ) ; gen . close ( ) ; byte [ ] data = bos . bytes ( ) . toBytes ( ) ; String sData = new String ( data , <str> ) ; System . out . println ( <str> + sData ) ; } public void testFieldCaseConversion ( ) throws Exception { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) . fieldCaseConversion ( CAMELCASE ) ; builder . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> ) ) ; builder = XContentFactory . contentBuilder ( XContentType . JSON ) . fieldCaseConversion ( UNDERSCORE ) ; builder . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> ) ) ; } public void testByteConversion ( ) throws Exception { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , ( Byte ) ( byte ) <int> ) . endObject ( ) ; assertThat ( builder . bytes ( ) . toUtf8 ( ) , equalTo ( <str> ) ) ; } public void testDateTypesConversion ( ) throws Exception { Date date = new Date ( ) ; String expectedDate = XContentBuilder . defaultDatePrinter . print ( date . getTime ( ) ) ; Calendar calendar = new GregorianCalendar ( TimeZone . getTimeZone ( <str> ) , Locale . ROOT ) ; String expectedCalendar = XContentBuilder . defaultDatePrinter . print ( calendar . getTimeInMillis ( ) ) ; XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , date ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> + expectedDate + <str> ) ) ; builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , calendar ) . endObject ( ) ; assertThat ( builder . string ( ) , equalTo ( <str> + expectedCalendar + <str> ) ) ; builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; Map < String , Object > map = new HashMap < > ( ) ; map . put ( <str> , date ) ; builder . map ( map ) ; assertThat ( builder . string ( ) , equalTo ( <str> + expectedDate + <str> ) ) ; builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; map = new HashMap < > ( ) ; map . put ( <str> , calendar ) ; builder . map ( map ) ; assertThat ( builder . string ( ) , equalTo ( <str> + expectedCalendar + <str> ) ) ; } public void testCopyCurrentStructure ( ) throws Exception { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) ; int numTerms = randomInt ( <int> ) + <int> ; List < String > terms = new ArrayList < > ( numTerms ) ; for ( int i = <int> ; i < numTerms ; i + + ) { terms . add ( <str> + i ) ; } builder . field ( <str> , terms ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; XContentBuilder filterBuilder = null ; XContentParser . Token token ; String currentFieldName = null ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { assertThat ( parser . text ( ) , equalTo ( <str> ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { filterBuilder = XContentFactory . contentBuilder ( parser . contentType ( ) ) ; filterBuilder . copyCurrentStructure ( parser ) ; } } } assertNotNull ( filterBuilder ) ; parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( filterBuilder . bytes ( ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . currentName ( ) , equalTo ( <str> ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . currentName ( ) , equalTo ( <str> ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_ARRAY ) ) ; int i = <int> ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { assertThat ( parser . text ( ) , equalTo ( terms . get ( i + + ) ) ) ; } assertThat ( i , equalTo ( terms . size ( ) ) ) ; } public void testHandlingOfPath ( ) throws IOException { Path path = PathUtils . get ( <str> ) ; checkPathSerialization ( path ) ; } public void testHandlingOfPath_relative ( ) throws IOException { Path path = PathUtils . get ( <str> , <str> , <str> ) ; checkPathSerialization ( path ) ; } public void testHandlingOfPath_absolute ( ) throws IOException { Path path = createTempDir ( ) . toAbsolutePath ( ) ; checkPathSerialization ( path ) ; } private void checkPathSerialization ( Path path ) throws IOException { XContentBuilder pathBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; pathBuilder . startObject ( ) . field ( <str> , path ) . endObject ( ) ; XContentBuilder stringBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; stringBuilder . startObject ( ) . field ( <str> , path . toString ( ) ) . endObject ( ) ; assertThat ( pathBuilder . string ( ) , equalTo ( stringBuilder . string ( ) ) ) ; } public void testHandlingOfPath_XContentBuilderStringName ( ) throws IOException { Path path = PathUtils . get ( <str> ) ; XContentBuilderString name = new XContentBuilderString ( <str> ) ; XContentBuilder pathBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; pathBuilder . startObject ( ) . field ( name , path ) . endObject ( ) ; XContentBuilder stringBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; stringBuilder . startObject ( ) . field ( name , path . toString ( ) ) . endObject ( ) ; assertThat ( pathBuilder . string ( ) , equalTo ( stringBuilder . string ( ) ) ) ; } public void testHandlingOfCollectionOfPaths ( ) throws IOException { Path path = PathUtils . get ( <str> ) ; XContentBuilder pathBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; pathBuilder . startObject ( ) . field ( <str> , Arrays . asList ( path ) ) . endObject ( ) ; XContentBuilder stringBuilder = XContentFactory . contentBuilder ( XContentType . JSON ) ; stringBuilder . startObject ( ) . field ( <str> , Arrays . asList ( path . toString ( ) ) ) . endObject ( ) ; assertThat ( pathBuilder . string ( ) , equalTo ( stringBuilder . string ( ) ) ) ; } public void testIndentIsPlatformIndependent ( ) throws IOException { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) . prettyPrint ( ) ; builder . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; String string = builder . string ( ) ; assertEquals ( <str> + <str> + <str> + <str> + <str> + <str> , string ) ; builder = XContentFactory . contentBuilder ( XContentType . YAML ) . prettyPrint ( ) ; builder . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; string = builder . string ( ) ; assertEquals ( <str> + <str> + <str> + <str> , string ) ; } public void testRenderGeoPoint ( ) throws IOException { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) . prettyPrint ( ) ; builder . startObject ( ) . field ( <str> ) . value ( new GeoPoint ( <int> , <int> ) ) . endObject ( ) ; String string = builder . string ( ) ; assertEquals ( <str> + <str> + <str> + <str> + <str> + <str> , string . trim ( ) ) ; } } 
