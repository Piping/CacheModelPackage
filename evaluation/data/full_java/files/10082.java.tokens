package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionSize . SEVERAL ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import static com . google . common . collect . testing . features . MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION ; import static com . google . common . collect . testing . features . MapFeature . SUPPORTS_REMOVE ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . testing . AbstractMapTester ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . Map . Entry ; @GwtCompatible public class MapClearTester < K , V > extends AbstractMapTester < K , V > { @MapFeature.Require ( SUPPORTS_REMOVE ) public void testClear ( ) { getMap ( ) . clear ( ) ; assertTrue ( <str> , getMap ( ) . isEmpty ( ) ) ; assertEquals ( <int> , getMap ( ) . size ( ) ) ; assertFalse ( getMap ( ) . entrySet ( ) . iterator ( ) . hasNext ( ) ) ; } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_REMOVE } ) @CollectionSize.Require ( SEVERAL ) public void testClearConcurrentWithEntrySetIteration ( ) { try { Iterator < Entry < K , V > > iterator = getMap ( ) . entrySet ( ) . iterator ( ) ; getMap ( ) . clear ( ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_REMOVE } ) @CollectionSize.Require ( SEVERAL ) public void testClearConcurrentWithKeySetIteration ( ) { try { Iterator < K > iterator = getMap ( ) . keySet ( ) . iterator ( ) ; getMap ( ) . clear ( ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_REMOVE } ) @CollectionSize.Require ( SEVERAL ) public void testClearConcurrentWithValuesIteration ( ) { try { Iterator < V > iterator = getMap ( ) . values ( ) . iterator ( ) ; getMap ( ) . clear ( ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testClear_unsupported ( ) { try { getMap ( ) . clear ( ) ; fail ( <str> + <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; } @MapFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testClear_unsupportedByEmptyCollection ( ) { try { getMap ( ) . clear ( ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } } 
