package org . gradle . sonar . runner . tasks ; import com . google . common . base . Joiner ; import com . google . common . collect . Maps ; import org . gradle . api . DefaultTask ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . tasks . Input ; import org . gradle . api . tasks . TaskAction ; import org . gradle . process . JavaForkOptions ; import org . gradle . process . internal . DefaultJavaForkOptions ; import org . gradle . process . internal . JavaExecHandleBuilder ; import org . gradle . sonar . runner . SonarRunnerExtension ; import org . gradle . util . GUtil ; import javax . inject . Inject ; import java . io . File ; import java . util . Map ; import java . util . Properties ; @Deprecated public class SonarRunner extends DefaultTask { private static final Logger LOGGER = Logging . getLogger ( SonarRunner . class ) ; private static final String MAIN_CLASS_NAME = <str> ; private JavaForkOptions forkOptions ; private Map < String , Object > sonarProperties ; @TaskAction public void run ( ) { prepareExec ( ) . build ( ) . start ( ) . waitForFinish ( ) . assertNormalExitValue ( ) ; } JavaExecHandleBuilder prepareExec ( ) { Map < String , Object > properties = getSonarProperties ( ) ; if ( getProject ( ) . file ( <str> ) . exists ( ) ) { LOGGER . warn ( <str> ) ; } if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( <str> , Joiner . on ( <str> ) . withKeyValueSeparator ( <str> ) . join ( properties ) ) ; } JavaExecHandleBuilder javaExec = new JavaExecHandleBuilder ( getFileResolver ( ) ) ; getForkOptions ( ) . copyTo ( javaExec ) ; FileCollection sonarRunnerConfiguration = getProject ( ) . getConfigurations ( ) . getAt ( SonarRunnerExtension . SONAR_RUNNER_CONFIGURATION_NAME ) ; Properties propertiesObject = new Properties ( ) ; propertiesObject . putAll ( properties ) ; File propertyFile = new File ( getTemporaryDir ( ) , <str> ) ; GUtil . saveProperties ( propertiesObject , propertyFile ) ; return javaExec . systemProperty ( <str> , propertyFile . getAbsolutePath ( ) ) . systemProperty ( <str> , getProject ( ) . getProjectDir ( ) . getAbsolutePath ( ) ) . setClasspath ( sonarRunnerConfiguration ) . setMain ( MAIN_CLASS_NAME ) ; } public JavaForkOptions getForkOptions ( ) { if ( forkOptions = = null ) { forkOptions = new DefaultJavaForkOptions ( getFileResolver ( ) ) ; } return forkOptions ; } @Input public Map < String , Object > getSonarProperties ( ) { if ( sonarProperties = = null ) { sonarProperties = Maps . newLinkedHashMap ( ) ; } return sonarProperties ; } @Inject protected FileResolver getFileResolver ( ) { throw new UnsupportedOperationException ( ) ; } } 
