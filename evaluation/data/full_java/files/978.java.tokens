package org . apache . cassandra . service . paxos ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import com . google . common . base . Predicate ; import com . google . common . collect . Iterables ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . DecoratedKey ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . net . MessageIn ; public class PrepareCallback extends AbstractPaxosCallback < PrepareResponse > { private static final Logger logger = LoggerFactory . getLogger ( PrepareCallback . class ) ; public boolean promised = true ; public Commit mostRecentCommit ; public Commit mostRecentInProgressCommit ; public Commit mostRecentInProgressCommitWithUpdate ; private final Map < InetAddress , Commit > commitsByReplica = new ConcurrentHashMap < InetAddress , Commit > ( ) ; public PrepareCallback ( DecoratedKey key , CFMetaData metadata , int targets , ConsistencyLevel consistency ) { super ( targets , consistency ) ; mostRecentCommit = Commit . emptyCommit ( key , metadata ) ; mostRecentInProgressCommit = Commit . emptyCommit ( key , metadata ) ; mostRecentInProgressCommitWithUpdate = Commit . emptyCommit ( key , metadata ) ; } public synchronized void response ( MessageIn < PrepareResponse > message ) { PrepareResponse response = message . payload ; logger . debug ( <str> , response , message . from ) ; if ( response . inProgressCommit . isAfter ( mostRecentInProgressCommit ) ) mostRecentInProgressCommit = response . inProgressCommit ; if ( ! response . promised ) { promised = false ; while ( latch . getCount ( ) > <int> ) latch . countDown ( ) ; return ; } commitsByReplica . put ( message . from , response . mostRecentCommit ) ; if ( response . mostRecentCommit . isAfter ( mostRecentCommit ) ) mostRecentCommit = response . mostRecentCommit ; if ( response . inProgressCommit . isAfter ( mostRecentInProgressCommitWithUpdate ) & & ! response . inProgressCommit . update . isEmpty ( ) ) mostRecentInProgressCommitWithUpdate = response . inProgressCommit ; latch . countDown ( ) ; } public Iterable < InetAddress > replicasMissingMostRecentCommit ( ) { return Iterables . filter ( commitsByReplica . keySet ( ) , new Predicate < InetAddress > ( ) { public boolean apply ( InetAddress inetAddress ) { return ( ! commitsByReplica . get ( inetAddress ) . ballot . equals ( mostRecentCommit . ballot ) ) ; } } ) ; } } 
