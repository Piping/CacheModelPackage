package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . util . Signal ; import io . netty . util . internal . RecyclableArrayList ; import io . netty . util . internal . StringUtil ; import java . util . List ; public abstract class ReplayingDecoder < S > extends ByteToMessageDecoder { static final Signal REPLAY = Signal . valueOf ( ReplayingDecoder . class , <str> ) ; private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf ( ) ; private S state ; private int checkpoint = - <int> ; protected ReplayingDecoder ( ) { this ( null ) ; } protected ReplayingDecoder ( S initialState ) { state = initialState ; } protected void checkpoint ( ) { checkpoint = internalBuffer ( ) . readerIndex ( ) ; } protected void checkpoint ( S state ) { checkpoint ( ) ; state ( state ) ; } protected S state ( ) { return state ; } protected S state ( S newState ) { S oldState = state ; state = newState ; return oldState ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { RecyclableArrayList out = RecyclableArrayList . newInstance ( ) ; try { replayable . terminate ( ) ; callDecode ( ctx , internalBuffer ( ) , out ) ; decodeLast ( ctx , replayable , out ) ; } catch ( Signal replay ) { replay . expect ( REPLAY ) ; } catch ( DecoderException e ) { throw e ; } catch ( Exception e ) { throw new DecoderException ( e ) ; } finally { try { if ( cumulation ! = null ) { cumulation . release ( ) ; cumulation = null ; } int size = out . size ( ) ; if ( size > <int> ) { fireChannelRead ( ctx , out , size ) ; ctx . fireChannelReadComplete ( ) ; } ctx . fireChannelInactive ( ) ; } finally { out . recycle ( ) ; } } } @Override protected void callDecode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) { replayable . setCumulation ( in ) ; try { while ( in . isReadable ( ) ) { int oldReaderIndex = checkpoint = in . readerIndex ( ) ; int outSize = out . size ( ) ; if ( outSize > <int> ) { fireChannelRead ( ctx , out , outSize ) ; out . clear ( ) ; outSize = <int> ; } S oldState = state ; int oldInputLength = in . readableBytes ( ) ; try { decode ( ctx , replayable , out ) ; if ( ctx . isRemoved ( ) ) { break ; } if ( outSize = = out . size ( ) ) { if ( oldInputLength = = in . readableBytes ( ) & & oldState = = state ) { throw new DecoderException ( StringUtil . simpleClassName ( getClass ( ) ) + <str> + <str> ) ; } else { continue ; } } } catch ( Signal replay ) { replay . expect ( REPLAY ) ; if ( ctx . isRemoved ( ) ) { break ; } int checkpoint = this . checkpoint ; if ( checkpoint > = <int> ) { in . readerIndex ( checkpoint ) ; } else { } break ; } if ( oldReaderIndex = = in . readerIndex ( ) & & oldState = = state ) { throw new DecoderException ( StringUtil . simpleClassName ( getClass ( ) ) + <str> + <str> ) ; } if ( isSingleDecode ( ) ) { break ; } } } catch ( DecoderException e ) { throw e ; } catch ( Throwable cause ) { throw new DecoderException ( cause ) ; } } } 
