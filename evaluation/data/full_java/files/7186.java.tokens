package org . elasticsearch . search . aggregations . bucket . histogram ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . common . inject . internal . Nullable ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . rounding . Rounding ; import org . elasticsearch . common . util . LongHash ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . bucket . BucketsAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public class HistogramAggregator extends BucketsAggregator { private final ValuesSource . Numeric valuesSource ; private final ValueFormatter formatter ; private final Rounding rounding ; private final InternalOrder order ; private final boolean keyed ; private final long minDocCount ; private final ExtendedBounds extendedBounds ; private final InternalHistogram . Factory histogramFactory ; private final LongHash bucketOrds ; public HistogramAggregator ( String name , AggregatorFactories factories , Rounding rounding , InternalOrder order , boolean keyed , long minDocCount , @Nullable ExtendedBounds extendedBounds , @Nullable ValuesSource . Numeric valuesSource , ValueFormatter formatter , InternalHistogram . Factory < ? > histogramFactory , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . rounding = rounding ; this . order = order ; this . keyed = keyed ; this . minDocCount = minDocCount ; this . extendedBounds = extendedBounds ; this . valuesSource = valuesSource ; this . formatter = formatter ; this . histogramFactory = histogramFactory ; bucketOrds = new LongHash ( <int> , aggregationContext . bigArrays ( ) ) ; } @Override public boolean needsScores ( ) { return ( valuesSource ! = null & & valuesSource . needsScores ( ) ) | | super . needsScores ( ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { if ( valuesSource = = null ) { return LeafBucketCollector . NO_OP_COLLECTOR ; } final SortedNumericDocValues values = valuesSource . longValues ( ctx ) ; return new LeafBucketCollectorBase ( sub , values ) { @Override public void collect ( int doc , long bucket ) throws IOException { assert bucket = = <int> ; values . setDocument ( doc ) ; final int valuesCount = values . count ( ) ; long previousKey = Long . MIN_VALUE ; for ( int i = <int> ; i < valuesCount ; + + i ) { long value = values . valueAt ( i ) ; long key = rounding . roundKey ( value ) ; assert key > = previousKey ; if ( key = = previousKey ) { continue ; } long bucketOrd = bucketOrds . add ( key ) ; if ( bucketOrd < <int> ) { bucketOrd = - <int> - bucketOrd ; collectExistingBucket ( sub , doc , bucketOrd ) ; } else { collectBucket ( sub , doc , bucketOrd ) ; } previousKey = key ; } } } ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { assert owningBucketOrdinal = = <int> ; List < InternalHistogram . Bucket > buckets = new ArrayList < > ( ( int ) bucketOrds . size ( ) ) ; for ( long i = <int> ; i < bucketOrds . size ( ) ; i + + ) { buckets . add ( histogramFactory . createBucket ( rounding . valueForKey ( bucketOrds . get ( i ) ) , bucketDocCount ( i ) , bucketAggregations ( i ) , keyed , formatter ) ) ; } CollectionUtil . introSort ( buckets , InternalOrder . KEY_ASC . comparator ( ) ) ; InternalHistogram . EmptyBucketInfo emptyBucketInfo = minDocCount = = <int> ? new InternalHistogram . EmptyBucketInfo ( rounding , buildEmptySubAggregations ( ) , extendedBounds ) : null ; return histogramFactory . create ( name , buckets , order , minDocCount , emptyBucketInfo , formatter , keyed , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { InternalHistogram . EmptyBucketInfo emptyBucketInfo = minDocCount = = <int> ? new InternalHistogram . EmptyBucketInfo ( rounding , buildEmptySubAggregations ( ) , extendedBounds ) : null ; return histogramFactory . create ( name , Collections . emptyList ( ) , order , minDocCount , emptyBucketInfo , formatter , keyed , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public void doClose ( ) { Releasables . close ( bucketOrds ) ; } public static class Factory extends ValuesSourceAggregatorFactory < ValuesSource . Numeric > { private final Rounding rounding ; private final InternalOrder order ; private final boolean keyed ; private final long minDocCount ; private final ExtendedBounds extendedBounds ; private final InternalHistogram . Factory < ? > histogramFactory ; public Factory ( String name , ValuesSourceConfig < ValuesSource . Numeric > config , Rounding rounding , InternalOrder order , boolean keyed , long minDocCount , ExtendedBounds extendedBounds , InternalHistogram . Factory < ? > histogramFactory ) { super ( name , histogramFactory . type ( ) , config ) ; this . rounding = rounding ; this . order = order ; this . keyed = keyed ; this . minDocCount = minDocCount ; this . extendedBounds = extendedBounds ; this . histogramFactory = histogramFactory ; } public long minDocCount ( ) { return minDocCount ; } @Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new HistogramAggregator ( name , factories , rounding , order , keyed , minDocCount , extendedBounds , null , config . formatter ( ) , histogramFactory , aggregationContext , parent , pipelineAggregators , metaData ) ; } @Override protected Aggregator doCreateInternal ( ValuesSource . Numeric valuesSource , AggregationContext aggregationContext , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { if ( collectsFromSingleBucket = = false ) { return asMultiBucketAggregator ( this , aggregationContext , parent ) ; } ExtendedBounds roundedBounds = null ; if ( extendedBounds ! = null ) { extendedBounds . processAndValidate ( name , aggregationContext . searchContext ( ) , config . parser ( ) ) ; roundedBounds = extendedBounds . round ( rounding ) ; } return new HistogramAggregator ( name , factories , rounding , order , keyed , minDocCount , roundedBounds , valuesSource , config . formatter ( ) , histogramFactory , aggregationContext , parent , pipelineAggregators , metaData ) ; } } } 
