package org . nd4j . linalg . api . rng . distribution . impl ; import org . apache . commons . math3 . exception . NumberIsTooLargeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . util . LocalizedFormats ; import org . nd4j . linalg . api . rng . distribution . BaseDistribution ; import org . nd4j . linalg . factory . Nd4j ; public class UniformDistribution extends BaseDistribution { private double upper , lower ; public UniformDistribution ( double lower , double upper ) throws NumberIsTooLargeException { this ( Nd4j . getRandom ( ) , lower , upper ) ; } public UniformDistribution ( org . nd4j . linalg . api . rng . Random rng , double lower , double upper ) throws NumberIsTooLargeException { super ( rng ) ; if ( lower > = upper ) { throw new NumberIsTooLargeException ( LocalizedFormats . LOWER_BOUND_NOT_BELOW_UPPER_BOUND , lower , upper , false ) ; } this . lower = lower ; this . upper = upper ; } public double density ( double x ) { if ( x < lower | | x > upper ) { return <float> ; } return <int> / ( upper - lower ) ; } public double cumulativeProbability ( double x ) { if ( x < = lower ) { return <int> ; } if ( x > = upper ) { return <int> ; } return ( x - lower ) / ( upper - lower ) ; } @Override public double cumulativeProbability ( double x0 , double x1 ) throws NumberIsTooLargeException { return <int> ; } @Override public double inverseCumulativeProbability ( final double p ) throws OutOfRangeException { if ( p < <float> | | p > <float> ) { throw new OutOfRangeException ( p , <int> , <int> ) ; } return p * ( upper - lower ) + lower ; } public double getNumericalMean ( ) { return <float> * ( lower + upper ) ; } public double getNumericalVariance ( ) { double ul = upper - lower ; return ul * ul / <int> ; } public double getSupportLowerBound ( ) { return lower ; } public double getSupportUpperBound ( ) { return upper ; } public boolean isSupportLowerBoundInclusive ( ) { return true ; } public boolean isSupportUpperBoundInclusive ( ) { return true ; } public boolean isSupportConnected ( ) { return true ; } @Override public double sample ( ) { final double u = random . nextDouble ( ) ; return u * upper + ( <int> - u ) * lower ; } } 
