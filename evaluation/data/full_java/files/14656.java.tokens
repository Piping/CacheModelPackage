package org . gradle . language . base . internal . model ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . apache . commons . collections . comparators . BooleanComparator ; import org . gradle . api . Task ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . TaskContainer ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . language . base . internal . JointCompileTaskConfig ; import org . gradle . language . base . internal . LanguageSourceSetInternal ; import org . gradle . language . base . internal . SourceTransformTaskConfig ; import org . gradle . language . base . internal . registry . LanguageTransform ; import org . gradle . language . base . internal . registry . LanguageTransformContainer ; import org . gradle . platform . base . internal . BinarySpecInternal ; import java . util . * ; import static org . apache . commons . lang . StringUtils . capitalize ; public class BinarySourceTransformations { private final TaskContainer tasks ; private final Iterable < LanguageTransform < ? , ? > > prioritizedTransforms ; private final ServiceRegistry serviceRegistry ; public BinarySourceTransformations ( TaskContainer tasks , LanguageTransformContainer transforms , ServiceRegistry serviceRegistry ) { this . tasks = tasks ; this . prioritizedTransforms = prioritize ( transforms ) ; this . serviceRegistry = serviceRegistry ; } public void createTasksFor ( BinarySpecInternal binary ) { Set < LanguageSourceSetInternal > sourceSetsToCompile = getSourcesToCompile ( binary ) ; for ( LanguageTransform < ? , ? > languageTransform : prioritizedTransforms ) { if ( ! languageTransform . applyToBinary ( binary ) ) { continue ; } LanguageSourceSetInternal sourceSetToCompile ; while ( ( sourceSetToCompile = findSourceFor ( languageTransform , sourceSetsToCompile ) ) ! = null ) { sourceSetsToCompile . remove ( sourceSetToCompile ) ; final SourceTransformTaskConfig taskConfig = languageTransform . getTransformTask ( ) ; String taskName = getTransformTaskName ( languageTransform , taskConfig , binary , sourceSetToCompile ) ; Task task = tasks . create ( taskName , taskConfig . getTaskType ( ) ) ; taskConfig . configureTask ( task , binary , sourceSetToCompile , serviceRegistry ) ; task . dependsOn ( sourceSetToCompile ) ; binary . getTasks ( ) . add ( task ) ; if ( binary . hasCodependentSources ( ) & & taskConfig instanceof JointCompileTaskConfig ) { JointCompileTaskConfig jointCompileTaskConfig = ( JointCompileTaskConfig ) taskConfig ; Iterator < LanguageSourceSetInternal > candidateSourceSets = sourceSetsToCompile . iterator ( ) ; while ( candidateSourceSets . hasNext ( ) ) { LanguageSourceSetInternal candidate = candidateSourceSets . next ( ) ; if ( jointCompileTaskConfig . canTransform ( candidate ) ) { jointCompileTaskConfig . configureAdditionalTransform ( task , candidate ) ; candidateSourceSets . remove ( ) ; } } } } } } private Iterable < LanguageTransform < ? , ? > > prioritize ( LanguageTransformContainer languageTransforms ) { List < LanguageTransform < ? , ? > > prioritized = Lists . newArrayList ( languageTransforms ) ; Collections . sort ( prioritized , new Comparator < LanguageTransform < ? , ? > > ( ) { @Override public int compare ( LanguageTransform < ? , ? > o1 , LanguageTransform < ? , ? > o2 ) { boolean joint1 = o1 . getTransformTask ( ) instanceof JointCompileTaskConfig ; boolean joint2 = o2 . getTransformTask ( ) instanceof JointCompileTaskConfig ; return new BooleanComparator ( true ) . compare ( joint1 , joint2 ) ; } } ) ; return prioritized ; } private Set < LanguageSourceSetInternal > getSourcesToCompile ( BinarySpecInternal binary ) { return Sets . newLinkedHashSet ( binary . getInputs ( ) . withType ( LanguageSourceSetInternal . class ) . matching ( new Spec < LanguageSourceSetInternal > ( ) { @Override public boolean isSatisfiedBy ( LanguageSourceSetInternal element ) { return element . getMayHaveSources ( ) ; } } ) ) ; } private String getTransformTaskName ( LanguageTransform < ? , ? > transform , SourceTransformTaskConfig taskConfig , BinarySpecInternal binary , LanguageSourceSetInternal sourceSetToCompile ) { if ( binary . hasCodependentSources ( ) & & taskConfig instanceof JointCompileTaskConfig ) { return taskConfig . getTaskPrefix ( ) + capitalize ( binary . getProjectScopedName ( ) ) + capitalize ( transform . getClass ( ) . getSimpleName ( ) ) ; } return taskConfig . getTaskPrefix ( ) + capitalize ( binary . getProjectScopedName ( ) ) + capitalize ( sourceSetToCompile . getProjectScopedName ( ) ) ; } private LanguageSourceSetInternal findSourceFor ( LanguageTransform < ? , ? > languageTransform , Set < LanguageSourceSetInternal > sourceSetsToCompile ) { for ( LanguageSourceSetInternal candidate : sourceSetsToCompile ) { if ( languageTransform . getSourceSetType ( ) . isInstance ( candidate ) ) { return candidate ; } } return null ; } } 
