package org . apache . cassandra . stress . settings ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; abstract class OptionMulti extends Option { private static final Pattern ARGS = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; private final class Delegate extends GroupedOptions { @Override public List < ? extends Option > options ( ) { if ( collectAsMap = = null ) return OptionMulti . this . options ( ) ; List < Option > options = new ArrayList < > ( OptionMulti . this . options ( ) ) ; options . add ( collectAsMap ) ; return options ; } } protected abstract List < ? extends Option > options ( ) ; public Map < String , String > extraOptions ( ) { return collectAsMap = = null ? new HashMap < String , String > ( ) : collectAsMap . options ; } private final String name ; private final Pattern pattern ; private final String description ; private final Delegate delegate = new Delegate ( ) ; private final CollectAsMap collectAsMap ; public OptionMulti ( String name , String description , boolean collectExtraOptionsInMap ) { this . name = name ; pattern = Pattern . compile ( name + <str> , Pattern . CASE_INSENSITIVE ) ; this . description = description ; this . collectAsMap = collectExtraOptionsInMap ? new CollectAsMap ( ) : null ; } @Override public boolean accept ( String param ) { Matcher m = pattern . matcher ( param ) ; if ( ! m . matches ( ) ) return false ; m = ARGS . matcher ( m . group ( <int> ) ) ; int last = - <int> ; while ( m . find ( ) ) { if ( m . start ( ) ! = last + <int> ) throw new IllegalArgumentException ( <str> + name + <str> + param ) ; last = m . end ( ) ; if ( ! delegate . accept ( m . group ( ) ) ) { throw new IllegalArgumentException ( <str> + name + <str> + m . group ( ) ) ; } } return true ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( name ) ; sb . append ( <str> ) ; for ( Option option : delegate . options ( ) ) { sb . append ( option ) ; sb . append ( <str> ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } @Override public String shortDisplay ( ) { return ( happy ( ) ? <str> : <str> ) + name + <str> + ( happy ( ) ? <str> : <str> ) ; } @Override public String longDisplay ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( name ) ; sb . append ( <str> ) ; for ( Option opt : delegate . options ( ) ) { sb . append ( opt . shortDisplay ( ) ) ; } sb . append ( <str> ) ; sb . append ( description ) ; return sb . toString ( ) ; } @Override public List < String > multiLineDisplay ( ) { final List < String > r = new ArrayList < > ( ) ; for ( Option option : options ( ) ) r . add ( option . longDisplay ( ) ) ; return r ; } @Override boolean happy ( ) { return delegate . happy ( ) ; } private static final class CollectAsMap extends Option { static final String description = <str> ; Map < String , String > options = new LinkedHashMap < > ( ) ; boolean accept ( String param ) { String [ ] args = param . split ( <str> ) ; if ( args . length = = <int> & & args [ <int> ] . length ( ) > <int> & & args [ <int> ] . length ( ) > <int> ) { if ( options . put ( args [ <int> ] , args [ <int> ] ) ! = null ) throw new IllegalArgumentException ( args [ <int> ] + <str> ) ; return true ; } return false ; } boolean happy ( ) { return true ; } String shortDisplay ( ) { return <str> ; } String longDisplay ( ) { return GroupedOptions . formatLong ( shortDisplay ( ) , description ) ; } List < String > multiLineDisplay ( ) { return Collections . emptyList ( ) ; } boolean setByUser ( ) { return ! options . isEmpty ( ) ; } boolean present ( ) { return ! options . isEmpty ( ) ; } } List < Option > optionsSetByUser ( ) { List < Option > r = new ArrayList < > ( ) ; for ( Option option : delegate . options ( ) ) if ( option . setByUser ( ) ) r . add ( option ) ; return r ; } List < Option > defaultOptions ( ) { List < Option > r = new ArrayList < > ( ) ; for ( Option option : delegate . options ( ) ) if ( ! option . setByUser ( ) & & option . present ( ) ) r . add ( option ) ; return r ; } boolean setByUser ( ) { for ( Option option : delegate . options ( ) ) if ( option . setByUser ( ) ) return true ; return false ; } boolean present ( ) { for ( Option option : delegate . options ( ) ) if ( option . present ( ) ) return true ; return false ; } } 
