package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . math . MathPreconditions . checkNoOverflow ; import static com . google . common . math . MathPreconditions . checkNonNegative ; import static com . google . common . math . MathPreconditions . checkPositive ; import static com . google . common . math . MathPreconditions . checkRoundingUnnecessary ; import static java . lang . Math . abs ; import static java . lang . Math . min ; import static java . math . RoundingMode . HALF_EVEN ; import static java . math . RoundingMode . HALF_UP ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . primitives . UnsignedLongs ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible ( emulated = true ) public final class LongMath { public static boolean isPowerOfTwo ( long x ) { return x > <int> & ( x & ( x - <int> ) ) = = <int> ; } @VisibleForTesting static int lessThanBranchFree ( long x , long y ) { return ( int ) ( ~ ~ ( x - y ) > > > ( Long . SIZE - <int> ) ) ; } @SuppressWarnings ( <str> ) public static int log2 ( long x , RoundingMode mode ) { checkPositive ( <str> , x ) ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; case DOWN : case FLOOR : return ( Long . SIZE - <int> ) - Long . numberOfLeadingZeros ( x ) ; case UP : case CEILING : return Long . SIZE - Long . numberOfLeadingZeros ( x - <int> ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : int leadingZeros = Long . numberOfLeadingZeros ( x ) ; long cmp = MAX_POWER_OF_SQRT2_UNSIGNED > > > leadingZeros ; int logFloor = ( Long . SIZE - <int> ) - leadingZeros ; return logFloor + lessThanBranchFree ( cmp , x ) ; default: throw new AssertionError ( <str> ) ; } } @VisibleForTesting static final long MAX_POWER_OF_SQRT2_UNSIGNED = <hex> ; @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static int log10 ( long x , RoundingMode mode ) { checkPositive ( <str> , x ) ; int logFloor = log10Floor ( x ) ; long floorPow = powersOf10 [ logFloor ] ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( x = = floorPow ) ; case FLOOR : case DOWN : return logFloor ; case CEILING : case UP : return logFloor + lessThanBranchFree ( floorPow , x ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : return logFloor + lessThanBranchFree ( halfPowersOf10 [ logFloor ] , x ) ; default : throw new AssertionError ( ) ; } } @GwtIncompatible ( <str> ) static int log10Floor ( long x ) { int y = maxLog10ForLeadingZeros [ Long . numberOfLeadingZeros ( x ) ] ; return y - lessThanBranchFree ( x , powersOf10 [ y ] ) ; } @VisibleForTesting static final byte [ ] maxLog10ForLeadingZeros = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @GwtIncompatible ( <str> ) @VisibleForTesting static final long [ ] powersOf10 = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @GwtIncompatible ( <str> ) @VisibleForTesting static final long [ ] halfPowersOf10 = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @GwtIncompatible ( <str> ) public static long pow ( long b , int k ) { checkNonNegative ( <str> , k ) ; if ( - <int> < = b & & b < = <int> ) { switch ( ( int ) b ) { case <int> : return ( k = = <int> ) ? <int> : <int> ; case <int> : return <int> ; case ( - <int> ) : return ( ( k & <int> ) = = <int> ) ? <int> : - <int> ; case <int> : return ( k < Long . SIZE ) ? <int> < < k : <int> ; case ( - <int> ) : if ( k < Long . SIZE ) { return ( ( k & <int> ) = = <int> ) ? <int> < < k : - ( <int> < < k ) ; } else { return <int> ; } default : throw new AssertionError ( ) ; } } for ( long accum = <int> ; ; k > > = <int> ) { switch ( k ) { case <int> : return accum ; case <int> : return accum * b ; default : accum * = ( ( k & <int> ) = = <int> ) ? <int> : b ; b * = b ; } } } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static long sqrt ( long x , RoundingMode mode ) { checkNonNegative ( <str> , x ) ; if ( fitsInInt ( x ) ) { return IntMath . sqrt ( ( int ) x , mode ) ; } long guess = ( long ) Math . sqrt ( x ) ; long guessSquared = guess * guess ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( guessSquared = = x ) ; return guess ; case FLOOR : case DOWN : if ( x < guessSquared ) { return guess - <int> ; } return guess ; case CEILING : case UP : if ( x > guessSquared ) { return guess + <int> ; } return guess ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : long sqrtFloor = guess - ( ( x < guessSquared ) ? <int> : <int> ) ; long halfSquare = sqrtFloor * sqrtFloor + sqrtFloor ; return sqrtFloor + lessThanBranchFree ( halfSquare , x ) ; default : throw new AssertionError ( ) ; } } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static long divide ( long p , long q , RoundingMode mode ) { checkNotNull ( mode ) ; long div = p / q ; long rem = p - q * div ; if ( rem = = <int> ) { return div ; } int signum = <int> | ( int ) ( ( p ^ q ) > > ( Long . SIZE - <int> ) ) ; boolean increment ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( rem = = <int> ) ; case DOWN : increment = false ; break ; case UP : increment = true ; break ; case CEILING : increment = signum > <int> ; break ; case FLOOR : increment = signum < <int> ; break ; case HALF_EVEN : case HALF_DOWN : case HALF_UP : long absRem = abs ( rem ) ; long cmpRemToHalfDivisor = absRem - ( abs ( q ) - absRem ) ; if ( cmpRemToHalfDivisor = = <int> ) { increment = ( mode = = HALF_UP | ( mode = = HALF_EVEN & ( div & <int> ) ! = <int> ) ) ; } else { increment = cmpRemToHalfDivisor > <int> ; } break ; default : throw new AssertionError ( ) ; } return increment ? div + signum : div ; } @GwtIncompatible ( <str> ) public static int mod ( long x , int m ) { return ( int ) mod ( x , ( long ) m ) ; } @GwtIncompatible ( <str> ) public static long mod ( long x , long m ) { if ( m < = <int> ) { throw new ArithmeticException ( <str> ) ; } long result = x % m ; return ( result > = <int> ) ? result : result + m ; } public static long gcd ( long a , long b ) { checkNonNegative ( <str> , a ) ; checkNonNegative ( <str> , b ) ; if ( a = = <int> ) { return b ; } else if ( b = = <int> ) { return a ; } int aTwos = Long . numberOfTrailingZeros ( a ) ; a > > = aTwos ; int bTwos = Long . numberOfTrailingZeros ( b ) ; b > > = bTwos ; while ( a ! = b ) { long delta = a - b ; long minDeltaOrZero = delta & ( delta > > ( Long . SIZE - <int> ) ) ; a = delta - minDeltaOrZero - minDeltaOrZero ; b + = minDeltaOrZero ; a > > = Long . numberOfTrailingZeros ( a ) ; } return a < < min ( aTwos , bTwos ) ; } @GwtIncompatible ( <str> ) public static long checkedAdd ( long a , long b ) { long result = a + b ; checkNoOverflow ( ( a ^ b ) < <int> | ( a ^ result ) > = <int> ) ; return result ; } @GwtIncompatible ( <str> ) public static long checkedSubtract ( long a , long b ) { long result = a - b ; checkNoOverflow ( ( a ^ b ) > = <int> | ( a ^ result ) > = <int> ) ; return result ; } @GwtIncompatible ( <str> ) public static long checkedMultiply ( long a , long b ) { int leadingZeros = Long . numberOfLeadingZeros ( a ) + Long . numberOfLeadingZeros ( ~ a ) + Long . numberOfLeadingZeros ( b ) + Long . numberOfLeadingZeros ( ~ b ) ; if ( leadingZeros > Long . SIZE + <int> ) { return a * b ; } checkNoOverflow ( leadingZeros > = Long . SIZE ) ; checkNoOverflow ( a > = <int> | b ! = Long . MIN_VALUE ) ; long result = a * b ; checkNoOverflow ( a = = <int> | | result / a = = b ) ; return result ; } @GwtIncompatible ( <str> ) public static long checkedPow ( long b , int k ) { checkNonNegative ( <str> , k ) ; if ( b > = - <int> & b < = <int> ) { switch ( ( int ) b ) { case <int> : return ( k = = <int> ) ? <int> : <int> ; case <int> : return <int> ; case ( - <int> ) : return ( ( k & <int> ) = = <int> ) ? <int> : - <int> ; case <int> : checkNoOverflow ( k < Long . SIZE - <int> ) ; return <int> < < k ; case ( - <int> ) : checkNoOverflow ( k < Long . SIZE ) ; return ( ( k & <int> ) = = <int> ) ? ( <int> < < k ) : ( - <int> < < k ) ; default : throw new AssertionError ( ) ; } } long accum = <int> ; while ( true ) { switch ( k ) { case <int> : return accum ; case <int> : return checkedMultiply ( accum , b ) ; default : if ( ( k & <int> ) ! = <int> ) { accum = checkedMultiply ( accum , b ) ; } k > > = <int> ; if ( k > <int> ) { checkNoOverflow ( - FLOOR_SQRT_MAX_LONG < = b & & b < = FLOOR_SQRT_MAX_LONG ) ; b * = b ; } } } } @VisibleForTesting static final long FLOOR_SQRT_MAX_LONG = <int> ; @GwtIncompatible ( <str> ) public static long factorial ( int n ) { checkNonNegative ( <str> , n ) ; return ( n < factorials . length ) ? factorials [ n ] : Long . MAX_VALUE ; } static final long [ ] factorials = { <int> , <int> , <int> * <int> , <int> * <int> * <int> , <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> , <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> * <int> } ; public static long binomial ( int n , int k ) { checkNonNegative ( <str> , n ) ; checkNonNegative ( <str> , k ) ; checkArgument ( k < = n , <str> , k , n ) ; if ( k > ( n > > <int> ) ) { k = n - k ; } switch ( k ) { case <int> : return <int> ; case <int> : return n ; default : if ( n < factorials . length ) { return factorials [ n ] / ( factorials [ k ] * factorials [ n - k ] ) ; } else if ( k > = biggestBinomials . length | | n > biggestBinomials [ k ] ) { return Long . MAX_VALUE ; } else if ( k < biggestSimpleBinomials . length & & n < = biggestSimpleBinomials [ k ] ) { long result = n - - ; for ( int i = <int> ; i < = k ; n - - , i + + ) { result * = n ; result / = i ; } return result ; } else { int nBits = LongMath . log2 ( n , RoundingMode . CEILING ) ; long result = <int> ; long numerator = n - - ; long denominator = <int> ; int numeratorBits = nBits ; for ( int i = <int> ; i < = k ; i + + , n - - ) { if ( numeratorBits + nBits < Long . SIZE - <int> ) { numerator * = n ; denominator * = i ; numeratorBits + = nBits ; } else { result = multiplyFraction ( result , numerator , denominator ) ; numerator = n ; denominator = i ; numeratorBits = nBits ; } } return multiplyFraction ( result , numerator , denominator ) ; } } } static long multiplyFraction ( long x , long numerator , long denominator ) { if ( x = = <int> ) { return numerator / denominator ; } long commonDivisor = gcd ( x , denominator ) ; x / = commonDivisor ; denominator / = commonDivisor ; return x * ( numerator / denominator ) ; } static final int [ ] biggestBinomials = { Integer . MAX_VALUE , Integer . MAX_VALUE , Integer . MAX_VALUE , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @VisibleForTesting static final int [ ] biggestSimpleBinomials = { Integer . MAX_VALUE , Integer . MAX_VALUE , Integer . MAX_VALUE , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; static boolean fitsInInt ( long x ) { return ( int ) x = = x ; } public static long mean ( long x , long y ) { return ( x & y ) + ( ( x ^ y ) > > <int> ) ; } private static final long [ ] [ ] millerRabinBaseSets = { { <int> , <int> } , { <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> , <int> } , { Long . MAX_VALUE , <int> , <int> , <int> , <int> , <int> , <int> , <int> } } ; private enum MillerRabinTester { SMALL { @Override long mulMod ( long a , long b , long m ) { return ( a * b ) % m ; } @Override long squareMod ( long a , long m ) { return ( a * a ) % m ; } } , LARGE { private long plusMod ( long a , long b , long m ) { return ( a > = m - b ) ? ( a + b - m ) : ( a + b ) ; } private long times2ToThe32Mod ( long a , long m ) { int remainingPowersOf2 = <int> ; do { int shift = Math . min ( remainingPowersOf2 , Long . numberOfLeadingZeros ( a ) ) ; a = UnsignedLongs . remainder ( a < < shift , m ) ; remainingPowersOf2 - = shift ; } while ( remainingPowersOf2 > <int> ) ; return a ; } @Override long mulMod ( long a , long b , long m ) { long aHi = a > > > <int> ; long bHi = b > > > <int> ; long aLo = a & <hex> ; long bLo = b & <hex> ; long result = times2ToThe32Mod ( aHi * bHi , m ) ; result + = aHi * bLo ; if ( result < <int> ) { result = UnsignedLongs . remainder ( result , m ) ; } result + = aLo * bHi ; result = times2ToThe32Mod ( result , m ) ; return plusMod ( result , UnsignedLongs . remainder ( aLo * bLo , m ) , m ) ; } @Override long squareMod ( long a , long m ) { long aHi = a > > > <int> ; long aLo = a & <hex> ; long result = times2ToThe32Mod ( aHi * aHi , m ) ; long hiLo = aHi * aLo * <int> ; if ( hiLo < <int> ) { hiLo = UnsignedLongs . remainder ( hiLo , m ) ; } result + = hiLo ; result = times2ToThe32Mod ( result , m ) ; return plusMod ( result , UnsignedLongs . remainder ( aLo * aLo , m ) , m ) ; } } ; static boolean test ( long base , long n ) { return ( ( n < = FLOOR_SQRT_MAX_LONG ) ? SMALL : LARGE ) . testWitness ( base , n ) ; } abstract long mulMod ( long a , long b , long m ) ; abstract long squareMod ( long a , long m ) ; private long powMod ( long a , long p , long m ) { long res = <int> ; for ( ; p ! = <int> ; p > > = <int> ) { if ( ( p & <int> ) ! = <int> ) { res = mulMod ( res , a , m ) ; } a = squareMod ( a , m ) ; } return res ; } private boolean testWitness ( long base , long n ) { int r = Long . numberOfTrailingZeros ( n - <int> ) ; long d = ( n - <int> ) > > r ; base % = n ; if ( base = = <int> ) { return true ; } long a = powMod ( base , d , n ) ; if ( a = = <int> ) { return true ; } int j = <int> ; while ( a ! = n - <int> ) { if ( + + j = = r ) { return false ; } a = squareMod ( a , n ) ; } return true ; } } private LongMath ( ) { } } 
