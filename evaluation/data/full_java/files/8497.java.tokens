package org . elasticsearch . search . builder ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . inject . multibindings . Multibinder ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . NamedWriteableAwareStreamInput ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . settings . SettingsModule ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . index . query . AbstractQueryTestCase ; import org . elasticsearch . index . query . EmptyQueryBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . QueryParseContext ; import org . elasticsearch . index . query . functionscore . ScoreFunctionParser ; import org . elasticsearch . indices . IndicesModule ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . script . Script ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . fetch . innerhits . InnerHitsBuilder ; import org . elasticsearch . search . fetch . innerhits . InnerHitsBuilder . InnerHit ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import org . elasticsearch . search . highlight . HighlightBuilder ; import org . elasticsearch . search . rescore . RescoreBuilder ; import org . elasticsearch . search . sort . SortBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . search . suggest . SuggestBuilder ; import org . elasticsearch . search . suggest . SuggestBuilders ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolModule ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . Matchers . equalTo ; public class SearchSourceBuilderTests extends ESTestCase { private static Injector injector ; private static NamedWriteableRegistry namedWriteableRegistry ; private static IndicesQueriesRegistry indicesQueriesRegistry ; @BeforeClass public static void init ( ) throws IOException { Settings settings = Settings . settingsBuilder ( ) . put ( <str> , SearchSourceBuilderTests . class . toString ( ) ) . put ( <str> , createTempDir ( ) ) . build ( ) ; injector = new ModulesBuilder ( ) . add ( new SettingsModule ( settings , new SettingsFilter ( settings ) ) , new ThreadPoolModule ( new ThreadPool ( settings ) ) , new IndicesModule ( ) { @Override public void configure ( ) { bindQueryParsersExtension ( ) ; } } , new AbstractModule ( ) { @Override protected void configure ( ) { Multibinder . newSetBinder ( binder ( ) , ScoreFunctionParser . class ) ; bind ( NamedWriteableRegistry . class ) . asEagerSingleton ( ) ; } } ) . createInjector ( ) ; indicesQueriesRegistry = injector . getInstance ( IndicesQueriesRegistry . class ) ; namedWriteableRegistry = injector . getInstance ( NamedWriteableRegistry . class ) ; } @AfterClass public static void afterClass ( ) throws Exception { terminate ( injector . getInstance ( ThreadPool . class ) ) ; injector = null ; namedWriteableRegistry = null ; indicesQueriesRegistry = null ; } protected final SearchSourceBuilder createSearchSourceBuilder ( ) throws IOException { SearchSourceBuilder builder = new SearchSourceBuilder ( ) ; if ( randomBoolean ( ) ) { builder . from ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { builder . size ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { builder . explain ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { builder . version ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { builder . trackScores ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { builder . minScore ( randomFloat ( ) * <int> ) ; } if ( randomBoolean ( ) ) { builder . timeout ( new TimeValue ( randomIntBetween ( <int> , <int> ) , randomFrom ( TimeUnit . values ( ) ) ) ) ; } if ( randomBoolean ( ) ) { builder . terminateAfter ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { int fieldsSize = randomInt ( <int> ) ; List < String > fields = new ArrayList < > ( fieldsSize ) ; for ( int i = <int> ; i < fieldsSize ; i + + ) { fields . add ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } builder . fields ( fields ) ; } if ( randomBoolean ( ) ) { int fieldDataFieldsSize = randomInt ( <int> ) ; for ( int i = <int> ; i < fieldDataFieldsSize ; i + + ) { builder . fieldDataField ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } } if ( randomBoolean ( ) ) { int scriptFieldsSize = randomInt ( <int> ) ; for ( int i = <int> ; i < scriptFieldsSize ; i + + ) { if ( randomBoolean ( ) ) { builder . scriptField ( randomAsciiOfLengthBetween ( <int> , <int> ) , new Script ( <str> ) , randomBoolean ( ) ) ; } else { builder . scriptField ( randomAsciiOfLengthBetween ( <int> , <int> ) , new Script ( <str> ) ) ; } } } if ( randomBoolean ( ) ) { FetchSourceContext fetchSourceContext ; int branch = randomInt ( <int> ) ; String [ ] includes = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < includes . length ; i + + ) { includes [ i ] = randomAsciiOfLengthBetween ( <int> , <int> ) ; } String [ ] excludes = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < excludes . length ; i + + ) { excludes [ i ] = randomAsciiOfLengthBetween ( <int> , <int> ) ; } switch ( branch ) { case <int> : fetchSourceContext = new FetchSourceContext ( randomBoolean ( ) ) ; break ; case <int> : fetchSourceContext = new FetchSourceContext ( includes , excludes ) ; break ; case <int> : fetchSourceContext = new FetchSourceContext ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; case <int> : fetchSourceContext = new FetchSourceContext ( true , includes , excludes ) ; break ; case <int> : fetchSourceContext = new FetchSourceContext ( includes ) ; break ; case <int> : fetchSourceContext = new FetchSourceContext ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; default : throw new IllegalStateException ( ) ; } builder . fetchSource ( fetchSourceContext ) ; } if ( randomBoolean ( ) ) { int size = randomIntBetween ( <int> , <int> ) ; List < String > statsGroups = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { statsGroups . add ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } builder . stats ( statsGroups ) ; } if ( randomBoolean ( ) ) { int indexBoostSize = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < indexBoostSize ; i + + ) { builder . indexBoost ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomFloat ( ) * <int> ) ; } } if ( randomBoolean ( ) ) { builder . query ( QueryBuilders . termQuery ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ; } if ( randomBoolean ( ) ) { builder . postFilter ( QueryBuilders . termQuery ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ; } if ( randomBoolean ( ) ) { int numSorts = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numSorts ; i + + ) { int branch = randomInt ( <int> ) ; switch ( branch ) { case <int> : builder . sort ( SortBuilders . fieldSort ( randomAsciiOfLengthBetween ( <int> , <int> ) ) . order ( randomFrom ( SortOrder . values ( ) ) ) ) ; break ; case <int> : builder . sort ( SortBuilders . geoDistanceSort ( randomAsciiOfLengthBetween ( <int> , <int> ) ) . geohashes ( AbstractQueryTestCase . randomGeohash ( <int> , <int> ) ) . order ( randomFrom ( SortOrder . values ( ) ) ) ) ; break ; case <int> : builder . sort ( SortBuilders . scoreSort ( ) . order ( randomFrom ( SortOrder . values ( ) ) ) ) ; break ; case <int> : builder . sort ( SortBuilders . scriptSort ( new Script ( <str> ) , <str> ) . order ( randomFrom ( SortOrder . values ( ) ) ) ) ; break ; case <int> : builder . sort ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; case <int> : builder . sort ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomFrom ( SortOrder . values ( ) ) ) ; break ; } } } if ( randomBoolean ( ) ) { builder . highlighter ( new HighlightBuilder ( ) . field ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ; } if ( randomBoolean ( ) ) { builder . suggest ( new SuggestBuilder ( ) . setText ( randomAsciiOfLengthBetween ( <int> , <int> ) ) . addSuggestion ( SuggestBuilders . termSuggestion ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ) ; } if ( randomBoolean ( ) ) { InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder ( ) ; InnerHit innerHit = new InnerHit ( ) ; innerHit . field ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; innerHitsBuilder . addNestedInnerHits ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) , innerHit ) ; builder . innerHits ( innerHitsBuilder ) ; } if ( randomBoolean ( ) ) { int numRescores = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numRescores ; i + + ) { RescoreBuilder rescoreBuilder = new RescoreBuilder ( ) ; rescoreBuilder . rescorer ( RescoreBuilder . queryRescorer ( QueryBuilders . termQuery ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ) ; builder . addRescorer ( rescoreBuilder ) ; } } if ( randomBoolean ( ) ) { builder . aggregation ( AggregationBuilders . avg ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ; } if ( true ) { XContentBuilder xContentBuilder = XContentFactory . jsonBuilder ( ) ; xContentBuilder . startObject ( ) ; xContentBuilder . field ( <str> , randomAsciiOfLengthBetween ( <int> , <int> ) ) ; xContentBuilder . endObject ( ) ; builder . ext ( xContentBuilder ) ; } return builder ; } public void testFromXContent ( ) throws IOException { SearchSourceBuilder testSearchSourceBuilder = createSearchSourceBuilder ( ) ; XContentBuilder builder = XContentFactory . contentBuilder ( randomFrom ( XContentType . values ( ) ) ) ; if ( randomBoolean ( ) ) { builder . prettyPrint ( ) ; } testSearchSourceBuilder . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; assertParseSearchSource ( testSearchSourceBuilder , builder . bytes ( ) ) ; } private void assertParseSearchSource ( SearchSourceBuilder testBuilder , BytesReference searchSourceAsBytes ) throws IOException { XContentParser parser = XContentFactory . xContent ( searchSourceAsBytes ) . createParser ( searchSourceAsBytes ) ; QueryParseContext parseContext = createParseContext ( parser ) ; parseContext . reset ( parser ) ; if ( randomBoolean ( ) ) { parser . nextToken ( ) ; } SearchSourceBuilder newBuilder = SearchSourceBuilder . parseSearchSource ( parser , parseContext ) ; assertNotSame ( testBuilder , newBuilder ) ; assertEquals ( testBuilder , newBuilder ) ; assertEquals ( testBuilder . hashCode ( ) , newBuilder . hashCode ( ) ) ; } private static QueryParseContext createParseContext ( XContentParser parser ) { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . reset ( parser ) ; context . parseFieldMatcher ( ParseFieldMatcher . STRICT ) ; return context ; } public void testSerialization ( ) throws IOException { SearchSourceBuilder testBuilder = createSearchSourceBuilder ( ) ; try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { testBuilder . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { SearchSourceBuilder deserializedBuilder = SearchSourceBuilder . readSearchSourceFrom ( in ) ; assertEquals ( deserializedBuilder , testBuilder ) ; assertEquals ( deserializedBuilder . hashCode ( ) , testBuilder . hashCode ( ) ) ; assertNotSame ( deserializedBuilder , testBuilder ) ; } } } public void testEqualsAndHashcode ( ) throws IOException { SearchSourceBuilder firstBuilder = createSearchSourceBuilder ( ) ; assertFalse ( <str> , firstBuilder . equals ( null ) ) ; assertFalse ( <str> , firstBuilder . equals ( <str> ) ) ; assertTrue ( <str> , firstBuilder . equals ( firstBuilder ) ) ; assertThat ( <str> , firstBuilder . hashCode ( ) , equalTo ( firstBuilder . hashCode ( ) ) ) ; SearchSourceBuilder secondBuilder = copyBuilder ( firstBuilder ) ; assertTrue ( <str> , secondBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , firstBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , secondBuilder . equals ( firstBuilder ) ) ; assertThat ( <str> , secondBuilder . hashCode ( ) , equalTo ( firstBuilder . hashCode ( ) ) ) ; SearchSourceBuilder thirdBuilder = copyBuilder ( secondBuilder ) ; assertTrue ( <str> , thirdBuilder . equals ( thirdBuilder ) ) ; assertTrue ( <str> , secondBuilder . equals ( thirdBuilder ) ) ; assertThat ( <str> , secondBuilder . hashCode ( ) , equalTo ( thirdBuilder . hashCode ( ) ) ) ; assertTrue ( <str> , firstBuilder . equals ( thirdBuilder ) ) ; assertThat ( <str> , firstBuilder . hashCode ( ) , equalTo ( thirdBuilder . hashCode ( ) ) ) ; assertTrue ( <str> , thirdBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , thirdBuilder . equals ( firstBuilder ) ) ; } protected SearchSourceBuilder copyBuilder ( SearchSourceBuilder builder ) throws IOException { try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { builder . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { return SearchSourceBuilder . readSearchSourceFrom ( in ) ; } } } public void testParseIncludeExclude ( ) throws IOException { { String restContent = <str> ; try ( XContentParser parser = XContentFactory . xContent ( restContent ) . createParser ( restContent ) ) { SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder . parseSearchSource ( parser , createParseContext ( parser ) ) ; assertArrayEquals ( new String [ ] { <str> } , searchSourceBuilder . fetchSource ( ) . excludes ( ) ) ; assertArrayEquals ( new String [ ] { <str> } , searchSourceBuilder . fetchSource ( ) . includes ( ) ) ; } } { String restContent = <str> ; try ( XContentParser parser = XContentFactory . xContent ( restContent ) . createParser ( restContent ) ) { SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder . parseSearchSource ( parser , createParseContext ( parser ) ) ; assertArrayEquals ( new String [ ] { } , searchSourceBuilder . fetchSource ( ) . excludes ( ) ) ; assertArrayEquals ( new String [ ] { } , searchSourceBuilder . fetchSource ( ) . includes ( ) ) ; assertFalse ( searchSourceBuilder . fetchSource ( ) . fetchSource ( ) ) ; } } } public void testParseSort ( ) throws IOException { { String restContent = <str> ; try ( XContentParser parser = XContentFactory . xContent ( restContent ) . createParser ( restContent ) ) { SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder . parseSearchSource ( parser , createParseContext ( parser ) ) ; assertEquals ( <int> , searchSourceBuilder . sorts ( ) . size ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; } } { String restContent = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; try ( XContentParser parser = XContentFactory . xContent ( restContent ) . createParser ( restContent ) ) { SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder . parseSearchSource ( parser , createParseContext ( parser ) ) ; assertEquals ( <int> , searchSourceBuilder . sorts ( ) . size ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; assertEquals ( <str> , searchSourceBuilder . sorts ( ) . get ( <int> ) . toUtf8 ( ) ) ; } } } public void testEmptyPostFilter ( ) throws IOException { SearchSourceBuilder builder = new SearchSourceBuilder ( ) ; builder . postFilter ( EmptyQueryBuilder . PROTOTYPE ) ; String query = <str> ; assertParseSearchSource ( builder , new BytesArray ( query ) ) ; } } 
