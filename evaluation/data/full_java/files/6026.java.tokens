package org . elasticsearch . common . path ; import org . elasticsearch . common . Strings ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; public class PathTrie < T > { public interface Decoder { String decode ( String value ) ; } private final Decoder decoder ; private final TrieNode root ; private final char separator ; private T rootValue ; public PathTrie ( Decoder decoder ) { this ( <str> , <str> , decoder ) ; } public PathTrie ( char separator , String wildcard , Decoder decoder ) { this . decoder = decoder ; this . separator = separator ; root = new TrieNode ( new String ( new char [ ] { separator } ) , null , wildcard ) ; } public class TrieNode { private transient String key ; private transient T value ; private boolean isWildcard ; private final String wildcard ; private transient String namedWildcard ; private Map < String , TrieNode > children ; public TrieNode ( String key , T value , String wildcard ) { this . key = key ; this . wildcard = wildcard ; this . isWildcard = ( key . equals ( wildcard ) ) ; this . value = value ; this . children = emptyMap ( ) ; if ( isNamedWildcard ( key ) ) { namedWildcard = key . substring ( key . indexOf ( <str> ) + <int> , key . indexOf ( <str> ) ) ; } else { namedWildcard = null ; } } public void updateKeyWithNamedWildcard ( String key ) { this . key = key ; namedWildcard = key . substring ( key . indexOf ( <str> ) + <int> , key . indexOf ( <str> ) ) ; } public boolean isWildcard ( ) { return isWildcard ; } public synchronized void addChild ( TrieNode child ) { addInnerChild ( child . key , child ) ; } private void addInnerChild ( String key , TrieNode child ) { Map < String , TrieNode > newChildren = new HashMap < > ( children ) ; newChildren . put ( key , child ) ; children = unmodifiableMap ( newChildren ) ; } public TrieNode getChild ( String key ) { return children . get ( key ) ; } public synchronized void insert ( String [ ] path , int index , T value ) { if ( index > = path . length ) return ; String token = path [ index ] ; String key = token ; if ( isNamedWildcard ( token ) ) { key = wildcard ; } TrieNode node = children . get ( key ) ; if ( node = = null ) { T nodeValue = index = = path . length - <int> ? value : null ; node = new TrieNode ( token , nodeValue , wildcard ) ; addInnerChild ( key , node ) ; } else { if ( isNamedWildcard ( token ) ) { node . updateKeyWithNamedWildcard ( token ) ; } if ( index = = ( path . length - <int> ) ) { assert ( node . value = = null | | node . value = = value ) ; if ( node . value = = null ) { node . value = value ; } } } node . insert ( path , index + <int> , value ) ; } private boolean isNamedWildcard ( String key ) { return key . indexOf ( <str> ) ! = - <int> & & key . indexOf ( <str> ) ! = - <int> ; } private String namedWildcard ( ) { return namedWildcard ; } private boolean isNamedWildcard ( ) { return namedWildcard ! = null ; } public T retrieve ( String [ ] path , int index , Map < String , String > params ) { if ( index > = path . length ) return null ; String token = path [ index ] ; TrieNode node = children . get ( token ) ; boolean usedWildcard ; if ( node = = null ) { node = children . get ( wildcard ) ; if ( node = = null ) { return null ; } usedWildcard = true ; } else { if ( index + <int> = = path . length & & node . value = = null & & children . get ( wildcard ) ! = null ) { node = children . get ( wildcard ) ; usedWildcard = true ; } else { usedWildcard = token . equals ( wildcard ) ; } } put ( params , node , token ) ; if ( index = = ( path . length - <int> ) ) { return node . value ; } T res = node . retrieve ( path , index + <int> , params ) ; if ( res = = null & & ! usedWildcard ) { node = children . get ( wildcard ) ; if ( node ! = null ) { put ( params , node , token ) ; res = node . retrieve ( path , index + <int> , params ) ; } } return res ; } private void put ( Map < String , String > params , TrieNode node , String value ) { if ( params ! = null & & node . isNamedWildcard ( ) ) { params . put ( node . namedWildcard ( ) , decoder . decode ( value ) ) ; } } @Override public String toString ( ) { return key ; } } public void insert ( String path , T value ) { String [ ] strings = Strings . splitStringToArray ( path , separator ) ; if ( strings . length = = <int> ) { rootValue = value ; return ; } int index = <int> ; if ( strings . length > <int> & & strings [ <int> ] . isEmpty ( ) ) { index = <int> ; } root . insert ( strings , index , value ) ; } public T retrieve ( String path ) { return retrieve ( path , null ) ; } public T retrieve ( String path , Map < String , String > params ) { if ( path . length ( ) = = <int> ) { return rootValue ; } String [ ] strings = Strings . splitStringToArray ( path , separator ) ; if ( strings . length = = <int> ) { return rootValue ; } int index = <int> ; if ( strings . length > <int> & & strings [ <int> ] . isEmpty ( ) ) { index = <int> ; } return root . retrieve ( strings , index , params ) ; } } 
