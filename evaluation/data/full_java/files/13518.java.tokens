package org . gradle . api . tasks . compile ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; import org . gradle . api . Incubating ; import org . gradle . api . file . FileCollection ; import org . gradle . api . tasks . Input ; import org . gradle . api . tasks . Nested ; import org . gradle . api . tasks . Optional ; import org . gradle . util . SingleMessageLogger ; import java . util . List ; import java . util . Map ; public class CompileOptions extends AbstractOptions { private static final long serialVersionUID = <int> ; private static final ImmutableSet < String > EXCLUDE_FROM_ANT_PROPERTIES = ImmutableSet . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; private boolean failOnError = true ; private boolean verbose ; private boolean listFiles ; private boolean deprecation ; private boolean warnings = true ; private String encoding ; private boolean debug = true ; private DebugOptions debugOptions = new DebugOptions ( ) ; private boolean fork ; private ForkOptions forkOptions = new ForkOptions ( ) ; private boolean useDepend ; private DependOptions dependOptions = new DependOptions ( ) ; private String bootClasspath ; private String extensionDirs ; private List < String > compilerArgs = Lists . newArrayList ( ) ; private boolean incremental ; private FileCollection sourcepath ; @Input public boolean isFailOnError ( ) { return failOnError ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public boolean isVerbose ( ) { return verbose ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean isListFiles ( ) { return listFiles ; } public void setListFiles ( boolean listFiles ) { this . listFiles = listFiles ; } public boolean isDeprecation ( ) { return deprecation ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean isWarnings ( ) { return warnings ; } public void setWarnings ( boolean warnings ) { this . warnings = warnings ; } @Input @Optional public String getEncoding ( ) { return encoding ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } @Input public boolean isDebug ( ) { return debug ; } public void setDebug ( boolean debug ) { this . debug = debug ; } @Nested public DebugOptions getDebugOptions ( ) { return debugOptions ; } public void setDebugOptions ( DebugOptions debugOptions ) { this . debugOptions = debugOptions ; } public boolean isFork ( ) { return fork ; } public void setFork ( boolean fork ) { this . fork = fork ; } @Nested public ForkOptions getForkOptions ( ) { return forkOptions ; } public void setForkOptions ( ForkOptions forkOptions ) { this . forkOptions = forkOptions ; } public boolean isUseDepend ( ) { return useDepend ; } public void setUseDepend ( boolean useDepend ) { this . useDepend = useDepend ; } public DependOptions getDependOptions ( ) { return dependOptions ; } public void setDependOptions ( DependOptions dependOptions ) { this . dependOptions = dependOptions ; } @Input @Optional public String getBootClasspath ( ) { return bootClasspath ; } public void setBootClasspath ( String bootClasspath ) { this . bootClasspath = bootClasspath ; } @Input @Optional public String getExtensionDirs ( ) { return extensionDirs ; } public void setExtensionDirs ( String extensionDirs ) { this . extensionDirs = extensionDirs ; } @Input public List < String > getCompilerArgs ( ) { return compilerArgs ; } public void setCompilerArgs ( List < String > compilerArgs ) { this . compilerArgs = compilerArgs ; } public CompileOptions fork ( Map < String , Object > forkArgs ) { fork = true ; forkOptions . define ( forkArgs ) ; return this ; } public CompileOptions debug ( Map < String , Object > debugArgs ) { debug = true ; debugOptions . define ( debugArgs ) ; return this ; } public CompileOptions depend ( Map < String , Object > dependArgs ) { useDepend = true ; dependOptions . define ( dependArgs ) ; return this ; } @Incubating public CompileOptions setIncremental ( boolean incremental ) { SingleMessageLogger . incubatingFeatureUsed ( <str> ) ; this . incremental = incremental ; return this ; } public Map < String , Object > optionMap ( ) { Map < String , Object > map = super . optionMap ( ) ; map . putAll ( debugOptions . optionMap ( ) ) ; map . putAll ( forkOptions . optionMap ( ) ) ; return map ; } @Override protected boolean excludeFromAntProperties ( String fieldName ) { return EXCLUDE_FROM_ANT_PROPERTIES . contains ( fieldName ) ; } @Override protected String getAntPropertyName ( String fieldName ) { if ( fieldName . equals ( <str> ) ) { return <str> ; } if ( fieldName . equals ( <str> ) ) { return <str> ; } return fieldName ; } @Override protected Object getAntPropertyValue ( String fieldName , Object value ) { if ( fieldName . equals ( <str> ) ) { return ! warnings ; } return value ; } @Incubating public boolean isIncremental ( ) { return incremental ; } @Input @Optional @Incubating public FileCollection getSourcepath ( ) { return sourcepath ; } @Incubating public void setSourcepath ( FileCollection sourcepath ) { this . sourcepath = sourcepath ; } } 
