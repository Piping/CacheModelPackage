package com . google . common . collect ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import java . lang . reflect . Array ; import java . util . Collection ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public final class ObjectArrays { static final Object [ ] EMPTY_ARRAY = new Object [ <int> ] ; private ObjectArrays ( ) { } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } public static < T > T [ ] newArray ( T [ ] reference , int length ) { return Platform . newArray ( reference , length ) ; } @GwtIncompatible ( <str> ) public static < T > T [ ] concat ( T [ ] first , T [ ] second , Class < T > type ) { T [ ] result = newArray ( type , first . length + second . length ) ; System . arraycopy ( first , <int> , result , <int> , first . length ) ; System . arraycopy ( second , <int> , result , first . length , second . length ) ; return result ; } public static < T > T [ ] concat ( @Nullable T element , T [ ] array ) { T [ ] result = newArray ( array , array . length + <int> ) ; result [ <int> ] = element ; System . arraycopy ( array , <int> , result , <int> , array . length ) ; return result ; } public static < T > T [ ] concat ( T [ ] array , @Nullable T element ) { T [ ] result = arraysCopyOf ( array , array . length + <int> ) ; result [ array . length ] = element ; return result ; } static < T > T [ ] arraysCopyOf ( T [ ] original , int newLength ) { T [ ] copy = newArray ( original , newLength ) ; System . arraycopy ( original , <int> , copy , <int> , Math . min ( original . length , newLength ) ) ; return copy ; } static < T > T [ ] toArrayImpl ( Collection < ? > c , T [ ] array ) { int size = c . size ( ) ; if ( array . length < size ) { array = newArray ( array , size ) ; } fillArray ( c , array ) ; if ( array . length > size ) { array [ size ] = null ; } return array ; } static < T > T [ ] toArrayImpl ( Object [ ] src , int offset , int len , T [ ] dst ) { checkPositionIndexes ( offset , offset + len , src . length ) ; if ( dst . length < len ) { dst = newArray ( dst , len ) ; } else if ( dst . length > len ) { dst [ len ] = null ; } System . arraycopy ( src , offset , dst , <int> , len ) ; return dst ; } static Object [ ] toArrayImpl ( Collection < ? > c ) { return fillArray ( c , new Object [ c . size ( ) ] ) ; } static Object [ ] copyAsObjectArray ( Object [ ] elements , int offset , int length ) { checkPositionIndexes ( offset , offset + length , elements . length ) ; if ( length = = <int> ) { return EMPTY_ARRAY ; } Object [ ] result = new Object [ length ] ; System . arraycopy ( elements , offset , result , <int> , length ) ; return result ; } private static Object [ ] fillArray ( Iterable < ? > elements , Object [ ] array ) { int i = <int> ; for ( Object element : elements ) { array [ i + + ] = element ; } return array ; } static void swap ( Object [ ] array , int i , int j ) { Object temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } static Object [ ] checkElementsNotNull ( Object . . . array ) { return checkElementsNotNull ( array , array . length ) ; } static Object [ ] checkElementsNotNull ( Object [ ] array , int length ) { for ( int i = <int> ; i < length ; i + + ) { checkElementNotNull ( array [ i ] , i ) ; } return array ; } static Object checkElementNotNull ( Object element , int index ) { if ( element = = null ) { throw new NullPointerException ( <str> + index ) ; } return element ; } } 
