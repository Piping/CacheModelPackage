package org . gradle . api . internal . tasks ; import groovy . lang . Closure ; import org . gradle . api . Buildable ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . Task ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . typeconversion . UnsupportedNotationException ; import org . gradle . util . GUtil ; import java . util . * ; import java . util . concurrent . Callable ; public class DefaultTaskDependency extends AbstractTaskDependency { private final Set < Object > values = new HashSet < Object > ( ) ; private final TaskResolver resolver ; public DefaultTaskDependency ( ) { this ( null ) ; } public DefaultTaskDependency ( TaskResolver resolver ) { this . resolver = resolver ; } @Override public void visitDependencies ( TaskDependencyResolveContext context ) { LinkedList < Object > queue = new LinkedList < Object > ( values ) ; while ( ! queue . isEmpty ( ) ) { Object dependency = queue . removeFirst ( ) ; if ( dependency instanceof Buildable ) { context . add ( dependency ) ; } else if ( dependency instanceof Task ) { context . add ( dependency ) ; } else if ( dependency instanceof TaskDependency ) { context . add ( dependency ) ; } else if ( dependency instanceof Closure ) { Closure closure = ( Closure ) dependency ; Object closureResult = closure . call ( context . getTask ( ) ) ; if ( closureResult ! = null ) { queue . add ( <int> , closureResult ) ; } } else if ( dependency instanceof RealizableTaskCollection ) { RealizableTaskCollection realizableTaskCollection = ( RealizableTaskCollection ) dependency ; realizableTaskCollection . realizeRuleTaskTypes ( ) ; queue . addAll ( <int> , GUtil . addToCollection ( new ArrayList < Object > ( ) , realizableTaskCollection ) ) ; } else if ( dependency instanceof Iterable ) { Iterable < ? > iterable = ( Iterable ) dependency ; queue . addAll ( <int> , GUtil . addToCollection ( new ArrayList < Object > ( ) , iterable ) ) ; } else if ( dependency instanceof Map ) { Map < ? , ? > map = ( Map ) dependency ; queue . addAll ( <int> , map . values ( ) ) ; } else if ( dependency instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) dependency ; queue . addAll ( <int> , Arrays . asList ( array ) ) ; } else if ( dependency instanceof Callable ) { Callable callable = ( Callable ) dependency ; Object callableResult ; try { callableResult = callable . call ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } if ( callableResult ! = null ) { queue . add ( <int> , callableResult ) ; } } else if ( resolver ! = null & & dependency instanceof CharSequence ) { context . add ( resolver . resolveTask ( dependency . toString ( ) ) ) ; } else { List < String > formats = new ArrayList < String > ( ) ; if ( resolver ! = null ) { formats . add ( <str> ) ; } formats . add ( <str> ) ; formats . add ( <str> ) ; formats . add ( <str> ) ; formats . add ( <str> ) ; formats . add ( <str> ) ; formats . add ( <str> ) ; throw new UnsupportedNotationException ( dependency , String . format ( <str> , dependency ) , null , formats ) ; } } } public Set < Object > getValues ( ) { return values ; } public void setValues ( Iterable < ? > values ) { this . values . clear ( ) ; for ( Object value : values ) { addValue ( value ) ; } } public DefaultTaskDependency add ( Object . . . values ) { for ( Object value : values ) { addValue ( value ) ; } return this ; } private void addValue ( Object dependency ) { if ( dependency = = null ) { throw new InvalidUserDataException ( <str> ) ; } this . values . add ( dependency ) ; } } 
