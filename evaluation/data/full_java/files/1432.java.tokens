package org . apache . cassandra . db ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . junit . Before ; import org . junit . Assume ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import com . google . common . collect . Iterators ; import org . apache . cassandra . * ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . metrics . ClearableHistogram ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . WrappedRunnable ; import static junit . framework . Assert . assertNotNull ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class ColumnFamilyStoreTest { public static final String KEYSPACE1 = <str> ; public static final String KEYSPACE2 = <str> ; public static final String CF_STANDARD1 = <str> ; public static final String CF_STANDARD2 = <str> ; public static final String CF_SUPER1 = <str> ; public static final String CF_SUPER6 = <str> ; public static final String CF_INDEX1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 ) , SchemaLoader . keysIndexCFMD ( KEYSPACE1 , CF_INDEX1 , true ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE2 , CF_STANDARD1 ) ) ; } @Before public void truncateCFS ( ) { Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD2 ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE2 ) . getColumnFamilyStore ( CF_STANDARD1 ) . truncateBlocking ( ) ; } @Test public void testTimeSortedQuery ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; ( ( ClearableHistogram ) cfs . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; Util . getAll ( Util . cmd ( cfs , <str> ) . includeRow ( <str> ) . build ( ) ) ; assertEquals ( <int> , cfs . metric . sstablesPerReadHistogram . cf . getCount ( ) ) ; } @Test public void testGetColumnWithWrongBF ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; List < Mutation > rms = new LinkedList < > ( ) ; rms . add ( new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ) ; Util . writeColumnFamily ( rms ) ; List < SSTableReader > ssTables = keyspace . getAllSSTables ( SSTableSet . LIVE ) ; assertEquals ( <int> , ssTables . size ( ) ) ; ssTables . get ( <int> ) . forceFilterFailures ( ) ; Util . assertEmpty ( Util . cmd ( cfs , <str> ) . build ( ) ) ; } @Test public void testEmptyRow ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; final ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD2 ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , FBUtilities . timestampMicros ( ) , <str> , <str> ) . applyUnsafe ( ) ; Runnable r = new WrappedRunnable ( ) { public void runMayThrow ( ) throws IOException { Row toCheck = Util . getOnlyRowUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; Iterator < Cell > iter = toCheck . cells ( ) . iterator ( ) ; assert ( Iterators . size ( iter ) = = <int> ) ; } } ; reTest ( cfs , r ) ; } @Test public void testDeleteStandardRowSticksAfterFlush ( ) throws Throwable { String keyspaceName = KEYSPACE1 ; String cfName = CF_STANDARD1 ; Keyspace keyspace = Keyspace . open ( keyspaceName ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; ByteBuffer val = ByteBufferUtil . bytes ( <str> ) ; ColumnDefinition newCol = ColumnDefinition . regularDef ( cfs . metadata , ByteBufferUtil . bytes ( <str> ) , AsciiType . instance ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; cfs . forceBlockingFlush ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; cfs . forceBlockingFlush ( ) ; assertRangeCount ( cfs , col , val , <int> ) ; } @Test public void testClearEphemeralSnapshots ( ) throws Throwable { Assume . assumeTrue ( ! FBUtilities . isWindows ( ) ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_INDEX1 ) ; cfs . clearSnapshot ( <str> ) ; int numRows = <int> ; long [ ] colValues = new long [ numRows * <int> ] ; for ( int i = <int> ; i < colValues . length ; i + = <int> ) { colValues [ i ] = ( i % <int> = = <int> ? <int> : <int> ) ; colValues [ i + <int> ] = <int> ; } ScrubTest . fillIndexCF ( cfs , false , colValues ) ; cfs . snapshot ( <str> , null , false ) ; cfs . snapshot ( <str> , null , true ) ; Map < String , Pair < Long , Long > > snapshotDetails = cfs . getSnapshotDetails ( ) ; assertEquals ( <int> , snapshotDetails . size ( ) ) ; assertTrue ( snapshotDetails . containsKey ( <str> ) ) ; assertTrue ( snapshotDetails . containsKey ( <str> ) ) ; ColumnFamilyStore . clearEphemeralSnapshots ( cfs . getDirectories ( ) ) ; snapshotDetails = cfs . getSnapshotDetails ( ) ; assertEquals ( <int> , snapshotDetails . size ( ) ) ; assertTrue ( snapshotDetails . containsKey ( <str> ) ) ; cfs . clearSnapshot ( <str> ) ; } @Test public void testBackupAfterFlush ( ) throws Throwable { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE2 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; new RowUpdateBuilder ( cfs . metadata , <int> , ByteBufferUtil . bytes ( <str> ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , ByteBufferUtil . bytes ( <str> ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; for ( int version = <int> ; version < = <int> ; + + version ) { Descriptor existing = new Descriptor ( cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) , KEYSPACE2 , CF_STANDARD1 , version ) ; Descriptor desc = new Descriptor ( Directories . getBackupsDirectory ( existing ) , KEYSPACE2 , CF_STANDARD1 , version ) ; for ( Component c : new Component [ ] { Component . DATA , Component . PRIMARY_INDEX , Component . FILTER , Component . STATS } ) assertTrue ( <str> + desc . filenameFor ( c ) , new File ( desc . filenameFor ( c ) ) . exists ( ) ) ; } } public void reTest ( ColumnFamilyStore cfs , Runnable verify ) throws Exception { verify . run ( ) ; cfs . forceBlockingFlush ( ) ; verify . run ( ) ; } private void assertRangeCount ( ColumnFamilyStore cfs , ByteBuffer col , ByteBuffer val , int count ) { assertRangeCount ( cfs , cfs . metadata . getColumnDefinition ( col ) , val , count ) ; } private void assertRangeCount ( ColumnFamilyStore cfs , ColumnDefinition col , ByteBuffer val , int count ) { int found = <int> ; if ( count ! = <int> ) { for ( FilteredPartition partition : Util . getAll ( Util . cmd ( cfs ) . filterOn ( col . name . toString ( ) , Operator . EQ , val ) . build ( ) ) ) { for ( Row r : partition ) { if ( r . getCell ( col ) . value ( ) . equals ( val ) ) + + found ; } } } assertEquals ( count , found ) ; } @Test public void testScrubDataDirectories ( ) throws Throwable { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; ColumnFamilyStore . scrubDataDirectories ( cfs . metadata ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Collection < SSTableReader > ssTables = cfs . getLiveSSTables ( ) ; assertEquals ( <int> , ssTables . size ( ) ) ; SSTableReader ssTable = ssTables . iterator ( ) . next ( ) ; String dataFileName = ssTable . descriptor . filenameFor ( Component . DATA ) ; String tmpDataFileName = ssTable . descriptor . tmpFilenameFor ( Component . DATA ) ; new File ( dataFileName ) . renameTo ( new File ( tmpDataFileName ) ) ; ssTable . selfRef ( ) . release ( ) ; ColumnFamilyStore . scrubDataDirectories ( cfs . metadata ) ; List < File > ssTableFiles = new Directories ( cfs . metadata ) . sstableLister ( Directories . OnTxnErr . THROW ) . listFiles ( ) ; assertNotNull ( ssTableFiles ) ; assertEquals ( <int> , ssTableFiles . size ( ) ) ; } } 
