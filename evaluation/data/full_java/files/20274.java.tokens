package io . netty . channel . nio ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . FileRegion ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . socket . ChannelInputShutdownEvent ; import io . netty . util . internal . StringUtil ; import java . io . IOException ; import java . nio . channels . SelectableChannel ; import java . nio . channels . SelectionKey ; public abstract class AbstractNioByteChannel extends AbstractNioChannel { private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( FileRegion . class ) + <str> ; private Runnable flushTask ; protected AbstractNioByteChannel ( Channel parent , SelectableChannel ch ) { super ( parent , ch , SelectionKey . OP_READ ) ; } @Override protected AbstractNioUnsafe newUnsafe ( ) { return new NioByteUnsafe ( ) ; } protected class NioByteUnsafe extends AbstractNioUnsafe { private void closeOnRead ( ChannelPipeline pipeline ) { SelectionKey key = selectionKey ( ) ; setInputShutdown ( ) ; if ( isOpen ( ) ) { if ( Boolean . TRUE . equals ( config ( ) . getOption ( ChannelOption . ALLOW_HALF_CLOSURE ) ) ) { key . interestOps ( key . interestOps ( ) & ~ readInterestOp ) ; pipeline . fireUserEventTriggered ( ChannelInputShutdownEvent . INSTANCE ) ; } else { close ( voidPromise ( ) ) ; } } } private void handleReadException ( ChannelPipeline pipeline , ByteBuf byteBuf , Throwable cause , boolean close , RecvByteBufAllocator . Handle allocHandle ) { if ( byteBuf ! = null ) { if ( byteBuf . isReadable ( ) ) { setReadPending ( false ) ; pipeline . fireChannelRead ( byteBuf ) ; } else { byteBuf . release ( ) ; } } allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; pipeline . fireExceptionCaught ( cause ) ; if ( close | | cause instanceof IOException ) { closeOnRead ( pipeline ) ; } } @Override public final void read ( ) { final ChannelConfig config = config ( ) ; if ( ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { removeReadOp ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final ByteBufAllocator allocator = config . getAllocator ( ) ; final RecvByteBufAllocator . Handle allocHandle = recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; ByteBuf byteBuf = null ; try { boolean needReadPendingReset = true ; do { byteBuf = allocHandle . allocate ( allocator ) ; allocHandle . lastBytesRead ( doReadBytes ( byteBuf ) ) ; if ( allocHandle . lastBytesRead ( ) < = <int> ) { byteBuf . release ( ) ; byteBuf = null ; break ; } allocHandle . incMessagesRead ( <int> ) ; if ( needReadPendingReset ) { needReadPendingReset = false ; setReadPending ( false ) ; } pipeline . fireChannelRead ( byteBuf ) ; byteBuf = null ; } while ( allocHandle . continueReading ( ) ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( allocHandle . lastBytesRead ( ) < <int> ) { closeOnRead ( pipeline ) ; } } catch ( Throwable t ) { handleReadException ( pipeline , byteBuf , t , allocHandle . lastBytesRead ( ) < <int> , allocHandle ) ; } finally { if ( ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { removeReadOp ( ) ; } } } } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { int writeSpinCount = - <int> ; boolean setOpWrite = false ; for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { clearOpWrite ( ) ; return ; } if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; int readableBytes = buf . readableBytes ( ) ; if ( readableBytes = = <int> ) { in . remove ( ) ; continue ; } boolean done = false ; long flushedAmount = <int> ; if ( writeSpinCount = = - <int> ) { writeSpinCount = config ( ) . getWriteSpinCount ( ) ; } for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { int localFlushedAmount = doWriteBytes ( buf ) ; if ( localFlushedAmount = = <int> ) { setOpWrite = true ; break ; } flushedAmount + = localFlushedAmount ; if ( ! buf . isReadable ( ) ) { done = true ; break ; } } in . progress ( flushedAmount ) ; if ( done ) { in . remove ( ) ; } else { break ; } } else if ( msg instanceof FileRegion ) { FileRegion region = ( FileRegion ) msg ; boolean done = region . transfered ( ) > = region . count ( ) ; if ( ! done ) { long flushedAmount = <int> ; if ( writeSpinCount = = - <int> ) { writeSpinCount = config ( ) . getWriteSpinCount ( ) ; } for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { long localFlushedAmount = doWriteFileRegion ( region ) ; if ( localFlushedAmount = = <int> ) { setOpWrite = true ; break ; } flushedAmount + = localFlushedAmount ; if ( region . transfered ( ) > = region . count ( ) ) { done = true ; break ; } } in . progress ( flushedAmount ) ; } if ( done ) { in . remove ( ) ; } else { break ; } } else { throw new Error ( ) ; } } incompleteWrite ( setOpWrite ) ; } @Override protected final Object filterOutboundMessage ( Object msg ) { if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; if ( buf . isDirect ( ) ) { return msg ; } return newDirectBuffer ( buf ) ; } if ( msg instanceof FileRegion ) { return msg ; } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } protected final void incompleteWrite ( boolean setOpWrite ) { if ( setOpWrite ) { setOpWrite ( ) ; } else { Runnable flushTask = this . flushTask ; if ( flushTask = = null ) { flushTask = this . flushTask = new Runnable ( ) { @Override public void run ( ) { flush ( ) ; } } ; } eventLoop ( ) . execute ( flushTask ) ; } } protected abstract long doWriteFileRegion ( FileRegion region ) throws Exception ; protected abstract int doReadBytes ( ByteBuf buf ) throws Exception ; protected abstract int doWriteBytes ( ByteBuf buf ) throws Exception ; protected final void setOpWrite ( ) { final SelectionKey key = selectionKey ( ) ; if ( ! key . isValid ( ) ) { return ; } final int interestOps = key . interestOps ( ) ; if ( ( interestOps & SelectionKey . OP_WRITE ) = = <int> ) { key . interestOps ( interestOps | SelectionKey . OP_WRITE ) ; } } protected final void clearOpWrite ( ) { final SelectionKey key = selectionKey ( ) ; if ( ! key . isValid ( ) ) { return ; } final int interestOps = key . interestOps ( ) ; if ( ( interestOps & SelectionKey . OP_WRITE ) ! = <int> ) { key . interestOps ( interestOps & ~ SelectionKey . OP_WRITE ) ; } } } 
