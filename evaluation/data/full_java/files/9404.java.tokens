package com . google . common . hash ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import static com . google . common . hash . LittleEndianByteArray . load32 ; import static com . google . common . hash . LittleEndianByteArray . load64 ; import static java . lang . Long . rotateRight ; import com . google . common . annotations . VisibleForTesting ; final class FarmHashFingerprint64 extends AbstractNonStreamingHashFunction { private static final long K0 = <hex> ; private static final long K1 = <hex> ; private static final long K2 = <hex> ; @Override public HashCode hashBytes ( byte [ ] input , int off , int len ) { checkPositionIndexes ( off , off + len , input . length ) ; return HashCode . fromLong ( fingerprint ( input , off , len ) ) ; } @Override public int bits ( ) { return <int> ; } @Override public String toString ( ) { return <str> ; } @VisibleForTesting static long fingerprint ( byte [ ] bytes , int offset , int length ) { if ( length < = <int> ) { if ( length < = <int> ) { return hashLength0to16 ( bytes , offset , length ) ; } else { return hashLength17to32 ( bytes , offset , length ) ; } } else if ( length < = <int> ) { return hashLength33To64 ( bytes , offset , length ) ; } else { return hashLength65Plus ( bytes , offset , length ) ; } } private static long shiftMix ( long val ) { return val ^ ( val > > > <int> ) ; } private static long hashLength16 ( long u , long v , long mul ) { long a = ( u ^ v ) * mul ; a ^ = ( a > > > <int> ) ; long b = ( v ^ a ) * mul ; b ^ = ( b > > > <int> ) ; b * = mul ; return b ; } private static void weakHashLength32WithSeeds ( byte [ ] bytes , int offset , long seedA , long seedB , long [ ] output ) { long part1 = load64 ( bytes , offset ) ; long part2 = load64 ( bytes , offset + <int> ) ; long part3 = load64 ( bytes , offset + <int> ) ; long part4 = load64 ( bytes , offset + <int> ) ; seedA + = part1 ; seedB = rotateRight ( seedB + seedA + part4 , <int> ) ; long c = seedA ; seedA + = part2 ; seedA + = part3 ; seedB + = rotateRight ( seedA , <int> ) ; output [ <int> ] = seedA + part4 ; output [ <int> ] = seedB + c ; } private static long hashLength0to16 ( byte [ ] bytes , int offset , int length ) { if ( length > = <int> ) { long mul = K2 + length * <int> ; long a = load64 ( bytes , offset ) + K2 ; long b = load64 ( bytes , offset + length - <int> ) ; long c = rotateRight ( b , <int> ) * mul + a ; long d = ( rotateRight ( a , <int> ) + b ) * mul ; return hashLength16 ( c , d , mul ) ; } if ( length > = <int> ) { long mul = K2 + length * <int> ; long a = load32 ( bytes , offset ) & <hex> ; return hashLength16 ( length + ( a < < <int> ) , load32 ( bytes , offset + length - <int> ) & <hex> , mul ) ; } if ( length > <int> ) { byte a = bytes [ offset ] ; byte b = bytes [ offset + ( length > > <int> ) ] ; byte c = bytes [ offset + ( length - <int> ) ] ; int y = ( a & <hex> ) + ( ( b & <hex> ) < < <int> ) ; int z = length + ( ( c & <hex> ) < < <int> ) ; return shiftMix ( y * K2 ^ z * K0 ) * K2 ; } return K2 ; } private static long hashLength17to32 ( byte [ ] bytes , int offset , int length ) { long mul = K2 + length * <int> ; long a = load64 ( bytes , offset ) * K1 ; long b = load64 ( bytes , offset + <int> ) ; long c = load64 ( bytes , offset + length - <int> ) * mul ; long d = load64 ( bytes , offset + length - <int> ) * K2 ; return hashLength16 ( rotateRight ( a + b , <int> ) + rotateRight ( c , <int> ) + d , a + rotateRight ( b + K2 , <int> ) + c , mul ) ; } private static long hashLength33To64 ( byte [ ] bytes , int offset , int length ) { long mul = K2 + length * <int> ; long a = load64 ( bytes , offset ) * K2 ; long b = load64 ( bytes , offset + <int> ) ; long c = load64 ( bytes , offset + length - <int> ) * mul ; long d = load64 ( bytes , offset + length - <int> ) * K2 ; long y = rotateRight ( a + b , <int> ) + rotateRight ( c , <int> ) + d ; long z = hashLength16 ( y , a + rotateRight ( b + K2 , <int> ) + c , mul ) ; long e = load64 ( bytes , offset + <int> ) * mul ; long f = load64 ( bytes , offset + <int> ) ; long g = ( y + load64 ( bytes , offset + length - <int> ) ) * mul ; long h = ( z + load64 ( bytes , offset + length - <int> ) ) * mul ; return hashLength16 ( rotateRight ( e + f , <int> ) + rotateRight ( g , <int> ) + h , e + rotateRight ( f + a , <int> ) + g , mul ) ; } private static long hashLength65Plus ( byte [ ] bytes , int offset , int length ) { final int seed = <int> ; long x = seed ; long y = seed * K1 + <int> ; long z = shiftMix ( y * K2 + <int> ) * K2 ; long [ ] v = new long [ <int> ] , w = new long [ <int> ] ; x = x * K2 + load64 ( bytes , offset ) ; int end = offset + ( ( length - <int> ) / <int> ) * <int> ; int last64offset = end + ( ( length - <int> ) & <int> ) - <int> ; do { x = rotateRight ( x + y + v [ <int> ] + load64 ( bytes , offset + <int> ) , <int> ) * K1 ; y = rotateRight ( y + v [ <int> ] + load64 ( bytes , offset + <int> ) , <int> ) * K1 ; x ^ = w [ <int> ] ; y + = v [ <int> ] + load64 ( bytes , offset + <int> ) ; z = rotateRight ( z + w [ <int> ] , <int> ) * K1 ; weakHashLength32WithSeeds ( bytes , offset , v [ <int> ] * K1 , x + w [ <int> ] , v ) ; weakHashLength32WithSeeds ( bytes , offset + <int> , z + w [ <int> ] , y + load64 ( bytes , offset + <int> ) , w ) ; long tmp = x ; x = z ; z = tmp ; offset + = <int> ; } while ( offset ! = end ) ; long mul = K1 + ( ( z & <hex> ) < < <int> ) ; offset = last64offset ; w [ <int> ] + = ( ( length - <int> ) & <int> ) ; v [ <int> ] + = w [ <int> ] ; w [ <int> ] + = v [ <int> ] ; x = rotateRight ( x + y + v [ <int> ] + load64 ( bytes , offset + <int> ) , <int> ) * mul ; y = rotateRight ( y + v [ <int> ] + load64 ( bytes , offset + <int> ) , <int> ) * mul ; x ^ = w [ <int> ] * <int> ; y + = v [ <int> ] * <int> + load64 ( bytes , offset + <int> ) ; z = rotateRight ( z + w [ <int> ] , <int> ) * mul ; weakHashLength32WithSeeds ( bytes , offset , v [ <int> ] * mul , x + w [ <int> ] , v ) ; weakHashLength32WithSeeds ( bytes , offset + <int> , z + w [ <int> ] , y + load64 ( bytes , offset + <int> ) , w ) ; return hashLength16 ( hashLength16 ( v [ <int> ] , w [ <int> ] , mul ) + shiftMix ( y ) * K0 + x , hashLength16 ( v [ <int> ] , w [ <int> ] , mul ) + z , mul ) ; } } 
