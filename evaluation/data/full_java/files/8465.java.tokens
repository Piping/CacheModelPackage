package org . elasticsearch . search . aggregations . metrics ; import com . carrotsearch . hppc . ObjectIntHashMap ; import com . carrotsearch . hppc . ObjectIntMap ; import com . carrotsearch . hppc . ObjectObjectHashMap ; import com . carrotsearch . hppc . ObjectObjectMap ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . SearchHitField ; import org . elasticsearch . search . sort . SortBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . geo . RandomGeoGenerator ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; @ESIntegTestCase.SuiteScopeTestCase public abstract class AbstractGeoTestCase extends ESIntegTestCase { protected static final String SINGLE_VALUED_FIELD_NAME = <str> ; protected static final String MULTI_VALUED_FIELD_NAME = <str> ; protected static final String NUMBER_FIELD_NAME = <str> ; protected static final String UNMAPPED_IDX_NAME = <str> ; protected static final String IDX_NAME = <str> ; protected static final String EMPTY_IDX_NAME = <str> ; protected static final String DATELINE_IDX_NAME = <str> ; protected static final String HIGH_CARD_IDX_NAME = <str> ; protected static final String IDX_ZERO_NAME = <str> ; protected static int numDocs ; protected static int numUniqueGeoPoints ; protected static GeoPoint [ ] singleValues , multiValues ; protected static GeoPoint singleTopLeft , singleBottomRight , multiTopLeft , multiBottomRight , singleCentroid , multiCentroid , unmappedCentroid ; protected static ObjectIntMap < String > expectedDocCountsForGeoHash = null ; protected static ObjectObjectMap < String , GeoPoint > expectedCentroidsForGeoHash = null ; protected static final double GEOHASH_TOLERANCE = <float> ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( UNMAPPED_IDX_NAME ) ; assertAcked ( prepareCreate ( IDX_NAME ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> , MULTI_VALUED_FIELD_NAME , <str> , NUMBER_FIELD_NAME , <str> , <str> , <str> ) ) ; singleTopLeft = new GeoPoint ( Double . NEGATIVE_INFINITY , Double . POSITIVE_INFINITY ) ; singleBottomRight = new GeoPoint ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; multiTopLeft = new GeoPoint ( Double . NEGATIVE_INFINITY , Double . POSITIVE_INFINITY ) ; multiBottomRight = new GeoPoint ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; singleCentroid = new GeoPoint ( <int> , <int> ) ; multiCentroid = new GeoPoint ( <int> , <int> ) ; unmappedCentroid = new GeoPoint ( <int> , <int> ) ; numDocs = randomIntBetween ( <int> , <int> ) ; numUniqueGeoPoints = randomIntBetween ( <int> , numDocs ) ; expectedDocCountsForGeoHash = new ObjectIntHashMap < > ( numDocs * <int> ) ; expectedCentroidsForGeoHash = new ObjectObjectHashMap < > ( numDocs * <int> ) ; singleValues = new GeoPoint [ numUniqueGeoPoints ] ; for ( int i = <int> ; i < singleValues . length ; i + + ) { singleValues [ i ] = RandomGeoGenerator . randomPoint ( random ( ) ) ; updateBoundsTopLeft ( singleValues [ i ] , singleTopLeft ) ; updateBoundsBottomRight ( singleValues [ i ] , singleBottomRight ) ; } multiValues = new GeoPoint [ numUniqueGeoPoints ] ; for ( int i = <int> ; i < multiValues . length ; i + + ) { multiValues [ i ] = RandomGeoGenerator . randomPoint ( random ( ) ) ; updateBoundsTopLeft ( multiValues [ i ] , multiTopLeft ) ; updateBoundsBottomRight ( multiValues [ i ] , multiBottomRight ) ; } List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; GeoPoint singleVal ; final GeoPoint [ ] multiVal = new GeoPoint [ <int> ] ; double newMVLat , newMVLon ; for ( int i = <int> ; i < numDocs ; i + + ) { singleVal = singleValues [ i % numUniqueGeoPoints ] ; multiVal [ <int> ] = multiValues [ i % numUniqueGeoPoints ] ; multiVal [ <int> ] = multiValues [ ( i + <int> ) % numUniqueGeoPoints ] ; builders . add ( client ( ) . prepareIndex ( IDX_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . array ( SINGLE_VALUED_FIELD_NAME , singleVal . lon ( ) , singleVal . lat ( ) ) . startArray ( MULTI_VALUED_FIELD_NAME ) . startArray ( ) . value ( multiVal [ <int> ] . lon ( ) ) . value ( multiVal [ <int> ] . lat ( ) ) . endArray ( ) . startArray ( ) . value ( multiVal [ <int> ] . lon ( ) ) . value ( multiVal [ <int> ] . lat ( ) ) . endArray ( ) . endArray ( ) . field ( NUMBER_FIELD_NAME , i ) . field ( <str> , <str> + i ) . endObject ( ) ) ) ; singleCentroid = singleCentroid . reset ( singleCentroid . lat ( ) + ( singleVal . lat ( ) - singleCentroid . lat ( ) ) / ( i + <int> ) , singleCentroid . lon ( ) + ( singleVal . lon ( ) - singleCentroid . lon ( ) ) / ( i + <int> ) ) ; newMVLat = ( multiVal [ <int> ] . lat ( ) + multiVal [ <int> ] . lat ( ) ) / <float> ; newMVLon = ( multiVal [ <int> ] . lon ( ) + multiVal [ <int> ] . lon ( ) ) / <float> ; multiCentroid = multiCentroid . reset ( multiCentroid . lat ( ) + ( newMVLat - multiCentroid . lat ( ) ) / ( i + <int> ) , multiCentroid . lon ( ) + ( newMVLon - multiCentroid . lon ( ) ) / ( i + <int> ) ) ; } assertAcked ( prepareCreate ( EMPTY_IDX_NAME ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; assertAcked ( prepareCreate ( DATELINE_IDX_NAME ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> , MULTI_VALUED_FIELD_NAME , <str> , NUMBER_FIELD_NAME , <str> , <str> , <str> ) ) ; GeoPoint [ ] geoValues = new GeoPoint [ <int> ] ; geoValues [ <int> ] = new GeoPoint ( <int> , <int> ) ; geoValues [ <int> ] = new GeoPoint ( <int> , - <int> ) ; geoValues [ <int> ] = new GeoPoint ( - <int> , <int> ) ; geoValues [ <int> ] = new GeoPoint ( <int> , - <int> ) ; geoValues [ <int> ] = new GeoPoint ( - <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( DATELINE_IDX_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . array ( SINGLE_VALUED_FIELD_NAME , geoValues [ i ] . lon ( ) , geoValues [ i ] . lat ( ) ) . field ( NUMBER_FIELD_NAME , i ) . field ( <str> , <str> + i ) . endObject ( ) ) ) ; } assertAcked ( prepareCreate ( HIGH_CARD_IDX_NAME ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> , MULTI_VALUED_FIELD_NAME , <str> , NUMBER_FIELD_NAME , <str> , <str> , <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { singleVal = singleValues [ i % numUniqueGeoPoints ] ; builders . add ( client ( ) . prepareIndex ( HIGH_CARD_IDX_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . array ( SINGLE_VALUED_FIELD_NAME , singleVal . lon ( ) , singleVal . lat ( ) ) . startArray ( MULTI_VALUED_FIELD_NAME ) . startArray ( ) . value ( multiValues [ i % numUniqueGeoPoints ] . lon ( ) ) . value ( multiValues [ i % numUniqueGeoPoints ] . lat ( ) ) . endArray ( ) . startArray ( ) . value ( multiValues [ ( i + <int> ) % numUniqueGeoPoints ] . lon ( ) ) . value ( multiValues [ ( i + <int> ) % numUniqueGeoPoints ] . lat ( ) ) . endArray ( ) . endArray ( ) . field ( NUMBER_FIELD_NAME , i ) . field ( <str> , <str> + i ) . endObject ( ) ) ) ; updateGeohashBucketsCentroid ( singleVal ) ; } builders . add ( client ( ) . prepareIndex ( IDX_ZERO_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . array ( SINGLE_VALUED_FIELD_NAME , <float> , <float> ) . endObject ( ) ) ) ; assertAcked ( prepareCreate ( IDX_ZERO_NAME ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; indexRandom ( true , builders ) ; ensureSearchable ( ) ; SearchResponse response = client ( ) . prepareSearch ( HIGH_CARD_IDX_NAME ) . addField ( NUMBER_FIELD_NAME ) . addSort ( SortBuilders . fieldSort ( NUMBER_FIELD_NAME ) . order ( SortOrder . ASC ) ) . setSize ( <int> ) . get ( ) ; assertSearchResponse ( response ) ; long totalHits = response . getHits ( ) . totalHits ( ) ; XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) ; response . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . endObject ( ) ; logger . info ( <str> , builder . string ( ) ) ; for ( int i = <int> ; i < totalHits ; i + + ) { SearchHit searchHit = response . getHits ( ) . getAt ( i ) ; assertThat ( <str> + i + <str> + searchHit . getId ( ) , searchHit . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( <str> + i + <str> + searchHit . getId ( ) , searchHit . getType ( ) , equalTo ( <str> ) ) ; SearchHitField hitField = searchHit . field ( NUMBER_FIELD_NAME ) ; assertThat ( <str> + i + <str> , hitField . getValues ( ) . size ( ) , equalTo ( <int> ) ) ; Long value = hitField . getValue ( ) ; assertThat ( <str> + i + <str> , value . intValue ( ) , equalTo ( i ) ) ; } assertThat ( totalHits , equalTo ( <int> ) ) ; } private void updateGeohashBucketsCentroid ( final GeoPoint location ) { String hash = GeoHashUtils . stringEncode ( location . lon ( ) , location . lat ( ) , GeoHashUtils . PRECISION ) ; for ( int precision = GeoHashUtils . PRECISION ; precision > <int> ; - - precision ) { final String h = hash . substring ( <int> , precision ) ; expectedDocCountsForGeoHash . put ( h , expectedDocCountsForGeoHash . getOrDefault ( h , <int> ) + <int> ) ; expectedCentroidsForGeoHash . put ( h , updateHashCentroid ( h , location ) ) ; } } private GeoPoint updateHashCentroid ( String hash , final GeoPoint location ) { GeoPoint centroid = expectedCentroidsForGeoHash . getOrDefault ( hash , null ) ; if ( centroid = = null ) { return new GeoPoint ( location . lat ( ) , location . lon ( ) ) ; } final int docCount = expectedDocCountsForGeoHash . get ( hash ) ; final double newLon = centroid . lon ( ) + ( location . lon ( ) - centroid . lon ( ) ) / docCount ; final double newLat = centroid . lat ( ) + ( location . lat ( ) - centroid . lat ( ) ) / docCount ; return centroid . reset ( newLat , newLon ) ; } private void updateBoundsBottomRight ( GeoPoint geoPoint , GeoPoint currentBound ) { if ( geoPoint . lat ( ) < currentBound . lat ( ) ) { currentBound . resetLat ( geoPoint . lat ( ) ) ; } if ( geoPoint . lon ( ) > currentBound . lon ( ) ) { currentBound . resetLon ( geoPoint . lon ( ) ) ; } } private void updateBoundsTopLeft ( GeoPoint geoPoint , GeoPoint currentBound ) { if ( geoPoint . lat ( ) > currentBound . lat ( ) ) { currentBound . resetLat ( geoPoint . lat ( ) ) ; } if ( geoPoint . lon ( ) < currentBound . lon ( ) ) { currentBound . resetLon ( geoPoint . lon ( ) ) ; } } } 
