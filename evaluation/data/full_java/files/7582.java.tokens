package org . elasticsearch . search . suggest ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . HasContextAndHeaders ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . suggest . SuggestionSearchContext . SuggestionContext ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; public final class SuggestParseElement implements SearchParseElement { private Suggesters suggesters ; @Inject public SuggestParseElement ( Suggesters suggesters ) { this . suggesters = suggesters ; } @Override public void parse ( XContentParser parser , SearchContext context ) throws Exception { SuggestionSearchContext suggestionSearchContext = parseInternal ( parser , context . mapperService ( ) , context . fieldData ( ) , context . shardTarget ( ) . index ( ) , context . shardTarget ( ) . shardId ( ) , context ) ; context . suggest ( suggestionSearchContext ) ; } public SuggestionSearchContext parseInternal ( XContentParser parser , MapperService mapperService , IndexFieldDataService fieldDataService , String index , int shardId , HasContextAndHeaders headersContext ) throws IOException { SuggestionSearchContext suggestionSearchContext = new SuggestionSearchContext ( ) ; BytesRef globalText = null ; String fieldName = null ; Map < String , SuggestionContext > suggestionContexts = new HashMap < > ( ) ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( fieldName ) ) { globalText = parser . utf8Bytes ( ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { String suggestionName = fieldName ; BytesRef suggestText = null ; BytesRef prefix = null ; BytesRef regex = null ; SuggestionContext suggestionContext = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( fieldName ) ) { suggestText = parser . utf8Bytes ( ) ; } else if ( <str> . equals ( fieldName ) ) { prefix = parser . utf8Bytes ( ) ; } else if ( <str> . equals ( fieldName ) ) { regex = parser . utf8Bytes ( ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( suggestionName = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( suggesters . get ( fieldName ) = = null ) { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } final SuggestContextParser contextParser = suggesters . get ( fieldName ) . getContextParser ( ) ; suggestionContext = contextParser . parse ( parser , mapperService , fieldDataService , headersContext ) ; } } if ( suggestionContext ! = null ) { if ( suggestText ! = null & & prefix = = null ) { suggestionContext . setPrefix ( suggestText ) ; suggestionContext . setText ( suggestText ) ; } else if ( suggestText = = null & & prefix ! = null ) { suggestionContext . setPrefix ( prefix ) ; suggestionContext . setText ( prefix ) ; } else if ( regex ! = null ) { suggestionContext . setRegex ( regex ) ; suggestionContext . setText ( regex ) ; } suggestionContexts . put ( suggestionName , suggestionContext ) ; } } } for ( Map . Entry < String , SuggestionContext > entry : suggestionContexts . entrySet ( ) ) { String suggestionName = entry . getKey ( ) ; SuggestionContext suggestionContext = entry . getValue ( ) ; suggestionContext . setShard ( shardId ) ; suggestionContext . setIndex ( index ) ; SuggestUtils . verifySuggestion ( mapperService , globalText , suggestionContext ) ; suggestionSearchContext . addSuggestion ( suggestionName , suggestionContext ) ; } return suggestionSearchContext ; } } 
