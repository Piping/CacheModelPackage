package com . google . common . primitives ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . util . Arrays ; import java . util . Comparator ; import javax . annotation . CheckReturnValue ; @Beta @GwtCompatible public final class UnsignedInts { static final long INT_MASK = <hex> ; private UnsignedInts ( ) { } static int flip ( int value ) { return value ^ Integer . MIN_VALUE ; } @CheckReturnValue public static int compare ( int a , int b ) { return Ints . compare ( flip ( a ) , flip ( b ) ) ; } @CheckReturnValue public static long toLong ( int value ) { return value & INT_MASK ; } @CheckReturnValue public static int min ( int . . . array ) { checkArgument ( array . length > <int> ) ; int min = flip ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { int next = flip ( array [ i ] ) ; if ( next < min ) { min = next ; } } return flip ( min ) ; } @CheckReturnValue public static int max ( int . . . array ) { checkArgument ( array . length > <int> ) ; int max = flip ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { int next = flip ( array [ i ] ) ; if ( next > max ) { max = next ; } } return flip ( max ) ; } @CheckReturnValue public static String join ( String separator , int . . . array ) { checkNotNull ( separator ) ; if ( array . length = = <int> ) { return <str> ; } StringBuilder builder = new StringBuilder ( array . length * <int> ) ; builder . append ( toString ( array [ <int> ] ) ) ; for ( int i = <int> ; i < array . length ; i + + ) { builder . append ( separator ) . append ( toString ( array [ i ] ) ) ; } return builder . toString ( ) ; } @CheckReturnValue public static Comparator < int [ ] > lexicographicalComparator ( ) { return LexicographicalComparator . INSTANCE ; } enum LexicographicalComparator implements Comparator < int [ ] > { INSTANCE ; @Override public int compare ( int [ ] left , int [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; for ( int i = <int> ; i < minLength ; i + + ) { if ( left [ i ] ! = right [ i ] ) { return UnsignedInts . compare ( left [ i ] , right [ i ] ) ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } @CheckReturnValue public static int divide ( int dividend , int divisor ) { return ( int ) ( toLong ( dividend ) / toLong ( divisor ) ) ; } @CheckReturnValue public static int remainder ( int dividend , int divisor ) { return ( int ) ( toLong ( dividend ) % toLong ( divisor ) ) ; } public static int decode ( String stringValue ) { ParseRequest request = ParseRequest . fromString ( stringValue ) ; try { return parseUnsignedInt ( request . rawValue , request . radix ) ; } catch ( NumberFormatException e ) { NumberFormatException decodeException = new NumberFormatException ( <str> + stringValue ) ; decodeException . initCause ( e ) ; throw decodeException ; } } public static int parseUnsignedInt ( String s ) { return parseUnsignedInt ( s , <int> ) ; } public static int parseUnsignedInt ( String string , int radix ) { checkNotNull ( string ) ; long result = Long . parseLong ( string , radix ) ; if ( ( result & INT_MASK ) ! = result ) { throw new NumberFormatException ( <str> + string + <str> + radix + <str> ) ; } return ( int ) result ; } @CheckReturnValue public static String toString ( int x ) { return toString ( x , <int> ) ; } @CheckReturnValue public static String toString ( int x , int radix ) { long asLong = x & INT_MASK ; return Long . toString ( asLong , radix ) ; } } 
