package com . google . common . collect . testing . google ; import static junit . framework . TestCase . assertEquals ; import static junit . framework . TestCase . assertTrue ; import static junit . framework . TestCase . fail ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . Iterators ; import com . google . common . collect . LinkedHashMultiset ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import com . google . common . collect . Multiset ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map . Entry ; import java . util . Set ; @GwtCompatible public class UnmodifiableCollectionTests { public static void assertMapEntryIsUnmodifiable ( Entry < ? , ? > entry ) { try { entry . setValue ( null ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } public static void assertIteratorIsUnmodifiable ( Iterator < ? > iterator ) { while ( iterator . hasNext ( ) ) { iterator . next ( ) ; try { iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } } public static void assertIteratorsInOrder ( Iterator < ? > expectedIterator , Iterator < ? > actualIterator ) { int i = <int> ; while ( expectedIterator . hasNext ( ) ) { Object expected = expectedIterator . next ( ) ; assertTrue ( <str> + i + <str> + expected + <str> , actualIterator . hasNext ( ) ) ; Object actual = actualIterator . next ( ) ; assertEquals ( <str> + i , expected , actual ) ; i + + ; } if ( actualIterator . hasNext ( ) ) { fail ( <str> + i + <str> + actualIterator . next ( ) + <str> ) ; } } public static < E > void assertCollectionIsUnmodifiable ( Collection < E > collection , E sampleElement ) { Collection < E > siblingCollection = new ArrayList < E > ( ) ; siblingCollection . add ( sampleElement ) ; Collection < E > copy = new ArrayList < E > ( ) ; Iterators . addAll ( copy , collection . iterator ( ) ) ; try { collection . add ( sampleElement ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; try { collection . addAll ( siblingCollection ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; try { collection . clear ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; assertIteratorIsUnmodifiable ( collection . iterator ( ) ) ; assertCollectionsAreEquivalent ( copy , collection ) ; try { collection . remove ( sampleElement ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; try { collection . removeAll ( siblingCollection ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; try { collection . retainAll ( siblingCollection ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( copy , collection ) ; } public static < E > void assertSetIsUnmodifiable ( Set < E > set , E sampleElement ) { assertCollectionIsUnmodifiable ( set , sampleElement ) ; } public static < E > void assertMultisetIsUnmodifiable ( Multiset < E > multiset , final E sampleElement ) { Multiset < E > copy = LinkedHashMultiset . create ( multiset ) ; assertCollectionsAreEquivalent ( multiset , copy ) ; assertCollectionIsUnmodifiable ( multiset , sampleElement ) ; assertCollectionsAreEquivalent ( multiset , copy ) ; try { multiset . add ( sampleElement , <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( multiset , copy ) ; try { multiset . remove ( sampleElement , <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertCollectionsAreEquivalent ( multiset , copy ) ; assertCollectionsAreEquivalent ( multiset , copy ) ; assertSetIsUnmodifiable ( multiset . elementSet ( ) , sampleElement ) ; assertCollectionsAreEquivalent ( multiset , copy ) ; assertSetIsUnmodifiable ( multiset . entrySet ( ) , new Multiset . Entry < E > ( ) { @Override public int getCount ( ) { return <int> ; } @Override public E getElement ( ) { return sampleElement ; } } ) ; assertCollectionsAreEquivalent ( multiset , copy ) ; } public static < K , V > void assertMultimapIsUnmodifiable ( Multimap < K , V > multimap , final K sampleKey , final V sampleValue ) { List < Entry < K , V > > originalEntries = Collections . unmodifiableList ( Lists . newArrayList ( multimap . entries ( ) ) ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; Collection < V > sampleValueAsCollection = Collections . singleton ( sampleValue ) ; try { multimap . clear ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; assertSetIsUnmodifiable ( multimap . asMap ( ) . entrySet ( ) , Maps . immutableEntry ( sampleKey , sampleValueAsCollection ) ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; if ( ! multimap . isEmpty ( ) ) { Collection < V > values = multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ; assertCollectionIsUnmodifiable ( values , sampleValue ) ; } assertCollectionIsUnmodifiable ( multimap . entries ( ) , Maps . immutableEntry ( sampleKey , sampleValue ) ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; for ( Entry < K , V > entry : multimap . entries ( ) ) { assertMapEntryIsUnmodifiable ( entry ) ; } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; assertMultisetIsUnmodifiable ( multimap . keys ( ) , sampleKey ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; assertSetIsUnmodifiable ( multimap . keySet ( ) , sampleKey ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; if ( ! multimap . isEmpty ( ) ) { K key = multimap . keySet ( ) . iterator ( ) . next ( ) ; assertCollectionIsUnmodifiable ( multimap . get ( key ) , sampleValue ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; } try { multimap . put ( sampleKey , sampleValue ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . putAll ( sampleKey , sampleValueAsCollection ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; Multimap < K , V > multimap2 = ArrayListMultimap . create ( ) ; multimap2 . put ( sampleKey , sampleValue ) ; try { multimap . putAll ( multimap2 ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . remove ( sampleKey , sampleValue ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . removeAll ( sampleKey ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . replaceValues ( sampleKey , sampleValueAsCollection ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . asMap ( ) . remove ( sampleKey ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; if ( ! multimap . isEmpty ( ) ) { K presentKey = multimap . keySet ( ) . iterator ( ) . next ( ) ; try { multimap . asMap ( ) . get ( presentKey ) . remove ( sampleValue ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; try { multimap . asMap ( ) . values ( ) . iterator ( ) . next ( ) . remove ( sampleValue ) ; fail ( <str> + <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { ( ( Collection < ? > ) multimap . asMap ( ) . values ( ) . toArray ( ) [ <int> ] ) . clear ( ) ; fail ( <str> + <str> ) ; } catch ( UnsupportedOperationException expected ) { } } assertCollectionIsUnmodifiable ( multimap . values ( ) , sampleValue ) ; assertMultimapRemainsUnmodified ( multimap , originalEntries ) ; } private static < E > void assertCollectionsAreEquivalent ( Collection < E > expected , Collection < E > actual ) { assertIteratorsInOrder ( expected . iterator ( ) , actual . iterator ( ) ) ; } private static < K , V > void assertMultimapRemainsUnmodified ( Multimap < K , V > expected , List < Entry < K , V > > actual ) { assertIteratorsInOrder ( expected . entries ( ) . iterator ( ) , actual . iterator ( ) ) ; } } 
