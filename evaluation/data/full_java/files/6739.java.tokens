package org . elasticsearch . index . shard ; import org . apache . lucene . index . CodecReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . MergePolicy ; import org . apache . lucene . index . MergeTrigger ; import org . apache . lucene . index . SegmentCommitInfo ; import org . apache . lucene . index . SegmentInfos ; import org . apache . lucene . store . Directory ; import org . elasticsearch . Version ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public final class ElasticsearchMergePolicy extends MergePolicy { private static ESLogger logger = Loggers . getLogger ( ElasticsearchMergePolicy . class ) ; private final MergePolicy delegate ; private volatile boolean upgradeInProgress ; private volatile boolean upgradeOnlyAncientSegments ; private static final int MAX_CONCURRENT_UPGRADE_MERGES = <int> ; public ElasticsearchMergePolicy ( MergePolicy delegate ) { this . delegate = delegate ; } static CodecReader filter ( CodecReader reader ) throws IOException { reader = VersionFieldUpgrader . wrap ( reader ) ; return reader ; } static class IndexUpgraderOneMerge extends OneMerge { public IndexUpgraderOneMerge ( List < SegmentCommitInfo > segments ) { super ( segments ) ; } @Override public List < CodecReader > getMergeReaders ( ) throws IOException { final List < CodecReader > newReaders = new ArrayList < > ( ) ; for ( CodecReader reader : super . getMergeReaders ( ) ) { newReaders . add ( filter ( reader ) ) ; } return newReaders ; } } static class IndexUpgraderMergeSpecification extends MergeSpecification { @Override public void add ( OneMerge merge ) { super . add ( new IndexUpgraderOneMerge ( merge . segments ) ) ; } @Override public String segString ( Directory dir ) { return <str> + super . segString ( dir ) + <str> ; } } static MergeSpecification upgradedMergeSpecification ( MergeSpecification spec ) { if ( spec = = null ) { return null ; } MergeSpecification upgradedSpec = new IndexUpgraderMergeSpecification ( ) ; for ( OneMerge merge : spec . merges ) { upgradedSpec . add ( merge ) ; } return upgradedSpec ; } @Override public MergeSpecification findMerges ( MergeTrigger mergeTrigger , SegmentInfos segmentInfos , IndexWriter writer ) throws IOException { return upgradedMergeSpecification ( delegate . findMerges ( mergeTrigger , segmentInfos , writer ) ) ; } private boolean shouldUpgrade ( SegmentCommitInfo info ) { org . apache . lucene . util . Version old = info . info . getVersion ( ) ; org . apache . lucene . util . Version cur = Version . CURRENT . luceneVersion ; assert old . major < = cur . major ; if ( cur . major > old . major ) { return true ; } if ( upgradeOnlyAncientSegments = = false & & cur . minor > old . minor ) { return true ; } return false ; } @Override public MergeSpecification findForcedMerges ( SegmentInfos segmentInfos , int maxSegmentCount , Map < SegmentCommitInfo , Boolean > segmentsToMerge , IndexWriter writer ) throws IOException { if ( upgradeInProgress ) { MergeSpecification spec = new IndexUpgraderMergeSpecification ( ) ; for ( SegmentCommitInfo info : segmentInfos ) { if ( shouldUpgrade ( info ) ) { logger . debug ( <str> + info . info . name + <str> ) ; spec . add ( new OneMerge ( Collections . singletonList ( info ) ) ) ; } if ( spec . merges . size ( ) = = MAX_CONCURRENT_UPGRADE_MERGES ) { logger . debug ( <str> + spec . merges . size ( ) + <str> ) ; return spec ; } } if ( spec . merges . isEmpty ( ) = = false ) { logger . debug ( <str> + spec . merges . size ( ) + <str> ) ; return spec ; } upgradeInProgress = false ; } return upgradedMergeSpecification ( delegate . findForcedMerges ( segmentInfos , maxSegmentCount , segmentsToMerge , writer ) ) ; } @Override public MergeSpecification findForcedDeletesMerges ( SegmentInfos segmentInfos , IndexWriter writer ) throws IOException { return upgradedMergeSpecification ( delegate . findForcedDeletesMerges ( segmentInfos , writer ) ) ; } @Override public boolean useCompoundFile ( SegmentInfos segments , SegmentCommitInfo newSegment , IndexWriter writer ) throws IOException { return delegate . useCompoundFile ( segments , newSegment , writer ) ; } public void setUpgradeInProgress ( boolean upgrade , boolean onlyAncientSegments ) { this . upgradeInProgress = upgrade ; this . upgradeOnlyAncientSegments = onlyAncientSegments ; } @Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + <str> + delegate + <str> ; } } 
