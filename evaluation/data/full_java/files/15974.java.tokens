package org . gradle . tooling . internal . consumer . connection ; import org . gradle . api . Action ; import org . gradle . tooling . internal . adapter . CompatibleIntrospector ; import org . gradle . tooling . internal . adapter . ProtocolToModelAdapter ; import org . gradle . tooling . internal . adapter . SourceObjectMapping ; import org . gradle . tooling . internal . consumer . ConnectionParameters ; import org . gradle . tooling . internal . consumer . parameters . ConsumerOperationParameters ; import org . gradle . tooling . internal . consumer . versioning . ModelMapping ; import org . gradle . tooling . internal . consumer . versioning . VersionDetails ; import org . gradle . tooling . internal . protocol . ConnectionVersion4 ; import org . gradle . tooling . internal . protocol . InternalConnection ; import org . gradle . tooling . model . GradleProject ; import org . gradle . tooling . model . build . BuildEnvironment ; import org . gradle . tooling . model . eclipse . EclipseProject ; import org . gradle . tooling . model . eclipse . HierarchicalEclipseProject ; import org . gradle . tooling . model . idea . BasicIdeaProject ; import org . gradle . tooling . model . idea . IdeaProject ; import org . gradle . tooling . model . internal . Exceptions ; import org . gradle . util . GradleVersion ; public class InternalConnectionBackedConsumerConnection extends AbstractConsumerConnection { private final ModelProducer modelProducer ; private final UnsupportedActionRunner actionRunner ; public InternalConnectionBackedConsumerConnection ( ConnectionVersion4 delegate , ModelMapping modelMapping , ProtocolToModelAdapter adapter ) { super ( delegate , new R10M8VersionDetails ( delegate . getMetaData ( ) . getVersion ( ) ) ) ; ModelProducer modelProducer = new InternalConnectionBackedModelProducer ( adapter , getVersionDetails ( ) , modelMapping , ( InternalConnection ) delegate , getCompatibilityMapperAction ( ) ) ; modelProducer = new GradleBuildAdapterProducer ( adapter , modelProducer ) ; modelProducer = new BuildInvocationsAdapterProducer ( adapter , getVersionDetails ( ) , modelProducer ) ; modelProducer = new BuildExecutingModelProducer ( modelProducer ) ; if ( GradleVersion . version ( getVersionDetails ( ) . getVersion ( ) ) . compareTo ( GradleVersion . version ( <str> ) ) < <int> ) { modelProducer = new NoCommandLineArgsModelProducer ( modelProducer ) ; } this . modelProducer = modelProducer ; this . actionRunner = new UnsupportedActionRunner ( getVersionDetails ( ) . getVersion ( ) ) ; } @Override protected ActionRunner getActionRunner ( ) { return actionRunner ; } @Override protected ModelProducer getModelProducer ( ) { return modelProducer ; } @Override public void configure ( ConnectionParameters connectionParameters ) { new CompatibleIntrospector ( getDelegate ( ) ) . callSafely ( <str> , connectionParameters . getVerboseLogging ( ) ) ; } private static class R10M8VersionDetails extends VersionDetails { public R10M8VersionDetails ( String version ) { super ( version ) ; } @Override public boolean maySupportModel ( Class < ? > modelType ) { return modelType . equals ( Void . class ) | | modelType . equals ( HierarchicalEclipseProject . class ) | | modelType . equals ( EclipseProject . class ) | | modelType . equals ( IdeaProject . class ) | | modelType . equals ( BasicIdeaProject . class ) | | modelType . equals ( GradleProject . class ) | | modelType . equals ( BuildEnvironment . class ) ; } } private class NoCommandLineArgsModelProducer implements ModelProducer { private final ModelProducer delegate ; public NoCommandLineArgsModelProducer ( ModelProducer delegate ) { this . delegate = delegate ; } @Override public < T > T produceModel ( Class < T > type , ConsumerOperationParameters operationParameters ) { if ( operationParameters . getArguments ( ) ! = null & & ! operationParameters . getArguments ( ) . isEmpty ( ) ) { throw Exceptions . unsupportedOperationConfiguration ( operationParameters . getEntryPointName ( ) + <str> , getVersionDetails ( ) . getVersion ( ) , <str> ) ; } return delegate . produceModel ( type , operationParameters ) ; } } private class BuildExecutingModelProducer implements ModelProducer { private final ModelProducer delegate ; private BuildExecutingModelProducer ( ModelProducer delegate ) { this . delegate = delegate ; } public < T > T produceModel ( Class < T > type , ConsumerOperationParameters operationParameters ) { if ( type . equals ( Void . class ) ) { getDelegate ( ) . executeBuild ( operationParameters , operationParameters ) ; return null ; } else { if ( operationParameters . getTasks ( ) ! = null ) { throw Exceptions . unsupportedOperationConfiguration ( operationParameters . getEntryPointName ( ) + <str> , getVersionDetails ( ) . getVersion ( ) , <str> ) ; } return delegate . produceModel ( type , operationParameters ) ; } } } private static class InternalConnectionBackedModelProducer implements ModelProducer { private final ProtocolToModelAdapter adapter ; private final VersionDetails versionDetails ; private final ModelMapping modelMapping ; private final InternalConnection delegate ; private final Action < ? super SourceObjectMapping > mapper ; public InternalConnectionBackedModelProducer ( ProtocolToModelAdapter adapter , VersionDetails versionDetails , ModelMapping modelMapping , InternalConnection delegate , Action < ? super SourceObjectMapping > mapper ) { this . adapter = adapter ; this . versionDetails = versionDetails ; this . modelMapping = modelMapping ; this . delegate = delegate ; this . mapper = mapper ; } public < T > T produceModel ( Class < T > type , ConsumerOperationParameters operationParameters ) { if ( ! versionDetails . maySupportModel ( type ) ) { throw Exceptions . unsupportedModel ( type , versionDetails . getVersion ( ) ) ; } Class < ? > protocolType = modelMapping . getProtocolType ( type ) ; return adapter . adapt ( type , delegate . getTheModel ( protocolType , operationParameters ) , mapper ) ; } } } 
