package com . google . common . escape ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . util . HashMap ; import java . util . Map ; import javax . annotation . Nullable ; @Beta @GwtCompatible public final class Escapers { private Escapers ( ) { } public static Escaper nullEscaper ( ) { return NULL_ESCAPER ; } private static final Escaper NULL_ESCAPER = new CharEscaper ( ) { @Override public String escape ( String string ) { return checkNotNull ( string ) ; } @Override protected char [ ] escape ( char c ) { return null ; } } ; public static Builder builder ( ) { return new Builder ( ) ; } @Beta public static final class Builder { private final Map < Character , String > replacementMap = new HashMap < Character , String > ( ) ; private char safeMin = Character . MIN_VALUE ; private char safeMax = Character . MAX_VALUE ; private String unsafeReplacement = null ; private Builder ( ) { } public Builder setSafeRange ( char safeMin , char safeMax ) { this . safeMin = safeMin ; this . safeMax = safeMax ; return this ; } public Builder setUnsafeReplacement ( @Nullable String unsafeReplacement ) { this . unsafeReplacement = unsafeReplacement ; return this ; } public Builder addEscape ( char c , String replacement ) { checkNotNull ( replacement ) ; replacementMap . put ( c , replacement ) ; return this ; } public Escaper build ( ) { return new ArrayBasedCharEscaper ( replacementMap , safeMin , safeMax ) { private final char [ ] replacementChars = unsafeReplacement ! = null ? unsafeReplacement . toCharArray ( ) : null ; @Override protected char [ ] escapeUnsafe ( char c ) { return replacementChars ; } } ; } } static UnicodeEscaper asUnicodeEscaper ( Escaper escaper ) { checkNotNull ( escaper ) ; if ( escaper instanceof UnicodeEscaper ) { return ( UnicodeEscaper ) escaper ; } else if ( escaper instanceof CharEscaper ) { return wrap ( ( CharEscaper ) escaper ) ; } throw new IllegalArgumentException ( <str> + escaper . getClass ( ) . getName ( ) ) ; } public static String computeReplacement ( CharEscaper escaper , char c ) { return stringOrNull ( escaper . escape ( c ) ) ; } public static String computeReplacement ( UnicodeEscaper escaper , int cp ) { return stringOrNull ( escaper . escape ( cp ) ) ; } private static String stringOrNull ( char [ ] in ) { return ( in = = null ) ? null : new String ( in ) ; } private static UnicodeEscaper wrap ( final CharEscaper escaper ) { return new UnicodeEscaper ( ) { @Override protected char [ ] escape ( int cp ) { if ( cp < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { return escaper . escape ( ( char ) cp ) ; } char [ ] surrogateChars = new char [ <int> ] ; Character . toChars ( cp , surrogateChars , <int> ) ; char [ ] hiChars = escaper . escape ( surrogateChars [ <int> ] ) ; char [ ] loChars = escaper . escape ( surrogateChars [ <int> ] ) ; if ( hiChars = = null & & loChars = = null ) { return null ; } int hiCount = hiChars ! = null ? hiChars . length : <int> ; int loCount = loChars ! = null ? loChars . length : <int> ; char [ ] output = new char [ hiCount + loCount ] ; if ( hiChars ! = null ) { for ( int n = <int> ; n < hiChars . length ; + + n ) { output [ n ] = hiChars [ n ] ; } } else { output [ <int> ] = surrogateChars [ <int> ] ; } if ( loChars ! = null ) { for ( int n = <int> ; n < loChars . length ; + + n ) { output [ hiCount + n ] = loChars [ n ] ; } } else { output [ hiCount ] = surrogateChars [ <int> ] ; } return output ; } } ; } } 
