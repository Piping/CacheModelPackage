package org . elasticsearch . test . disruption ; import org . elasticsearch . common . unit . TimeValue ; import java . util . HashSet ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; public class IntermittentLongGCDisruption extends LongGCDisruption { volatile boolean disrupting ; volatile Thread worker ; final long intervalBetweenDelaysMin ; final long intervalBetweenDelaysMax ; final long delayDurationMin ; final long delayDurationMax ; public IntermittentLongGCDisruption ( Random random ) { this ( null , random ) ; } public IntermittentLongGCDisruption ( String disruptedNode , Random random ) { this ( disruptedNode , random , <int> , <int> , <int> , <int> ) ; } public IntermittentLongGCDisruption ( String disruptedNode , Random random , long intervalBetweenDelaysMin , long intervalBetweenDelaysMax , long delayDurationMin , long delayDurationMax ) { this ( random , disruptedNode , intervalBetweenDelaysMin , intervalBetweenDelaysMax , delayDurationMin , delayDurationMax ) ; } public IntermittentLongGCDisruption ( Random random , String disruptedNode , long intervalBetweenDelaysMin , long intervalBetweenDelaysMax , long delayDurationMin , long delayDurationMax ) { super ( random , disruptedNode ) ; this . intervalBetweenDelaysMin = intervalBetweenDelaysMin ; this . intervalBetweenDelaysMax = intervalBetweenDelaysMax ; this . delayDurationMin = delayDurationMin ; this . delayDurationMax = delayDurationMax ; } final static AtomicInteger thread_ids = new AtomicInteger ( ) ; @Override public void startDisrupting ( ) { disrupting = true ; worker = new Thread ( new BackgroundWorker ( ) , <str> + thread_ids . incrementAndGet ( ) ) ; worker . setDaemon ( true ) ; worker . start ( ) ; } @Override public void stopDisrupting ( ) { if ( worker = = null ) { return ; } logger . info ( <str> , disruptedNode ) ; disrupting = false ; worker . interrupt ( ) ; try { worker . join ( <int> * ( intervalBetweenDelaysMax + delayDurationMax ) ) ; } catch ( InterruptedException e ) { logger . info ( <str> ) ; } worker = null ; } private void simulateLongGC ( final TimeValue duration ) throws InterruptedException { final String disruptionNodeCopy = disruptedNode ; if ( disruptionNodeCopy = = null ) { return ; } logger . info ( <str> , disruptionNodeCopy , duration ) ; final Set < Thread > nodeThreads = new HashSet < > ( ) ; try { while ( stopNodeThreads ( disruptionNodeCopy , nodeThreads ) ) ; if ( ! nodeThreads . isEmpty ( ) ) { Thread . sleep ( duration . millis ( ) ) ; } } finally { logger . info ( <str> , disruptionNodeCopy ) ; resumeThreads ( nodeThreads ) ; } } class BackgroundWorker implements Runnable { @Override public void run ( ) { while ( disrupting & & disruptedNode ! = null ) { try { TimeValue duration = new TimeValue ( delayDurationMin + random . nextInt ( ( int ) ( delayDurationMax - delayDurationMin ) ) ) ; simulateLongGC ( duration ) ; duration = new TimeValue ( intervalBetweenDelaysMin + random . nextInt ( ( int ) ( intervalBetweenDelaysMax - intervalBetweenDelaysMin ) ) ) ; if ( disrupting & & disruptedNode ! = null ) { Thread . sleep ( duration . millis ( ) ) ; } } catch ( InterruptedException e ) { } catch ( Exception e ) { logger . error ( <str> , e ) ; } } } } } 
