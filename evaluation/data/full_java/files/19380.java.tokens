package io . netty . handler . codec . http2 . hpack ; import static io . netty . handler . codec . http2 . hpack . HeaderField . HEADER_ENTRY_OVERHEAD ; final class DynamicTable { HeaderField [ ] headerFields ; int head ; int tail ; private int size ; private int capacity = - <int> ; DynamicTable ( int initialCapacity ) { setCapacity ( initialCapacity ) ; } public int length ( ) { int length ; if ( head < tail ) { length = headerFields . length - tail + head ; } else { length = head - tail ; } return length ; } public int size ( ) { return size ; } public int capacity ( ) { return capacity ; } public HeaderField getEntry ( int index ) { if ( index < = <int> | | index > length ( ) ) { throw new IndexOutOfBoundsException ( ) ; } int i = head - index ; if ( i < <int> ) { return headerFields [ i + headerFields . length ] ; } else { return headerFields [ i ] ; } } public void add ( HeaderField header ) { int headerSize = header . size ( ) ; if ( headerSize > capacity ) { clear ( ) ; return ; } while ( size + headerSize > capacity ) { remove ( ) ; } headerFields [ head + + ] = header ; size + = header . size ( ) ; if ( head = = headerFields . length ) { head = <int> ; } } public HeaderField remove ( ) { HeaderField removed = headerFields [ tail ] ; if ( removed = = null ) { return null ; } size - = removed . size ( ) ; headerFields [ tail + + ] = null ; if ( tail = = headerFields . length ) { tail = <int> ; } return removed ; } public void clear ( ) { while ( tail ! = head ) { headerFields [ tail + + ] = null ; if ( tail = = headerFields . length ) { tail = <int> ; } } head = <int> ; tail = <int> ; size = <int> ; } public void setCapacity ( int capacity ) { if ( capacity < <int> ) { throw new IllegalArgumentException ( <str> + capacity ) ; } if ( this . capacity = = capacity ) { return ; } this . capacity = capacity ; if ( capacity = = <int> ) { clear ( ) ; } else { while ( size > capacity ) { remove ( ) ; } } int maxEntries = capacity / HEADER_ENTRY_OVERHEAD ; if ( capacity % HEADER_ENTRY_OVERHEAD ! = <int> ) { maxEntries + + ; } if ( headerFields ! = null & & headerFields . length = = maxEntries ) { return ; } HeaderField [ ] tmp = new HeaderField [ maxEntries ] ; int len = length ( ) ; int cursor = tail ; for ( int i = <int> ; i < len ; i + + ) { HeaderField entry = headerFields [ cursor + + ] ; tmp [ i ] = entry ; if ( cursor = = headerFields . length ) { cursor = <int> ; } } this . tail = <int> ; this . head = tail + len ; this . headerFields = tmp ; } } 
