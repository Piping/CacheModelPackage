package com . google . common . reflect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Maps ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . TestMapGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class ImmutableTypeToInstanceMapTest extends TestCase { @AndroidIncompatible public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableTypeToInstanceMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestTypeToInstanceMapGenerator ( ) { @Override @SuppressWarnings ( <str> ) public Map < TypeToken , Object > create ( Object . . . elements ) { ImmutableTypeToInstanceMap . Builder < Object > builder = ImmutableTypeToInstanceMap . builder ( ) ; for ( Object object : elements ) { Entry < TypeToken , Object > entry = ( Entry < TypeToken , Object > ) object ; builder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ( Map ) builder . build ( ) ; } } ) . named ( <str> ) . withFeatures ( MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . RESTRICTS_KEYS , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } public void testEmpty ( ) { assertEquals ( <int> , ImmutableTypeToInstanceMap . of ( ) . size ( ) ) ; } public void testPrimitiveAndWrapper ( ) { ImmutableTypeToInstanceMap < Number > map = ImmutableTypeToInstanceMap . < Number > builder ( ) . put ( Integer . class , <int> ) . put ( int . class , <int> ) . build ( ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( Integer . class ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( TypeToken . of ( Integer . class ) ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( int . class ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( TypeToken . of ( int . class ) ) ) ; } public void testParameterizedType ( ) { TypeToken < ImmutableList < Integer > > type = new TypeToken < ImmutableList < Integer > > ( ) { } ; ImmutableTypeToInstanceMap < Iterable < ? > > map = ImmutableTypeToInstanceMap . < Iterable < ? > > builder ( ) . put ( type , ImmutableList . of ( <int> ) ) . build ( ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableList . of ( <int> ) , map . getInstance ( type ) ) ; } public void testGeneriArrayType ( ) { @SuppressWarnings ( <str> ) ImmutableList < Integer > [ ] array = new ImmutableList [ ] { ImmutableList . of ( <int> ) } ; TypeToken < ImmutableList < Integer > [ ] > type = new TypeToken < ImmutableList < Integer > [ ] > ( ) { } ; ImmutableTypeToInstanceMap < Iterable < ? > [ ] > map = ImmutableTypeToInstanceMap . < Iterable < ? > [ ] > builder ( ) . put ( type , array ) . build ( ) ; assertEquals ( <int> , map . size ( ) ) ; assertThat ( map . getInstance ( type ) ) . asList ( ) . containsExactly ( array [ <int> ] ) ; } public void testWildcardType ( ) { TypeToken < ImmutableList < ? > > type = new TypeToken < ImmutableList < ? > > ( ) { } ; ImmutableTypeToInstanceMap < Iterable < ? > > map = ImmutableTypeToInstanceMap . < Iterable < ? > > builder ( ) . put ( type , ImmutableList . of ( <int> ) ) . build ( ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableList . of ( <int> ) , map . getInstance ( type ) ) ; } public void testGetInstance_containsTypeVariable ( ) { ImmutableTypeToInstanceMap < Iterable < Number > > map = ImmutableTypeToInstanceMap . of ( ) ; try { map . getInstance ( this . < Number > anyIterableType ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPut_containsTypeVariable ( ) { ImmutableTypeToInstanceMap . Builder < Iterable < Integer > > builder = ImmutableTypeToInstanceMap . builder ( ) ; try { builder . put ( this . < Integer > anyIterableType ( ) , ImmutableList . of ( <int> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } private < T > TypeToken < Iterable < T > > anyIterableType ( ) { return new TypeToken < Iterable < T > > ( ) { } ; } abstract static class TestTypeToInstanceMapGenerator implements TestMapGenerator < TypeToken , Object > { @Override public TypeToken [ ] createKeyArray ( int length ) { return new TypeToken [ length ] ; } @Override public Object [ ] createValueArray ( int length ) { return new Object [ length ] ; } @Override public SampleElements < Entry < TypeToken , Object > > samples ( ) { Entry < TypeToken , Object > entry1 = Maps . immutableEntry ( ( TypeToken ) TypeToken . of ( Integer . class ) , ( Object ) <int> ) ; Entry < TypeToken , Object > entry2 = Maps . immutableEntry ( ( TypeToken ) TypeToken . of ( Number . class ) , ( Object ) <int> ) ; Entry < TypeToken , Object > entry3 = Maps . immutableEntry ( ( TypeToken ) new TypeToken < ImmutableList < Integer > > ( ) { } , ( Object ) ImmutableList . of ( <int> ) ) ; Entry < TypeToken , Object > entry4 = Maps . immutableEntry ( ( TypeToken ) new TypeToken < int [ ] > ( ) { } , ( Object ) new int [ ] { <int> } ) ; Entry < TypeToken , Object > entry5 = Maps . immutableEntry ( ( TypeToken ) new TypeToken < Iterable < ? > > ( ) { } , ( Object ) ImmutableList . of ( <str> ) ) ; return new SampleElements < Entry < TypeToken , Object > > ( entry1 , entry2 , entry3 , entry4 , entry5 ) ; } @Override @SuppressWarnings ( <str> ) public Entry < TypeToken , Object > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < TypeToken , Object > > order ( List < Entry < TypeToken , Object > > insertionOrder ) { return insertionOrder ; } } } 
