module RubyToken EXPR_BEG = <str> EXPR_MID = <str> EXPR_END = <str> EXPR_ARG = <str> EXPR_FNAME = <str> EXPR_DOT = <str> EXPR_CLASS = <str> class Token def initialize ( seek , line_no , char_no ) @seek = seek @line_no = line_no @char_no = char_no end attr_reader <str> , <str> , <str> end class TkNode < Token def initialize ( seek , line_no , char_no ) super end attr_reader <str> end class TkId < Token def initialize ( seek , line_no , char_no , name ) super ( seek , line_no , char_no ) @name = name end attr_reader <str> end class TkVal < Token def initialize ( seek , line_no , char_no , value = nil ) super ( seek , line_no , char_no ) @value = value end attr_reader <str> end class TkOp < Token attr_accessor <str> end class TkOPASGN < TkOp def initialize ( seek , line_no , char_no , op ) super ( seek , line_no , char_no ) op = TkReading2Token [ op ] [ <int> ] unless op . kind_of? ( Symbol ) @op = op end attr_reader <str> end class TkUnknownChar < Token def initialize ( seek , line_no , char_no , id ) super ( seek , line_no , char_no ) @name = name end attr_reader <str> end class TkError < Token end def Token ( token , value = nil ) case token when String if ( tk = TkReading2Token [ token ] ) . nil? IRB . fail TkReading2TokenNoKey , token end tk = Token ( tk [ <int> ] , value ) if tk . kind_of? ( TkOp ) tk . name = token end return tk when Symbol if ( tk = TkSymbol2Token [ token ] ) . nil? IRB . fail TkSymbol2TokenNoKey , token end return Token ( tk [ <int> ] , value ) else if ( token . ancestors & [ TkId , TkVal , TkOPASGN , TkUnknownChar ] ) . empty? token . new ( @prev_seek , @prev_line_no , @prev_char_no ) else token . new ( @prev_seek , @prev_line_no , @prev_char_no , value ) end end end TokenDefinitions = [ [ <str> , TkId , <str> , EXPR_CLASS ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_FNAME ] , [ <str> , TkId , <str> , EXPR_FNAME ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_MID ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_BEG , <str> ] , [ <str> , TkId , <str> , EXPR_BEG , <str> ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG , <str> ] , [ <str> , TkId , <str> , EXPR_BEG , <str> ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_MID ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId , <str> , EXPR_BEG ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId , <str> , EXPR_FNAME ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> , EXPR_END ] , [ <str> , TkId , <str> __LINE__ <str> , EXPR_END ] , [ <str> , TkId , <str> __FILE__ <str> , EXPR_END ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkId ] , [ <str> , TkVal ] , [ <str> , TkVal ] , [ <str> , TkVal ] , [ <str> , TkVal ] , [ <str> , TkVal ] , [ <str> , TkVal ] , [ <str> , TkNode ] , [ <str> , TkNode ] , [ <str> , TkNode ] , [ <str> , TkNode ] , [ <str> , TkNode ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp ] , [ <str> , TkOp ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , TkOp , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> , Token , <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> , TkUnknownChar , <str> ] , [ <str> , TkUnknownChar , <str> ] , [ <str> , TkUnknownChar , <str> ] , ] TkReading2Token = { } TkSymbol2Token = { } def RubyToken . def_token ( token_n , super_token = Token , reading = nil , * opts ) token_n = token_n . id2name if token_n . kind_of? ( Symbol ) if RubyToken . const_defined? ( token_n ) IRB . fail AlreadyDefinedToken , token_n end token_c = eval ( <str> token_n <str> super_token <str> token_n <str> ) if reading if TkReading2Token [ reading ] IRB . fail TkReading2TokenDuplicateError , token_n , reading end if opts . empty? TkReading2Token [ reading ] = [ token_c ] else TkReading2Token [ reading ] = [ token_c ] . concat ( opts ) end end TkSymbol2Token [ token_n . intern ] = token_c end for defs in TokenDefinitions def_token ( * defs ) end end 
