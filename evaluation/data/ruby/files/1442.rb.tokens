require <str> require <str> class TestDateConv < Test :: Unit :: TestCase def test_to_class [ Time . now , Date . today , DateTime . now ] . each do | o | assert_instance_of ( Time , o . to_time ) assert_instance_of ( Date , o . to_date ) assert_instance_of ( DateTime , o . to_datetime ) end end def test_to_time__from_time t = Time . mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) t2 = t . to_time assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t2 . year , t2 . mon , t2 . mday , t2 . hour , t2 . min , t2 . sec , t2 . usec ] ) t = Time . utc ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) t2 = t . to_time . utc assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t2 . year , t2 . mon , t2 . mday , t2 . hour , t2 . min , t2 . sec , t2 . usec ] ) end def test_to_time__from_date d = Date . new ( <int> , <int> , <int> ) t = d . to_time assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t . year , t . mon , t . mday , t . hour , t . min , t . sec , t . usec ] ) end def test_to_time__from_datetime d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> ) + <int> . to_r / <int> t = d . to_time if t . utc_offset == <int> * <int> * <int> assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t . year , t . mon , t . mday , t . hour , t . min , t . sec , t . usec ] ) end d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) + <int> . to_r / <int> t = d . to_time . utc assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t . year , t . mon , t . mday , t . hour , t . min , t . sec , t . usec ] ) if Time . allocate . respond_to? ( <str> ) d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) + <int> . to_r / <int> t = d . to_time . utc assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ t . year , t . mon , t . mday , t . hour , t . min , t . sec , t . nsec ] ) end if Time . allocate . respond_to? ( <str> ) d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) + <int> . to_r / <int> t = d . to_time . utc assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , Rational ( <int> , <int> ) ] , [ t . year , t . mon , t . mday , t . hour , t . min , t . sec , t . subsec ] ) end end def test_to_date__from_time t = Time . mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) d = t . to_date assert_equal ( [ <int> , <int> , <int> , <int> ] , [ d . year , d . mon , d . mday , d . day_fraction ] ) t = Time . utc ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) d = t . to_date assert_equal ( [ <int> , <int> , <int> , <int> ] , [ d . year , d . mon , d . mday , d . day_fraction ] ) end def test_to_date__from_date d = Date . new ( <int> , <int> , <int> ) + <int> . to_r / <int> d2 = d . to_date assert_equal ( [ <int> , <int> , <int> , <int> . to_r / <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . day_fraction ] ) end def test_to_date__from_datetime d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> ) + <int> . to_r / <int> d2 = d . to_date assert_equal ( [ <int> , <int> , <int> , <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . day_fraction ] ) d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) + <int> . to_r / <int> d2 = d . to_date assert_equal ( [ <int> , <int> , <int> , <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . day_fraction ] ) end def test_to_datetime__from_time t = Time . mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) d = t . to_datetime assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> , t . utc_offset . to_r / <int> ] , [ d . year , d . mon , d . mday , d . hour , d . min , d . sec , d . sec_fraction , d . offset ] ) t = Time . utc ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) d = t . to_datetime assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> , <int> ] , [ d . year , d . mon , d . mday , d . hour , d . min , d . sec , d . sec_fraction , d . offset ] ) t = Time . now d = t . to_datetime require <str> assert_equal ( t . iso8601 ( <int> ) , d . iso8601 ( <int> ) ) end def test_to_datetime__from_date d = Date . new ( <int> , <int> , <int> ) + <int> . to_r / <int> d2 = d . to_datetime assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . hour , d2 . min , d2 . sec , d2 . sec_fraction , d2 . offset ] ) end def test_to_datetime__from_datetime d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> ) + <int> . to_r / <int> d2 = d . to_datetime assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> , <int> . to_r / <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . hour , d2 . min , d2 . sec , d2 . sec_fraction , d2 . offset ] ) d = DateTime . new ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) + <int> . to_r / <int> d2 = d . to_datetime assert_equal ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> . to_r / <int> , <int> ] , [ d2 . year , d2 . mon , d2 . mday , d2 . hour , d2 . min , d2 . sec , d2 . sec_fraction , d2 . offset ] ) end end 
