require <str> demodir = File . dirname ( $0 ) themesdir = File . join ( demodir , <str> ) Tk :: AUTO_PATH . lappend ( <str> , demodir , themesdir ) Dir . foreach ( themesdir ) { | name | next if name == <str> || name == <str> dir = File . join ( themesdir , name ) Tk :: AUTO_PATH . lappend ( dir ) if File . directory? ( dir ) } require <str> def version? ( ver ) TkPackage . vcompare ( Tk :: Tile . package_version , ver ) > = <int> end Tk :: Tile . __define_LoadImages_proc_for_compatibility__! Tk :: Tile :: Style . __define_wrapper_proc_for_compatibility__! unless Tk :: Tile :: Style . theme_names . include? ( <str> ) Tk :: Tile :: Style . theme_create ( <str> ) end Tk . load_tclscript ( File . join ( demodir , <str> ) ) Tk . load_tclscript ( File . join ( demodir , <str> ) ) Tk . ip_eval ( <str> TkPackage . unknown_proc <str> TkPackage . provide ( <str> ) <str> ) TkRoot . new { title <str> iconname <str> } $THEMELIST = [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , ] $V = TkVariable . new_hash ( <str> = > <str> , <str> = > <str> , <str> = > false , <str> = > <str> , <str> = > true , <str> = > <str> , <str> = > true , <str> = > <int> ) TkPackage . names . find_all { | n | n =~ <str> } . each { | pkg | name = pkg . split ( <str> ) [ - <int> ] unless $THEMELIST . assoc ( name ) $THEMELIST << [ name , Tk . tk_call ( <str> , <str> , name ) ] end } $RUBY_THEMELIST = [ ] begin load ( File . join ( demodir , <str> , <str> ) , true ) rescue = > e raise e $RUBY_THEMELIST << [ <str> , <str> , false ] else $RUBY_THEMELIST << [ <str> , <str> , true ] end def makeThemeControl ( parent ) c = Tk :: Tile :: Labelframe . new ( parent , <str> = > <str> ) $THEMELIST . each { | theme , name | b = Tk :: Tile :: Radiobutton . new ( c , <str> = > name , <str> = > theme , <str> = > $V . ref ( <str> ) , <str> = > proc { setTheme ( theme ) } ) b . grid ( <str> = > <str> ) unless ( TkPackage . names . find { | n | n =~ <str> theme <str> } ) b . ttk_state ( <str> ) end } $RUBY_THEMELIST . each { | theme , name , available | b = Tk :: Tile :: Radiobutton . new ( c , <str> = > name , <str> = > theme , <str> = > $V . ref ( <str> ) , <str> = > proc { setTheme ( theme ) } ) b . grid ( <str> = > <str> ) b . ttk_state ( <str> ) unless available } c end def makeThemeMenu ( parent ) m = TkMenu . new ( parent ) $THEMELIST . each { | theme , name | m . add ( <str> , <str> = > name , <str> = > $V . ref ( <str> ) , <str> = > theme , <str> = > proc { setTheme ( theme ) } ) unless ( TkPackage . names . find { | n | n =~ <str> theme <str> } ) m . entryconfigure ( <str> , <str> = > <str> ) end } $RUBY_THEMELIST . each { | theme , name , available | m . add ( <str> , <str> = > name , <str> = > $V . ref ( <str> ) , <str> = > theme , <str> = > proc { setTheme ( theme ) } ) m . entryconfigure ( <str> , <str> = > <str> ) unless available } m end def setTheme ( theme ) if ( pkg = TkPackage . names . find { | n | n =~ <str> theme <str> } ) unless Tk :: Tile :: Style . theme_names . find { | n | n == theme } TkPackage . require ( pkg ) end end Tk :: Tile :: Style . theme_use ( theme ) end $BUTTONS = [ <str> , <str> , <str> ] $CHECKBOXES = [ <str> , <str> ] $ICON = { } def loadIcons ( file ) Tk . load_tclscript ( file ) img_data = TkVarAccess . new ( <str> ) img_data . keys . each { | icon | $ICON [ icon ] = TkPhotoImage . new ( <str> = > img_data [ icon ] ) } end loadIcons ( File . join ( demodir , <str> ) ) def foreachWidget ( wins , cmd ) wins . each { | w | cmd . call ( w ) foreachWidget ( w . winfo_children , cmd ) } end def sbstub ( sb , cmd , num , units = <str> ) num = TkComm . number ( num ) case cmd . to_s when <str> sb . set ( num , num + <int> . <int> ) when <str> if units . to_s == <str> delta = <int> . <int> else delta = <int> . <oct> end current = sb . get sb . set ( current [ <int> ] + delta * num , current [ <int> ] + delta * num ) end end TkBindTag :: ALL . bind ( <str> , proc { | w | $W = w } , <str> ) TkBindTag :: ALL . bind ( <str> , proc { | w | w . set_focus } , <str> ) def showHelp ( ) Tk . messageBox ( <str> = > <str> ) end TkOption . add ( <str> , <str> ) TkOption . add ( <str> , <int> ) TkOption . add ( <str> , <int> ) $ROOT = Tk . root $BASE = $ROOT Tk . destroy ( * ( $ROOT . winfo_children ) ) $TOOLBARS = [ ] def makeToolbars tb = Tk :: Tile :: Frame . new ( $BASE , <str> = > <str> ) $TOOLBARS << tb i = <int> $BUTTONS . each { | icon | i += <int> Tk :: Tile :: Button . new ( tb , <str> = > icon , <str> = > $ICON [ icon ] , <str> = > $V [ <str> ] , <str> = > <str> ) . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) } $CHECKBOXES . each { | icon | i += <int> Tk :: Tile :: Checkbutton . new ( tb , <str> = > icon , <str> = > $ICON [ icon ] , <str> = > $V . ref ( icon ) , <str> = > $V [ <str> ] , <str> = > <str> ) . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) } mb = Tk :: Tile :: Menubutton . new ( tb , <str> = > <str> , <str> = > $ICON [ <str> ] , <str> = > $V [ <str> ] ) mb . configure ( <str> = > makeCompoundMenu ( mb ) ) i += <int> mb . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) i += <int> tb . grid_columnconfigure ( i , <str> = > <int> ) tb = TkFrame . new ( $BASE , <str> = > <str> ) $TOOLBARS << tb i = <int> $BUTTONS . each { | icon | i += <int> TkButton . new ( tb , <str> = > icon , <str> = > $ICON [ icon ] , <str> = > $V [ <str> ] , <str> = > <str> , <str> = > <str> ) . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) } $CHECKBOXES . each { | icon | i += <int> TkCheckbutton . new ( tb , <str> = > icon , <str> = > $ICON [ icon ] , <str> = > $V . ref ( icon ) , <str> = > $V [ <str> ] , <str> = > false , <str> = > <str> , <str> = > <str> , <str> = > <str> ) . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) } mb = TkMenubutton . new ( tb , <str> = > <str> , <str> = > $ICON [ <str> ] , <str> = > $V [ <str> ] ) mb . configure ( <str> = > makeCompoundMenu ( mb ) ) i += <int> mb . grid ( <str> = > <int> , <str> = > i , <str> = > <str> ) i += <int> tb . grid_columnconfigure ( i , <str> = > <int> ) end def makeCompoundMenu ( mb ) menu = TkMenu . new ( mb ) <str> . each { | str | menu . add ( <str> , <str> = > Tk . tk_call ( <str> , <str> , str ) , <str> = > $V . ref ( <str> ) , <str> = > str , <str> = > proc { changeToolbars ( ) } ) } menu end makeToolbars ( ) control = Tk :: Tile :: Frame . new ( $BASE ) makeThemeControl ( control ) . grid ( <str> = > <str> , <str> = > <int> , <str> = > <int> ) control . grid_rowconfigure ( <int> , <str> = > <int> ) def changeToolbars foreachWidget ( $TOOLBARS , proc { | w | begin w . compound ( $V [ <str> ] ) rescue end } ) end def scrolledWidget ( parent , klass , themed , * args ) if themed f = Tk :: Tile :: Frame . new ( parent ) t = klass . new ( f , * args ) vs = Tk :: Tile :: Scrollbar . new ( f ) hs = Tk :: Tile :: Scrollbar . new ( f ) else f = TkFrame . new ( parent ) t = klass . new ( f , * args ) vs = TkScrollbar . new ( f ) hs = TkScrollbar . new ( f ) end t . yscrollbar ( vs ) t . xscrollbar ( hs ) TkGrid . configure ( t , vs , <str> = > <str> ) TkGrid . configure ( hs , <str> , <str> = > <str> ) TkGrid . rowconfigure ( f , <int> , <str> = > <int> ) TkGrid . columnconfigure ( f , <int> , <str> = > <int> ) [ f , t ] end def makeNotebook nb = Tk :: Tile :: Notebook . new ( $BASE , <str> = > <int> ) nb . enable_traversal client = Tk :: Tile :: Frame . new ( nb ) nb . add ( client , <str> = > <str> , <str> = > <int> ) nb . select ( client ) scales = Tk :: Tile :: Frame . new ( nb ) nb . add ( scales , <str> = > <str> ) combo = Tk :: Tile :: Frame . new ( nb ) nb . add ( combo , <str> = > <str> , <str> = > <int> ) tree = Tk :: Tile :: Frame . new ( nb ) nb . add ( tree , <str> = > <str> ) others = Tk :: Tile :: Frame . new ( nb ) nb . add ( others , <str> = > <str> , <str> = > <int> ) [ nb , client , scales , combo , tree , others ] end nb , client , scales , combo , tree , others = makeNotebook ( ) def fillMenu ( menu ) <str> . each { | dir | menu . add ( <str> , <str> = > Tk . tk_call ( <str> , <str> , dir ) , <str> = > proc { menu . winfo_parent . direction ( dir ) } ) } menu . add ( <str> , <str> = > <str> , <str> = > ( submenu = TkMenu . new ( menu ) ) ) submenu . add ( <str> , <str> = > <str> ) submenu . add ( <str> , <str> = > <str> ) submenu . add ( <str> , <str> = > <str> ) menu . add ( <str> ) menu . add ( <str> , <str> = > <str> , <str> = > proc { Tk . root . destroy } ) end l = Tk :: Tile :: Labelframe . new ( client , <str> = > <str> , <str> = > <int> ) r = TkLabelframe . new ( client , <str> = > <str> , <str> = > <int> , <str> = > <int> ) cb = Tk :: Tile :: Checkbutton . new ( l , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> ) rb1 = Tk :: Tile :: Radiobutton . new ( l , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> , <str> = > <int> ) rb2 = Tk :: Tile :: Radiobutton . new ( l , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> ) rb3 = Tk :: Tile :: Radiobutton . new ( l , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> , <str> = > <int> ) btn = Tk :: Tile :: Button . new ( l , <str> = > <str> , <str> = > <int> ) mb = Tk :: Tile :: Menubutton . new ( l , <str> = > <str> , <str> = > <int> ) m = TkMenu . new ( mb ) mb . menu ( m ) fillMenu ( m ) $entryText = TkVariable . new ( <str> ) e = Tk :: Tile :: Entry . new ( l , <str> = > $entryText ) e . selection_range ( <int> , <str> ) ltext_f , ltext = scrolledWidget ( l , TkText , true , <str> = > <int> , <str> = > <int> , <str> = > <str> ) Tk . grid ( cb , <str> = > <str> ) Tk . grid ( rb1 , <str> = > <str> ) Tk . grid ( rb2 , <str> = > <str> ) Tk . grid ( rb3 , <str> = > <str> ) Tk . grid ( btn , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( mb , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( e , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( ltext_f , <str> = > <str> ) TkGrid . columnconfigure ( l , <int> , <str> = > <int> ) TkGrid . rowconfigure ( l , <int> , <str> = > <int> ) cb = TkCheckbutton . new ( r , <str> = > <str> , <str> = > $V . ref ( <str> ) ) rb1 = TkRadiobutton . new ( r , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> ) rb2 = TkRadiobutton . new ( r , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> , <str> = > <int> ) rb3 = TkRadiobutton . new ( r , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > <int> ) btn = TkButton . new ( r , <str> = > <str> ) mb = TkMenubutton . new ( r , <str> = > <str> , <str> = > <int> , <str> = > true ) m = TkMenu . new ( mb ) mb . menu ( m ) $V [ <str> ] = mb . indicatoron m . add ( <str> , <str> = > <str> , <str> = > $V . ref ( <str> ) , <str> = > proc { mb . indicatoron ( $V [ <str> ] ) } ) m . add ( <str> ) fillMenu ( m ) e = TkEntry . new ( r , <str> = > $entryText ) rtext_f , rtext = scrolledWidget ( r , TkText , false , <str> = > <int> , <str> = > <int> , <str> = > <str> ) Tk . grid ( cb , <str> = > <str> ) Tk . grid ( rb1 , <str> = > <str> ) Tk . grid ( rb2 , <str> = > <str> ) Tk . grid ( rb3 , <str> = > <str> ) Tk . grid ( btn , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( mb , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( e , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( rtext_f , <str> = > <str> ) TkGrid . columnconfigure ( l , <int> , <str> = > <int> ) TkGrid . rowconfigure ( l , <int> , <str> = > <int> ) Tk . grid ( l , r , <str> = > <str> , <str> = > <int> , <str> = > <int> ) TkGrid . rowconfigure ( client , <int> , <str> = > <int> ) TkGrid . columnconfigure ( client , [ <int> , <int> ] , <str> = > <int> ) msgs = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] nmsgs = msgs . size ( <int> ... <int> ) . each { | n | msg = msgs [ n % nmsgs ] ltext . insert ( <str> , <str> n <str> msg <str> ) rtext . insert ( <str> , <str> n <str> msg <str> ) } l = Tk :: Tile :: Labelframe . new ( scales , <str> = > <str> , <str> = > <int> ) r = TkLabelframe . new ( scales , <str> = > <str> , <str> = > <int> , <str> = > <int> ) if version? ( <str> ) scale = Tk :: Tile :: Scale . new ( l , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > $V . ref ( <str> ) ) vscale = Tk :: Tile :: Scale . new ( l , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > $V . ref ( <str> ) ) progress = Tk :: Tile :: Progressbar . new ( l , <str> = > <str> , <str> = > <int> ) vprogress = Tk :: Tile :: Progressbar . new ( l , <str> = > <str> , <str> = > <int> ) if true def progress . inverted ( w , value ) if w . mode == <str> w . value ( value ) else w . value ( w . maximum - value ) end end scale . command { | value | progress . value ( value ) } vscale . command { | value | progress . inverted ( vprogress , value ) } else progress . variable $V . ref ( <str> ) vprogress . variable $V . ref ( <str> ) end scale . set ( <int> ) vscale . set ( <int> ) lmode = Tk :: Tile :: Label . new ( l , <str> = > <str> ) pbmode0 = Tk :: Tile :: Radiobutton . new ( l , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > <str> , <str> = > proc { pbMode ( progress , vprogress ) } ) pbmode1 = Tk :: Tile :: Radiobutton . new ( l , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > <str> , <str> = > proc { pbMode ( progress , vprogress ) } ) def pbMode ( progress , vprogress ) if vprogress . mode != $V [ <str> ] vprogress . value ( vprogress . maximum - vprogress . value ) end progress . mode $V [ <str> ] vprogress . mode $V [ <str> ] end start = Tk :: Tile :: Button . new ( l , <str> = > <str> , <str> = > proc { pbStart ( progress , vprogress ) } ) def pbStart ( progress , vprogress ) pbMode ( progress , vprogress ) progress . start <int> vprogress . start end stop = Tk :: Tile :: Button . new ( l , <str> = > <str> , <str> = > proc { pbStop ( progress , vprogress ) } ) def pbStop ( progress , vprogress ) progress . stop vprogress . stop end Tk . grid ( scale , <str> = > <int> , <str> = > <str> ) Tk . grid ( progress , <str> = > <int> , <str> = > <str> ) Tk . grid ( vscale , vprogress , <str> = > <str> ) Tk . grid ( lmode , <str> = > <str> , <str> = > <int> ) Tk . grid ( pbmode0 , <str> = > <str> , <str> = > <int> ) Tk . grid ( pbmode1 , <str> = > <str> , <str> = > <int> ) Tk . grid ( start , <str> = > <str> , <str> = > <int> ) Tk . grid ( stop , <str> = > <str> , <str> = > <int> ) l . grid_columnconfigure ( <int> , <str> = > <int> ) l . grid_columnconfigure ( <int> , <str> = > <int> ) l . grid_rowconfigure ( <int> , <str> = > <int> ) TkScale . new ( r , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > $V . ref ( <str> ) ) . grid ( <str> = > <str> ) TkScale . new ( r , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > $V . ref ( <str> ) ) . grid ( <str> = > <str> ) r . grid_columnconfigure ( <int> , <str> = > <int> ) r . grid_columnconfigure ( <int> , <str> = > <int> ) r . grid_rowconfigure ( <int> , <str> = > <int> ) else scale = Tk :: Tile :: Scale . new ( l , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > <int> , <str> = > <int> ) vscale = Tk :: Tile :: Scale . new ( l , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > - <int> , <str> = > <int> ) progress = Tk :: Tile :: Progress . new ( l , <str> = > <str> , <str> = > <int> , <str> = > <int> ) vprogress = Tk :: Tile :: Progress . new ( l , <str> = > <str> , <str> = > - <int> , <str> = > <int> ) if true scale . command { | value | progress . set ( value ) } vscale . command { | value | vprogress . set ( value ) } else v1 = scale . variable v2 = vscale . variable v1 . trace ( <str> , proc { progress . set ( v1 . value ) } ) v2 . trace ( <str> , proc { vprogress . set ( v2 . value ) } ) end Tk . grid ( scale , <str> = > <int> , <str> = > <str> ) Tk . grid ( progress , <str> = > <int> , <str> = > <str> ) Tk . grid ( vscale , vprogress , <str> = > <str> ) TkGrid . columnconfigure ( l , <int> , <str> = > <int> ) TkGrid . columnconfigure ( l , <int> , <str> = > <int> ) TkScale . new ( r , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > <int> , <str> = > <int> ) . grid ( <str> = > <str> ) TkScale . new ( r , <str> = > $V . ref ( <str> ) , <str> = > <str> , <str> = > - <int> , <str> = > <int> ) . grid ( <str> = > <str> ) TkGrid . columnconfigure ( r , <int> , <str> = > <int> ) TkGrid . columnconfigure ( r , <int> , <str> = > <int> ) end Tk . grid ( l , r , <str> = > <str> , <str> = > <int> , <str> = > <int> ) scales . grid_columnconfigure ( <int> , <str> = > <int> ) scales . grid_columnconfigure ( <int> , <str> = > <int> ) scales . grid_rowconfigure ( <int> , <str> = > <int> ) cmd = Tk :: Tile :: Frame . new ( $BASE ) b_close = Tk :: Tile :: Button . new ( cmd , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > proc { Tk . root . destroy } ) b_help = Tk :: Tile :: Button . new ( cmd , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > proc { showHelp ( ) } ) Tk . grid ( <str> , b_close , b_help , <str> = > [ <int> , <int> ] , <str> = > <int> ) TkGrid . columnconfigure ( cmd , <int> , <str> = > <int> ) $ROOT . bind ( <str> , proc { Tk . event_generate ( b_close , <str> ) } ) $ROOT . bind ( <str> , proc { Tk . event_generate ( b_help , <str> ) } ) Tk :: Tile :: KeyNav . enableMnemonics ( $ROOT ) Tk :: Tile :: KeyNav . defaultButton ( b_help ) Tk . grid ( $TOOLBARS [ <int> ] , <str> , <str> = > <str> ) Tk . grid ( $TOOLBARS [ <int> ] , <str> , <str> = > <str> ) Tk . grid ( control , nb , <str> = > <str> ) Tk . grid ( cmd , <str> , <str> = > <str> ) TkGrid . columnconfigure ( $ROOT , <int> , <str> = > <int> ) TkGrid . rowconfigure ( $ROOT , <int> , <str> = > <int> ) menu = TkMenu . new ( $BASE ) $ROOT . menu ( menu ) m_file = TkMenu . new ( menu , <str> = > <int> ) menu . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > m_file ) m_file . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > $ICON [ <str> ] ) m_file . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > $ICON [ <str> ] ) m_file . add ( <str> ) m_f_test = TkMenu . new ( menu , <str> = > <int> ) m_file . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > m_f_test ) m_file . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > $V . ref ( <str> ) ) m_file . insert ( <str> , <str> ) if Tk . windowingsystem != <str> TkConsole . create m_file . insert ( <str> , <str> , <str> = > <str> , <str> = > <int> , <str> = > $V . ref ( <str> ) , <str> = > proc { toggle_console ( ) } ) def toggle_console if TkComm . bool ( $V [ <str> ] ) TkConsole . show else TkConsole . hide end end end m_file . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > proc { Tk . event_generate ( b_close , <str> ) } ) <str> . each { | lbl | m_f_test . add ( <str> , <str> = > lbl , <str> = > $V . ref ( <str> ) ) } menu . add ( <str> , <str> = > <str> , <str> = > <int> , <str> = > makeThemeMenu ( menu ) ) setTheme ( $V [ <str> ] ) values = <str> <int> . times { | i | cb = Tk :: Tile :: Combobox . new ( combo , <str> = > values , <str> = > $V . ref ( <str> ) ) cb . pack ( <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > false , <str> = > <str> ) if i == <int> cb . ttk_state <str> begin cb . current = <int> rescue end end } if version? ( <str> ) treeview = nil scrollbar = Tk :: Tile :: Scrollbar . new ( tree , <str> = > proc { | * args | treeview . yview ( * args ) } ) treeview = Tk :: Tile :: Treeview . new ( tree , <str> = > <str> , <str> = > <int> , <str> = > proc { | * args | scrollbar . set ( * args ) } ) Tk . grid ( treeview , scrollbar , <str> = > <str> ) tree . grid_columnconfigure ( <int> , <str> = > <int> ) tree . grid_rowconfigure ( <int> , <str> = > <int> ) tree . grid_propagate ( <int> ) treeview . insert ( <str> , <int> , <str> = > <str> , <str> = > <str> , <str> = > false , <str> = > [ TkWinfo . classname ( <str> ) ] ) treeview . headingconfigure ( <str> , <str> = > <str> ) treeview . headingconfigure ( <str> , <str> = > <str> ) treeview . bind ( <str> , proc { fillTree ( treeview ) } ) def fillTree ( treeview ) id = treeview . focus_item unless TkWinfo . exist? ( id ) treeview . delete ( id ) end treeview . delete ( treeview . children ( id ) ) for child in TkWinfo . children ( id ) treeview . insert ( id , <str> , <str> = > child , <str> = > TkWinfo . appname ( child ) , <str> = > false , <str> = > [ TkWinfo . classname ( child ) ] ) unless TkWinfo . children ( child ) . empty? treeview . insert ( child , <str> ) end end end else Tk :: Tile :: Label . new ( tree , <str> = > <str> ) . pack end $Timers = { <str> = > nil , <str> = > nil } begin msg = Tk :: Tile :: Label . new ( others , <str> = > <str> , <str> = > <int> ) rescue msg = TkMessage . new ( others , <str> = > <int> ) end $Desc = { } showDescription = TkBindTag . new showDescription . bind ( <str> , proc { | w | msg . text ( $Desc [ w . path ] ) } , <str> ) showDescription . bind ( <str> , proc { | w | msg . text ( <str> ) } , <str> ) [ [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] ] . each { | demo_cmd , label , description | b = Tk :: Tile :: Button . new ( others , <str> = > label , <str> = > proc { self . __send__ ( demo_cmd ) } ) $Desc [ b . path ] = description b . bindtags << = showDescription b . pack ( <str> = > <str> , <str> = > false , <str> = > <str> , <str> = > <int> , <str> = > <int> ) } msg . pack ( <str> = > <str> , <str> = > true , <str> = > <str> ) $scrollbars = nil def scrollbarResizeDemo if $scrollbars begin $scrollbars . destroy rescue end end $scrollbars = TkToplevel . new ( <str> = > <str> , <str> = > <str> ) f = TkFrame . new ( $scrollbars , <str> = > <int> ) tsb = Tk :: Tile :: Scrollbar . new ( f , <str> = > proc { | * args | sbstub ( tsb , * args ) } ) sb = TkScrollbar . new ( f , <str> = > proc { | * args | sbstub ( sb , * args ) } ) Tk . grid ( tsb , sb , <str> = > <str> ) sb . set ( <int> , <int> . <int> ) f . grid_columnconfigure ( <int> , <str> = > <int> ) f . grid_columnconfigure ( <int> , <str> = > <int> ) f . grid_rowconfigure ( <int> , <str> = > <int> ) f . pack ( <str> = > true , <str> = > <str> ) end $FocusInf = TkVariable . new_hash $focus = nil def trackFocus if $focus begin $focus . destroy rescue end end $focus = TkToplevel . new ( <str> = > <str> ) i = <int> [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] . each { | label , var_index | Tk . grid ( Tk :: Tile :: Label . new ( $focus , <str> = > label , <str> = > <str> ) , Tk :: Tile :: Label . new ( $focus , <str> = > $FocusInf . ref ( var_index ) , <str> = > <int> , <str> = > <str> , <str> = > <str> ) , <str> = > <str> ) i += <int> } $focus . grid_columnconfigure ( <int> , <str> = > <int> ) $focus . grid_rowconfigure ( i , <str> = > <int> ) $focus . bind ( <str> , proc { Tk . after_cancel ( $Timers [ <str> ] ) } ) focusMonitor end def focusMonitor $FocusInf [ <str> ] = focus_win = Tk . focus if focus_win $FocusInf [ <str> ] = focus_win . winfo_classname $FocusInf [ <str> ] = Tk . focus_next ( focus_win ) else $FocusInf [ <str> ] = $FocusInf [ <str> ] = <str> end $FocusInf [ <str> ] = grab_wins = Tk . current_grabs unless grab_wins . empty? $FocusInf [ <str> ] = grab_wins [ <int> ] . grab_status else $FocusInf [ <str> ] = <str> end $Timers [ <str> ] = Tk . after ( <int> , proc { focusMonitor ( ) } ) end $Widget = TkVariable . new TkBindTag :: ALL . bind ( <str> , proc { | w | $Widget . value = w updateStates ( ) Tk . callback_break } , <str> ) $states_list = <str> $states_btns = { } $states = nil $State = TkVariable . new_hash def trackStates if $states begin $state . destroy rescue end end $states = TkToplevel . new ( <str> = > <str> ) l_inf = Tk :: Tile :: Label . new ( $states , <str> = > <str> ) l_lw = Tk :: Tile :: Label . new ( $states , <str> = > <str> , <str> = > <str> , <str> = > <str> ) l_w = Tk :: Tile :: Label . new ( $states , <str> = > $Widget , <str> = > <str> , <str> = > <str> ) Tk . grid ( l_inf , <str> , <str> = > <str> , <str> = > <int> , <str> = > <int> ) Tk . grid ( l_lw , l_w , <str> = > <str> ) $states_list . each { | st | cb = Tk :: Tile :: Checkbutton . new ( $states , <str> = > st , <str> = > $State . ref ( st ) , <str> = > proc { changeState ( st ) } ) $states_btns [ st ] = cb Tk . grid ( <str> , cb , <str> = > <str> ) } $states . grid_columnconfigure ( <int> , <str> = > <int> ) f_cmd = Tk :: Tile :: Frame . new ( $states ) Tk . grid ( <str> , f_cmd , <str> = > <str> ) b_close = Tk :: Tile :: Button . new ( f_cmd , <str> = > <str> , <str> = > proc { $states . destroy } ) Tk . grid ( <str> , b_close , <str> = > <int> , <str> = > [ <int> , <int> ] ) f_cmd . grid_columnconfigure ( <int> , <str> = > <int> ) $states . bind ( <str> , proc { Tk . event_generate ( b_close , <str> ) } ) $states . bind ( <str> , proc { Tk . after_cancel ( $Timers [ <str> ] ) } ) stateMonitor ( ) end def stateMonitor updateStates ( ) if $Widget . value != <str> $Timers [ <str> ] = Tk . after ( <int> , proc { stateMonitor ( ) } ) end def updateStates $states_list . each { | st | begin $State [ st ] = $Widget . window . ttk_instate ( st ) rescue $states_btns [ st ] . ttk_state ( <str> ) else $states_btns [ st ] . ttk_state ( <str> ) end } end def changeState ( st ) if $Widget . value != <str> if $State . bool_element ( st ) $Widget . window . ttk_state ( st ) else $Widget . window . ttk_state ( <str> st <str> ) end end end def repeatDemo if defined? ( $repeatDemo ) && $repeatDemo . exist? $repeatDemo . deiconify ; return end $repeatDemo = TkToplevel . new ( <str> = > <str> ) f = Tk :: Tile :: Frame . new ( $repeatDemo ) b = Tk :: Tile :: Button . new ( f , <str> = > <str> , <str> = > <str> ) if version? ( <str> ) p = Tk :: Tile :: Progressbar . new ( f , <str> = > <str> , <str> = > <int> ) else p = Tk :: Tile :: Progress . new ( f , <str> = > <str> , <str> = > <int> , <str> = > <int> ) def p . step i = self . get + <int> i = self . from if i > self . to self . set ( i ) end end b . command { p . step } b . pack ( <str> = > <str> , <str> = > false , <str> = > <str> , <str> = > <int> , <str> = > <int> ) p . pack ( <str> = > <str> , <str> = > true , <str> = > <str> , <str> = > <int> , <str> = > <int> ) f . pack ( <str> = > true , <str> = > <str> ) end Tk . mainloop 
