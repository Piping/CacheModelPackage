require <str> require <str> if Puppet . features . cfpropertylist? require <str> require <str> Puppet :: Type . type ( <str> ) . provide <str> , <str> = > Puppet :: Provider do desc <str> commands <str> = > <str> confine <str> = > <str> confine <str> = > <str> defaultfor <str> = > <str> AuthDB = <str> @rights = { } @rules = { } @parsed_auth_db = { } @comment = <str> PuppetToNativeAttributeMap = { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , } class << self attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> def prefetch ( resources ) self . populate_rules_rights end def instances if self . parsed_auth_db == { } self . prefetch ( nil ) end self . parsed_auth_db . collect do | k , v | new ( <str> = > k ) end end def populate_rules_rights auth_plist = Puppet :: Util :: Plist . parse_plist ( AuthDB ) raise Puppet :: Error . new ( <str> AuthDB <str> ) if not auth_plist self . rights = auth_plist [ <str> ] . dup self . rules = auth_plist [ <str> ] . dup self . parsed_auth_db = self . rights . dup self . parsed_auth_db . merge! ( self . rules . dup ) end end def initialize ( resource ) if self . class . parsed_auth_db == { } self . class . prefetch ( resource ) end super end def create new_values = { } validprops = Puppet :: Type . type ( resource . class . name ) . validproperties validprops . each do | prop | next if prop == <str> if value = resource . should ( prop ) and value != <str> new_values [ prop ] = value end end @property_hash = new_values . dup end def destroy case resource [ <str> ] when <str> destroy_right when <str> destroy_rule else raise Puppet :: Error . new ( <str> ) end end def exists? ! ! self . class . parsed_auth_db . has_key? ( resource [ <str> ] ) end def flush if resource [ <str> ] != <str> case resource [ <str> ] when <str> flush_right when <str> flush_rule else raise Puppet :: Error . new ( <str> ) end @property_hash . clear end end def destroy_right security <str> , <str> , resource [ <str> ] end def destroy_rule authdb = Puppet :: Util :: Plist . parse_plist ( AuthDB ) authdb_rules = authdb [ <str> ] . dup if authdb_rules [ resource [ <str> ] ] begin authdb [ <str> ] . delete ( resource [ <str> ] ) Puppet :: Util :: Plist . write_plist_file ( authdb , AuthDB ) rescue Errno :: EACCES = > e raise Puppet :: Error . new ( <str> AuthDB <str> e <str> , e ) end end end def flush_right cmds = [ ] cmds << <str> << <str> << <str> << resource [ <str> ] output = execute ( cmds , <str> = > false , <str> = > false ) current_values = Puppet :: Util :: Plist . parse_plist ( output ) current_values || = { } specified_values = convert_plist_to_native_attributes ( @property_hash ) new_values = current_values . merge ( specified_values ) set_right ( resource [ <str> ] , new_values ) end def flush_rule authdb = Puppet :: Util :: Plist . parse_plist ( AuthDB ) authdb_rules = authdb [ <str> ] . dup current_values = { } current_values = authdb_rules [ resource [ <str> ] ] if authdb_rules [ resource [ <str> ] ] specified_values = convert_plist_to_native_attributes ( @property_hash ) new_values = current_values . merge ( specified_values ) set_rule ( resource [ <str> ] , new_values ) end def set_right ( name , values ) values = convert_plist_to_native_attributes ( values ) tmp = Tempfile . new ( <str> ) begin Puppet :: Util :: Plist . write_plist_file ( values , tmp . path ) cmds = [ ] cmds << <str> << <str> << <str> << name execute ( cmds , <str> = > false , <str> = > false , <str> = > tmp . path . to_s ) rescue Errno :: EACCES = > e raise Puppet :: Error . new ( <str> tmp . path <str> e <str> , e ) ensure tmp . close tmp . unlink end end def set_rule ( name , values ) values = convert_plist_to_native_attributes ( values ) authdb = Puppet :: Util :: Plist . parse_plist ( AuthDB ) authdb [ <str> ] [ name ] = values begin Puppet :: Util :: Plist . write_plist_file ( authdb , AuthDB ) rescue raise Puppet :: Error . new ( <str> AuthDB <str> ) end end def convert_plist_to_native_attributes ( propertylist ) newplist = { } propertylist . each_pair do | key , value | next if key == <str> next if key == <str> case value when true , <str> value = true when false , <str> value = false end new_key = key if PuppetToNativeAttributeMap . has_key? ( key ) new_key = PuppetToNativeAttributeMap [ key ] . to_s elsif not key . is_a? ( String ) new_key = key . to_s end newplist [ new_key ] = value end newplist end def retrieve_value ( resource_name , attribute ) raise Puppet :: Error . new ( <str> resource_name <str> ) if not self . class . parsed_auth_db . has_key? ( resource_name ) if PuppetToNativeAttributeMap . has_key? ( attribute ) native_attribute = PuppetToNativeAttributeMap [ attribute ] else native_attribute = attribute . to_s end if self . class . parsed_auth_db [ resource_name ] . has_key? ( native_attribute ) value = self . class . parsed_auth_db [ resource_name ] [ native_attribute ] case value when true , <str> value = <str> when false , <str> value = <str> end @property_hash [ attribute ] = value return value else @property_hash . delete ( attribute ) return <str> end end properties = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] properties . each do | field | define_method ( field . to_s ) do retrieve_value ( resource [ <str> ] , field ) end define_method ( field . to_s + <str> ) do | value | @property_hash [ field ] = value end end def auth_type if resource . should ( <str> ) != nil return resource . should ( <str> ) elsif self . exists? if self . class . rights . has_key? ( resource [ <str> ] ) return <str> elsif self . class . rules . has_key? ( resource [ <str> ] ) return <str> else raise Puppet :: Error . new ( <str> resource [ <str> ] <str> ) end else raise Puppet :: Error . new ( <str> ) end end def auth_type = ( value ) @property_hash [ <str> ] = value end end 
