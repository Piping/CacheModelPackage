require <str> require <str> require <str> require <str> class Puppet :: Resource include Puppet :: Util :: Tagging include Enumerable attr_accessor <str> , <str> , <str> , <str> , <str> , <str> attr_reader <str> , <str> attr_accessor <str> require <str> extend Puppet :: Indirector indirects <str> , <str> = > <str> ATTRIBUTES = [ <str> , <str> , <str> ] def self . from_data_hash ( data ) raise ArgumentError , <str> unless type = data [ <str> ] raise ArgumentError , <str> unless title = data [ <str> ] resource = new ( type , title ) if params = data [ <str> ] params . each { | param , value | resource [ param ] = value } end if tags = data [ <str> ] tags . each { | tag | resource . tag ( tag ) } end ATTRIBUTES . each do | a | if value = data [ a . to_s ] resource . send ( a . to_s + <str> , value ) end end resource end def inspect <str> @type <str> @title <str> to_hash . inspect <str> end def to_data_hash data = ( [ <str> , <str> , <str> ] + ATTRIBUTES ) . inject ( { } ) do | hash , param | next hash unless value = self . send ( param ) hash [ param . to_s ] = value hash end data [ <str> ] || = false params = self . to_hash . inject ( { } ) do | hash , ary | param , value = ary next hash if param == namevar and value == title hash [ param ] = Puppet :: Resource . value_to_pson_data ( value ) hash end data [ <str> ] = params unless params . empty? data end def self . value_to_pson_data ( value ) if value . is_a? Array value . map { | v | value_to_pson_data ( v ) } elsif value . is_a? Puppet :: Resource value . to_s else value end end def yaml_property_munge ( x ) case x when Hash x . inject ( { } ) { | h , kv | k , v = kv h [ k ] = self . class . value_to_pson_data ( v ) h } else self . class . value_to_pson_data ( x ) end end YAML_ATTRIBUTES = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] def to_yaml_properties YAML_ATTRIBUTES & super end <str> . each do | method | define_method ( method ) do | * args | parameters . send ( method , * args ) end end def []= ( param , value ) validate_parameter ( param ) if validate_parameters parameters [ parameter_name ( param ) ] = value end def [] ( param ) parameters [ parameter_name ( param ) ] end def == ( other ) return false unless other . respond_to? ( <str> ) and self . type == other . type and self . title == other . title return false unless to_hash == other . to_hash true end def builtin? builtin_type? end def builtin_type? resource_type . is_a? ( Class ) end def each parameters . each { | p , v | yield p , v } end def include? ( parameter ) super || parameters . keys . include? ( parameter_name ( parameter ) ) end <str> . each do | m | define_method ( m + <str> ) do self . send ( m ) end end def class? @is_class || = @type == <str> end def stage? @is_stage || = @type . to_s . downcase == <str> end def initialize ( type , title = nil , attributes = { } ) @parameters = { } if type . is_a? ( Puppet :: Resource ) src = type self . file = src . file self . line = src . line self . exported = src . exported self . virtual = src . virtual self . set_tags ( src ) self . environment = src . environment @rstype = src . resource_type @type = src . type @title = src . title src . to_hash . each do | p , v | if v . is_a? ( Puppet :: Resource ) v = Puppet :: Resource . new ( v . type , v . title ) elsif v . is_a? ( Array ) v = v . flatten if v . flatten . find { | av | av . is_a? ( Puppet :: Resource ) } v = v . collect do | av | av = Puppet :: Resource . new ( av . type , av . title ) if av . is_a? ( Puppet :: Resource ) av end end self [ p ] = v end else environment = attributes [ <str> ] if type . is_a? ( Class ) && type < Puppet :: Type self . resource_type = type type = type . name end attributes . each do | attr , value | next if attr == <str> send ( attr . to_s + <str> , value ) end @type , @title = extract_type_and_title ( type , title ) @type = munge_type_name ( @type ) if self . class? @title = <str> if @title == <str> @title = munge_type_name ( @title ) end if params = attributes [ <str> ] extract_parameters ( params ) end if resource_type && resource_type . respond_to? ( <str> ) resource_type . deprecate_params ( title , attributes [ <str> ] ) end tag ( self . type ) tag_if_valid ( self . title ) end if strict? and ! resource_type if self . class? raise ArgumentError , <str> title <str> else raise ArgumentError , <str> type <str> end end end def ref to_s end def resolve catalog ? catalog . resource ( to_s ) : nil end def is_application_component? return true if ! export . empty? || self [ <str> ] req = self [ <str> ] || [ ] req = [ req ] unless req . is_a? ( Array ) req . any? { | r | r . is_capability? } end def is_capability? resource_type and resource_type . is_capability? end def export v = self [ <str> ] || [ ] v . is_a? ( Array ) ? v : [ v ] end def resource_type @rstype || = case type when <str> ; environment . known_resource_types . hostclass ( title == <str> ? <str> : title ) when <str> ; environment . known_resource_types . node ( title ) when <str> ; environment . known_resource_types . site ( nil ) else result = Puppet :: Type . type ( type ) if ! result krt = environment . known_resource_types result = krt . definition ( type ) || krt . application ( type ) end result end end def resource_type = ( type ) @rstype = type end def environment @environment || = if catalog catalog . environment_instance else Puppet . lookup ( <str> ) { Puppet :: Node :: Environment :: NONE } end end def environment = ( environment ) @environment = environment end def to_hash parse_title . merge parameters end def to_s <str> type <str> title <str> end def uniqueness_key h = self . to_hash name = h [ namevar ] || h [ <str> ] || self . name h [ namevar ] || = name h [ <str> ] || = name h . values_at ( * key_attributes . sort_by { | k | k . to_s } ) end def key_attributes resource_type . respond_to? ( <str> ) ? resource_type . key_attributes : [ <str> ] end def to_hierayaml attr = parameters . keys attr_max = attr . inject ( <int> ) { | max , k | k . to_s . length > max ? k . to_s . length : max } attr . sort! if attr . first != <str> && attr . include? ( <str> ) attr . delete ( <str> ) attr . unshift ( <str> ) end attributes = attr . collect { | k | v = parameters [ k ] <str> attr_max <str> % [ k , Puppet :: Parameter . format_value_for_display ( v ) ] } . join <str> % [ self . title , attributes ] end def to_manifest attr = parameters . keys attr_max = attr . inject ( <int> ) { | max , k | k . to_s . length > max ? k . to_s . length : max } attr . sort! if attr . first != <str> && attr . include? ( <str> ) attr . delete ( <str> ) attr . unshift ( <str> ) end attributes = attr . collect { | k | v = parameters [ k ] <str> attr_max <str> % [ k , Puppet :: Parameter . format_value_for_display ( v ) ] } . join escaped = self . title . gsub ( <str> , <str> ) <str> % [ self . type . to_s . downcase , escaped , attributes ] end def to_ref ref end def to_ral typeklass = Puppet :: Type . type ( self . type ) || Puppet :: Type . type ( <str> ) typeklass . new ( self ) end def name [ type , title ] . join ( <str> ) end def missing_arguments resource_type . arguments . select do | param , default | the_param = parameters [ param . to_sym ] the_param . nil? || the_param . value . nil? || the_param . value == <str> end end private <str> def set_default_parameters ( scope ) Puppet . deprecation_warning ( <str> ) return [ ] unless resource_type and resource_type . respond_to? ( <str> ) unless is_a? ( Puppet :: Parser :: Resource ) fail Puppet :: DevError , <str> self <str> end missing_arguments . collect do | param , default | rtype = resource_type if rtype . type == <str> using_bound_value = false catch ( <str> ) do bound_value = Puppet :: Pops :: Lookup . search_and_merge ( <str> rtype . name <str> param <str> , Puppet :: Pops :: Lookup :: Invocation . new ( scope ) , nil ) unless bound_value . nil? && ! default . nil? self [ param . to_sym ] = bound_value using_bound_value = true end end end unless using_bound_value next if default . nil? self [ param . to_sym ] = default . safeevaluate ( scope ) end param end . compact end def copy_as_resource Puppet :: Resource . new ( self ) end def valid_parameter? ( name ) resource_type . valid_parameter? ( name ) end def validate_complete Puppet . deprecation_warning ( <str> ) return unless resource_type and resource_type . respond_to? ( <str> ) resource_type . arguments . each do | param , default | param = param . to_sym fail Puppet :: ParseError , <str> param <str> self <str> unless parameters . include? ( param ) end arg_types = resource_type . argument_types parameters . each do | name , value | next unless t = arg_types [ name . to_s ] unless Puppet :: Pops :: Types :: TypeCalculator . instance? ( t , value . value ) inferred_type = Puppet :: Pops :: Types :: TypeCalculator . infer_set ( value . value ) actual = inferred_type . generalize ( ) fail Puppet :: ParseError , <str> name <str> self <str> t . to_s <str> actual . to_s <str> end end end def validate_parameter ( name ) raise Puppet :: ParseError . new ( <str> name <str> , file , line ) unless valid_parameter? ( name ) end def prune_parameters ( options = { } ) properties = resource_type . properties . map ( & <str> ) dup . collect do | attribute , value | if value . to_s . empty? or Array ( value ) . empty? delete ( attribute ) elsif value . to_s == <str> and attribute . to_s != <str> delete ( attribute ) end parameters_to_include = options [ <str> ] || [ ] delete ( attribute ) unless properties . include? ( attribute ) || parameters_to_include . include? ( attribute ) end self end private def parameter_name ( param ) param = param . to_s . downcase . to_sym if param == <str> and namevar param = namevar end param end def namevar if builtin_type? and t = resource_type and t . key_attributes . length == <int> t . key_attributes . first else <str> end end def extract_parameters ( params ) params . each do | param , value | validate_parameter ( param ) if strict? self [ param ] = value end end def extract_type_and_title ( argtype , argtitle ) if ( argtype . nil? || argtype == <str> || argtype == <str> ) && argtitle =~ <str> then [ $1 , $2 ] elsif argtitle . nil? && argtype =~ <str> then [ $1 , $2 ] elsif argtitle then [ argtype , argtitle ] elsif argtype . is_a? ( Puppet :: Type ) then [ argtype . class . name , argtype . title ] elsif argtype . is_a? ( Hash ) then raise ArgumentError , <str> + <str> ( argtype [ <str> ] || argtype [ <str> ] ) . inspect <str> ( argtype [ <str> ] || argtype [ <str> ] ) . inspect <str> else raise ArgumentError , <str> argtype . inspect <str> end end def munge_type_name ( value ) return <str> if value == <str> return <str> if value == <str> or value . nil? or value . to_s . downcase == <str> value . to_s . split ( <str> ) . collect { | s | s . capitalize } . join ( <str> ) end def parse_title h = { } type = resource_type if type . respond_to? <str> type . title_patterns . each { | regexp , symbols_and_lambdas | if captures = regexp . match ( title . to_s ) symbols_and_lambdas . zip ( captures [ <int> .. - <int> ] ) . each do | symbol_and_lambda , capture | symbol , proc = symbol_and_lambda if proc then h [ symbol ] = proc . call ( capture ) else h [ symbol ] = capture end end return h end } raise Puppet :: Error , <str> title <str> else return { <str> = > title . to_s } end end def parameters @parameters || = { } end end 
