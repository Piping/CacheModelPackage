module Rubinius module FFI module PointerAccessors ; end class Pointer include PointerAccessors def initialize ( a1 , a2 = undefined ) if undefined . equal? a2 self . address = a1 else @type = a1 self . address = a2 end end def inspect addr = address ( ) if addr < <int> sign = <str> addr = - addr else sign = <str> end <str> self . class . name <str> sign <str> addr . to_s ( <int> ) <str> end def address Rubinius . primitive <str> raise PrimitiveFailure , <str> end alias_method <str> , <str> def address = ( address ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def null? address == <hex> end def + ( value ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def == ( other ) return false unless other . kind_of? Pointer return address == other . address end def network_order ( start , size ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def read_string_length ( len ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def read_string_to_null Rubinius . primitive <str> raise PrimitiveFailure , <str> end def read_string ( len = nil ) if len read_string_length ( len ) else read_string_to_null end end def get_bytes ( offset , length ) ( self + offset ) . read_string_length ( length ) end def write_string_length ( str , len ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def write_string ( str , len = nil ) len = str . bytesize unless len write_string_length ( str , len ) ; end def read_array_of_type ( type , reader , length , signed = nil ) args = [ ] args = [ signed ] if ! signed . nil? ary = [ ] size = FFI . type_size ( FFI . find_type type ) tmp = self length . times { ary << tmp . send ( reader , * args ) tmp += size } ary end def write_array_of_type ( type , writer , ary ) size = FFI . type_size ( FFI . find_type type ) tmp = self ary . each do | i | tmp . send ( writer , i ) tmp += size end self end def get_at_offset ( offset , type ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def set_at_offset ( offset , type , val ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def self . size Rubinius :: WORDSIZE / <int> end def primitive_read_char ( signed ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_char ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_short ( signed ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_short ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_int ( signed ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_int ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_long ( signed ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_long ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_long_long ( signed ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_long_long ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_float Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_float ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_double Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_double ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_read_pointer Rubinius . primitive <str> raise PrimitiveFailure , <str> end def primitive_write_pointer ( obj ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def autorelease = ( val ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def autorelease? Rubinius . primitive <str> raise PrimitiveFailure , <str> end NULL = Pointer . new ( <hex> ) end class MemoryPointer < Pointer def self . new ( type , count = nil , clear = true ) if type . kind_of? Fixnum size = type elsif type . kind_of? Symbol type = FFI . find_type type size = FFI . type_size ( type ) else size = type . size end if count total = size * count else total = size end ptr = malloc total ptr . total = total ptr . type_size = size FFI :: Platform :: POSIX . memset ptr , <int> , total if clear if block_given? begin value = yield ptr ensure ptr . free end return value else ptr . autorelease = true ptr end end def self . malloc ( total ) Rubinius . primitive <str> raise PrimitiveFailure , <str> end def self . from_string ( str ) ptr = new str . bytesize + <int> ptr . write_string str + <str> ptr end def copy other = malloc total other . total = total other . type_size = type_size FFI :: Platform :: POSIX . memcpy other , self , total Rubinius . privately do other . initialize_copy self end other end attr_accessor <str> attr_accessor <str> def [] ( which ) raise ArgumentError , <str> unless @type_size self + ( which * @type_size ) end def free Rubinius . primitive <str> raise PrimitiveFailure , <str> end end class DynamicLibrary class Symbol < Pointer def initialize ( library , ptr , name ) @library = library @name = name self . address = ptr . address end def inspect <str> @name <str> address . to_s ( <int> ) <str> end end end class Function < Pointer def initialize ( ret_type , arg_types , val = nil , options = nil , & block ) if block if val or options raise ArgumentError , <str> end val = block end args = arg_types . map { | x | FFI . find_type ( x ) } ret = FFI . find_type ( ret_type ) if val . kind_of? Pointer @function = FFI . generate_function ( val , <str> , args , ret ) self . address = val . address elsif val . respond_to? <str> @function , ptr = FFI . generate_trampoline ( val , <str> , args , ret ) self . address = ptr . address else raise ArgumentError , <str> end sc = Rubinius :: Type . object_singleton_class ( self ) sc . method_table . store <str> , nil , @function , nil , <int> , <str> end attr_reader <str> def attach ( mod , name ) unless mod . kind_of? ( Module ) raise TypeError , <str> end name = name . to_sym sc = Rubinius :: Type . object_singleton_class ( mod ) sc . method_table . store name , nil , @function , nil , <int> , <str> mod . method_table . store name , nil , @function , nil , <int> , <str> end end end end 
