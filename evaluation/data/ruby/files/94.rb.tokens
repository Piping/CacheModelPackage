module Rubinius class Splitter def self . split_characters ( string , pattern , limit , tail_empty ) if limit string . chars . take ( limit - <int> ) << string [ ( limit - <int> ) .. - <int> ] else ret = string . chars . to_a ret << string . byteslice ( <int> , <int> ) if tail_empty ret end end def self . valid_encoding? ( string ) raise ArgumentError , <str> string . encoding . name <str> unless string . valid_encoding? end def self . split ( string , pattern , limit ) return [ ] if string . empty? tail_empty = false if undefined . equal? ( limit ) limited = false else limit = Rubinius :: Type . coerce_to limit , Fixnum , <str> if limit > <int> return [ string . dup ] if limit == <int> limited = true else if limit < <int> tail_empty = true end limited = false end end pattern || = ( $; || <str> ) if pattern == <str> if limited lim = limit elsif tail_empty lim = - <int> else lim = <int> end return Rubinius . invoke_primitive <str> , string , lim elsif pattern . kind_of? ( Regexp ) else pattern = StringValue ( pattern ) unless pattern . kind_of? ( String ) valid_encoding? ( string ) valid_encoding? ( pattern ) trim_end = ! tail_empty || limit == <int> unless limited if pattern . empty? if trim_end return string . chars . to_a end else return split_on_string ( string , pattern , trim_end ) end end pattern = Regexp . new ( Regexp . quote ( pattern ) ) end if pattern . source . empty? return split_characters ( string , pattern , limited && limit , tail_empty ) end start = <int> ret = [ ] last_match = nil last_match_end = <int> while match = pattern . match_from ( string , start ) break if limited && limit - ret . size < = <int> collapsed = match . collapsing? unless collapsed && ( match . full . at ( <int> ) == last_match_end ) ret << match . pre_match_from ( last_match_end ) if match . length > <int> ret . concat ( match . captures . compact ) end end start = match . full . at ( <int> ) if collapsed start += <int> end last_match = match last_match_end = last_match . full . at ( <int> ) end if last_match ret << last_match . post_match elsif ret . empty? ret << string . dup end if undefined . equal? ( limit ) || limit == <int> while s = ret . at ( - <int> ) and s . empty? ret . pop end end ret end def self . split_on_string ( string , pattern , trim_end ) pos = <int> ret = [ ] pat_size = pattern . bytesize str_size = string . bytesize while pos < str_size nxt = string . find_string ( pattern , pos ) break unless nxt match_size = nxt - pos ret << string . byteslice ( pos , match_size ) pos = nxt + pat_size end ret << string . byteslice ( pos , str_size - pos ) if trim_end while s = ret . at ( - <int> ) and s . empty? ret . pop end end ret end end end 
