require <str> module IRB module HistorySavingAbility end class Context def init_save_history unless ( class << @io ; self ; end ) . include? ( HistorySavingAbility ) @io . extend ( HistorySavingAbility ) end end def save_history IRB . conf [ <str> ] end def save_history = ( val ) IRB . conf [ <str> ] = val if val main_context = IRB . conf [ <str> ] main_context = self unless main_context main_context . init_save_history end end def history_file IRB . conf [ <str> ] end def history_file = ( hist ) IRB . conf [ <str> ] = hist end end module HistorySavingAbility include Readline def HistorySavingAbility . extended ( obj ) IRB . conf [ <str> ] . push proc { obj . save_history } obj . load_history obj end def load_history if history_file = IRB . conf [ <str> ] history_file = File . expand_path ( history_file ) end history_file = IRB . rc_file ( <str> ) unless history_file if File . exist? ( history_file ) open ( history_file ) do | f | f . each { | l | HISTORY << l . chomp } end end end def save_history if num = IRB . conf [ <str> ] and ( num = num . to_i ) > <int> if history_file = IRB . conf [ <str> ] history_file = File . expand_path ( history_file ) end history_file = IRB . rc_file ( <str> ) unless history_file begin if File . stat ( history_file ) . mode & <oct> != <int> File . chmod ( <oct> , history_file ) end rescue Errno :: ENOENT rescue raise end open ( history_file , <str> , <oct> ) do | f | hist = HISTORY . to_a f . puts ( hist [ - num .. - <int> ] || hist ) end end end end end 
