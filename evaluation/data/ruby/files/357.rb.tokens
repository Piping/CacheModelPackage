rhs = expand_except_paren ( assign [ <int> ] ) lopen = Sentence === lhs && lhs [ - <int> ] != <str> && lhs . any? { | e | e == <str> || e == <str> } ropen = Sentence === rhs && rhs [ - <int> ] != <str> && rhs . any? { | e | e == <str> || e == <str> } lhs = Sentence . new ( [ <str> ] + lhs . to_a + [ <str> ] ) if lopen begin rv = eval ( ( ropen ? [ <str> , assign [ <int> ] , <str> ] : assign [ <int> ] ) . join ( <str> ) ) rescue Exception rv = $! . message end emu_assign_single ( lhs , rv ) end def do_assign ( assign , vars ) assign = assign . to_s code1 = <str> assign <str> vars . join ( <str> ) <str> assign . gsub! ( <str> , <str> ) code2 = <str> assign <str> begin vals1 = eval ( code1 ) rescue Exception return { <str> = > $! . message } end begin vals2 = eval ( code2 ) rescue Exception return { <str> = > $! . message } end assert_equal ( vals1 , vals2 , code1 ) vals = vals1 h = { } [ vars , vals ] . transpose . each { | k , v | h [ k ] = v } h end def check ( assign ) assign , vars = rename_var ( assign ) sent = assign . to_s bruby = do_assign ( assign , vars ) . to_a . sort bemu = emu_assign ( assign ) . to_a . sort assert_equal ( bemu , bruby , sent ) end def test_assignment syntax = Sentence . expand_syntax ( Syntax ) Sentence . each ( syntax , <str> , <int> ) { | assign | check ( assign ) } end def test_optimized_aset bug9448 = Class . new do def []= ( key , new_value ) <str> end end o = bug9448 . new assert_equal ( <str> , o [ <str> ] = <str> ) end def test_massign_aref_lhs_splat bug11970 = <str> h = { } k = [ <str> ] h [ * k ] , = [ <str> , <str> ] assert_equal ( <str> , h [ <str> ] , bug11970 ) end end 
