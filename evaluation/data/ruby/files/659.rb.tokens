require <str> module ActionDispatch module Journey module GTG class TransitionTable include Journey :: NFA :: Dot attr_reader <str> def initialize @regexp_states = { } @string_states = { } @accepting = { } @memos = Hash . new { | h , k | h [ k ] = [ ] } end def add_accepting ( state ) @accepting [ state ] = true end def accepting_states @accepting . keys end def accepting? ( state ) @accepting [ state ] end def add_memo ( idx , memo ) @memos [ idx ] << memo end def memo ( idx ) @memos [ idx ] end def eclosure ( t ) Array ( t ) end def move ( t , a ) return [ ] if t . empty? regexps = [ ] t . map { | s | if states = @regexp_states [ s ] regexps . concat states . map { | re , v | re === a ? v : nil } end if states = @string_states [ s ] states [ a ] end } . compact . concat regexps end def as_json ( options = nil ) simple_regexp = Hash . new { | h , k | h [ k ] = { } } @regexp_states . each do | from , hash | hash . each do | re , to | simple_regexp [ from ] [ re . source ] = to end end { <str> : simple_regexp , <str> : @string_states , <str> : @accepting } end def to_svg svg = IO . popen ( <str> , <str> ) { | f | f . write ( to_dot ) f . close_write f . readlines } <int> . times { svg . shift } svg . join . sub ( <str> , <str> ) . sub ( <str> , <str> ) end def visualizer ( paths , title = <str> ) viz_dir = File . join File . dirname ( __FILE__ ) , <str> , <str> fsm_js = File . read File . join ( viz_dir , <str> ) fsm_css = File . read File . join ( viz_dir , <str> ) erb = File . read File . join ( viz_dir , <str> ) states = <str> to_json <str> fun_routes = paths . sample ( <int> ) . map do | ast | ast . map { | n | case n when Nodes :: Symbol case n . left when <str> then rand ( <int> ) . to_s when <str> then <str> . sample else <str> end when Nodes :: Terminal then n . symbol else nil end } . compact . join end stylesheets = [ fsm_css ] svg = to_svg javascripts = [ states , fsm_js ] fun_routes = fun_routes stylesheets = stylesheets svg = svg javascripts = javascripts require <str> template = ERB . new erb template . result ( binding ) end def []= ( from , to , sym ) to_mappings = states_hash_for ( sym ) [ from ] || = { } to_mappings [ sym ] = to end def states ss = @string_states . keys + @string_states . values . flat_map ( & <str> ) rs = @regexp_states . keys + @regexp_states . values . flat_map ( & <str> ) ( ss + rs ) . uniq end def transitions @string_states . flat_map { | from , hash | hash . map { | s , to | [ from , s , to ] } } + @regexp_states . flat_map { | from , hash | hash . map { | s , to | [ from , s , to ] } } end private def states_hash_for ( sym ) case sym when String @string_states when Regexp @regexp_states else raise ArgumentError , <str> % sym . class end end end end end end 
