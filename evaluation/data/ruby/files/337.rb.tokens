module Rex module IO require <str> require <str> require <str> class BidirectionalPipe < Rex :: Ui :: Text :: Input def initialize @subscribers_out = { } @subscribers_ref = { } @subscribers_idx = <int> @pipe_input = Rex :: Ui :: Text :: Input :: Buffer . new self . output = self self . input = self end def pipe_input @pipe_input end def close @pipe_input . close end def has_subscriber? ( id ) @subscribers_out . has_key? ( id ) end def create_subscriber ( id = nil ) id || = ( @subscribers_idx += <int> ) . to_s @subscribers_out [ id ] = Rex :: Ui :: Text :: Output :: Buffer . new return id end def create_subscriber_proc ( id = nil , & block ) id = create_subscriber ( id ) @subscribers_ref [ id ] = block end def remove_subscriber ( id ) @subscribers_out . delete ( id ) @subscribers_ref . delete ( id ) end def write_input ( buf ) @pipe_input . put ( buf ) end def read_subscriber ( id ) output = @subscribers_out [ id ] return <str> if output . nil? buf = output . buf output . reset buf end def print ( msg = <str> ) @subscribers_out . each_pair { | id , buf | begin @subscribers_ref [ id ] ? @subscribers_ref [ id ] . call ( msg ) : buf . print ( msg ) rescue :: Exception = > e raise e end } msg end def print_error ( msg = <str> ) print_line ( <str> + msg ) end def print_line ( msg = <str> ) print ( msg + <str> ) end def print_good ( msg = <str> ) print_line ( <str> + msg ) end def flush end def print_status ( msg = <str> ) print_line ( <str> + msg ) end def print_warning ( msg = <str> ) print_line ( <str> + msg ) end def close @pipe_input . close end def sysread ( len = <int> ) @pipe_input . sysread ( len ) end def put ( msg ) @pipe_input . put ( msg ) end def gets @pipe_input . gets end def eof? @pipe_input . eof? end def fd @pipe_input . fd end attr_accessor <str> , <str> , <str> def intrinsic_shell? true end def supports_readline false end def supports_color? false end def pgets gets end protected end end end 
