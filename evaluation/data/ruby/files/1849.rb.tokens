require <str> require <str> require <str> require_relative <str> class TestWEBrickServer < Test :: Unit :: TestCase class Echo < WEBrick :: GenericServer def run ( sock ) while line = sock . gets sock << line end end end def test_server TestWEBrick . start_server ( Echo ) { | server , addr , port , log | TCPSocket . open ( addr , port ) { | sock | sock . puts ( <str> ) ; assert_equal ( <str> , sock . gets , log . call ) sock . puts ( <str> ) ; assert_equal ( <str> , sock . gets , log . call ) sock . puts ( <str> ) ; assert_equal ( <str> , sock . gets , log . call ) sock . puts ( <str> ) ; assert_equal ( <str> , sock . gets , log . call ) } } end def test_start_exception stopped = <int> log = [ ] logger = WEBrick :: Log . new ( log , WEBrick :: BasicLog :: WARN ) assert_raise ( SignalException ) do listener = Object . new def listener . to_io raise SignalException , <str> end def listener . shutdown end def listener . close end server = WEBrick :: HTTPServer . new ( { <str> = > <str> , <str> = > <int> , <str> = > Proc . new { stopped += <int> } , <str> = > logger , } ) server . listeners [ <int> ] . close server . listeners [ <int> ] = listener server . start end assert_equal ( <int> , stopped ) assert_equal ( <int> , log . length ) assert_match ( <str> , log [ <int> ] ) end def test_callbacks accepted = started = stopped = <int> config = { <str> = > Proc . new { accepted += <int> } , <str> = > Proc . new { started += <int> } , <str> = > Proc . new { stopped += <int> } , } TestWEBrick . start_server ( Echo , config ) { | server , addr , port , log | true while server . status != <str> assert_equal ( <int> , started , log . call ) assert_equal ( <int> , stopped , log . call ) assert_equal ( <int> , accepted , log . call ) TCPSocket . open ( addr , port ) { | sock | ( sock << <str> ) . gets } TCPSocket . open ( addr , port ) { | sock | ( sock << <str> ) . gets } TCPSocket . open ( addr , port ) { | sock | ( sock << <str> ) . gets } assert_equal ( <int> , accepted , log . call ) } assert_equal ( <int> , started ) assert_equal ( <int> , stopped ) end def test_daemon begin r , w = IO . pipe pid1 = Process . fork { r . close WEBrick :: Daemon . start w . puts ( Process . pid ) sleep <int> } pid2 = r . gets . to_i assert ( Process . kill ( <str> , pid2 ) ) assert_not_equal ( pid1 , pid2 ) rescue NotImplementedError ensure Process . wait ( pid1 ) if pid1 r . close w . close end end def test_restart_after_shutdown address = <str> port = <int> log = [ ] config = { <str> = > address , <str> = > port , <str> = > WEBrick :: Log . new ( log , WEBrick :: BasicLog :: WARN ) , } server = Echo . new ( config ) client_proc = lambda { | str | begin ret = server . listeners . first . connect_address . connect { | s | s . write ( str ) s . close_write s . read } assert_equal ( str , ret ) ensure server . shutdown end } server_thread = Thread . new { server . start } client_thread = Thread . new { client_proc . call ( <str> ) } assert_join_threads ( [ client_thread , server_thread ] ) server . listen ( address , port ) server_thread = Thread . new { server . start } client_thread = Thread . new { client_proc . call ( <str> ) } assert_join_threads ( [ client_thread , server_thread ] ) assert_equal ( [ ] , log ) end def test_restart_after_stop log = Object . new class << log include Test :: Unit :: Assertions def << ( msg ) flunk <str> msg . inspect <str> end end client_thread = nil wakeup = - > { client_thread . wakeup } warn_flunk = WEBrick :: Log . new ( log , WEBrick :: BasicLog :: WARN ) server = WEBrick :: HTTPServer . new ( <str> = > wakeup , <str> = > wakeup , <str> = > <str> , <str> = > <int> , <str> = > warn_flunk ) <int> . times { server_thread = Thread . start { server . start } client_thread = Thread . start { sleep <int> . <int> until server . status == <str> || ! server_thread . status server . stop sleep <int> . <int> until server . status == <str> || ! server_thread . status } assert_join_threads ( [ client_thread , server_thread ] ) } end end 
