require File . expand_path ( <str> , __FILE__ ) require File . expand_path ( <str> , __FILE__ ) describe <str> do it <str> do a = [ <int> , <int> , <int> , <int> ] different = false <int> . times do s = a . shuffle s . sort . should == a different || = ( a != s ) end different . should be_true end it <str> do a = [ <int> , <int> , <int> ] <int> . times do a . shuffle a . should == [ <int> , <int> , <int> ] end end it <str> do ArraySpecs :: MyArray [ <int> , <int> , <int> ] . shuffle . should be_an_instance_of ( Array ) end it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . once . and_return ( { } ) [ <int> , <int> ] . shuffle ( obj ) end it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( <int> . <int> ) result = [ <int> , <int> ] . shuffle ( <str> = > obj ) result . size . should == <int> result . should include ( <int> , <int> ) end it <str> do obj = mock ( <str> ) result = [ <int> , <int> ] . shuffle ( <str> = > obj ) result . size . should == <int> result . should include ( <int> , <int> ) end it <str> do random = mock ( <str> ) random . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( <int> . <int> ) [ <int> , <int> ] . shuffle ( <str> = > random ) . should be_an_instance_of ( Array ) end it <str> do value = mock ( <str> ) value . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( <int> ) random = mock ( <str> ) random . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( value ) [ <int> , <int> ] . shuffle ( <str> = > random ) . should be_an_instance_of ( Array ) end it <str> do value = mock ( <str> ) value . should_receive ( <str> ) . and_return ( - <int> ) random = mock ( <str> ) random . should_receive ( <str> ) . and_return ( value ) lambda { [ <int> , <int> ] . shuffle ( <str> = > random ) } . should raise_error ( RangeError ) end it <str> do value = mock ( <str> ) value . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( <int> ) random = mock ( <str> ) random . should_receive ( <str> ) . at_least ( <int> ) . times . and_return ( value ) lambda { [ <int> , <int> ] . shuffle ( <str> = > random ) } . should raise_error ( RangeError ) end end describe <str> do it <str> do a = [ <int> , <int> , <int> , <int> ] original = a different = false <int> . times do a = a . shuffle! a . sort . should == [ <int> , <int> , <int> , <int> ] different || = ( a != [ <int> , <int> , <int> , <int> ] ) end different . should be_true a . should equal ( original ) end it <str> do lambda { ArraySpecs . frozen_array . shuffle! } . should raise_error ( RuntimeError ) lambda { ArraySpecs . empty_frozen_array . shuffle! } . should raise_error ( RuntimeError ) end end 
