require <str> module ActionDispatch module Journey class Formatter attr_reader <str> def initialize ( routes ) @routes = routes @cache = nil end def generate ( name , options , path_parameters , parameterize = nil ) constraints = path_parameters . merge ( options ) missing_keys = nil match_route ( name , constraints ) do | route | parameterized_parts = extract_parameterized_parts ( route , options , path_parameters , parameterize ) next unless name || route . dispatcher? missing_keys = missing_keys ( route , parameterized_parts ) next if missing_keys && ! missing_keys . empty? params = options . dup . delete_if do | key , _ | parameterized_parts . key? ( key ) || route . defaults . key? ( key ) end defaults = route . defaults required_parts = route . required_parts parameterized_parts . keep_if do | key , value | ( defaults [ key ] . nil? && value . present? ) || value . to_s != defaults [ key ] . to_s || required_parts . include? ( key ) end return [ route . format ( parameterized_parts ) , params ] end message = <str> Hash [ constraints . sort_by <str> | k , v | k . to_s <str> ] . inspect <str> message << <str> missing_keys . sort . inspect <str> if missing_keys && ! missing_keys . empty? raise ActionController :: UrlGenerationError , message end def clear @cache = nil end private def extract_parameterized_parts ( route , options , recall , parameterize = nil ) parameterized_parts = recall . merge ( options ) keys_to_keep = route . parts . reverse_each . drop_while { | part | ! options . key? ( part ) || ( options [ part ] || recall [ part ] ) . nil? } | route . required_parts parameterized_parts . delete_if do | bad_key , _ | ! keys_to_keep . include? ( bad_key ) end if parameterize parameterized_parts . each do | k , v | parameterized_parts [ k ] = parameterize . call ( k , v ) end end parameterized_parts . keep_if { | _ , v | v } parameterized_parts end def named_routes routes . named_routes end def match_route ( name , options ) if named_routes . key? ( name ) yield named_routes [ name ] else routes = non_recursive ( cache , options ) hash = routes . group_by { | _ , r | r . score ( options ) } hash . keys . sort . reverse_each do | score | break if score < <int> hash [ score ] . sort_by { | i , _ | i } . each do | _ , route | yield route end end end end def non_recursive ( cache , options ) routes = [ ] queue = [ cache ] while queue . any? c = queue . shift routes . concat ( c [ <str> ] ) if c . key? ( <str> ) options . each do | pair | queue << c [ pair ] if c . key? ( pair ) end end routes end module RegexCaseComparator DEFAULT_INPUT = <str> DEFAULT_REGEX = <str> DEFAULT_INPUT <str> def self . === ( regex ) DEFAULT_INPUT == regex end end def missing_keys ( route , parts ) missing_keys = nil tests = route . path . requirements route . required_parts . each { | key | case tests [ key ] when nil unless parts [ key ] missing_keys || = [ ] missing_keys << key end when RegexCaseComparator unless RegexCaseComparator :: DEFAULT_REGEX === parts [ key ] missing_keys || = [ ] missing_keys << key end else unless <str> tests [ key ] <str> === parts [ key ] missing_keys || = [ ] missing_keys << key end end } missing_keys end def possibles ( cache , options , depth = <int> ) cache . fetch ( <str> ) { [ ] } + options . find_all { | pair | cache . key? ( pair ) } . flat_map { | pair | possibles ( cache [ pair ] , options , depth + <int> ) } end def build_cache root = { <str> : [ ] } routes . routes . each_with_index do | route , i | leaf = route . required_defaults . inject ( root ) do | h , tuple | h [ tuple ] || = { } end ( leaf [ <str> ] || = [ ] ) << [ i , route ] end root end def cache @cache || = build_cache end end end end 
