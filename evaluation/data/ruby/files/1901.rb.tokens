class Puppet :: Pops :: Model :: ModelTreeDumper < Puppet :: Pops :: Model :: TreeDumper def dump_Array o o . collect { | e | do_dump ( e ) } end def dump_LiteralFloat o o . value . to_s end def dump_LiteralInteger o case o . radix when <int> o . value . to_s when <int> <str> % o . value when <int> <str> % o . value else <str> + o . value . to_s end end def dump_LiteralValue o o . value . to_s end def dump_Factory o do_dump ( o . current ) end def dump_Application o [ <str> , o . name , do_dump ( o . parameters ) , do_dump ( o . body ) ] end def dump_ArithmeticExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_AccessExpression o if o . keys . size < = <int> [ <str> , do_dump ( o . left_expr ) , do_dump ( o . keys [ <int> ] ) ] else [ <str> , do_dump ( o . left_expr ) , do_dump ( o . keys ) ] end end def dump_MatchesExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_CollectExpression o result = [ <str> , do_dump ( o . type_expr ) , <str> , <str> , do_dump ( o . query ) , <str> ] o . operations do | ao | result << <str> << do_dump ( ao ) end result += [ <str> , <str> ] result end def dump_EppExpression o result = [ <str> ] if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_ExportedQuery o result = [ <str> ] result += dump_QueryExpression ( o ) unless is_nop? ( o . expr ) result end def dump_VirtualQuery o result = [ <str> ] result += dump_QueryExpression ( o ) unless is_nop? ( o . expr ) result end def dump_QueryExpression o [ do_dump ( o . expr ) ] end def dump_ComparisonExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_AndExpression o [ <str> , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_OrExpression o [ <str> , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_InExpression o [ <str> , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_AssignmentExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_AttributeOperation o [ o . attribute_name , o . operator , do_dump ( o . value_expr ) ] end def dump_AttributesOperation o [ <str> , do_dump ( o . expr ) ] end def dump_LiteralList o [ <str> ] + o . values . collect { | x | do_dump ( x ) } end def dump_LiteralHash o [ <str> ] + o . entries . collect { | x | do_dump ( x ) } end def dump_KeyedEntry o [ do_dump ( o . key ) , do_dump ( o . value ) ] end def dump_MatchExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_LiteralString o <str> o . value <str> end def dump_LambdaExpression o result = [ <str> ] result << [ <str> ] + o . parameters . collect { | p | do_dump ( p ) } if o . parameters . size ( ) > <int> if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_LiteralDefault o <str> end def dump_LiteralUndef o <str> end def dump_LiteralRegularExpression o <str> o . value . source <str> end def dump_Nop o <str> end def dump_NamedAccessExpression o [ <str> , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_NilClass o <str> end def dump_NotExpression o [ <str> , dump ( o . expr ) ] end def dump_VariableExpression o <str> dump ( o . expr ) <str> end def dump_TextExpression o [ <str> , do_dump ( o . expr ) ] end def dump_UnaryMinusExpression o [ <str> , do_dump ( o . expr ) ] end def dump_UnfoldExpression o [ <str> , do_dump ( o . expr ) ] end def dump_BlockExpression o result = [ <str> , <str> ] o . statements . each { | x | result << <str> ; result << do_dump ( x ) } result << <str> << <str> result end def dump_ConcatenatedString o [ <str> ] + o . segments . collect { | x | do_dump ( x ) } end def dump_HeredocExpression ( o ) result = [ <str> o . syntax <str> , <str> , <str> , do_dump ( o . text_expr ) , <str> , <str> ] end def dump_HostClassDefinition o result = [ <str> , o . name ] result << [ <str> , o . parent_class ] if o . parent_class result << [ <str> ] + o . parameters . collect { | p | do_dump ( p ) } if o . parameters . size ( ) > <int> if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_NodeDefinition o result = [ <str> ] result << [ <str> ] + o . host_matches . collect { | m | do_dump ( m ) } result << [ <str> , do_dump ( o . parent ) ] if o . parent if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_SiteDefinition o result = [ <str> ] if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_NamedDefinition o result = [ nil , o . name ] result << [ <str> ] + o . parameters . collect { | p | do_dump ( p ) } if o . parameters . size ( ) > <int> if o . body result << do_dump ( o . body ) else result << [ ] end result end def dump_ResourceTypeDefinition o result = dump_NamedDefinition ( o ) result [ <int> ] = <str> result end def dump_CapabilityMapping o [ o . kind , do_dump ( o . component ) , o . capability , do_dump ( o . mappings ) ] end def dump_ResourceOverrideExpression o form = o . form == <str> ? <str> : o . form . to_s + <str> result = [ form + <str> , do_dump ( o . resources ) , <str> ] o . operations . each do | p | result << <str> << do_dump ( p ) end result << <str> result end def dump_ReservedWord o [ <str> , o . word ] end def dump_Parameter o name_prefix = o . captures_rest ? <str> : <str> name_part = <str> name_prefix <str> o . name <str> if o . value && o . type_expr [ <str> , do_dump ( o . type_expr ) , name_part , do_dump ( o . value ) ] elsif o . value [ <str> , name_part , do_dump ( o . value ) ] elsif o . type_expr [ <str> , do_dump ( o . type_expr ) , name_part ] else name_part end end def dump_ParenthesizedExpression o do_dump ( o . expr ) end def dump_Program ( o ) dump ( o . body ) end def dump_IfExpression o result = [ <str> , do_dump ( o . test ) , <str> , <str> , [ <str> , <str> , do_dump ( o . then_expr ) , <str> ] ] result += [ <str> , [ <str> , <str> , do_dump ( o . else_expr ) , <str> ] , <str> ] unless is_nop? o . else_expr result end def dump_UnlessExpression o result = [ <str> , do_dump ( o . test ) , <str> , <str> , [ <str> , <str> , do_dump ( o . then_expr ) , <str> ] ] result += [ <str> , [ <str> , <str> , do_dump ( o . else_expr ) , <str> ] , <str> ] unless is_nop? o . else_expr result end def dump_CallNamedFunctionExpression o result = [ o . rval_required ? <str> : <str> , do_dump ( o . functor_expr ) ] o . arguments . collect { | a | result << do_dump ( a ) } result end def dump_CallMethodExpression o result = [ o . rval_required ? <str> : <str> , do_dump ( o . functor_expr ) ] o . arguments . collect { | a | result << do_dump ( a ) } result << do_dump ( o . lambda ) if o . lambda result end def dump_CaseExpression o result = [ <str> , do_dump ( o . test ) , <str> ] o . options . each do | s | result << <str> << do_dump ( s ) end result << <str> end def dump_CaseOption o result = [ <str> ] result << o . values . collect { | x | do_dump ( x ) } result << [ <str> , do_dump ( o . then_expr ) ] result end def dump_RelationshipExpression o [ o . operator . to_s , do_dump ( o . left_expr ) , do_dump ( o . right_expr ) ] end def dump_RenderStringExpression o [ <str> , <str> o . value <str> ] end def dump_RenderExpression o [ <str> , do_dump ( o . expr ) ] end def dump_ResourceBody o result = [ do_dump ( o . title ) , <str> ] o . operations . each do | p | result << <str> << do_dump ( p ) end result << <str> result end def dump_ResourceDefaultsExpression o form = o . form == <str> ? <str> : o . form . to_s + <str> result = [ form + <str> , do_dump ( o . type_ref ) , <str> ] o . operations . each do | p | result << <str> << do_dump ( p ) end result << <str> result end def dump_ResourceExpression o form = o . form == <str> ? <str> : o . form . to_s + <str> result = [ form + <str> , do_dump ( o . type_name ) , <str> ] o . bodies . each do | b | result << <str> << do_dump ( b ) end result << <str> result end def dump_SelectorExpression o [ <str> , do_dump ( o . left_expr ) ] + o . selectors . collect { | x | do_dump ( x ) } end def dump_SelectorEntry o [ do_dump ( o . matching_expr ) , <str> , do_dump ( o . value_expr ) ] end def dump_SubLocatedExpression o [ <str> , do_dump ( o . expr ) ] end def dump_TypeAlias ( o ) [ <str> , o . name , do_dump ( o . type_expr ) ] end def dump_TypeDefinition ( o ) [ <str> , o . name , o . parent , do_dump ( o . body ) ] end def dump_Object o [ o . class . to_s , o . to_s ] end def is_nop? o o . nil? || o . is_a? ( Puppet :: Pops :: Model :: Nop ) end end 
