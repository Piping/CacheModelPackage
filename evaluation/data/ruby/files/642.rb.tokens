require <str> class TestProc < Test :: Unit :: TestCase def setup @verbose = $VERBOSE $VERBOSE = nil end def teardown $VERBOSE = @verbose end def test_proc p1 = proc { | i | i } assert_equal ( <int> , p1 . call ( <int> ) ) assert_equal ( <int> , p1 . call ( <int> ) ) p1 = proc { | i | i * <int> } assert_equal ( <int> , p1 . call ( <int> ) ) assert_equal ( <int> , p1 . call ( <int> ) ) p2 = nil x = <int> proc { iii = <int> p1 = proc { | i | iii = i } p2 = proc { x = iii } assert ( defined? ( iii ) ) } . call assert ( ! defined? ( iii ) ) loop { iii = iii = <int> ; assert ( eval ( <str> ) ) ; break } loop { iii = iii = <int> def self . dyna_var_check loop { assert ( ! defined? ( iii ) ) break } end dyna_var_check break } p1 . call ( <int> ) p2 . call assert_equal ( <int> , x ) end def assert_arity ( n ) meta = class << self ; self ; end meta . class_eval { define_method ( <str> , Proc . new ) } assert_equal ( n , method ( <str> ) . arity ) end def test_arity assert_equal ( <int> , proc { } . arity ) assert_equal ( <int> , proc { || } . arity ) assert_equal ( <int> , proc { | x | } . arity ) assert_equal ( <int> , proc { | x = <int> | } . arity ) assert_equal ( <int> , proc { | x , y | } . arity ) assert_equal ( <int> , proc { | x = <int> , y | } . arity ) assert_equal ( <int> , proc { | x = <int> , y = <int> | } . arity ) assert_equal ( <int> , proc { | x , y = <int> | } . arity ) assert_equal ( - <int> , proc { | x , * y | } . arity ) assert_equal ( - <int> , proc { | x = <int> , * y | } . arity ) assert_equal ( - <int> , proc { | * x | } . arity ) assert_equal ( - <int> , proc { | * | } . arity ) assert_equal ( - <int> , proc { | x , * y , z | } . arity ) assert_equal ( - <int> , proc { | x = <int> , * y , z | } . arity ) assert_equal ( <int> , proc { | ( x , y ) , z | [ x , y ] } . arity ) assert_equal ( <int> , proc { | ( x , y ) , z = <int> | [ x , y ] } . arity ) assert_equal ( - <int> , proc { | x , * y , z , a | } . arity ) assert_equal ( <int> , proc { | ** | } . arity ) assert_equal ( <int> , proc { | ** o | } . arity ) assert_equal ( <int> , proc { | x , ** o | } . arity ) assert_equal ( <int> , proc { | x = <int> , ** o | } . arity ) assert_equal ( <int> , proc { | x , y = <int> , ** o | } . arity ) assert_equal ( <int> , proc { | x , y = <int> , z , ** o | } . arity ) assert_equal ( - <int> , proc { | x , y = <int> , * z , w , ** o | } . arity ) assert_equal ( <int> , proc { | x , y = <int> , z , <str> : <int> | } . arity ) assert_equal ( <int> , proc { | x , y = <int> , z , <str> : | } . arity ) assert_equal ( - <int> , proc { | x , y , * rest , <str> : , <str> : , <str> : | } . arity ) assert_equal ( <int> , proc { | x , y = <int> , z , <str> : , ** o | } . arity ) assert_equal ( <int> , lambda { } . arity ) assert_equal ( <int> , lambda { || } . arity ) assert_equal ( <int> , lambda { | x | } . arity ) assert_equal ( - <int> , lambda { | x = <int> | } . arity ) assert_equal ( <int> , lambda { | x , y | } . arity ) assert_equal ( - <int> , lambda { | x = <int> , y | } . arity ) assert_equal ( - <int> , lambda { | x = <int> , y = <int> | } . arity ) assert_equal ( - <int> , lambda { | x , y = <int> | } . arity ) assert_equal ( - <int> , lambda { | x , * y | } . arity ) assert_equal ( - <int> , lambda { | x = <int> , * y | } . arity ) assert_equal ( - <int> , lambda { | * x | } . arity ) assert_equal ( - <int> , lambda { | * | } . arity ) assert_equal ( - <int> , lambda { | x , * y , z | } . arity ) assert_equal ( - <int> , lambda { | x = <int> , * y , z | } . arity ) assert_equal ( <int> , lambda { | ( x , y ) , z | [ x , y ] } . arity ) assert_equal ( - <int> , lambda { | ( x , y ) , z = <int> | [ x , y ] } . arity ) assert_equal ( - <int> , lambda { | x , * y , z , a | } . arity ) assert_equal ( - <int> , lambda { | ** | } . arity ) assert_equal ( - <int> , lambda { | ** o | } . arity ) assert_equal ( - <int> , lambda { | x , ** o | } . arity ) assert_equal ( - <int> , lambda { | x = <int> , ** o | } . arity ) assert_equal ( - <int> , lambda { | x , y = <int> , ** o | } . arity ) assert_equal ( - <int> , lambda { | x , y = <int> , z , ** o | } . arity ) assert_equal ( - <int> , lambda { | x , y = <int> , * z , w , ** o | } . arity ) assert_arity ( <int> ) { } assert_arity ( <int> ) { || } assert_arity ( <int> ) { | x | } assert_arity ( <int> ) { | x , y | } assert_arity ( - <int> ) { | x , * y | } assert_arity ( - <int> ) { | x , * y , z | } assert_arity ( - <int> ) { | * x | } assert_arity ( - <int> ) { | * | } assert_arity ( - <int> ) { | ** o | } assert_arity ( - <int> ) { | ** | } assert_arity ( - <int> ) { | x , * y , ** | } assert_arity ( - <int> ) { | x , * y , z , ** | } end def m ( x ) lambda { x } end def test_eq a = m ( <int> ) b = m ( <int> ) assert_not_equal ( a , b , <str> ) assert_not_equal ( a . call , b . call , <str> ) assert_not_equal ( proc { || } , proc { | x , y | } , <str> ) a = lambda { | x | lambda { } } . call ( <int> ) b = lambda { } assert_not_equal ( a , b , <str> ) end def test_block_par assert_equal ( <int> , Proc . new { | & b | b . call ( <int> ) } . call { | x | x } ) assert_equal ( <int> , Proc . new { | a , & b | b . call ( a ) } . call ( <int> ) { | x | x } ) end def test_safe safe = $SAFE c = Class . new x = c . new p = proc { $SAFE += <int> proc { $SAFE } } . call assert_equal ( safe , $SAFE ) assert_equal ( safe + <int> , p . call ) assert_equal ( safe , $SAFE ) c . class_eval { define_method ( <str> , p ) } assert_equal ( safe , x . safe ) assert_equal ( safe , x . method ( <str> ) . call ) assert_equal ( safe , x . method ( <str> ) . to_proc . call ) p = proc { $SAFE += <int> } assert_equal ( safe + <int> , p . call ) assert_equal ( safe , $SAFE ) c . class_eval { define_method ( <str> , p ) } assert_equal ( safe + <int> , proc { x . inc ; $SAFE } . call ) assert_equal ( safe , $SAFE ) assert_equal ( safe + <int> , proc { x . method ( <str> ) . call ; $SAFE } . call ) assert_equal ( safe , $SAFE ) assert_equal ( safe + <int> , proc { x . method ( <str> ) . to_proc . call ; $SAFE } . call ) assert_equal ( safe , $SAFE ) end def m2 <str> end def block method ( <str> ) . to_proc end def m1 ( var ) var end def m_block_given? m1 ( block_given? ) end def test_method_to_proc b = block ( ) assert_equal <str> , b . call b = b . binding assert_instance_of ( Binding , b , <str> ) bug10432 = <str> assert_same ( self , b . receiver , bug10432 ) assert_not_send [ b , <str> , <str> ] assert_raise ( NameError ) { b . local_variable_get ( <str> ) } assert_equal <int> , b . local_variable_set ( <str> , <int> ) assert_send [ b , <str> , <str> ] assert_equal <int> , b . local_variable_get ( <str> ) end def test_block_given_method m = method ( <str> ) assert ( ! m . call , <str> ) assert ( m . call { } , <str> ) assert ( ! m . call , <str> ) end def test_block_given_method_to_proc bug8341 = <str> m = method ( <str> ) . to_proc assert ( ! m . call , <str> bug8341 <str> ) assert ( m . call { } , <str> bug8341 <str> ) assert ( ! m . call , <str> bug8341 <str> ) end def test_block_persist_between_calls bug8341 = <str> o = Object . new def o . m1 ( top = true ) if top [ block_given? , @m . call ( false ) ] else block_given? end end m = o . method ( <str> ) . to_proc o . instance_variable_set ( <str> , m ) assert_equal ( [ true , false ] , m . call { } , <str> bug8341 <str> ) assert_equal ( [ false , false ] , m . call , <str> bug8341 <str> ) end def test_curry b = proc { | x , y , z | ( x || <int> ) + ( y || <int> ) + ( z || <int> ) } assert_equal ( <int> , b . curry [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry [ <int> , <int> ] [ <int> , <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> ] [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> , <int> ] [ <int> , <int> ] [ <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> ] ) b = proc { | x , y , z , * w | ( x || <int> ) + ( y || <int> ) + ( z || <int> ) + w . inject ( <int> , & <str> ) } assert_equal ( <int> , b . curry [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry [ <int> , <int> ] [ <int> , <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> ] [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> , <int> ] [ <int> , <int> ] [ <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> ] ) b = lambda { | x , y , z | ( x || <int> ) + ( y || <int> ) + ( z || <int> ) } assert_equal ( <int> , b . curry [ <int> ] [ <int> ] [ <int> ] ) assert_raise ( ArgumentError ) { b . curry [ <int> , <int> ] [ <int> , <int> ] } assert_raise ( ArgumentError ) { b . curry ( <int> ) } assert_raise ( ArgumentError ) { b . curry ( <int> ) } b = lambda { | x , y , z , * w | ( x || <int> ) + ( y || <int> ) + ( z || <int> ) + w . inject ( <int> , & <str> ) } assert_equal ( <int> , b . curry [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry [ <int> , <int> ] [ <int> , <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> ] [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) assert_equal ( <int> , b . curry ( <int> ) [ <int> , <int> ] [ <int> , <int> ] [ <int> ] ) assert_raise ( ArgumentError ) { b . curry ( <int> ) } b = proc { <str> } assert_equal ( <str> , b . curry [ ] ) b = lambda { | x , y , & blk | blk . call ( x + y ) } . curry b = b . call ( <int> ) { raise } b = b . call ( <int> ) { | x | x + <int> } assert_equal ( <int> , b ) l = proc { } assert_equal ( false , l . lambda? ) assert_equal ( false , l . curry . lambda? , <str> ) l = lambda { } assert_equal ( true , l . lambda? ) assert_equal ( true , l . curry . lambda? , <str> ) end def test_curry_ski_fib s = proc { | f , g , x | f [ x ] [ g [ x ] ] } . curry k = proc { | x , y | x } . curry i = proc { | x | x } . curry fib = [ ] inc = proc { | x | fib [ - <int> ] += <int> ; x } . curry ret = proc { | x | throw <str> if fib . size > <int> ; fib << <int> ; x } . curry catch ( <str> ) do s [ s [ s [ i ] [ i ] ] [ k [ i ] ] ] [ k [ inc ] ] [ s [ s [ k [ s ] ] [ s [ k [ s [ k [ s ] ] ] ] [ s [ s [ k [ s ] ] [ s [ k [ s [ k [ ret ] ] ] ] [ s [ k [ s [ i ] ] ] [ k ] ] ] ] [ k ] ] ] ] [ k [ s [ k [ s ] ] [ k ] ] ] ] end assert_equal ( fib , [ <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_curry_from_knownbug a = lambda { | x , y , & b | b } b = a . curry [ <int> ] assert_equal ( <str> , if b . call ( <int> ) { } == nil <str> else <str> end , <str> ) end def test_curry_instance_exec a = lambda { | x , y | [ x + y , self ] } b = a . curry . call ( <int> ) result = instance_exec <int> , & b assert_equal ( <int> , result [ <int> ] ) assert_equal ( self , result [ <int> ] ) end def test_curry_optional_params obj = Object . new def obj . foo ( a , b = <int> ) ; end assert_raise ( ArgumentError ) { obj . method ( <str> ) . to_proc . curry ( <int> ) } assert_raise ( ArgumentError ) { - > ( a , b = <int> ) { } . curry ( <int> ) } end def test_dup_clone b = proc { | x | x + <str> } class << b ; attr_accessor <str> ; end bd = b . dup assert_equal ( <str> , bd . call ( <str> ) ) assert_raise ( NoMethodError ) { bd . foo = <str> } assert_raise ( NoMethodError ) { bd . foo } bc = b . clone assert_equal ( <str> , bc . call ( <str> ) ) bc . foo = <str> assert_equal ( <str> , bc . foo ) end def test_binding b = proc { | x , y , z | proc { } . binding } . call ( <int> , <int> , <int> ) class << b ; attr_accessor <str> ; end bd = b . dup assert_equal ( [ <int> , <int> , <int> ] , bd . eval ( <str> ) ) assert_raise ( NoMethodError ) { bd . foo = <str> } assert_raise ( NoMethodError ) { bd . foo } bc = b . clone assert_equal ( [ <int> , <int> , <int> ] , bc . eval ( <str> ) ) bc . foo = <str> assert_equal ( <str> , bc . foo ) b = nil <int> . times { x , y , z = <int> , <int> , <int> ; [ x , y , z ] ; b = binding } assert_equal ( [ <int> , <int> , <int> ] , b . eval ( <str> ) ) end def test_proc_lambda assert_raise ( ArgumentError ) { proc } assert_raise ( ArgumentError ) { lambda } o = Object . new def o . foo b = nil <int> . times { b = lambda } b end assert_equal ( <str> , o . foo { <str> } . call ) def o . foo ( & b ) b = nil <int> . times { b = lambda } b end assert_equal ( <str> , o . foo { <str> } . call ) end def test_arity2 assert_equal ( <int> , method ( <str> ) . to_proc . arity ) assert_equal ( - <int> , proc { } . curry . arity ) c = Class . new c . class_eval { attr_accessor <str> } assert_equal ( <int> , c . new . method ( <str> = ) . to_proc . arity ) end def test_proc_location t = Thread . new { sleep } assert_raise ( ThreadError ) { t . instance_eval { initialize { } } } t . kill t . join end def test_to_proc b = proc { <str> } assert_equal ( <str> , b . to_proc . call ) end def test_localjump_error o = o = Object . new def foo ; yield ; end exc = foo rescue $! assert_nil ( exc . exit_value ) assert_equal ( <str> , exc . reason ) end def test_curry_binding assert_raise ( ArgumentError ) { proc { } . curry . binding } end def test_proc_args_plain pr = proc { | a , b , c , d , e | [ a , b , c , d , e ] } assert_equal [ nil , nil , nil , nil , nil ] , pr . call ( ) assert_equal [ <int> , nil , nil , nil , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , nil , nil , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> , nil , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , nil ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , nil , nil , nil ] , pr . call ( [ ] ) assert_equal [ <int> , nil , nil , nil , nil ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , nil , nil , nil ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , nil , nil ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , nil ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) r = proc { | a | a } . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , r r = proc { | a , | a } . call ( [ <int> , <int> , <int> ] ) assert_equal <int> , r r = proc { | a , | a } . call ( [ ] ) assert_equal nil , r end def test_proc_args_rest pr = proc { | a , b , c , * d | [ a , b , c , d ] } assert_equal [ nil , nil , nil , [ ] ] , pr . call ( ) assert_equal [ <int> , nil , nil , [ ] ] , pr . call ( <int> ) assert_equal [ <int> , <int> , nil , [ ] ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> , <int> ] ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , nil , [ ] ] , pr . call ( [ ] ) assert_equal [ <int> , nil , nil , [ ] ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , nil , [ ] ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> , <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) r = proc { | * a | a } . call ( [ <int> , <int> , <int> ] ) assert_equal [ [ <int> , <int> , <int> ] ] , r end def test_proc_args_pos_rest_post pr = proc { | a , b , * c , d , e | [ a , b , c , d , e ] } assert_equal [ nil , nil , [ ] , nil , nil ] , pr . call ( ) assert_equal [ <int> , nil , [ ] , nil , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , [ ] , nil , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , [ ] , <int> , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , [ ] , nil , nil ] , pr . call ( [ ] ) assert_equal [ <int> , nil , [ ] , nil , nil ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , [ ] , nil , nil ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , [ ] , <int> , nil ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , [ ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , [ <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , [ <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , [ <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_rest_post pr = proc { | * a , b , c | [ a , b , c ] } assert_equal [ [ ] , nil , nil ] , pr . call ( ) assert_equal [ [ ] , <int> , nil ] , pr . call ( <int> ) assert_equal [ [ ] , <int> , <int> ] , pr . call ( <int> , <int> ) assert_equal [ [ <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ [ <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ [ <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ [ <int> , <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ [ <int> , <int> , <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ [ ] , nil , nil ] , pr . call ( [ ] ) assert_equal [ [ ] , <int> , nil ] , pr . call ( [ <int> ] ) assert_equal [ [ ] , <int> , <int> ] , pr . call ( [ <int> , <int> ] ) assert_equal [ [ <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ [ <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ [ <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ [ <int> , <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ [ <int> , <int> , <int> , <int> , <int> ] , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_pos_opt pr = proc { | a , b , c = <str> | [ a , b , c ] } assert_equal [ nil , nil , <str> ] , pr . call ( ) assert_equal [ <int> , nil , <str> ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , <str> ] , pr . call ( [ ] ) assert_equal [ <int> , nil , <str> ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_opt pr = proc { | a = <str> , b = <str> , c = <str> | [ a , b , c ] } assert_equal [ <str> , <str> , <str> ] , pr . call ( ) assert_equal [ <int> , <str> , <str> ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ <str> , <str> , <str> ] , pr . call ( [ ] ) assert_equal [ <int> , <str> , <str> ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_opt_single bug7621 = <str> pr = proc { | a = <str> | a } assert_equal <str> , pr . call ( ) assert_equal <int> , pr . call ( <int> ) assert_equal <int> , pr . call ( <int> , <int> ) assert_equal [ ] , pr . call ( [ ] ) , bug7621 assert_equal [ <int> ] , pr . call ( [ <int> ] ) , bug7621 assert_equal [ <int> , <int> ] , pr . call ( [ <int> , <int> ] ) , bug7621 assert_equal [ <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) , bug7621 assert_equal [ <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) , bug7621 end def test_proc_args_pos_opt_post pr = proc { | a , b , c = <str> , d , e | [ a , b , c , d , e ] } assert_equal [ nil , nil , <str> , nil , nil ] , pr . call ( ) assert_equal [ <int> , nil , <str> , nil , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> , nil , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <str> , <int> , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <str> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , <str> , nil , nil ] , pr . call ( [ ] ) assert_equal [ <int> , nil , <str> , nil , nil ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> , nil , nil ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <str> , <int> , nil ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <str> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_opt_post pr = proc { | a = <str> , b = <str> , c = <str> , d , e | [ a , b , c , d , e ] } assert_equal [ <str> , <str> , <str> , nil , nil ] , pr . call ( ) assert_equal [ <str> , <str> , <str> , <int> , nil ] , pr . call ( <int> ) assert_equal [ <str> , <str> , <str> , <int> , <int> ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <str> , <str> , <int> , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <str> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ <str> , <str> , <str> , nil , nil ] , pr . call ( [ ] ) assert_equal [ <str> , <str> , <str> , <int> , nil ] , pr . call ( [ <int> ] ) assert_equal [ <str> , <str> , <str> , <int> , <int> ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <str> , <str> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <str> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , <int> , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_pos_opt_rest pr = proc { | a , b , c = <str> , * d | [ a , b , c , d ] } assert_equal [ nil , nil , <str> , [ ] ] , pr . call ( ) assert_equal [ <int> , nil , <str> , [ ] ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> , [ ] ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , <str> , [ ] ] , pr . call ( [ ] ) assert_equal [ <int> , nil , <str> , [ ] ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> , [ ] ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_opt_rest pr = proc { | a = <str> , b = <str> , c = <str> , * d | [ a , b , c , d ] } assert_equal [ <str> , <str> , <str> , [ ] ] , pr . call ( ) assert_equal [ <int> , <str> , <str> , [ ] ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> , [ ] ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <str> , <str> , <str> , [ ] ] , pr . call ( [ ] ) assert_equal [ <int> , <str> , <str> , [ ] ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> , [ ] ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ ] ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_pos_opt_rest_post pr = proc { | a , b , c = <str> , * d , e | [ a , b , c , d , e ] } assert_equal [ nil , nil , <str> , [ ] , nil ] , pr . call ( ) assert_equal [ <int> , nil , <str> , [ ] , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , <str> , [ ] , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <str> , [ ] , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , <str> , [ ] , nil ] , pr . call ( [ ] ) assert_equal [ <int> , nil , <str> , [ ] , nil ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , <str> , [ ] , nil ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <str> , [ ] , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_opt_rest_post pr = proc { | a = <str> , b = <str> , c = <str> , * d , e | [ a , b , c , d , e ] } assert_equal [ <str> , <str> , <str> , [ ] , nil ] , pr . call ( ) assert_equal [ <str> , <str> , <str> , [ ] , <int> ] , pr . call ( <int> ) assert_equal [ <int> , <str> , <str> , [ ] , <int> ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , <str> , [ ] , <int> ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] , <int> ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ <str> , <str> , <str> , [ ] , nil ] , pr . call ( [ ] ) assert_equal [ <str> , <str> , <str> , [ ] , <int> ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <str> , <str> , [ ] , <int> ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , <str> , [ ] , <int> ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , <int> , [ <int> , <int> ] , <int> ] , pr . call ( [ <int> , <int> , <int> , <int> , <int> , <int> ] ) end def test_proc_args_pos_block pr = proc { | a , b , & c | [ a , b , c . class , c && c . call ( <str> ) ] } assert_equal [ nil , nil , NilClass , nil ] , pr . call ( ) assert_equal [ <int> , nil , NilClass , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , NilClass , nil ] , pr . call ( [ ] ) assert_equal [ <int> , nil , NilClass , nil ] , pr . call ( [ <int> ] ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( [ <int> , <int> ] ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( [ <int> , <int> , <int> ] ) assert_equal [ <int> , <int> , NilClass , nil ] , pr . call ( [ <int> , <int> , <int> , <int> ] ) assert_equal [ nil , nil , Proc , <str> ] , ( pr . call ( ) { <str> } ) assert_equal [ <int> , nil , Proc , <str> ] , ( pr . call ( <int> ) { <str> } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { <str> } ) assert_equal [ nil , nil , Proc , <str> ] , ( pr . call ( ) { | x | x } ) assert_equal [ <int> , nil , Proc , <str> ] , ( pr . call ( <int> ) { | x | x } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { | x | x } ) end def test_proc_args_pos_rest_block pr = proc { | a , b , * c , & d | [ a , b , c , d . class , d && d . call ( <str> ) ] } assert_equal [ nil , nil , [ ] , NilClass , nil ] , pr . call ( ) assert_equal [ <int> , nil , [ ] , NilClass , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , [ ] , NilClass , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , [ <int> ] , NilClass , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> , <int> ] , NilClass , nil ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , [ ] , Proc , <str> ] , ( pr . call ( ) { <str> } ) assert_equal [ <int> , nil , [ ] , Proc , <str> ] , ( pr . call ( <int> ) { <str> } ) assert_equal [ <int> , <int> , [ ] , Proc , <str> ] , ( pr . call ( <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ <int> , <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { <str> } ) assert_equal [ nil , nil , [ ] , Proc , <str> ] , ( pr . call ( ) { | x | x } ) assert_equal [ <int> , nil , [ ] , Proc , <str> ] , ( pr . call ( <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ ] , Proc , <str> ] , ( pr . call ( <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ <int> , <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { | x | x } ) end def test_proc_args_rest_block pr = proc { | * c , & d | [ c , d . class , d && d . call ( <str> ) ] } assert_equal [ [ ] , NilClass , nil ] , pr . call ( ) assert_equal [ [ <int> ] , NilClass , nil ] , pr . call ( <int> ) assert_equal [ [ <int> , <int> ] , NilClass , nil ] , pr . call ( <int> , <int> ) assert_equal [ [ ] , Proc , <str> ] , ( pr . call ( ) { <str> } ) assert_equal [ [ <int> ] , Proc , <str> ] , ( pr . call ( <int> ) { <str> } ) assert_equal [ [ <int> , <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> ) { <str> } ) assert_equal [ [ ] , Proc , <str> ] , ( pr . call ( ) { | x | x } ) assert_equal [ [ <int> ] , Proc , <str> ] , ( pr . call ( <int> ) { | x | x } ) assert_equal [ [ <int> , <int> ] , Proc , <str> ] , ( pr . call ( <int> , <int> ) { | x | x } ) end def test_proc_args_pos_rest_post_block pr = proc { | a , b , * c , d , e , & f | [ a , b , c , d , e , f . class , f && f . call ( <str> ) ] } assert_equal [ nil , nil , [ ] , nil , nil , NilClass , nil ] , pr . call ( ) assert_equal [ <int> , nil , [ ] , nil , nil , NilClass , nil ] , pr . call ( <int> ) assert_equal [ <int> , <int> , [ ] , nil , nil , NilClass , nil ] , pr . call ( <int> , <int> ) assert_equal [ <int> , <int> , [ ] , <int> , nil , NilClass , nil ] , pr . call ( <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ ] , <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> ] , <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> , <int> , <int> , <int> ) assert_equal [ <int> , <int> , [ <int> , <int> ] , <int> , <int> , NilClass , nil ] , pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) assert_equal [ nil , nil , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( ) { <str> } ) assert_equal [ <int> , nil , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( <int> ) { <str> } ) assert_equal [ <int> , <int> , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ ] , <int> , nil , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ ] , <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ <int> ] , <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> , <int> ) { <str> } ) assert_equal [ <int> , <int> , [ <int> , <int> ] , <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> , <int> , <int> ) { <str> } ) assert_equal [ nil , nil , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( ) { | x | x } ) assert_equal [ <int> , nil , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ ] , nil , nil , Proc , <str> ] , ( pr . call ( <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ ] , <int> , nil , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> ) { | x | x } ) assert_equal [ <int> , <int> , [ ] , <int> , <int> , Proc , <str> ] , ( pr . call ( <int> , <int> , <int> , <int> ) { | x | x } ) 
