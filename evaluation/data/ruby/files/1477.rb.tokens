require <str> module Rex module Parser load_nokogiri && class AppscanDocument < Nokogiri :: XML :: SAX :: Document include NokogiriDocMixin attr_reader <str> attr_reader <str> def start_document @parse_warnings = [ ] @resolv_cache = { } end def start_element ( name = nil , attrs = [ ] ) attrs = normalize_attrs ( attrs ) block = @block @state [ <str> ] [ name ] = true case name when <str> collect_issue ( attrs ) when <str> collect_entity ( attrs ) when <str> , <str> , <str> @state [ <str> ] = true end end def end_element ( name = nil ) block = @block case name when <str> record_issue @state = @state . select do | k | [ <str> , <str> ] . include? k end when <str> @state [ <str> ] = false record_url @text = nil report_web_site ( & block ) handle_parse_warnings ( & block ) when <str> @state [ <str> ] = false record_risk @text = nil when <str> @state [ <str> ] = false record_request_and_response report_service_info page_info = report_web_page ( & block ) if page_info form_info = report_web_form ( page_info , & block ) if form_info report_web_vuln ( form_info , & block ) end end @text = nil end @state [ <str> ] . delete name end def report_web_vuln ( form_info , & block ) return unless ( in_issue && has_text ) return unless form_info . kind_of? Hash return unless @state [ <str> ] return unless @state [ <str> ] [ <str> ] return unless @state [ <str> ] [ <str> ] . to_s . downcase == <str> return unless @state [ <str> ] [ <str> ] web_vuln_info = { } web_vuln_info [ <str> ] = form_info [ <str> ] web_vuln_info [ <str> ] = form_info [ <str> ] web_vuln_info [ <str> ] = form_info [ <str> ] web_vuln_info [ <str> ] = form_info [ <str> ] web_vuln_info [ <str> ] = form_info [ <str> ] web_vuln_info [ <str> ] = @state [ <str> ] [ <str> ] web_vuln_info [ <str> ] = <str> web_vuln_info [ <str> ] = @state [ <str> ] [ <str> ] web_vuln_info [ <str> ] = @state [ <str> ] [ <str> ] web_vuln_info [ <str> ] = <str> web_vuln_info [ <str> ] = <int> db . emit ( <str> , web_vuln_info [ <str> ] , & block ) if block web_vuln = db_report ( <str> , web_vuln_info ) end def collect_entity ( attrs ) return unless in_issue return unless @state [ <str> ] . kind_of? Hash ent_hash = attr_hash ( attrs ) return unless ent_hash return unless ent_hash [ <str> ] . to_s . downcase == <str> @state [ <str> ] [ <str> ] = ent_hash [ <str> ] end def report_web_form ( page_info , & block ) return unless ( in_issue && has_text ) return unless page_info . kind_of? Hash return unless @state [ <str> ] return if @state [ <str> ] . strip . empty? web_form_info = { } web_form_info [ <str> ] = page_info [ <str> ] web_form_info [ <str> ] = page_info [ <str> ] web_form_info [ <str> ] = page_info [ <str> ] web_form_info [ <str> ] = @state [ <str> ] . cmd_string . split ( <str> ) [ <int> ] parsed_params = parse_params ( @state [ <str> ] ) return unless parsed_params return if parsed_params . empty? web_form_info [ <str> ] = parsed_params web_form = db_report ( <str> , web_form_info ) @state [ <str> ] || = [ ] unless @state [ <str> ] . include? web_form db . emit ( <str> , @state [ <str> ] . to_s , & block ) if block @state [ <str> ] << web_form end web_form_info end def parse_params ( request_body ) return unless request_body pairs = request_body . split ( <str> ) params = [ ] pairs . each do | pair | param , value = pair . split ( <str> , <int> ) params << [ param , <str> ] end params end def report_web_page ( & block ) return unless ( in_issue && has_text ) return unless @state [ <str> ] . present? return unless @state [ <str> ] . present? return unless @state [ <str> ] . present? web_page_info = { } web_page_info [ <str> ] = @state [ <str> ] web_page_info [ <str> ] = @state [ <str> ] . path web_page_info [ <str> ] = @state [ <str> ] . to_s web_page_info [ <str> ] = @state [ <str> ] . query code = @state [ <str> ] . cmd_string . split ( <str> ) [ <int> ] return unless code web_page_info [ <str> ] = code parsed_headers = { } @state [ <str> ] . each do | k , v | parsed_headers [ k . to_s . downcase ] || = [ ] parsed_headers [ k . to_s . downcase ] << v end return if parsed_headers . empty? web_page_info [ <str> ] = parsed_headers web_page = db_report ( <str> , web_page_info ) @state [ <str> ] || = [ ] unless @state [ <str> ] . include? web_page db . emit ( <str> , @state [ <str> ] . to_s , & block ) if block @state [ <str> ] << web_page end web_page_info end def report_service_info return unless ( in_issue && has_text ) return unless @state [ <str> ] return unless @state [ <str> ] banner = @state [ <str> ] [ <str> ] return unless banner service = @state [ <str> ] . service return unless service . info . to_s . empty? service_info = { <str> = > service . host , <str> = > service . port , <str> = > service . proto , <str> = > banner } db_report ( <str> , service_info ) end def record_request_and_response return unless ( in_issue && has_text ) return unless @state [ <str> ] . present? really_original_traffic = unindent_and_crlf ( @text ) request_headers , request_body , response_headers , response_body = really_original_traffic . split ( <str> ) return unless ( request_headers && response_headers ) req_header = Rex :: Proto :: Http :: Packet :: Header . new res_header = Rex :: Proto :: Http :: Packet :: Header . new req_header . from_s request_headers . lstrip res_header . from_s response_headers . lstrip if response_body . blank? response_body = <str> end @state [ <str> ] = req_header @state [ <str> ] = request_body . lstrip @state [ <str> ] = res_header @state [ <str> ] = response_body . lstrip end def unindent_and_crlf ( text ) second_line = text . split ( <str> ) [ <int> ] indent_level = second_line . size - second_line . lstrip . size unindented_text_lines = [ ] text . split ( <str> ) . each do | line | if line =~ <str> indent_level <str> unindented_line = line [ indent_level , line . size ] unindented_text_lines << unindented_line else unindented_text_lines << line end end unindented_text_lines . join ( <str> ) end def record_risk return unless ( in_issue && has_text ) @state [ <str> ] || = { } @state [ <str> ] [ <str> ] = map_severity_to_risk end def map_severity_to_risk case @text . to_s . downcase when <str> ; <int> when <str> ; <int> when <str> ; <int> else ; <int> end end def record_issue return unless in_issue return unless @report_data [ <str> ] . kind_of? Hash return unless @state [ <str> ] return if @state [ <str> ] [ <str> ] . to_s . downcase == <str> end def collect_issue ( attrs ) return unless in_issue @state [ <str> ] = { } @state [ <str> ] . merge! attr_hash ( attrs ) end def report_web_site ( & block ) return unless @state [ <str> ] uri = @state [ <str> ] hostname = uri . host address = resolve_issue_url_address ( uri ) return unless address unless @resolv_cache . values . include? address db . emit ( <str> , address , & block ) if block end port = resolve_port ( uri ) return unless port scheme = uri . scheme return unless scheme web_site_info = { <str> = > @args [ <str> ] } web_site_info [ <str> ] = hostname service_obj = check_for_existing_service ( address , port ) if service_obj web_site_info [ <str> ] = service_obj else web_site_info [ <str> ] = address web_site_info [ <str> ] = port web_site_info [ <str> ] = scheme == <str> end web_site_obj = db_report ( <str> , web_site_info ) @state [ <str> ] || = [ ] unless @state [ <str> ] . include? web_site_obj url = <str> uri . scheme <str> uri . host <str> uri . port <str> db . emit ( <str> , url , & block ) if block db . report_import_note ( @args [ <str> ] , web_site_obj . service . host ) @state [ <str> ] << web_site_obj end @state [ <str> ] = service_obj || web_site_obj . service @state [ <str> ] = ( service_obj || web_site_obj . service ) . host @state [ <str> ] = web_site_obj end def check_for_existing_service ( address , port ) db . get_service ( @args [ <str> ] , address , <str> , port ) end def resolve_port ( uri ) @state [ <str> ] = uri . port unless @state [ <str> ] @parse_warnings << <str> @state [ <str> ] <str> end return @state [ <str> ] end def resolve_address ( host ) return @resolv_cache [ host ] if @resolv_cache [ host ] address = Rex :: Socket . resolv_to_dotted ( host ) rescue nil @resolv_cache [ host ] = address if address block = @block db . emit ( <str> , address , & block ) if block end return address end def resolve_issue_url_address ( uri ) if uri . host address = resolve_address ( uri . host ) unless address @parse_warnings << <str> uri . host <str> end else @parse_warnings << <str> end address end def handle_parse_warnings ( & block ) return if @parse_warnings . empty? @parse_warnings . each do | pwarn | db . emit ( <str> , pwarn , & block ) if block end end def record_url return unless in_issue return unless has_text uri = URI . parse ( @text ) rescue nil return unless uri @state [ <str> ] = uri end def in_issue return false unless in_tag ( <str> ) return false unless in_tag ( <str> ) return false unless in_tag ( <str> ) return true end def has_text return false unless @text return false if @text . strip . empty? @text = @text . strip end end end end 
