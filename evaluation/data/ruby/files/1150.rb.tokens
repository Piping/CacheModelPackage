module Rex module Struct2 require <str> class CStruct_Values def initialize ( obj ) @obj = obj end def [] ( * args ) o = @obj [ * args ] return if ! o return o . value end def []= ( * args ) o = @obj [ * args [ <int> .. - <int> ] ] return if ! o o . value = args [ - <int> ] end def method_missing ( sym , * args ) if sym . to_s [ - <int> ] == <str> [ <int> ] return self [ sym . to_s [ <int> .. - <int> ] ] = args [ <int> ] else return self [ sym . to_s ] end end end class CStruct < SStruct require <str> require <str> require <str> require <str> require <str> include Rex :: Struct2 :: Element attr_reader <str> @@dt_table = { <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , true , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: Generic . new ( <str> , false , * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: SString . new ( * a ) } , <str> = > proc { | * a | Rex :: Struct2 :: SStruct . new ( * a ) } , <str> = > proc { | o | o } , <str> = > proc { | o | o . make_struct } , } def CStruct . typedef ( * args ) while args . length > = <int> name = args . shift factory = args . shift @@dt_table [ name ] = factory end end def initialize ( * dts ) super ( ) @name_table = [ ] @v = Rex :: Struct2 :: CStruct_Values . new ( self ) return self . add_from_dt ( * dts ) end def add_from_dt ( * dts ) dts . each { | dt | return if ! dt . kind_of? ( Array ) || dt . length < <int> type = dt [ <int> ] name = dt [ <int> ] factory = @@dt_table [ type ] return if ! factory obj = factory . call ( * ( dt [ <int> .. - <int> ] ) ) self . add_object ( name , obj ) } return dts . length end def add_object ( * objs ) while objs . length > = <int> @name_table << objs . shift self << objs . shift end end def apply_restraint ( * ress ) while ress . length > = <int> name = ress . shift res = ress . shift self [ name ] . restraint = res self [ name ] . update_restraint end return self end def create_restraints ( * ress ) ress . each { | r | r = r . dup r [ <int> ] = self [ r [ <int> ] ] if r [ <int> ] r [ <int> ] = self [ r [ <int> ] ] if r [ <int> ] self . apply_restraint ( r [ <int> ] , Rex :: Struct2 :: Restraint . new ( * r [ <int> .. - <int> ] ) ) } return self end def [] ( index , * other ) if index . kind_of? ( String ) i = @name_table . index ( index ) return if ! i return super ( i ) else return super ( index , * other ) end end def []= ( index , * other ) if index . kind_of? ( String ) i = @name_table . index ( index ) return if ! i return super ( i , * other ) else return super ( index , * other ) end end def keys @name_table end def each_pair ( & block ) @name_table . each do | k | block . call ( k , self . v [ k ] ) end end end end end 
