require <str> RSpec . describe Rex :: Text do context <str> do context <str> do it <str> do expect ( described_class . to_ebcdic ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( lambda { described_class . to_ebcdic ( <str> ) } ) . to raise_exception ( described_class :: IllegalSequence ) end end context <str> do it <str> do expect ( described_class . from_ebcdic ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( lambda { described_class . from_ebcdic ( <str> ) } ) . to raise_exception ( described_class :: IllegalSequence ) end end context <str> do it <str> do expect ( described_class . to_ibm1047 ( <str> ) ) . to eq ( <str> ) end end context <str> do it <str> do expect ( described_class . from_ibm1047 ( <str> ) ) . to eq ( <str> ) end end context <str> do it <str> do expect ( described_class . to_utf8 ( <str> ) ) . to eq ( <str> ) expect ( described_class . to_utf8 ( <str> ) ) . to eq ( <str> ) end end context <str> do it <str> do expect ( described_class . to_octal ( <str> * <int> ) ) . to eq ( <str> * <int> ) all_chars = ( <int> .. <hex> ) . map { | c | [ c ] . pack ( <str> ) } . join all_octal = ( <int> .. <hex> ) . map { | c | <str> } . join expect ( described_class . to_octal ( all_chars ) ) . to eq ( all_octal ) end it <str> do expect ( described_class . to_octal ( <str> * <int> , <str> ) ) . to eq ( <str> * <int> ) all_chars = ( <int> .. <hex> ) . map { | c | [ c ] . pack ( <str> ) } . join all_octal = ( <int> .. <hex> ) . map { | c | <str> } . join expect ( described_class . to_octal ( all_chars , <str> ) ) . to eq ( all_octal ) end end context <str> do it <str> do expect ( described_class . to_hex ( <str> * <int> ) ) . to eq ( <str> * <int> ) all_chars = ( <int> .. <hex> ) . map { | c | [ c ] . pack ( <str> ) } . join all_hex = ( <int> .. <hex> ) . map { | c | <str> } . join expect ( described_class . to_hex ( all_chars ) ) . to eq ( all_hex ) end it <str> do expect ( described_class . to_hex ( <str> * <int> , <str> ) ) . to eq ( <str> * <int> ) all_chars = ( <int> .. <hex> ) . map { | c | [ c ] . pack ( <str> ) } . join all_hex = ( <int> .. <hex> ) . map { | c | <str> } . join expect ( described_class . to_hex ( all_chars , <str> ) ) . to eq ( all_hex ) end end context <str> do it <str> do non_print = ( <hex> .. <hex> ) . map { | c | [ c ] . pack ( <str> ) } . join non_print_hex = ( <hex> .. <hex> ) . map { | c | <str> } . join expect ( described_class . to_hex_ascii ( non_print ) ) . to eq ( non_print_hex ) expect ( described_class . to_hex_ascii ( <str> ) ) . to eq ( <str> ) expect ( described_class . to_hex_ascii ( <str> ) ) . to eq ( <str> ) expect ( described_class . to_hex_ascii ( <str> * <int> ) ) . to eq ( <str> * <int> ) end it <str> do expect ( described_class . to_hex_ascii ( <str> ) ) . to eq ( <str> ) expect ( described_class . to_hex_ascii ( <str> ) ) . to eq ( <str> ) end end context <str> do it <str> do str = described_class . gzip ( <str> ) expect ( str [ <int> , <int> ] ) . to eq ( <str> ) expect ( str [ <int> .. - <int> ] ) . to eq ( <str> ) end end context <str> do it <str> do gzip = <str> gzip << <str> * <int> gzip << <str> expect ( described_class . ungzip ( gzip ) ) . to eq ( <str> ) end end context <str> do it <str> do expect ( described_class :: Surnames ) . to include ( described_class . rand_surname ) end end context <str> do it <str> do names = described_class :: Names_Female + described_class :: Names_Male expect ( names ) . to include ( described_class . rand_name ) end end context <str> do it <str> do expect ( described_class :: Names_Female ) . to include ( described_class . rand_name_female ) end end context <str> do it <str> do expect ( described_class :: Names_Male ) . to include ( described_class . rand_name_male ) end end context <str> do it <str> do names = described_class :: Names_Female + described_class :: Names_Male surnames = described_class :: Surnames tlds = described_class :: TLDs mail_address = described_class . rand_mail_address . split ( <str> ) . map { | x | x . split ( <str> ) } name , surname = mail_address . first . first , mail_address . first . last domain , tld = <str> , mail_address . last . last expect ( names ) . to include ( name ) expect ( surnames ) . to include ( surname ) expect ( domain ) . to eq ( <str> ) expect ( tlds ) . to include ( tld ) end end context <str> do let ( <str> ) { <str> } let ( <str> ) { described_class . randomize_space ( sample_text ) } it <str> do expect ( spaced_text ) . to match <str> end it <str> do normalized_text = spaced_text . gsub ( <str> , <str> ) expect ( normalized_text ) . to eq ( sample_text ) end end context <str> do def moo ( num ) ( <str> * num ) . join ( <str> ) end it <str> do cowsaid = << <str> EOCOW <str> <str> EOCOW expect ( described_class . cowsay ( moo ( <int> ) ) ) . to eq ( cowsaid ) end it <str> do cowsaid = << <str> EOCOW <str> <str> EOCOW expect ( described_class . cowsay ( moo ( <int> ) ) ) . to eq ( cowsaid ) end it <str> do cowsaid = << <str> EOCOW <str> <str> EOCOW expect ( described_class . cowsay ( moo ( <int> ) ) ) . to eq ( cowsaid ) end it <str> do wrap = <int> + rand ( <int> ) cowsaid = described_class . cowsay ( moo ( <int> ) , wrap ) max_len = cowsaid . split ( <str> ) . map ( & <str> ) . sort . last expect ( max_len ) . to eq ( wrap ) end end end end 
