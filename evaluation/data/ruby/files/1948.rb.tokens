module ActiveRecord module ConnectionAdapters class IndexDefinition < Struct . new ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) end class ColumnDefinition < Struct . new ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def primary_key? primary_key || type . to_sym == <str> end end class AddColumnDefinition < Struct . new ( <str> ) end class ChangeColumnDefinition < Struct . new ( <str> , <str> ) end class PrimaryKeyDefinition < Struct . new ( <str> ) end class ForeignKeyDefinition < Struct . new ( <str> , <str> , <str> ) def name options [ <str> ] end def column options [ <str> ] end def primary_key options [ <str> ] || default_primary_key end def on_delete options [ <str> ] end def on_update options [ <str> ] end def custom_primary_key? options [ <str> ] != default_primary_key end def defined_for? ( options_or_to_table = { } ) if options_or_to_table . is_a? ( Hash ) options_or_to_table . all? { | key , value | options [ key ] . to_s == value . to_s } else to_table == options_or_to_table . to_s end end private def default_primary_key <str> end end class ReferenceDefinition def initialize ( name , <str> : false , <str> : true , <str> : false , <str> : <str> , ** options ) @name = name @polymorphic = polymorphic @index = index @foreign_key = foreign_key @type = type @options = options if polymorphic && foreign_key raise ArgumentError , <str> end end def add_to ( table ) columns . each do | column_options | table . column ( * column_options ) end if index table . index ( column_names , index_options ) end if foreign_key table . foreign_key ( foreign_table_name , foreign_key_options ) end end protected attr_reader <str> , <str> , <str> , <str> , <str> , <str> private def as_options ( value , default = { } ) if value . is_a? ( Hash ) value else default end end def polymorphic_options as_options ( polymorphic , options ) end def index_options as_options ( index ) end def foreign_key_options as_options ( foreign_key ) . merge ( <str> : column_name ) end def columns result = [ [ column_name , type , options ] ] if polymorphic result . unshift ( [ <str> name <str> , <str> , polymorphic_options ] ) end result end def column_name <str> name <str> end def column_names columns . map ( & <str> ) end def foreign_table_name foreign_key_options . fetch ( <str> ) do Base . pluralize_table_names ? name . to_s . pluralize : name end end end module ColumnMethods def primary_key ( name , type = <str> , ** options ) column ( name , type , options . merge ( <str> : true ) ) end [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] . each do | column_type | module_eval <<- <str> CODE <str> , __FILE__ , __LINE__ + <int> <str> CODE end alias_method <str> , <str> end class TableDefinition include ColumnMethods attr_accessor <str> attr_reader <str> , <str> , <str> , <str> , <str> def initialize ( name , temporary , options , as = nil ) @columns_hash = { } @indexes = { } @foreign_keys = [ ] @primary_keys = nil @temporary = temporary @options = options @as = as @name = name end def primary_keys ( name = nil ) @primary_keys = PrimaryKeyDefinition . new ( name ) if name @primary_keys end def columns ; @columns_hash . values ; end def [] ( name ) @columns_hash [ name . to_s ] end def column ( name , type , options = { } ) name = name . to_s type = type . to_sym options = options . dup if @columns_hash [ name ] && @columns_hash [ name ] . primary_key? raise ArgumentError , <str> name <str> end index_options = options . delete ( <str> ) index ( name , index_options . is_a? ( Hash ) ? index_options : { } ) if index_options @columns_hash [ name ] = new_column_definition ( name , type , options ) self end def remove_column ( name ) @columns_hash . delete name . to_s end def index ( column_name , options = { } ) indexes [ column_name ] = options end def foreign_key ( table_name , options = { } ) foreign_keys . push ( [ table_name , options ] ) end def timestamps ( * args ) options = args . extract_options! options [ <str> ] = false if options [ <str> ] . nil? column ( <str> , <str> , options ) column ( <str> , <str> , options ) end def references ( * args , ** options ) args . each do | col | ReferenceDefinition . new ( col , ** options ) . add_to ( self ) end end alias <str> <str> def new_column_definition ( name , type , options ) type = aliased_types ( type . to_s , type ) column = create_column_definition name , type column . limit = options [ <str> ] column . precision = options [ <str> ] column . scale = options [ <str> ] column . default = options [ <str> ] column . null = options [ <str> ] column . first = options [ <str> ] column . after = options [ <str> ] column . auto_increment = options [ <str> ] column . primary_key = type == <str> || options [ <str> ] column . collation = options [ <str> ] column end private def create_column_definition ( name , type ) ColumnDefinition . new name , type end def aliased_types ( name , fallback ) <str> == name ? <str> : fallback end end class AlterTable attr_reader <str> attr_reader <str> attr_reader <str> def initialize ( td ) @td = td @adds = [ ] @foreign_key_adds = [ ] @foreign_key_drops = [ ] end def name ; @td . name ; end def add_foreign_key ( to_table , options ) @foreign_key_adds << ForeignKeyDefinition . new ( name , to_table , options ) end def drop_foreign_key ( name ) @foreign_key_drops << name end def add_column ( name , type , options ) name = name . to_s type = type . to_sym @adds << AddColumnDefinition . new ( @td . new_column_definition ( name , type , options ) ) end end class Table include ColumnMethods attr_reader <str> def initialize ( table_name , base ) @name = table_name @base = base end def column ( column_name , type , options = { } ) @base . add_column ( name , column_name , type , options ) end def column_exists? ( column_name , type = nil , options = { } ) @base . column_exists? ( name , column_name , type , options ) end def index ( column_name , options = { } ) @base . add_index ( name , column_name , options ) end def index_exists? ( column_name , options = { } ) @base . index_exists? ( name , column_name , options ) end def rename_index ( index_name , new_index_name ) @base . rename_index ( name , index_name , new_index_name ) end def timestamps ( options = { } ) @base . add_timestamps ( name , options ) end def change ( column_name , type , options = { } ) @base . change_column ( name , column_name , type , options ) end def change_default ( column_name , default_or_changes ) @base . change_column_default ( name , column_name , default_or_changes ) end def remove ( * column_names ) @base . remove_columns ( name , * column_names ) end def remove_index ( options = { } ) @base . remove_index ( name , options ) end def remove_timestamps ( options = { } ) @base . remove_timestamps ( name , options ) end def rename ( column_name , new_column_name ) @base . rename_column ( name , column_name , new_column_name ) end def references ( * args ) options = args . extract_options! args . each do | ref_name | @base . add_reference ( name , ref_name , options ) end end alias <str> <str> def remove_references ( * args ) options = args . extract_options! args . each do | ref_name | @base . remove_reference ( name , ref_name , options ) end end alias <str> <str> def foreign_key ( * args ) @base . add_foreign_key ( name , * args ) end def foreign_key_exists? ( * args ) @base . foreign_key_exists? ( name , * args ) end end end end 
