class Event < ActiveRecord :: Base include Sortable default_scope { where . not ( <str> : nil ) } CREATED = <int> UPDATED = <int> CLOSED = <int> REOPENED = <int> PUSHED = <int> COMMENTED = <int> MERGED = <int> JOINED = <int> LEFT = <int> DESTROYED = <int> delegate <str> , <str> , <str> : <str> , <str> : true , <str> : true delegate <str> , <str> : <str> , <str> : true , <str> : true delegate <str> , <str> : <str> , <str> : true , <str> : true delegate <str> , <str> : <str> , <str> : true , <str> : true belongs_to <str> , <str> : <str> belongs_to <str> belongs_to <str> , <str> : true serialize <str> after_create <str> scope <str> , - > { reorder ( id : <str> ) } scope <str> , - > { where ( <str> : PUSHED ) } scope <str> , - > ( projects ) do where ( <str> : projects . map ( & <str> ) ) . recent end scope <str> , - > { includes ( <str> : <str> ) } scope <str> , - > ( milestone_id ) { where ( <str> : <str> , <str> : milestone_id ) } class << self def reset_event_cache_for ( target ) Event . where ( <str> : target . id , <str> : target . class . to_s ) . order ( <str> ) . limit ( <int> ) . update_all ( <str> : Time . now ) end def contributions where ( <str> , Event :: PUSHED , [ <str> , <str> ] , [ Event :: CREATED , Event :: CLOSED , Event :: MERGED ] ) end def limit_recent ( limit = <int> , offset = nil ) recent . limit ( limit ) . offset ( offset ) end end def proper? if push? true elsif membership_changed? true elsif created_project? true else ( ( issue? || merge_request? || note? ) && target ) || milestone? end end def project_name if project project . name_with_namespace else <str> end end def target_title target . title if target && target . respond_to? ( <str> ) end def created? action == CREATED end def push? action == PUSHED && valid_push? end def merged? action == MERGED end def closed? action == CLOSED end def reopened? action == REOPENED end def joined? action == JOINED end def left? action == LEFT end def destroyed? action == DESTROYED end def commented? action == COMMENTED end def membership_changed? joined? || left? end def created_project? created? && ! target && target_type . nil? end def created_target? created? && target end def milestone? target_type == <str> end def note? target_type == <str> end def issue? target_type == <str> end def merge_request? target_type == <str> end def milestone target if milestone? end def issue target if issue? end def merge_request target if merge_request? end def note target if note? end def action_name if push? if new_ref? <str> elsif rm_ref? <str> else <str> end elsif closed? <str> elsif merged? <str> elsif joined? <str> elsif left? <str> elsif destroyed? <str> elsif commented? <str> elsif created_project? if project . external_import? <str> else <str> end else <str> end end def valid_push? data [ <str> ] && ref_name . present? rescue false end def tag? Gitlab :: Git . tag_ref? ( data [ <str> ] ) end def branch? Gitlab :: Git . branch_ref? ( data [ <str> ] ) end def new_ref? Gitlab :: Git . blank_ref? ( commit_from ) end def rm_ref? Gitlab :: Git . blank_ref? ( commit_to ) end def md_ref? ! ( rm_ref? || new_ref? ) end def commit_from data [ <str> ] end def commit_to data [ <str> ] end def ref_name if tag? tag_name else branch_name end end def branch_name @branch_name || = Gitlab :: Git . ref_name ( data [ <str> ] ) end def tag_name @tag_name || = Gitlab :: Git . ref_name ( data [ <str> ] ) end def commits @commits || = ( data [ <str> ] || [ ] ) . reverse end def commits_count data [ <str> ] || commits . count || <int> end def ref_type tag? ? <str> : <str> end def push_with_commits? ! commits . empty? && commit_from && commit_to end def last_push_to_non_root? branch? && project . default_branch != branch_name end def note_commit_id target . commit_id end def target_iid target . respond_to? ( <str> ) ? target . iid : target_id end def note_short_commit_id Commit . truncate_sha ( note_commit_id ) end def note_commit? target . noteable_type == <str> end def note_project_snippet? target . noteable_type == <str> end def note_target target . noteable end def note_target_id if note_commit? target . commit_id else target . noteable_id . to_s end end def note_target_iid if note_target . respond_to? ( <str> ) note_target . iid else note_target_id end . to_s end def note_target_type if target . noteable_type . present? target . noteable_type . titleize else <str> end . downcase end def body? if push? push_with_commits? elsif note? true else target . respond_to? <str> end end def reset_project_activity if project project . update_column ( <str> , self . created_at ) end end end 
