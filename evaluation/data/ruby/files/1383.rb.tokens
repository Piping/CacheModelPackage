module Msf class Plugin :: Wiki < Msf :: Plugin class WikiCommandDispatcher include Msf :: Ui :: Console :: CommandDispatcher def name <str> end def commands { <str> = > <str> , <str> = > <str> } end def cmd_dokuwiki ( * args ) wiki ( <str> , * args ) end def cmd_mediawiki ( * args ) wiki ( <str> , * args ) end def wiki ( wiki_type , * args ) tbl_opts = { } tbl_opts [ <str> ] = [ ] tbl_opts [ <str> ] = false tbl_opts [ <str> ] = wiki_type tbl_opts [ <str> ] = <int> case wiki_type when <str> tbl_opts [ <str> ] = <str> else tbl_opts [ <str> ] = <str> end command = args . shift if command . nil? or not ( [ <str> , <str> , <str> , <str> , <str> ] . include? ( command . downcase ) ) usage ( wiki_type ) return end while ( arg = args . shift ) case arg when <str> , <str> tbl_opts [ <str> ] = next_opt ( args ) when <str> , <str> usage ( wiki_type ) return when <str> , <str> , <str> , <str> tbl_opts [ <str> ] = true when <str> , <str> , <str> tbl_opts [ <str> ] = next_opt ( args ) when <str> , <str> , <str> , <str> tbl_opts [ <str> ] = next_opts ( args ) tbl_opts [ <str> ] . map! { | p | p . to_i } when <str> , <str> , <str> tbl_opts [ <str> ] = next_opt ( args ) when <str> , <str> , <str> heading_size = next_opt ( args ) tbl_opts [ <str> ] = heading_size . to_i unless heading_size . nil? else rw = Rex :: Socket :: RangeWalker . new ( arg ) if rw . valid? rw . each do | ip | tbl_opts [ <str> ] << ip end else print_warning <str> arg <str> end end end outputs = [ ] if respond_to? <str> command <str> , true table = send <str> command <str> , tbl_opts if table . respond_to? <str> wiki_type <str> , true if tbl_opts [ <str> ] print_status ( <str> command <str> wiki_type <str> ) File . open ( tbl_opts [ <str> ] , <str> ) { | f | f . write ( table . send <str> wiki_type <str> ) } else print_line table . send <str> wiki_type <str> end return end end usage ( wiki_type ) end def next_opts ( args ) opts = [ ] while ( opt = args . shift ) if opt =~ <str> args . unshift opt break end opts . concat ( opt . split ( <str> ) ) end return opts . uniq end def next_opt ( args ) return nil if args [ <int> ] =~ <str> args . shift end def usage ( cmd_name = <str> ) print_line <str> cmd_name <str> print_line print_line <str> print_line <str> print_line print_line <str> print_line <str> print_line <str> print_line <str> print_line <str> print_line <str> print_line <str> print_line <str> print_line end def creds_to_table ( opts = { } ) tbl = Rex :: Ui :: Text :: Table . new ( { <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] } ) tbl . header = <str> tbl . headeri = opts [ <str> ] framework . db . creds . each do | cred | unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . include? cred . service . host . address end unless opts [ <str> ] . nil? next unless opts [ <str> ] . any? { | p | cred . service . port . eql? p } end address = cred . service . host . address address = to_wikilink ( address , opts [ <str> ] ) if opts [ <str> ] row = [ address , cred . service . port , cred . user , cred . pass , cred . ptype , cred . proof , cred . active ] if opts [ <str> ] tbl << row if row . any? { | r | <str> opts [ <str> ] <str> . match r . to_s } else tbl << row end end return tbl end def hosts_to_table ( opts = { } ) tbl = Rex :: Ui :: Text :: Table . new ( { <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] } ) tbl . header = <str> tbl . headeri = opts [ <str> ] framework . db . hosts . each do | host | unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . include? host . address end unless opts [ <str> ] . nil? next unless ( host . services . map { | s | s [ <str> ] } ) . any? { | p | opts [ <str> ] . include? p } end address = host . address address = to_wikilink ( address , opts [ <str> ] ) if opts [ <str> ] row = [ address , host . mac , host . name , host . os_name , host . os_flavor , host . os_sp , host . purpose , host . info , host . comments ] if opts [ <str> ] tbl << row if row . any? { | r | <str> opts [ <str> ] <str> . match r . to_s } else tbl << row end end return tbl end def loot_to_table ( opts = { } ) tbl = Rex :: Ui :: Text :: Table . new ( { <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] } ) tbl . header = <str> tbl . headeri = opts [ <str> ] framework . db . loots . each do | loot | unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . include? loot . host . address end unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next if loot . service . nil? or loot . service . port . nil? or not opts [ <str> ] . include? loot . service . port end if loot . service svc = ( loot . service . name ? loot . service . name : <str> loot . service . port <str> loot . service . proto <str> ) end address = loot . host . address address = to_wikilink ( address , opts [ <str> ] ) if opts [ <str> ] row = [ address , svc || <str> , loot . ltype , loot . name , loot . content_type , loot . info , loot . path ] if opts [ <str> ] tbl << row if row . any? { | r | <str> opts [ <str> ] <str> . match r . to_s } else tbl << row end end return tbl end def services_to_table ( opts = { } ) tbl = Rex :: Ui :: Text :: Table . new ( { <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> ] } ) tbl . header = <str> tbl . headeri = opts [ <str> ] framework . db . services . each do | service | unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . include? service . host . address end unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . any? { | p | service [ <str> ] . eql? p } end address = service . host . address address = to_wikilink ( address , opts [ <str> ] ) if opts [ <str> ] row = [ address , service . port , service . proto , service . name , service . state , service . info ] if opts [ <str> ] tbl << row if row . any? { | r | <str> opts [ <str> ] <str> . match r . to_s } else tbl << row end end return tbl end def vulns_to_table ( opts = { } ) tbl = Rex :: Ui :: Text :: Table . new ( { <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] } ) tbl . header = <str> tbl . headeri = opts [ <str> ] framework . db . vulns . each do | vuln | unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . include? vuln . host . address end unless opts [ <str> ] . nil? or opts [ <str> ] . empty? next unless opts [ <str> ] . any? { | p | vuln . service . port . eql? p } end address = vuln . host . address address = to_wikilink ( address , opts [ <str> ] ) if opts [ <str> ] row = [ vuln . name , address , ( vuln . service ? vuln . service . port : <str> ) , vuln . info , vuln . vuln_detail_count , vuln . vuln_attempt_count , vuln . exploited_at , vuln . updated_at , ] if opts [ <str> ] tbl << row if row . any? { | r | <str> opts [ <str> ] <str> . match r . to_s } else tbl << row end end return tbl end def to_wikilink ( text , namespace = <str> ) return <str> + namespace + text + <str> end end def initialize ( framework , opts ) super add_dokuwiki_to_rex add_mediawiki_to_rex add_console_dispatcher ( WikiCommandDispatcher ) end def cleanup Rex :: Ui :: Text :: Table . class_eval { undef <str> } Rex :: Ui :: Text :: Table . class_eval { undef <str> } remove_console_dispatcher ( <str> ) end def name <str> end def desc <str> end def add_dokuwiki_to_rex Rex :: Ui :: Text :: Table . class_eval do def to_dokuwiki str = prefix . dup if header level = <str> * headeri str << level + header + level + <str> end columns . each do | col | str << <str> + col . to_s + <str> end str << <str> unless columns . count . eql? <int> rows . each do | row | row . each do | val | cell = val . to_s cell = <str> cell <str> if cell . include? <str> str << <str> + cell + <str> end str << <str> unless rows . count . eql? <int> end return str end end end def add_mediawiki_to_rex Rex :: Ui :: Text :: Table . class_eval do def to_mediawiki str = prefix . dup if header if headeri < = <int> level = <str> * ( - headeri + <int> ) str << <str> level <str> header <str> level <str> else str << <str> header <str> end str << <str> end str << <str> unless columns . count . eql? <int> str << <str> str << columns . join ( <str> ) str << <str> end unless rows . count . eql? <int> rows . each do | row | str << <str> bad = [ <str> , <str> , <str> , <str> , <str> , <str> ] r = row . join ( <str> ) r . each_char do | c | if bad . include? c str << Rex :: Text . html_encode ( c ) else str << c end end str << <str> end end str << <str> return str end end end protected end end 
