require <str> require <str> require <str> class Shell class ProcessController @ProcessControllers = { } @ProcessControllersMonitor = Mutex . new @ProcessControllersCV = ConditionVariable . new @BlockOutputMonitor = Mutex . new @BlockOutputCV = ConditionVariable . new class << self extend Forwardable def_delegator ( <str> , <str> , <str> ) def active_process_controllers process_controllers_exclusive do @ProcessControllers . dup end end def activate ( pc ) process_controllers_exclusive do @ProcessControllers [ pc ] || = <int> @ProcessControllers [ pc ] += <int> end end def inactivate ( pc ) process_controllers_exclusive do if @ProcessControllers [ pc ] if ( @ProcessControllers [ pc ] -= <int> ) == <int> @ProcessControllers . delete ( pc ) @ProcessControllersCV . signal end end end end def each_active_object process_controllers_exclusive do for ref in @ProcessControllers . keys yield ref end end end def block_output_synchronize ( & b ) @BlockOutputMonitor . synchronize ( & b ) end def wait_to_finish_all_process_controllers process_controllers_exclusive do while ! @ProcessControllers . empty? Shell :: notify ( <str> , <str> ) if Shell . debug? for pc in @ProcessControllers . keys Shell :: notify ( <str> + pc . shell . to_s ) for com in pc . jobs com . notify ( <str> ) end end end @ProcessControllersCV . wait ( @ProcessControllersMonitor ) end end end end USING_AT_EXIT_WHEN_PROCESS_EXIT = true at_exit do wait_to_finish_all_process_controllers unless $@ end def initialize ( shell ) @shell = shell @waiting_jobs = [ ] @active_jobs = [ ] @jobs_sync = Sync . new @job_monitor = Mutex . new @job_condition = ConditionVariable . new end attr_reader <str> def jobs jobs = [ ] @jobs_sync . synchronize ( <str> ) do jobs . concat @waiting_jobs jobs . concat @active_jobs end jobs end def active_jobs @active_jobs end def waiting_jobs @waiting_jobs end def jobs_exist? @jobs_sync . synchronize ( <str> ) do @active_jobs . empty? or @waiting_jobs . empty? end end def active_jobs_exist? @jobs_sync . synchronize ( <str> ) do @active_jobs . empty? end end def waiting_jobs_exist? @jobs_sync . synchronize ( <str> ) do @waiting_jobs . empty? end end def add_schedule ( command ) @jobs_sync . synchronize ( <str> ) do ProcessController . activate ( self ) if @active_jobs . empty? start_job command else @waiting_jobs . push ( command ) end end end def start_job ( command = nil ) @jobs_sync . synchronize ( <str> ) do if command return if command . active? @waiting_jobs . delete command else command = @waiting_jobs . shift return unless command end @active_jobs . push command command . start for job in @waiting_jobs . dup start_job ( job ) if job . input == command end end end def waiting_job? ( job ) @jobs_sync . synchronize ( <str> ) do @waiting_jobs . include? ( job ) end end def active_job? ( job ) @jobs_sync . synchronize ( <str> ) do @active_jobs . include? ( job ) end end def terminate_job ( command ) @jobs_sync . synchronize ( <str> ) do @active_jobs . delete command ProcessController . inactivate ( self ) if @active_jobs . empty? command . notify ( <str> , Shell :: debug? ) start_job end end end def kill_job ( sig , command ) @jobs_sync . synchronize ( <str> ) do if @waiting_jobs . delete command ProcessController . inactivate ( self ) return elsif @active_jobs . include? ( command ) begin r = command . kill ( sig ) ProcessController . inactivate ( self ) rescue print <str> if @shell . verbose? return nil end @active_jobs . delete command r end end end def wait_all_jobs_execution @job_monitor . synchronize do begin while ! jobs . empty? @job_condition . wait ( @job_monitor ) for job in jobs job . notify ( <str> , Shell :: debug? ) end end ensure redo unless jobs . empty? end end end def sfork ( command ) pipe_me_in , pipe_peer_out = IO . pipe pipe_peer_in , pipe_me_out = IO . pipe pid = nil pid_mutex = Mutex . new pid_cv = ConditionVariable . new Thread . start do ProcessController . block_output_synchronize do STDOUT . flush ProcessController . each_active_object do | pc | for jobs in pc . active_jobs jobs . flush end end pid = fork { Thread . list . each do | th | th . kill unless Thread . current == th end STDIN . reopen ( pipe_peer_in ) STDOUT . reopen ( pipe_peer_out ) ObjectSpace . each_object ( IO ) do | io | if ! [ STDIN , STDOUT , STDERR ] . include? ( io ) io . close unless io . closed? end end yield } end pid_cv . signal pipe_peer_in . close pipe_peer_out . close command . notify <str> pid <str> , @shell . debug? begin _pid = nil command . notify ( <str> , @shell . debug? ) _pid = Process . waitpid ( pid , nil ) rescue Errno :: ECHILD command . notify <str> _pid = true ensure command . notify ( <str> , @shell . debug? ) if USING_AT_EXIT_WHEN_PROCESS_EXIT or _pid else command . notify ( <str> , <str> , <str> ) redo end @job_monitor . synchronize do terminate_job ( command ) @job_condition . signal command . notify <str> , @shell . debug? end end end pid_mutex . synchronize do while ! pid pid_cv . wait ( pid_mutex ) end end return pid , pipe_me_in , pipe_me_out end end end 
