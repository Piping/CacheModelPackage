require <str> require <str> require <str> require <str> module Rex::Socket::SslTcpServer @@loaded_openssl = false begin require <str> @@loaded_openssl = true require <str> rescue :: Exception end include Rex :: Socket :: TcpServer def self . create ( hash = { } ) hash [ <str> ] = <str> hash [ <str> ] = true hash [ <str> ] = true self . create_param ( Rex :: Socket :: Parameters . from_hash ( hash ) ) end def self . create_param ( param ) param . proto = <str> param . server = true param . ssl = true Rex :: Socket . create_param ( param ) end def initsock ( params = nil ) raise RuntimeError , <str> unless @@loaded_openssl if params && params . sslctx && params . sslctx . kind_of? ( OpenSSL :: SSL :: SSLContext ) self . sslctx = params . sslctx else self . sslctx = makessl ( params ) end super end def accept ( opts = { } ) sock = super ( ) return if not sock begin ssl = OpenSSL :: SSL :: SSLSocket . new ( sock , self . sslctx ) if not allow_nonblock? ( ssl ) ssl . accept else begin ssl . accept_nonblock rescue :: Errno :: EAGAIN , :: Errno :: EWOULDBLOCK IO :: select ( nil , nil , nil , <int> . <int> ) retry rescue :: Exception = > e if :: IO . const_defined? ( <str> ) and e . kind_of? ( :: IO :: WaitReadable ) IO :: select ( [ ssl ] , nil , nil , <int> . <int> ) retry end if :: IO . const_defined? ( <str> ) and e . kind_of? ( :: IO :: WaitWritable ) IO :: select ( nil , [ ssl ] , nil , <int> . <int> ) retry end raise e end end sock . extend ( Rex :: Socket :: SslTcp ) sock . sslsock = ssl sock . sslctx = self . sslctx return sock rescue :: OpenSSL :: SSL :: SSLError sock . close nil end end def self . ssl_parse_pem ( ssl_cert ) Rex :: Parser :: X509Certificate . parse_pem ( ssl_cert ) end def ssl_parse_pem ( ssl_cert ) Rex :: Socket :: SslTcpServer . ssl_parse_pem ( ssl_cert ) end def self . ssl_generate_certificate yr = <int> * <int> * <int> vf = Time . at ( Time . now . to_i - rand ( yr * <int> ) - yr ) vt = Time . at ( vf . to_i + ( <int> * yr ) ) cn = Rex :: Text . rand_text_alpha_lower ( rand ( <int> ) + <int> ) key = OpenSSL :: PKey :: RSA . new ( <int> ) { } cert = OpenSSL :: X509 :: Certificate . new cert . version = <int> cert . serial = ( rand ( <hex> ) << <int> ) + rand ( <hex> ) cert . subject = OpenSSL :: X509 :: Name . new ( [ [ <str> , cn ] ] ) cert . issuer = OpenSSL :: X509 :: Name . new ( [ [ <str> , cn ] ] ) cert . not_before = vf cert . not_after = vt cert . public_key = key . public_key ef = OpenSSL :: X509 :: ExtensionFactory . new ( nil , cert ) cert . extensions = [ ef . create_extension ( <str> , <str> ) ] ef . issuer_certificate = cert cert . sign ( key , OpenSSL :: Digest :: SHA256 . new ) [ key , cert , nil ] end def ssl_generate_certificate Rex :: Socket :: SslTcpServer . ssl_generate_certificate end def makessl ( params ) if params . ssl_cert key , cert , chain = ssl_parse_pem ( params . ssl_cert ) else key , cert , chain = ssl_generate_certificate end ctx = OpenSSL :: SSL :: SSLContext . new ( ) ctx . key = key ctx . cert = cert ctx . extra_chain_cert = chain ctx . options = <int> if defined? ( OpenSSL :: SSL :: OP_NO_COMPRESSION ) if params . ssl_compression ctx . options & = ~ OpenSSL :: SSL :: OP_NO_COMPRESSION else ctx . options |= OpenSSL :: SSL :: OP_NO_COMPRESSION end end ctx . session_id_context = Rex :: Text . rand_text ( <int> ) return ctx end def allow_nonblock? ( sock = self . sock ) avail = sock . respond_to? ( <str> ) if avail and Rex :: Compat . is_windows return true end false end attr_accessor <str> end 
