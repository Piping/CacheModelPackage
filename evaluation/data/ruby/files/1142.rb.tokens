module Rex module Ui module Interactive include Rex :: Ui :: Subscriber def interact ( user_input , user_output ) if ( self . interacting ) detach ( ) end init_ui ( user_input , user_output ) self . interacting = true self . completed = false eof = false handle_suspend while ( self . interacting == true ) begin _interact rescue Interrupt eof = true if ( _interrupt ) rescue EOFError , Errno :: ECONNRESET , IOError eof = true end break if eof end begin restore_suspend _interact_complete if ( eof == true ) reset_ui ( ) ensure self . completed = true end return eof end def detach if ( self . interacting ) self . interacting = false while ( not self . completed ) :: IO . select ( nil , nil , nil , <int> . <int> ) end end end attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> protected attr_accessor <str> def _interact end def _interrupt true end def _suspend false end def _interact_complete true end def _stream_read_remote_write_local ( stream ) data = stream . get self . on_print_proc . call ( data ) if self . on_print_proc user_output . print ( data ) end def _stream_read_local_write_remote ( stream ) data = user_input . gets self . on_command_proc . call ( data ) if self . on_command_proc stream . put ( data ) end def _local_fd user_input . fd end def _remote_fd ( stream ) stream . fd end def interact_stream ( stream ) while self . interacting sd = Rex :: ThreadSafe . select ( [ _local_fd , _remote_fd ( stream ) ] , nil , nil , <int> . <int> ) sd [ <int> ] . each { | s | if ( s == _remote_fd ( stream ) ) _stream_read_remote_write_local ( stream ) elsif ( s == _local_fd ) _stream_read_local_write_remote ( stream ) end } if ( sd ) Thread . pass end end def interact_ring ( ring ) begin rdr = Rex :: ThreadFactory . spawn ( <str> , false ) do seq = nil while self . interacting nseq , data = ring . read_data ( seq ) seq = nseq || seq user_output . print ( data ) if data ring . wait ( seq ) end end while self . interacting sd = Rex :: ThreadSafe . select ( [ _local_fd ] , nil , [ _local_fd ] , <int> . <int> ) if sd data = user_input . gets ring . put ( data ) end end ensure rdr . kill end end def handle_suspend if ( orig_suspend == nil ) begin self . orig_suspend = Signal . trap ( <str> ) { _suspend } rescue end end end def restore_suspend begin if ( orig_suspend ) Signal . trap ( <str> , orig_suspend ) else Signal . trap ( <str> , <str> ) end self . orig_suspend = nil rescue end end def prompt ( query ) if ( user_output and user_input ) user_output . print ( <str> + query ) user_input . sysread ( <int> ) end end def prompt_yesno ( query ) ( prompt ( query + <str> ) =~ <str> ) ? true : false end end end end 
