require <str> class Option attr_reader <str> , <str> , <str> def initialize ( name , description = <str> ) @name = name @flag = <str> name <str> @description = description end def to_s flag end def <=> ( other ) return unless Option === other name < = > other . name end def == ( other ) instance_of? ( other . class ) && name == other . name end alias_method <str> , <str> def hash name . hash end def inspect <str> self . class . name <str> flag . inspect <str> end end class DeprecatedOption attr_reader <str> , <str> def initialize ( old , current ) @old = old @current = current end def old_flag <str> old <str> end def current_flag <str> current <str> end def == ( other ) instance_of? ( other . class ) && old == other . old && current == other . current end alias_method <str> , <str> end class Options include Enumerable def self . create ( array ) new array . map { | e | Option . new ( e [ <str> , <int> ] || e ) } end def initialize ( * args ) @options = Set . new ( * args ) end def each ( * args , & block ) @options . each ( * args , & block ) end def << ( o ) @options << o self end def + ( o ) self . class . new ( @options + o ) end def - ( o ) self . class . new ( @options - o ) end def & ( o ) self . class . new ( @options & o ) end def | ( o ) self . class . new ( @options | o ) end def * ( arg ) @options . to_a * arg end def empty? @options . empty? end def as_flags map ( & <str> ) end def include? ( o ) any? { | opt | opt == o || opt . name == o || opt . flag == o } end alias_method <str> , <str> def inspect <str> self . class . name <str> to_a . inspect <str> end end module Homebrew def dump_options_for_formula ( f ) f . options . sort_by ( & <str> ) . each do | opt | puts <str> opt . flag <str> opt . description <str> end puts <str> f . devel . version <str> if f . devel puts <str> if f . head end end 
