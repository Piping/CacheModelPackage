class GetoptLong ORDERINGS = [ REQUIRE_ORDER = <int> , PERMUTE = <int> , RETURN_IN_ORDER = <int> ] ARGUMENT_FLAGS = [ NO_ARGUMENT = <int> , REQUIRED_ARGUMENT = <int> , OPTIONAL_ARGUMENT = <int> ] STATUS_YET , STATUS_STARTED , STATUS_TERMINATED = <int> , <int> , <int> class Error < StandardError ; end class AmbiguousOption < Error ; end class NeedlessArgument < Error ; end class MissingArgument < Error ; end class InvalidOption < Error ; end def initialize ( * arguments ) if ENV . include? ( <str> ) @ordering = REQUIRE_ORDER else @ordering = PERMUTE end @canonical_names = Hash . new @argument_flags = Hash . new @quiet = FALSE @status = STATUS_YET @error = nil @error_message = nil @rest_singles = <str> @non_option_arguments = Array . new if <int> < arguments . length set_options ( * arguments ) end end def ordering = ( ordering ) if @status != STATUS_YET set_error ( ArgumentError , <str> ) raise RuntimeError , <str> end if ! ORDERINGS . include? ( ordering ) raise ArgumentError , <str> ordering <str> end if ordering == PERMUTE && ENV . include? ( <str> ) @ordering = REQUIRE_ORDER else @ordering = ordering end end attr_reader <str> def set_options ( * arguments ) if @status != STATUS_YET raise RuntimeError , <str> end @canonical_names . clear @argument_flags . clear arguments . each do | arg | if ! arg . is_a? ( Array ) raise ArgumentError , <str> end argument_flag = nil arg . each do | i | if ARGUMENT_FLAGS . include? ( i ) if argument_flag != nil raise ArgumentError , <str> end argument_flag = i end end raise ArgumentError , <str> if argument_flag == nil canonical_name = nil arg . each do | i | next if i == argument_flag begin if ! i . is_a? ( String ) || i !~ <str> raise ArgumentError , <str> i <str> end if ( @canonical_names . include? ( i ) ) raise ArgumentError , <str> i <str> end rescue @canonical_names . clear @argument_flags . clear raise end if canonical_name == nil canonical_name = i end @canonical_names [ i ] = canonical_name @argument_flags [ i ] = argument_flag end raise ArgumentError , <str> if canonical_name == nil end return self end attr_writer <str> attr_reader <str> alias quiet? quiet def terminate return nil if @status == STATUS_TERMINATED raise RuntimeError , <str> if @error != nil @status = STATUS_TERMINATED @non_option_arguments . reverse_each do | argument | ARGV . unshift ( argument ) end @canonical_names = nil @argument_flags = nil @rest_singles = nil @non_option_arguments = nil return self end def terminated? return @status == STATUS_TERMINATED end def set_error ( type , message ) $stderr . print ( <str> $0 <str> message <str> ) if ! @quiet @error = type @error_message = message @canonical_names = nil @argument_flags = nil @rest_singles = nil @non_option_arguments = nil raise type , message end protected <str> attr_reader <str> alias error? error def error_message return @error_message end def get option_name , option_argument = nil , <str> return nil if @error != nil case @status when STATUS_YET @status = STATUS_STARTED when STATUS_TERMINATED return nil end if <int> < @rest_singles . length argument = <str> + @rest_singles elsif ( ARGV . length == <int> ) terminate return nil elsif @ordering == PERMUTE while <int> < ARGV . length && ARGV [ <int> ] !~ <str> @non_option_arguments . push ( ARGV . shift ) end if ARGV . length == <int> terminate return nil end argument = ARGV . shift elsif @ordering == REQUIRE_ORDER if ( ARGV [ <int> ] !~ <str> ) terminate return nil end argument = ARGV . shift else argument = ARGV . shift end if argument == <str> && @rest_singles . length == <int> terminate return nil end if argument =~ <str> && @rest_singles . length == <int> pattern = $1 if @canonical_names . include? ( pattern ) option_name = pattern else matches = [ ] @canonical_names . each_key do | key | if key . index ( pattern ) == <int> option_name = key matches << key end end if <int> < = matches . length set_error ( AmbiguousOption , <str> argument <str> matches . join ( <str> ) <str> ) elsif matches . length == <int> set_error ( InvalidOption , <str> argument <str> ) end end if @argument_flags [ option_name ] == REQUIRED_ARGUMENT if argument =~ <str> option_argument = $1 elsif <int> < ARGV . length option_argument = ARGV . shift else set_error ( MissingArgument , <str> argument <str> ) end elsif @argument_flags [ option_name ] == OPTIONAL_ARGUMENT if argument =~ <str> option_argument = $1 elsif <int> < ARGV . length && ARGV [ <int> ] !~ <str> option_argument = ARGV . shift else option_argument = <str> end elsif argument =~ <str> set_error ( NeedlessArgument , <str> option_name <str> ) end elsif argument =~ <str> option_name , ch , @rest_singles = $1 , $2 , $3 if @canonical_names . include? ( option_name ) if @argument_flags [ option_name ] == REQUIRED_ARGUMENT if <int> < @rest_singles . length option_argument = @rest_singles @rest_singles = <str> elsif <int> < ARGV . length option_argument = ARGV . shift else set_error ( MissingArgument , <str> ch <str> ) end elsif @argument_flags [ option_name ] == OPTIONAL_ARGUMENT if <int> < @rest_singles . length option_argument = @rest_singles @rest_singles = <str> elsif <int> < ARGV . length && ARGV [ <int> ] !~ <str> option_argument = ARGV . shift else option_argument = <str> end end else if ENV . include? ( <str> ) set_error ( InvalidOption , <str> ch <str> ) else set_error ( InvalidOption , <str> ch <str> ) end end else return <str> , argument end return @canonical_names [ option_name ] , option_argument end alias get_option get def each loop do option_name , option_argument = get_option break if option_name == nil yield option_name , option_argument end end alias each_option each end 
