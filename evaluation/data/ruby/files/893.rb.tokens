require <str> TkMessage . new ( <str> = > << <str> EOM <str> ) . pack <str> EOM if ENV [ <str> ] =~ <str> ent = TkOptionDB . read_entries ( File . expand_path ( <str> , File . dirname ( __FILE__ ) ) , <str> ) else ent = TkOptionDB . read_entries ( File . expand_path ( <str> , File . dirname ( __FILE__ ) ) ) end file = File . expand_path ( <str> , File . dirname ( __FILE__ ) ) ip = MultiTkIp . new_safeTk { ent . each { | pat , val | Tk . tk_call ( <str> , <str> , pat , val ) } } print <str> , ip . eval_proc { $SAFE } , <str> print <str> print <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ip . wait_on_mainloop = false ret = ip . eval_proc { load file } print <str> , ret . inspect , <str> print <str> , ip . eval_proc ( proc { $SAFE } ) , <str> safe0_cmd = Proc . new { print <str> , $SAFE , <str> load file } ip . eval_proc { safe0_cmd . call } Tk . mainloop 
