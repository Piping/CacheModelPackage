require <str> class Gem :: Package :: TarWriter class FileOverflow < StandardError ; end class BoundedStream attr_reader <str> attr_reader <str> def initialize ( io , limit ) @io = io @limit = limit @written = <int> end def write ( data ) if data . bytesize + @written > @limit raise FileOverflow , <str> end @io . write data @written += data . bytesize data . bytesize end end class RestrictedStream def initialize ( io ) @io = io end def write ( data ) @io . write data end end def self . new ( io ) writer = super return writer unless block_given? begin yield writer ensure writer . close end nil end def initialize ( io ) @io = io @closed = false end def add_file ( name , mode ) check_closed raise Gem :: Package :: NonSeekableIO unless @io . respond_to? <str> = name , prefix = split_name name init_pos = @io . pos @io . write <str> * <int> yield RestrictedStream . new ( @io ) if block_given? size = @io . pos - init_pos - <int> remainder = ( <int> - ( size % <int> ) ) % <int> @io . write <str> * remainder final_pos = @io . pos @io . pos = init_pos header = Gem :: Package :: TarHeader . new <str> = > name , <str> = > mode , <str> = > size , <str> = > prefix , <str> = > Time . now @io . write header @io . pos = final_pos self end def add_file_digest name , mode , digest_algorithms digests = digest_algorithms . map do | digest_algorithm | digest = digest_algorithm . new digest_name = if digest . respond_to? <str> then digest . name else <str> =~ digest_algorithm . name $1 end [ digest_name , digest ] end digests = Hash [ * digests . flatten ] add_file name , mode do | io | Gem :: Package :: DigestIO . wrap io , digests do | digest_io | yield digest_io end end digests end def add_file_signed name , mode , signer digest_algorithms = [ signer . digest_algorithm , Digest :: SHA512 , ] . compact . uniq digests = add_file_digest name , mode , digest_algorithms do | io | yield io end signature_digest = digests . values . compact . find do | digest | digest_name = if digest . respond_to? <str> then digest . name else <str> =~ digest . class . name $1 end digest_name == signer . digest_name end if signer . key then signature = signer . sign signature_digest . digest add_file_simple <str> name <str> , <oct> , signature . length do | io | io . write signature end end digests end def add_file_simple ( name , mode , size ) check_closed name , prefix = split_name name header = Gem :: Package :: TarHeader . new ( <str> = > name , <str> = > mode , <str> = > size , <str> = > prefix , <str> = > Time . now ) . to_s @io . write header os = BoundedStream . new @io , size yield os if block_given? min_padding = size - os . written @io . write ( <str> * min_padding ) remainder = ( <int> - ( size % <int> ) ) % <int> @io . write ( <str> * remainder ) self end def add_symlink ( name , target , mode ) check_closed name , prefix = split_name name header = Gem :: Package :: TarHeader . new ( <str> = > name , <str> = > mode , <str> = > <int> , <str> = > <str> , <str> = > target , <str> = > prefix , <str> = > Time . now ) . to_s @io . write header self end def check_closed raise IOError , <str> self . class <str> if closed? end def close check_closed @io . write <str> * <int> flush @closed = true end def closed? @closed end def flush check_closed @io . flush if @io . respond_to? <str> end def mkdir ( name , mode ) check_closed name , prefix = split_name ( name ) header = Gem :: Package :: TarHeader . new <str> = > name , <str> = > mode , <str> = > <str> , <str> = > <int> , <str> = > prefix , <str> = > Time . now @io . write header self end def split_name ( name ) if name . bytesize > <int> raise Gem :: Package :: TooLongFileName . new ( <str> name <str> ) end if name . bytesize < = <int> then prefix = <str> else parts = name . split ( <str> ) newname = parts . pop nxt = <str> loop do nxt = parts . pop break if newname . bytesize + <int> + nxt . bytesize > <int> newname = nxt + <str> + newname end prefix = ( parts + [ nxt ] ) . join <str> name = newname if name . bytesize > <int> raise Gem :: Package :: TooLongFileName . new ( <str> prefix <str> name <str> ) end if prefix . bytesize > <int> then raise Gem :: Package :: TooLongFileName . new ( <str> prefix <str> name <str> ) end end return name , prefix end end 
