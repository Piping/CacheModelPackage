class File < IO include Enumerable class FileError < Exception ; end class NoFileError < FileError ; end class UnableToStat < FileError ; end class PermissionError < FileError ; end attr_reader <str> def clamp_short ( value ) mode = Rubinius :: Type . coerce_to value , Integer , <str> mode < <int> || mode > <hex> ? <int> : mode end module_function <str> def self . absolute_path ( obj , dir = nil ) obj = path ( obj ) if obj [ <int> ] == <str> File . join Dir . getwd , dir . to_s , obj else expand_path ( obj , dir ) end end def self . atime ( path ) Stat . new ( path ) . atime end def self . ctime ( path ) Stat . new ( path ) . ctime end def self . birthtime ( path ) Stat . new ( path ) . birthtime end def self . mtime ( path ) Stat . new ( path ) . mtime end def self . utime ( a_in , m_in , * paths ) a_in || = Time . now a_in_usec = if a_in . is_a? ( Time ) || a_in . is_a? ( Float ) || a_in . is_a? ( Rational ) Time . at ( a_in ) . usec else <int> end m_in || = Time . now m_in_usec = if m_in . is_a? ( Time ) || m_in . is_a? ( Float ) || m_in . is_a? ( Rational ) Time . at ( m_in ) . usec else <int> end FFI :: MemoryPointer . new ( POSIX :: TimeVal , <int> ) do | ptr | atime = POSIX :: TimeVal . new ptr mtime = POSIX :: TimeVal . new ptr [ <int> ] atime [ <str> ] = a_in . to_i atime [ <str> ] = a_in_usec mtime [ <str> ] = m_in . to_i mtime [ <str> ] = m_in_usec paths . each do | path | n = POSIX . utimes ( Rubinius :: Type . coerce_to_path ( path ) , ptr ) Errno . handle unless n == <int> end end end def self . basename ( path , ext = undefined ) path = Rubinius :: Type . coerce_to_path ( path ) slash = <str> ext_not_present = undefined . equal? ( ext ) if pos = path . find_string_reverse ( slash , path . bytesize ) if pos == path . bytesize - <int> data = path . data found = false pos . downto ( <int> ) do | i | if data [ i ] != <int> path = path . byteslice ( <int> , i + <int> ) found = true break end end return slash unless found pos = path . find_string_reverse ( slash , path . bytesize ) if ext_not_present and ! pos return path end end path = path . byteslice ( pos + <int> , path . bytesize - pos ) if pos end return path if ext_not_present ext = StringValue ( ext ) if ext == <str> if pos = path . find_string_reverse ( <str> , path . bytesize ) return path . byteslice ( <int> , pos ) end elsif pos = path . find_string_reverse ( ext , path . bytesize ) if pos == path . bytesize - ext . size return path . byteslice ( <int> , pos ) end end return path end def self . blockdev? ( path ) st = Stat . stat path st ? st . blockdev? : false end def self . chardev? ( path ) st = Stat . stat path st ? st . chardev? : false end def self . chmod ( mode , * paths ) mode = clamp_short mode paths . each do | path | n = POSIX . chmod Rubinius :: Type . coerce_to_path ( path ) , mode Errno . handle if n == - <int> end paths . size end def self . lchmod ( mode , * paths ) raise NotImplementedError , <str> unless Rubinius :: HAVE_LCHMOD mode = Rubinius :: Type . coerce_to ( mode , Integer , <str> ) paths . each do | path | n = POSIX . lchmod Rubinius :: Type . coerce_to_path ( path ) , mode Errno . handle if n == - <int> end paths . size end def self . chown ( owner , group , * paths ) if owner owner = Rubinius :: Type . coerce_to ( owner , Integer , <str> ) else owner = - <int> end if group group = Rubinius :: Type . coerce_to ( group , Integer , <str> ) else group = - <int> end paths . each do | path | n = POSIX . chown Rubinius :: Type . coerce_to_path ( path ) , owner , group Errno . handle if n == - <int> end paths . size end def chmod ( mode ) mode = Rubinius :: Type . coerce_to ( mode , Integer , <str> ) n = POSIX . fchmod @descriptor , clamp_short ( mode ) Errno . handle if n == - <int> n end def chown ( owner , group ) if owner owner = Rubinius :: Type . coerce_to ( owner , Integer , <str> ) else owner = - <int> end if group group = Rubinius :: Type . coerce_to ( group , Integer , <str> ) else group = - <int> end n = POSIX . fchown @descriptor , owner , group Errno . handle if n == - <int> n end def self . lchown ( owner , group , * paths ) raise NotImplementedError , <str> unless Rubinius :: HAVE_LCHOWN if owner owner = Rubinius :: Type . coerce_to ( owner , Integer , <str> ) else owner = - <int> end if group group = Rubinius :: Type . coerce_to ( group , Integer , <str> ) else group = - <int> end paths . each do | path | n = POSIX . lchown Rubinius :: Type . coerce_to_path ( path ) , owner , group Errno . handle if n == - <int> end paths . size end def self . directory? ( io_or_path ) io = Rubinius :: Type . try_convert io_or_path , IO , <str> if io . is_a? IO Stat . fstat ( io . fileno ) . directory? else st = Stat . stat io_or_path st ? st . directory? : false end end def self . last_nonslash ( path , start = nil ) data = path . data idx = nil start || = ( path . size - <int> ) start . downto ( <int> ) do | i | if data [ i ] != <int> return i end end return nil end def self . dirname ( path ) path = Rubinius :: Type . coerce_to_path ( path ) return <str> if path . empty? slash = <str> chunk_size = last_nonslash ( path ) return <str> unless chunk_size if pos = path . find_string_reverse ( slash , chunk_size ) return <str> if pos == <int> path = path . byteslice ( <int> , pos ) return <str> if path == <str> return path unless path . suffix? slash idx = last_nonslash ( path , pos ) return <str> unless idx return path . byteslice ( <int> , idx - <int> ) end return <str> end def self . executable? ( path ) st = Stat . stat path st ? st . executable? : false end def self . executable_real? ( path ) st = Stat . stat path st ? st . executable_real? : false end def self . exist? ( path ) st = Stat . stat ( path ) st ? true : false end PrivateDir = :: Dir def self . expand_path ( path , dir = nil ) path = Rubinius :: Type . coerce_to_path ( path ) str = <str> . force_encoding path . encoding first = path [ <int> ] if first == <str> case path [ <int> ] when <str> unless home = ENV [ <str> ] raise ArgumentError , <str> end path = ENV [ <str> ] + path . byteslice ( <int> , path . bytesize - <int> ) when nil unless home = ENV [ <str> ] raise ArgumentError , <str> end if home . empty? raise ArgumentError , <str> end return home . dup else unless length = path . find_string ( <str> , <int> ) length = path . bytesize end name = path . byteslice <int> , length - <int> unless dir = Rubinius . get_user_home ( name ) raise ArgumentError , <str> name <str> end path = dir + path . byteslice ( length , path . bytesize - length ) end elsif first != <str> if dir dir = expand_path dir else dir = PrivateDir . pwd end path = <str> dir <str> path <str> end items = [ ] start = <int> size = path . bytesize while index = path . find_string ( <str> , start ) or ( start < size and index = size ) length = index - start if length > <int> item = path . byteslice start , length if item == <str> items . pop elsif item != <str> items << item end end start = index + <int> end if items . empty? str << <str> else items . each { | x | str . append <str> x <str> } end str end def self . extname ( path ) path = Rubinius :: Type . coerce_to_path ( path ) path_size = path . bytesize dot_idx = path . find_string_reverse ( <str> , path_size ) return <str> unless dot_idx slash_idx = path . find_string_reverse ( <str> , path_size ) slash_idx || = - <int> return <str> if dot_idx < slash_idx return <str> if dot_idx == slash_idx + <int> return <str> if dot_idx == path_size - <int> return path . byteslice ( dot_idx , path_size - dot_idx ) end def self . file? ( path ) st = Stat . stat path st ? st . file? : false end def self . braces ( pattern , flags = <int> , patterns = [ ] ) escape = ( flags & FNM_NOESCAPE ) == <int> rbrace = nil lbrace = nil i = pattern . index ( <str> ) if i nest = <int> while i < pattern . size char = pattern [ i ] if char == <str> lbrace = i if nest == <int> nest += <int> end if char == <str> nest -= <int> end if nest == <int> rbrace = i break end if char == <str> and escape i += <int> end i += <int> end end if lbrace and rbrace pos = lbrace front = pattern [ <int> ... lbrace ] back = pattern [ ( rbrace + <int> ) .. - <int> ] while pos < rbrace nest = <int> pos += <int> last = pos while pos < rbrace and not ( pattern [ pos ] == <str> and nest == <int> ) nest += <int> if pattern [ pos ] == <str> nest -= <int> if pattern [ pos ] == <str> if pattern [ pos ] == <str> and escape pos += <int> break if pos == rbrace end pos += <int> end brace_pattern = <str> front <str> pattern [ last ... pos ] <str> back <str> patterns << brace_pattern braces ( brace_pattern , flags , patterns ) end end patterns end def self . fnmatch ( pattern , path , flags = <int> ) pattern = StringValue ( pattern ) path = Rubinius :: Type . coerce_to_path ( path ) flags = Rubinius :: Type . coerce_to ( flags , Fixnum , <str> ) brace_match = false if ( flags & FNM_EXTGLOB ) != <int> brace_match = braces ( pattern , flags ) . any? { | p | super ( p , path , flags ) } end brace_match || super ( pattern , path , flags ) end def self . ftype ( path ) lstat ( path ) . ftype end def self . grpowned? ( path ) begin lstat ( path ) . grpowned? rescue false end end def self . identical? ( orig , copy ) orig = Rubinius :: Type . coerce_to_path ( orig ) st_o = File :: Stat . stat ( orig ) copy = Rubinius :: Type . coerce_to_path ( copy ) st_c = File :: Stat . stat ( copy ) return false if st_o . nil? || st_c . nil? return false unless st_o . dev == st_c . dev return false unless st_o . ino == st_c . ino return false unless st_o . ftype == st_c . ftype return false unless POSIX . access ( orig , Constants :: R_OK ) return false unless POSIX . access ( copy , Constants :: R_OK ) true end def self . join ( * args ) return <str> if args . empty? sep = SEPARATOR first = args . shift case first when String first = first . dup when Array recursion = Thread . detect_recursion ( first ) do first = join ( * first ) end raise ArgumentError , <str> if recursion else first = Rubinius :: Type . coerce_to_path ( first ) . dup end ret = first args . each do | el | value = nil case el when String value = el when Array recursion = Thread . detect_recursion ( el ) do value = join ( * el ) end raise ArgumentError , <str> if recursion else value = Rubinius :: Type . coerce_to_path ( el ) end if value . prefix? sep ret . gsub! ( <str> SEPARATOR <str> , <str> ) elsif not ret . suffix? sep ret << sep end ret << value end ret end def self . link ( from , to ) n = POSIX . link Rubinius :: Type . coerce_to_path ( from ) , Rubinius :: Type . coerce_to_path ( to ) Errno . handle if n == - <int> n end def self . lstat ( path ) Stat . lstat path end def self . path ( obj ) return obj . to_path if obj . respond_to? <str> StringValue ( obj ) end def self . pipe? ( path ) st = Stat . stat path st ? st . pipe? : false end def self . readable? ( path ) st = Stat . stat path st ? st . readable? : false end def self . readable_real? ( path ) st = Stat . stat path st ? st . readable_real? : false end def self . readlink ( path ) FFI :: MemoryPointer . new ( <int> ) do | ptr | n = POSIX . readlink Rubinius :: Type . coerce_to_path ( path ) , ptr , <int> Errno . handle if n == - <int> return ptr . read_string ( n ) end end def self . realpath ( path , basedir = nil ) real = basic_realpath path , basedir unless exist? real raise Errno :: ENOENT , real end real end def self . realdirpath ( path , basedir = nil ) real = basic_realpath path , basedir dir = dirname real unless directory? dir raise Errno :: ENOENT , real end real end def self . basic_realpath ( path , basedir = nil ) path = expand_path ( path , basedir || Dir . pwd ) real = <str> symlinks = { } while ! path . empty? pos = path . index ( SEPARATOR , <int> ) if pos name = path [ <int> ... pos ] path = path [ pos .. - <int> ] else name = path path = <str> end real = join ( real , name ) if symlink? ( real ) raise Errno :: ELOOP if symlinks [ real ] symlinks [ real ] = true if path . empty? path = expand_path ( readlink ( real ) , dirname ( real ) ) else path = expand_path ( join ( readlink ( real ) , path ) , dirname ( real ) ) end real = <str> end end real end class << self private <str> end def self . rename ( from , to ) n = POSIX . rename Rubinius :: Type . coerce_to_path ( from ) , Rubinius :: Type . coerce_to_path ( to ) Errno . handle if n == - <int> n end def self . size ( io_or_path ) io = Rubinius :: Type . try_convert io_or_path , IO , <str> if io . is_a? IO Stat . fstat ( io . fileno ) . size else stat ( io_or_path ) . size end end def self . size? ( io_or_path ) s = <int> io = Rubinius :: Type . try_convert io_or_path , IO , <str> if io . is_a? IO s = Stat . fstat ( io . fileno ) . size else st = Stat . stat io_or_path s = st . size if st end s > <int> ? s : nil end def self . socket? ( path ) st = Stat . stat path st ? st . socket? : false end def self . split ( path ) p = Rubinius :: Type . coerce_to_path ( path ) [ dirname ( p ) , basename ( p ) ] end def self . stat ( path ) Stat . new path end def self . symlink ( from , to ) n = POSIX . symlink Rubinius :: Type . coerce_to_path ( from ) , Rubinius :: Type . coerce_to_path ( to ) Errno . handle if n == - <int> n end def self . symlink? ( path ) Stat . lstat ( path ) . symlink? rescue Errno :: ENOENT , Errno :: ENODIR false end def self . syscopy ( from , to ) out = directory? ( to ) ? to + basename ( from ) : to open ( out , <str> ) do | f | f . write read ( from ) . read end end def self . truncate ( path , length ) path = Rubinius :: Type . coerce_to_path ( path ) unless exist? ( path ) raise Errno :: ENOENT , path end length = Rubinius :: Type . coerce_to length , Integer , <str> prim_truncate ( path , length ) end def self . umask ( mask = nil ) if mask POSIX . umask clamp_short ( mask ) else old_mask = POSIX . umask ( <int> ) POSIX . umask old_mask old_mask end end def self . unlink ( * paths ) paths . each do | path | n = POSIX . unlink Rubinius :: Type . coerce_to_path ( path ) Errno . handle if n == - <int> end paths . size end def self . world_readable? ( path ) path = Rubinius :: Type . coerce_to_path path return nil unless exist? path mode = Stat . new ( path ) . mode if ( mode & Stat :: S_IROTH ) == Stat :: S_IROTH tmp = mode & ( Stat :: S_IRUGO | Stat :: S_IWUGO | Stat :: S_IXUGO ) return Rubinius :: Type . coerce_to tmp , Fixnum , <str> end nil end def self . world_writable? ( path ) path = Rubinius :: Type . coerce_to_path path return nil unless exist? path mode = Stat . new ( path ) . mode if ( mode & Stat :: S_IWOTH ) == Stat :: S_IWOTH tmp = mode & ( Stat :: S_IRUGO | Stat :: S_IWUGO | Stat :: S_IXUGO ) return Rubinius :: Type . coerce_to tmp , Fixnum , <str> end end def self . writable? ( path ) st = Stat . stat path st ? st . writable? : false end def self . writable_real? ( path ) st = Stat . stat path st ? st . writable_real? : false end def self . zero? ( path ) st = Stat . stat path st ? st . zero? : false end def self . owned? ( file_name ) Stat . new ( file_name ) . owned? rescue Errno :: ENOENT return false end def self . setgid? ( file_name ) Stat . new ( file_name ) . setgid? rescue Errno :: ENOENT return false end def self . setuid? ( file_name ) Stat . new ( file_name ) . setuid? rescue Errno :: ENOENT return false end def self . sticky? ( file_name ) Stat . new ( file_name ) . sticky? rescue Errno :: ENOENT return false end def self . mkfifo ( file_name , mode = <oct> ) raise NotImplementedError , <str> unless Rubinius :: HAVE_MKFIFO file_name = file_name . to_path if file_name . respond_to? ( <str> ) file_name = StringValue ( file_name ) ret = POSIX . mkfifo ( file_name , mode ) if ret == <int> ret else Errno . handle ( file_name ) end end class << self alias_method <str> , <str> alias_method <str> , <str> alias_method <str> , <str> end def initialize ( path_or_fd , mode = undefined , perm = undefined , options = undefined ) if path_or_fd . kind_of? Integer super ( path_or_fd , mode , options ) @path = nil else path = Rubinius :: Type . coerce_to_path path_or_fd case mode when String , Fixnum when nil , undefined mode = <str> when Hash options = mode mode = nil else options = Rubinius :: Type . coerce_to mode , Hash , <str> mode = nil end if undefined . equal? ( options ) options = Rubinius :: Type . try_convert ( perm , Hash , <str> ) perm = undefined if options end nmode , binary , external , internal = IO . normalize_options ( mode , options ) nmode || = <str> perm = <oct> if undefined . equal? perm fd = IO . sysopen ( path , nmode , perm ) Errno . handle path if fd < <int> @path = path super ( fd , mode , options ) end end private <str> def atime Stat . new ( @path ) . atime end def ctime Stat . new ( @path ) . ctime end def birthtime Stat . new ( @path ) . birthtime end def mtime Stat . new ( @path ) . mtime end def reopen ( other , mode = <str> ) rewind unless closed? unless other . kind_of? IO other = Rubinius :: Type . coerce_to_path ( other ) end super ( other , mode ) end def flock ( const ) const = Rubinius :: Type . coerce_to const , Integer , <str> result = POSIX . flock @descriptor , const return false if result == - <int> result end def lstat Stat . lstat @path end def stat Stat . fstat @descriptor end alias_method <str> , <str> def truncate ( length ) length = Rubinius :: Type . coerce_to length , Integer , <str> ensure_open_and_writable raise Errno :: EINVAL , <str> if length < <int> flush reset_buffering prim_ftruncate ( length ) end def inspect return_string = <str> self . class <str> object_id . to_s ( <int> ) <str> @path <str> return_string << <str> if closed? return_string << <str> end def size raise IOError , <str> if closed? stat . size end def self . to_sexp ( name ) File . read ( name ) . to_sexp ( name ) end end 
