require <str> require <str> require <str> require <str> module DiskUsageExtension def disk_usage return @disk_usage if @disk_usage compute_disk_usage @disk_usage end def file_count return @file_count if @file_count compute_disk_usage @file_count end def abv out = <str> compute_disk_usage out << <str> number_readable ( @file_count ) <str> if @file_count > <int> out << <str> disk_usage_readable ( @disk_usage ) <str> end private def compute_disk_usage if directory? @file_count = <int> @disk_usage = <int> find do | f | if ! f . directory? && ! f . symlink? && f . basename . to_s != <str> @file_count += <int> @disk_usage += f . size end end else @file_count = <int> @disk_usage = size end end end class Pathname include DiskUsageExtension BOTTLE_EXTNAME_RX = <str> def install ( * sources ) sources . each do | src | case src when Resource src . stage ( self ) when Resource :: Partial src . resource . stage { install ( * src . files ) } when Array if src . empty? opoo <str> self <str> return end src . each { | s | install_p ( s , File . basename ( s ) ) } when Hash if src . empty? opoo <str> self <str> return end src . each { | s , new_basename | install_p ( s , new_basename ) } else install_p ( src , File . basename ( src ) ) end end end def install_p ( src , new_basename ) raise Errno :: ENOENT , src . to_s unless File . symlink? ( src ) || File . exist? ( src ) src = Pathname ( src ) dst = join ( new_basename ) dst = yield ( src , dst ) if block_given? mkpath if src . symlink? raise unless Kernel . system <str> , src , dst else FileUtils . mv src , dst end end private <str> def install_symlink ( * sources ) sources . each do | src | case src when Array src . each { | s | install_symlink_p ( s , File . basename ( s ) ) } when Hash src . each { | s , new_basename | install_symlink_p ( s , new_basename ) } else install_symlink_p ( src , File . basename ( src ) ) end end end def install_symlink_p ( src , new_basename ) src = Pathname ( src ) . expand_path ( self ) dst = join ( new_basename ) mkpath FileUtils . ln_sf ( src . relative_path_from ( dst . parent ) , dst ) end private <str> if method_defined? ( <str> ) alias_method <str> , <str> end def write ( content , * open_args ) raise <str> self <str> if exist? dirname . mkpath open ( <str> , * open_args ) { | f | f . write ( content ) } end def append_lines ( content , * open_args ) raise <str> self <str> unless exist? open ( <str> , * open_args ) { | f | f . puts ( content ) } end def binwrite ( contents , * open_args ) open ( <str> , * open_args ) { | f | f . write ( contents ) } end unless method_defined? ( <str> ) def binread ( * open_args ) open ( <str> , * open_args ) { | f | f . read } end unless method_defined? ( <str> ) def atomic_write ( content ) require <str> tf = Tempfile . new ( basename . to_s , dirname ) begin tf . binmode tf . write ( content ) begin old_stat = stat rescue Errno :: ENOENT old_stat = default_stat end uid = Process . uid gid = Process . groups . delete ( old_stat . gid ) { Process . gid } begin tf . chown ( uid , gid ) tf . chmod ( old_stat . mode ) rescue Errno :: EPERM end File . rename ( tf . path , self ) ensure tf . close! end end def default_stat sentinel = parent . join ( <str> Process . pid <str> rand ( Time . now . to_i ) <str> ) sentinel . open ( <str> ) { } sentinel . stat ensure sentinel . unlink end private <str> def cp_path_sub ( pattern , replacement ) raise <str> self <str> unless self . exist? dst = sub ( pattern , replacement ) raise <str> self <str> dst <str> if self == dst if directory? dst . mkpath else dst . dirname . mkpath dst = yield ( self , dst ) if block_given? FileUtils . cp ( self , dst ) end end alias_method <str> , <str> def extname ( path = to_s ) BOTTLE_EXTNAME_RX . match ( path ) return $1 if $1 <str> . match ( path ) return $1 if $1 File . extname ( path ) end def stem File . basename ( ( path = to_s ) , extname ( path ) ) end def rmdir_if_possible rmdir true rescue Errno :: ENOTEMPTY if ( ds_store = self + <str> ) . exist? && children . length == <int> ds_store . unlink retry else false end rescue Errno :: EACCES , Errno :: ENOENT false end def version require <str> Version . parse ( self ) end def compression_type case extname when <str> , <str> return when <str> return <str> when <str> return <str> when <str> , <str> return <str> end case open ( <str> ) { | f | f . read ( <int> ) } when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> else case extname when <str> , <str> , <str> , <str> then <str> when <str> then <str> end end end def text_executable? <str> === open ( <str> ) { | f | f . read ( <int> ) } end def incremental_hash ( klass ) digest = klass . new if digest . respond_to? ( <str> ) digest . file ( self ) else buf = <str> open ( <str> ) { | f | digest << buf while f . read ( <int> , buf ) } end digest . hexdigest end def sha1 require <str> incremental_hash ( Digest :: SHA1 ) end def sha256 require <str> incremental_hash ( Digest :: SHA2 ) end def verify_checksum ( expected ) raise ChecksumMissingError if expected . nil? || expected . empty? actual = Checksum . new ( expected . hash_type , send ( expected . hash_type ) . downcase ) raise ChecksumMismatchError . new ( self , expected , actual ) unless expected == actual end alias_method <str> , <str> unless method_defined? ( <str> ) def cd Dir . chdir ( self ) { yield } end def subdirs children . select ( & <str> ) end def resolved_path self . symlink? ? dirname + readlink : self end def resolved_path_exists? link = readlink rescue ArgumentError false else ( dirname + link ) . exist? end def make_relative_symlink ( src ) dirname . mkpath File . symlink ( src . relative_path_from ( dirname ) , self ) end def / ( other ) unless other . respond_to? ( <str> ) || other . respond_to? ( <str> ) opoo <str> inspect <str> other . inspect <str> puts <str> end self + other . to_s end unless method_defined? ( <str> ) def ensure_writable saved_perms = nil unless writable_real? saved_perms = stat . mode chmod <oct> end yield ensure chmod saved_perms if saved_perms end def install_info quiet_system <str> , <str> , to_s , <str> dirname <str> end def uninstall_info quiet_system <str> , <str> , <str> , to_s , <str> dirname <str> end def write_exec_script ( * targets ) targets . flatten! if targets . empty? opoo <str> self <str> return end mkpath targets . each do | target | target = Pathname . new ( target ) ( self + target . basename ) . write <<- <str> EOS <str> . undent <str> EOS end end def write_env_script ( target , env ) env_export = <str> env . each { | key , value | env_export += <str> key <str> value <str> } dirname . mkpath write <<- <str> EOS <str> . undent <str> EOS end def env_script_all_files ( dst , env ) dst . mkpath Pathname . glob ( <str> self <str> ) do | file | next if file . directory? dst . install ( file ) new_file = dst + file . basename file . write_env_script ( new_file , env ) end end def write_jar_script ( target_jar , script_name , java_opts = <str> ) mkpath ( self + script_name ) . write <<- <str> EOS <str> . undent <str> EOS end def install_metafiles ( from = Pathname . pwd ) Pathname ( from ) . children . each do | p | next if p . directory? next unless Metafiles . copy? ( p . basename . to_s ) filename = p . resolved_path next unless filename . exist? filename . chmod <oct> install ( filename ) end end if RUBY_VERSION < = <str> alias_method <str> , <str> def chop_basename ( path ) base = File . basename ( path ) if <str> Pathname :: SEPARATOR_PAT <str> =~ base return nil else return path [ <int> , path . rindex ( base ) ] , base end end private <str> alias_method <str> , <str> def prepend_prefix ( prefix , relpath ) if relpath . empty? File . dirname ( prefix ) elsif <str> SEPARATOR_PAT <str> =~ prefix prefix = File . dirname ( prefix ) prefix = File . join ( prefix , <str> ) if File . basename ( prefix + <str> ) != <str> prefix + relpath else prefix + relpath end end private <str> elsif RUBY_VERSION == <str> prepend Module . new { def inspect super . force_encoding ( @path . encoding ) end } end end module ObserverPathnameExtension class << self attr_accessor <str> , <str> def reset_counts! @n = @d = <int> @put_verbose_trimmed_warning = false end def total n + d end def counts [ n , d ] end MAXIMUM_VERBOSE_OUTPUT = <int> def verbose? return ARGV . verbose? unless ENV [ <str> ] return false unless ARGV . verbose? if total < MAXIMUM_VERBOSE_OUTPUT true else unless @put_verbose_trimmed_warning puts <str> MAXIMUM_VERBOSE_OUTPUT <str> @put_verbose_trimmed_warning = true end false end end end def unlink super puts <str> self <str> if ObserverPathnameExtension . verbose? ObserverPathnameExtension . n += <int> end def rmdir super puts <str> self <str> if ObserverPathnameExtension . verbose? ObserverPathnameExtension . d += <int> end def make_relative_symlink ( src ) super puts <str> src . relative_path_from ( dirname ) <str> basename <str> if ObserverPathnameExtension . verbose? ObserverPathnameExtension . n += <int> end def install_info super puts <str> self <str> if ObserverPathnameExtension . verbose? end def uninstall_info super puts <str> self <str> if ObserverPathnameExtension . verbose? end end 
