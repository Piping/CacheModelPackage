require <str> class BuildkiteService < CiService ENDPOINT = <str> prop_accessor <str> , <str> , <str> validates <str> , <str> : true , if : <str> validates <str> , <str> : true , if : <str> after_save <str> , if : <str> def webhook_url <str> buildkite_endpoint ( <str> ) <str> webhook_token <str> end def compose_service_hook hook = service_hook || build_service_hook hook . url = webhook_url hook . enable_ssl_verification = ! ! enable_ssl_verification hook . save end def supported_events <str> end def execute ( data ) return unless supported_events . include? ( data [ <str> ] ) service_hook . execute ( data ) end def commit_status ( sha , ref ) response = HTTParty . get ( commit_status_path ( sha ) , <str> : false ) if response . code == <int> && response [ <str> ] response [ <str> ] else <str> end end def commit_status_path ( sha ) <str> buildkite_endpoint ( <str> ) <str> status_token <str> sha <str> end def build_page ( sha , ref ) <str> project_url <str> sha <str> end def title <str> end def description <str> end def to_param <str> end def fields [ { <str> : <str> , name : <str> , <str> : <str> } , { <str> : <str> , name : <str> , <str> : <str> ENDPOINT <str> } , { <str> : <str> , name : <str> , <str> : <str> } ] end private def webhook_token token_parts . first end def status_token token_parts . second end def token_parts if token . present? token . split ( <str> ) else [ ] end end def buildkite_endpoint ( subdomain = nil ) if subdomain . present? uri = Addressable :: URI . parse ( ENDPOINT ) new_endpoint = <str> uri . scheme || <str> subdomain <str> uri . host <str> if uri . port . present? <str> new_endpoint <str> uri . port <str> else new_endpoint end else ENDPOINT end end end 
