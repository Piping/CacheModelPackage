require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Tcp include Msf :: Auxiliary :: Fuzzer def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptInt . new ( <str> , [ false , <str> ] ) ] , self . class ) end def do_ssh_version ( pkt , opts = { } ) @connected = false connect @connected = true @banner = sock . get_once ( - <int> , opts [ <str> ] ) return if not @banner sock . put ( <str> pkt <str> ) end def run last_str = nil last_inp = nil last_err = nil pkt = make_ssh_version cnt = <int> max = datastore [ <str> ] . to_i max = nil if max == <int> tot = ( max ? [ max , pkt . length ] . min : pkt . length ) * <int> print_status ( <str> tot <str> ) fuzz_string_corrupt_byte_reverse ( pkt , max ) do | str | cnt += <int> if ( cnt % <int> == <int> ) print_status ( <str> cnt <str> tot <str> @last_fuzzer_input <str> ) end begin r = do_ssh_version ( str , <str> = > <int> ) rescue :: Interrupt print_status ( <str> cnt <str> @last_fuzzer_input <str> ) raise $! rescue :: Exception = > e last_err = e ensure disconnect end if ( not @connected ) if ( last_str ) print_status ( <str> cnt - <int> <str> last_inp <str> last_str . unpack ( <str> ) [ <int> ] <str> last_err <str> ) else print_status ( <str> last_err <str> ) end return end if ( not @banner ) print_status ( <str> cnt - <int> <str> last_inp <str> last_str . unpack ( <str> ) [ <int> ] <str> ) return end last_str = str last_inp = @last_fuzzer_input end end def make_ssh_version <str> end end 
