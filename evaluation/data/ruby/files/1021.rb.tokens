require <str> require <str> module Bosh::Director module Api describe Controllers :: TasksController do include Rack :: Test :: Methods subject ( <str> ) { described_class . new ( config ) } let ( <str> ) { Dir . mktmpdir } let ( <str> ) do blobstore_dir = File . join ( temp_dir , <str> ) FileUtils . mkdir_p ( blobstore_dir ) config = Psych . load ( spec_asset ( <str> ) ) config [ <str> ] = temp_dir config [ <str> ] = { <str> = > <str> , <str> = > { <str> = > blobstore_dir } } config [ <str> ] [ <str> ] = true config end let ( <str> ) { Config . load_hash ( test_config ) } after { FileUtils . rm_rf ( temp_dir ) } it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) end it <str> do get <str> expect ( last_response . headers [ <str> ] ) . not_to be_nil end it <str> + <str> do basic_authorize <str> , <str> get <str> expect ( last_response . status ) . to eq ( <int> ) end describe <str> do before ( <str> ) { basic_authorize <str> , <str> } describe <str> do context <str> do let ( <str> ) { <str> } let! ( <str> ) do ( Bosh :: Director :: Jobs . constants . inject ( [ ] ) { | memo , const | klass = Bosh :: Director :: Jobs . const_get ( const ) if klass . ancestors . include? ( Bosh :: Director :: Jobs :: BaseJob ) memo << klass end memo } - [ Bosh :: Director :: Jobs :: BaseJob ] ) . map ( & <str> ) . map { | job_type | Models :: Task . make ( <str> : job_type ) } end context <str> do it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) actual_ids = body . map { | attributes | attributes [ <str> ] } actual_tasks = Models :: Task . filter ( id : actual_ids ) expect ( actual_tasks ) . to match ( all_tasks . select { | task | concise_task_types . include? ( task . type ) } ) end end context <str> do it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) actual_ids = body . map { | attributes | attributes [ <str> ] } actual_tasks = Models :: Task . filter ( id : actual_ids ) expect ( actual_tasks ) . to match ( all_tasks ) end end context <str> do it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) actual_ids = body . map { | attributes | attributes [ <str> ] } actual_tasks = Models :: Task . filter ( id : actual_ids ) expect ( actual_tasks ) . to match ( all_tasks . select { | task | concise_task_types . include? ( task . type ) } ) end end end context <str> do it <str> do expected_task = Models :: Task . make ( <str> : <str> , <str> : <str> ) filtered_task = Models :: Task . make ( <str> : <str> , <str> : <str> ) get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) actual_ids = body . map { | attributes | attributes [ <str> ] } actual_tasks = Models :: Task . filter ( id : actual_ids ) . to_a expect ( actual_tasks . map ( & <str> ) ) . to eq ( [ expected_task . id ] ) end end context <str> do before do ( <int> .. <int> ) . map { | i | Models :: Task . make ( <str> = > <str> , <str> = > <str> , ) } end context <str> do it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) expect ( body . size ) . to eq ( <int> ) end end context <str> do it <str> do get <str> expect ( last_response . status ) . to eq ( <int> ) body = Yajl :: Parser . parse ( last_response . body ) expect ( body . size ) . to eq ( <int> ) end end end end describe <str> do it <str> do task = Models :: Task . make ( <str> : <str> , <str> : <str> ) get <str> task . id <str> expect ( last_response . status ) . to eq ( <int> ) task_json = Yajl :: Parser . parse ( last_response . body ) expect ( task_json [ <str> ] ) . to eq ( task . id ) expect ( task_json [ <str> ] ) . to eq ( <str> ) expect ( task_json [ <str> ] ) . to eq ( <str> ) task . state = <str> task . save get <str> task . id <str> expect ( last_response . status ) . to eq ( <int> ) task_json = Yajl :: Parser . parse ( last_response . body ) expect ( task_json [ <str> ] ) . to eq ( <int> ) expect ( task_json [ <str> ] ) . to eq ( <str> ) expect ( task_json [ <str> ] ) . to eq ( <str> ) end it <str> do output_file = File . new ( File . join ( temp_dir , <str> ) , <str> ) output_file . print ( <str> ) output_file . close task = Models :: Task . make ( <str> : temp_dir ) get <str> task . id <str> expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) end it <str> do output_file = File . new ( File . join ( temp_dir , <str> ) , <str> ) output_file . print ( <str> ) output_file . close task = Models :: Task . make ( <str> : temp_dir ) get <str> task . id <str> , { } , { <str> = > <str> } expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) expect ( last_response . headers [ <str> ] ) . to eq ( <str> ) expect ( last_response . headers [ <str> ] ) . to eq ( <str> ) get <str> task . id <str> , { } , { <str> = > <str> } expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) expect ( last_response . headers [ <str> ] ) . to eq ( <str> ) expect ( last_response . headers [ <str> ] ) . to eq ( <str> ) end it <str> do <str> . each do | log_type | output_file = File . new ( File . join ( temp_dir , log_type ) , <str> ) output_file . print ( <str> log_type <str> ) output_file . close end task = Models :: Task . new task . state = <str> task . type = <str> task . timestamp = Time . now . to_i task . description = <str> task . output = temp_dir task . save <str> . each do | log_type | get <str> task . id <str> log_type <str> expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> log_type <str> ) end get <str> task . id <str> expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) get <str> task . id <str> expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) end it <str> do output_file = File . new ( File . join ( temp_dir , <str> ) , <str> ) output_file . print ( <str> ) output_file . close task = Models :: Task . new task . state = <str> task . type = <str> task . timestamp = Time . now . to_i task . description = <str> task . output = temp_dir task . save <str> . each do | log_type | get <str> task . id <str> log_type <str> expect ( last_response . status ) . to eq ( <int> ) expect ( last_response . body ) . to eq ( <str> ) end end end end describe <str> do before ( <str> ) { basic_authorize <str> , <str> } let ( <str> ) { Support :: TestIdentityProvider . new } let ( <str> ) do config = Config . load_hash ( test_config ) allow ( config ) . to receive ( <str> ) . and_return ( identity_provider ) config end it <str> do get <str> expect ( identity_provider . scope ) . to eq ( <str> ) get <str> expect ( identity_provider . scope ) . to eq ( <str> ) get <str> expect ( identity_provider . scope ) . to eq ( <str> ) get <str> expect ( identity_provider . scope ) . to eq ( <str> ) get <str> expect ( identity_provider . scope ) . to eq ( <str> ) end end end end end 
