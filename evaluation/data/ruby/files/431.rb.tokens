require <str> require <str> module Tk module Tile class TPaned < TkWindow end PanedWindow = Panedwindow = Paned = TPaned end end class Tk :: Tile :: TPaned < TkWindow include Tk :: Tile :: TileWidget if Tk :: Tile :: USE_TTK_NAMESPACE if Tk :: Tile :: TILE_SPEC_VERSION_ID < <int> TkCommandNames = [ <str> . freeze ] . freeze else TkCommandNames = [ <str> . freeze ] . freeze end else TkCommandNames = [ <str> . freeze ] . freeze end WidgetClassName = <str> . freeze WidgetClassNames [ WidgetClassName ] || = self def self . style ( * args ) [ self :: WidgetClassName , * ( args . map! { | a | _get_eval_string ( a ) } ) ] . join ( <str> ) end def add ( * args ) keys = args . pop fail ArgumentError , <str> unless keys if keys && keys . kind_of? ( Hash ) fail ArgumentError , <str> if args == [ ] opts = hash_kv ( keys ) else args . push ( keys ) if keys opts = [ ] end args . each { | win | tk_send_without_enc ( <str> , _epath ( win ) , * opts ) } self end def forget ( pane ) pane = _epath ( pane ) tk_send_without_enc ( <str> , pane ) self end def insert ( pos , win , keys ) win = _epath ( win ) tk_send_without_enc ( <str> , pos , win , * hash_kv ( keys ) ) self end def panecget_tkstring ( pane , slot ) pane = _epath ( pane ) tk_send_without_enc ( <str> , pane , <str> slot <str> ) end alias pane_cget_tkstring panecget_tkstring def panecget_strict ( pane , slot ) pane = _epath ( pane ) tk_tcl2ruby ( tk_send_without_enc ( <str> , pane , <str> slot <str> ) ) end alias pane_cget_strict panecget_strict def panecget ( pane , slot ) unless TkItemConfigMethod . __IGNORE_UNKNOWN_CONFIGURE_OPTION__ panecget_strict ( pane , slot ) else begin panecget_strict ( pane , slot ) rescue = > e begin if current_paneconfiginfo ( pane ) . has_key? ( slot . to_s ) fail e else nil end rescue fail e end end end end alias pane_cget panecget def paneconfigure ( pane , key , value = nil ) pane = _epath ( pane ) if key . kind_of? Hash params = [ ] key . each { | k , v | params . push ( <str> k <str> ) params . push ( _epath ( v ) ) } tk_send_without_enc ( <str> , pane , * params ) else value = _epath ( value ) tk_send_without_enc ( <str> , pane , <str> key <str> , value ) end self end alias pane_config paneconfigure alias pane_configure paneconfigure def paneconfiginfo ( win ) if TkComm :: GET_CONFIGINFO_AS_ARRAY win = _epath ( win ) if key conf = tk_split_list ( tk_send_without_enc ( <str> , win , <str> key <str> ) ) conf [ <int> ] = conf [ <int> ] [ <int> .. - <int> ] if conf [ <int> ] == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? end conf else tk_split_simplelist ( tk_send_without_enc ( <str> , win ) ) . collect { | conflist | conf = tk_split_simplelist ( conflist ) conf [ <int> ] = conf [ <int> ] [ <int> .. - <int> ] if conf [ <int> ] if conf [ <int> ] == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? elsif conf [ <int> ] . index ( <str> ) conf [ <int> ] = tk_split_list ( conf [ <int> ] ) else conf [ <int> ] = tk_tcl2ruby ( conf [ <int> ] ) end end if conf [ <int> ] if conf [ <int> ] == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? elsif conf [ <int> ] . index ( <str> ) conf [ <int> ] = tk_split_list ( conf [ <int> ] ) else conf [ <int> ] = tk_tcl2ruby ( conf [ <int> ] ) end end conf [ <int> ] = conf [ <int> ] [ <int> .. - <int> ] if conf . size == <int> conf } end else win = _epath ( win ) if key conf = tk_split_list ( tk_send_without_enc ( <str> , win , <str> key <str> ) ) key = conf . shift [ <int> .. - <int> ] if key == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? end { key = > conf } else ret = { } tk_split_simplelist ( tk_send_without_enc ( <str> , win ) ) . each { | conflist | conf = tk_split_simplelist ( conflist ) key = conf . shift [ <int> .. - <int> ] if key if key == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? elsif conf [ <int> ] . index ( <str> ) conf [ <int> ] = tk_split_list ( conf [ <int> ] ) else conf [ <int> ] = tk_tcl2ruby ( conf [ <int> ] ) end end if conf [ <int> ] if key == <str> conf [ <int> ] = bool ( conf [ <int> ] ) unless conf [ <int> ] . empty? elsif conf [ <int> ] . index ( <str> ) conf [ <int> ] = tk_split_list ( conf [ <int> ] ) else conf [ <int> ] = tk_tcl2ruby ( conf [ <int> ] ) end end if conf . size == <int> ret [ key ] = conf [ <int> ] [ <int> .. - <int> ] else ret [ key ] = conf end } ret end end end alias pane_configinfo paneconfiginfo def current_paneconfiginfo ( win , key = nil ) if TkComm :: GET_CONFIGINFO_AS_ARRAY if key conf = paneconfiginfo ( win , key ) { conf [ <int> ] = > conf [ <int> ] } else ret = { } paneconfiginfo ( win ) . each { | conf | ret [ conf [ <int> ] ] = conf [ <int> ] if conf . size > <int> } ret end else ret = { } paneconfiginfo ( win , key ) . each { | k , conf | ret [ k ] = conf [ - <int> ] if conf . kind_of? ( Array ) } ret end end alias current_pane_configinfo current_paneconfiginfo def panes tk_split_simplelist ( tk_send_without_enc ( <str> ) ) . map { | w | ( obj = window ( w ) ) ? <str> : w } end def identify ( x , y ) num_or_nil ( tk_send_without_enc ( <str> , x , y ) ) end def sashpos ( idx , newpos = None ) num_or_str ( tk_send_without_enc ( <str> , idx , newpos ) ) end end Tk . __set_loaded_toplevel_aliases__ ( <str> , <str> , Tk :: Tile :: Panedwindow , <str> , <str> ) 
