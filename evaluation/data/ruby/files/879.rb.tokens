require <str> require <str> require <str> require <str> require <str> module Msf module Exploit::Remote::DCERPC DCERPCPacket = Rex :: Proto :: DCERPC :: Packet DCERPCClient = Rex :: Proto :: DCERPC :: Client DCERPCResponse = Rex :: Proto :: DCERPC :: Response DCERPCUUID = Rex :: Proto :: DCERPC :: UUID NDR = Rex :: Encoder :: NDR include Exploit :: Remote :: Tcp include Exploit :: Remote :: DCERPC_EPM include Exploit :: Remote :: DCERPC_MGMT include Exploit :: Remote :: DCERPC_LSA def initialize ( info = { } ) super register_evasion_options ( [ OptInt . new ( <str> , [ true , <str> , <int> ] ) , OptBool . new ( <str> , [ false , <str> , true ] ) , OptInt . new ( <str> , [ false , <str> , <int> ] ) , OptInt . new ( <str> , [ false , <str> , <int> ] ) , OptEnum . new ( <str> , [ false , <str> , <str> , [ <str> , <str> ] ] ) ] , Msf :: Exploit :: Remote :: DCERPC ) register_options ( [ Opt :: RHOST , Opt :: RPORT ( <int> ) , ] , Msf :: Exploit :: Remote :: DCERPC ) register_advanced_options ( [ OptInt . new ( <str> , [ true , <str> , <int> ] ) ] , Msf :: Exploit :: Remote :: DCERPC ) end def dcerpc_handle ( uuid , version , protocol , opts ) self . handle = Rex :: Proto :: DCERPC :: Handle . new ( [ uuid , version ] , protocol , rhost , opts ) end def dcerpc_bind ( h ) opts = { <str> = > framework , <str> = > self } if datastore [ <str> ] opts [ <str> ] = datastore [ <str> ] end if datastore [ <str> ] opts [ <str> ] = <int> if datastore [ <str> ] opts [ <str> ] = datastore [ <str> ] end if datastore [ <str> ] opts [ <str> ] = datastore [ <str> ] end end opts [ <str> ] = ( datastore [ <str> ] || <int> ) . to_i opts [ <str> ] = ( datastore [ <str> ] || <int> ) . to_i if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( datastore [ <str> ] ) opts [ <str> ] = datastore [ <str> ] end if ( self . respond_to? ( <str> ) and self . simple ) opts [ <str> ] = self . simple end self . dcerpc = Rex :: Proto :: DCERPC :: Client . new ( h , self . sock , opts ) if ( self . handle . protocol == <str> and not self . simple ) self . simple = self . dcerpc . smb end end def dcerpc_call ( function , stub = <str> , timeout = nil , do_recv = true ) otimeout = dcerpc . options [ <str> ] begin dcerpc . options [ <str> ] = timeout if timeout dcerpc . call ( function , stub , do_recv ) rescue :: Rex :: Proto :: SMB :: Exceptions :: NoReply , Rex :: Proto :: DCERPC :: Exceptions :: NoResponse print_status ( <str> ) return ensure dcerpc . options [ <str> ] = otimeout end end def unicode ( str ) Rex :: Text . to_unicode ( str ) end attr_accessor <str> , <str> end end 
