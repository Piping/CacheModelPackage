require <str> class TestString < Test :: Unit :: TestCase ENUMERATOR_WANTARRAY = RUBY_VERSION > = <str> def initialize ( * args ) @cls = String @aref_re_nth = true @aref_re_silent = false @aref_slicebang_silent = true super end def S ( * args ) @cls . new ( * args ) end def test_s_new assert_equal ( <str> , S ( ) ) assert_equal ( Encoding :: ASCII_8BIT , S ( ) . encoding ) assert_equal ( <str> , S ( <str> ) ) assert_equal ( __ENCODING__ , S ( <str> ) . encoding ) src = <str> assert_equal ( src , S ( src ) ) assert_equal ( __ENCODING__ , S ( src ) . encoding ) src . force_encoding ( <str> ) assert_equal ( src , S ( src ) ) assert_equal ( Encoding :: EUC_JP , S ( src ) . encoding ) assert_equal ( <str> , S ( <str> : <str> ) ) assert_equal ( Encoding :: EUC_JP , S ( <str> : <str> ) . encoding ) assert_equal ( <str> , S ( <str> , <str> : <str> ) ) assert_equal ( Encoding :: EUC_JP , S ( <str> , <str> : <str> ) . encoding ) src = <str> assert_equal ( src , S ( src , <str> : <str> ) ) assert_equal ( Encoding :: EUC_JP , S ( src , <str> : <str> ) . encoding ) src . force_encoding ( <str> ) assert_equal ( src , S ( src , <str> : <str> ) ) assert_equal ( Encoding :: UTF_8 , S ( src , <str> : <str> ) . encoding ) assert_equal ( <str> , S ( <str> : <int> ) ) assert_equal ( Encoding :: ASCII_8BIT , S ( <str> : <int> ) . encoding ) assert_equal ( <str> , S ( <str> : <int> , <str> : <str> ) ) assert_equal ( Encoding :: EUC_JP , S ( <str> : <int> , <str> : <str> ) . encoding ) assert_equal ( <str> , S ( <str> , <str> : <int> ) ) assert_equal ( __ENCODING__ , S ( <str> , <str> : <int> ) . encoding ) assert_equal ( <str> , S ( <str> , <str> : <int> , <str> : <str> ) ) assert_equal ( Encoding :: EUC_JP , S ( <str> , <str> : <int> , <str> : <str> ) . encoding ) end def test_initialize str = S ( <str> ) . freeze assert_equal ( <str> , str . __send__ ( <str> ) ) assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> ) } assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> : <int> ) } assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> , <str> : <int> ) } assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> : <str> ) } assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> , <str> : <str> ) } assert_raise ( RuntimeError ) { str . __send__ ( <str> , <str> , <str> : <int> , <str> : <str> ) } end def test_initialize_nonstring assert_raise ( TypeError ) { S ( <int> ) } assert_raise ( TypeError ) { S ( <int> , <str> : <int> ) } end def test_initialize_memory_leak assert_no_memory_leak ( [ ] , <<- <str> PREP <str> , <<- <str> CODE <str> , <str> : true ) <str> PREP <str> CODE end def test_AREF assert_equal ( <str> , S ( <str> ) [ <int> ] ) assert_equal ( <str> , S ( <str> ) [ - <int> ] ) assert_equal ( nil , S ( <str> ) [ <int> ] ) assert_equal ( nil , S ( <str> ) [ - <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <int> , <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ - <int> , <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <int> , <int> ] ) assert_equal ( nil , S ( <str> ) [ - <int> , <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <int> .. <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <int> ... <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ - <int> .. - <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <int> .. <int> ] ) assert_equal ( nil , S ( <str> ) [ - <int> .. - <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <str> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <str> ] ) assert_equal ( nil , S ( <str> ) [ <str> ] ) assert_equal ( nil , S ( <str> ) [ <str> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ S ( <str> ) ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ S ( <str> ) ] ) assert_equal ( nil , S ( <str> ) [ S ( <str> ) ] ) assert_equal ( nil , S ( <str> ) [ S ( <str> ) ] ) if @aref_re_nth assert_equal ( S ( <str> ) , S ( <str> ) [ <str> , <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <str> , <int> ] ) assert_equal ( nil , S ( <str> ) [ <str> , <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <str> , - <int> ] ) assert_equal ( S ( <str> ) , S ( <str> ) [ <str> , - <int> ] ) assert_equal ( nil , S ( <str> ) [ <str> , - <int> ] ) end o = Object . new def o . to_int ; <int> ; end assert_equal ( <str> , <str> [ o ] ) assert_raise ( ArgumentError ) { <str> [ ] } end def test_ASET s = S ( <str> ) s [ <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ - <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) assert_raise ( IndexError ) { s [ - <int> ] = S ( <str> ) } assert_equal ( S ( <str> ) , s ) s [ <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s = S ( <str> ) s [ <int> , <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ - <int> , <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) assert_raise ( IndexError ) { s [ <int> , <int> ] = S ( <str> ) } assert_raise ( IndexError ) { s [ - <int> , <int> ] = S ( <str> ) } s = S ( <str> ) s [ <int> .. <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ <int> .. <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ - <int> .. - <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) assert_raise ( RangeError ) { s [ <int> .. <int> ] = S ( <str> ) } assert_raise ( RangeError ) { s [ - <int> .. - <int> ] = S ( <str> ) } s = S ( <str> ) s [ <str> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ <str> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) if @aref_re_silent s [ <str> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) else assert_raise ( IndexError ) { s [ <str> ] = S ( <str> ) } end if @aref_re_nth s [ <str> , <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ <str> , <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) assert_raise ( IndexError ) { s [ <str> , <int> ] = <str> } s [ <str> , - <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s [ <str> , - <int> ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) assert_raise ( IndexError ) { s [ <str> , - <int> ] = <str> } end s = S ( <str> ) s [ S ( <str> ) ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) s = S ( <str> ) s [ <int> .. s . size ] = S ( <str> ) assert_equal ( S ( <str> ) , s ) o = Object . new def o . to_int ; <int> ; end s = <str> s [ o ] = <str> assert_equal ( <str> , s ) assert_raise ( ArgumentError ) { <str> [ <int> , <int> , <int> ] = <str> } end def test_CMP assert_equal ( <int> , S ( <str> ) < = > S ( <str> ) ) assert_equal ( <int> , S ( <str> ) < = > S ( <str> ) ) assert_equal ( - <int> , S ( <str> ) < = > S ( <str> ) ) assert_equal ( - <int> , S ( <str> ) < = > S ( <str> ) ) assert_nil ( <str> < = > Object . new ) o = Object . new def o . to_str ; <str> ; end assert_equal ( <int> , <str> < = > o ) class << o ; remove_method <str> ; end def o . <=> ( x ) ; nil ; end assert_nil ( <str> < = > o ) class << o ; remove_method <str> ; end def o . <=> ( x ) ; <int> ; end assert_equal ( - <int> , <str> < = > o ) class << o ; remove_method <str> ; end def o . <=> ( x ) ; <int> ** <int> ; end assert_equal ( - <int> , <str> < = > o ) end def test_EQUAL assert_not_equal ( <str> , S ( <str> ) ) assert_equal ( S ( <str> ) , S ( <str> ) ) assert_not_equal ( S ( <str> ) , S ( <str> ) ) assert_not_equal ( S ( <str> ) , S ( <str> ) ) o = Object . new def o . to_str ; end def o . == ( x ) ; false ; end assert_equal ( false , <str> == o ) class << o ; remove_method <str> ; end def o . == ( x ) ; true ; end assert_equal ( true , <str> == o ) end def test_LSHIFT assert_equal ( S ( <str> ) , S ( <str> ) << <int> ) assert_equal ( S ( <str> ) , S ( <str> ) << S ( <str> ) ) s = <str> <int> . times { | i | s << s assert_equal ( <str> * ( <int> << i ) , s ) } s = [ <str> ] . pack ( <str> ) l = s . size s << <str> assert_equal ( l + <int> , s . size ) bug = <str> assert_raise ( RangeError , bug ) { S ( <str> . force_encoding ( Encoding :: UTF_8 ) ) << - <int> } assert_raise ( RangeError , bug ) { S ( <str> . force_encoding ( Encoding :: UTF_8 ) ) << - <int> } assert_raise ( RangeError , bug ) { S ( <str> . force_encoding ( Encoding :: UTF_8 ) ) << - <int> } assert_raise ( RangeError , bug ) { S ( <str> . force_encoding ( Encoding :: UTF_8 ) ) << <hex> } assert_nothing_raised { S ( <str> . force_encoding ( Encoding :: GB18030 ) ) << <hex> } end def test_MATCH assert_equal ( <int> , S ( <str> ) =~ <str> ) assert_equal ( nil , S ( <str> ) =~ <str> ) o = Object . new def o . = ~ ( x ) ; x + <str> ; end assert_equal ( <str> , S ( <str> ) =~ o ) assert_raise ( TypeError ) { S ( <str> ) =~ <str> } end def test_MOD assert_equal ( S ( <str> ) , S ( <str> ) % <int> ) assert_equal ( S ( <str> ) , S ( <str> ) % [ <int> , <int> ] ) x = S ( <str> ) % [ S ( <str> ) , <int> , S ( <str> ) , <int> , <int> , <str> , <int> . <int> , <int> , <int> , <int> , <int> , <int> , <int> ] assert_equal ( S ( <str> ) , x ) end def test_MUL assert_equal ( S ( <str> ) , S ( <str> ) * <int> ) assert_equal ( S ( <str> ) , S ( <str> ) * <int> ) end def test_PLUS assert_equal ( S ( <str> ) , S ( <str> ) + S ( <str> ) ) end def casetest ( a , b , rev = false ) msg = proc { <str> a <str> if rev <str> b <str> } case a when b assert ( ! rev , msg ) else assert ( rev , msg ) end end def test_VERY_EQUAL casetest ( S ( <str> ) , S ( <str> ) ) casetest ( S ( <str> ) , S ( <str> ) , true ) casetest ( S ( <str> ) , S ( <str> ) , true ) end def test_capitalize assert_equal ( S ( <str> ) , S ( <str> ) . capitalize ) assert_equal ( S ( <str> ) , S ( <str> ) . capitalize ) assert_equal ( S ( <str> ) , S ( <str> ) . capitalize ) end def test_capitalize! a = S ( <str> ) ; a . capitalize! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) ; a . capitalize! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) ; a . capitalize! assert_equal ( S ( <str> ) , a ) assert_equal ( nil , S ( <str> ) . capitalize! ) assert_equal ( S ( <str> ) , S ( <str> ) . capitalize! ) assert_equal ( S ( <str> ) , S ( <str> ) . capitalize! ) assert_equal ( S ( <str> ) , S ( <str> ) . capitalize! ) assert_equal ( nil , S ( <str> ) . capitalize! ) a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . capitalize! ) assert_equal ( S ( <str> ) , b ) end Bug2463 = <str> def test_center assert_equal ( S ( <str> ) , S ( <str> ) . center ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . center ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . center ( <int> , <str> ) , Bug2463 ) assert_equal ( S ( <str> ) , S ( <str> ) . center ( <int> , <str> ) , Bug2463 ) end def test_chomp assert_equal ( S ( <str> ) , S ( <str> ) . chomp ( <str> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . chomp ( <str> ) ) save = $/ $/ = <str> assert_equal ( S ( <str> ) , S ( <str> ) . chomp ) assert_equal ( S ( <str> ) , S ( <str> ) . chomp ) $/ = <str> assert_equal ( S ( <str> ) , S ( <str> ) . chomp ) assert_equal ( S ( <str> ) , S ( <str> ) . chomp ) $/ = save assert_equal ( S ( <str> ) . hash , S ( <str> ) . chomp ( S ( <str> ) ) . hash , <str> ) end def test_chomp! a = S ( <str> ) a . chomp! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) assert_equal ( nil , a . chomp! ( S ( <str> ) ) ) a = S ( <str> ) a . chomp! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) save = $/ $/ = <str> a = S ( <str> ) a . chomp! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . chomp! assert_equal ( S ( <str> ) , a ) $/ = <str> a = S ( <str> ) a . chomp! assert_equal ( S ( <str> ) , a ) a = <str> a . chomp! assert_equal ( S ( <str> ) , a ) $/ = save a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . chomp! ) assert_equal ( S ( <str> ) , b ) s = <str> s . chomp! assert_equal ( <str> , s ) s = <str> s . chomp! assert_equal ( <str> , s ) s = <str> s . chomp! ( <str> ) assert_equal ( <str> , s ) s = <str> s . chomp! ( <str> ) assert_equal ( <str> , s ) assert_equal ( S ( <str> ) . hash , S ( <str> ) . chomp! ( S ( <str> ) ) . hash , <str> ) end def test_chop assert_equal ( S ( <str> ) , S ( <str> ) . chop ) assert_equal ( S ( <str> ) , S ( <str> ) . chop ) assert_equal ( S ( <str> ) , S ( <str> ) . chop ) assert_equal ( S ( <str> ) , S ( <str> ) . chop ) assert_equal ( S ( <str> ) , S ( <str> ) . chop ) assert_equal ( S ( <str> ) . hash , S ( <str> ) . chop . hash ) end def test_chop! a = S ( <str> ) . chop! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) . chop! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) . chop! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) . chop! assert_equal ( S ( <str> ) , a ) a = S ( <str> ) . chop! assert_nil ( a ) a = S ( <str> ) a . chop! assert_equal ( S ( <str> ) . hash , a . hash ) a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . chop! ) assert_equal ( S ( <str> ) , b ) end def test_clone for taint in [ false , true ] for frozen in [ false , true ] a = S ( <str> ) a . taint if taint a . freeze if frozen b = a . clone assert_equal ( a , b ) assert_not_same ( a , b ) assert_equal ( a . frozen? , b . frozen? ) assert_equal ( a . tainted? , b . tainted? ) end end assert_equal ( <str> , File . read ( IO :: NULL ) . clone , <str> ) end def test_concat assert_equal ( S ( <str> ) , S ( <str> ) . concat ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . concat ( S ( <str> ) ) ) bug7090 = <str> result = S ( <str> ) . force_encoding ( Encoding :: UTF_16LE ) result << <hex> expected = S ( <str> . encode ( Encoding :: UTF_16LE ) ) assert_equal ( expected , result , bug7090 ) assert_raise ( TypeError ) { <str> << <str> } end def test_count a = S ( <str> ) assert_equal ( <int> , a . count ( S ( <str> ) ) ) assert_equal ( <int> , a . count ( S ( <str> ) , S ( <str> ) ) ) assert_equal ( <int> , a . count ( S ( <str> ) , S ( <str> ) ) ) assert_equal ( <int> , a . count ( S ( <str> ) ) ) assert_equal ( <int> , S ( <str> ) . count ( S ( <str> ) ) ) assert_equal ( <int> , <str> . count ( <str> ) ) assert_equal ( <int> , <str> . count ( <str> ) ) assert_equal ( <int> , <str> . count ( <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_equal ( <int> , <str> . count ( <str> , <str> ) ) assert_raise ( ArgumentError ) { <str> . count } end def test_crypt assert_equal ( S ( <str> ) , S ( <str> ) . crypt ( S ( <str> ) ) ) assert_not_equal ( S ( <str> ) , S ( <str> ) . crypt ( S ( <str> ) ) ) assert_raise ( ArgumentError ) { S ( <str> ) . crypt ( S ( <str> ) ) } assert_raise ( ArgumentError ) { S ( <str> ) . crypt ( S ( <str> ) ) } assert_raise ( ArgumentError ) { S ( <str> ) . crypt ( S ( <str> ) ) } assert_raise ( ArgumentError ) { S ( <str> ) . crypt ( S ( <str> ) ) } [ Encoding :: UTF_16BE , Encoding :: UTF_16LE , Encoding :: UTF_32BE , Encoding :: UTF_32LE ] . each do | enc | assert_raise ( ArgumentError ) { S ( <str> ) . crypt ( S ( <str> . encode ( enc ) ) ) } assert_raise ( ArgumentError ) { S ( <str> . encode ( enc ) ) . crypt ( S ( <str> ) ) } end end def test_delete assert_equal ( S ( <str> ) , S ( <str> ) . delete ( S ( <str> ) , S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . delete ( S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . delete ( S ( <str> ) , S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . delete ( S ( <str> ) ) ) assert_equal ( <str> . hash , <str> . delete ( <str> ) . hash , <str> ) assert_equal ( true , <str> . delete ( <str> ) . ascii_only? ) assert_equal ( true , <str> . delete ( <str> ) . ascii_only? ) assert_equal ( false , <str> . tr ( <str> , <str> ) . ascii_only? ) assert_equal ( <str> , <str> . delete ( <str> ) ) assert_equal ( <str> , <str> . delete ( <str> ) ) assert_equal ( <str> , <str> . delete ( <str> ) ) bug6160 = <str> assert_equal ( <str> , <str> . delete ( <str> ) , bug6160 ) end def test_delete! a = S ( <str> ) a . delete! ( S ( <str> ) , S ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . delete! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . delete! ( S ( <str> ) , S ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . delete! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_nil ( a . delete! ( S ( <str> ) ) ) a = S ( <str> ) b = a . dup a . delete! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) a = S ( <str> ) a . delete! ( S ( <str> ) ) assert_equal ( S ( <str> ) , a ) assert_raise ( ArgumentError ) { S ( <str> ) . delete! } end def test_downcase assert_equal ( S ( <str> ) , S ( <str> ) . downcase ) assert_equal ( S ( <str> ) , S ( <str> ) . downcase ) assert_equal ( S ( <str> ) , S ( <str> ) . downcase ) assert_equal ( S ( <str> ) , S ( <str> ) . downcase ) end def test_downcase! a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . downcase! ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) a = S ( <str> ) assert_nil ( a . downcase! ) assert_equal ( S ( <str> ) , a ) end def test_dump a = S ( <str> ) << <int> << <int> << <int> << <int> << <int> << <int> assert_equal ( S ( <str> ) , a . dump ) end def test_dup for taint in [ false , true ] for frozen in [ false , true ] a = S ( <str> ) a . taint if taint a . freeze if frozen b = a . dup assert_equal ( a , b ) assert_not_same ( a , b ) assert_not_predicate ( b , <str> ) assert_equal ( a . tainted? , b . tainted? ) end end end def test_each save = $/ $/ = <str> res = [ ] S ( <str> ) . lines . each { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) res = [ ] S ( <str> ) . lines ( S ( <str> ) ) . each { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) $/ = <str> res = [ ] S ( <str> ) . lines . each { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) $/ = save end def test_each_byte s = S ( <str> ) res = [ ] assert_equal s . object_id , s . each_byte { | x | res << x } . object_id assert_equal ( <int> , res [ <int> ] ) assert_equal ( <int> , res [ <int> ] ) assert_equal ( <int> , res [ <int> ] ) assert_equal <int> , s . each_byte . next end def test_bytes s = S ( <str> ) assert_equal [ <int> , <int> , <int> ] , s . bytes if ENUMERATOR_WANTARRAY assert_warn ( <str> ) { assert_equal [ <int> , <int> , <int> ] , s . bytes { } } else assert_warning ( <str> ) { res = [ ] assert_equal s . object_id , s . bytes { | x | res << x } . object_id assert_equal ( <int> , res [ <int> ] ) assert_equal ( <int> , res [ <int> ] ) assert_equal ( <int> , res [ <int> ] ) } end end def test_each_codepoint assert_equal <int> , S ( <str> ) . each_codepoint . next s = S ( <str> ) res = [ ] assert_equal s . object_id , s . each_codepoint { | x | res << x } . object_id assert_equal ( <hex> , res [ <int> ] ) assert_equal ( <hex> , res [ <int> ] ) assert_equal ( <hex> , res [ <int> ] ) assert_equal <hex> , s . each_codepoint . next end def test_codepoints assert_equal [ <int> , <int> , <int> ] , S ( <str> ) . codepoints s = S ( <str> ) assert_equal [ <hex> , <hex> , <hex> ] , s . codepoints if ENUMERATOR_WANTARRAY assert_warn ( <str> ) { assert_equal [ <hex> , <hex> , <hex> ] , s . codepoints { } } else assert_warning ( <str> ) { res = [ ] assert_equal s . object_id , s . codepoints { | x | res << x } . object_id assert_equal ( <hex> , res [ <int> ] ) assert_equal ( <hex> , res [ <int> ] ) assert_equal ( <hex> , res [ <int> ] ) } end end def test_each_char s = S ( <str> ) res = [ ] assert_equal s . object_id , s . each_char { | x | res << x } . object_id assert_equal ( <str> , res [ <int> ] ) assert_equal ( <str> , res [ <int> ] ) assert_equal ( <str> , res [ <int> ] ) assert_equal <str> , S ( <str> ) . each_char . next end def test_chars s = S ( <str> ) assert_equal [ <str> , <str> , <str> ] , s . chars if ENUMERATOR_WANTARRAY assert_warn ( <str> ) { assert_equal [ <str> , <str> , <str> ] , s . chars { } } else assert_warning ( <str> ) { res = [ ] assert_equal s . object_id , s . chars { | x | res << x } . object_id assert_equal ( <str> , res [ <int> ] ) assert_equal ( <str> , res [ <int> ] ) assert_equal ( <str> , res [ <int> ] ) } end end def test_each_line save = $/ $/ = <str> res = [ ] S ( <str> ) . each_line { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) res = [ ] S ( <str> ) . each_line ( S ( <str> ) ) { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) $/ = <str> res = [ ] S ( <str> ) . each_line { | x | res << x } assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) $/ = <str> res = [ ] S ( <str> ) . lines . each { | x | res << x } assert_equal ( <int> , res . size ) assert_equal ( S ( <str> ) , res [ <int> ] ) $/ = save s = nil <str> . each_line ( nil ) { | s2 | s = s2 } assert_equal ( <str> , s ) assert_equal <str> , S ( <str> ) . each_line . next assert_equal <str> , S ( <str> ) . each_line ( nil ) . next bug7646 = <str> assert_nothing_raised ( bug7646 ) do <str> . each_line ( <str> ) { } end end def test_lines s = S ( <str> ) assert_equal [ <str> , <str> ] , s . lines assert_equal [ <str> ] , s . lines ( nil ) if ENUMERATOR_WANTARRAY assert_warn ( <str> ) { assert_equal [ <str> , <str> ] , s . lines { } } else assert_warning ( <str> ) { res = [ ] assert_equal s . object_id , s . lines { | x | res << x } . object_id assert_equal ( S ( <str> ) , res [ <int> ] ) assert_equal ( S ( <str> ) , res [ <int> ] ) } end end def test_empty? assert_empty ( S ( <str> ) ) assert_not_empty ( S ( <str> ) ) end def test_end_with? assert_send ( [ S ( <str> ) , <str> , S ( <str> ) ] ) assert_not_send ( [ S ( <str> ) , <str> , S ( <str> ) ] ) assert_send ( [ S ( <str> ) , <str> , S ( <str> ) , S ( <str> ) ] ) bug5536 = <str> assert_raise ( TypeError , bug5536 ) { S ( <str> ) . end_with? <str> } end def test_eql? a = S ( <str> ) assert_operator ( a , <str> , S ( <str> ) ) assert_operator ( a , <str> , a ) end def test_gsub assert_equal ( S ( <str> ) , S ( <str> ) . gsub ( <str> , S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . gsub ( <str> , S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . gsub ( <str> ) { | s | s [ <int> ] . to_s + S ( <str> ) } ) assert_equal ( S ( <str> ) , S ( <str> ) . gsub ( <str> ) { | s | $1 . upcase + S ( <str> ) + $2 } ) assert_equal ( S ( <str> ) , S ( <str> ) . gsub ( S ( <str> ) , S ( <str> ) ) ) a = S ( <str> ) a . taint assert_predicate ( a . gsub ( <str> , S ( <str> ) ) , <str> ) assert_equal ( <str> , <str> . gsub ( <str> , <str> = > <str> ) , <str> ) assert_raise ( ArgumentError ) { <str> . gsub } end def test_gsub_encoding a = S ( <str> ) a . force_encoding Encoding :: UTF_8 b = S ( <str> ) b . force_encoding Encoding :: US_ASCII assert_equal Encoding :: UTF_8 , a . gsub ( <str> , b ) . encoding c = S ( <str> ) c . force_encoding Encoding :: US_ASCII assert_equal Encoding :: UTF_8 , a . gsub ( <str> , c ) . encoding assert_equal S ( <str> ) , S ( <str> ) . gsub ( <str> , <str> ) bug9849 = <str> assert_equal S ( <str> ) , S ( <str> ) . gsub ( <str> , <str> ) , bug9849 end def test_gsub! a = S ( <str> ) b = a . dup a . gsub! ( <str> , S ( <str> ) ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) a = S ( <str> ) a . gsub! ( <str> , S ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . gsub! ( <str> ) { | s | s [ <int> ] . to_s + S ( <str> ) } assert_equal ( S ( <str> ) , a ) a = S ( <str> ) a . gsub! ( <str> ) { | s | $1 . upcase + S ( <str> ) + $2 } assert_equal ( S ( <str> ) , a ) r = S ( <str> ) r . taint a . gsub! ( <str> , r ) assert_predicate ( a , <str> ) a = S ( <str> ) assert_nil ( a . sub! ( S ( <str> ) , S ( <str> ) ) ) end def test_sub_hash assert_equal ( <str> , <str> . sub ( <str> , <str> = > <str> ) ) assert_equal ( <str> , <str> . sub ( <str> , { } ) ) assert_equal ( <str> , <str> . sub ( <str> , <str> = > <int> ) ) assert_equal ( <str> , <str> . sub ( <str> , Hash . new { | h , k | k . upcase } ) ) assert_equal ( <str> , <str> . sub ( <str> , <str> = > <str> ) ) assert_equal ( <str> , <str> . sub ( <str> , Hash . new { | h , k | h [ k ] = k . upcase } ) ) assert_equal ( <str> , <str> . sub ( <str> , <str> = > <str> , <str> = > <str> ) ) end def test_gsub_hash assert_equal ( <str> , <str> . gsub ( <str> , <str> = > <str> ) ) assert_equal ( <str> , <str> . gsub ( <str> , { } ) ) assert_equal ( <str> , <str> . gsub ( <str> , <str> = > <int> ) ) assert_equal ( <str> , <str> . gsub ( <str> , Hash . new { | h , k | k . upcase } ) ) assert_equal ( <str> , <str> . gsub ( <str> , <str> = > <str> ) ) assert_equal ( <str> , <str> . gsub ( <str> , Hash . new { | h , k | h [ k ] = k . upcase } ) ) assert_equal ( <str> , <str> . gsub ( <str> , <str> = > <str> , <str> = > <str> ) ) end def test_hash assert_equal ( S ( <str> ) . hash , S ( <str> ) . hash ) assert_not_equal ( S ( <str> ) . hash , S ( <str> ) . hash ) bug4104 = <str> assert_not_equal ( S ( <str> ) . hash , S ( <str> ) . hash , bug4104 ) bug9172 = <str> assert_not_equal ( S ( <str> ) . hash , S ( <str> ) . hash , bug9172 ) end def test_hash_random str = <str> a = [ str . hash . to_s ] <int> . times { assert_in_out_err ( [ <str> , <str> str . dump <str> ] , <str> ) do | r , e | a += r assert_equal ( [ ] , e ) end } assert_not_equal ( [ str . hash . to_s ] , a . uniq ) end def test_hex assert_equal ( <int> , S ( <str> ) . hex ) assert_equal ( - <int> , S ( <str> ) . hex ) assert_equal ( <int> , S ( <str> ) . hex ) assert_equal ( - <int> , S ( <str> ) . hex ) assert_equal ( <int> , S ( <str> ) . hex ) assert_equal ( - <int> , S ( <str> ) . hex ) assert_equal ( <int> , S ( <str> ) . hex ) end def test_include? assert_include ( S ( <str> ) , <str> ) assert_include ( S ( <str> ) , S ( <str> ) ) assert_not_include ( S ( <str> ) , S ( <str> ) ) assert_not_include ( S ( <str> ) , <str> ) end def test_index assert_equal ( <int> , S ( <str> ) . index ( <str> ) ) assert_equal ( <int> , S ( <str> ) . index ( S ( <str> ) ) ) assert_equal ( <int> , S ( <str> ) . index ( <str> ) ) assert_equal ( <int> , S ( <str> ) . index ( <str> , <int> ) ) assert_equal ( <int> , S ( <str> ) . index ( S ( <str> ) , <int> ) ) assert_equal ( <int> , S ( <str> ) . index ( <str> , <int> ) ) assert_nil ( S ( <str> ) . index ( <str> , <int> ) ) assert_nil ( S ( <str> ) . index ( S ( <str> ) , <int> ) ) assert_nil ( S ( <str> ) . index ( <str> , <int> ) ) assert_nil ( S ( <str> ) . index ( <str> ) ) assert_nil ( S ( <str> ) . index ( S ( <str> ) ) ) assert_nil ( S ( <str> ) . index ( <str> ) ) assert_equal ( <int> , S ( <str> ) . index ( S ( <str> ) ) ) assert_equal ( <int> , S ( <str> ) . index ( <str> ) ) assert_nil ( S ( <str> ) . index ( S ( <str> ) ) ) assert_nil ( S ( <str> ) . index ( <str> ) ) assert_equal ( <int> , S ( <str> ) . index ( S ( <str> ) ) ) assert_equal ( <int> , S ( <str> ) . index ( <str> ) ) s = S ( <str> ) * <int> << <str> assert_nil ( s . index ( S ( <str> ) ) ) assert_equal ( <int> * <int> , s . index ( S ( <str> ) ) ) s << <str> assert_equal ( <int> * <int> , s . index ( S ( <str> ) ) ) assert_equal ( <int> * <int> , s . index ( S ( <str> ) ) ) o = Object . new def o . to_str ; <str> ; end assert_equal ( <int> , <str> . index ( o ) ) assert_raise ( TypeError ) { <str> . index ( Object . new ) } assert_nil ( <str> . index ( <str> , - <int> ) ) assert_nil ( $~ ) end def test_insert assert_equal ( <str> , S ( <str> ) . insert ( <int> , <str> ) ) assert_equal ( <str> , S ( <str> ) . insert ( <int> , <str> ) ) assert_equal ( <str> , S ( <str> ) . insert ( <int> , <str> ) ) assert_equal ( <str> , S ( <str> ) . insert ( - <int> , <str> ) ) assert_equal ( <str> , S ( <str> ) . insert ( - <int> , <str> ) ) end def test_intern assert_equal ( <str> , S ( <str> ) . intern ) assert_not_equal ( <str> , S ( <str> ) . intern ) end def test_length assert_equal ( <int> , S ( <str> ) . length ) assert_equal ( <int> , S ( <str> ) . length ) assert_equal ( <int> , S ( <str> ) . length ) assert_equal ( <int> , S ( <str> ) . length ) end def test_ljust assert_equal ( S ( <str> ) , S ( <str> ) . ljust ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . ljust ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . ljust ( <int> , <str> ) , Bug2463 ) assert_equal ( S ( <str> ) , S ( <str> ) . ljust ( <int> , <str> ) , Bug2463 ) end def test_next assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) assert_equal ( S ( <str> ) , S ( <str> ) . next ) end def test_next! a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . next! ) assert_equal ( S ( <str> ) , a ) end def test_oct assert_equal ( <int> , S ( <str> ) . oct ) assert_equal ( <int> , S ( <str> ) . oct ) assert_equal ( - <int> , S ( <str> ) . oct ) assert_equal ( - <int> , S ( <str> ) . oct ) assert_equal ( <int> , S ( <str> ) . oct ) assert_equal ( <int> , S ( <str> ) . oct ) end def test_replace a = S ( <str> ) assert_equal ( S ( <str> ) , a . replace ( S ( <str> ) ) ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . replace ( S ( <str> ) ) ) a = S ( <str> ) a . taint b = a . replace ( S ( <str> ) ) assert_equal ( S ( <str> ) , b ) assert_predicate ( b , <str> ) s = <str> * <int> s2 = ( <str> * <int> ) . dup s . replace ( s2 ) assert_equal ( s2 , s ) s2 = [ <str> ] . pack ( <str> ) s . replace ( s2 ) assert_equal ( s2 , s ) fs = <str> . freeze assert_raise ( RuntimeError ) { fs . replace ( <str> ) } assert_raise ( RuntimeError ) { fs . replace ( fs ) } assert_raise ( ArgumentError ) { fs . replace ( ) } assert_raise ( RuntimeError ) { fs . replace ( <int> ) } end def test_reverse assert_equal ( S ( <str> ) , S ( <str> ) . reverse ) assert_equal ( S ( <str> ) , S ( <str> ) . reverse ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . reverse ) assert_equal ( S ( <str> ) , a ) end def test_reverse! a = S ( <str> ) b = a . dup assert_equal ( S ( <str> ) , a . reverse! ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) assert_equal ( S ( <str> ) , S ( <str> ) . reverse! ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . reverse! ) assert_equal ( S ( <str> ) , a ) end def test_rindex assert_equal ( <int> , S ( <str> ) . rindex ( <str> ) ) assert_equal ( <int> , S ( <str> ) . rindex ( S ( <str> ) ) ) assert_equal ( <int> , S ( <str> ) . rindex ( <str> ) ) assert_equal ( <int> , S ( <str> ) . rindex ( <str> , <int> ) ) assert_equal ( <int> , S ( <str> ) . rindex ( S ( <str> ) , <int> ) ) assert_equal ( <int> , S ( <str> ) . rindex ( <str> , <int> ) ) assert_nil ( S ( <str> ) . rindex ( <str> , <int> ) ) assert_nil ( S ( <str> ) . rindex ( S ( <str> ) , <int> ) ) assert_nil ( S ( <str> ) . rindex ( <str> , <int> ) ) assert_nil ( S ( <str> ) . rindex ( <str> ) ) assert_nil ( S ( <str> ) . rindex ( S ( <str> ) ) ) assert_nil ( S ( <str> ) . rindex ( <str> ) ) o = Object . new def o . to_str ; <str> ; end assert_equal ( <int> , <str> . rindex ( o ) ) assert_raise ( TypeError ) { <str> . rindex ( Object . new ) } assert_nil ( <str> . rindex ( <str> , - <int> ) ) assert_nil ( $~ ) end def test_rjust assert_equal ( S ( <str> ) , S ( <str> ) . rjust ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . rjust ( <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . rjust ( <int> , <str> ) , Bug2463 ) assert_equal ( S ( <str> ) , S ( <str> ) . rjust ( <int> , <str> ) , Bug2463 ) end def test_scan a = S ( <str> ) assert_equal ( [ S ( <str> ) , S ( <str> ) ] , a . scan ( <str> ) ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , a . scan ( <str> ) ) assert_equal ( [ [ S ( <str> ) ] , [ S ( <str> ) ] , [ S ( <str> ) ] ] , a . scan ( <str> ) ) res = [ ] a . scan ( <str> ) { | w | res << w } assert_equal ( [ S ( <str> ) , S ( <str> ) ] , res ) res = [ ] a . scan ( <str> ) { | w | res << w } assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , res ) res = [ ] a . scan ( <str> ) { | w | res << w } assert_equal ( [ [ S ( <str> ) ] , [ S ( <str> ) ] , [ S ( <str> ) ] ] , res ) a = S ( <str> ) a . taint res = [ ] a . scan ( <str> ) { | w | res << w } assert_predicate ( res [ <int> ] , <str> , <str> ) <str> =~ a a . scan ( <str> ) assert_nil ( $~ ) <str> =~ a a . scan ( <str> ) assert_nil ( $~ ) assert_equal ( <int> , S ( <str> ) . scan ( <str> . taint ) . count ( & <str> ) ) end def test_size assert_equal ( <int> , S ( <str> ) . size ) assert_equal ( <int> , S ( <str> ) . size ) assert_equal ( <int> , S ( <str> ) . size ) assert_equal ( <int> , S ( <str> ) . size ) end def test_slice assert_equal ( <str> , S ( <str> ) . slice ( <int> ) ) assert_equal ( <str> , S ( <str> ) . slice ( - <int> ) ) assert_nil ( S ( <str> ) . slice ( <int> ) ) assert_nil ( S ( <str> ) . slice ( - <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( <int> , <int> ) ) assert_equal ( S ( S ( <str> ) ) , S ( <str> ) . slice ( - <int> , <int> ) ) assert_nil ( S ( <str> ) . slice ( <int> , <int> ) ) assert_nil ( S ( <str> ) . slice ( - <int> , <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( <int> .. <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( - <int> .. - <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( <int> .. <int> ) ) assert_nil ( S ( <str> ) . slice ( - <int> .. - <int> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( <str> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( <str> ) ) assert_nil ( S ( <str> ) . slice ( <str> ) ) assert_nil ( S ( <str> ) . slice ( <str> ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( S ( <str> ) ) ) assert_equal ( S ( <str> ) , S ( <str> ) . slice ( S ( <str> ) ) ) assert_nil ( S ( <str> ) . slice ( S ( <str> ) ) ) assert_nil ( S ( <str> ) . slice ( S ( <str> ) ) ) bug9882 = <str> substr = S ( <str> bug9882 <str> ) . slice ( <int> .. - <int> ) assert_equal ( S ( bug9882 ) . hash , substr . hash , bug9882 ) assert_predicate ( substr , <str> , bug9882 ) end def test_slice! a = S ( <str> ) b = a . dup assert_equal ( <str> , a . slice! ( <int> ) ) assert_equal ( S ( <str> ) , a ) assert_equal ( S ( <str> ) , b ) a = S ( <str> ) assert_equal ( <str> , a . slice! ( - <int> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) if @aref_slicebang_silent assert_nil ( a . slice! ( <int> ) ) else assert_raise ( IndexError ) { a . slice! ( <int> ) } end assert_equal ( S ( <str> ) , a ) if @aref_slicebang_silent assert_nil ( a . slice! ( - <int> ) ) else assert_raise ( IndexError ) { a . slice! ( - <int> ) } end assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( <int> , <int> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( - <int> , <int> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) if @aref_slicebang_silent assert_nil ( a . slice! ( <int> , <int> ) ) else assert_raise ( IndexError ) { a . slice! ( <int> , <int> ) } end assert_equal ( S ( <str> ) , a ) if @aref_slicebang_silent assert_nil ( a . slice! ( - <int> , <int> ) ) else assert_raise ( IndexError ) { a . slice! ( - <int> , <int> ) } end assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( <int> .. <int> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( - <int> .. - <int> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) if @aref_slicebang_silent assert_equal ( S ( <str> ) , a . slice! ( <int> .. <int> ) ) else assert_raise ( RangeError ) { a . slice! ( <int> .. <int> ) } end assert_equal ( S ( <str> ) , a ) if @aref_slicebang_silent assert_nil ( a . slice! ( - <int> .. - <int> ) ) else assert_raise ( RangeError ) { a . slice! ( - <int> .. - <int> ) } end assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( <str> ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) if @aref_slicebang_silent assert_nil ( a . slice! ( <str> ) ) else assert_raise ( IndexError ) { a . slice! ( <str> ) } end assert_equal ( S ( <str> ) , a ) if @aref_slicebang_silent assert_nil ( a . slice! ( <str> ) ) else assert_raise ( IndexError ) { a . slice! ( <str> ) } end assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( S ( <str> ) ) ) assert_equal ( S ( <str> ) , a ) a = S ( <str> ) assert_equal ( S ( <str> ) , a . slice! ( S ( <str> ) ) ) assert_equal ( S ( <str> ) , a ) assert_raise ( ArgumentError ) { <str> . slice! } end def test_split assert_nil ( $; ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , S ( <str> ) . split ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , S ( <str> ) . split ( S ( <str> ) ) ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , S ( <str> ) . split ( S ( <str> ) ) ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , S ( <str> ) . split ( <str> ) ) assert_equal ( [ S ( <str> ) , S ( <str> ) , S ( <str> ) ] , S ( <str> ) . split ( <str> ) ) assert_equal ( [ S ( <str> ) ] , S ( <str> ) . split ( S ( <str> ) , <int> ) ) 
