class Gem :: RequestSet :: Lockfile :: Parser def initialize tokenizer , set , platforms , filename = nil @tokens = tokenizer @filename = filename @set = set @platforms = platforms end def parse until @tokens . empty? do token = get case token . type when <str> then @tokens . skip <str> case token . value when <str> then parse_DEPENDENCIES when <str> then parse_GIT when <str> then parse_GEM when <str> then parse_PATH when <str> then parse_PLATFORMS else token = get until @tokens . empty? or peek . first == <str> end else raise <str> token . type <str> token . value . inspect <str> token . line <str> token . column <str> end end end def get expected_types = nil , expected_value = nil token = @tokens . shift if expected_types and not Array ( expected_types ) . include? token . type then unget token message = <str> token . type . inspect <str> token . value . inspect <str> + <str> expected_types . inspect <str> raise Gem :: RequestSet :: Lockfile :: ParseError . new message , token . column , token . line , @filename end if expected_value and expected_value != token . value then unget token message = <str> token . type . inspect <str> token . value . inspect <str> + <str> expected_types . inspect <str> + <str> expected_value . inspect <str> raise Gem :: RequestSet :: Lockfile :: ParseError . new message , token . column , token . line , @filename end token end def parse_DEPENDENCIES while not @tokens . empty? and <str> == peek . type do token = get <str> requirements = [ ] case peek [ <int> ] when <str> then get <str> requirements << pinned_requirement ( token . value ) when <str> then get <str> loop do op = get ( <str> ) . value version = get ( <str> ) . value requirements << <str> op <str> version <str> break unless peek . type == <str> get <str> end get <str> if peek [ <int> ] == <str> then requirements . clear requirements << pinned_requirement ( token . value ) get <str> end end @set . gem token . value , * requirements skip <str> end end def parse_GEM sources = [ ] while [ <str> , <str> ] == peek . first ( <int> ) do get <str> , <str> data = get ( <str> ) . value skip <str> sources << Gem :: Source . new ( data ) end sources << Gem :: Source . new ( Gem :: DEFAULT_HOST ) if sources . empty? get <str> , <str> skip <str> set = Gem :: Resolver :: LockSet . new sources last_specs = nil while not @tokens . empty? and <str> == peek . type do token = get <str> name = token . value column = token . column case peek [ <int> ] when <str> then last_specs . each do | spec | spec . add_dependency Gem :: Dependency . new name if column == <int> end when <str> then get <str> token = get [ <str> , <str> ] type = token . type data = token . value if type == <str> and column == <int> then version , platform = data . split <str> , <int> platform = platform ? Gem :: Platform . new ( platform ) : Gem :: Platform :: RUBY last_specs = set . add name , version , platform else dependency = parse_dependency name , data last_specs . each do | spec | spec . add_dependency dependency end end get <str> else raise <str> peek <str> end skip <str> end @set . sets << set end def parse_GIT get <str> , <str> repository = get ( <str> ) . value skip <str> get <str> , <str> revision = get ( <str> ) . value skip <str> type = peek . type value = peek . value if type == <str> and <str> . include? value then get get <str> skip <str> end get <str> , <str> skip <str> set = Gem :: Resolver :: GitSet . new set . root_dir = @set . install_dir last_spec = nil while not @tokens . empty? and <str> == peek . type do token = get <str> name = token . value column = token . column case peek [ <int> ] when <str> then last_spec . add_dependency Gem :: Dependency . new name if column == <int> when <str> then get <str> token = get [ <str> , <str> ] type = token . type data = token . value if type == <str> and column == <int> then last_spec = set . add_git_spec name , data , repository , revision , true else dependency = parse_dependency name , data last_spec . add_dependency dependency end get <str> else raise <str> peek <str> end skip <str> end @set . sets << set end def parse_PATH get <str> , <str> directory = get ( <str> ) . value skip <str> get <str> , <str> skip <str> set = Gem :: Resolver :: VendorSet . new last_spec = nil while not @tokens . empty? and <str> == peek . first do token = get <str> name = token . value column = token . column case peek [ <int> ] when <str> then last_spec . add_dependency Gem :: Dependency . new name if column == <int> when <str> then get <str> token = get [ <str> , <str> ] type = token . type data = token . value if type == <str> and column == <int> then last_spec = set . add_vendor_gem name , directory else dependency = parse_dependency name , data last_spec . dependencies << dependency end get <str> else raise <str> peek <str> end skip <str> end @set . sets << set end def parse_PLATFORMS while not @tokens . empty? and <str> == peek . first do name = get ( <str> ) . value @platforms << name skip <str> end end def parse_dependency name , op return Gem :: Dependency . new name , op unless peek [ <int> ] == <str> version = get ( <str> ) . value requirements = [ <str> op <str> version <str> ] while peek . type == <str> do get <str> op = get ( <str> ) . value version = get ( <str> ) . value requirements << <str> op <str> version <str> end Gem :: Dependency . new name , requirements end private def skip type @tokens . skip type end def peek @tokens . peek end if [ ] . respond_to? <str> def pinned_requirement name requirement = Gem :: Dependency . new name specification = @set . sets . flat_map { | set | set . find_all ( requirement ) } . compact . first specification && specification . version end else def pinned_requirement name requirement = Gem :: Dependency . new name specification = @set . sets . map { | set | set . find_all ( requirement ) } . flatten ( <int> ) . compact . first specification && specification . version end end def unget token @tokens . unshift token end end 
