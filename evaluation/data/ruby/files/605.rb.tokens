require <str> require <str> require <str> require <str> require <str> require <str> module Rex module Post module Meterpreter module Extensions module Stdapi module Railgun class MultiCaller include DLLHelper def initialize ( client , parent , win_consts ) @parent = parent @client = client @win_consts = win_consts if ( @client . platform =~ <str> ) @native = <str> else @native = <str> end end def call ( functions ) request = Packet . create_request ( <str> ) function_results = [ ] layouts = [ ] functions . each do | f | dll_name , funcname , args = f dll_host = @parent . get_dll ( dll_name ) if not dll_host raise <str> dll_name <str> end function = dll_host . functions [ funcname ] if not function raise <str> dll_name <str> funcname <str> end raise <str> function . params . length <str> args . length <str> unless args . length == function . params . length out_only_layout = { } out_only_size_bytes = <int> function . params . each_with_index do | param_desc , param_idx | if param_desc [ <int> ] [ <int> , <int> ] == <str> if args [ param_idx ] == nil next end end if param_desc [ <int> ] == <str> raise <str> param_desc [ <int> ] <str> unless args [ param_idx ] . class == Fixnum buffer_size = args [ param_idx ] if ( @native == <str> and buffer_size == <int> ) args [ param_idx ] = <int> buffer_size = args [ param_idx ] end if ( @native == <str> ) raise <str> unless buffer_size == <int> elsif ( @native == <str> ) raise <str> unless buffer_size == <int> end out_only_layout [ param_desc [ <int> ] ] = BufferItem . new ( param_idx , out_only_size_bytes , buffer_size , param_desc [ <int> ] ) out_only_size_bytes += buffer_size end end tmp = assemble_buffer ( <str> , function , args ) in_only_layout = tmp [ <int> ] in_only_buffer = tmp [ <int> ] tmp = assemble_buffer ( <str> , function , args ) inout_layout = tmp [ <int> ] inout_buffer = tmp [ <int> ] literal_pairs_blob = <str> function . params . each_with_index do | param_desc , param_idx | buffer = nil if [ <str> , <str> , <str> , <str> ] . include? param_desc [ <int> ] if args [ param_idx ] == nil buffer = [ <int> ] . pack ( @native ) buffer += [ <int> ] . pack ( @native ) elsif param_desc [ <int> ] == <str> buffer = [ <int> ] . pack ( @native ) buffer += [ in_only_layout [ param_desc [ <int> ] ] . addr ] . pack ( @native ) elsif param_desc [ <int> ] == <str> buffer = [ <int> ] . pack ( @native ) buffer += [ out_only_layout [ param_desc [ <int> ] ] . addr ] . pack ( @native ) elsif param_desc [ <int> ] == <str> buffer = [ <int> ] . pack ( @native ) buffer += [ inout_layout [ param_desc [ <int> ] ] . addr ] . pack ( @native ) else raise <str> end else buffer = [ <int> ] . pack ( @native ) case param_desc [ <int> ] when <str> , <str> num = param_to_number ( args [ param_idx ] ) buffer += [ num ] . pack ( @native ) when <str> num = param_to_number ( args [ param_idx ] ) buffer += [ num % <int> ] . pack ( @native ) when <str> num = param_to_number ( args [ param_idx ] ) buffer += [ num % <int> ] . pack ( @native ) when <str> num = param_to_number ( args [ param_idx ] ) buffer += [ num % <int> ] . pack ( @native ) when <str> case args [ param_idx ] when true buffer += [ <int> ] . pack ( <str> ) when false buffer += [ <int> ] . pack ( <str> ) else raise <str> param_desc [ <int> ] <str> end else raise <str> param_desc [ <int> ] <str> end end literal_pairs_blob += buffer end group = Rex :: Post :: Meterpreter :: GroupTlv . new ( TLV_TYPE_RAILGUN_MULTI_GROUP ) group . add_tlv ( TLV_TYPE_RAILGUN_SIZE_OUT , out_only_size_bytes ) group . add_tlv ( TLV_TYPE_RAILGUN_STACKBLOB , literal_pairs_blob ) group . add_tlv ( TLV_TYPE_RAILGUN_BUFFERBLOB_IN , in_only_buffer ) group . add_tlv ( TLV_TYPE_RAILGUN_BUFFERBLOB_INOUT , inout_buffer ) group . add_tlv ( TLV_TYPE_RAILGUN_DLLNAME , dll_name ) group . add_tlv ( TLV_TYPE_RAILGUN_FUNCNAME , function . windows_name ) request . tlvs << group layouts << [ inout_layout , out_only_layout ] end call_results = [ ] res = @client . send_request ( request ) res . each ( TLV_TYPE_RAILGUN_MULTI_GROUP ) do | val | call_results << val end functions . each do | f | dll_name , funcname , args = f dll_host = @parent . get_dll ( dll_name ) function = dll_host . functions [ funcname ] response = call_results . shift inout_layout , out_only_layout = layouts . shift rec_inout_buffers = response . get_tlv_value ( TLV_TYPE_RAILGUN_BACK_BUFFERBLOB_INOUT ) rec_out_only_buffers = response . get_tlv_value ( TLV_TYPE_RAILGUN_BACK_BUFFERBLOB_OUT ) rec_return_value = response . get_tlv_value ( TLV_TYPE_RAILGUN_BACK_RET ) rec_last_error = response . get_tlv_value ( TLV_TYPE_RAILGUN_BACK_ERR ) rec_err_msg = response . get_tlv_value ( TLV_TYPE_RAILGUN_BACK_MSG ) rec_err_msg . strip! if not rec_err_msg . nil? return_hash = { <str> = > rec_last_error , <str> = > rec_err_msg } case function . return_type when <str> , <str> if ( @native == <str> ) return_hash [ <str> ] = rec_return_value else return_hash [ <str> ] = rec_return_value % <int> end when <str> return_hash [ <str> ] = rec_return_value % <int> when <str> return_hash [ <str> ] = rec_return_value % <int> when <str> return_hash [ <str> ] = rec_return_value % <int> when <str> return_hash [ <str> ] = ( rec_return_value != <int> ) when <str> return_hash [ <str> ] = nil else raise <str> function . return_type <str> end out_only_layout . each_pair do | param_name , buffer_item | buffer = rec_out_only_buffers [ buffer_item . addr , buffer_item . length_in_bytes ] case buffer_item . datatype when <str> return_hash [ param_name ] = buffer . unpack ( <str> ) [ <int> ] when <str> return_hash [ param_name ] = asciiz_to_str ( buffer ) when <str> return_hash [ param_name ] = uniz_to_str ( buffer ) when <str> return_hash [ param_name ] = buffer else raise <str> param_name <str> buffer_item . datatype <str> end end inout_layout . each_pair do | param_name , buffer_item | buffer = rec_inout_buffers [ buffer_item . addr , buffer_item . length_in_bytes ] case buffer_item . datatype when <str> return_hash [ param_name ] = buffer . unpack ( <str> ) [ <int> ] when <str> return_hash [ param_name ] = asciiz_to_str ( buffer ) when <str> return_hash [ param_name ] = uniz_to_str ( buffer ) when <str> return_hash [ param_name ] = buffer else raise <str> param_name <str> buffer_item . datatype <str> end end function_results << return_hash end function_results end protected end end ; end ; end ; end ; end ; end 
