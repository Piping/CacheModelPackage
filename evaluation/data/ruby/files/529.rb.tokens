require <str> Puppet :: Type . newtype ( <str> ) do @doc = <str> apply_to_device ensurable do defaultvalues aliasvalue <str> , <str> aliasvalue <str> , <str> defaultto { <str> } end newparam ( <str> ) do desc <str> end newparam ( <str> ) do desc <str> end newproperty ( <str> ) do desc <str> defaultto { @resource [ <str> ] } end newproperty ( <str> ) do desc <str> newvalues ( <str> , <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> , <str> , <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> , <str> , <str> , <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> , <str> , <str> , <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> , <str> ) end newproperty ( <str> ) do desc <str> newvalues ( <str> ) end newproperty ( <str> , <str> = > <str> ) do include Puppet :: Util :: NetworkDevice :: IPCalc desc <str> validate do | values | values = [ values ] unless values . is_a? ( Array ) values . each do | value | self . fail <str> unless parse ( value . gsub ( <str> , <str> ) ) end end munge do | value | option = value =~ <str> ? value . gsub ( <str> , <str> ) : nil [ parse ( value . gsub ( <str> , <str> ) ) , option ] . flatten end def value_to_s ( value ) value = [ value ] unless value . is_a? ( Array ) value . map { | v | <str> v [ <int> ] . to_s <str> v [ <int> ] <str> v [ <int> ] <str> } . join ( <str> ) end def change_to_s ( currentvalue , newvalue ) currentvalue = value_to_s ( currentvalue ) if currentvalue != <str> newvalue = value_to_s ( newvalue ) super ( currentvalue , newvalue ) end end def present? ( current_values ) super && current_values [ <str> ] != <str> end end 
