require <str> provider_class = Puppet :: Type . type ( <str> ) . provider ( <str> ) describe provider_class , <str> = > Puppet . features . microsoft_windows? do before <str> do Puppet :: Type . type ( <str> ) . stubs ( <str> ) . returns described_class Facter . stubs ( <str> ) . with ( <str> ) . returns <str> Facter . stubs ( <str> ) . with ( <str> ) . returns <str> described_class . stubs ( <str> ) . returns ( <str> ) @provider = provider_class . new @provider . stubs ( <str> ) end describe <str> do it <str> do expect ( described_class ) . to respond_to <str> end it <str> do expect ( described_class . instances ) . to be_all { | provider | provider . get ( <str> ) == described_class . defpath } end end describe <str> do it <str> do expect ( @provider ) . to respond_to ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) Puppet :: FileSystem . stubs ( <str> ) . with ( <str> ) . returns ( true ) Puppet :: FileSystem . expects ( <str> ) . with ( <str> ) . returns ( true ) File . stubs ( <str> ) . with ( <str> ) provider . disable end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) File . stubs ( <str> ) . with ( <str> ) . returns ( false ) Puppet :: FileSystem . expects ( <str> ) . with ( <str> ) . returns ( false ) provider . disable end end describe <str> do it <str> do expect ( @provider ) . to respond_to ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) Dir . stubs ( <str> ) . with ( <str> ) fh = stub <str> File . stubs ( <str> ) . with ( <str> , File :: WRONLY | File :: APPEND | File :: CREAT , <oct> ) . yields ( fh ) fh . expects ( <str> ) . with ( <str> ) provider . enable end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) Dir . stubs ( <str> ) . with ( <str> ) File . stubs ( <str> ) . with ( <str> ) . returns ( <str> ) fh = stub <str> File . stubs ( <str> ) . with ( <str> , File :: WRONLY | File :: APPEND | File :: CREAT , <oct> ) . yields ( fh ) fh . expects ( <str> ) . with ( <str> ) provider . enable end end describe <str> do it <str> do expect ( @provider ) . to respond_to ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) Puppet :: FileSystem . stubs ( <str> ) . with ( <str> ) . returns ( false ) expect ( provider . enabled? ) . to eq ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) Puppet :: FileSystem . stubs ( <str> ) . with ( <str> ) . returns ( true ) expect ( provider . enabled? ) . to eq ( <str> ) end end describe <str> do it <str> do expect ( @provider ) . to respond_to ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> , <str> = > <str> ) ) provider . expects ( <str> ) . with ( [ <str> ] , <str> = > true , <str> = > false , <str> = > false , <str> = > true ) provider . start end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) provider . expects ( <str> ) . with ( [ <str> , <str> ] , <str> = > true , <str> = > false , <str> = > false , <str> = > true ) provider . expects ( <str> ) . with ( <str> ) . returns ( <str> ) provider . start end end describe <str> do it <str> do expect ( @provider ) . to respond_to ( <str> ) end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> , <str> = > <str> ) ) provider . expects ( <str> ) . with ( [ <str> ] , <str> = > true , <str> = > false , <str> = > false , <str> = > true ) provider . stop end it <str> do provider = described_class . new ( Puppet :: Type . type ( <str> ) . new ( <str> = > <str> ) ) provider . expects ( <str> ) . with ( [ <str> , <str> ] , <str> = > true , <str> = > false , <str> = > false , <str> = > true ) provider . expects ( <str> ) . with ( <str> ) . returns ( <str> ) provider . stop end end end 
