module ActiveRecord module Persistence extend ActiveSupport :: Concern module ClassMethods def create ( attributes = nil , & block ) if attributes . is_a? ( Array ) attributes . collect { | attr | create ( attr , & block ) } else object = new ( attributes , & block ) object . save object end end def create! ( attributes = nil , & block ) if attributes . is_a? ( Array ) attributes . collect { | attr | create! ( attr , & block ) } else object = new ( attributes , & block ) object . save! object end end def instantiate ( attributes , column_types = { } ) klass = discriminate_class_for_record ( attributes ) attributes = klass . attributes_builder . build_from_database ( attributes , column_types ) klass . allocate . init_with ( <str> = > attributes , <str> = > false ) end private def discriminate_class_for_record ( record ) self end end def new_record? sync_with_transaction_state @new_record end def destroyed? sync_with_transaction_state @destroyed end def persisted? sync_with_transaction_state ! ( @new_record || @destroyed ) end def save ( * args ) create_or_update ( * args ) rescue ActiveRecord :: RecordInvalid false end def save! ( * args ) create_or_update ( * args ) || raise ( RecordNotSaved . new ( <str> , self ) ) end def delete self . class . delete ( id ) if persisted? @destroyed = true freeze end def destroy raise ReadOnlyRecord , <str> self . class <str> if readonly? destroy_associations self . class . connection . add_transaction_record ( self ) destroy_row if persisted? @destroyed = true freeze end def destroy! destroy || _raise_record_not_destroyed end def becomes ( klass ) became = klass . new became . instance_variable_set ( <str> , @attributes ) became . instance_variable_set ( <str> , @mutation_tracker ) if defined? ( @mutation_tracker ) became . instance_variable_set ( <str> , attributes_changed_by_setter ) became . instance_variable_set ( <str> , new_record? ) became . instance_variable_set ( <str> , destroyed? ) became . errors . copy! ( errors ) became end def becomes! ( klass ) became = becomes ( klass ) sti_type = nil if ! klass . descends_from_active_record? sti_type = klass . sti_name end became . public_send ( <str> klass . inheritance_column <str> , sti_type ) became end def update_attribute ( name , value ) name = name . to_s verify_readonly_attribute ( name ) public_send ( <str> name <str> , value ) save ( <str> : false ) if changed? end def update ( attributes ) with_transaction_returning_status do assign_attributes ( attributes ) save end end alias update_attributes update def update! ( attributes ) with_transaction_returning_status do assign_attributes ( attributes ) save! end end alias update_attributes! update! def update_column ( name , value ) update_columns ( name = > value ) end def update_columns ( attributes ) raise ActiveRecordError , <str> if new_record? raise ActiveRecordError , <str> if destroyed? attributes . each_key do | key | verify_readonly_attribute ( key . to_s ) end updated_count = self . class . unscoped . where ( self . class . primary_key = > id ) . update_all ( attributes ) attributes . each do | k , v | raw_write_attribute ( k , v ) end updated_count == <int> end def increment ( attribute , by = <int> ) self [ attribute ] || = <int> self [ attribute ] += by self end def increment! ( attribute , by = <int> ) increment ( attribute , by ) change = public_send ( attribute ) - ( attribute_was ( attribute . to_s ) || <int> ) self . class . update_counters ( id , attribute = > change ) clear_attribute_change ( attribute ) self end def decrement ( attribute , by = <int> ) increment ( attribute , - by ) end def decrement! ( attribute , by = <int> ) increment! ( attribute , - by ) end def toggle ( attribute ) self [ attribute ] = ! public_send ( <str> attribute <str> ) self end def toggle! ( attribute ) toggle ( attribute ) . update_attribute ( attribute , self [ attribute ] ) end def reload ( options = nil ) self . class . connection . clear_query_cache fresh_object = if options && options [ <str> ] self . class . unscoped { self . class . lock ( options [ <str> ] ) . find ( id ) } else self . class . unscoped { self . class . find ( id ) } end @attributes = fresh_object . instance_variable_get ( <str> ) @new_record = false self end def touch ( * names , <str> : nil ) raise ActiveRecordError , <str> unless persisted? time || = current_time_from_proper_timezone attributes = timestamp_attributes_for_update_in_model attributes . concat ( names ) unless attributes . empty? changes = { } attributes . each do | column | column = column . to_s changes [ column ] = write_attribute ( column , time ) end clear_attribute_changes ( changes . keys ) primary_key = self . class . primary_key scope = self . class . unscoped . where ( primary_key = > _read_attribute ( primary_key ) ) if locking_enabled? locking_column = self . class . locking_column scope = scope . where ( locking_column = > _read_attribute ( locking_column ) ) changes [ locking_column ] = increment_lock end result = scope . update_all ( changes ) == <int> if ! result && locking_enabled? raise ActiveRecord :: StaleObjectError . new ( self , <str> ) end result else true end end private def destroy_associations end def destroy_row relation_for_destroy . delete_all end def relation_for_destroy self . class . unscoped . where ( self . class . primary_key = > id ) end def create_or_update ( * args ) raise ReadOnlyRecord , <str> self . class <str> if readonly? result = new_record? ? _create_record : _update_record ( * args ) result != false end def _update_record ( attribute_names = self . attribute_names ) attributes_values = arel_attributes_with_values_for_update ( attribute_names ) if attributes_values . empty? <int> else self . class . unscoped . _update_record attributes_values , id , id_was end end def _create_record ( attribute_names = self . attribute_names ) attributes_values = arel_attributes_with_values_for_create ( attribute_names ) new_id = self . class . unscoped . insert attributes_values self . id || = new_id if self . class . primary_key @new_record = false id end def verify_readonly_attribute ( name ) raise ActiveRecordError , <str> name <str> if self . class . readonly_attributes . include? ( name ) end def _raise_record_not_destroyed @_association_destroy_exception || = nil raise @_association_destroy_exception || RecordNotDestroyed . new ( <str> , self ) ensure @_association_destroy_exception = nil end def belongs_to_touch_method <str> end end end 
