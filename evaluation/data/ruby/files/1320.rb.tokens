load Metasploit :: Framework . root . join ( <str> ) . to_path require <str> require <str> RSpec . describe Md5LookupUtility do let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do <str> end let ( <str> ) do { <str> = > [ db_source ] , <str> = > output_file , <str> = > input_file } end subject do Md5LookupUtility :: Md5Lookup . new end def set_expected_response ( body ) res = Rex :: Proto :: Http :: Response . new res . code = <int> res . body = body res end def set_send_request_cgi ( body ) allow ( subject ) . to receive ( <str> ) do | opts | set_expected_response ( body ) end end def get_stdout ( & block ) out = $stdout $stdout = fake = StringIO . new begin yield ensure $stdout = out end fake . string end describe Md5LookupUtility :: Disclaimer do let ( <str> ) { <str> } let ( <str> ) { <str> } let ( <str> ) { true } let ( <str> ) { <str> } def stub_save ini = Rex :: Parser :: Ini . new ( t_path ) allow ( ini ) . to receive ( <str> ) . with ( any_args ) allow ( Rex :: Parser :: Ini ) . to receive ( <str> ) . and_return ( ini ) return ini end def stub_load ( with_setting = true ) if with_setting ini = stub_save disclamer . save_waiver else ini = Rex :: Parser :: Ini . new ( t_path ) end allow ( Rex :: Parser :: Ini ) . to receive ( <str> ) . and_return ( ini ) return ini end subject ( <str> ) do Md5LookupUtility :: Disclaimer . new end describe <str> do context <str> do it <str> do agree = <str> allow ( $stdin ) . to receive ( <str> ) . and_return ( agree ) get_stdout { expect ( disclamer . ack ) . to be_truthy } end end end describe <str> do context <str> do it <str> do ini = stub_save disclamer . save_waiver expect ( ini [ group_name ] ) . to eq ( { setting_name = > true } ) end end end describe <str> do context <str> do it <str> do ini = stub_load ( true ) expect ( disclamer . send ( <str> ) ) . to be_truthy end end context <str> do it <str> do ini = stub_load ( false ) expect ( disclamer . send ( <str> ) ) . to be_falsey end end end describe <str> do context <str> do it <str> do ini = stub_save disclamer . send ( <str> , setting_name , data ) expect ( ini [ group_name ] ) . to eq ( { setting_name = > true } ) end end end describe <str> do end end describe Md5LookupUtility :: Md5Lookup do describe <str> do it <str> do expect ( subject ) . to be_a ( Md5LookupUtility :: Md5Lookup ) end end describe <str> do context <str> do it <str> do set_send_request_cgi ( good_json_response ) expect ( subject . lookup ( input_data , db_source ) ) . to eq ( good_result ) end end context <str> do it <str> do set_send_request_cgi ( bad_json_response ) expect ( subject . lookup ( input_data , db_source ) ) . to eq ( empty_result ) end end end describe <str> do context <str> do it <str> do res = set_expected_response ( good_json_response ) expect ( subject . send ( <str> , res ) ) . to eq ( good_result ) end end context <str> do it <str> do res = set_expected_response ( <str> ) expect ( subject . send ( <str> , res ) ) . to eq ( empty_result ) end end end end describe Md5LookupUtility :: Driver do let ( <str> ) { { <str> = > input_data , <str> = > good_result , <str> = > db_source } } before ( <str> ) do expect ( Md5LookupUtility :: OptsConsole ) . to receive ( <str> ) . with ( any_args ) . and_return ( options ) allow ( File ) . to receive ( <str> ) . with ( input_file , <str> ) . and_yield ( StringIO . new ( input_data ) ) allow ( File ) . to receive ( <str> ) . with ( output_file , <str> ) . and_return ( StringIO . new ) end subject do Md5LookupUtility :: Driver . new end describe <str> do it <str> do expect ( subject ) . to be_a ( Md5LookupUtility :: Driver ) end end describe <str> do context <str> do it <str> do disclaimer = Md5LookupUtility :: Disclaimer . new allow ( disclaimer ) . to receive ( <str> ) . and_return ( true ) allow ( Md5LookupUtility :: Disclaimer ) . to receive ( <str> ) . and_return ( disclaimer ) allow ( subject ) . to receive ( <str> ) . and_yield ( expected_result ) output = get_stdout { subject . run } expect ( output ) . to include ( <str> ) end end end describe <str> do context <str> do it <str> do subject . send ( <str> , expected_result ) expect ( subject . instance_variable_get ( <str> ) . string ) . to include ( good_result ) end end end describe <str> do context <str> do it <str> do search_engine = Md5LookupUtility :: Md5Lookup . new allow ( search_engine ) . to receive ( <str> ) . and_return ( good_result ) allow ( Md5LookupUtility :: Md5Lookup ) . to receive ( <str> ) . and_return ( search_engine ) expect { | b | subject . send ( <str> , input_file , [ db_source ] , & b ) } . to yield_with_args ( expected_result ) end end end describe <str> do context <str> do it <str> do expect { | b | subject . send ( <str> , input_file , & b ) } . to yield_with_args ( input_data ) end end context <str> do before do allow ( File ) . to receive ( <str> ) . with ( input_file , <str> ) . and_yield ( StringIO . new ( <str> ) ) end it <str> do expect { | b | subject . send ( <str> , input_file , & b ) } . not_to yield_control end end end describe <str> do context <str> do it <str> do expect ( subject . send ( <str> , input_data ) ) . to be_truthy end end context <str> do it <str> do expect ( subject . send ( <str> , bad_input_data ) ) . to be_falsey end end end end describe Md5LookupUtility :: OptsConsole do let ( <str> ) { <str> input_file <str> output_file <str> . split } let ( <str> ) { <str> . split } subject do Md5LookupUtility :: OptsConsole end describe <str> do context <str> do let ( <str> ) { subject . parse ( valid_argv ) } before ( <str> ) do allow ( File ) . to receive ( <str> ) . and_return ( true ) end it <str> do expect ( opts [ <str> ] ) . to eq ( input_file ) end it <str> do expect ( opts [ <str> ] ) . to eq ( output_file ) end it <str> do expect ( opts [ <str> ] ) . to be_a ( Array ) expect ( opts [ <str> ] ) . to include ( db_source ) end end context <str> do before ( <str> ) do allow ( File ) . to receive ( <str> ) . and_return ( false ) end it <str> do expect { subject . parse ( invalid_argv ) } . to raise_error ( OptionParser :: MissingArgument ) end end end describe <str> do let ( <str> ) { <str> } context <str> do it <str> do db_names = subject . extract_db_names ( list ) expect ( db_names ) . to be_a ( Array ) expect ( db_names ) . to include ( db_source ) end end end describe <str> do it <str> do expect ( subject . get_database_symbols ) . to be_a ( Array ) end end describe <str> do it <str> do expect ( subject . get_database_names ) . to be_a ( Array ) end end end end 
