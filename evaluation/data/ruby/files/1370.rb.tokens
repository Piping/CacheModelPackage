require <str> describe ColorSchemeRevisor do let ( <str> ) { Fabricate . build ( <str> , <str> : <str> , <str> : nil ) } let ( <str> ) { Fabricate ( <str> , <str> : false , <str> : <int> . day . ago , <str> : <int> . day . ago , <str> : [ color ] ) } let ( <str> ) { { name : color_scheme . name , <str> : color_scheme . enabled , <str> : nil } } describe <str> do it <str> do expect { described_class . revise ( color_scheme , valid_params . merge ( <str> : nil ) ) } . to_not change { color_scheme . reload . updated_at } end it <str> do described_class . revise ( color_scheme , valid_params . merge ( name : <str> ) ) expect ( color_scheme . reload . name ) . to eq ( <str> ) end it <str> do described_class . revise ( color_scheme , valid_params . merge ( <str> : true ) ) expect ( color_scheme . reload ) . to be_enabled described_class . revise ( color_scheme , valid_params . merge ( <str> : false ) ) expect ( color_scheme . reload ) . not_to be_enabled end def test_color_change ( color_scheme_arg , expected_enabled ) described_class . revise ( color_scheme_arg , valid_params . merge ( <str> : [ { name : color . name , <str> : <str> } ] ) ) color_scheme_arg . reload expect ( color_scheme_arg . enabled ) . to eq ( expected_enabled ) expect ( color_scheme_arg . colors . size ) . to eq ( <int> ) expect ( color_scheme_arg . colors . first . hex ) . to eq ( <str> ) end it <str> do test_color_change ( color_scheme , false ) end it <str> do color_scheme . update_attribute ( <str> , true ) test_color_change ( color_scheme , true ) end it <str> do prev_enabled = Fabricate ( <str> , <str> : true ) described_class . revise ( color_scheme , valid_params . merge ( <str> : true ) ) expect ( prev_enabled . reload . enabled ) . to eq ( false ) expect ( color_scheme . reload . enabled ) . to eq ( true ) end it <str> do expect { cs = described_class . revise ( color_scheme , valid_params . merge ( <str> : [ { name : color . name , <str> : <str> } ] ) ) expect ( cs ) . not_to be_valid expect ( cs . errors ) . to be_present } . to_not change { color_scheme . reload . version } expect ( color_scheme . colors . first . hex ) . to eq ( color . hex ) end describe <str> do it <str> do expect { described_class . revise ( color_scheme , valid_params . merge ( name : <str> ) ) } . to_not change { color_scheme . reload . version } end it <str> do old_hex = color . hex expect { described_class . revise ( color_scheme , valid_params . merge ( <str> : [ { name : color . name , <str> : <str> } ] ) ) } . to change { color_scheme . reload . version } . by ( <int> ) old_version = ColorScheme . find_by ( <str> : color_scheme . id , <str> : ( color_scheme . version - <int> ) ) expect ( old_version ) . not_to eq ( nil ) expect ( old_version . colors . count ) . to eq ( color_scheme . colors . count ) expect ( old_version . colors_by_name [ color . name ] . hex ) . to eq ( old_hex ) expect ( color_scheme . colors_by_name [ color . name ] . hex ) . to eq ( <str> ) end it <str> do expect { described_class . revise ( color_scheme , valid_params . merge ( <str> : [ { name : color . name , <str> : color . hex } ] ) ) } . to_not change { color_scheme . reload . version } end end end describe <str> do context <str> do it <str> do expect { expect ( described_class . revert ( color_scheme ) ) . to eq ( color_scheme ) } . to_not change { color_scheme . reload . version } end end context <str> do let ( <str> ) { { name : color . name , <str> : <str> } } before do @prev_hex = color . hex described_class . revise ( color_scheme , valid_params . merge ( <str> : [ new_color_params ] ) ) end it <str> do expect ( color_scheme . colors_by_name [ new_color_params [ <str> ] ] . hex ) . to eq ( new_color_params [ <str> ] ) expect { described_class . revert ( color_scheme ) } . to change { color_scheme . reload . version } . by ( - <int> ) expect ( color_scheme . colors . size ) . to eq ( <int> ) expect ( color_scheme . colors . first . hex ) . to eq ( @prev_hex ) expect ( color_scheme . colors_by_name [ new_color_params [ <str> ] ] . hex ) . to eq ( @prev_hex ) end it <str> do expect { described_class . revert ( color_scheme ) } . to change { ColorScheme . count } . by ( - <int> ) expect ( color_scheme . reload . previous_version ) . to eq ( nil ) end end end end 
