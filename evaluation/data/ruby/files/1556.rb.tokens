require <str> require <str> require <str> describe <str> , <str> : <str> do with_reset_sandbox_before_each def self . pending_for_travis_mysql! before do if ENV [ <str> ] && ENV [ <str> ] == <str> skip <str> end end end before do target_and_login runner = bosh_runner_in_work_dir ( ClientSandbox . test_release_dir ) runner . run ( <str> ) runner . run ( <str> ) runner . run ( <str> ) runner . run ( <str> spec_asset ( <str> ) <str> ) cloud_config_manifest = yaml_file ( <str> , Bosh :: Spec :: Deployments . simple_cloud_config ) bosh_runner . run ( <str> cloud_config_manifest . path <str> ) deployment_hash = Bosh :: Spec :: Deployments . simple_manifest deployment_hash [ <str> ] [ <int> ] [ <str> ] = <int> deployment_manifest = yaml_file ( <str> , deployment_hash ) runner . run ( <str> deployment_manifest . path <str> ) runner . run ( <str> ) end describe <str> do before { current_sandbox . scheduler_process . start } after { current_sandbox . scheduler_process . stop } it <str> do waiter . wait ( <int> ) { expect ( snapshots ) . to_not be_empty } keys = <str> snapshots . each do | snapshot | json = JSON . parse ( File . read ( snapshot ) ) expect ( json . keys - keys ) . to be_empty end end def snapshots Dir [ File . join ( current_sandbox . agent_tmp_path , <str> , <str> ) ] end end describe <str> do pending_for_travis_mysql! before { current_sandbox . scheduler_process . start } after { current_sandbox . scheduler_process . stop } it <str> do waiter . wait ( <int> ) { expect ( backups ) . to_not be_empty } end def backups Dir [ File . join ( current_sandbox . sandbox_root , <str> , <str> ) ] end end describe <str> do pending_for_travis_mysql! after { FileUtils . rm_f ( tmp_dir ) } let ( <str> ) { Dir . mktmpdir ( <str> ) } it <str> do runner = bosh_runner_in_work_dir ( tmp_dir ) expect ( runner . run ( <str> ) ) . to match ( <str> ) backup_file = Bosh :: Spec :: TarFileInspector . new ( <str> tmp_dir <str> ) expect ( backup_file . file_names ) . to match_array ( <str> ) expect ( backup_file . smallest_file_size ) . to be > <int> end end end 
