require <str> require <str> require <str> require <str> class Puppet :: Resource :: Type Puppet :: ResourceType = self include Puppet :: Util :: Warnings include Puppet :: Util :: Errors RESOURCE_KINDS = [ <str> , <str> , <str> , <str> , <str> , <str> ] RESOURCE_KINDS_TO_EXTERNAL_NAMES = { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } RESOURCE_EXTERNAL_NAMES_TO_KINDS = RESOURCE_KINDS_TO_EXTERNAL_NAMES . invert NAME = <str> . freeze TITLE = <str> . freeze MODULE_NAME = <str> . freeze CALLER_MODULE_NAME = <str> . freeze PARAMETERS = <str> . freeze KIND = <str> . freeze NODES = <str> . freeze DOUBLE_COLON = <str> . freeze EMPTY_ARRAY = [ ] . freeze attr_accessor <str> , <str> , <str> , <str> , <str> , <str> attr_reader <str> , <str> , <str> , <str> attr_reader <str> attr_reader <str> RESOURCE_KINDS . each do | t | define_method ( <str> t <str> ) { self . type == t } end require <str> extend Puppet :: Indirector indirects <str> , <str> = > <str> def self . from_data_hash ( data ) name = data . delete ( NAME ) or raise ArgumentError , <str> kind = data . delete ( KIND ) || <str> unless type = RESOURCE_EXTERNAL_NAMES_TO_KINDS [ kind ] raise ArgumentError , <str> kind <str> end data = data . inject ( { } ) { | result , ary | result [ ary [ <int> ] . intern ] = ary [ <int> ] ; result } data [ <str> ] = data . delete ( <str> ) new ( type , name , data ) end def to_data_hash data = [ <str> , <str> , <str> , <str> ] . inject ( { } ) do | hash , param | next hash unless ( value = self . send ( param ) ) and ( value != <str> ) hash [ param . to_s ] = value hash end data [ PARAMETERS ] = Hash [ arguments . map do | k , v | [ k , v . respond_to? ( <str> ) ? v . source_text : v ] end ] data [ NAME ] = name unless RESOURCE_KINDS_TO_EXTERNAL_NAMES . has_key? ( type ) raise ArgumentError , <str> type <str> end data [ KIND ] = RESOURCE_KINDS_TO_EXTERNAL_NAMES [ type ] data end def child_of? ( klass ) return false unless parent return ( klass == parent_type ? true : parent_type . child_of? ( klass ) ) end def evaluate_produces ( resource , scope ) return unless definition? || hostclass? resource . export . map do | ex | raise Puppet :: Error , <str> resource . ref <str> ex <str> unless ex . is_a? ( Puppet :: Resource ) raise Puppet :: Error , <str> resource . ref <str> ex <str> if ex . resource_type . nil? || ! ex . resource_type . is_capability? blueprint = produces . find { | pr | pr [ <str> ] == ex . type } if blueprint . nil? raise Puppet :: ParseError , <str> resource . type <str> ex . type <str> end produced_resource = Puppet :: Parser :: Resource . new ( ex . type , ex . title , <str> = > scope , <str> = > self ) produced_resource . resource_type . parameters . each do | name | next if name == <str> if expr = blueprint [ <str> ] [ name . to_s ] produced_resource [ name ] = expr . safeevaluate ( scope ) else produced_resource [ name ] = scope [ name . to_s ] end end produced_resource . tag ( <str> scope . catalog . environment <str> ) scope . catalog . add_resource ( produced_resource ) produced_resource [ <str> ] = resource . ref produced_resource end end def evaluate_code ( resource ) static_parent = evaluate_parent_type ( resource ) scope = static_parent || resource . scope scope = scope . newscope ( <str> = > namespace , <str> = > self , <str> = > resource ) unless resource . title == <str> scope . compiler . add_class ( name ) unless definition? set_resource_parameters ( resource , scope ) resource . add_edge_to_stage evaluate_produces ( resource , scope ) if code if @match scope . with_guarded_scope do scope . ephemeral_from ( @match , file , line ) code . safeevaluate ( scope ) end else code . safeevaluate ( scope ) end end end def initialize ( type , name , options = { } ) @type = type . to_s . downcase . to_sym raise ArgumentError , <str> type <str> unless RESOURCE_KINDS . include? ( @type ) name = convert_from_ast ( name ) if name . is_a? ( Puppet :: Parser :: AST :: HostName ) set_name_and_namespace ( name ) [ <str> , <str> , <str> , <str> , <str> ] . each do | param | next unless value = options [ param ] send ( param . to_s + <str> , value ) end set_arguments ( options [ <str> ] ) set_argument_types ( options [ <str> ] ) @match = nil @module_name = options [ <str> ] end def produces @produces || EMPTY_ARRAY end def consumes @consumes || EMPTY_ARRAY end def add_produces ( blueprint ) @produces || = [ ] @produces << blueprint end def add_consumes ( blueprint ) @consumes || = [ ] @consumes << blueprint end def match ( string ) return string . to_s . downcase == name unless name_is_regex? @match = @name . match ( string ) end def merge ( other ) fail <str> name <str> unless type == <str> fail <str> other . name <str> unless other . type == <str> fail <str> if name == <str> and Puppet . settings [ <str> ] if parent and other . parent and parent != other . parent fail <str> name <str> parent <str> other . name <str> other . parent <str> end self . parent || = other . parent if other . doc self . doc || = <str> self . doc += other . doc end return unless other . code unless self . code self . code = other . code return end self . code = Puppet :: Parser :: ParserFactory . code_merger . concatenate ( [ self , other ] ) end def ensure_in_catalog ( scope , parameters = nil ) resource_type = case type when <str> raise ArgumentError , <str> when <str> <str> when <str> <str> when <str> <str> end if parameters . nil? resource = scope . catalog . resource ( resource_type , name ) return resource unless resource . nil? elsif parameters . is_a? ( Hash ) parameters = parameters . map { | k , v | Puppet :: Parser :: Resource :: Param . new ( <str> = > k , <str> = > v , <str> = > self ) } end resource = Puppet :: Parser :: Resource . new ( resource_type , name , <str> = > scope , <str> = > self , <str> = > parameters ) instantiate_resource ( scope , resource ) scope . compiler . add_resource ( scope , resource ) resource end def instantiate_resource ( scope , resource ) if parent && ! scope . catalog . resource ( resource . type , parent ) parent_type ( scope ) . ensure_in_catalog ( scope ) end if [ <str> , <str> ] . include? resource . type scope . catalog . tag ( * resource . tags ) end end def name if type == <str> && name_is_regex? <str> @name . source . downcase . gsub ( <str> , <str> ) . sub ( <str> , <str> ) <str> else @name end end def name_is_regex? @name . is_a? ( Regexp ) end def assign_parameter_values ( parameters , resource ) Puppet . deprecation_warning ( <str> ) return unless parameters parameters . each do | name , value | resource . set_parameter name , value end end def parent_type ( scope = nil ) return nil unless parent @parent_type || = scope . environment . known_resource_types . send ( <str> type <str> , parent ) || fail ( Puppet :: ParseError , <str> parent <str> type <str> scope . environment <str> ) end def set_resource_parameters ( resource , scope ) modname = resource [ <str> ] || module_name scope [ MODULE_NAME ] = modname unless modname . nil? caller_name = resource [ <str> ] || scope . parent_module_name scope [ CALLER_MODULE_NAME ] = caller_name unless caller_name . nil? resource . add_parameters_from_consume inject_external_parameters ( resource , scope ) if @type == <str> scope [ TITLE ] = resource . title . to_s . downcase scope [ NAME ] = resource . name . to_s . downcase else scope [ TITLE ] = resource . title scope [ NAME ] = resource . name end scope . class_set ( self . name , scope ) if hostclass? || node? param_hash = scope . with_parameter_scope ( arguments . keys ) do | param_scope | resource . each { | k , v | param_scope [ k . to_s ] = v . value unless k == <str> || k == <str> } assign_defaults ( resource , param_scope , scope ) param_scope . to_hash end validate_resource_hash ( resource , param_hash ) param_hash . each { | param , value | exceptwrap { scope [ param ] = value } } end def inject_external_parameters ( resource , scope ) return unless type == <str> parameters = resource . parameters arguments . each do | param_name , default | sym_name = param_name . to_sym param = parameters [ sym_name ] next unless param . nil? || param . value . nil? catch ( <str> ) do bound_value = Puppet :: Pops :: Lookup . search_and_merge ( <str> name <str> param_name <str> , Puppet :: Pops :: Lookup :: Invocation . new ( scope ) , nil ) resource [ sym_name ] = bound_value unless bound_value . nil? && ! default . nil? end end end private <str> def assign_defaults ( resource , param_scope , scope ) return unless resource . is_a? ( Puppet :: Parser :: Resource ) parameters = resource . parameters arguments . each do | param_name , default | next if default . nil? name = param_name . to_sym param = parameters [ name ] next unless param . nil? || param . value . nil? value = exceptwrap { param_scope . evaluate3x ( param_name , default , scope ) } resource [ name ] = value param_scope [ param_name ] = value end end private <str> def validate_resource_hash ( resource , resource_hash ) Puppet :: Pops :: Types :: TypeMismatchDescriber . validate_parameters ( resource . to_s , parameter_struct , resource_hash , resource . is_unevaluated_consumer? ) end private <str> def validate_resource ( resource ) validate_resource_hash ( resource , Hash [ resource . parameters . map { | name , value | [ name . to_s , value . value ] } ] ) end def valid_parameter? ( param ) parameter_struct . hashed_elements . include? ( param . to_s ) end def set_arguments ( arguments ) @arguments = { } @parameter_struct = nil return if arguments . nil? arguments . each do | arg , default | arg = arg . to_s warn_if_metaparam ( arg , default ) @arguments [ arg ] = default end end def set_argument_types ( name_to_type_hash ) @argument_types = { } @parameter_struct = nil return unless name_to_type_hash name_to_type_hash . each do | name , t | unless @arguments . include? ( name ) raise Puppet :: DevError , <str> name <str> end unless t . is_a? Puppet :: Pops :: Types :: PAnyType raise Puppet :: DevError , <str> name <str> t . class <str> end @argument_types [ name ] = t end end def is_capability? false end private def convert_from_ast ( name ) value = name . value if value . is_a? ( Puppet :: Parser :: AST :: Regex ) name = value . value else name = value end end def evaluate_parent_type ( resource ) return unless klass = parent_type ( resource . scope ) and parent_resource = resource . scope . compiler . catalog . resource ( <str> , klass . name ) || resource . scope . compiler . catalog . resource ( <str> , klass . name ) parent_resource . evaluate unless parent_resource . evaluated? parent_scope ( resource . scope , klass ) end def namesplit ( fullname ) ary = fullname . split ( DOUBLE_COLON ) n = ary . pop || <str> ns = ary . join ( DOUBLE_COLON ) return ns , n end def parent_scope ( scope , klass ) scope . class_scope ( klass ) || raise ( Puppet :: DevError , <str> klass . name <str> ) end def set_name_and_namespace ( name ) if name . is_a? ( Regexp ) @name = name @namespace = <str> else @name = name . to_s . downcase @namespace , ignored_shortname = @type == <str> ? [ @name , <str> ] : namesplit ( @name ) end end def warn_if_metaparam ( param , default ) return unless Puppet :: Type . metaparamclass ( param ) if default warnonce <str> param <str> self . name <str> else raise Puppet :: ParseError , <str> param <str> self . name <str> end end def parameter_struct @parameter_struct || = create_params_struct end def create_params_struct arg_types = argument_types type_factory = Puppet :: Pops :: Types :: TypeFactory members = { type_factory . optional ( type_factory . string ( nil , NAME ) ) = > type_factory . any } if application? resource_type = type_factory . type_type ( type_factory . resource ) members [ type_factory . optional ( type_factory . string ( nil , NODES ) ) ] = type_factory . hash_of ( type_factory . variant ( resource_type , type_factory . array_of ( resource_type ) ) , type_factory . type_type ( type_factory . resource ( <str> ) ) ) end Puppet :: Type . eachmetaparam do | name | members [ name . to_s ] = type_factory . any end arguments . each_pair do | name , default | key_type = type_factory . string ( nil , name . to_s ) key_type = type_factory . optional ( key_type ) unless default . nil? arg_type = arg_types [ name ] arg_type = type_factory . any if arg_type . nil? members [ key_type ] = arg_type end type_factory . struct ( members ) end private <str> end 
