require <str> module Rex module Parser load_nokogiri && class MbsaDocument < Nokogiri :: XML :: SAX :: Document include NokogiriDocMixin def start_element ( name = nil , attrs = [ ] ) attrs = normalize_attrs ( attrs ) block = @block @state [ <str> ] [ name ] = true case name when <str> record_host ( attrs ) when <str> when <str> record_check ( attrs ) when <str> @state [ <str> ] = true when <str> record_detail ( attrs ) when <str> record_updatedata ( attrs ) when <str> @state [ <str> ] = true when <str> @state [ <str> ] = true end end def characters ( text ) return unless @state [ <str> ] @text || = <str> @text << text end def end_element ( name = nil ) block = @block case name when <str> collect_host_data host_object = report_host & block if host_object db . report_import_note ( @args [ <str> ] , host_object ) report_fingerprint ( host_object ) report_vulns ( host_object , & block ) end @state . delete_if { | k | k != <str> } when <str> collect_check_data when <str> @state [ <str> ] = false collect_advice_data when <str> collect_detail_data when <str> collect_updatedata when <str> @state [ <str> ] = false collect_title when <str> collect_url @state [ <str> ] = false end @state [ <str> ] . delete name end def report_fingerprint ( host_object ) return unless host_object . kind_of? :: Mdm :: Host return unless @report_data [ <str> ] fp_note = @report_data [ <str> ] . merge ( { <str> = > host_object . workspace , <str> = > host_object } ) db_report ( <str> , fp_note ) end def collect_url return unless in_tag ( <str> ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) @state [ <str> ] [ <str> ] = @text . to_s . strip @text = nil end def report_vulns ( host_object , & block ) return unless host_object . kind_of? :: Mdm :: Host return unless @report_data [ <str> ] return if @report_data [ <str> ] . empty? @report_data [ <str> ] . each do | vuln | next unless vuln [ <str> ] if vuln [ <str> ] . empty? next end if block db . emit ( <str> , [ <str> vuln [ <str> ] <str> , <int> ] , & block ) if block end db_report ( <str> , vuln . merge ( <str> = > host_object ) ) end end def collect_title return unless in_tag ( <str> ) return unless in_tag ( <str> ) collect_bulletin_title @text = nil end def collect_bulletin_title return unless @state [ <str> ] [ <str> ] == <int> . to_s return unless in_tag ( <str> ) return unless @state [ <str> ] return if @text . to_s . strip . empty? @state [ <str> ] [ <str> ] = @text . to_s . strip end def collect_updatedata return unless in_tag ( <str> ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) collect_missing_update @state [ <str> ] = { } end def collect_missing_update return unless @state [ <str> ] [ <str> ] == <int> . to_s return if @state [ <str> ] [ <str> ] == <str> @report_data [ <str> ] || = [ ] this_update = { } this_update [ <str> ] = @state [ <str> ] [ <str> ] . to_s . strip this_update [ <str> ] = [ ] if @state [ <str> ] [ <str> ] . empty? this_update [ <str> ] << <str> @state [ <str> ] [ <str> ] <str> else this_update [ <str> ] << <str> @state [ <str> ] [ <str> ] <str> end @report_data [ <str> ] << this_update end def collect_advice_data return unless in_tag ( <str> ) return unless in_tag ( <str> ) collect_os_name @text = nil end def collect_os_name return unless @state [ <str> ] [ <str> ] == <int> . to_s return unless @text return if @text . strip . empty? os_match = @text . match ( <str> ) return unless os_match os_info = os_match [ <int> ] os_vendor = os_info [ <str> ] os_family = os_info [ <str> ] os_version = os_info [ <str> ] if os_info @report_data [ <str> ] = { } @report_data [ <str> ] [ <str> ] = <str> @report_data [ <str> ] [ <str> ] = { <str> = > os_vendor , <str> = > os_family , <str> = > os_version , <str> = > <int> , <str> = > os_info . gsub ( <str> , <str> ) } end end def collect_detail_data return unless in_tag ( <str> ) return unless in_tag ( <str> ) if @report_data [ <str> ] @report_data [ <str> ] = @report_data [ <str> ] end end def collect_check_data return unless in_tag ( <str> ) @state [ <str> ] = { } end def collect_host_data return unless @state [ <str> ] return if @state [ <str> ] . strip . empty? @report_data [ <str> ] = @state [ <str> ] . strip if @state [ <str> ] && ! @state [ <str> ] . empty? @report_data [ <str> ] = @state [ <str> ] end @report_data [ <str> ] = Msf :: HostState :: Alive end def report_host ( & block ) if host_is_okay db . emit ( <str> , @report_data [ <str> ] , & block ) if block host_info = @report_data . merge ( <str> = > @args [ <str> ] ) db_report ( <str> , host_info ) end end def record_updatedata ( attrs ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) update_attrs = attr_hash ( attrs ) @state [ <str> ] = attr_hash ( attrs ) end def record_host ( attrs ) host_attrs = attr_hash ( attrs ) @state [ <str> ] = host_attrs [ <str> ] @state [ <str> ] = host_attrs [ <str> ] end def record_check ( attrs ) return unless in_tag ( <str> ) @state [ <str> ] = attr_hash ( attrs ) end def record_detail ( attrs ) return unless in_tag ( <str> ) return unless in_tag ( <str> ) @state [ <str> ] = attr_hash ( attrs ) end def host_is_okay return false unless @report_data [ <str> ] return false unless valid_ip ( @report_data [ <str> ] ) return false unless @report_data [ <str> ] == Msf :: HostState :: Alive if @args [ <str> ] return false if @args [ <str> ] . include? ( @report_data [ <str> ] ) end return true end end end end 
