if defined? ( $ttkpane_demo ) && $ttkpane_demo $ttkpane_demo . destroy $ttkpane_demo = nil end $ttkpane_demo = TkToplevel . new { | w | title ( <str> ) iconname ( <str> ) positionWindow ( w ) } base_frame = TkFrame . new ( $ttkpane_demo ) . pack ( <str> = > <str> , <str> = > true ) Ttk :: Label . new ( base_frame , <str> = > $font , <str> = > <str> , <str> = > <str> , <str> = > << <str> EOL <str> ) . pack ( <str> = > <str> , <str> = > <str> ) <str> EOL Ttk :: Separator . new ( base_frame ) . pack ( <str> = > <str> , <str> = > <str> ) Ttk :: Frame . new ( base_frame ) { | frame | sep = Ttk :: Separator . new ( frame ) Tk . grid ( sep , <str> = > <int> , <str> = > <int> , <str> = > <str> , <str> = > <int> ) TkGrid ( <str> , Ttk :: Button . new ( frame , <str> = > <str> , <str> = > $image [ <str> ] , <str> = > <str> , <str> = > proc { showCode <str> } ) , Ttk :: Button . new ( frame , <str> = > <str> , <str> = > $image [ <str> ] , <str> = > <str> , <str> = > proc { $ttkpane_demo . destroy $ttkpane_demo = nil } ) , <str> = > <int> , <str> = > <int> ) grid_columnconfigure ( <int> , <str> = > <int> ) pack ( <str> = > <str> , <str> = > <str> ) } frame = Ttk :: Frame . new ( base_frame ) . pack ( <str> = > <str> , <str> = > true ) outer = Ttk :: Panedwindow . new ( frame , <str> = > <str> ) outer . add ( in_left = Ttk :: Panedwindow . new ( outer , <str> = > <str> ) ) outer . add ( in_right = Ttk :: Panedwindow . new ( outer , <str> = > <str> ) ) in_left . add ( left_top = Ttk :: Labelframe . new ( in_left , <str> = > <str> ) ) in_left . add ( left_bot = Ttk :: Labelframe . new ( in_left , <str> = > <str> ) ) in_right . add ( right_top = Ttk :: Labelframe . new ( in_right , <str> = > <str> ) ) in_right . add ( right_bot = Ttk :: Labelframe . new ( in_right , <str> = > <str> ) ) if Tk . windowingsystem == <str> [ left_top , left_bot , right_top , right_bot ] . each { | w | w . padding ( <int> ) } end Ttk :: Button . new ( left_top , <str> = > <str> , <str> = > proc { Tk . messageBox ( <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > base_frame , <str> = > <str> ) } ) . pack ( <str> = > <int> , <str> = > <int> ) zones_list = [ [ <str> ] , [ <str> , <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , ] zones = [ ] if $tk_major_ver > <int> || ( $tk_major_ver == <int> && $tk_minor_ver > = <int> ) tzinfo = <str> zones_list . each { | list | list . each { | zone | begin Tk . tk_call ( <str> , <str> , <str> , <str> , zone ) rescue RuntimeError else zones << [ zone , zone [ <str> ] . tr ( <str> , <str> ) ] break end } } else begin require <str> tzinfo = <str> rescue Exception begin require <str> tzinfo = <str> rescue Exception tzinfo = nil end end case tzinfo when <str> zones_list . each { | list | list . each { | zone | begin tz = TZInfo :: Timezone . get ( zone [ <str> ] ) rescue Exception else zones << [ tz , zone [ <str> ] . tr ( <str> , <str> ) ] break end } } when <str> zones_list . each { | list | list . each { | zone | begin tz = TZFile . create ( zone [ <str> ] ) rescue Exception else zones << [ tz , zone [ <str> ] . tr ( <str> , <str> ) ] break end } } else [ - <int> , - <int> , - <int> , - <int> , <int> , + <int> , + <int> , + <int> , + <int> , + <int> ] . each { | zone | zones << [ zone , <str> % zone ] } end end time = TkVariable . new_hash case tzinfo when <str> update_proc = proc { | now , tz , label | time [ label ] = Tk . tk_call ( <str> , <str> , now . tv_sec , <str> , tz , <str> , <str> ) } when <str> update_proc = proc { | now , tz , label | time [ label ] = tz . utc_to_local ( now ) . strftime ( <str> ) } when <str> update_proc = proc { | now , tz , label | time [ label ] = tz . at ( now . tv_sec ) . strftime ( <str> ) } else update_proc = proc { | now , tz , label | time [ label ] = ( now + ( tz * <int> ) ) . strftime ( <str> ) } end zones . each_with_index { | ( zone , label ) , idx | Ttk :: Separator . new ( left_bot ) . pack ( <str> = > <str> ) if idx > <int> Ttk :: Label . new ( left_bot , <str> = > label , <str> = > <str> ) . pack ( <str> = > <str> ) Ttk :: Label . new ( left_bot , <str> = > time . ref ( label ) , <str> = > <str> ) . pack ( <str> = > <str> ) } every = proc { now = Time . now . utc zones . each { | zone , label | update_proc . call ( now , zone , label ) } } TkRTTimer . new ( <int> , - <int> , every ) . start ( <int> , every ) Ttk :: Progressbar . new ( right_top , <str> = > <str> ) . pack ( <str> = > <str> , <str> = > true ) . start if Tk . windowingsystem != <str> f = Ttk :: Frame . new ( right_bot , <str> = > Ttk :: Entry ) txt = TkText . new ( frame , <str> = > <str> , <str> = > <int> , <str> = > <int> ) txt . pack ( <str> = > <str> , <str> = > true , <str> = > f , <str> = > <int> , <str> = > <int> ) scr = txt . yscrollbar ( Ttk :: Scrollbar . new ( frame ) ) scr . pack ( <str> = > <str> , <str> = > <str> , <str> = > right_bot ) f . pack ( <str> = > <str> , <str> = > true ) outer . pack ( <str> = > <str> , <str> = > true ) else txt = TkText . new ( frame , <str> = > <str> , <str> = > <int> , <str> = > <int> ) scr = txt . yscrollbar ( TkScrollbar . new ( frame ) ) scr . pack ( <str> = > <str> , <str> = > <str> , <str> = > right_bot ) txt . pack ( <str> = > <str> , <str> = > true , <str> = > right_bot ) outer . pack ( <str> = > <str> , <str> = > true , <str> = > <int> , <str> = > [ <int> , <int> ] ) end 
