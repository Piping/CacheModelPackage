require <str> module Bosh::Monitor class AuthProvider def initialize ( auth_info , config , logger ) @auth_info = auth_info . fetch ( <str> , { } ) @user = config [ <str> ] . to_s @password = config [ <str> ] . to_s @client_id = config [ <str> ] . to_s @client_secret = config [ <str> ] . to_s @ca_cert = config [ <str> ] . to_s @logger = logger end def auth_header if @auth_info . fetch ( <str> , <str> ) == <str> uaa_url = @auth_info . fetch ( <str> , { } ) . fetch ( <str> ) return uaa_token_header ( uaa_url ) end [ @user , @password ] end private def uaa_token_header ( uaa_url ) @uaa_token || = UAAToken . new ( @client_id , @client_secret , uaa_url , @ca_cert , @logger ) @uaa_token . auth_header end end private class UAAToken EXPIRATION_DEADLINE_IN_SECONDS = <int> def initialize ( client_id , client_secret , uaa_url , ca_cert , logger ) @uaa_token_issuer = CF :: UAA :: TokenIssuer . new ( uaa_url , client_id , client_secret , { <str> : ca_cert } ) @logger = logger end def auth_header if @uaa_token && ! expires_soon? return @uaa_token . auth_header end fetch @uaa_token ? @uaa_token . auth_header : nil end private def expires_soon? expiration = @token_data [ <str> ] || @token_data [ <str> ] ( Time . at ( expiration ) . to_i - Time . now . to_i ) < EXPIRATION_DEADLINE_IN_SECONDS end def fetch @uaa_token = @uaa_token_issuer . client_credentials_grant @token_data = decode rescue = > e @logger . error ( <str> e . inspect <str> ) end def decode access_token = @uaa_token . info [ <str> ] || @uaa_token . info [ <str> ] CF :: UAA :: TokenCoder . decode ( access_token , { <str> : false } , nil , nil ) end end end 
