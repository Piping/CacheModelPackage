require <str> require <str> require <str> require <str> require <str> module Net ; module SSH ; module Transport ; module Kex class DiffieHellmanGroup1SHA1 include Constants , Loggable P_s = <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> + <str> <str> <str> <str> P_r = <int> G = <int> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> def initialize ( algorithms , connection , data ) @p = OpenSSL :: BN . new ( P_s , P_r ) @g = G @digester = OpenSSL :: Digest :: SHA1 @algorithms = algorithms @connection = connection @data = data . dup @dh = generate_key @logger = @data . delete ( <str> ) end def exchange_keys result = send_kexinit verify_server_key ( result [ <str> ] ) session_id = verify_signature ( result ) confirm_newkeys return { <str> = > session_id , <str> = > result [ <str> ] , <str> = > result [ <str> ] , <str> = > digester } end private def get_parameters [ p , g ] end def get_message_types [ KEXDH_INIT , KEXDH_REPLY ] end def build_signature_buffer ( result ) response = Net :: SSH :: Buffer . new response . write_string data [ <str> ] , data [ <str> ] , data [ <str> ] , data [ <str> ] , result [ <str> ] response . write_bignum dh . pub_key , result [ <str> ] , result [ <str> ] response end def generate_key dh = OpenSSL :: PKey :: DH . new dh . p , dh . g = get_parameters dh . priv_key = OpenSSL :: BN . rand ( data [ <str> ] * <int> ) dh . generate_key! until dh . valid? dh end def send_kexinit init , reply = get_message_types buffer = Net :: SSH :: Buffer . from ( <str> , init , <str> , dh . pub_key ) connection . send_message ( buffer ) buffer = connection . next_message raise Net :: SSH :: Exception , <str> unless buffer . type == reply result = Hash . new result [ <str> ] = buffer . read_string result [ <str> ] = Net :: SSH :: Buffer . new ( result [ <str> ] ) . read_key result [ <str> ] = buffer . read_bignum result [ <str> ] = OpenSSL :: BN . new ( dh . compute_key ( result [ <str> ] ) , <int> ) sig_buffer = Net :: SSH :: Buffer . new ( buffer . read_string ) sig_type = sig_buffer . read_string if sig_type != algorithms . host_key raise Net :: SSH :: Exception , <str> + <str> sig_type <str> algorithms . host_key <str> end result [ <str> ] = sig_buffer . read_string return result end def verify_server_key ( key ) if key . ssh_type != algorithms . host_key raise Net :: SSH :: Exception , <str> + <str> key . ssh_type <str> algorithms . host_key <str> end blob , fingerprint = generate_key_fingerprint ( key ) unless connection . host_key_verifier . verify ( <str> = > key , <str> = > blob , <str> = > fingerprint , <str> = > connection ) raise Net :: SSH :: Exception , <str> end end def generate_key_fingerprint ( key ) blob = Net :: SSH :: Buffer . from ( <str> , key ) . to_s fingerprint = OpenSSL :: Digest :: MD5 . hexdigest ( blob ) . scan ( <str> ) . join ( <str> ) [ blob , fingerprint ] rescue :: Exception = > e [ nil , <str> e . message <str> ] end def verify_signature ( result ) response = build_signature_buffer ( result ) hash = @digester . digest ( response . to_s ) unless result [ <str> ] . ssh_do_verify ( result [ <str> ] , hash ) raise Net :: SSH :: Exception , <str> end return hash end def confirm_newkeys response = Net :: SSH :: Buffer . new response . write_byte ( NEWKEYS ) connection . send_message ( response ) buffer = connection . next_message raise Net :: SSH :: Exception , <str> unless buffer . type == NEWKEYS end end end ; end ; end ; end 
