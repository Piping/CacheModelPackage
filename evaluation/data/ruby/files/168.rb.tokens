require <str> require <str> require <str> class SecurePasswordTest < ActiveModel :: TestCase setup do @original_min_cost = ActiveModel :: SecurePassword . min_cost ActiveModel :: SecurePassword . min_cost = true @user = User . new @visitor = Visitor . new @existing_user = User . new @existing_user . password_digest = BCrypt :: Password . create ( <str> , <str> : BCrypt :: Engine :: MIN_COST ) end teardown do ActiveModel :: SecurePassword . min_cost = @original_min_cost end test <str> do assert_respond_to @user , <str> end test <str> do assert_not_respond_to @visitor , <str> end test <str> do @user . password = <str> @user . password_confirmation = <str> assert @user . valid? ( <str> ) , <str> @user . password = <str> * <int> @user . password_confirmation = <str> * <int> assert @user . valid? ( <str> ) , <str> end test <str> do @user . password = <str> * <int> assert @user . valid? ( <str> ) , <str> end test <str> do @user . password = <str> assert ! @user . valid? ( <str> ) , <str> assert_equal <int> , @user . errors . count assert_equal [ <str> ] , @user . errors [ <str> ] end test <str> do @user . password = nil assert ! @user . valid? ( <str> ) , <str> assert_equal <int> , @user . errors . count assert_equal [ <str> ] , @user . errors [ <str> ] end test <str> do @user . password = <str> * <int> @user . password_confirmation = <str> * <int> assert ! @user . valid? ( <str> ) , <str> assert_equal <int> , @user . errors . count assert_equal [ <str> ] , @user . errors [ <str> ] end test <str> do @user . password = <str> @user . password_confirmation = <str> assert ! @user . valid? ( <str> ) , <str> assert_equal <int> , @user . errors . count assert_equal [ <str> ] , @user . errors [ <str> ] end test <str> do @user . password = <str> @user . password_confirmation = nil assert @user . valid? ( <str> ) , <str> end test <str> do @user . password = <str> @user . password_confirmation = <str> assert ! @user . valid? ( <str> ) , <str> assert_equal <int> , @user . errors . count assert_equal [ <str> ] , @user . errors [ <str> ] end test <str> do assert @existing_user . valid? ( <str> ) , <str> end test <str> do @existing_user . password = <str> @existing_user . password_confirmation = <str> assert @existing_user . valid? ( <str> ) , <str> @existing_user . password = <str> * <int> @existing_user . password_confirmation = <str> * <int> assert @existing_user . valid? ( <str> ) , <str> end test <str> do @existing_user . password = <str> assert @existing_user . valid? ( <str> ) , <str> end test <str> do @user . password = <str> * <int> assert @user . valid? ( <str> ) , <str> end test <str> do @existing_user . password = <str> @existing_user . password_confirmation = <str> assert @existing_user . valid? ( <str> ) , <str> end test <str> do @existing_user . password = nil assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password = <str> * <int> @existing_user . password_confirmation = <str> * <int> assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password = <str> @existing_user . password_confirmation = <str> assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password = <str> @existing_user . password_confirmation = nil assert @existing_user . valid? ( <str> ) , <str> end test <str> do @existing_user . password = <str> @existing_user . password_confirmation = <str> assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password_digest = <str> assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password_digest = nil assert ! @existing_user . valid? ( <str> ) , <str> assert_equal <int> , @existing_user . errors . count assert_equal [ <str> ] , @existing_user . errors [ <str> ] end test <str> do @existing_user . password = <str> assert @existing_user . password_digest == <str> end test <str> do @existing_user . password = nil assert_equal nil , @existing_user . password_digest end test <str> do @user . password = <str> assert ! @user . authenticate ( <str> ) assert @user . authenticate ( <str> ) end test <str> do ActiveModel :: SecurePassword . min_cost = false @user . password = <str> assert_equal BCrypt :: Engine :: DEFAULT_COST , @user . password_digest . cost end test <str> do begin original_bcrypt_cost = BCrypt :: Engine . cost ActiveModel :: SecurePassword . min_cost = false BCrypt :: Engine . cost = <int> @user . password = <str> assert_equal BCrypt :: Engine . cost , @user . password_digest . cost ensure BCrypt :: Engine . cost = original_bcrypt_cost end end test <str> do ActiveModel :: SecurePassword . min_cost = true @user . password = <str> assert_equal BCrypt :: Engine :: MIN_COST , @user . password_digest . cost end end 
