begin gem <str> , <str> rescue NoMethodError , Gem :: LoadError end if defined? Gem :: QuickLoader Gem :: QuickLoader . load_full_rubygems_library else require <str> end begin gem <str> rescue Gem :: LoadError end unless Gem :: Dependency . new ( <str> , <str> ) . matching_specs . empty? gem <str> gem <str> end require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> module Gem def self . searcher = ( searcher ) @searcher = searcher end def self . win_platform = ( val ) @@win_platform = val end def self . ruby = ruby @ruby = ruby end module DefaultUserInteraction @ui = Gem :: MockGemUi . new end end class Gem :: TestCase < MiniTest :: Unit :: TestCase attr_accessor <str> attr_accessor <str> attr_accessor <str> def assert_activate expected , * specs specs . each do | spec | case spec when String then Gem :: Specification . find_by_name ( spec ) . activate when Gem :: Specification then spec . activate else flunk spec . inspect end end loaded = Gem . loaded_specs . values . map ( & <str> ) assert_equal expected . sort , loaded . sort if expected end def assert_path_exists path , msg = nil msg = message ( msg ) { <str> path <str> } assert File . exist? ( path ) , msg end def enable_shared value enable_shared = RbConfig :: CONFIG [ <str> ] RbConfig :: CONFIG [ <str> ] = value yield ensure if enable_shared then RbConfig :: CONFIG [ <str> ] = enable_shared else RbConfig :: CONFIG . delete <str> end end def refute_path_exists path , msg = nil msg = message ( msg ) { <str> path <str> } refute File . exist? ( path ) , msg end def scan_make_command_lines ( output ) output . scan ( <str> Regexp . escape make_command <str> ) end def parse_make_command_line ( line ) command , * args = line . shellsplit targets = [ ] macros = { } args . each do | arg | case arg when <str> macros [ $1 ] = $' else targets << arg end end targets << <str> if targets . empty? { <str> = > command , <str> = > targets , <str> = > macros , } end def assert_contains_make_command ( target , output , msg = nil ) if output . match ( <str> ) msg = message ( msg ) { <str> % [ ( <str> % [ make_command , target ] ) . rstrip , output . inspect ] } else msg = message ( msg ) { <str> % [ ( <str> % [ make_command , target ] ) . rstrip , output . inspect ] } end assert scan_make_command_lines ( output ) . any? { | line | make = parse_make_command_line ( line ) if make [ <str> ] . include? ( target ) yield make , line if block_given? true else false end } , msg end include Gem :: DefaultUserInteraction undef_method <str> if instance_methods . include? <str> or instance_methods . include? <str> @@project_dir = Dir . pwd . untaint unless defined? ( @@project_dir ) @@initial_reset = false def setup super @orig_gem_home = ENV [ <str> ] @orig_gem_path = ENV [ <str> ] @orig_gem_vendor = ENV [ <str> ] @orig_gem_spec_cache = ENV [ <str> ] @orig_rubygems_gemdeps = ENV [ <str> ] @orig_rubygems_host = ENV [ <str> ] ENV [ <str> ] = nil @current_dir = Dir . pwd @fetcher = nil @ui = Gem :: MockGemUi . new tmpdir = File . expand_path Dir . tmpdir tmpdir . untaint if ENV [ <str> ] then @tempdir = File . join ( tmpdir , <str> $$ <str> Time . now . to_i <str> ) else @tempdir = File . join ( tmpdir , <str> $$ <str> ) end @tempdir . untaint FileUtils . mkdir_p @tempdir Dir . chdir @tempdir do @tempdir = File . expand_path <str> @tempdir . untaint end @gemhome = File . join @tempdir , <str> @userhome = File . join @tempdir , <str> ENV [ <str> ] = File . join @tempdir , <str> @orig_ruby = if ENV [ <str> ] then ruby = Gem . ruby Gem . ruby = ENV [ <str> ] ruby end @git = ENV [ <str> ] || <str> Gem . ensure_gem_subdirectories @gemhome @orig_LOAD_PATH = $LOAD_PATH . dup $LOAD_PATH . map! { | s | ( expand_path = File . expand_path ( s ) ) == s ? s : expand_path . untaint } Dir . chdir @tempdir @orig_ENV_HOME = ENV [ <str> ] ENV [ <str> ] = @userhome Gem . instance_variable_set <str> , nil Gem . instance_variable_set <str> , nil Gem . send <str> , <str> if Gem . instance_variables . include? <str> FileUtils . mkdir_p @gemhome FileUtils . mkdir_p @userhome @orig_gem_private_key_passphrase = ENV [ <str> ] ENV [ <str> ] = PRIVATE_KEY_PASSPHRASE @default_dir = File . join @tempdir , <str> @default_spec_dir = File . join @default_dir , <str> , <str> Gem . instance_variable_set <str> , @default_dir FileUtils . mkdir_p @default_spec_dir if @@initial_reset Gem :: Specification . unresolved_deps . clear else @@initial_reset = true Gem :: Specification . reset end Gem . use_paths ( @gemhome ) Gem :: Security . reset Gem . loaded_specs . clear Gem . clear_default_specs Gem :: Specification . unresolved_deps . clear Gem . configuration . verbose = true Gem . configuration . update_sources = true Gem :: RemoteFetcher . fetcher = Gem :: FakeFetcher . new @gem_repo = <str> @uri = URI . parse @gem_repo Gem . sources . replace [ @gem_repo ] Gem . searcher = nil Gem :: SpecFetcher . fetcher = nil @orig_BASERUBY = RbConfig :: CONFIG [ <str> ] RbConfig :: CONFIG [ <str> ] = RbConfig :: CONFIG [ <str> ] @orig_arch = RbConfig :: CONFIG [ <str> ] if win_platform? util_set_arch <str> else util_set_arch <str> end @marshal_version = <str> Marshal :: MAJOR_VERSION <str> Marshal :: MINOR_VERSION <str> @orig_LOADED_FEATURES = $LOADED_FEATURES . dup end def teardown $LOAD_PATH . replace @orig_LOAD_PATH if @orig_LOAD_PATH if @orig_LOADED_FEATURES if @orig_LOAD_PATH paths = @orig_LOAD_PATH . map { | path | File . join ( File . expand_path ( path ) , <str> ) } ( $LOADED_FEATURES - @orig_LOADED_FEATURES ) . each do | feat | unless paths . any? { | path | feat . start_with? ( path ) } $LOADED_FEATURES . delete ( feat ) end end else $LOADED_FEATURES . replace @orig_LOADED_FEATURES end end if @orig_BASERUBY RbConfig :: CONFIG [ <str> ] = @orig_BASERUBY else RbConfig :: CONFIG . delete ( <str> ) end RbConfig :: CONFIG [ <str> ] = @orig_arch if defined? Gem :: RemoteFetcher then Gem :: RemoteFetcher . fetcher = nil end Dir . chdir @current_dir FileUtils . rm_rf @tempdir unless ENV [ <str> ] ENV [ <str> ] = @orig_gem_home ENV [ <str> ] = @orig_gem_path ENV [ <str> ] = @orig_gem_vendor ENV [ <str> ] = @orig_gem_spec_cache ENV [ <str> ] = @orig_rubygems_gemdeps ENV [ <str> ] = @orig_rubygems_host Gem . ruby = @orig_ruby if @orig_ruby if @orig_ENV_HOME then ENV [ <str> ] = @orig_ENV_HOME else ENV . delete <str> end Gem . instance_variable_set <str> , nil ENV [ <str> ] = @orig_gem_private_key_passphrase Gem :: Specification . _clear_load_cache Gem :: Specification . unresolved_deps . clear end def common_installer_setup common_installer_teardown Gem . post_build do | installer | @post_build_hook_arg = installer true end Gem . post_install do | installer | @post_install_hook_arg = installer end Gem . post_uninstall do | uninstaller | @post_uninstall_hook_arg = uninstaller end Gem . pre_install do | installer | @pre_install_hook_arg = installer true end Gem . pre_uninstall do | uninstaller | @pre_uninstall_hook_arg = uninstaller end end def common_installer_teardown Gem . post_build_hooks . clear Gem . post_install_hooks . clear Gem . done_installing_hooks . clear Gem . post_reset_hooks . clear Gem . post_uninstall_hooks . clear Gem . pre_install_hooks . clear Gem . pre_reset_hooks . clear Gem . pre_uninstall_hooks . clear end def git_gem name = <str> , version = <int> have_git? directory = File . join <str> , name directory = File . expand_path directory git_spec = Gem :: Specification . new name , version do | specification | yield specification if block_given? end FileUtils . mkdir_p directory gemspec = <str> name <str> open File . join ( directory , gemspec ) , <str> do | io | io . write git_spec . to_ruby end head = nil Dir . chdir directory do unless File . exist? <str> then system @git , <str> , <str> system @git , <str> , <str> , <str> system @git , <str> , <str> , <str> end system @git , <str> , gemspec system @git , <str> , <str> , <str> , <str> , <str> head = Gem :: Util . popen ( <str> , <str> , <str> ) . strip end return name , git_spec . version , directory , head end def have_git? return if in_path? @git skip <str> end def in_path? executable return true if <str> =~ executable and File . exist? executable ENV [ <str> ] . split ( File :: PATH_SEPARATOR ) . any? do | directory | File . exist? File . join directory , executable end end def install_gem spec , options = { } require <str> gem = File . join @tempdir , <str> , <str> spec . full_name <str> unless File . exist? gem then use_ui Gem :: MockGemUi . new do Dir . chdir @tempdir do Gem :: Package . build spec end end gem = File . join ( @tempdir , File . basename ( spec . cache_file ) ) . untaint end Gem :: Installer . at ( gem , options . merge ( { <str> = > true } ) ) . install end def install_gem_user spec install_gem spec , <str> = > true end def uninstall_gem spec require <str> Class . new ( Gem :: Uninstaller ) { def ask_if_ok spec true end } . new ( spec . name , <str> = > true , <str> = > true ) . uninstall end def create_tmpdir tmpdir = nil Dir . chdir Dir . tmpdir do tmpdir = Dir . pwd end tmpdir = File . join tmpdir , <str> $$ <str> FileUtils . mkdir_p tmpdir return tmpdir end def mu_pp ( obj ) s = <str> s = PP . pp obj , s s = s . force_encoding ( Encoding . default_external ) if defined? Encoding s . chomp end def read_cache ( path ) open path . dup . untaint , <str> do | io | Marshal . load io . read end end def read_binary ( path ) Gem . read_binary path end def write_file ( path ) path = File . join @gemhome , path unless Pathname . new ( path ) . absolute? dir = File . dirname path FileUtils . mkdir_p dir open path , <str> do | io | yield io if block_given? end path end def all_spec_names Gem :: Specification . map ( & <str> ) end def quick_gem ( name , version = <str> ) require <str> spec = Gem :: Specification . new do | s | s . platform = Gem :: Platform :: RUBY s . name = name s . version = version s . author = <str> s . email = <str> s . homepage = <str> s . summary = <str> s . description = <str> yield ( s ) if block_given? end Gem :: Specification . map written_path = write_file spec . spec_file do | io | io . write spec . to_ruby_for_cache end spec . loaded_from = spec . loaded_from = written_path Gem :: Specification . reset return spec end def quick_spec name , version = <str> util_spec name , version end def util_build_gem ( spec ) dir = spec . gem_dir FileUtils . mkdir_p dir Dir . chdir dir do spec . files . each do | file | next if File . exist? file FileUtils . mkdir_p File . dirname ( file ) File . open file , <str> do | fp | fp . puts <str> file <str> end end use_ui Gem :: MockGemUi . new do Gem :: Package . build spec end cache = spec . cache_file FileUtils . mv File . basename ( cache ) , cache end end def util_remove_gem ( spec ) FileUtils . rm_rf spec . cache_file FileUtils . rm_rf spec . spec_file end def util_clear_gems FileUtils . rm_rf File . join ( @gemhome , <str> ) FileUtils . mkdir File . join ( @gemhome , <str> ) FileUtils . rm_rf File . join ( @gemhome , <str> ) FileUtils . mkdir File . join ( @gemhome , <str> ) Gem :: Specification . reset end def install_specs ( * specs ) specs . each do | spec | Gem :: Installer . for_spec ( spec ) . install end Gem . searcher = nil end def install_default_gems ( * specs ) install_default_specs ( * specs ) specs . each do | spec | open spec . loaded_from , <str> do | io | io . write spec . to_ruby_for_cache end end end def install_default_specs ( * specs ) specs . each do | spec | installer = Gem :: Installer . for_spec ( spec , <str> = > true ) installer . install Gem . register_default_spec ( spec ) end end def loaded_spec_names Gem . loaded_specs . values . map ( & <str> ) . sort end def unresolved_names Gem :: Specification . unresolved_deps . values . map ( & <str> ) . sort end def save_loaded_features old_loaded_features = $LOADED_FEATURES . dup yield ensure $LOADED_FEATURES . replace old_loaded_features end def new_spec name , version , deps = nil , * files require <str> spec = Gem :: Specification . new do | s | s . platform = Gem :: Platform :: RUBY s . name = name s . version = version s . author = <str> s . email = <str> s . homepage = <str> s . summary = <str> s . description = <str> Array ( deps ) . each do | n , req | s . add_dependency n , ( req || <str> ) end s . files . push ( * files ) unless files . empty? yield s if block_given? end spec . loaded_from = spec . spec_file unless files . empty? then write_file spec . spec_file do | io | io . write spec . to_ruby_for_cache end util_build_gem spec cache_file = File . join @tempdir , <str> , <str> spec . full_name <str> FileUtils . mkdir_p File . dirname cache_file FileUtils . mv spec . cache_file , cache_file FileUtils . rm spec . spec_file end spec end def new_default_spec ( name , version , deps = nil , * files ) spec = util_spec name , version , deps spec . loaded_from = File . join ( @default_spec_dir , spec . spec_name ) spec . files = files lib_dir = File . join ( @tempdir , <str> , <str> ) $LOAD_PATH . unshift ( lib_dir ) files . each do | file | rb_path = File . join ( lib_dir , file ) FileUtils . mkdir_p ( File . dirname ( rb_path ) ) File . open ( rb_path , <str> ) do | rb | rb << <str> file <str> end end spec end def util_spec name , version = <int> , deps = nil raise <str> if deps and block_given? spec = Gem :: Specification . new do | s | s . platform = Gem :: Platform :: RUBY s . name = name s . version = version s . author = <str> s . email = <str> s . homepage = <str> s . summary = <str> s . description = <str> yield s if block_given? end if deps then deps . keys . sort . each do | n | spec . add_dependency n , ( deps [ n ] || <str> ) end end Gem :: Specification . reset return spec end def util_gem ( name , version , deps = nil , & block ) raise <str> if deps and block if deps then block = proc do | s | deps . keys . sort . each do | n | s . add_dependency n , ( deps [ n ] || <str> ) end end end spec = quick_gem ( name , version , & block ) util_build_gem spec cache_file = File . join @tempdir , <str> , <str> spec . original_name <str> FileUtils . mkdir_p File . dirname cache_file FileUtils . mv spec . cache_file , cache_file FileUtils . rm spec . spec_file spec . loaded_from = nil [ spec , cache_file ] end def util_gzip ( data ) out = StringIO . new Zlib :: GzipWriter . wrap out do | io | io . write data end out . string end def util_make_gems ( prerelease = false ) @a1 = quick_gem <str> , <str> do | s | s . files = <str> s . require_paths = <str> s . date = Gem :: Specification :: TODAY - <int> s . homepage = <str> s . email = <str> s . authors = <str> s . description = <<- <str> DESC <str> <str> DESC end init = proc do | s | s . files = <str> s . require_paths = <str> end @a2 = quick_gem ( <str> , <str> , & init ) @a3a = quick_gem ( <str> , <str> , & init ) @a_evil9 = quick_gem ( <str> , <str> , & init ) @b2 = quick_gem ( <str> , <str> , & init ) @c1_2 = quick_gem ( <str> , <str> , & init ) @x = quick_gem ( <str> , <str> , & init ) @dep_x = quick_gem ( <str> , <str> ) do | s | s . files = <str> s . require_paths = <str> s . add_dependency <str> , <str> end @pl1 = quick_gem <str> , <str> do | s | s . files = <str> s . require_paths = <str> s . platform = Gem :: Platform . new <str> s . instance_variable_set <str> , <str> end if prerelease @a2_pre = quick_gem ( <str> , <str> , & init ) write_file File . join ( * <str> @a2_pre . original_name <str> ) util_build_gem @a2_pre end write_file File . join ( * <str> @a1 . original_name <str> ) write_file File . join ( * <str> @a2 . original_name <str> ) write_file File . join ( * <str> @a3a . original_name <str> ) write_file File . join ( * <str> @a_evil9 . original_name <str> ) write_file File . join ( * <str> @b2 . original_name <str> ) write_file File . join ( * <str> @c1_2 . original_name <str> ) write_file File . join ( * <str> @pl1 . original_name <str> ) write_file File . join ( * <str> @x . original_name <str> ) write_file File . join ( * <str> @dep_x . original_name <str> ) [ @a1 , @a2 , @a3a , @a_evil9 , @b2 , @c1_2 , @pl1 , @x , @dep_x ] . each do | spec | util_build_gem spec end FileUtils . rm_r File . join ( @gemhome , <str> , @pl1 . original_name ) end def util_set_arch ( arch ) RbConfig :: CONFIG [ <str> ] = arch platform = Gem :: Platform . new arch Gem . instance_variable_set <str> , nil Gem :: Platform . instance_variable_set <str> , nil platform end def util_setup_fake_fetcher ( prerelease = false ) require <str> require <str> require <str> @fetcher = Gem :: FakeFetcher . new util_make_gems ( prerelease ) Gem :: Specification . reset @all_gems = [ @a1 , @a2 , @a3a , @a_evil9 , @b2 , @c1_2 ] . sort @all_gem_names = @all_gems . map { | gem | gem . full_name } gem_names = [ @a1 . full_name , @a2 . full_name , @a3a . full_name , @b2 . full_name ] @gem_names = gem_names . sort . join ( <str> ) Gem :: RemoteFetcher . fetcher = @fetcher end def add_to_fetcher ( spec , path = nil , repo = @gem_repo ) path || = spec . cache_file @fetcher . data [ <str> @gem_repo <str> spec . file_name <str> ] = read_binary ( path ) end def util_setup_spec_fetcher ( * specs ) all_specs = Gem :: Specification . to_a + specs Gem :: Specification . _resort! all_specs spec_fetcher = Gem :: SpecFetcher . fetcher prerelease , all = all_specs . partition { | spec | spec . version . prerelease? } latest = Gem :: Specification . _latest_specs all_specs spec_fetcher . specs [ @uri ] = [ ] all . each do | spec | spec_fetcher . specs [ @uri ] << spec . name_tuple end spec_fetcher . latest_specs [ @uri ] = [ ] latest . each do | spec | spec_fetcher . latest_specs [ @uri ] << spec . name_tuple end spec_fetcher . prerelease_specs [ @uri ] = [ ] prerelease . each do | spec | spec_fetcher . prerelease_specs [ @uri ] << spec . name_tuple end unless Gem :: RemoteFetcher === @fetcher then v = Gem . marshal_version specs = all . map { | spec | spec . name_tuple } s_zip = util_gzip Marshal . dump Gem :: NameTuple . to_basic specs latest_specs = latest . map do | spec | spec . name_tuple end l_zip = util_gzip Marshal . dump Gem :: NameTuple . to_basic latest_specs prerelease_specs = prerelease . map { | spec | spec . name_tuple } p_zip = util_gzip Marshal . dump Gem :: NameTuple . to_basic prerelease_specs @fetcher . data [ <str> @gem_repo <str> v <str> ] = s_zip @fetcher . data [ <str> @gem_repo <str> v <str> ] = l_zip @fetcher . data [ <str> @gem_repo <str> v <str> ] = p_zip v = Gem . marshal_version all_specs . each do | spec | path = <str> @gem_repo <str> v <str> spec . original_name <str> data = Marshal . dump spec data_deflate = Zlib :: Deflate . deflate data @fetcher . data [ path ] = data_deflate end end nil end def util_zip ( data ) Zlib :: Deflate . deflate data end def util_set_RUBY_VERSION ( version , patchlevel = nil , revision = nil ) if Gem . instance_variables . include? <str> or Gem . instance_variables . include? <str> then Gem . send <str> , <str> end @RUBY_VERSION = RUBY_VERSION @RUBY_PATCHLEVEL = RUBY_PATCHLEVEL if defined? ( RUBY_PATCHLEVEL ) @RUBY_REVISION = RUBY_REVISION if defined? ( RUBY_REVISION ) Object . send <str> , <str> Object . send <str> , <str> if defined? ( RUBY_PATCHLEVEL ) Object . send <str> , <str> if defined? ( RUBY_REVISION ) Object . const_set <str> , version Object . const_set <str> , patchlevel if patchlevel Object . const_set <str> , revision if revision end def util_restore_RUBY_VERSION Object . send <str> , <str> Object . send <str> , <str> if defined? ( RUBY_PATCHLEVEL ) Object . send <str> , <str> if defined? ( RUBY_REVISION ) Object . const_set <str> , @RUBY_VERSION Object . const_set <str> , @RUBY_PATCHLEVEL if defined? ( @RUBY_PATCHLEVEL ) Object . const_set <str> , @RUBY_REVISION if defined? ( @RUBY_REVISION ) end def self . win_platform? Gem . win_platform? end def win_platform? Gem . win_platform? end def self . vc_windows? RUBY_PLATFORM . match ( <str> ) end def vc_windows? RUBY_PLATFORM . match ( <str> ) end def self . make_command ENV [ <str> ] || ENV [ <str> ] || ( vc_windows? ? <str> : <str> ) end def make_command ENV [ <str> ] || ENV [ <str> ] || ( vc_windows? ? <str> : <str> ) end def nmake_found? system ( <str> ) end def wait_for_child_process_to_exit Process . wait if Process . respond_to? ( <str> ) rescue Errno :: ECHILD end def self . process_based_port @@process_based_port || = <int> + $$ % <int> end def process_based_port self . class . process_based_port end def build_rake_in ( good = true ) gem_ruby = Gem . ruby Gem . ruby = @@ruby env_rake = ENV [ <str> ] rake = ( good ? @@good_rake : @@bad_rake ) ENV [ <str> ] = rake yield rake ensure Gem . ruby = gem_ruby if env_rake ENV [ <str> ] = env_rake else ENV . delete ( <str> ) end end def self . rubybin ruby = ENV [ <str> ] return ruby if ruby ruby = <str> rubyexe = <str> ruby <str> <int> . times do if File . exist? ruby and File . executable? ruby and ! File . directory? ruby return File . expand_path ( ruby ) end if File . exist? rubyexe and File . executable? rubyexe return File . expand_path ( rubyexe ) end ruby = File . join ( <str> , ruby ) end begin require <str> File . join ( RbConfig :: CONFIG [ <str> ] , RbConfig :: CONFIG [ <str> ] + RbConfig :: CONFIG [ <str> ] ) rescue LoadError <str> end end @@ruby = rubybin @@good_rake = <str> rubybin <str> File . expand_path ( <str> , __FILE__ ) <str> @@bad_rake = <str> rubybin <str> File . expand_path ( <str> , __FILE__ ) <str> def dep name , * requirements Gem :: Dependency . new name , * requirements end def dependency_request dep , from_name , from_version , parent = nil remote = Gem :: Source . new @uri unless parent then parent_dep = dep from_name , from_version parent = Gem :: Resolver :: DependencyRequest . new parent_dep , nil end spec = Gem :: Resolver :: IndexSpecification . new \ nil , from_name , from_version , remote , Gem :: Platform :: RUBY activation = Gem :: Resolver :: ActivationRequest . new spec , parent Gem :: Resolver :: DependencyRequest . new dep , activation end def req * requirements return requirements . first if Gem :: Requirement === requirements . first Gem :: Requirement . create requirements end def spec name , version , & block Gem :: Specification . new name , v ( version ) , & block end def spec_fetcher repository = @gem_repo Gem :: TestCase :: SpecFetcherSetup . declare self , repository do | spec_fetcher_setup | yield spec_fetcher_setup if block_given? end end def v string Gem :: Version . create string end def vendor_gem name = <str> , version = <int> directory = File . join <str> , name vendor_spec = Gem :: Specification . new name , version do | specification | yield specification if block_given? end FileUtils . mkdir_p directory open File . join ( directory , <str> name <str> ) , <str> do | io | io . write vendor_spec . to_ruby end return name , vendor_spec . version , directory end class StaticSet < Gem :: Resolver :: Set attr_accessor <str> def initialize ( specs ) super ( ) @specs = specs @remote = true end def add spec @specs << spec end def find_spec ( dep ) @specs . reverse_each do | s | return s if dep . matches_spec? s end end def find_all ( dep ) @specs . find_all { | s | dep . match? s , @prerelease } end def load_spec name , ver , platform , source dep = Gem :: Dependency . new name , ver spec = find_spec dep Gem :: Specification . new spec . name , spec . version do | s | s . platform = spec . platform end end def prefetch reqs end end def self . load_cert cert_name cert_file = cert_path cert_name cert = File . read cert_file OpenSSL :: X509 :: Certificate . new cert end def self . cert_path cert_name if <int> == ( Time . at ( <int> ** <int> ) rescue <int> ) then cert_file = File . expand_path <str> cert_name <str> , __FILE__ return cert_file if File . exist? cert_file end File . expand_path <str> cert_name <str> , __FILE__ end def self . load_key key_name , passphrase = nil key_file = key_path key_name key = File . read key_file OpenSSL :: PKey :: RSA . new key , passphrase end def self . key_path key_name File . expand_path <str> key_name <str> , __FILE__ end PRIVATE_KEY_PASSPHRASE = <str> begin PRIVATE_KEY = load_key <str> PRIVATE_KEY_PATH = key_path <str> ENCRYPTED_PRIVATE_KEY = load_key <str> , PRIVATE_KEY_PASSPHRASE ENCRYPTED_PRIVATE_KEY_PATH = key_path <str> PUBLIC_KEY = PRIVATE_KEY . public_key PUBLIC_CERT = load_cert <str> PUBLIC_CERT_PATH = cert_path <str> rescue Errno :: ENOENT PRIVATE_KEY = nil PUBLIC_KEY = nil PUBLIC_CERT = nil end if defined? ( OpenSSL :: SSL ) end begin gem <str> rescue Gem :: LoadError end begin require <str> rescue LoadError end begin gem <str> require <str> rescue LoadError , Gem :: LoadError end begin gem <str> require <str> rescue LoadError , Gem :: LoadError end require <str> tmpdirs = [ ] tmpdirs << ( ENV [ <str> ] = Dir . mktmpdir ( <str> ) ) tmpdirs << ( ENV [ <str> ] = Dir . mktmpdir ( <str> ) ) pid = $$ END { tmpdirs . each { | dir | Dir . rmdir ( dir ) } if $$ == pid } Gem . clear_paths 
