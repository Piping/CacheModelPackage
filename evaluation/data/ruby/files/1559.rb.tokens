require <str> module Rex module Parser class Arguments HasArgument = ( <int> << <int> ) def initialize ( fmt ) self . fmt = fmt self . longest = fmt . keys . inject ( <int> ) { | max , str | max = ( ( max > str . length ) ? max : str . length ) } end def self . from_s ( str ) Shellwords . shellwords ( str ) end def parse ( args , & block ) skip_next = false args . each_with_index { | arg , idx | if ( skip_next == true ) skip_next = false next end if ( arg . match ( <str> ) ) cfs = arg [ <int> .. <int> ] fmt . each_pair { | fmtspec , val | next if ( fmtspec != cfs ) param = nil if ( val [ <int> ] ) param = args [ idx + <int> ] skip_next = true end yield fmtspec , idx , param } else yield nil , idx , arg end } end def usage txt = <str> fmt . sort . each { | entry | fmtspec , val = entry txt << <str> fmtspec . ljust ( longest ) <str> + ( ( val [ <int> ] == true ) ? <str> : <str> ) txt << val [ <int> ] + <str> } txt << <str> return txt end def include? ( search ) return fmt . include? ( search ) end def arg_required? ( opt ) fmt [ opt ] [ <int> ] if fmt [ opt ] end attr_accessor <str> attr_accessor <str> end end end 
