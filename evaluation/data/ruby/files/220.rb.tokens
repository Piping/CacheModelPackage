require_dependency <str> class UserAvatarsController < ApplicationController skip_before_filter <str> , <str> , <str> , <str> , <str> : [ <str> , <str> , <str> ] def refresh_gravatar user = User . find_by ( <str> : params [ <str> ] . downcase ) guardian . ensure_can_edit! ( user ) if user user . create_user_avatar ( <str> : user . id ) unless user . user_avatar user . user_avatar . update_gravatar! render <str> : { <str> : user . user_avatar . gravatar_upload_id , <str> : User . avatar_template ( user . username , user . user_avatar . gravatar_upload_id ) } else raise Discourse :: NotFound end end def show_proxy_letter params . require ( <str> ) params . require ( <str> ) params . require ( <str> ) params . require ( <str> ) no_cookies identity = LetterAvatar :: Identity . new identity . letter = params [ <str> ] . to_s [ <int> ] . upcase identity . color = params [ <str> ] . scan ( <str> ) . map ( & <str> ) image = LetterAvatar . generate ( params [ <str> ] . to_s , params [ <str> ] . to_i , <str> : identity ) response . headers [ <str> ] = File . ctime ( image ) . httpdate response . headers [ <str> ] = File . size ( image ) . to_s expires_in <int> . year , public : true send_file image , <str> : nil end def show_letter params . require ( <str> ) params . require ( <str> ) params . require ( <str> ) no_cookies return render_blank if params [ <str> ] != LetterAvatar . version image = LetterAvatar . generate ( params [ <str> ] . to_s , params [ <str> ] . to_i ) response . headers [ <str> ] = File . ctime ( image ) . httpdate response . headers [ <str> ] = File . size ( image ) . to_s expires_in <int> . year , public : true send_file image , <str> : nil end def show no_cookies RailsMultisite :: ConnectionManagement . with_hostname ( params [ <str> ] ) do show_in_site ( params [ <str> ] ) end end protected def show_in_site ( hostname ) username = params [ <str> ] . to_s return render_blank unless user = User . find_by ( <str> : username . downcase ) upload_id , version = params [ <str> ] . split ( <str> ) version = ( version || OptimizedImage :: VERSION ) . to_i return render_blank if version != OptimizedImage :: VERSION upload_id = upload_id . to_i return render_blank unless upload_id > <int> && user_avatar = user . user_avatar size = params [ <str> ] . to_i return render_blank if size < <int> || size > <int> if ! Discourse . avatar_sizes . include? ( size ) && Discourse . store . external? closest = Discourse . avatar_sizes . to_a . min { | a , b | ( size - a ) . abs < = > ( size - b ) . abs } avatar_url = UserAvatar . local_avatar_url ( hostname , user . username_lower , upload_id , closest ) return redirect_to cdn_path ( avatar_url ) end upload = Upload . find_by ( id : upload_id ) if user_avatar . contains_upload? ( upload_id ) upload || = user . uploaded_avatar if user . uploaded_avatar_id == upload_id if user . uploaded_avatar && ! upload avatar_url = UserAvatar . local_avatar_url ( hostname , user . username_lower , user . uploaded_avatar_id , size ) return redirect_to cdn_path ( avatar_url ) elsif upload && optimized = get_optimized_image ( upload , size ) if optimized . local? optimized_path = Discourse . store . path_for ( optimized ) image = optimized_path if File . exists? ( optimized_path ) else return proxy_avatar ( Discourse . store . cdn_url ( optimized . url ) ) end end if image response . headers [ <str> ] = File . ctime ( image ) . httpdate response . headers [ <str> ] = File . size ( image ) . to_s expires_in <int> . year , public : true send_file image , <str> : nil else render_blank end end PROXY_PATH = Rails . root + <str> def proxy_avatar ( url ) if url [ <int> .. <int> ] == <str> url = ( SiteSetting . use_https ? <str> : <str> ) + url end sha = Digest :: SHA1 . hexdigest ( url ) filename = <str> sha <str> File . extname ( url ) <str> path = <str> PROXY_PATH <str> filename <str> unless File . exist? path FileUtils . mkdir_p PROXY_PATH tmp = FileHelper . download ( url , <int> . megabyte , filename , true ) FileUtils . mv tmp . path , path end response . headers [ <str> ] = DateTime . parse ( <str> ) . httpdate response . headers [ <str> ] = File . size ( path ) . to_s expires_in <int> . year , public : true send_file path , <str> : nil end def render_blank path = Rails . root + <str> expires_in <int> . minutes , public : true response . headers [ <str> ] = DateTime . parse ( <str> ) . httpdate response . headers [ <str> ] = File . size ( path ) . to_s send_file path , <str> : nil end def get_optimized_image ( upload , size ) OptimizedImage . create_for ( upload , size , size , <str> : upload . original_filename , <str> : SiteSetting . allow_animated_avatars , ) end end 
