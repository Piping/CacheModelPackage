require <str> require <str> module Gitlab module Ci module Build module Artifacts class Metadata class ParserError < StandardError ; end VERSION_PATTERN = <str> INVALID_PATH_PATTERN = <str> attr_reader <str> , <str> , <str> def initialize ( file , path , ** opts ) @file , @path , @opts = file , path , opts @full_version = read_version end def version @full_version . match ( VERSION_PATTERN ) [ <int> ] end def errors gzip do | gz | read_string ( gz ) errors = read_string ( gz ) raise ParserError , <str> unless errors begin JSON . parse ( errors ) rescue JSON :: ParserError raise ParserError , <str> end end end def find_entries! gzip do | gz | <int> . times { read_string ( gz ) } match_entries ( gz ) end end def to_entry entries = find_entries! Entry . new ( @path , entries ) end private def match_entries ( gz ) entries = { } child_pattern = <str> unless @opts [ <str> ] match_pattern = <str> Regexp . escape ( @path ) <str> child_pattern <str> until gz . eof? do begin path = read_string ( gz ) . force_encoding ( <str> ) meta = read_string ( gz ) . force_encoding ( <str> ) next unless path . valid_encoding? && meta . valid_encoding? next unless path =~ match_pattern next if path =~ INVALID_PATH_PATTERN entries [ path ] = JSON . parse ( meta , <str> : true ) rescue JSON :: ParserError , Encoding :: CompatibilityError next end end entries end def read_version gzip do | gz | version_string = read_string ( gz ) unless version_string raise ParserError , <str> end unless version_string =~ VERSION_PATTERN raise ParserError , <str> end version_string . chomp end end def read_uint32 ( gz ) binary = gz . read ( <int> ) binary . unpack ( <str> ) [ <int> ] if binary end def read_string ( gz ) string_size = read_uint32 ( gz ) return nil unless string_size gz . read ( string_size ) end def gzip ( & block ) Zlib :: GzipReader . open ( @file , & block ) end end end end end end 
