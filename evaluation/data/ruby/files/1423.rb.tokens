module Bosh::Director class Lock class TimeoutError < StandardError ; end def initialize ( name , opts = { } ) @name = name @id = SecureRandom . uuid @timeout = opts [ <str> ] || <int> . <int> @expiration = opts [ <str> ] || <int> . <int> @logger = Config . logger @refresh_thread = nil end def lock acquire @refresh_thread = Thread . new do redis = Config . redis sleep_interval = [ <int> . <int> , @expiration / <int> ] . max begin loop do @logger . debug ( <str> ) redis . watch ( @name ) existing_lock = redis . get ( @name ) lock_id = existing_lock . split ( <str> ) [ <int> ] break if lock_id != @id lock_expiration = Time . now . to_f + @expiration + <int> redis . multi do redis . set ( @name , <str> lock_expiration <str> ) end sleep ( sleep_interval ) end ensure @logger . debug ( <str> ) redis . quit end end if block_given? begin yield ensure release end end end def release @refresh_thread . exit if @refresh_thread delete end private def acquire @logger . debug ( <str> ) redis = Config . redis started = Time . now lock_expiration = Time . now . to_f + @expiration + <int> until redis . setnx ( @name , <str> lock_expiration <str> ) existing_lock = redis . get ( @name ) @logger . debug ( <str> + <str> existing_lock <str> ) if lock_expired? ( existing_lock ) @logger . debug ( <str> + <str> ) replaced_lock = redis . getset ( @name , <str> lock_expiration <str> ) if replaced_lock == existing_lock @logger . debug ( <str> ) break else @logger . debug ( <str> + <str> ) end end raise TimeoutError , <str> @name <str> if Time . now - started > @timeout sleep ( <int> . <int> ) lock_expiration = Time . now . to_f + @expiration + <int> end @lock_expiration = lock_expiration @logger . debug ( <str> ) end def delete @logger . debug ( <str> ) redis = Config . redis redis . watch ( @name ) existing_lock = redis . get ( @name ) if existing_lock . nil? @logger . debug ( <str> ) redis . unwatch else lock_id = existing_lock . split ( <str> ) [ <int> ] if lock_id == @id redis . multi do redis . del ( @name ) end else redis . unwatch end @logger . debug ( <str> ) end end def lock_expired? ( lock ) existing_lock_expiration = lock . split ( <str> ) [ <int> ] . to_f lock_time_left = existing_lock_expiration - Time . now . to_f @logger . info ( <str> lock <str> lock_time_left <str> ) lock_time_left < <int> end end end 
