module Scanf class FormatSpecifier attr_reader <str> , <str> , <str> , <str> private def skip ; <str> . match ( @spec_string ) ; end def extract_float ( s ) return nil unless s && ! skip if <str> =~ s f1 , f2 = frac . split ( <str> ) f = f1 . hex if f2 len = f2 . length if len > <int> f += f2 . hex / ( <int> . <int> ** len ) end end ( sign == <str> ? - <int> : <int> ) * Math . ldexp ( f , exp . to_i ) elsif <str> =~ s ( $1 << $2 ) . to_f else s . to_f end end def extract_decimal ( s ) ; s . to_i if s && ! skip ; end def extract_hex ( s ) ; s . hex if s && ! skip ; end def extract_octal ( s ) ; s . oct if s && ! skip ; end def extract_integer ( s ) ; Integer ( s ) if s && ! skip ; end def extract_plain ( s ) ; s unless skip ; end def nil_proc ( s ) ; nil ; end public def to_s @spec_string end def count_space? <str> . match ( @spec_string ) end def initialize ( str ) @spec_string = str h = <str> @re_string , @handler = case @spec_string when <str> [ <str> $1 <str> , <str> ] when <str> [ <str> $2 <str> $1 <str> , <str> ] when <str> yes = $1 if <str> . match ( yes ) then no = yes [ <int> .. - <int> ] else no = <str> + yes end [ <str> yes <str> no <str> , <str> ] when <str> yes = $2 w = $1 [ <str> yes <str> w <str> , <str> ] when <str> [ <str> h <str> , <str> ] when <str> n = $1 . to_i s = <str> if n > <int> then s += <str> n - <int> <str> end if n > <int> then s += <str> n - <int> <str> end if n > <int> then s += <str> n - <int> <str> end if n > <int> then s += <str> n - <int> <str> end if n > <int> then s += <str> h <str> n - <int> <str> end if n > <int> then s += <str> h <str> n - <int> <str> end s += <str> s += <str> [ s , <str> ] when <str> [ <str> , <str> ] when <str> n = $1 . to_i s = <str> if n > <int> then s += <str> n - <int> <str> end s += <str> $1 <str> [ s , <str> ] when <str> [ <str> h <str> , <str> ] when <str> n = $1 . to_i s = <str> if n > <int> then s += <str> h <str> n - <int> <str> end if n > <int> then s += <str> h <str> n - <int> <str> end if n > <int> then s += <str> h <str> n - <int> <str> end s += <str> h <str> n <str> s += <str> [ s , <str> ] when <str> [ <str> , <str> ] when <str> [ <str> $1 . to_i - <int> <str> $1 <str> , <str> ] when <str> [ <str> , <str> ] when <str> [ <str> + <str> $1 <str> , <str> ] when <str> [ <str> $1 <str> , <str> ] when <str> [ <str> , <str> ] when <str> [ <str> , <str> ] when <str> [ <str> , <str> ] when <str> [ <str> $1 <str> , <str> ] when <str> [ <str> , <str> ] else [ <str> Regexp . escape ( @spec_string ) <str> , <str> ] end @re_string = <str> + @re_string end def to_re Regexp . new ( @re_string , Regexp :: MULTILINE ) end def match ( str ) @matched = false s = str . dup s . sub! ( <str> , <str> ) unless count_space? res = to_re . match ( s ) if res @conversion = send ( @handler , res [ <int> ] ) @matched_string = @conversion . to_s @matched = true end res end def letter @spec_string [ <str> , <int> ] end def width @spec_string [ <str> , <int> ] & . to_i end def mid_match? return false unless @matched cc_no_width = letter == <str> && ! width c_or_cc_width = ( letter == <str> || letter == <str> ) && width width_left = c_or_cc_width && ( matched_string . size < width ) return width_left || cc_no_width end end class FormatString attr_reader <str> , <str> , <str> , <str> , <str> SPECIFIERS = <str> REGEX = <str> SPECIFIERS <str> def initialize ( str ) @specs = [ ] @i = <int> s = str . to_s return unless <str> . match ( s ) @space = true if <str> . match ( s ) @specs . replace s . scan ( REGEX ) . map { | spec | FormatSpecifier . new ( spec ) } end def to_s @specs . join ( <str> ) end def prune ( n = matched_count ) n . times { @specs . shift } end def spec_count @specs . size end def last_spec @i == spec_count - <int> end def match ( str ) accum = [ ] @string_left = str @matched_count = <int> @specs . each_with_index do | spec , i | @i = i @last_spec_tried = spec @last_match_tried = spec . match ( @string_left ) break unless @last_match_tried @matched_count += <int> accum << spec . conversion @string_left = @last_match_tried . post_match break if @string_left . empty? end return accum . compact end end end class IO def scanf ( str , & b ) return block_scanf ( str , & b ) if b return [ ] unless str . size > <int> start_position = pos rescue <int> matched_so_far = <int> source_buffer = <str> result_buffer = [ ] final_result = [ ] fstr = Scanf :: FormatString . new ( str ) loop do if eof || ( tty? && ! fstr . match ( source_buffer ) ) final_result . concat ( result_buffer ) break end source_buffer << gets current_match = fstr . match ( source_buffer ) spec = fstr . last_spec_tried if spec . matched if spec . mid_match? result_buffer . replace ( current_match ) next end elsif ( fstr . matched_count == fstr . spec_count - <int> ) if <str> . match ( fstr . string_left ) break if spec . count_space? result_buffer . replace ( current_match ) next end end final_result . concat ( current_match ) matched_so_far += source_buffer . size source_buffer . replace ( fstr . string_left ) matched_so_far -= source_buffer . size break if fstr . last_spec fstr . prune end begin seek ( start_position + matched_so_far , IO :: SEEK_SET ) rescue Errno :: ESPIPE end soak_up_spaces if fstr . last_spec && fstr . space return final_result end private def soak_up_spaces c = getc ungetc ( c ) if c until eof || ! c || <str> . match ( c . chr ) c = getc end ungetc ( c ) if ( c && <str> . match ( c . chr ) ) end def block_scanf ( str ) final = [ ] fstr = Scanf :: FormatString . new ( str ) last_spec = fstr . last_spec begin current = scanf ( str ) break if current . empty? final . push ( yield ( current ) ) end until eof || fstr . last_spec_tried == last_spec return final end end class String def scanf ( fstr , & b ) if b block_scanf ( fstr , & b ) else fs = if fstr . is_a? Scanf :: FormatString fstr else Scanf :: FormatString . new ( fstr ) end fs . match ( self ) end end def block_scanf ( fstr ) fs = Scanf :: FormatString . new ( fstr ) str = self . dup final = [ ] begin current = str . scanf ( fs ) final . push ( yield ( current ) ) unless current . empty? str = fs . string_left end until current . empty? || str . empty? return final end end module Kernel private def scanf ( format , & b ) STDIN . scanf ( format , & b ) end end 
