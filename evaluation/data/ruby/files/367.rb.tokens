begin require <str> rescue LoadError end require <str> require <str> require <str> require <str> require <str> require <str> class TestSocket_UNIXSocket < Test :: Unit :: TestCase def test_fd_passing r1 , w = IO . pipe s1 , s2 = UNIXSocket . pair begin s1 . send_io ( nil ) rescue NotImplementedError assert_raise ( NotImplementedError ) { s2 . recv_io } rescue TypeError s1 . send_io ( r1 ) r2 = s2 . recv_io assert_equal ( r1 . stat . ino , r2 . stat . ino ) assert_not_equal ( r1 . fileno , r2 . fileno ) assert ( r2 . close_on_exec? ) w . syswrite <str> assert_equal ( <str> , r2 . sysread ( <int> ) ) ensure s1 . close s2 . close w . close r1 . close r2 . close if r2 && ! r2 . closed? end end def test_fd_passing_class_mode UNIXSocket . pair do | s1 , s2 | s1 . send_io ( s1 . fileno ) r = s2 . recv_io ( nil ) assert_kind_of Integer , r , <str> assert_not_equal s1 . fileno , r r = IO . for_fd ( r ) assert_equal s1 . stat . ino , r . stat . ino r . close s1 . send_io ( s1 ) klass = IO r = s2 . recv_io ( klass , <str> ) assert_instance_of klass , r , <str> assert_not_equal s1 . fileno , r . fileno r . close end end def test_fd_passing_n io_ary = [ ] return if ! defined? ( Socket :: SCM_RIGHTS ) io_ary . concat IO . pipe io_ary . concat IO . pipe io_ary . concat IO . pipe send_io_ary = [ ] io_ary . each { | io | send_io_ary << io UNIXSocket . pair { | s1 , s2 | begin ret = s1 . sendmsg ( <str> , <int> , nil , [ Socket :: SOL_SOCKET , Socket :: SCM_RIGHTS , send_io_ary . map { | io2 | io2 . fileno } . pack ( <str> ) ] ) rescue NotImplementedError return end assert_equal ( <int> , ret ) ret = s2 . recvmsg ( <str> = > true ) _ , _ , _ , * ctls = ret recv_io_ary = [ ] begin ctls . each { | ctl | next if ctl . level != Socket :: SOL_SOCKET || ctl . type != Socket :: SCM_RIGHTS recv_io_ary . concat ctl . unix_rights } assert_equal ( send_io_ary . length , recv_io_ary . length ) send_io_ary . length . times { | i | assert_not_equal ( send_io_ary [ i ] . fileno , recv_io_ary [ i ] . fileno ) assert ( File . identical? ( send_io_ary [ i ] , recv_io_ary [ i ] ) ) assert ( recv_io_ary [ i ] . close_on_exec? ) } ensure recv_io_ary . each { | io2 | io2 . close if ! io2 . closed? } end } } ensure io_ary . each { | io | io . close if ! io . closed? } end def test_fd_passing_n2 io_ary = [ ] return if ! defined? ( Socket :: SCM_RIGHTS ) return if ! defined? ( Socket :: AncillaryData ) io_ary . concat IO . pipe io_ary . concat IO . pipe io_ary . concat IO . pipe send_io_ary = [ ] io_ary . each { | io | send_io_ary << io UNIXSocket . pair { | s1 , s2 | begin ancdata = Socket :: AncillaryData . unix_rights ( * send_io_ary ) ret = s1 . sendmsg ( <str> , <int> , nil , ancdata ) rescue NotImplementedError return end assert_equal ( <int> , ret ) ret = s2 . recvmsg ( <str> = > true ) _ , _ , _ , * ctls = ret recv_io_ary = [ ] begin ctls . each { | ctl | next if ctl . level != Socket :: SOL_SOCKET || ctl . type != Socket :: SCM_RIGHTS recv_io_ary . concat ctl . unix_rights } assert_equal ( send_io_ary . length , recv_io_ary . length ) send_io_ary . length . times { | i | assert_not_equal ( send_io_ary [ i ] . fileno , recv_io_ary [ i ] . fileno ) assert ( File . identical? ( send_io_ary [ i ] , recv_io_ary [ i ] ) ) assert ( recv_io_ary [ i ] . close_on_exec? ) } ensure recv_io_ary . each { | io2 | io2 . close if ! io2 . closed? } end } } ensure io_ary . each { | io | io . close if ! io . closed? } end def test_fd_passing_race_condition r1 , w = IO . pipe s1 , s2 = UNIXSocket . pair s1 . nonblock = s2 . nonblock = true lock = Mutex . new nr = <int> x = <int> y = <int> begin s1 . send_io ( nil ) rescue NotImplementedError assert_raise ( NotImplementedError ) { s2 . recv_io } rescue TypeError thrs = x . times . map do Thread . new do y . times do s2 . recv_io . close lock . synchronize { nr += <int> } end true end end ( x * y ) . times { s1 . send_io r1 } assert_equal ( [ true ] * x , thrs . map { | t | t . value } ) assert_equal x * y , nr ensure s1 . close s2 . close w . close r1 . close end end def test_sendmsg return if ! defined? ( Socket :: SCM_RIGHTS ) IO . pipe { | r1 , w | UNIXSocket . pair { | s1 , s2 | begin ret = s1 . sendmsg ( <str> , <int> , nil , [ Socket :: SOL_SOCKET , Socket :: SCM_RIGHTS , [ r1 . fileno ] . pack ( <str> ) ] ) rescue NotImplementedError return end assert_equal ( <int> , ret ) r2 = s2 . recv_io begin assert ( File . identical? ( r1 , r2 ) ) assert ( r2 . close_on_exec? ) ensure r2 . close end } } end def test_sendmsg_ancillarydata_int return if ! defined? ( Socket :: SCM_RIGHTS ) return if ! defined? ( Socket :: AncillaryData ) IO . pipe { | r1 , w | UNIXSocket . pair { | s1 , s2 | begin ad = Socket :: AncillaryData . int ( <str> , <str> , <str> , r1 . fileno ) ret = s1 . sendmsg ( <str> , <int> , nil , ad ) rescue NotImplementedError return end assert_equal ( <int> , ret ) r2 = s2 . recv_io begin assert ( File . identical? ( r1 , r2 ) ) ensure r2 . close end } } end def test_sendmsg_ancillarydata_unix_rights return if ! defined? ( Socket :: SCM_RIGHTS ) return if ! defined? ( Socket :: AncillaryData ) IO . pipe { | r1 , w | UNIXSocket . pair { | s1 , s2 | begin ad = Socket :: AncillaryData . unix_rights ( r1 ) ret = s1 . sendmsg ( <str> , <int> , nil , ad ) rescue NotImplementedError return end assert_equal ( <int> , ret ) r2 = s2 . recv_io begin assert ( File . identical? ( r1 , r2 ) ) ensure r2 . close end } } end def test_recvmsg return if ! defined? ( Socket :: SCM_RIGHTS ) return if ! defined? ( Socket :: AncillaryData ) IO . pipe { | r1 , w | UNIXSocket . pair { | s1 , s2 | s1 . send_io ( r1 ) ret = s2 . recvmsg ( <str> = > true ) data , srcaddr , flags , * ctls = ret assert_equal ( <str> , data ) if flags == nil assert_instance_of ( Array , ctls ) assert_equal ( <int> , ctls . length ) else assert_equal ( <int> , flags & ( Socket :: MSG_TRUNC | Socket :: MSG_CTRUNC ) ) assert_instance_of ( Addrinfo , srcaddr ) assert_instance_of ( Array , ctls ) assert_equal ( <int> , ctls . length ) ctl = ctls [ <int> ] assert_instance_of ( Socket :: AncillaryData , ctl ) assert_equal ( Socket :: SOL_SOCKET , ctl . level ) assert_equal ( Socket :: SCM_RIGHTS , ctl . type ) assert_instance_of ( String , ctl . data ) ios = ctl . unix_rights assert_equal ( <int> , ios . length ) r2 = ios [ <int> ] begin assert ( File . identical? ( r1 , r2 ) ) assert ( r2 . close_on_exec? ) ensure r2 . close end end } } end def bound_unix_socket ( klass ) tmpfile = Tempfile . new ( <str> ) path = tmpfile . path tmpfile . close ( true ) io = klass . new ( path ) yield io , path ensure io . close File . unlink path if path && File . socket? ( path ) end def test_addr bound_unix_socket ( UNIXServer ) { | serv , path | UNIXSocket . open ( path ) { | c | s = serv . accept begin assert_equal ( [ <str> , path ] , c . peeraddr ) assert_equal ( [ <str> , <str> ] , c . addr ) assert_equal ( [ <str> , <str> ] , s . peeraddr ) assert_equal ( [ <str> , path ] , s . addr ) assert_equal ( path , s . path ) assert_equal ( <str> , c . path ) ensure s . close end } } end def test_cloexec bound_unix_socket ( UNIXServer ) { | serv , path | UNIXSocket . open ( path ) { | c | s = serv . accept begin assert ( serv . close_on_exec? ) assert ( c . close_on_exec? ) assert ( s . close_on_exec? ) ensure s . close end } } end def test_noname_path s1 , s2 = UNIXSocket . pair assert_equal ( <str> , s1 . path ) assert_equal ( <str> , s2 . path ) ensure s1 . close s2 . close end def test_noname_addr s1 , s2 = UNIXSocket . pair assert_equal ( [ <str> , <str> ] , s1 . addr ) assert_equal ( [ <str> , <str> ] , s2 . addr ) ensure s1 . close s2 . close end def test_noname_peeraddr s1 , s2 = UNIXSocket . pair assert_equal ( [ <str> , <str> ] , s1 . peeraddr ) assert_equal ( [ <str> , <str> ] , s2 . peeraddr ) ensure s1 . close s2 . close end def test_noname_unpack_sockaddr_un s1 , s2 = UNIXSocket . pair n = nil assert_equal ( <str> , Socket . unpack_sockaddr_un ( n ) ) if ( n = s1 . getsockname ) != <str> assert_equal ( <str> , Socket . unpack_sockaddr_un ( n ) ) if ( n = s1 . getsockname ) != <str> assert_equal ( <str> , Socket . unpack_sockaddr_un ( n ) ) if ( n = s2 . getsockname ) != <str> assert_equal ( <str> , Socket . unpack_sockaddr_un ( n ) ) if ( n = s1 . getpeername ) != <str> assert_equal ( <str> , Socket . unpack_sockaddr_un ( n ) ) if ( n = s2 . getpeername ) != <str> ensure s1 . close s2 . close end def test_noname_recvfrom s1 , s2 = UNIXSocket . pair s2 . write ( <str> ) assert_equal ( [ <str> , [ <str> , <str> ] ] , s1 . recvfrom ( <int> ) ) ensure s1 . close s2 . close end def test_noname_recv_nonblock s1 , s2 = UNIXSocket . pair s2 . write ( <str> ) IO . select [ s1 ] assert_equal ( <str> , s1 . recv_nonblock ( <int> ) ) ensure s1 . close s2 . close end def test_too_long_path assert_raise ( ArgumentError ) { Socket . sockaddr_un ( <str> * <int> ) } assert_raise ( ArgumentError ) { UNIXServer . new ( <str> * <int> ) } end def test_abstract_namespace return if <str> !~ RUBY_PLATFORM addr = Socket . pack_sockaddr_un ( <str> ) assert_match ( <str> , addr ) assert_equal ( <str> , Socket . unpack_sockaddr_un ( addr ) ) end def test_dgram_pair s1 , s2 = UNIXSocket . pair ( Socket :: SOCK_DGRAM ) begin s1 . recv_nonblock ( <int> ) fail rescue = > e assert ( IO :: EAGAINWaitReadable === e ) assert ( IO :: WaitReadable === e ) end s2 . send ( <str> , <int> ) s2 . send ( <str> , <int> ) s2 . send ( <str> , <int> ) s2 . send ( <str> , <int> ) assert_equal ( <str> , s1 . recv ( <int> ) ) assert_equal ( <str> , s1 . recv ( <int> ) ) assert_equal ( <str> , s1 . recv ( <int> ) ) assert_equal ( <str> , s1 . recv ( <int> ) ) assert_raise ( IO :: EAGAINWaitReadable ) { s1 . recv_nonblock ( <int> ) } buf = <str> . dup s2 . send ( <str> , <int> ) IO . select ( [ s1 ] ) rv = s1 . recv ( <int> , <int> , buf ) assert_equal buf . object_id , rv . object_id assert_equal <str> , rv ensure s1 . close if s1 s2 . close if s2 end def test_dgram_pair_sendrecvmsg_errno_set s1 , s2 = to_close = UNIXSocket . pair ( Socket :: SOCK_DGRAM ) pipe = IO . pipe to_close . concat ( pipe ) set_errno = lambda do begin pipe [ <int> ] . read_nonblock ( <int> ) fail rescue = > e assert ( IO :: EAGAINWaitReadable === e ) end end Timeout . timeout ( <int> ) do set_errno . call assert_equal ( <int> , s1 . sendmsg ( <str> ) ) set_errno . call assert_equal ( <str> , s2 . recvmsg [ <int> ] ) end ensure to_close . each ( & <str> ) if to_close end def test_epipe UNIXSocket . pair { | s1 , s2 | s1 . shutdown ( Socket :: SHUT_WR ) assert_raise ( Errno :: EPIPE ) { s1 . write <str> } assert_equal ( nil , s2 . read ( <int> ) ) s2 . write <str> assert_equal ( <str> , s1 . read ( <int> ) ) } end def test_socket_pair_with_block pair = nil ret = Socket . pair ( Socket :: AF_UNIX , Socket :: SOCK_STREAM , <int> ) { | s1 , s2 | pair = [ s1 , s2 ] <str> } assert_equal ( <str> , ret ) assert_kind_of ( Socket , pair [ <int> ] ) assert_kind_of ( Socket , pair [ <int> ] ) end def test_unix_socket_pair_with_block pair = nil UNIXSocket . pair { | s1 , s2 | pair = [ s1 , s2 ] } assert_kind_of ( UNIXSocket , pair [ <int> ] ) assert_kind_of ( UNIXSocket , pair [ <int> ] ) end def test_unix_socket_pair_close_on_exec UNIXSocket . pair { | s1 , s2 | assert ( s1 . close_on_exec? ) assert ( s2 . close_on_exec? ) } end def test_initialize Dir . mktmpdir { | d | Socket . open ( Socket :: AF_UNIX , Socket :: SOCK_STREAM , <int> ) { | s | s . bind ( Socket . pack_sockaddr_un ( <str> d <str> ) ) addr = s . getsockname assert_nothing_raised { Socket . unpack_sockaddr_un ( addr ) } assert_raise ( ArgumentError ) { Socket . unpack_sockaddr_in ( addr ) } } Socket . open ( <str> , <str> , <int> ) { | s | s . bind ( Socket . pack_sockaddr_un ( <str> d <str> ) ) addr = s . getsockname assert_nothing_raised { Socket . unpack_sockaddr_un ( addr ) } assert_raise ( ArgumentError ) { Socket . unpack_sockaddr_in ( addr ) } } } end def test_unix_server_socket Dir . mktmpdir { | d | path = <str> d <str> s0 = nil Socket . unix_server_socket ( path ) { | s | assert_equal ( path , s . local_address . unix_path ) assert ( File . socket? ( path ) ) s0 = s } assert ( s0 . closed? ) assert_raise ( Errno :: ENOENT ) { File . stat path } } end def test_getcred_ucred return if <str> !~ RUBY_PLATFORM Dir . mktmpdir { | d | sockpath = <str> d <str> Socket . unix_server_socket ( sockpath ) { | serv | Socket . unix ( sockpath ) { | c | s , = serv . accept begin cred = s . getsockopt ( <str> , <str> ) inspect = cred . inspect assert_match ( <str> $$ <str> , inspect ) assert_match ( <str> Process . euid <str> , inspect ) assert_match ( <str> Process . egid <str> , inspect ) assert_match ( <str> , inspect ) ensure s . close end } } } end def test_getcred_xucred return if <str> !~ RUBY_PLATFORM Dir . mktmpdir { | d | sockpath = <str> d <str> serv = Socket . unix_server_socket ( sockpath ) Socket . unix ( sockpath ) s , = serv . accept cred = s . getsockopt ( <int> , Socket :: LOCAL_PEERCRED ) inspect = cred . inspect assert_match ( <str> Process . euid <str> , inspect ) assert_match ( <str> , inspect ) } end def test_sendcred_ucred return if <str> !~ RUBY_PLATFORM Dir . mktmpdir { | d | sockpath = <str> d <str> Socket . unix_server_socket ( sockpath ) { | serv | Socket . unix ( sockpath ) { | c | s , = serv . accept begin s . setsockopt ( <str> , <str> , <int> ) c . print <str> msg , _ , _ , cred = s . recvmsg inspect = cred . inspect assert_equal ( <str> , msg ) assert_match ( <str> $$ <str> , inspect ) assert_match ( <str> Process . uid <str> , inspect ) assert_match ( <str> Process . gid <str> , inspect ) assert_match ( <str> , inspect ) ensure s . close end } } } end def test_sendcred_sockcred return if <str> !~ RUBY_PLATFORM Dir . mktmpdir { | d | sockpath = <str> d <str> serv = Socket . unix_server_socket ( sockpath ) c = Socket . unix ( sockpath ) s , = serv . accept s . setsockopt ( <int> , Socket :: LOCAL_CREDS , <int> ) c . print <str> msg , _ , _ , cred = s . recvmsg assert_equal ( <str> , msg ) inspect = cred . inspect assert_match ( <str> Process . uid <str> , inspect ) assert_match ( <str> Process . euid <str> , inspect ) assert_match ( <str> Process . gid <str> , inspect ) assert_match ( <str> Process . egid <str> , inspect ) assert_match ( <str> , inspect ) } end def test_sendcred_cmsgcred return if <str> !~ RUBY_PLATFORM Dir . mktmpdir { | d | sockpath = <str> d <str> serv = Socket . unix_server_socket ( sockpath ) c = Socket . unix ( sockpath ) s , = serv . accept c . sendmsg ( <str> , <int> , nil , [ <str> , Socket :: SCM_CREDS , <str> ] ) msg , _ , _ , cred = s . recvmsg assert_equal ( <str> , msg ) inspect = cred . inspect assert_match ( <str> $$ <str> , inspect ) assert_match ( <str> Process . uid <str> , inspect ) assert_match ( <str> Process . euid <str> , inspect ) assert_match ( <str> Process . gid <str> , inspect ) assert_match ( <str> , inspect ) } end def test_getpeereid Dir . mktmpdir { | d | path = <str> d <str> Socket . unix_server_socket ( path ) { | serv | Socket . unix ( path ) { | c | s , = serv . accept begin assert_equal ( [ Process . euid , Process . egid ] , c . getpeereid ) assert_equal ( [ Process . euid , Process . egid ] , s . getpeereid ) rescue NotImplementedError ensure s . close end } } } end def test_abstract_unix_server return if <str> !~ RUBY_PLATFORM name = <str> s0 = nil UNIXServer . open ( name ) { | s | assert_equal ( name , s . local_address . unix_path ) s0 = s UNIXSocket . open ( name ) { | c | sock = s . accept begin assert_equal ( name , c . remote_address . unix_path ) ensure sock . close end } } assert ( s0 . closed? ) end def test_abstract_unix_socket_econnrefused return if <str> !~ RUBY_PLATFORM name = <str> assert_raise ( Errno :: ECONNREFUSED ) do UNIXSocket . open ( name ) { } end end def test_abstract_unix_server_socket return if <str> !~ RUBY_PLATFORM name = <str> s0 = nil Socket . unix_server_socket ( name ) { | s | assert_equal ( name , s . local_address . unix_path ) s0 = s Socket . unix ( name ) { | c | sock , = s . accept begin assert_equal ( name , c . remote_address . unix_path ) ensure sock . close end } } assert ( s0 . closed? ) end def test_autobind return if <str> !~ RUBY_PLATFORM s0 = nil Socket . unix_server_socket ( <str> ) { | s | name = s . local_address . unix_path assert_match ( <str> , name ) s0 = s Socket . unix ( name ) { | c | sock , = s . accept begin assert_equal ( name , c . remote_address . unix_path ) ensure sock . close end } } assert ( s0 . closed? ) end def test_accept_nonblock bound_unix_socket ( UNIXServer ) { | serv , path | assert_raise ( IO :: WaitReadable ) { serv . accept_nonblock } assert_raise ( IO :: WaitReadable ) { serv . accept_nonblock ( <str> : true ) } assert_equal <str> , serv . accept_nonblock ( <str> : false ) } end end if defined? ( UNIXSocket ) && <str> !~ RUBY_PLATFORM 
