require <str> require <str> describe Puppet :: ModuleTool do describe <str> do it <str> do FileTest . expects ( <str> ) . with ( responds_with ( <str> , <str> ) ) . returns ( true ) expect ( subject . is_module_root? ( Pathname . new ( <str> ) ) ) . to be_truthy end it <str> do FileTest . expects ( <str> ) . with ( responds_with ( <str> , <str> ) ) . returns ( false ) expect ( subject . is_module_root? ( Pathname . new ( <str> ) ) ) . to be_falsey end end describe <str> do let ( <str> ) { Pathname . new ( <str> ) . expand_path } it <str> do Puppet :: ModuleTool . expects ( <str> ) . with ( sample_path ) . returns ( true ) expect ( subject . find_module_root ( sample_path ) ) . to eq ( sample_path ) end it <str> do Puppet :: ModuleTool . expects ( <str> ) . with ( responds_with ( <str> , File . expand_path ( <str> ) ) ) . returns ( false ) Puppet :: ModuleTool . expects ( <str> ) . with ( responds_with ( <str> , File . expand_path ( <str> ) ) ) . returns ( true ) expect ( subject . find_module_root ( sample_path ) ) . to eq ( Pathname . new ( <str> ) . expand_path ) end it <str> do Puppet :: ModuleTool . expects ( <str> ) . at_least_once . returns ( false ) expect ( subject . find_module_root ( sample_path ) ) . to be_nil end end describe <str> do it <str> do expect ( subject . format_tree ( [ ] ) ) . to eq ( <str> ) end it <str> do list = [ { <str> = > <str> } , { <str> = > <str> } , { <str> = > <str> } ] expect ( subject . format_tree ( list ) ) . to eq <<- <str> TREE <str> <str> TREE end it <str> do list = [ { <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > [ { <str> = > <str> } ] } ] } , ] expect ( subject . format_tree ( list ) ) . to eq <<- <str> TREE <str> <str> TREE end it <str> do list = [ { <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > [ { <str> = > <str> } ] } ] } , { <str> = > <str> } ] expect ( subject . format_tree ( list ) ) . to eq <<- <str> TREE <str> <str> TREE end it <str> do list = [ { <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > [ { <str> = > <str> } ] } , { <str> = > <str> } ] } ] expect ( subject . format_tree ( list ) ) . to eq <<- <str> TREE <str> <str> TREE end it <str> do list = [ { <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > [ { <str> = > <str> } ] } , { <str> = > <str> } ] } , { <str> = > <str> } ] expect ( subject . format_tree ( list ) ) . to eq <<- <str> TREE <str> <str> TREE end end describe <str> do let ( <str> ) { { } } let ( <str> ) { [ <str> , <str> ] } let ( <str> ) { <str> } let ( <str> ) { Puppet :: Node :: Environment . create ( environment_name , modulepath ) } subject do described_class . set_option_defaults ( options ) options end around do | example | envs = Puppet :: Environments :: Static . new ( environment ) Puppet . override ( <str> = > envs ) do example . run end end describe <str> do context <str> do let ( <str> ) { { <str> = > <str> environment_name <str> } } it <str> do expect ( subject ) . to include <str> = > environment end end context <str> do let ( <str> ) { { <str> = > <str> environment_name <str> } } it <str> do expect ( subject ) . to include <str> = > environment end end context <str> do let ( <str> ) { Puppet :: Node :: Environment . create ( <str> , [ ] ) } let ( <str> ) { { <str> = > env } } it <str> do expect ( subject ) . to include <str> = > env end end end describe <str> do let ( <str> ) do { <str> = > <str> . join ( File :: PATH_SEPARATOR ) } end let ( <str> ) { options [ <str> ] . split ( File :: PATH_SEPARATOR ) . map { | dir | File . expand_path ( dir ) } } it <str> do expect ( subject [ <str> ] . full_modulepath ) . to eql paths end it <str> do expect ( subject ) . to include <str> = > paths . first end context <str> do let ( <str> ) do { <str> = > <str> . join ( File :: PATH_SEPARATOR ) , <str> = > environment_name } end it <str> do expect ( subject [ <str> ] . full_modulepath ) . to eql paths end it <str> do expect ( subject ) . to include <str> = > paths . first end end end describe <str> do let ( <str> ) do { <str> = > <str> } end let ( <str> ) { File . expand_path ( options [ <str> ] ) } it <str> do expect ( subject ) . to include <str> = > target end it <str> do expect ( subject [ <str> ] . full_modulepath . first ) . to eql target end context <str> do let ( <str> ) do { <str> = > <str> , <str> = > <str> . join ( File :: PATH_SEPARATOR ) } end it <str> do expect ( subject [ <str> ] . full_modulepath . first ) . to eql target end it <str> do paths = <str> + options [ <str> ] . split ( File :: PATH_SEPARATOR ) paths . map! { | dir | File . expand_path ( dir ) } expect ( subject [ <str> ] . full_modulepath ) . to eql paths end end context <str> do let ( <str> ) do { <str> = > <str> , <str> = > environment_name } end it <str> do expect ( subject [ <str> ] . full_modulepath . first ) . to eql target end it <str> do paths = <str> + environment . full_modulepath paths . map! { | dir | File . expand_path ( dir ) } expect ( subject [ <str> ] . full_modulepath ) . to eql paths end end context <str> do it <str> do expect ( subject ) . to include <str> = > subject [ <str> ] . full_modulepath . first end end end end describe <str> do it <str> do name , range , expr = subject . parse_module_dependency ( <str> , <str> = > <str> ) expect ( name ) . to eql ( <str> ) expect ( range ) . to eql ( Semantic :: VersionRange . parse ( <str> ) ) expect ( expr ) . to eql ( <str> ) end it <str> do name , range , expr = subject . parse_module_dependency ( <str> , <str> = > <str> , <str> = > <str> ) expect ( name ) . to eql ( <str> ) expect ( range ) . to eql ( Semantic :: VersionRange . parse ( <str> ) ) expect ( expr ) . to eql ( <str> ) end it <str> do name , range , expr = subject . parse_module_dependency ( <str> , <str> = > <str> , <str> = > <str> ) expect ( name ) . to eql ( <str> ) expect ( range ) . to eql ( Semantic :: VersionRange :: EMPTY_RANGE ) expect ( expr ) . to eql ( <str> ) end end end 
