module Puppet::Pops module Binder module BindingsFactory T = Types :: TypeFactory class AbstractBuilder attr_reader <str> def initialize ( binding ) @model = binding end def method_missing ( meth , * args , & block ) factory = BindingsFactory if factory . respond_to? ( meth ) factory . send ( meth , * args , & block ) else super end end end class BindingsContainerBuilder < AbstractBuilder def bind ( & block ) binding = Bindings :: Binding . new ( ) model . addBindings ( binding ) builder = BindingsBuilder . new ( binding ) builder . instance_eval ( & block ) if block_given? builder end def multibind ( id , & block ) binding = Bindings :: Multibinding . new ( ) binding . id = id model . addBindings ( binding ) builder = MultibindingsBuilder . new ( binding ) builder . instance_eval ( & block ) if block_given? builder end end class BindingsBuilder < AbstractBuilder def initialize ( binding ) super binding data ( ) end def name ( name ) model . name = name self end alias_method <str> , <str> def abstract model . abstract = true self end def override model . override = true self end def final model . final = true self end def in_multibind ( id ) model . multibind_id = id self end def type ( type ) model . type = type self end def integer ( ) type ( T . integer ( ) ) end def float ( ) type ( T . float ( ) ) end def boolean ( ) type ( T . boolean ( ) ) end def string ( ) type ( T . string ( ) ) end def pattern ( ) type ( T . pattern ( ) ) end def scalar ( ) type ( T . scalar ( ) ) end def data ( ) type ( T . data ( ) ) end def array_of_data ( ) type ( T . array_of_data ( ) ) end def array_of ( t ) type ( T . array_of ( t ) ) end def hash_of_data ( ) type ( T . hash_of_data ( ) ) end def hash_of ( t ) type ( T . hash_of ( t ) ) end def instance_of ( t ) type ( T . type_of ( t ) ) end def type_factory Types :: TypeFactory end def to ( producer , * args ) case producer when Class producer = BindingsFactory . instance_producer ( producer . name , * args ) when Model :: Program producer = BindingsFactory . evaluating_producer ( producer . body ) when Model :: Expression producer = BindingsFactory . evaluating_producer ( producer ) when Bindings :: ProducerDescriptor else producer = BindingsFactory . literal_producer ( producer ) end model . producer = producer self end def to_instance ( type , * args ) class_name = case type when Class type . name when String type else raise ArgumentError , <str> type . class <str> end self . instance_of ( type ) model . producer = BindingsFactory . instance_producer ( class_name , * args ) end def to_producer ( producer , * args ) case producer when Class producer = BindingsFactory . instance_producer ( producer . name , * args ) when Bindings :: ProducerDescriptor when Producers :: Producer producer = BindingsFactory . literal_producer ( producer ) else raise ArgumentError , <str> end metaproducer = BindingsFactory . producer_producer ( producer ) model . producer = metaproducer self end def to_producer_series ( producer , * args ) case producer when Class producer = BindingsFactory . instance_producer ( producer . name , * args ) when Bindings :: ProducerDescriptor when Producers :: Producer producer = BindingsFactory . literal_producer ( producer ) else raise ArgumentError , <str> end non_caching = Bindings :: NonCachingProducerDescriptor . new ( ) non_caching . producer = producer metaproducer = BindingsFactory . producer_producer ( non_caching ) non_caching = Bindings :: NonCachingProducerDescriptor . new ( ) non_caching . producer = metaproducer model . producer = non_caching self end def to_series_of ( producer , * args ) case producer when Class producer = BindingsFactory . instance_producer ( producer . name , * args ) when Bindings :: ProducerDescriptor else producer = BindingsFactory . literal_producer ( producer ) end non_caching = Bindings :: NonCachingProducerDescriptor . new ( ) non_caching . producer = producer model . producer = non_caching self end def to_lookup_of ( type , name = nil ) unless name name = type type = Types :: TypeFactory . data ( ) end model . producer = BindingsFactory . lookup_producer ( type , name ) self end def to_hash_lookup_of ( type , name , key ) model . producer = BindingsFactory . hash_lookup_producer ( type , name , key ) self end def to_first_found ( * list_of_lookups ) producers = list_of_lookups . collect do | entry | if entry . is_a? ( Array ) case entry . size when <int> BindingsFactory . lookup_producer ( entry [ <int> ] , entry [ <int> ] ) when <int> BindingsFactory . lookup_producer ( Types :: TypeFactory . data ( ) , entry [ <int> ] ) else raise ArgumentError , <str> end else BindingsFactory . lookup_producer ( T . data ( ) , entry ) end end model . producer = BindingsFactory . first_found_producer ( * producers ) self end def producer_options ( options ) options . each do | k , v | arg = Bindings :: NamedArgument . new ( ) arg . name = k . to_s arg . value = v model . addProducer_args ( arg ) end self end end class MultibindingsBuilder < BindingsBuilder def type ( type ) unless type . class == Types :: PArrayType || type . class == Types :: PHashType raise ArgumentError , <str> type . to_s <str> end model . type = type self end def data ( ) hash_of_data ( ) end end def self . contributed_bindings ( name , named_bindings ) cb = Bindings :: ContributedBindings . new ( ) cb . name = name named_bindings = [ named_bindings ] unless named_bindings . is_a? ( Array ) named_bindings . each { | b | cb . addBindings ( b ) } cb end def self . named_bindings ( name , & block ) binding = Bindings :: NamedBindings . new ( ) binding . name = name builder = BindingsContainerBuilder . new ( binding ) builder . instance_eval ( & block ) if block_given? builder end def self . safe_named_bindings ( name , scope , & block ) binding = Bindings :: NamedBindings . new ( ) binding . name = name anon = Class . new ( BindingsContainerBuilder ) do def initialize ( b ) super b end end anon . send ( <str> , <str> , block ) builder = anon . new ( binding ) case block . arity when <int> builder . _produce ( ) when <int> builder . _produce ( scope ) end builder end def self . literal_producer ( value ) producer = Bindings :: ConstantProducerDescriptor . new ( ) producer . value = value producer end def self . non_caching_producer ( producer ) p = Bindings :: NonCachingProducerDescriptor . new ( ) p . producer = producer p end def self . producer_producer ( producer ) p = Bindings :: ProducerProducerDescriptor . new ( ) p . producer = producer p end def self . instance_producer ( class_name , * args ) p = Bindings :: InstanceProducerDescriptor . new ( ) p . class_name = class_name args . each { | a | p . addArguments ( a ) } p end def self . lookup_producer ( type , name ) p = Bindings :: LookupProducerDescriptor . new ( ) p . type = type p . name = name p end def self . hash_lookup_producer ( type , name , key ) p = Bindings :: HashLookupProducerDescriptor . new ( ) p . type = type p . name = name p . key = key p end def self . first_found_producer ( * producers ) p = Bindings :: FirstFoundProducerDescriptor . new ( ) producers . each { | p2 | p . addProducers ( p2 ) } p end def self . evaluating_producer ( expression ) p = Bindings :: EvaluatingProducerDescriptor . new ( ) p . expression = expression p end def self . named_layer ( name , * bindings ) result = Bindings :: NamedLayer . new ( ) result . name = name bindings . each { | b | result . addBindings ( b ) } result end def self . layered_bindings ( * named_layers ) result = Bindings :: LayeredBindings . new ( ) named_layers . each { | b | result . addLayers ( b ) } result end def self . parser @parser || = Parser :: EvaluatingParser . new ( ) end def self . puppet_expression ( string , source_file ) parser . parse_string ( string , source_file ) . current end def self . puppet_string ( string , source_file ) parser . parse_string ( parser . quote ( string ) , source_file ) . current end end end end 
