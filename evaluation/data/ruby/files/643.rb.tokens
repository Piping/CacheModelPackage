require <str> require <str> require <str> class EachTest < ActiveRecord :: TestCase fixtures <str> , <str> def setup @posts = Post . order ( <str> ) @total = Post . count Post . count ( <str> ) end def test_each_should_execute_one_query_per_batch assert_queries ( @total + <int> ) do Post . find_each ( <str> = > <int> ) do | post | assert_kind_of Post , post end end end def test_each_should_not_return_query_chain_and_execute_only_one_query assert_queries ( <int> ) do result = Post . find_each ( <str> = > <int> ) { } assert_nil result end end def test_each_should_return_an_enumerator_if_no_block_is_present assert_queries ( <int> ) do Post . find_each ( <str> = > <int> ) . with_index do | post , index | assert_kind_of Post , post assert_kind_of Integer , index end end end if Enumerator . method_defined? <str> def test_each_should_return_a_sized_enumerator assert_equal <int> , Post . find_each ( <str> : <int> ) . size assert_equal <int> , Post . find_each ( <str> : <int> , <str> : <int> ) . size assert_equal <int> , Post . find_each ( <str> : <int> ) . size end end def test_each_enumerator_should_execute_one_query_per_batch assert_queries ( @total + <int> ) do Post . find_each ( <str> = > <int> ) . with_index do | post , index | assert_kind_of Post , post assert_kind_of Integer , index end end end def test_each_should_raise_if_select_is_set_without_id assert_raise ( ArgumentError ) do Post . select ( <str> ) . find_each ( <str> : <int> ) { | post | flunk <str> } end end def test_each_should_execute_if_id_is_in_select assert_queries ( <int> ) do Post . select ( <str> ) . find_each ( <str> = > <int> ) do | post | assert_kind_of Post , post end end end def test_warn_if_limit_scope_is_set assert_called ( ActiveRecord :: Base . logger , <str> ) do Post . limit ( <int> ) . find_each { | post | post } end end def test_warn_if_order_scope_is_set assert_called ( ActiveRecord :: Base . logger , <str> ) do Post . order ( <str> ) . find_each { | post | post } end end def test_logger_not_required previous_logger = ActiveRecord :: Base . logger ActiveRecord :: Base . logger = nil assert_nothing_raised do Post . limit ( <int> ) . find_each { | post | post } end ensure ActiveRecord :: Base . logger = previous_logger end def test_find_in_batches_should_return_batches assert_queries ( @total + <int> ) do Post . find_in_batches ( <str> = > <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first end end end def test_find_in_batches_should_start_from_the_start_option assert_queries ( @total ) do Post . find_in_batches ( <str> : <int> , <str> : <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first end end end def test_find_in_batches_should_end_at_the_finish_option assert_queries ( <int> ) do Post . find_in_batches ( <str> : <int> , <str> : <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first end end end def test_find_in_batches_shouldnt_execute_query_unless_needed assert_queries ( <int> ) do Post . find_in_batches ( <str> = > @total ) { | batch | assert_kind_of Array , batch } end assert_queries ( <int> ) do Post . find_in_batches ( <str> = > @total + <int> ) { | batch | assert_kind_of Array , batch } end end def test_find_in_batches_should_quote_batch_order c = Post . connection assert_sql ( <str> c . quote_table_name ( <str> ) <str> c . quote_column_name ( <str> ) <str> ) do Post . find_in_batches ( <str> = > <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first end end end def test_find_in_batches_should_not_use_records_after_yielding_them_in_case_original_array_is_modified not_a_post = <str> def not_a_post . id ; end not_a_post . stub ( <str> , - > { raise StandardError . new ( <str> ) } ) do assert_nothing_raised do Post . find_in_batches ( <str> = > <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first batch . map! { not_a_post } end end end end def test_find_in_batches_should_ignore_the_order_default_scope first_post = PostWithDefaultScope . first posts = [ ] PostWithDefaultScope . find_in_batches do | batch | posts . concat ( batch ) end assert_not_equal first_post , posts . first assert_equal posts ( <str> ) . id , posts . first . id end def test_find_in_batches_should_not_ignore_the_default_scope_if_it_is_other_then_order special_posts_ids = SpecialPostWithDefaultScope . all . map ( & <str> ) . sort posts = [ ] SpecialPostWithDefaultScope . find_in_batches do | batch | posts . concat ( batch ) end assert_equal special_posts_ids , posts . map ( & <str> ) end def test_find_in_batches_should_not_modify_passed_options assert_nothing_raised do Post . find_in_batches ( { <str> : <int> , <str> : <int> } . freeze ) { } end end def test_find_in_batches_should_use_any_column_as_primary_key nick_order_subscribers = Subscriber . order ( <str> ) start_nick = nick_order_subscribers . second . nick subscribers = [ ] Subscriber . find_in_batches ( <str> : <int> , <str> : start_nick ) do | batch | subscribers . concat ( batch ) end assert_equal nick_order_subscribers [ <int> .. - <int> ] . map ( & <str> ) , subscribers . map ( & <str> ) end def test_find_in_batches_should_use_any_column_as_primary_key_when_start_is_not_specified assert_queries ( Subscriber . count + <int> ) do Subscriber . find_in_batches ( <str> : <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Subscriber , batch . first end end end def test_find_in_batches_should_return_an_enumerator enum = nil assert_no_queries do enum = Post . find_in_batches ( <str> = > <int> ) end assert_queries ( <int> ) do enum . first ( <int> ) do | batch | assert_kind_of Array , batch assert_kind_of Post , batch . first end end end def test_in_batches_should_not_execute_any_query assert_no_queries do assert_kind_of ActiveRecord :: Batches :: BatchEnumerator , Post . in_batches ( <str> : <int> ) end end def test_in_batches_should_yield_relation_if_block_given assert_queries ( <int> ) do Post . in_batches ( <str> : <int> ) do | relation | assert_kind_of ActiveRecord :: Relation , relation end end end def test_in_batches_should_be_enumerable_if_no_block_given assert_queries ( <int> ) do Post . in_batches ( <str> : <int> ) . each do | relation | assert_kind_of ActiveRecord :: Relation , relation end end end def test_in_batches_each_record_should_yield_record_if_block_is_given assert_queries ( <int> ) do Post . in_batches ( <str> : <int> ) . each_record do | post | assert post . title . present? assert_kind_of Post , post end end end def test_in_batches_each_record_should_return_enumerator_if_no_block_given assert_queries ( <int> ) do Post . in_batches ( <str> : <int> ) . each_record . with_index do | post , i | assert post . title . present? assert_kind_of Post , post end end end def test_in_batches_each_record_should_be_ordered_by_id ids = Post . order ( <str> ) . pluck ( <str> ) assert_queries ( <int> ) do Post . in_batches ( <str> : <int> ) . each_record . with_index do | post , i | assert_equal ids [ i ] , post . id end end end def test_in_batches_update_all_affect_all_records assert_queries ( <int> + <int> ) do Post . in_batches ( <str> : <int> ) . update_all ( <str> : <str> ) end assert_equal Post . all . pluck ( <str> ) , [ <str> ] * Post . count end def test_in_batches_delete_all_should_not_delete_records_in_other_batches not_deleted_count = Post . where ( <str> ) . count Post . where ( <str> ) . in_batches ( <str> : <int> ) . delete_all assert_equal <int> , Post . where ( <str> ) . count assert_equal not_deleted_count , Post . count end def test_in_batches_should_not_be_loaded Post . in_batches ( <str> : <int> ) do | relation | assert_not relation . loaded? end Post . in_batches ( <str> : <int> , load : false ) do | relation | assert_not relation . loaded? end end def test_in_batches_should_be_loaded Post . in_batches ( <str> : <int> , load : true ) do | relation | assert relation . loaded? end end def test_in_batches_if_not_loaded_executes_more_queries assert_queries ( @total + <int> ) do Post . in_batches ( <str> : <int> , load : false ) do | relation | assert_not relation . loaded? end end end def test_in_batches_should_return_relations assert_queries ( @total + <int> ) do Post . in_batches ( <str> : <int> ) do | relation | assert_kind_of ActiveRecord :: Relation , relation end end end def test_in_batches_should_start_from_the_start_option post = Post . order ( <str> ) . where ( <str> , <int> ) . first assert_queries ( <int> ) do relation = Post . in_batches ( <str> : <int> , <str> : <int> ) . first assert_equal post , relation . first end end def test_in_batches_should_end_at_the_finish_option post = Post . order ( <str> ) . where ( <str> , <int> ) . first assert_queries ( <int> ) do relation = Post . in_batches ( <str> : <int> , <str> : <int> , load : true ) . reverse_each . first assert_equal post , relation . last end end def test_in_batches_shouldnt_execute_query_unless_needed assert_queries ( <int> ) do Post . in_batches ( <str> : @total ) { | relation | assert_kind_of ActiveRecord :: Relation , relation } end assert_queries ( <int> ) do Post . in_batches ( <str> : @total + <int> ) { | relation | assert_kind_of ActiveRecord :: Relation , relation } end end def test_in_batches_should_quote_batch_order c = Post . connection assert_sql ( <str> c . quote_table_name ( <str> ) <str> c . quote_column_name ( <str> ) <str> ) do Post . in_batches ( <str> : <int> ) do | relation | assert_kind_of ActiveRecord :: Relation , relation assert_kind_of Post , relation . first end end end def test_in_batches_should_not_use_records_after_yielding_them_in_case_original_array_is_modified not_a_post = <str> def not_a_post . id raise StandardError . new ( <str> ) end assert_nothing_raised do Post . in_batches ( <str> : <int> ) do | relation | assert_kind_of ActiveRecord :: Relation , relation assert_kind_of Post , relation . first relation = [ not_a_post ] * relation . count end end end def test_in_batches_should_not_ignore_default_scope_without_order_statements special_posts_ids = SpecialPostWithDefaultScope . all . map ( & <str> ) . sort posts = [ ] SpecialPostWithDefaultScope . in_batches do | relation | posts . concat ( relation ) end assert_equal special_posts_ids , posts . map ( & <str> ) end def test_in_batches_should_not_modify_passed_options assert_nothing_raised do Post . in_batches ( { <str> : <int> , <str> : <int> } . freeze ) { } end end def test_in_batches_should_use_any_column_as_primary_key nick_order_subscribers = Subscriber . order ( <str> ) start_nick = nick_order_subscribers . second . nick subscribers = [ ] Subscriber . in_batches ( <str> : <int> , <str> : start_nick ) do | relation | subscribers . concat ( relation ) end assert_equal nick_order_subscribers [ <int> .. - <int> ] . map ( & <str> ) , subscribers . map ( & <str> ) end def test_in_batches_should_use_any_column_as_primary_key_when_start_is_not_specified assert_queries ( Subscriber . count + <int> ) do Subscriber . in_batches ( <str> : <int> , load : true ) do | relation | assert_kind_of ActiveRecord :: Relation , relation assert_kind_of Subscriber , relation . first end end end def test_in_batches_should_return_an_enumerator enum = nil assert_no_queries do enum = Post . in_batches ( <str> : <int> ) end assert_queries ( <int> ) do enum . first ( <int> ) do | relation | assert_kind_of ActiveRecord :: Relation , relation assert_kind_of Post , relation . first end end end def test_in_batches_relations_should_not_overlap_with_each_other seen_posts = [ ] Post . in_batches ( <str> : <int> , load : true ) do | relation | relation . to_a . each do | post | assert_not seen_posts . include? ( post ) seen_posts << post end end end def test_in_batches_relations_with_condition_should_not_overlap_with_each_other seen_posts = [ ] author_id = Post . first . author_id posts_by_author = Post . where ( <str> : author_id ) Post . in_batches ( <str> : <int> ) do | batch | seen_posts += batch . where ( <str> : author_id ) end assert_equal posts_by_author . pluck ( <str> ) . sort , seen_posts . map ( & <str> ) . sort end def test_in_batches_relations_update_all_should_not_affect_matching_records_in_other_batches Post . update_all ( <str> : <int> ) person = Post . last person . update_attributes ( <str> : <int> ) Post . in_batches ( <str> : <int> ) do | batch | batch . where ( <str> ) . update_all ( <str> ) end assert_equal <int> , person . reload . author_id end if Enumerator . method_defined? <str> def test_find_in_batches_should_return_a_sized_enumerator assert_equal <int> , Post . find_in_batches ( <str> = > <int> ) . size assert_equal <int> , Post . find_in_batches ( <str> = > <int> ) . size assert_equal <int> , Post . find_in_batches ( <str> : <int> , <str> : <int> ) . size assert_equal <int> , Post . find_in_batches ( <str> = > <int> ) . size assert_equal <int> , Post . find_in_batches ( <str> = > <int> ) . size end end end 
