require <str> require_dependency <str> describe Topic do let ( <str> ) { Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) } it { is_expected . to validate_presence_of <str> } it { is_expected . to rate_limit } context <str> do let ( <str> ) { Post . types } it <str> do post_types = Topic . visible_post_types expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to_not include ( types [ <str> ] ) end it <str> do post_types = Topic . visible_post_types ( Fabricate . build ( <str> ) ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to_not include ( types [ <str> ] ) end it <str> do post_types = Topic . visible_post_types ( Fabricate . build ( <str> ) ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) expect ( post_types ) . to include ( types [ <str> ] ) end end context <str> do let ( <str> ) { <str> } let ( <str> ) { <str> } context <str> do before { SiteSetting . slug_generation_method = <str> } after { SiteSetting . slug_generation_method = <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( slug ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( slug ) end context <str> do let ( <str> ) { <str> } let ( <str> ) { <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( slug ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( slug ) end end context <str> do let ( <str> ) { <str> } let ( <str> ) { <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( <str> ) end end end context <str> do before { SiteSetting . slug_generation_method = <str> } after { SiteSetting . slug_generation_method = <str> } let ( <str> ) { <str> } let ( <str> ) { <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( slug ) end end context <str> do before { SiteSetting . slug_generation_method = <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( slug ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( slug ) end context <str> do let ( <str> ) { <str> } let ( <str> ) { <str> } it <str> do Slug . expects ( <str> ) . with ( title ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : title ) . slug ) . to eq ( <str> ) end end end end context <str> do let! ( <str> ) { Fabricate ( <str> ) } it <str> do topic . title = <str> expect ( topic . save ) . to eq ( false ) end end context <str> do before do SiteSetting . stubs ( <str> ) . returns ( <int> ) SiteSetting . stubs ( <str> ) . returns ( <int> ) end it <str> do pm = Fabricate . build ( <str> , <str> : <str> * SiteSetting . min_private_message_title_length ) expect ( pm ) . to be_valid end it <str> do pm = Fabricate . build ( <str> , <str> : <str> ) expect ( pm ) . to_not be_valid end end context <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do pm = Fabricate . build ( <str> , <str> : admin , <str> : <str> ) expect ( pm ) . to be_valid end it <str> do pm = Fabricate . build ( <str> , <str> : <str> ) expect ( pm ) . to_not be_valid end end context <str> do let! ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate . build ( <str> , <str> : topic . title ) } context <str> do before do SiteSetting . expects ( <str> ) . returns ( false ) end it <str> do expect ( new_topic ) . not_to be_valid end it <str> do new_topic . title = new_topic . title . upcase expect ( new_topic ) . not_to be_valid end it <str> do topic . destroy expect ( new_topic ) . to be_valid end it <str> do new_topic . archetype = Archetype . private_message expect ( new_topic ) . to be_valid end end context <str> do before do SiteSetting . expects ( <str> ) . returns ( true ) end it <str> do expect ( new_topic ) . to be_valid end end end context <str> do def build_topic_with_title ( title ) build ( <str> , <str> : title ) . tap { | t | t . valid? } end let ( <str> ) { build_topic_with_title ( <str> ) } let ( <str> ) { build_topic_with_title ( <str> ) } let ( <str> ) { build_topic_with_title ( <str> ) } it <str> do expect ( topic_script . fancy_title ) . to eq ( <str> ) end it <str> do expect ( topic_bold . fancy_title ) . to eq ( <str> ) end it <str> do expect ( topic_image . fancy_title ) . to eq ( <str> ) end end context <str> do let ( <str> ) { Fabricate . build ( <str> , <str> : <str> ) } context <str> do before do SiteSetting . title_fancy_entities = false end it <str> do expect ( topic . fancy_title ) . to eq ( <str> ) end end context <str> do before do SiteSetting . title_fancy_entities = true end it <str> do expect ( topic . fancy_title ) . to eq ( <str> ) topic . title = <str> topic . user . save! topic . save! topic . reload expect ( topic . fancy_title ) . to eq ( <str> ) topic . title = <str> topic . save! topic . reload expect ( topic . fancy_title ) . to eq ( <str> ) topic . title = <str> expect ( topic . fancy_title ) . to eq ( <str> ) end end end context <str> do context <str> do before do SiteSetting . stubs ( <str> ) . returns ( false ) end it <str> do topic = Fabricate . build ( <str> , <str> : nil ) expect ( topic ) . not_to be_valid expect ( topic . errors [ <str> ] ) . to be_present end it <str> do topic = Fabricate . build ( <str> , <str> : nil , <str> : Archetype . private_message ) expect ( topic ) . to be_valid end it <str> do expect ( Fabricate . build ( <str> , <str> : Fabricate ( <str> ) ) ) . to be_valid end end context <str> do before do SiteSetting . stubs ( <str> ) . returns ( true ) end it <str> do expect ( Fabricate . build ( <str> , <str> : nil ) ) . to be_valid end it <str> do expect ( Fabricate . build ( <str> , <str> : Fabricate ( <str> ) ) ) . to be_valid end end end context <str> do it <str> do expect ( Topic . similar_to ( nil , nil ) ) . to be_blank end context <str> do let! ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( Topic . similar_to ( <str> , <str> ) ) . to be_blank end end context <str> do let! ( <str> ) { ActiveRecord :: Base . observers . enable <str> post = create_post ( <str> : <str> ) post . topic } it <str> do expect ( Topic . similar_to ( <str> , <str> ) ) . to eq ( [ topic ] ) end context <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> , <str> : true ) } before do topic . category = category topic . save end it <str> do expect ( Topic . similar_to ( <str> , <str> , user ) ) . to be_blank end it <str> do Guardian . any_instance . expects ( <str> ) . returns ( [ category . id ] ) expect ( Topic . similar_to ( <str> , <str> , user ) ) . to include ( topic ) end end end end context <str> do let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Fabricate ( <str> , <str> : topic , <str> : topic . user ) } let! ( <str> ) { Fabricate ( <str> , <str> : topic , <str> : topic . user ) } let! ( <str> ) { Fabricate ( <str> , <str> : topic , <str> : topic . user ) } it <str> do expect ( topic . post_numbers ) . to eq ( [ <int> , <int> , <int> ] ) p2 . destroy topic . reload expect ( topic . post_numbers ) . to eq ( [ <int> , <int> ] ) end end context <str> do let ( <str> ) { User . find_by ( <str> : <str> ) } let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( Guardian . new ( topic . user ) . can_see? ( topic ) ) . to eq ( true ) expect ( Guardian . new . can_see? ( topic ) ) . to eq ( false ) expect ( Guardian . new ( evil_trout ) . can_see? ( topic ) ) . to eq ( false ) expect ( Guardian . new ( coding_horror ) . can_see? ( topic ) ) . to eq ( true ) expect ( TopicQuery . new ( evil_trout ) . list_latest . topics ) . not_to include ( topic ) expect ( topic . invite ( topic . user , <str> ) ) . to eq ( false ) end context <str> do context <str> do let ( <str> ) { Fabricate ( <str> ) } context <str> do it <str> do expect ( topic . invite ( topic . user , walter . username ) ) . to eq ( true ) expect ( topic . allowed_users . include? ( walter ) ) . to eq ( true ) expect ( topic . remove_allowed_user ( topic . user , walter . username ) ) . to eq ( true ) topic . reload expect ( topic . allowed_users . include? ( walter ) ) . to eq ( false ) end it <str> do expect { topic . invite ( topic . user , walter . username ) } . to change ( Notification , <str> ) end it <str> do expect { topic . invite ( topic . user , walter . username ) } . to change ( Post , <str> ) expect { topic . remove_allowed_user ( topic . user , walter . username ) } . to change ( Post , <str> ) end end context <str> do it <str> do expect { expect ( topic . invite ( topic . user , walter . email ) ) . to eq ( true ) } . to change ( Notification , <str> ) expect ( topic . allowed_users . include? ( walter ) ) . to eq ( true ) end end end end context <str> do let ( <str> ) { topic . user . user_actions } it <str> do ActiveRecord :: Base . observers . enable <str> expect ( actions . map { | a | a . action_type } ) . not_to include ( UserAction :: NEW_TOPIC ) expect ( actions . map { | a | a . action_type } ) . to include ( UserAction :: NEW_PRIVATE_MESSAGE ) expect ( coding_horror . user_actions . map { | a | a . action_type } ) . to include ( UserAction :: GOT_PRIVATE_MESSAGE ) end end end it <str> do SiteSetting . stubs ( <str> ) . returns ( <int> ) RateLimiter . stubs ( <str> ) . returns ( false ) RateLimiter . clear_all! start = Time . now . tomorrow . beginning_of_day freeze_time ( start ) user = Fabricate ( <str> ) topic = Fabricate ( <str> ) freeze_time ( start + <int> . minutes ) topic . invite ( topic . user , user . username ) freeze_time ( start + <int> . minutes ) topic . invite ( topic . user , <str> ) freeze_time ( start + <int> . minutes ) expect { topic . invite ( topic . user , <str> ) } . to raise_exception end context <str> do before do @topic = Fabricate ( <str> , <str> : <int> . year . ago ) end it <str> do expect ( @topic . bumped_at ) . to be_present expect { create_post ( <str> : @topic , <str> : @topic . user ) @topic . reload } . to change ( @topic , <str> ) end context <str> do before do @earlier_post = Fabricate ( <str> , <str> : @topic , <str> : @topic . user ) @last_post = Fabricate ( <str> , <str> : @topic , <str> : @topic . user ) @topic . reload end it <str> do expect { SiteSetting . expects ( <str> ) . returns ( <int> . minutes ) @last_post . revise ( @last_post . user , { <str> : <str> } , <str> : @last_post . created_at + <int> . seconds ) @topic . reload } . not_to change ( @topic , <str> ) end it <str> do expect { @last_post . revise ( Fabricate ( <str> ) , { <str> : <str> } ) @topic . reload } . to change ( @topic , <str> ) end it <str> do expect { @earlier_post . revise ( Fabricate ( <str> ) , { <str> : <str> } ) @topic . reload } . not_to change ( @topic , <str> ) end end end context <str> do before do @moderator = Fabricate ( <str> ) @topic = Fabricate ( <str> ) @mod_post = @topic . add_moderator_post ( @moderator , <str> , <str> : <int> ) end it <str> do expect ( @mod_post ) . to be_present expect ( @mod_post . post_type ) . to eq ( Post . types [ <str> ] ) expect ( @mod_post . post_number ) . to eq ( <int> ) expect ( @mod_post . sort_order ) . to eq ( <int> ) expect ( @topic . topic_links . count ) . to eq ( <int> ) @topic . reload expect ( @topic . moderator_posts_count ) . to eq ( <int> ) end end context <str> do before do @topic = Fabricate ( <str> , <str> : <int> . hour . ago ) @topic . reload @original_bumped_at = @topic . bumped_at . to_f @user = @topic . user @user . admin = true end context <str> do context <str> do before do @topic . update_status ( <str> , false , @user ) @topic . reload end it <str> do expect ( @topic ) . not_to be_visible expect ( @topic . moderator_posts_count ) . to eq ( <int> ) expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) end end context <str> do before do @topic . update_attribute <str> , false @topic . update_status ( <str> , true , @user ) @topic . reload end it <str> do expect ( @topic ) . to be_visible expect ( @topic . moderator_posts_count ) . to eq ( <int> ) expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) end end end context <str> do context <str> do before do @topic . update_status ( <str> , false , @user ) @topic . reload end it <str> do expect ( @topic . pinned_at ) . to be_blank expect ( @topic . moderator_posts_count ) . to eq ( <int> ) expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) end end context <str> do before do @topic . update_attribute <str> , nil @topic . update_status ( <str> , true , @user ) @topic . reload end it <str> do expect ( @topic . pinned_at ) . to be_present expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) expect ( @topic . moderator_posts_count ) . to eq ( <int> ) end end end context <str> do context <str> do before do @topic . update_status ( <str> , false , @user ) @topic . reload end it <str> do expect ( @topic ) . not_to be_archived expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) expect ( @topic . moderator_posts_count ) . to eq ( <int> ) end end context <str> do before do @topic . update_attribute <str> , false @topic . update_status ( <str> , true , @user ) @topic . reload end it <str> do expect ( @topic ) . to be_archived expect ( @topic . moderator_posts_count ) . to eq ( <int> ) expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) end end end shared_examples_for <str> do context <str> do before do @topic . update_status ( status , false , @user ) @topic . reload end it <str> do expect ( @topic ) . not_to be_closed expect ( @topic . moderator_posts_count ) . to eq ( <int> ) expect ( @topic . bumped_at . to_f ) . not_to eq ( @original_bumped_at ) end end context <str> do before do @topic . update_attribute <str> , false @topic . update_status ( status , true , @user ) @topic . reload end it <str> do expect ( @topic ) . to be_closed expect ( @topic . bumped_at . to_f ) . to eq ( @original_bumped_at ) expect ( @topic . moderator_posts_count ) . to eq ( <int> ) end end end context <str> do let ( <str> ) { <str> } it_should_behave_like <str> end context <str> do let ( <str> ) { <str> } it_should_behave_like <str> context <str> do it <str> do freeze_time ( Time . new ( <int> , <int> , <int> ) ) do @topic . created_at = <int> . days . ago @topic . update_status ( status , true , @user ) expect ( @topic . posts . last . raw ) . to include <str> end end end context <str> do it <str> do freeze_time ( Time . new ( <int> , <int> , <int> ) ) do @topic . created_at = <int> . days . ago freeze_time ( <int> . days . ago ) do @topic . set_auto_close ( <int> ) end @topic . update_status ( status , true , @user ) expect ( @topic . posts . last . raw ) . to include <str> end end end end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { topic . user } let ( <str> ) { { <str> : <str> , <str> : topic . url , <str> : topic . id } } before { topic . stubs ( <str> ) . returns ( banner ) } describe <str> do it <str> do messages = MessageBus . track_publish do topic . make_banner! ( user ) expect ( topic . archetype ) . to eq ( Archetype . banner ) end channels = messages . map ( & <str> ) expect ( channels ) . to include ( <str> ) expect ( channels ) . to include ( <str> ) end it <str> do _banner_topic = Fabricate ( <str> ) expect ( Topic . where ( <str> : Archetype . banner ) . count ) . to eq ( <int> ) topic . make_banner! ( user ) expect ( Topic . where ( <str> : Archetype . banner ) . count ) . to eq ( <int> ) end end describe <str> do it <str> do topic . expects ( <str> ) MessageBus . expects ( <str> ) . with ( <str> , nil ) topic . remove_banner! ( user ) expect ( topic . archetype ) . to eq ( Archetype . default ) end end end context <str> do before do @post = create_post @user = @post . user @topic = @post . topic end it <str> do expect ( @topic . last_post_user_id ) . to eq ( @user . id ) end context <str> do before do @second_user = Fabricate ( <str> ) @new_post = create_post ( <str> : @topic , <str> : @second_user ) @topic . reload end it <str> do expect ( @topic . last_post_user_id ) . to eq ( @second_user . id ) expect ( @topic . last_posted_at . to_i ) . to eq ( @new_post . created_at . to_i ) topic_user = @second_user . topic_users . find_by ( <str> : @topic . id ) expect ( topic_user . posted? ) . to eq ( true ) end end end describe <str> do before do @category = Fabricate ( <str> ) end it <str> do expect { Fabricate ( <str> , <str> : @category . user ) ; @category . reload } . not_to change ( @category , <str> ) end it <str> do expect { Fabricate ( <str> , <str> : @category . user , <str> : @category . id ) ; @category . reload } . to change ( @category , <str> ) . by ( <int> ) end end describe <str> do let ( <str> ) { Fabricate ( <str> , <str> : { <str> = > <str> } ) } it <str> do expect ( topic . meta_data [ <str> ] ) . to eq ( <str> ) end context <str> do context <str> do before do topic . update_meta_data ( <str> = > <str> ) end it <str> do expect ( topic . meta_data [ <str> ] ) . to eq ( <str> ) end end context <str> do before do topic . update_meta_data ( <str> = > <str> ) end it <str> do expect ( topic . meta_data [ <str> ] ) . to eq ( <str> ) expect ( topic . meta_data [ <str> ] ) . to eq ( <str> ) end end context <str> do before do topic . update_meta_data ( <str> = > <str> ) topic . save! end it <str> do expect ( Topic . find ( topic . id ) . meta_data [ <str> ] ) . to eq ( <str> ) end it <str> do expect ( Topic . find ( topic . id ) . custom_fields [ <str> ] ) . to eq ( <str> ) end end end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( topic . archetype ) . to eq ( Archetype . default ) expect ( topic . has_summary ) . to eq ( false ) expect ( topic . percent_rank ) . to eq ( <int> . <int> ) expect ( topic ) . to be_visible expect ( topic . pinned_at ) . to be_blank expect ( topic ) . not_to be_closed expect ( topic ) . not_to be_archived expect ( topic . moderator_posts_count ) . to eq ( <int> ) end context <str> do let ( <str> ) { Fabricate ( <str> , <str> : topic , <str> : topic . user ) } it <str> do expect ( post . archetype ) . to eq ( topic . archetype ) end end end describe <str> do before do @topic = Fabricate ( <str> ) @category = Fabricate ( <str> , <str> : @topic . user ) @user = @topic . user end describe <str> do it <str> do expect { @topic . change_category_to_id ( @topic . category . id ) ; @category . reload } . not_to change ( @category , <str> ) end describe <str> do before do @topic . change_category_to_id ( @category . id ) @category . reload end it <str> do expect ( @topic . category ) . to eq ( @category ) expect ( @category . topic_count ) . to eq ( <int> ) end end it <str> do @topic . change_category_to_id ( <int> ) expect ( @topic . category_id ) . to eq ( SiteSetting . uncategorized_category_id ) end end describe <str> do before do @topic . change_category_to_id ( @category . id ) @topic . reload @category . reload end it <str> do expect ( @category . topic_count ) . to eq ( <int> ) end it <str> do expect { @topic . change_category_to_id ( @category . id ) ; @category . reload } . not_to change ( @category , <str> ) end it <str> do @topic . change_category_to_id ( <int> ) expect ( @topic . category_id ) . to be_present end describe <str> do before do @new_category = Fabricate ( <str> , <str> : @user , name : <str> ) @topic . change_category_to_id ( @new_category . id ) @topic . reload @new_category . reload @category . reload end it <str> do expect ( @new_category . topic_count ) . to eq ( <int> ) end it <str> do expect ( @category . topic_count ) . to eq ( <int> ) end end context <str> do before do SiteSetting . stubs ( <str> ) . returns ( false ) end let! ( <str> ) { Fabricate ( <str> , <str> : Fabricate ( <str> ) ) } it <str> do expect ( topic . change_category_to_id ( nil ) ) . to eq ( false ) end end describe <str> do before do @topic . change_category_to_id ( nil ) @category . reload end it <str> do expect ( @topic . category_id ) . to eq ( SiteSetting . uncategorized_category_id ) expect ( @category . topic_count ) . to eq ( <int> ) end end end end describe <str> do describe <str> do it <str> do now = Time . now a = Fabricate ( <str> , <str> : now - <int> . minutes ) b = Fabricate ( <str> , <str> : now ) c = Fabricate ( <str> , <str> : now ) d = Fabricate ( <str> , <str> : now - <int> . minutes ) expect ( Topic . by_newest ) . to eq ( [ c , b , d , a ] ) end end describe <str> do it <str> do now = Time . now a = Fabricate ( <str> , <str> : now - <int> . minutes ) b = Fabricate ( <str> , <str> : now - <int> . minute ) c = Fabricate ( <str> , <str> : now ) d = Fabricate ( <str> , <str> : now + <int> . minute ) e = Fabricate ( <str> , <str> : now + <int> . minutes ) expect ( Topic . created_since ( now ) ) . not_to include a expect ( Topic . created_since ( now ) ) . not_to include b expect ( Topic . created_since ( now ) ) . not_to include c expect ( Topic . created_since ( now ) ) . to include d expect ( Topic . created_since ( now ) ) . to include e end end describe <str> do it <str> do a = Fabricate ( <str> , <str> : false ) b = Fabricate ( <str> , <str> : true ) c = Fabricate ( <str> , <str> : true ) expect ( Topic . visible ) . not_to include a expect ( Topic . visible ) . to include b expect ( Topic . visible ) . to include c end end end describe <str> do context <str> do context <str> do it <str> do Timecop . freeze ( now ) do Jobs . expects ( <str> ) . with ( <int> . hours . from_now , <str> , all_of ( has_key ( <str> ) , has_key ( <str> ) ) ) topic = Fabricate ( <str> , <str> : Fabricate ( <str> ) ) topic . set_auto_close ( <int> ) . save end end it <str> do topic_creator = Fabricate ( <str> ) Jobs . expects ( <str> ) . with do | datetime , job_name , job_args | job_args [ <str> ] == topic_creator . id end topic = Fabricate ( <str> , <str> : topic_creator ) topic . set_auto_close ( <int> ) . save end it <str> do topic_creator = Fabricate ( <str> ) topic_closer = Fabricate ( <str> , <str> : true ) Jobs . expects ( <str> ) . with do | datetime , job_name , job_args | job_args [ <str> ] == topic_closer . id end topic = Fabricate ( <str> , <str> : topic_creator ) topic . set_auto_close ( <int> , { <str> : topic_closer } ) . save end it <str> do Timecop . freeze ( now ) do Jobs . expects ( <str> ) . with ( <int> . hours . from_now , <str> , all_of ( has_key ( <str> ) , has_key ( <str> ) ) ) topic = Fabricate ( <str> , <str> : Fabricate ( <str> ) , <str> : true , <str> : Fabricate ( <str> , <str> : <int> ) . id ) topic . set_auto_close ( <int> ) . save end end it <str> do Timecop . freeze ( now ) do topic = Fabricate ( <str> , <str> : Fabricate ( <str> ) ) topic . set_auto_close ( <int> ) . save expect ( topic . auto_close_started_at ) . to eq ( now ) end end end end context <str> do it <str> do Timecop . freeze ( now ) do topic = Fabricate ( <str> ) Jobs . expects ( <str> ) . with ( <int> . hours . from_now , <str> , has_entries ( <str> : topic . id , <str> : topic . user_id ) ) topic . auto_close_at = <int> . hours . from_now expect ( topic . save ) . to eq ( true ) end end it <str> do Timecop . freeze ( now ) do topic = Fabricate ( <str> ) closer = Fabricate ( <str> ) Jobs . expects ( <str> ) . with ( <int> . hours . from_now , <str> , has_entries ( <str> : topic . id , <str> : closer . id ) ) topic . auto_close_at = <int> . hours . from_now topic . auto_close_user = closer expect ( topic . save ) . to eq ( true ) end end it <str> do Jobs . stubs ( <str> ) . returns ( true ) topic = Fabricate ( <str> , <str> : <int> . day . from_now ) Jobs . expects ( <str> ) . with ( <str> , { <str> : topic . id } ) topic . auto_close_at = nil expect ( topic . save ) . to eq ( true ) expect ( topic . auto_close_user ) . to eq ( nil ) end it <str> do Timecop . freeze ( now ) do Jobs . stubs ( <str> ) . with ( <int> . day . from_now , <str> , anything ) . returns ( true ) topic = Fabricate ( <str> , <str> : <int> . day . from_now , <str> : Fabricate ( <str> ) ) Jobs . expects ( <str> ) . with ( <str> , { <str> : topic . id } ) Jobs . expects ( <str> ) . with ( <int> . day . from_now , <str> , has_entries ( <str> : topic . id , <str> : topic . user_id ) ) topic . auto_close_user = nil expect ( topic . save ) . to eq ( true ) end end it <str> do Timecop . freeze ( now ) do Jobs . stubs ( <str> ) . returns ( true ) topic = Fabricate ( <str> , <str> : <int> . day . from_now ) Jobs . expects ( <str> ) . with ( <str> , { <str> : topic . id } ) Jobs . expects ( <str> ) . with ( <int> . days . from_now , <str> , has_entry ( <str> : topic . id ) ) topic . auto_close_at = <int> . days . from_now expect ( topic . save ) . to eq ( true ) end end it <str> do Timecop . freeze ( now ) do admin = Fabricate ( <str> ) Jobs . stubs ( <str> ) . returns ( true ) topic = Fabricate ( <str> , <str> : <int> . day . from_now ) Jobs . expects ( <str> ) . with ( <str> , { <str> : topic . id } ) Jobs . expects ( <str> ) . with ( <int> . day . from_now , <str> , has_entries ( <str> : topic . id , <str> : admin . id ) ) topic . auto_close_user = admin expect ( topic . save ) . to eq ( true ) end end it <str> do Timecop . freeze ( now ) do Jobs . expects ( <str> ) . with ( <int> . day . from_now , <str> , has_key ( <str> ) ) . once . returns ( true ) Jobs . expects ( <str> ) . never topic = Fabricate ( <str> , <str> : <int> . day . from_now ) topic . title = <str> expect ( topic . save ) . to eq ( true ) end end it <str> do Timecop . freeze ( now ) do mod = Fabricate ( <str> ) topic = Fabricate ( <str> , <str> : Fabricate ( <str> , <str> : <int> ) , <str> : mod ) Jobs . expects ( <str> ) . with ( <int> . hours . from_now , <str> , has_entries ( <str> : topic . id , <str> : topic . user_id ) ) topic . auto_close_at = <int> . hours . from_now topic . save topic . reload expect ( topic . closed ) . to eq ( false ) Timecop . freeze ( <int> . hours . from_now ) do Topic . auto_close topic . reload expect ( topic . closed ) . to eq ( true ) end end end end end describe <str> do let ( <str> ) { Fabricate . build ( <str> ) } let ( <str> ) { Fabricate . build ( <str> , <str> : <int> , <str> : <int> . hours . from_now , <str> : <int> . hours . from_now ) } let ( <str> ) { Fabricate . build ( <str> , id : <int> ) } let ( <str> ) { Fabricate . build ( <str> ) } before { Discourse . stubs ( <str> ) . returns ( admin ) } it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <int> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( <int> . days . from_now ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <int> , { <str> : admin , <str> : <int> } ) expect ( topic . auto_close_at ) . to eq ( <int> . days . from_now ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( <int> . hours . from_now ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin , <str> : <int> } ) expect ( topic . auto_close_at ) . to eq ( <int> . hours . from_now ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin , <str> : <int> } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin , <str> : <int> } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin , <str> : <int> } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( Time . zone . local ( <int> , <int> , <int> , <int> , <int> ) ) expect ( topic . errors [ <str> ] ) . to be_present end end it <str> do Timecop . freeze ( now ) do topic . set_auto_close ( <str> , { <str> : admin } ) expect ( topic . auto_close_at ) . to eq ( Time . utc ( <int> , <int> , <int> , <int> , <int> ) ) end end it <str> do topic . set_auto_close ( <int> , { <str> : admin } ) expect ( topic . auto_close_user_id ) . to eq ( admin . id ) end it <str> do topic . set_auto_close ( <int> , { <str> : trust_level_4 } ) expect ( topic . auto_close_user_id ) . to eq ( trust_level_4 . id ) end it <str> do topic . set_auto_close ( <int> , { <str> : Fabricate . build ( <str> , id : <int> ) } ) expect ( topic . auto_close_user_id ) . to eq ( admin . id ) end it <str> do topic . set_auto_close ( <int> ) expect ( topic . auto_close_user_id ) . to eq ( admin . id ) end it <str> do staff_topic = Fabricate . build ( <str> , <str> : Fabricate . build ( <str> , id : <int> ) ) staff_topic . set_auto_close ( <int> ) expect ( staff_topic . auto_close_user_id ) . to eq ( <int> ) end it <str> do tl4_topic = Fabricate . build ( <str> , <str> : Fabricate . build ( <str> , id : <int> ) ) tl4_topic . set_auto_close ( <int> ) expect ( tl4_topic . auto_close_user_id ) . to eq ( <int> ) end it <str> do closing_topic . set_auto_close ( nil ) expect ( closing_topic . auto_close_at ) . to be_nil end it <str> do closing_topic . set_auto_close ( nil ) expect ( closing_topic . auto_close_started_at ) . to be_nil end it <str> do Timecop . freeze ( now ) do closing_topic . set_auto_close ( <int> ) expect ( closing_topic . auto_close_at ) . to eq ( <int> . days . from_now ) end end it <str> do expect { closing_topic . set_auto_close ( <int> ) } . to_not change ( closing_topic , <str> ) end end describe <str> do let ( <str> ) { Fabricate . build ( <str> ) } it <str> do expect ( Topic . for_digest ( user , <int> . year . ago , <str> : true ) ) . to be_blank end it <str> do Fabricate ( <str> ) expect ( Topic . for_digest ( user , <int> . year . ago , <str> : true ) ) . to be_blank end it <str> do topic = Fabricate ( <str> ) expect ( Topic . for_digest ( user , <int> . year . ago , <str> : true ) ) . to eq ( [ topic ] ) end it <str> do user = Fabricate ( <str> ) category = Fabricate ( <str> ) Fabricate ( <str> , <str> : category ) CategoryUser . set_notification_level_for_category ( user , CategoryUser . notification_levels [ <str> ] , category . id ) expect ( Topic . for_digest ( user , <int> . year . ago , <str> : true ) ) . to be_blank end it <str> do new_user = Fabricate ( <str> , <str> : <int> ) Fabricate ( <str> , <str> : new_user . id ) expect ( Topic . for_digest ( user , <int> . year . ago , <str> : true ) ) . to be_blank end end describe <str> do it <str> do category = Fabricate ( <str> , <str> : true ) Fabricate ( <str> , <str> : category ) expect ( Topic . secured ( Guardian . new ( nil ) ) . count ) . to eq ( <int> ) expect ( Topic . secured ( Guardian . new ( Fabricate ( <str> ) ) ) . count ) . to eq ( <int> ) expect ( Topic . for_digest ( Fabricate ( <str> ) , <int> . year . ago ) . count ) . to eq ( <int> ) expect ( Topic . for_digest ( Fabricate ( <str> ) , <int> . year . ago ) . count ) . to eq ( <int> ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> , <str> : [ group ] ) } let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Fabricate ( <str> , <str> : true ) } let! ( <str> ) { Fabricate ( <str> ) } before do topic . allowed_users << allowed_user group . users << allowed_group_user end it <str> do expect ( topic . all_allowed_users ) . to include allowed_user end it <str> do expect ( topic . all_allowed_users ) . to include allowed_group_user end it <str> do topic . stubs ( <str> ) . returns ( true ) topic . stubs ( <str> ) . returns ( true ) expect ( topic . all_allowed_users ) . to include moderator end it <str> do topic . stubs ( <str> ) . returns ( true ) expect ( topic . all_allowed_users ) . not_to include moderator end it <str> do expect ( topic . all_allowed_users ) . not_to include moderator end it <str> do expect ( topic . all_allowed_users ) . not_to include rando end end describe <str> do before ( <str> ) do Timecop . freeze Fabricate ( <str> ) Fabricate ( <str> , <str> : <int> . day . ago ) Fabricate ( <str> , <str> : <int> . day . ago ) Fabricate ( <str> , <str> : <int> . days . ago ) Fabricate ( <str> , <str> : <int> . days . ago ) end after ( <str> ) do Timecop . return end let ( <str> ) { { <int> . day . ago . to_date = > <int> , <int> . days . ago . to_date = > <int> , Time . now . utc . to_date = > <int> } } it <str> do expect ( Topic . listable_count_per_day ( <int> . days . ago , Time . now ) ) . to include ( listable_topics_count_per_day ) expect ( Topic . listable_count_per_day ( <int> . days . ago , Time . now ) ) . not_to include ( { <int> . days . ago . to_date = > <int> } ) end end describe <str> do let ( <str> ) { Category . new } it <str> do category . stubs ( <str> ) . returns ( true ) expect ( Topic . new ( <str> = > category ) ) . to be_read_restricted_category end it <str> do category . stubs ( <str> ) . returns ( false ) expect ( Topic . new ( <str> = > category ) ) . not_to be_read_restricted_category end it <str> do expect ( Topic . new ( <str> = > nil ) ) . not_to be_read_restricted_category end end describe <str> do context <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } it <str> do topic = Fabricate ( <str> , <str> : category ) expect { topic . trash! ( moderator ) } . to change { category . reload . topic_count } . by ( - <int> ) end it <str> do topic = Fabricate ( <str> , <str> : category , <str> : <int> . day . ago ) expect { topic . trash! ( moderator ) } . to_not change { category . reload . topic_count } end end end describe <str> do context <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do topic = Fabricate ( <str> , <str> : category , <str> : <int> . day . ago ) expect { topic . recover! } . to change { category . reload . topic_count } . by ( <int> ) end it <str> do topic = Fabricate ( <str> , <str> : category ) expect { topic . recover! } . to_not change { category . reload . topic_count } end end end it <str> do SiteSetting . stubs ( <str> ) . returns ( <int> ) SiteSetting . stubs ( <str> ) . returns ( <int> ) SiteSetting . stubs ( <str> ) . returns ( SiteSetting . client_settings_json_uncached ) RateLimiter . stubs ( <str> ) . returns ( <int> ) RateLimiter . stubs ( <str> ) . returns ( false ) RateLimiter . clear_all! start = Time . now . tomorrow . beginning_of_day freeze_time ( start ) user = Fabricate ( <str> ) topic_id = create_post ( <str> : user ) . topic_id freeze_time ( start + <int> . minutes ) expect { create_post ( <str> : user ) } . to raise_exception freeze_time ( start + <int> . minutes ) create_post ( <str> : user , <str> : topic_id ) freeze_time ( start + <int> . minutes ) expect { create_post ( <str> : user , <str> : topic_id ) } . to raise_exception end describe <str> do before { SiteSetting . stubs ( <str> ) . returns ( <int> ) } context <str> do it <str> do Topic . stubs ( <str> ) . returns ( <int> ) expect ( Topic . count_exceeds_minimum? ) . to be_truthy end end context <str> do it <str> do Topic . stubs ( <str> ) . returns ( <int> ) expect ( Topic . count_exceeds_minimum? ) . to_not be_truthy end end end describe <str> do it <str> do Topic . calculate_avg_time Topic . calculate_avg_time ( <int> . day . ago ) end end describe <str> do let ( <str> ) { Fabricate . build ( <str> ) } it <str> do expect ( topic . expandable_first_post? ) . to eq ( false ) end describe <str> do before do Fabricate ( <str> ) SiteSetting . embed_truncate = true topic . stubs ( <str> ) . returns ( true ) end it <str> do expect ( topic . expandable_first_post? ) . to eq ( true ) end it <str> do SiteSetting . embed_truncate = false expect ( topic . expandable_first_post? ) . to eq ( false ) end it <str> do topic . stubs ( <str> ) . returns ( false ) expect ( topic . expandable_first_post? ) . to eq ( false ) end end end it <str> do topic = Fabricate ( <str> ) expect ( topic . custom_fields [ <str> ] ) . to eq ( nil ) topic . custom_fields [ <str> ] = <str> topic . custom_fields [ <str> ] = <str> topic . save topic = Topic . find ( topic . id ) expect ( topic . custom_fields ) . to eq ( { <str> = > <str> , <str> = > <str> } ) end it <str> do SiteSetting . stubs ( <str> ) . returns ( <int> ) topic = Fabricate ( <str> , <str> : <str> ) expect ( topic ) . to be_valid SiteSetting . stubs ( <str> ) . returns ( <int> ) topic . last_posted_at = <int> . minute . ago expect ( topic . save ) . to eq ( true ) end context <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) . tap { | g | g . add_owner ( group_manager ) } } let ( <str> ) { Fabricate ( <str> , <str> : group ) } let ( <str> ) { Fabricate ( <str> , <str> : private_category , <str> : group_manager ) } context <str> do let ( <str> ) { <str> } it <str> do invite = group_private_topic . invite ( group_manager , randolph ) expect ( invite . groups ) . to eq ( [ group ] ) end end context <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( Guardian . new ( walter ) . can_see? ( group_private_topic ) ) . to be_falsey invite = group_private_topic . invite ( group_manager , walter . email ) expect ( invite ) . to be_nil expect ( walter . groups ) . to include ( group ) expect ( Guardian . new ( walter ) . can_see? ( group_private_topic ) ) . to be_truthy end end end it <str> do topic = Fabricate ( <str> ) user = topic . user expect ( topic . message_archived? ( user ) ) . to eq ( false ) group = Fabricate ( <str> ) group . add ( user ) TopicAllowedGroup . create! ( <str> : topic . id , <str> : group . id ) GroupArchivedMessage . create! ( <str> : topic . id , <str> : group . id ) expect ( topic . message_archived? ( user ) ) . to eq ( true ) end end 
