module Rubinius class Stat include Comparable attr_reader <str> def self . stat ( path ) stat = allocate if Rubinius . privately { stat . setup path } == <int> stat else nil end end def self . fstat ( fd ) stat = allocate result = Rubinius . privately { stat . fsetup fd } Errno . handle <str> descriptor <str> unless result == <int> stat end def self . lstat ( path ) stat = allocate result = Rubinius . privately { stat . lsetup path } Errno . handle path unless result == <int> stat end def initialize ( path ) Errno . handle path unless setup ( path ) == <int> end def setup ( path ) Rubinius . primitive <str> path = Rubinius :: Type . coerce_to_path ( path ) setup ( path ) end private <str> def fsetup ( fd ) Rubinius . primitive <str> fd = Rubinius :: Type . coerce_to fd , Integer , <str> fsetup ( fd ) end private <str> def lsetup ( path ) Rubinius . primitive <str> path = Rubinius :: Type . coerce_to_path ( path ) lsetup ( path ) end private <str> def dev Rubinius . primitive <str> raise PrimitiveFailure , <str> end def ino Rubinius . primitive <str> raise PrimitiveFailure , <str> end def mode Rubinius . primitive <str> raise PrimitiveFailure , <str> end def nlink Rubinius . primitive <str> raise PrimitiveFailure , <str> end def uid Rubinius . primitive <str> raise PrimitiveFailure , <str> end def gid Rubinius . primitive <str> raise PrimitiveFailure , <str> end def rdev Rubinius . primitive <str> raise PrimitiveFailure , <str> end def size Rubinius . primitive <str> raise PrimitiveFailure , <str> end def blksize Rubinius . primitive <str> raise PrimitiveFailure , <str> end def blocks Rubinius . primitive <str> raise PrimitiveFailure , <str> end def atime Rubinius . primitive <str> raise PrimitiveFailure , <str> end def mtime Rubinius . primitive <str> raise PrimitiveFailure , <str> end def ctime Rubinius . primitive <str> raise PrimitiveFailure , <str> end def birthtime Rubinius . primitive <str> raise NotImplementedError , <str> end def inspect <str> self . class . name <str> self . dev . to_s ( <int> ) <str> self . ino <str> \ <str> sprintf ( <str> , self . mode . to_s ( <int> ) . to_i ) <str> self . nlink <str> \ <str> self . uid <str> self . gid <str> self . rdev . to_s ( <int> ) <str> \ <str> self . size <str> self . blksize <str> self . blocks <str> \ <str> self . atime <str> self . mtime <str> self . ctime <str> end def blockdev? mode & S_IFMT == S_IFBLK end def chardev? mode & S_IFMT == S_IFCHR end def dev_major major = Rubinius :: FFI :: Platform :: POSIX . major dev major < <int> ? nil : major end def dev_minor minor = Rubinius :: FFI :: Platform :: POSIX . major dev minor < <int> ? nil : minor end def directory? mode & S_IFMT == S_IFDIR end def executable? return true if superuser? return mode & S_IXUSR != <int> if owned? return mode & S_IXGRP != <int> if grpowned? return mode & S_IXOTH != <int> end def executable_real? return true if rsuperuser? return mode & S_IXUSR != <int> if rowned? return mode & S_IXGRP != <int> if rgrpowned? return mode & S_IXOTH != <int> end def file? mode & S_IFMT == S_IFREG end def ftype if file? <str> elsif directory? <str> elsif chardev? <str> elsif blockdev? <str> elsif pipe? <str> elsif socket? <str> elsif symlink? <str> else <str> end end def grpowned? Process . groups . include? ( gid ) end def owned? uid == Rubinius :: FFI :: Platform :: POSIX . geteuid end def pipe? mode & S_IFMT == S_IFIFO end def rdev_major major = Rubinius :: FFI :: Platform :: POSIX . major rdev major < <int> ? nil : major end def rdev_minor minor = Rubinius :: FFI :: Platform :: POSIX . minor rdev minor < <int> ? nil : minor end def readable? return true if superuser? return mode & S_IRUSR != <int> if owned? return mode & S_IRGRP != <int> if grpowned? return mode & S_IROTH != <int> end def readable_real? return true if rsuperuser? return mode & S_IRUSR != <int> if rowned? return mode & S_IRGRP != <int> if rgrpowned? return mode & S_IROTH != <int> end def setgid? mode & S_ISGID != <int> end def setuid? mode & S_ISUID != <int> end def sticky? mode & S_ISVTX != <int> end def size? size == <int> ? nil : size end def socket? mode & S_IFMT == S_IFSOCK end def symlink? mode & S_IFMT == S_IFLNK end def writable? return true if superuser? return mode & S_IWUSR != <int> if owned? return mode & S_IWGRP != <int> if grpowned? return mode & S_IWOTH != <int> end def writable_real? return true if rsuperuser? return mode & S_IWUSR != <int> if rowned? return mode & S_IWGRP != <int> if rgrpowned? return mode & S_IWOTH != <int> end def zero? size == <int> end def <=> ( other ) return nil unless other . is_a? ( File :: Stat ) self . mtime < = > other . mtime end def rgrpowned? gid == Rubinius :: FFI :: Platform :: POSIX . getgid end private <str> def rowned? uid == Rubinius :: FFI :: Platform :: POSIX . getuid end private <str> def rsuperuser? Rubinius :: FFI :: Platform :: POSIX . getuid == <int> end private <str> def superuser? Rubinius :: FFI :: Platform :: POSIX . geteuid == <int> end private <str> end end 
