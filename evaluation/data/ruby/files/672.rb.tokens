warn ( <str> ) if $VERBOSE class Numeric ; end require <str> require <str> require <str> require <str> require <str> unless defined? ( Math . exp! ) Object . instance_eval { remove_const <str> } Math = CMath end class Fixnum remove_method <str> alias / quo end class Bignum remove_method <str> alias / quo end module Math remove_method ( <str> ) def sqrt ( a ) if a . kind_of? ( Complex ) abs = sqrt ( a . real * a . real + a . imag * a . imag ) x = sqrt ( ( a . real + abs ) / Rational ( <int> ) ) y = sqrt ( ( - a . real + abs ) / Rational ( <int> ) ) if a . imag > = <int> Complex ( x , y ) else Complex ( x , - y ) end elsif a . respond_to? ( <str> ) and a . nan? a elsif a > = <int> rsqrt ( a ) else Complex ( <int> , rsqrt ( - a ) ) end end def rsqrt ( a ) if a . kind_of? ( Float ) sqrt! ( a ) elsif a . kind_of? ( Rational ) rsqrt ( a . numerator ) / rsqrt ( a . denominator ) else src = a max = <int> ** <int> byte_a = [ src & <hex> ] while ( src > = max ) and ( src >> = <int> ) byte_a . unshift src & <hex> end answer = <int> main = <int> side = <int> for elm in byte_a main = ( main << <int> ) + elm side << = <int> if answer != <int> if main * <int> < side * side applo = main . div ( side ) else applo = ( ( sqrt! ( side * side + <int> * main ) - side ) / <int> . <int> ) . to_i + <int> end else applo = sqrt! ( main ) . to_i + <int> end while ( x = ( side + applo ) * applo ) > main applo -= <int> end main -= x answer = ( answer << <int> ) + applo side += applo * <int> end if main == <int> answer else sqrt! ( a ) end end end class << self remove_method ( <str> ) end module_function <str> module_function <str> end 
