require <str> require <str> module Tilt class Console def initialize ( prefix = nil ) @prefix = prefix || <str> end def log ( msg ) Rails . logger . info ( <str> @prefix <str> msg <str> ) end def error ( msg ) Rails . logger . error ( <str> @prefix <str> msg <str> ) end end class ES6ModuleTranspilerTemplate < Tilt :: Template self . default_mime_type = <str> @mutex = Mutex . new @ctx_init = Mutex . new def prepare end def self . create_new_context ctx = V8 :: Context . new ( <str> : <int> ) ctx . eval ( <str> File . read ( Babel :: Transpiler . script_path ) <str> ) ctx . eval ( <str> ) ; ctx . load ( <str> Rails . root <str> ) ctx end def self . v8 return @ctx if @ctx @ctx_init . synchronize do return @ctx if @ctx @ctx = create_new_context end @ctx end class JavaScriptError < StandardError attr_accessor <str> , <str> def initialize ( message , backtrace ) @message = message @backtrace = backtrace end end def self . protect rval = nil @mutex . synchronize do begin rval = yield rescue V8 :: Error = > e raise JavaScriptError . new ( e . message , e . backtrace ) end end rval end def whitelisted? ( path ) @@whitelisted || = Set . new ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) @@whitelisted . include? ( path ) || path =~ <str> end def evaluate ( scope , locals , & block ) return @output if @output klass = self . class klass . protect do klass . v8 [ <str> ] = Console . new ( <str> scope . logical_path <str> ) @output = klass . v8 . eval ( generate_source ( scope ) ) end if whitelisted? ( scope . logical_path ) && scope . logical_path =~ <str> type = Regexp . last_match [ <int> ] file_name = Regexp . last_match [ <int> ] . gsub ( <str> , <str> ) class_name = file_name . classify if file_name . end_with? ( <str> ) && ( ! class_name . end_with? ( <str> ) ) class_name << <str> end require_name = module_name ( scope . root_path , scope . logical_path ) if require_name !~ <str> && require_name !~ <str> result = <str> class_name <str> type . classify <str> result = <str> if result == <str> result = <str> if result == <str> result = <str> if result == <str> result . gsub! ( <str> , <str> ) result . gsub! ( <str> , <str> ) if result != <str> @output << <str> result <str> require_name <str> end end end @output end private def generate_source ( scope ) js_source = :: JSON . generate ( data , <str> : true ) js_source = <str> js_source <str> <str> js_source <str> module_name ( scope . root_path , scope . logical_path ) <str> compiler_options <str> compiler_method <str> end def module_name ( root_path , logical_path ) path = nil root_base = File . basename ( Rails . root ) if root_path =~ <str> root_base <str> plugin_path = <str> Regexp . last_match [ <int> ] <str> plugin = Discourse . plugins . find { | p | p . path == plugin_path } path = <str> plugin . name <str> logical_path . sub ( <str> , <str> ) <str> if plugin end path || = logical_path if ES6ModuleTranspiler . transform path = ES6ModuleTranspiler . transform . call ( path ) end path end def compiler_method type = { <str> : <str> , <str> : <str> , <str> : <str> } [ ES6ModuleTranspiler . compile_to . to_sym ] <str> type <str> end def compiler_options :: JSON . generate ( ES6ModuleTranspiler . compiler_options , <str> : true ) end end end 
