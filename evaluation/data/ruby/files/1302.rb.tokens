require <str> require <str> require <str> require <str> RSpec . describe Msf :: Exploit :: Remote :: SMB :: Server :: Share do include_context <str> subject ( <str> ) do mod = Msf :: Exploit . new mod . extend described_class mod . send ( <str> ) mod end let ( <str> ) { <int> } let ( <str> ) do <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> end let ( <str> ) { <int> } let ( <str> ) do <str> + <str> + <str> + <str> + <str> + <str> end let ( <str> ) { <int> } let ( <str> ) do <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> end let ( <str> ) { <str> } let ( <str> ) { <str> } let ( <str> ) { <str> } let ( <str> ) { <int> } let ( <str> ) { <int> } let ( <str> ) { <int> } let ( <str> ) { <int> } let ( <str> ) { <int> } let ( <str> ) { <int> } let ( <str> ) { <int> } before ( <str> ) do msf_io . string = <str> mod . instance_variable_set ( <str> , { msf_io = > { <str> = > <hex> , <str> = > <hex> , <str> = > <hex> , <str> = > <hex> } } ) mod . lo = <int> mod . hi = <int> mod . share = <str> mod . file_name = <str> mod . file_contents = <str> end describe <str> do context <str> do it <str> do expect ( mod . send_find_file_both_directory_info_res ( msf_io ) ) . to eq ( default_find_file_both_directory_info_res_length ) end it <str> do mod . send_find_file_both_directory_info_res ( msf_io ) res = msf_io . read expect ( res ) . to eq ( default_find_file_both_directory_info_res ) end end end describe <str> do context <str> do it <str> do expect ( mod . send_find_file_names_info_res ( msf_io ) ) . to eq ( default_find_file_names_info_res_length ) end it <str> do mod . send_find_file_names_info_res ( msf_io ) res = msf_io . read expect ( res ) . to eq ( default_find_file_names_info_res ) end end end describe <str> do context <str> do it <str> do expect ( mod . send_find_full_directory_info_res ( msf_io ) ) . to eq ( default_find_full_directory_info_res_length ) end it <str> do mod . send_find_full_directory_info_res ( msf_io ) res = msf_io . read expect ( res ) . to eq ( default_find_full_directory_info_res ) end end end describe <str> do context <str> do it <str> do expect ( mod . smb_cmd_find_file_both_directory_info ( msf_io , non_existent_path ) ) . to eq ( error_res_length ) end it <str> do mod . smb_cmd_find_file_both_directory_info ( msf_io , non_existent_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) expect ( trans2_res [ <str> ] [ <str> ] . v [ <str> ] ) . to eq ( Rex :: Proto :: SMB :: Constants :: SMB_STATUS_NO_SUCH_FILE ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_both_directory_info ( msf_io , file_path ) ) . to eq ( existent_file_file_both_dir_res_length ) end it <str> do mod . smb_cmd_find_file_both_directory_info ( msf_io , file_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_BOTH_DIRECTORY_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( mod . file_name ) ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_both_directory_info ( msf_io , folder_path ) ) . to eq ( existent_folder_file_both_dir_res_length ) end it <str> do mod . smb_cmd_find_file_both_directory_info ( msf_io , folder_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_BOTH_DIRECTORY_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( folder_path ) ) end end end describe <str> do context <str> do it <str> do expect ( mod . smb_cmd_find_file_names_info ( msf_io , non_existent_path ) ) . to eq ( error_res_length ) end it <str> do mod . smb_cmd_find_file_names_info ( msf_io , non_existent_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) expect ( trans2_res [ <str> ] [ <str> ] . v [ <str> ] ) . to eq ( Rex :: Proto :: SMB :: Constants :: SMB_STATUS_NO_SUCH_FILE ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_names_info ( msf_io , file_path ) ) . to eq ( existent_file_file_names_res_length ) end it <str> do mod . smb_cmd_find_file_names_info ( msf_io , file_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_NAMES_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( mod . file_name ) ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_names_info ( msf_io , folder_path ) ) . to eq ( existent_folder_file_names_res_length ) end it <str> do mod . smb_cmd_find_file_names_info ( msf_io , folder_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_NAMES_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( folder_path ) ) end end end describe <str> do context <str> do it <str> do expect ( mod . smb_cmd_find_file_full_directory_info ( msf_io , non_existent_path ) ) . to eq ( error_res_length ) end it <str> do mod . smb_cmd_find_file_full_directory_info ( msf_io , non_existent_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) expect ( trans2_res [ <str> ] [ <str> ] . v [ <str> ] ) . to eq ( Rex :: Proto :: SMB :: Constants :: SMB_STATUS_NO_SUCH_FILE ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_full_directory_info ( msf_io , file_path ) ) . to eq ( existent_file_file_full_res_length ) end it <str> do mod . smb_cmd_find_file_full_directory_info ( msf_io , file_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_FULL_DIRECTORY_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( mod . file_name ) ) end end context <str> do it <str> do expect ( mod . smb_cmd_find_file_full_directory_info ( msf_io , folder_path ) ) . to eq ( existent_folder_file_full_res_length ) end it <str> do mod . smb_cmd_find_file_full_directory_info ( msf_io , folder_path ) res = msf_io . read trans2_res = Rex :: Proto :: SMB :: Constants :: SMB_TRANS_RES_PKT . make_struct trans2_res . from_s ( res ) param_count = trans2_res [ <str> ] . v [ <str> ] data_count = trans2_res [ <str> ] . v [ <str> ] data = trans2_res [ <str> ] . v [ <str> ] [ <int> + param_count , data_count ] smb_data = Rex :: Proto :: SMB :: Constants :: SMB_FIND_FILE_FULL_DIRECTORY_INFO_HDR . make_struct smb_data . from_s ( data ) expect ( smb_data . v [ <str> ] ) . to eq ( Rex :: Text . to_unicode ( folder_path ) ) end end end end 
