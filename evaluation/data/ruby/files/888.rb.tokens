describe <str> , <str> = > true do before <str> do @name = tmp ( <str> ) end after <str> do rm_r @name end it <str> do lambda { Process . wait @object . spawn ( <str> ) } . should output_to_fd ( <str> ) end it <str> do pid = @object . spawn ( ruby_cmd ( <str> ) ) Process . wait pid pid . should be_an_instance_of ( Fixnum ) end it <str> do start = Time . now pid = @object . spawn ( ruby_cmd ( <str> ) ) ( Time . now - start ) . should < <int> Process . kill <str> , pid Process . wait pid end describe <str> do it <str> do lambda { Process . wait @object . spawn ( <str> ) } . should_not output_to_fd ( <str> ) end it <str> do lambda { Process . wait @object . spawn ( <str> ) } . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda { Process . wait @object . spawn ( o ) } . should output_to_fd ( <str> ) end it <str> do lambda { @object . spawn <str> } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn <str> } . should raise_error ( TypeError ) end end describe <str> do it <str> do lambda { Process . wait @object . spawn ( <str> , <str> ) } . should output_to_fd ( <str> ) end it <str> do lambda { Process . wait @object . spawn ( <str> , <str> ) } . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda { Process . wait @object . spawn ( <str> , o ) } . should output_to_fd ( <str> ) end it <str> do lambda { @object . spawn <str> , <str> } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn <str> , <str> } . should raise_error ( TypeError ) end end describe <str> do it <str> do lambda { Process . wait @object . spawn ( [ <str> , <str> ] , <str> , <str> ) } . should output_to_fd ( <str> ) end it <str> do lambda { Process . wait @object . spawn ( [ <str> , <str> ] , <str> ) } . should output_to_fd ( <str> ) end it <str> do lambda { Process . wait @object . spawn ( [ <str> , <str> ] , <str> ) } . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( [ <str> , <str> ] ) lambda { Process . wait @object . spawn ( o , <str> , <str> ) } . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda { Process . wait @object . spawn ( [ o , <str> ] , <str> ) } . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda { Process . wait @object . spawn ( [ <str> , o ] , <str> ) } . should output_to_fd ( <str> ) end it <str> do lambda { @object . spawn ( [ ] ) } . should raise_error ( ArgumentError ) lambda { @object . spawn ( [ <str> ] ) } . should raise_error ( ArgumentError ) lambda { @object . spawn ( [ <str> , <str> , <str> ] ) } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn [ <str> , <str> ] } . should raise_error ( ArgumentError ) lambda { @object . spawn [ <str> , <str> ] } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn [ <str> , <str> ] } . should raise_error ( TypeError ) lambda { @object . spawn [ <str> , <str> ] } . should raise_error ( TypeError ) end end after <str> do ENV . delete ( <str> ) end it <str> do lambda do Process . wait @object . spawn ( { <str> = > <str> } , ruby_cmd ( <str> ) ) end . should output_to_fd ( <str> ) end it <str> do ENV [ <str> ] = <str> lambda do Process . wait @object . spawn ( { <str> = > nil } , ruby_cmd ( <str> ) ) end . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( { <str> = > <str> } ) lambda do Process . wait @object . spawn ( o , ruby_cmd ( <str> ) ) end . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda do Process . wait @object . spawn ( { o = > <str> } , ruby_cmd ( <str> ) ) end . should output_to_fd ( <str> ) end it <str> do o = mock ( <str> ) o . should_receive ( <str> ) . and_return ( <str> ) lambda do Process . wait @object . spawn ( { <str> = > o } , ruby_cmd ( <str> ) ) end . should output_to_fd ( <str> ) end it <str> do lambda do @object . spawn ( { <str> = > <str> } , ruby_cmd ( <str> ) ) end . should raise_error ( ArgumentError ) end it <str> do lambda do @object . spawn ( { <str> = > <str> } , ruby_cmd ( <str> ) ) end . should raise_error ( ArgumentError ) end it <str> do lambda do @object . spawn ( { <str> = > <str> } , ruby_cmd ( <str> ) ) end . should raise_error ( ArgumentError ) end it <str> do ENV [ <str> ] = <str> lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > true ) end . should output_to_fd ( <str> ) end it <str> do ENV [ <str> ] = <str> lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > <str> ) end . should output_to_fd ( <str> ) end it <str> do ENV [ <str> ] = <str> lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > false ) end . should output_to_fd ( <str> ) end it <str> do ENV [ <str> ] = <str> lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > nil ) end . should output_to_fd ( <str> ) end it <str> do lambda do Process . wait @object . spawn ( { <str> = > <str> } , ruby_cmd ( <str> ) , <str> = > true ) end . should output_to_fd ( <str> ) end platform_is_not <str> do it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) ) end . should output_to_fd ( Process . getpgid ( Process . pid ) . to_s ) end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > false ) end . should output_to_fd ( Process . getpgid ( Process . pid ) . to_s ) end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > nil ) end . should output_to_fd ( Process . getpgid ( Process . pid ) . to_s ) end it <str> do process = lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > true ) end process . should_not output_to_fd ( Process . getpgid ( Process . pid ) . to_s ) process . should output_to_fd ( <str> ) end it <str> do process = lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > <int> ) end process . should_not output_to_fd ( Process . getpgid ( Process . pid ) . to_s ) process . should output_to_fd ( <str> ) end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > <int> ) end . should_not output_to_fd ( <str> ) end it <str> do lambda { @object . spawn ( <str> , <str> = > - <int> ) } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn ( <str> , <str> = > <str> ) } . should raise_error ( TypeError ) end end platform_is <str> do it <str> do lambda { @object . spawn ( <str> , <str> = > false ) } . should raise_error ( ArgumentError ) end end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) ) end . should output_to_fd ( Dir . pwd ) end describe <str> do before do @dir = tmp ( <str> , false ) Dir . mkdir @dir end after do rm_r @dir end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > @dir ) end . should output_to_fd ( @dir ) end it <str> do dir = mock ( <str> ) dir . should_receive ( <str> ) . and_return ( @dir ) lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > dir ) end . should output_to_fd ( @dir ) end end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) ) end . should output_to_fd ( File . umask . to_s ) end it <str> do lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > <int> ) end . should output_to_fd ( <str> ) end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > file . fileno ) end . should output_to_fd ( <str> , file ) end end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > file ) end . should output_to_fd ( <str> , file ) end end it <str> do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > @name ) @name . should have_data ( <str> ) end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > file . fileno ) end . should output_to_fd ( <str> , file ) end end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > file ) end . should output_to_fd ( <str> , file ) end end it <str> do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > @name ) @name . should have_data ( <str> ) end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , <str> = > file , <str> = > [ <str> , <str> ] ) end . should output_to_fd ( <str> , file ) end end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , [ <str> , <str> ] = > file . fileno ) end . should output_to_fd ( <str> , file ) end end it <str> do File . open ( @name , <str> ) do | file | lambda do Process . wait @object . spawn ( ruby_cmd ( <str> ) , [ <str> , <str> ] = > file ) end . should output_to_fd ( <str> , file ) end end it <str> do touch @name Process . wait @object . spawn ( ruby_cmd ( <str> ) , [ <str> , <str> ] = > @name ) @name . should have_data ( <str> ) end context <str> do before <str> do @output = tmp ( <str> ) @options = { <str> = > true } @command = <str> RUBY_EXE <str> @options . inspect <str> end after <str> do rm_r @output end it <str> do IO . pipe do | r , w | begin pid = @object . spawn ( ruby_cmd ( <str> ) , @options ) w . close lambda { r . read_nonblock ( <int> ) } . should raise_error ( EOFError ) ensure Process . kill ( <str> , pid ) Process . wait ( pid ) end end end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end end context <str> do before <str> do @output = tmp ( <str> ) @options = { <str> = > false } @command = <str> RUBY_EXE <str> @options . inspect <str> end after <str> do rm_r @output end it <str> do IO . pipe do | r , w | begin pid = @object . spawn ( ruby_cmd ( <str> ) , @options ) w . close lambda { r . read_nonblock ( <int> ) } . should raise_error ( EOFError ) ensure Process . kill ( <str> , pid ) Process . wait ( pid ) end end end it <str> do IO . pipe do | r , w | r . close_on_exec = false w . close_on_exec = false begin pid = @object . spawn ( ruby_cmd ( <str> ) , @options ) w . close lambda { r . read_nonblock ( <int> ) } . should raise_error ( Errno :: EAGAIN ) ensure Process . kill ( <str> , pid ) Process . wait ( pid ) end end end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end it <str> do cmd = @command % [ <str> ] ruby_exe ( cmd , <str> = > <str> @output <str> ) @output . should have_data ( <str> ) end end it <str> do lambda { @object . spawn } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn ( { } ) } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn ( { } , { } ) } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn <str> } . should raise_error ( Errno :: ENOENT ) end it <str> do lambda { @object . spawn <str> } . should raise_error ( Errno :: ENOENT ) end it <str> do lambda { @object . spawn __FILE__ } . should raise_error ( Errno :: EACCES ) end it <str> do lambda { @object . spawn File . dirname ( __FILE__ ) } . should raise_error ( Errno :: EACCES ) end it <str> do lambda { @object . spawn ( <str> , <str> = > Dir . pwd ) } . should raise_error ( ArgumentError ) end it <str> do lambda { @object . spawn ( <str> , <str> = > <str> ) } . should raise_error ( ArgumentError ) end describe <str> do before <str> do @name = tmp ( <str> ) @io = new_io @name , <str> @io . sync = true end after <str> do @io . close unless @io . closed? rm_r @name end it <str> do child_fd = @io . fileno + <int> args = [ RUBY_EXE , fixture ( __FILE__ , <str> ) , child_fd . to_s ] pid = @object . spawn * args , { child_fd = > @io } Process . waitpid pid @io . rewind @io . read . should == <str> child_fd <str> end end end 
