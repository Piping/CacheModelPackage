require <str> require <str> require <str> require <str> module ActiveRecord module Core extend ActiveSupport :: Concern included do mattr_accessor <str> , <str> : false def self . configurations = ( config ) @@configurations = ActiveRecord :: ConnectionHandling :: MergeAndResolveDefaultUrlConfig . new ( config ) . resolve end self . configurations = { } def self . configurations @@configurations end mattr_accessor <str> , <str> : false self . default_timezone = <str> mattr_accessor <str> , <str> : false self . schema_format = <str> mattr_accessor <str> , <str> : false self . timestamped_migrations = true mattr_accessor <str> , <str> : false self . dump_schema_after_migration = true mattr_accessor <str> , <str> : false self . dump_schemas = <str> mattr_accessor <str> , <str> : false self . warn_on_records_fetched_greater_than = nil mattr_accessor <str> , <str> : false mattr_accessor <str> , <str> : false class_attribute <str> , <str> : false def self . connection_handler ActiveRecord :: RuntimeRegistry . connection_handler || default_connection_handler end def self . connection_handler = ( handler ) ActiveRecord :: RuntimeRegistry . connection_handler = handler end self . default_connection_handler = ConnectionAdapters :: ConnectionHandler . new end module ClassMethods def allocate define_attribute_methods super end def initialize_find_by_cache @find_by_statement_cache = { } . extend ( Mutex_m ) end def inherited ( child_class ) child_class . initialize_find_by_cache super end def find ( * ids ) return super unless ids . length == <int> return super if block_given? || primary_key . nil? || scope_attributes? || columns_hash . include? ( inheritance_column ) || ids . first . kind_of? ( Array ) id = ids . first if ActiveRecord :: Base === id id = id . id ActiveSupport :: Deprecation . warn ( <<- <str> MSG <str> . squish ) <str> MSG end key = primary_key statement = cached_find_by_statement ( key ) { | params | where ( key = > params . bind ) . limit ( <int> ) } record = statement . execute ( [ id ] , self , connection ) . first unless record raise RecordNotFound . new ( <str> name <str> primary_key <str> id <str> , name , primary_key , id ) end record rescue RangeError raise RecordNotFound . new ( <str> name <str> primary_key <str> , name , primary_key ) end def find_by ( * args ) return super if scope_attributes? || ! ( Hash === args . first ) || reflect_on_all_aggregations . any? hash = args . first return super if hash . values . any? { | v | v . nil? || Array === v || Hash === v || Relation === v } return super unless hash . keys . all? { | k | columns_hash . has_key? ( k . to_s ) } keys = hash . keys statement = cached_find_by_statement ( keys ) { | params | wheres = keys . each_with_object ( { } ) { | param , o | o [ param ] = params . bind } where ( wheres ) . limit ( <int> ) } begin statement . execute ( hash . values , self , connection ) . first rescue TypeError raise ActiveRecord :: StatementInvalid rescue RangeError nil end end def find_by! ( * args ) find_by ( * args ) or raise RecordNotFound . new ( <str> name <str> , name ) end def initialize_generated_modules generated_association_methods end def generated_association_methods @generated_association_methods || = begin mod = const_set ( <str> , Module . new ) include mod mod end end def inspect if self == Base super elsif abstract_class? <str> super <str> elsif ! connected? <str> super <str> super <str> elsif table_exists? attr_list = attribute_types . map { | name , type | <str> name <str> type . type <str> } * <str> <str> super <str> attr_list <str> else <str> super <str> end end def === ( object ) object . is_a? ( self ) end def arel_table @arel_table || = Arel :: Table . new ( table_name , <str> : type_caster ) end def arel_engine @arel_engine || = if Base == self || connection_handler . retrieve_connection_pool ( self ) self else superclass . arel_engine end end def arel_attribute ( name , table = arel_table ) name = attribute_alias ( name ) if attribute_alias? ( name ) table [ name ] end def predicate_builder @predicate_builder || = PredicateBuilder . new ( table_metadata ) end def type_caster TypeCaster :: Map . new ( self ) end private def cached_find_by_statement ( key , & block ) @find_by_statement_cache [ key ] || @find_by_statement_cache . synchronize { @find_by_statement_cache [ key ] || = StatementCache . create ( connection , & block ) } end def relation relation = Relation . create ( self , arel_table , predicate_builder ) if finder_needs_type_condition? && ! ignore_default_scope? relation . where ( type_condition ) . create_with ( inheritance_column . to_sym = > sti_name ) else relation end end def table_metadata TableMetadata . new ( self , arel_table ) end end def initialize ( attributes = nil ) @attributes = self . class . _default_attributes . deep_dup self . class . define_attribute_methods init_internals initialize_internals_callback assign_attributes ( attributes ) if attributes yield self if block_given? _run_initialize_callbacks end def init_with ( coder ) coder = LegacyYamlAdapter . convert ( self . class , coder ) @attributes = coder [ <str> ] init_internals @new_record = coder [ <str> ] self . class . define_attribute_methods _run_find_callbacks _run_initialize_callbacks self end def initialize_dup ( other ) @attributes = @attributes . deep_dup @attributes . reset ( self . class . primary_key ) _run_initialize_callbacks @new_record = true @destroyed = false super end def encode_with ( coder ) coder [ <str> ] = attributes_before_type_cast coder [ <str> ] = @attributes coder [ <str> ] = new_record? coder [ <str> ] = <int> end def == ( comparison_object ) super || comparison_object . instance_of? ( self . class ) && ! id . nil? && comparison_object . id == id end alias <str> <str> def hash if id id . hash else super end end def freeze @attributes = @attributes . clone . freeze self end def frozen? @attributes . frozen? end def <=> ( other_object ) if other_object . is_a? ( self . class ) self . to_key < = > other_object . to_key else super end end def readonly? @readonly end def readonly! @readonly = true end def connection_handler self . class . connection_handler end def inspect inspection = if defined? ( @attributes ) && @attributes self . class . column_names . collect { | name | if has_attribute? ( name ) <str> name <str> attribute_for_inspect ( name ) <str> end } . compact . join ( <str> ) else <str> end <str> self . class <str> inspection <str> end def pretty_print ( pp ) return super if custom_inspect_method_defined? pp . object_address_group ( self ) do if defined? ( @attributes ) && @attributes column_names = self . class . column_names . select { | name | has_attribute? ( name ) || new_record? } pp . seplist ( column_names , proc { pp . text <str> } ) do | column_name | column_value = read_attribute ( column_name ) pp . breakable <str> pp . group ( <int> ) do pp . text column_name pp . text <str> pp . breakable pp . pp column_value end end else pp . breakable <str> pp . text <str> end end end def slice ( * methods ) Hash [ methods . map! { | method | [ method , public_send ( method ) ] } ] . with_indifferent_access end private def to_ary nil end def init_internals @readonly = false @destroyed = false @marked_for_destruction = false @destroyed_by_association = nil @new_record = true @txn = nil @_start_transaction_state = { } @transaction_state = nil end def initialize_internals_callback end def thaw if frozen? @attributes = @attributes . dup end end def custom_inspect_method_defined? self . class . instance_method ( <str> ) . owner != ActiveRecord :: Base . instance_method ( <str> ) . owner end end end 
