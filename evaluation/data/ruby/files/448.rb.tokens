require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: SMB :: Client include Msf :: Auxiliary :: Report SIMPLE = Rex :: Proto :: SMB :: Client XCEPT = Rex :: Proto :: SMB :: Exceptions CONST = Rex :: Proto :: SMB :: Constants def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ ] , <str> = > MSF_LICENSE ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , ] , self . class ) end def as_size ( s ) prefix = <str> s = s . to_f i = prefix . length - <int> while s > <int> && i > <int> s /= <int> i -= <int> end ( ( s > <int> || s . modulo ( <int> ) < <int> . <int> ? <str> : <str> ) % s ) + <str> + prefix [ i ] end def run print_status ( <str> ) begin connect ( ) smb_login ( ) print_status ( <str> datastore [ <str> ] <str> datastore [ <str> ] <str> ) self . simple . connect ( <str> datastore [ <str> ] <str> datastore [ <str> ] <str> ) if datastore [ <str> ] print_status ( <str> datastore [ <str> ] <str> datastore [ <str> ] <str> datastore [ <str> ] <str> ) end listing = self . simple . client . find_first ( <str> datastore [ <str> ] <str> ) directory = Rex :: Ui :: Text :: Table . new ( <str> = > <str> datastore [ <str> ] <str> datastore [ <str> ] <str> datastore [ <str> ] <str> , <str> = > <int> , <str> = > <int> , <str> = > [ <str> , <str> , <str> , <str> ] ) listing . each_pair do | key , val | file_lastmodified = :: Time . at ( Rex :: Proto :: SMB :: Utils . time_smb_to_unix ( val [ <str> ] [ <int> ] , val [ <str> ] [ <int> ] ) ) size = val [ <str> ] [ <int> ] if val [ <str> ] == <int> type = <str> size = <str> else type = <str> end directory << [ as_size ( size . to_s ) , val [ <str> ] , file_lastmodified . strftime ( <str> ) , key ] end print_status ( directory . to_s ) rescue Rex :: Proto :: SMB :: Exceptions :: Error = > e print_error ( <str> e <str> ) end end end 
