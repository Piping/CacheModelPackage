begin require <str> require <str> require <str> rescue LoadError end require <str> require <str> require <str> class TestSocketNonblock < Test :: Unit :: TestCase def test_accept_nonblock serv = Socket . new ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) serv . bind ( Socket . sockaddr_in ( <int> , <str> ) ) serv . listen ( <int> ) assert_raise ( IO :: WaitReadable ) { serv . accept_nonblock } assert_equal <str> , serv . accept_nonblock ( <str> : false ) assert_raise ( IO :: WaitReadable ) { serv . accept_nonblock ( <str> : true ) } c = Socket . new ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) c . connect ( serv . getsockname ) begin s , sockaddr = serv . accept_nonblock rescue IO :: WaitReadable IO . select [ serv ] s , sockaddr = serv . accept_nonblock end assert_equal ( Socket . unpack_sockaddr_in ( c . getsockname ) , Socket . unpack_sockaddr_in ( sockaddr ) ) if s . respond_to? ( <str> ) assert_predicate ( s , <str> , <str> ) end ensure serv . close if serv c . close if c s . close if s end def test_connect_nonblock serv = Socket . new ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) serv . bind ( Socket . sockaddr_in ( <int> , <str> ) ) serv . listen ( <int> ) c = Socket . new ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) servaddr = serv . getsockname begin c . connect_nonblock ( servaddr ) rescue IO :: WaitWritable IO . select nil , [ c ] assert_nothing_raised { begin c . connect_nonblock ( servaddr ) rescue Errno :: EISCONN end } end s , sockaddr = serv . accept assert_equal ( Socket . unpack_sockaddr_in ( c . getsockname ) , Socket . unpack_sockaddr_in ( sockaddr ) ) ensure serv . close if serv c . close if c s . close if s end def test_connect_nonblock_no_exception serv = Socket . new ( <str> , <str> ) serv . bind ( Socket . sockaddr_in ( <int> , <str> ) ) serv . listen ( <int> ) c = Socket . new ( <str> , <str> ) servaddr = serv . getsockname rv = c . connect_nonblock ( servaddr , <str> : false ) case rv when <int> else assert_equal <str> , rv end assert_equal ( [ [ ] , [ c ] , [ ] ] , IO . select ( nil , [ c ] , nil , <int> ) ) assert_equal ( <int> , c . connect_nonblock ( servaddr , <str> : false ) , <str> ) s , sockaddr = serv . accept assert_equal ( Socket . unpack_sockaddr_in ( c . getsockname ) , Socket . unpack_sockaddr_in ( sockaddr ) ) ensure serv . close if serv c . close if c s . close if s end def test_udp_recvfrom_nonblock u1 = UDPSocket . new u2 = UDPSocket . new u1 . bind ( <str> , <int> ) assert_raise ( IO :: WaitReadable ) { u1 . recvfrom_nonblock ( <int> ) } assert_raise ( IO :: WaitReadable , Errno :: EINVAL ) { u2 . recvfrom_nonblock ( <int> ) } u2 . send ( <str> , <int> , u1 . getsockname ) IO . select [ u1 ] mesg , inet_addr = u1 . recvfrom_nonblock ( <int> ) assert_equal ( <int> , inet_addr . length ) assert_equal ( <str> , mesg ) _ , port , _ , _ = inet_addr u2_port , _ = Socket . unpack_sockaddr_in ( u2 . getsockname ) assert_equal ( u2_port , port ) assert_raise ( IO :: WaitReadable ) { u1 . recvfrom_nonblock ( <int> ) } u2 . send ( <str> , <int> , u1 . getsockname ) assert_nothing_raised ( <str> ) { Timeout . timeout ( <int> ) { IO . select [ u1 ] } } mesg , inet_addr = u1 . recvfrom_nonblock ( <int> ) assert_equal ( <str> , mesg ) ensure u1 . close if u1 u2 . close if u2 end def test_udp_recv_nonblock u1 = UDPSocket . new u2 = UDPSocket . new u1 . bind ( <str> , <int> ) assert_raise ( IO :: WaitReadable ) { u1 . recv_nonblock ( <int> ) } assert_raise ( IO :: WaitReadable , Errno :: EINVAL ) { u2 . recv_nonblock ( <int> ) } u2 . send ( <str> , <int> , u1 . getsockname ) IO . select [ u1 ] mesg = u1 . recv_nonblock ( <int> ) assert_equal ( <str> , mesg ) assert_raise ( IO :: WaitReadable ) { u1 . recv_nonblock ( <int> ) } u2 . send ( <str> , <int> , u1 . getsockname ) assert_nothing_raised ( <str> ) { Timeout . timeout ( <int> ) { IO . select [ u1 ] } } mesg = u1 . recv_nonblock ( <int> ) assert_equal ( <str> , mesg ) buf = <str> . dup out = <str> * <int> out . freeze u2 . send ( out , <int> , u1 . getsockname ) IO . select [ u1 ] rv = u1 . recv_nonblock ( <int> , <int> , buf ) assert_equal rv . object_id , buf . object_id assert_equal out , rv assert_equal out , buf ensure u1 . close if u1 u2 . close if u2 end def test_socket_recvfrom_nonblock s1 = Socket . new ( Socket :: AF_INET , Socket :: SOCK_DGRAM , <int> ) s1 . bind ( Socket . sockaddr_in ( <int> , <str> ) ) s2 = Socket . new ( Socket :: AF_INET , Socket :: SOCK_DGRAM , <int> ) assert_raise ( IO :: WaitReadable ) { s1 . recvfrom_nonblock ( <int> ) } assert_raise ( IO :: WaitReadable , Errno :: EINVAL ) { s2 . recvfrom_nonblock ( <int> ) } s2 . send ( <str> , <int> , s1 . getsockname ) IO . select [ s1 ] mesg , sockaddr = s1 . recvfrom_nonblock ( <int> ) assert_equal ( <str> , mesg ) port , _ = Socket . unpack_sockaddr_in ( sockaddr ) s2_port , _ = Socket . unpack_sockaddr_in ( s2 . getsockname ) assert_equal ( s2_port , port ) ensure s1 . close if s1 s2 . close if s2 end def tcp_pair serv = TCPServer . new ( <str> , <int> ) _ , port , _ , addr = serv . addr c = TCPSocket . new ( addr , port ) s = serv . accept if block_given? begin yield c , s ensure c . close if ! c . closed? s . close if ! s . closed? end else return c , s end ensure serv . close if serv && ! serv . closed? end def udp_pair s1 = UDPSocket . new s1 . bind ( <str> , <int> ) af , port1 , host , addr1 = s1 . addr s2 = UDPSocket . new s2 . bind ( <str> , <int> ) af , port2 , host , addr2 = s2 . addr s1 . connect ( addr2 , port2 ) s2 . connect ( addr1 , port1 ) if block_given? begin yield s1 , s2 ensure s1 . close if ! s1 . closed? s2 . close if ! s2 . closed? end else return s1 , s2 end end def test_tcp_recv_nonblock c , s = tcp_pair assert_raise ( IO :: WaitReadable ) { c . recv_nonblock ( <int> ) } assert_raise ( IO :: WaitReadable ) { s . recv_nonblock ( <int> ) } c . write ( <str> ) IO . select [ s ] assert_equal ( <str> , s . recv_nonblock ( <int> ) ) assert_equal ( <str> , s . recv_nonblock ( <int> ) ) assert_raise ( IO :: WaitReadable ) { s . recv_nonblock ( <int> ) } ensure c . close if c s . close if s end def test_read_nonblock c , s = tcp_pair assert_raise ( IO :: WaitReadable ) { c . read_nonblock ( <int> ) } assert_raise ( IO :: WaitReadable ) { s . read_nonblock ( <int> ) } c . write ( <str> ) IO . select [ s ] assert_equal ( <str> , s . read_nonblock ( <int> ) ) assert_equal ( <str> , s . read_nonblock ( <int> ) ) assert_raise ( IO :: WaitReadable ) { s . read_nonblock ( <int> ) } ensure c . close if c s . close if s end def test_read_nonblock_no_exception c , s = tcp_pair assert_equal <str> , c . read_nonblock ( <int> , <str> : false ) assert_equal <str> , s . read_nonblock ( <int> , <str> : false ) c . write ( <str> ) IO . select [ s ] assert_equal ( <str> , s . read_nonblock ( <int> , <str> : false ) ) assert_equal ( <str> , s . read_nonblock ( <int> , <str> : false ) ) assert_equal <str> , s . read_nonblock ( <int> , <str> : false ) ensure c . close if c s . close if s end def test_sendmsg_nonblock_error udp_pair { | s1 , s2 | begin loop { s1 . sendmsg_nonblock ( <str> * <int> ) } rescue NotImplementedError , Errno :: ENOSYS skip <str> $! <str> rescue Errno :: EMSGSIZE rescue Errno :: EWOULDBLOCK assert_kind_of ( IO :: WaitWritable , $! ) end } end def test_recvfrom_nonblock_no_exception udp_pair do | s1 , s2 | assert_equal <str> , s1 . recvfrom_nonblock ( <int> , <str> : false ) s2 . send ( <str> , <int> ) assert_predicate s1 , <str> mesg , inet_addr = s1 . recvfrom_nonblock ( <int> , <str> : false ) assert_equal ( <int> , inet_addr . length ) assert_equal ( <str> , mesg ) end end if defined? ( UNIXSocket ) && defined? ( Socket :: SOCK_SEQPACKET ) def test_sendmsg_nonblock_seqpacket buf = <str> * <int> UNIXSocket . pair ( <str> ) do | s1 , s2 | assert_raise ( IO :: WaitWritable ) do loop { s1 . sendmsg_nonblock ( buf ) } end end rescue NotImplementedError , Errno :: ENOSYS , Errno :: EPROTONOSUPPORT skip <str> $! <str> end def test_sendmsg_nonblock_no_exception buf = <str> * <int> UNIXSocket . pair ( <str> ) do | s1 , s2 | n = <int> Timeout . timeout ( <int> ) do case rv = s1 . sendmsg_nonblock ( buf , <str> : false ) when Integer n += rv when <str> break else flunk <str> rv . inspect <str> end while true assert_equal <str> , rv assert_operator n , <str> , <int> end end rescue NotImplementedError , Errno :: ENOSYS , Errno :: EPROTONOSUPPORT skip <str> $! <str> end end def test_recvmsg_nonblock_error udp_pair { | s1 , s2 | begin s1 . recvmsg_nonblock ( <int> ) rescue NotImplementedError skip <str> rescue Errno :: EWOULDBLOCK assert_kind_of ( IO :: WaitReadable , $! ) end assert_equal <str> , s1 . recvmsg_nonblock ( <int> , <str> : false ) } end def test_recv_nonblock_error tcp_pair { | c , s | begin c . recv_nonblock ( <int> ) rescue Errno :: EWOULDBLOCK assert_kind_of ( IO :: WaitReadable , $! ) end } end def test_recv_nonblock_no_exception tcp_pair { | c , s | assert_equal <str> , c . recv_nonblock ( <int> , <str> : false ) s . write ( <str> ) assert_predicate c , <str> assert_equal <str> , c . recv_nonblock ( <int> , <str> : false ) assert_equal <str> , c . recv_nonblock ( <int> , <str> : false ) } end def test_connect_nonblock_error serv = TCPServer . new ( <str> , <int> ) _ , port , _ , _ = serv . addr c = Socket . new ( <str> , <str> ) begin c . connect_nonblock ( Socket . sockaddr_in ( port , <str> ) ) rescue Errno :: EINPROGRESS assert_kind_of ( IO :: WaitWritable , $! ) end ensure serv . close if serv && ! serv . closed? c . close if c && ! c . closed? end def test_accept_nonblock_error serv = Socket . new ( <str> , <str> ) serv . bind ( Socket . sockaddr_in ( <int> , <str> ) ) serv . listen ( <int> ) begin s , _ = serv . accept_nonblock rescue Errno :: EWOULDBLOCK assert_kind_of ( IO :: WaitReadable , $! ) end ensure serv . close if serv && ! serv . closed? s . close if s && ! s . closed? end end if defined? ( Socket ) 
