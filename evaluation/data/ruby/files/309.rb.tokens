require <str> require_relative <str> class TestSprintfComb < Test :: Unit :: TestCase VS = [ - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <hex> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ] VS . reverse! FLAGS = [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] def self . combination ( * args , & b ) AllPairs . each ( * args , & b ) end def emu_int ( format , v ) <str> =~ format sp = $1 hs = $2 pl = $3 mi = $4 zr = $5 width = $6 precision = $7 type = $8 width = width . to_i if width precision = precision . to_i if precision prefix = <str> zr = nil if precision zr = nil if mi && zr case type when <str> radix = <int> digitmap = { <int> = > <str> , <int> = > <str> } complement = ! pl && ! sp prefix = <str> if hs && v != <int> when <str> radix = <int> digitmap = { <int> = > <str> , <int> = > <str> } complement = ! pl && ! sp prefix = <str> if hs && v != <int> when <str> radix = <int> digitmap = { } <int> . times { | i | digitmap [ i ] = i . to_s } complement = false when <str> radix = <int> digitmap = { } <int> . times { | i | digitmap [ i ] = i . to_s } complement = ! pl && ! sp when <str> radix = <int> digitmap = { } <int> . times { | i | digitmap [ i ] = i . to_s ( <int> ) . upcase } complement = ! pl && ! sp prefix = <str> if hs && v != <int> when <str> radix = <int> digitmap = { } <int> . times { | i | digitmap [ i ] = i . to_s ( <int> ) } complement = ! pl && ! sp prefix = <str> if hs && v != <int> else raise <str> type . inspect <str> end digits = [ ] abs = v . abs sign = <str> while <int> < abs digits << ( abs % radix ) abs /= radix end if v < <int> if complement digits . map! { | d | radix - <int> - d } carry = <int> digits . each_index { | i | digits [ i ] += carry carry = <int> if radix < = digits [ i ] digits [ i ] -= radix carry = <int> end } if digits . last != radix - <int> digits << ( radix - <int> ) end sign = <str> else sign = <str> end else if pl sign = <str> elsif sp sign = <str> end end dlen = digits . length dlen += <int> if sign == <str> if v < <int> && complement d = radix - <int> else d = <int> end if precision if dlen < precision ( precision - dlen ) . times { digits << d } end else if dlen == <int> digits << d end end if type == <str> && hs if digits . empty? || digits . last != d digits << d end end digits . reverse! str = digits . map { | digit | digitmap [ digit ] } . join pad = <str> nlen = prefix . length + sign . length + str . length if width && nlen < width len = width - nlen if zr if complement && v < <int> pad = digitmap [ radix - <int> ] * len else pad = <str> * len end else pad = <str> * len end end if <str> =~ pad if sign == <str> str = prefix + sign + str else str = sign + prefix + str end if mi str = str + pad else str = pad + str end else if sign == <str> str = prefix + sign + pad + str else str = sign + prefix + pad + str end end str end def self . assertions_format_integer ( format ) proc { VS . each { | v | r = sprintf format , v e = emu_int format , v if true assert_equal ( e , r , <str> format . dump <str> v <str> ) else if e != r puts <str> e . dump <str> r . dump <str> format . dump <str> v <str> end end } } end combination ( <str> , [ nil , <int> , <int> , <int> ] , [ <str> , <str> , <str> , <str> , <str> ] , * FLAGS ) { | type , width , precision , sp , hs , pl , mi , zr | format = <str> sp <str> hs <str> pl <str> mi <str> zr <str> width <str> precision <str> type <str> define_method ( <str> format <str> , assertions_format_integer ( format ) ) } FLOAT_VALUES = [ - <int> e100 , - <int> . <int> , - <int> . <int> , - <int> . <int> , <int> . <int> , <int> . <oct> , <int> / <int> . <int> , <int> / <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> e100 , Float :: MAX , Float :: MIN , Float :: EPSILON , <int> + Float :: EPSILON , <int> + Float :: EPSILON * <int> , <int> - Float :: EPSILON * <int> , <int> . <int> / <int> . <int> , - <int> . <int> / <int> . <int> , <int> . <int> / <int> . <int> , ] def split_float10 ( v ) if v == <int> if <int> / v < <int> sign = - <int> v = - v else sign = <int> end else if v < <int> sign = - <int> v = - v else sign = <int> end end exp = <int> int = v . floor v -= int while v != <int> v *= <int> int *= <int> i = v . floor v -= i int += i exp -= <int> end int *= <int> ** ( - exp ) [ sign , int , exp ] end def emu_e ( sp , hs , pl , mi , zr , width , precision , type , v , sign , int , exp ) precision = <int> unless precision if int == <int> if precision == <int> && ! hs result = <str> type <str> else result = <str> + <str> * precision + <str> type <str> end else if int < <int> ** precision int *= <int> ** precision exp -= precision end digits = int . to_s . length discard = digits - ( precision + <int> ) if discard != <int> q , r = int . divmod ( <int> ** discard ) if r < <int> ** discard / <int> int = q exp += discard elsif ( q + <int> ) . to_s . length == q . to_s . length int = q + <int> exp += discard else discard += <int> q , r = int . divmod ( <int> ** discard ) int = q + <int> exp += discard end end ints = int . to_s frac = ints [ <int> .. - <int> ] result = ints [ <int> , <int> ] e = exp + frac . length if precision != <int> || hs result << <str> if precision != <int> result << frac end end result << type if e == <int> if v . abs < <int> result << <str> else result << <str> end else result << sprintf ( <str> , e ) end result end result end def emu_f ( sp , hs , pl , mi , zr , width , precision , type , sign , int , exp ) precision = <int> unless precision if int == <int> if precision == <int> && ! hs result = <str> else result = <str> + <str> * precision end else if - precision < exp int *= <int> ** ( precision + exp ) exp = - precision end if exp < - precision discard = - exp - precision q , r = int . divmod ( <int> ** discard ) if <int> ** discard / <int> < = r q += <int> end int = q exp += discard end result = int . to_s if result . length < = precision result = <str> * ( precision + <int> - result . length ) + result end if precision != <int> || hs if precision == <int> result << <str> else result [ - precision , <int> ] = <str> end end end result end def emu_float ( format , v ) <str> =~ format sp = $1 hs = $2 pl = $3 mi = $4 zr = $5 width = $6 precision = $7 type = $8 width = width . to_i if width precision = precision . to_i if precision zr = nil if mi && zr if v . infinite? sign = v < <int> ? - <int> : <int> int = <str> hs = zr = nil elsif v . nan? sign = <int> int = <str> hs = zr = nil else sign , int , exp = split_float10 ( v ) end if sign < <int> sign = <str> elsif sign == <int> sign = <str> elsif pl sign = <str> elsif sp sign = <str> else sign = <str> end if v . nan? result = <str> elsif v . infinite? result = <str> else case type when <str> result = emu_e ( sp , hs , pl , mi , zr , width , precision , type , v , sign , int , exp ) when <str> result = emu_f ( sp , hs , pl , mi , zr , width , precision , type , sign , int , exp ) when <str> precision = <int> unless precision precision = <int> if precision == <int> r = emu_e ( sp , hs , pl , mi , zr , width , precision - <int> , type . tr ( <str> , <str> ) , v , sign , int , exp ) <str> =~ r e = $1 . to_i if e < - <int> || precision < = e result = r else result = emu_f ( sp , hs , pl , mi , zr , width , precision - <int> - e , type , sign , int , exp ) end result . sub! ( <str> ) { $& . sub ( <str> , <str> ) } if ! hs else raise <str> type <str> end end pad = <str> if width && sign . length + result . length < width if zr pad = <str> * ( width - sign . length - result . length ) else pad = <str> * ( width - sign . length - result . length ) end end if mi sign + result + pad elsif zr sign + pad + result else pad + sign + result end end def self . assertions_format_float ( format ) proc { FLOAT_VALUES . each { | v | r = sprintf format , v e = emu_float format , v if true assert_equal ( e , r , <str> format . dump <str> % v <str> ) else if e != r puts <str> e . dump <str> r . dump <str> format . dump <str> % v <str> end end } } end combination ( <str> , [ nil , <int> , <int> , <int> ] , [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , * FLAGS ) { | type , width , precision , sp , hs , pl , mi , zr | format = <str> sp <str> hs <str> pl <str> mi <str> zr <str> width <str> precision <str> type <str> define_method ( <str> format <str> , assertions_format_float ( format ) ) } end 
