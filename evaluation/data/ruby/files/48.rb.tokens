require <str> module ActionView class StreamingTemplateRenderer < TemplateRenderer class Body def initialize ( & start ) @start = start end def each ( & block ) begin @start . call ( block ) rescue Exception = > exception log_error ( exception ) block . call ActionView :: Base . streaming_completion_on_exception end self end private def log_error ( exception ) logger = ActionView :: Base . logger return unless logger message = <str> exception . class <str> exception . message <str> message << exception . annoted_source_code . to_s if exception . respond_to? ( <str> ) message << <str> << exception . backtrace . join ( <str> ) logger . fatal ( <str> message <str> ) end end def render_template ( template , layout_name = nil , locals = { } ) return [ super ] unless layout_name && template . supports_streaming? locals || = { } layout = layout_name && find_layout ( layout_name , locals . keys , [ formats . first ] ) Body . new do | buffer | delayed_render ( buffer , template , layout , @view , locals ) end end private def delayed_render ( buffer , template , layout , view , locals ) output = ActionView :: StreamingBuffer . new ( buffer ) yielder = lambda { | * name | view . _layout_for ( * name ) } instrument ( <str> , <str> = > template . identifier , <str> = > layout . try ( <str> ) ) do fiber = Fiber . new do if layout layout . render ( view , locals , output , & yielder ) else output . safe_concat view . _layout_for end end view . view_flow = StreamingFlow . new ( view , fiber ) fiber . resume if fiber . alive? content = template . render ( view , locals , & yielder ) view . view_flow . set ( <str> , content ) fiber . resume while fiber . alive? end end end end end 
