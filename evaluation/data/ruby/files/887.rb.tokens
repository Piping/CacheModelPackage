require <str> require <str> require <str> module PPTestModule class PPTest < Test :: Unit :: TestCase def test_list0123_12 assert_equal ( <str> , PP . pp ( [ <int> , <int> , <int> , <int> ] , <str> . dup , <int> ) ) end def test_list0123_11 assert_equal ( <str> , PP . pp ( [ <int> , <int> , <int> , <int> ] , <str> . dup , <int> ) ) end OverriddenStruct = Struct . new ( <str> , <str> , <str> ) def test_struct_override_members a = OverriddenStruct . new ( <int> , <int> ) assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) end def test_redefined_method o = <str> . dup def o . method end assert_equal ( <str> , PP . pp ( o , <str> . dup ) ) end end class HasInspect def initialize ( a ) @a = a end def inspect return <str> @a . inspect <str> end end class HasPrettyPrint def initialize ( a ) @a = a end def pretty_print ( q ) q . text <str> q . pp @a q . text <str> end end class HasBoth def initialize ( a ) @a = a end def inspect return <str> @a . inspect <str> end def pretty_print ( q ) q . text <str> q . pp @a q . text <str> end end class PrettyPrintInspect < HasPrettyPrint alias inspect pretty_print_inspect end class PrettyPrintInspectWithoutPrettyPrint alias inspect pretty_print_inspect end class PPInspectTest < Test :: Unit :: TestCase def test_hasinspect a = HasInspect . new ( <int> ) assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) end def test_hasprettyprint a = HasPrettyPrint . new ( <int> ) assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) end def test_hasboth a = HasBoth . new ( <int> ) assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) end def test_pretty_print_inspect a = PrettyPrintInspect . new ( <int> ) assert_equal ( <str> , a . inspect ) a = PrettyPrintInspectWithoutPrettyPrint . new assert_raise ( RuntimeError ) { a . inspect } end def test_proc a = proc { <int> } assert_equal ( <str> a . inspect <str> , PP . pp ( a , <str> . dup ) ) end def test_to_s_with_iv a = Object . new def a . to_s ( ) <str> end a . instance_eval { @a = nil } result = PP . pp ( a , <str> . dup ) assert_equal ( <str> a . inspect <str> , result ) end def test_to_s_without_iv a = Object . new def a . to_s ( ) <str> end result = PP . pp ( a , <str> . dup ) assert_equal ( <str> a . inspect <str> , result ) end end class PPCycleTest < Test :: Unit :: TestCase def test_array a = [ ] a << a assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) assert_equal ( <str> a . inspect <str> , PP . pp ( a , <str> . dup ) ) end def test_hash a = { } a [ <int> ] = a assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) assert_equal ( <str> a . inspect <str> , PP . pp ( a , <str> . dup ) ) end S = Struct . new ( <str> , <str> , <str> ) def test_struct a = S . new ( <int> , <int> ) a . b = a assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) assert_equal ( <str> a . inspect <str> , PP . pp ( a , <str> . dup ) ) end def test_object a = Object . new a . instance_eval { @a = a } assert_equal ( a . inspect + <str> , PP . pp ( a , <str> . dup ) ) end def test_anonymous a = Class . new . new assert_equal ( a . inspect + <str> , PP . pp ( a , <str> . dup ) ) end def test_withinspect a = [ ] a << HasInspect . new ( a ) assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) assert_equal ( <str> a . inspect <str> , PP . pp ( a , <str> . dup ) ) end def test_share_nil begin PP . sharing_detection = true a = [ nil , nil ] assert_equal ( <str> , PP . pp ( a , <str> . dup ) ) ensure PP . sharing_detection = false end end end class PPSingleLineTest < Test :: Unit :: TestCase def test_hash assert_equal ( <str> , PP . singleline_pp ( { <int> = > <int> } , <str> . dup ) ) assert_equal ( <str> * <int> <str> , PP . singleline_pp ( [ <int> ] * <int> , <str> . dup ) ) end end class PPDelegateTest < Test :: Unit :: TestCase class A < DelegateClass ( Array ) ; end def test_delegate assert_equal ( <str> , A . new ( [ ] ) . pretty_inspect , <str> ) end end class PPFileStatTest < Test :: Unit :: TestCase def test_nothing_raised assert_nothing_raised do File . stat ( __FILE__ ) . pretty_inspect end end end end 
