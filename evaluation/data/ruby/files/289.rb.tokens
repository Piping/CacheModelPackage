class Matrix class LUPDecomposition include Matrix :: ConversionHelper def l Matrix . build ( @row_count , [ @column_count , @row_count ] . min ) do | i , j | if ( i > j ) @lu [ i ] [ j ] elsif ( i == j ) <int> else <int> end end end def u Matrix . build ( [ @column_count , @row_count ] . min , @column_count ) do | i , j | if ( i < = j ) @lu [ i ] [ j ] else <int> end end end def p rows = Array . new ( @row_count ) { Array . new ( @row_count , <int> ) } @pivots . each_with_index { | p , i | rows [ i ] [ p ] = <int> } Matrix . send <str> , rows , @row_count end def to_ary [ l , u , p ] end alias_method <str> , <str> attr_reader <str> def singular? ( ) @column_count . times do | j | if ( @lu [ j ] [ j ] == <int> ) return true end end false end def det if ( @row_count != @column_count ) Matrix . Raise Matrix :: ErrDimensionMismatch end d = @pivot_sign @column_count . times do | j | d *= @lu [ j ] [ j ] end d end alias_method <str> , <str> def solve b if ( singular? ) Matrix . Raise Matrix :: ErrNotRegular , <str> end if b . is_a? Matrix if ( b . row_count != @row_count ) Matrix . Raise Matrix :: ErrDimensionMismatch end nx = b . column_count m = @pivots . map { | row | b . row ( row ) . to_a } @column_count . times do | k | ( k + <int> ) . upto ( @column_count - <int> ) do | i | nx . times do | j | m [ i ] [ j ] -= m [ k ] [ j ] * @lu [ i ] [ k ] end end end ( @column_count - <int> ) . downto ( <int> ) do | k | nx . times do | j | m [ k ] [ j ] = m [ k ] [ j ] . quo ( @lu [ k ] [ k ] ) end k . times do | i | nx . times do | j | m [ i ] [ j ] -= m [ k ] [ j ] * @lu [ i ] [ k ] end end end Matrix . send <str> , m , nx else b = convert_to_array ( b ) if ( b . size != @row_count ) Matrix . Raise Matrix :: ErrDimensionMismatch end m = b . values_at ( * @pivots ) @column_count . times do | k | ( k + <int> ) . upto ( @column_count - <int> ) do | i | m [ i ] -= m [ k ] * @lu [ i ] [ k ] end end ( @column_count - <int> ) . downto ( <int> ) do | k | m [ k ] = m [ k ] . quo ( @lu [ k ] [ k ] ) k . times do | i | m [ i ] -= m [ k ] * @lu [ i ] [ k ] end end Vector . elements ( m , false ) end end def initialize a raise TypeError , <str> a . class <str> unless a . is_a? ( Matrix ) @lu = a . to_a @row_count = a . row_count @column_count = a . column_count @pivots = Array . new ( @row_count ) @row_count . times do | i | @pivots [ i ] = i end @pivot_sign = <int> lu_col_j = Array . new ( @row_count ) @column_count . times do | j | @row_count . times do | i | lu_col_j [ i ] = @lu [ i ] [ j ] end @row_count . times do | i | lu_row_i = @lu [ i ] kmax = [ i , j ] . min s = <int> kmax . times do | k | s += lu_row_i [ k ] * lu_col_j [ k ] end lu_row_i [ j ] = lu_col_j [ i ] -= s end p = j ( j + <int> ) . upto ( @row_count - <int> ) do | i | if ( lu_col_j [ i ] . abs > lu_col_j [ p ] . abs ) p = i end end if ( p != j ) @column_count . times do | k | t = @lu [ p ] [ k ] ; @lu [ p ] [ k ] = @lu [ j ] [ k ] ; @lu [ j ] [ k ] = t end k = @pivots [ p ] ; @pivots [ p ] = @pivots [ j ] ; @pivots [ j ] = k @pivot_sign = - @pivot_sign end if ( j < @row_count && @lu [ j ] [ j ] != <int> ) ( j + <int> ) . upto ( @row_count - <int> ) do | i | @lu [ i ] [ j ] = @lu [ i ] [ j ] . quo ( @lu [ j ] [ j ] ) end end end end end end 
