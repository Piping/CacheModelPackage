require <str> require <str> require <str> require <str> TkPackage . require ( <str> ) module Tk class TkTable < TkWindow PACKAGE_NAME = <str> . freeze def self . package_name PACKAGE_NAME end def self . package_version begin TkPackage . require ( <str> ) rescue <str> end end class CellTag < TkObject end module ConfigMethod end end end module Tk::TkTable::ConfigMethod include TkItemConfigMethod def __item_cget_cmd ( id ) [ self . path , id [ <int> ] , <str> , id [ <int> ] ] end private <str> def __item_config_cmd ( id ) [ self . path , id [ <int> ] , <str> , id [ <int> ] ] end private <str> def __item_pathname ( id ) if id . kind_of? ( Array ) id = tagid ( id [ <int> ] ) end [ self . path , id ] . join ( <str> ) end private <str> def __item_boolval_optkeys ( id ) super ( id ) << <str> << <str> << <str> end private <str> def __item_strval_optkeys ( id ) super ( id ) << <str> end private <str> def __item_val2ruby_optkeys ( id ) super ( id ) . update ( <str> = > proc { | k , v | window ( v ) } ) end private <str> def tag_cget_tkstring ( tagOrId , option ) itemcget_tkstring ( [ <str> , tagid ( tagOrId ) ] , option ) end def tag_cget ( tagOrId , option ) itemcget ( [ <str> , tagid ( tagOrId ) ] , option ) end def tag_cget_strict ( tagOrId , option ) itemcget_strict ( [ <str> , tagid ( tagOrId ) ] , option ) end def tag_configure ( tagOrId , slot , value = None ) itemconfigure ( [ <str> , tagid ( tagOrId ) ] , slot , value ) end def tag_configinfo ( tagOrId , slot = nil ) itemconfiginfo ( [ <str> , tagid ( tagOrId ) ] , slot ) end def current_tag_configinfo ( tagOrId , slot = nil ) current_itemconfiginfo ( [ <str> , tagid ( tagOrId ) ] , slot ) end def window_cget_tkstring ( tagOrId , option ) itemcget_tkstring ( [ <str> , tagid ( tagOrId ) ] , option ) end def window_cget ( tagOrId , option ) itemcget ( [ <str> , tagid ( tagOrId ) ] , option ) end def window_cget_strict ( tagOrId , option ) itemcget_strict ( [ <str> , tagid ( tagOrId ) ] , option ) end def window_configure ( tagOrId , slot , value = None ) if slot == <str> || slot == <str> value = _epath ( value ) elsif slot . kind_of? ( Hash ) if slot . key? ( <str> ) || slot . key? ( <str> ) slot = _symbolkey2str ( slot ) slot [ <str> ] = _epath ( slot [ <str> ] ) end end itemconfigure ( [ <str> , tagid ( tagOrId ) ] , slot , value ) end def window_configinfo ( tagOrId , slot = nil ) itemconfiginfo ( [ <str> , tagid ( tagOrId ) ] , slot ) end def current_window_configinfo ( tagOrId , slot = nil ) current_itemconfiginfo ( [ <str> , tagid ( tagOrId ) ] , slot ) end private <str> , <str> , <str> private <str> , <str> , <str> end class Tk :: TkTable :: CellTag include TkTreatTagFont CellTagID_TBL = TkCore :: INTERP . create_table ( CellTag_ID = [ <str> . freeze , TkUtil . untrust ( <str> ) ] ) . instance_eval { @mutex = Mutex . new def mutex ; @mutex ; end freeze } TkCore :: INTERP . init_ip_env { CellTagID_TBL . mutex . synchronize { CellTagID_TBL . clear } } def self . id2obj ( table , id ) tpath = table . path CellTagID_TBL . mutex . synchronize { if CellTagID_TBL [ tpath ] CellTagID_TBL [ tpath ] [ id ] ? CellTagID_TBL [ tpath ] [ id ] : id else id end } end def initialize ( parent , keys = nil ) @parent = @t = parent @tpath - parent . path CellTag_ID . mutex . synchronize { @path = @id = CellTag_ID . join ( TkCore :: INTERP . _ip_id_ ) CellTag_ID [ <int> ] . succ! } CellTagID_TBL . mutex . synchronize { CellTagID_TBL [ @tpath ] = { } unless CellTagID_TBL [ @tpath ] CellTagID_TBL [ @tpath ] [ @id ] = self } configure ( keys ) if keys end def id @id end def destroy tk_call ( @tpath , <str> , <str> , @id ) CellTagID_TBL . mutex . synchronize { CellTagID_TBL [ @tpath ] . delete ( @id ) if CellTagID_TBL [ @tpath ] } self end alias delete destroy def exist? @t . tag_exist? ( @id ) end def include? ( idx ) @t . tag_include? ( @id , idx ) end def add_cell ( * args ) @t . tag_cell ( @id , * args ) end def add_col ( * args ) @t . tag_col ( @id , * args ) end def add_row ( * args ) @t . tag_row ( @id , * args ) end def raise ( target = None ) @t . tag_raise ( @id , target ) end def lower ( target = None ) @t . tag_lower ( @id , target ) end def cget_tkstring ( key ) @t . tag_cget_tkstring ( @id , key ) end def cget ( key ) @t . tag_cget ( @id , key ) end def cget_strict ( key ) @t . tag_cget_strict ( @id , key ) end def configure ( key , val = None ) @t . tag_configure ( @id , key , val ) end def configinfo ( key = nil ) @t . tag_configinfo ( @id , key ) end def current_configinfo ( key = nil ) @t . current_tag_configinfo ( @id , key ) end end class Tk :: TkTable :: NamedCellTag < Tk :: TkTable :: CellTag def self . new ( parent , name , keys = nil ) obj = nil CellTagID_TBL . mutex . synchronize { if CellTagID_TBL [ parent . path ] && CellTagID_TBL [ parent . path ] [ name ] obj = CellTagID_TBL [ parent . path ] [ name ] else ( obj = self . allocate ) . instance_eval { @parent = @t = parent @tpath = parent . path @path = @id = name CellTagID_TBL [ @tpath ] = { } unless CellTagID_TBL [ @tpath ] CellTagID_TBL [ @tpath ] [ @id ] = self } end } obj . configure ( keys ) if keys && ! keys . empty? obj end def initialize ( parent , name , keys = nil ) @parent = @t = parent @tpath = parent . path @path = @id = name CellTagID_TBL . mutex . synchronize { CellTagID_TBL [ @tpath ] = { } unless CellTagID_TBL [ @tpath ] CellTagID_TBL [ @tpath ] [ @id ] = self } configure ( keys ) if keys && ! keys . empty? end end class Tk :: TkTable TkCommandNames = [ <str> . freeze ] . freeze WidgetClassName = <str> . freeze WidgetClassNames [ WidgetClassName ] || = self include Scrollable include Tk :: TkTable :: ConfigMethod include Tk :: ValidateConfigure def __destroy_hook__ Tk :: TkTable :: CelTag :: CellTagID_TBL . mutex . synchronize { Tk :: TkTable :: CelTag :: CellTagID_TBL . delete ( @path ) } end def __boolval_optkeys super ( ) << <str> << <str> << <str> << <str> << <str> << <str> end private <str> def __strval_optkeys super ( ) << <str> << <str> << <str> << <str> end private <str> class BrowseCommand < TkValidateCommand class ValidateArgs < TkUtil :: CallbackSubst KEY_TBL = [ [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , nil ] PROC_TBL = [ [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , nil ] _setup_subst_table ( KEY_TBL , PROC_TBL ) ; def self . ret_val ( val ) val end end def self . _config_keys [ <str> , <str> ] end end class CellCommand < TkValidateCommand class ValidateArgs < TkUtil :: CallbackSubst KEY_TBL = [ [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , nil ] PROC_TBL = [ [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , proc { | val | ( val == <str> ) ? ( <str> ) : ( <str> ) } ] , [ <str> , proc { | val | TkComm . tk_tcl2ruby ( val , true , false ) } ] , nil ] _setup_subst_table ( KEY_TBL , PROC_TBL ) ; def self . ret_val ( val ) TkComm . _get_eval_string ( val ) end end def self . _config_keys [ <str> ] end end class SelectionCommand < TkValidateCommand class ValidateArgs < TkUtil :: CallbackSubst KEY_TBL = [ [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , nil ] PROC_TBL = [ [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , nil ] _setup_subst_table ( KEY_TBL , PROC_TBL ) ; def self . ret_val ( val ) val . to_s end end def self . _config_keys [ <str> , <str> ] end end class ValidateCommand < TkValidateCommand class ValidateArgs < TkUtil :: CallbackSubst KEY_TBL = [ [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> , <str> ] , nil ] PROC_TBL = [ [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , TkComm . method ( <str> ) ] , [ <str> , proc { | val | TkComm . tk_tcl2ruby ( val , true , false ) } ] , nil ] _setup_subst_table ( KEY_TBL , PROC_TBL ) ; end def self . _config_keys [ <str> , <str> ] end end def __validation_class_list super ( ) << BrowseCommand << CellCommand << SelectionCommand << ValidateCommand end Tk :: ValidateConfigure . __def_validcmd ( binding , BrowseCommand ) Tk :: ValidateConfigure . __def_validcmd ( binding , CellCommand ) Tk :: ValidateConfigure . __def_validcmd ( binding , SelectionCommand ) Tk :: ValidateConfigure . __def_validcmd ( binding , ValidateCommand ) def activate ( idx ) tk_send ( <str> , tagid ( idx ) ) end def bbox ( idx ) list ( tk_send ( <str> , tagid ( idx ) ) ) end def border_mark ( x , y ) simplelist ( tk_send ( <str> , <str> , x , y ) ) end def border_mark_row ( x , y ) tk_send ( <str> , <str> , x , y , <str> ) end def border_mark_col ( x , y ) tk_send ( <str> , <str> , x , y , <str> ) end def border_dragto ( x , y ) tk_send ( <str> , <str> , x , y ) end def clear_cache ( first = None , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def clear_sizes ( first = None , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def clear_tags ( first = None , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def clear_all ( first = None , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def curselection simplelist ( tk_send ( <str> ) ) end def curselection = ( val ) tk_send ( <str> , val ) val end def curvalue tk_tcl2ruby ( tk_send ( <str> ) , true , false ) end def curvalue = ( val ) tk_send ( <str> , val ) val end def delete_active ( idx1 , idx2 = None ) tk_send ( <str> , <str> , tagid ( idx1 ) , tagid ( idx2 ) ) self end def delete_cols ( * args ) params = [ ] if args [ <int> ] . kind_of? ( Array ) switches = args . shift switches . each { | k | params << <str> k <str> } end params << <str> params << tagid ( args . shift ) params . concat ( args ) tk_send ( <str> , <str> , * params ) self end def delete_rows ( * args ) params = [ ] if args [ <int> ] . kind_of? ( Array ) switches = args . shift switches . each { | k | params << <str> k <str> } end params << <str> params << tagid ( args . shift ) params . concat ( args ) tk_send ( <str> , <str> , * params ) self end def get ( idx ) tk_tcl2ruby ( tk_send ( <str> , tagid ( idx ) ) , true , false ) end def get_area ( idx1 , idx2 ) simplelist ( tk_send ( <str> , tagid ( idx1 ) , tagid ( idx2 ) ) ) . collect { | v | tk_tcl2ruby ( v , true , false ) } end def height_list list ( tk_send ( <str> ) ) end def height ( row ) number ( tk_send ( <str> , row ) ) end def set_height ( * pairs ) tk_send ( <str> , * ( pairs . flatten ) ) self end def hidden_list simplelist ( tk_send ( <str> ) ) end def hidden? ( idx , * args ) if args . empty? if ( ret = tk_send ( <str> , tagid ( idx ) ) ) == <str> false else ret end else bool ( tk_send ( <str> , tagid ( idx ) , * ( args . collect { | i | tagid ( i ) } ) ) ) end end def icursor number ( tk_send ( <str> ) ) end def icursor_set ( idx ) number ( tk_send ( <str> , tagid ( idx ) ) ) end def index ( idx ) tk_send ( <str> , tagid ( idx ) ) end def row_index ( idx ) number ( tk_send ( <str> , tagid ( idx ) , <str> ) ) end def col_index ( idx ) number ( tk_send ( <str> , tagid ( idx ) , <str> ) ) end def insert_active ( idx , val ) tk_send ( <str> , <str> , tagid ( idx ) , val ) self end def insert_cols ( * args ) params = [ ] if args [ <int> ] . kind_of? ( Array ) switches = args . shift switches . each { | k | params << <str> k <str> } end params << <str> params . concat ( args ) params << tagid ( args . shift ) tk_send ( <str> , <str> , * params ) self end def insert_rows ( * args ) params = [ ] if args [ <int> ] . kind_of? ( Array ) switches = args . shift switches . each { | k | params << <str> k <str> } end params << <str> params << tagid ( args . shift ) params . concat ( args ) tk_send ( <str> , <str> , * params ) self end def reread tk_send ( <str> ) self end def scan_mark ( x , y ) tk_send ( <str> , <str> , x , y ) self end def scan_dragto ( x , y ) tk_send ( <str> , <str> , x , y ) self end def see ( idx ) tk_send ( <str> , tagid ( idx ) ) self end def selection_anchor ( idx ) tk_send ( <str> , <str> , tagid ( idx ) ) self end def selection_clear ( first , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def selection_clear_all selection_clear ( <str> ) end def selection_include? ( idx ) bool ( tk_send ( <str> , <str> , tagid ( idx ) ) ) end def selection_present bool ( tk_send ( <str> , <str> ) ) end def selection_set ( first , last = None ) tk_send ( <str> , <str> , tagid ( first ) , tagid ( last ) ) self end def set ( * pairs ) args = [ ] <int> . step ( pairs . size - <int> , <int> ) { | i | args << tagid ( pairs [ i ] ) args << pairs [ i + <int> ] } tk_send ( <str> , * args ) self end def set_row ( * pairs ) args = [ ] <int> . step ( pairs . size - <int> , <int> ) { | i | args << tagid ( pairs [ i ] ) args << pairs [ i + <int> ] } tk_send ( <str> , <str> , * args ) self end def set_col ( * pairs ) args = [ ] <int> . step ( pairs . size - <int> , <int> ) { | i | args << tagid ( pairs [ i ] ) args << pairs [ i + <int> ] } tk_send ( <str> , <str> , * args ) self end def spans simplelist ( tk_send ( <str> ) ) . collect { | inf | lst = simplelist ( inf ) idx = lst [ <int> ] rows , cols = lst [ <int> ] . split ( <str> ) . map! { | n | Integer ( n ) } [ idx [ rows , cols ] ] } end alias span_list spans def span ( idx ) lst = simplelist ( tk_send ( <str> , tagid ( idx ) ) ) idx = lst [ <int> ] rows , cols = lst [ <int> ] . split ( <str> ) . map! { | n | Integer ( n ) } [ idx [ rows , cols ] ] end def set_spans ( * pairs ) args = [ ] <int> . step ( pairs . size - <int> , <int> ) { | i | args << tagid ( pairs [ i ] ) val = pairs [ i + <int> ] if val . kind_of? ( Array ) args << val . join ( <str> ) else args << val end } tk_send ( <str> , * args ) self end def tagid ( tag ) if tag . kind_of? ( Tk :: TkTable :: CellTag ) tag . id elsif tag . kind_of? ( Array ) if tag [ <int> ] . kind_of? ( Integer ) && tag [ <int> ] . kind_of? ( Integer ) tag . join ( <str> ) else tag end else tag end end def tagid2obj ( tagid ) Tk :: TkTable :: CellTag :: CellTagID_TBL . mutex . synchronize { if Tk :: TkTable :: CellTag :: CellTagID_TBL . key? ( @path ) if Tk :: TkTable :: CellTag :: CellTagID_TBL [ @path ] . key? ( tagid ) Tk :: TkTable :: CellTag :: CellTagID_TBL [ @path ] [ tagid ] else tagid end else tagid end } end def tag_cell ( tag , * cells ) tk_send ( <str> , <str> , tagid ( tag ) , * ( cells . collect { | idx | tagid ( idx ) } ) ) self end def tag_reset ( * cells ) tk_send ( <str> , <str> , <str> , * ( cells . collect { | idx | tagid ( idx ) } ) ) self end def tag_col ( tag , * cols ) tk_send ( <str> , <str> , tagid ( tag ) , * cols ) self end def tag_col_reset ( * cols ) tk_send ( <str> , <str> , <str> , * cols ) self end def tag_delete ( tag ) tk_send ( <str> , <str> , tagid ( tag ) ) Tk :: TkTable :: CellTag :: CellTagID_TBL . mutex . synchronize { if Tk :: TkTable :: CellTag :: CellTagID_TBL [ @path ] if tag . kind_of? Tk :: TkTable :: CellTag Tk :: TkTable :: CellTag :: CellTagID_TBL [ @path ] . delete ( tag . id ) else Tk :: TkTable :: CellTag :: CellTagID_TBL [ @path ] . delete ( tag ) end end } self end def tag_exist? ( tag ) bool ( tk_send ( <str> , <str> , tagid ( tag ) ) ) end def tag_include? ( tag , idx ) bool ( tk_send ( <str> , <str> , tagid ( tag ) , tagid ( idx ) ) ) end def tag_lower ( tag , target = None ) tk_send ( <str> , <str> , tagid ( tag ) , tagid ( target ) ) self end def tag_names ( pat = None ) simplelist ( tk_send ( <str> , <str> , pat ) ) . collect { | tag | tagid2obj ( tag ) } end def tag_raise ( tag , target = None ) tk_send ( <str> , <str> , tagid ( tag ) , tagid ( target ) ) self end def tag_row ( tag , * rows ) tk_send ( <str> , <str> , tagid ( tag ) , * rows ) self end def tag_row_reset ( * rows ) tk_send ( <str> , <str> , <str> , * rows ) self end def validate ( idx ) bool ( tk_send ( <str> , tagid ( idx ) ) ) end def width_list list ( tk_send ( <str> ) ) end def width ( row ) number ( tk_send ( <str> , row ) ) end def set_width ( * pairs ) tk_send ( <str> , * ( pairs . flatten ) ) self end def window_delete ( * args ) tk_send ( <str> , <str> , * ( args . collect { | idx | tagid ( idx ) } ) ) self end def window_move ( from_idx , to_idx ) tk_send ( <str> , <str> , tagid ( from_idx ) , tagid ( to_idx ) ) self end def window_names ( pat = None ) simplelist ( tk_send ( <str> , <str> , pat ) ) end end 
