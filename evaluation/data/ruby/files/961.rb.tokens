require <str> describe Bosh :: Cli :: Client :: Director do DUMMY_TARGET = <str> before do allow ( Resolv ) . to receive ( <str> ) . with ( <str> ) . and_return ( [ <str> ] ) @director = Bosh :: Cli :: Client :: Director . new ( DUMMY_TARGET , credentials ) allow ( @director ) . to receive ( <str> ) . and_return ( <int> ) end let ( <str> ) { Bosh :: Cli :: Client :: BasicCredentials . new ( <str> , <str> ) } describe <str> do it <str> do expect ( @director ) . to receive ( <str> ) . and_raise ( Bosh :: Cli :: DirectorError ) . ordered expect ( @director ) . to receive ( <str> ) . and_return ( <str> : <str> ) . ordered @director . wait_until_ready end end describe <str> do it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> ) ] ) expect ( @director . authenticated? ) . to eql ( true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . authenticated? ) . to eql ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . authenticated? ) . to eql ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . authenticated? ) . to eql ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > nil , <str> = > <int> ) ] ) expect ( @director . authenticated? ) . to eql ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> ) ] ) expect ( @director . authenticated? ) . to eql ( true ) end end describe <str> do before do @director = Bosh :: Cli :: Client :: Director . new ( DUMMY_TARGET ) end context <str> do it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> , <str> = > <str> ) ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( true ) end it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> ) ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) end end context <str> do it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( { } ) ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( false ) end end it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> ) ] ) expect ( @director . login ( <str> , <str> ) ) . to eq ( true ) end end describe <str> do context <str> do let ( <str> ) { { <str> = > <str> , <str> = > <str> } } it <str> do stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : <str> , <str> : <int> ) @director . get_status end end context <str> do let ( <str> ) { Bosh :: Cli :: Client :: UaaCredentials . new ( token_provider ) } let ( <str> ) { instance_double ( Bosh :: Cli :: Client :: Uaa :: TokenProvider , <str> : <str> ) } let ( <str> ) { { <str> = > <str> , <str> = > <str> } } it <str> do stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : <str> , <str> : <int> ) @director . get_status end end context <str> do let ( <str> ) { nil } let ( <str> ) { { <str> = > <str> } } it <str> do stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : <str> , <str> : <int> ) @director . get_status end end end describe <str> do it <str> do [ <str> , <str> , <str> , <str> ] . each do | verb | expect ( @director ) . to receive ( <str> ) . with ( verb , <str> , <str> , nil , { } , { } ) @director . send ( verb , <str> , <str> ) end end end describe <str> do let ( <str> ) { <int> } describe <str> do let ( <str> ) do [ { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <int> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <int> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <int> } ] end let ( <str> ) { JSON . generate ( vms ) } before do stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : response_body , <str> : <int> ) end context <str> do let ( <str> ) { { <str> = > <str> , <str> = > <str> } } it <str> do expect ( @director . list_vms ( <str> ) ) . to eq vms end end end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , JSON . generate ( <str> = > <str> , <str> = > <str> ) ) . and_return ( true ) @director . create_user ( <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> ) . and_return ( [ <int> , <str> , { } ] ) expect ( @director . delete_user ( <str> ) ) . to eql ( true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> ) . and_return ( [ <int> , <str> , { } ] ) expect ( @director . delete_user ( <str> ) ) . to eql ( false ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , { <str> = > <str> } ) . and_return ( true ) @director . upload_stemcell ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , { <str> = > <str> , <str> = > true } ) . and_return ( true ) @director . upload_stemcell ( <str> , <str> : true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > JSON . generate ( <str> = > <str> ) } ) . and_return ( true ) @director . upload_remote_stemcell ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > true , <str> = > JSON . generate ( <str> = > <str> ) } ) . and_return ( true ) @director . upload_remote_stemcell ( <str> , <str> : true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_stemcells end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_releases end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . inspect_release ( <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_deployments end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ { <str> = > <str> } ] ) , { } ] ) @director . list_errands ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_running_tasks end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_recent_tasks expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_recent_tasks ( <int> ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_recent_tasks ( <int> , <int> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , hash_including ( <str> = > <str> ) ) . and_return ( true ) @director . upload_release ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , hash_including ( <str> = > <str> ) ) . and_return ( true ) @director . upload_release ( <str> , <str> : true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , hash_including ( <str> = > <str> , <str> = > JSON . generate ( <str> = > <str> ) ) ) . and_return ( true ) @director . upload_remote_release ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , hash_including ( <str> = > <str> , <str> = > JSON . generate ( <str> = > <str> ) ) ) . and_return ( true ) @director . upload_remote_release ( <str> , <str> : true , <str> : true , <str> : <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . get_release ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . get_deployment ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_stemcell ( <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_stemcell ( <str> , <str> , <str> = > true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_deployment ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_release ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_release ( <str> , <str> = > true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > <str> } ) . and_return ( true ) @director . deploy ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > <str> } ) . and_return ( true ) @director . change_job_state ( <str> , <str> , <str> , nil , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( true ) @director . attach_disk ( <str> , <str> , <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > <str> } ) . and_return ( true ) @director . change_job_state ( <str> , <str> , <str> , <int> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> , { } , { } ) @director . change_vm_resurrection ( <str> , <str> , <int> , true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> , { } , { } ) @director . change_vm_resurrection_for_all ( false ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> task_number <str> ) . and_return ( [ <int> , JSON . generate ( { <str> = > <str> } ) ] ) expect ( @director . get_task_state ( task_number ) ) . to eql ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> task_number <str> , nil , nil , { <str> = > <str> } ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) expect ( @director . get_task_output ( task_number , <int> ) ) . to eql ( [ <str> , <int> ] ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> task_number <str> , nil , nil , { <str> = > <str> } ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) expect ( @director . get_task_output ( task_number , <int> ) ) . to eql ( [ nil , nil ] ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> task_number <str> , nil , nil , { <str> = > <str> } ) . and_return ( [ <int> , <str> ] ) expect ( @director . get_task_output ( task_number , <int> ) ) . to eql ( [ <str> , nil ] ) end it <str> do now = Time . now server_time = now - <int> allow ( Time ) . to receive ( <str> ) . and_return ( now ) expect ( @director ) . to receive ( <str> ) . with ( <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <int> ) , { <str> = > server_time . rfc822 } ] ) expect ( @director . get_time_difference . to_i ) . to eql ( <int> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . take_snapshot ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . take_snapshot ( <str> , <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_snapshots ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . list_snapshots ( <str> , <str> , <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_all_snapshots ( <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_snapshot ( <str> , <str> ) end it <str> do payload = { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > [ <str> ] , <str> = > [ <str> ] } , <str> = > { <str> = > <str> , <str> = > <str> , <str> = > <str> } } expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > JSON . generate ( payload ) , <str> = > <str> } ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . setup_ssh ( <str> , <str> , <str> , <str> , <str> , <str> ) end it <str> do payload = { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > [ <str> ] , <str> = > [ <str> ] } , <str> = > { <str> = > <str> } } expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > JSON . generate ( payload ) , <str> = > <str> , <str> = > <str> } ) . and_return ( [ <int> , JSON . generate ( [ ] ) , { } ] ) @director . cleanup_ssh ( <str> , <str> , <str> , [ <str> ] ) end context <str> do let ( <str> ) { { <str> = > <str> } } before do stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : <str> , <str> : <int> ) end let ( <str> ) { <str> } before do status_response = { name : target_name } stub_request ( <str> , <str> ) . with ( <str> : request_headers ) . to_return ( <str> : JSON . generate ( status_response ) , <str> : <int> ) end context <str> do it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> task_number <str> ) . and_return ( [ <int> , <str> ] ) expect { @director . get_task_state ( task_number ) } . to raise_error ( Bosh :: Cli :: MissingTask ) end end context <str> do it <str> do expect { @director . get ( <str> ) } . to raise_error ( Bosh :: Cli :: ResourceNotFound , <str> target_name <str> + <str> ) end end end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . delete_release ( <str> , <str> : <str> ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> } ) . and_return ( true ) @director . restore_db ( <str> ) end describe <str> do it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . twice . and_return ( [ <int> , <str> ] , [ <int> , <str> ] ) expect ( @director . check_director_restart ( <int> , <int> ) ) . to eql ( true ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . at_least ( <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . check_director_restart ( <int> , <int> ) ) . to eql ( false ) end end end describe <str> do it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { } ) . and_return ( true ) @director . create_backup end end describe <str> do it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , nil , nil , { } , <str> = > true ) . and_return ( [ <int> , <str> , { } ] ) expect ( @director . fetch_backup ) . to eq ( <str> ) end end describe <str> do let ( <str> ) { <str> } let ( <str> ) do JSON . generate [ { <str> = > <str> , <str> = > <str> , <str> = > <str> } ] end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> dummy_deployment_name <str> , { } ) . and_return ( [ <str> , <int> ] ) expect ( @director ) . to receive ( <str> ) . with ( <int> ) . and_return ( dummy_vm_state ) expect ( @director . fetch_vm_state ( dummy_deployment_name ) ) . to eq ( JSON . parse dummy_vm_state ) end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> dummy_deployment_name <str> , nil , nil , { } , { } ) . and_return ( [ <int> , <str> dummy_vm_state <str> , nil ] ) expect ( @director . fetch_vm_state ( dummy_deployment_name , { } , false ) ) . to eq ( JSON . parse dummy_vm_state ) end end describe <str> do it <str> do locks = <str> expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( locks ) ] ) expect ( @director . list_locks ) . to eq ( locks ) end end describe <str> do it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , <str> ] ) expect ( @director . exists? ) . to eql ( true ) end it <str> do allow ( @director ) . to receive ( <str> ) . with ( <str> , <str> ) . and_return ( [ <int> , JSON . generate ( <str> = > <str> ) ] ) expect ( @director . exists? ) . to eql ( true ) end end describe <str> do it <str> do options = { <str> = > <int> , <str> = > <int> } expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) tracker = double ( <str> , <str> = > <str> , <str> = > <str> ) expect ( Bosh :: Cli :: TaskTracking :: TaskTracker ) . to receive ( <str> ) . with ( @director , <str> , options ) . and_return ( tracker ) expect ( @director . request_and_track ( <str> , <str> , { <str> : <str> , <str> : <str> , <str> : <int> , <str> : <int> } ) ) . to eql ( [ <str> , <str> ] ) end it <str> do options = { <str> = > <int> , <str> = > <int> } expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) tracker = double ( <str> , <str> = > <str> , <str> = > <str> ) expect ( Bosh :: Cli :: TaskTracking :: TaskTracker ) . to receive ( <str> ) . with ( @director , <str> , options ) . and_return ( tracker ) expect ( @director . request_and_track ( <str> , <str> , { <str> = > <str> , <str> = > <str> , <str> = > <int> , <str> = > <int> } ) ) . to eql ( [ <str> , <str> ] ) end describe <str> do it <str> do options = { <str> = > <int> , <str> = > <int> } expect ( URI ) . to receive ( <str> ) . with ( DUMMY_TARGET ) . and_call_original expect ( Resolv ) . to receive ( <str> ) . with ( <str> ) . and_return ( [ <str> ] ) @director = Bosh :: Cli :: Client :: Director . new ( DUMMY_TARGET , credentials , <str> = > true ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) tracker = double ( <str> , <str> = > <str> , <str> = > <str> ) expect ( Bosh :: Cli :: TaskTracking :: TaskTracker ) . to receive ( <str> ) . with ( @director , <str> , options ) . never expect ( @director . request_and_track ( <str> , <str> , { <str> = > <str> , <str> = > <str> , <str> = > <int> , <str> = > <int> } ) ) . to eql ( [ <str> , <str> ] ) end end it <str> do [ <int> , <int> , <int> ] . each do | code | expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> ) . and_return ( [ code , <str> , { } ] ) expect ( @director . request_and_track ( <str> , <str> , { <str> = > <str> , <str> = > <str> , <str> = > <int> , <str> = > <int> } ) ) . to eql ( [ <str> , nil ] ) end end it <str> do expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> ) . and_return ( [ <int> , <str> , { <str> = > <str> } ] ) expect ( @director . request_and_track ( <str> , <str> , { <str> = > <str> , <str> = > <str> , <str> = > <int> , <str> = > <int> } ) ) . to eql ( [ <str> , nil ] ) end it <str> do file = spec_asset ( <str> ) f = Bosh :: Cli :: FileWithProgressBar . open ( file , <str> ) allow ( Bosh :: Cli :: FileWithProgressBar ) . to receive ( <str> ) . with ( file , <str> ) . and_return ( f ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , { <str> = > <str> , <str> = > f } ) @director . upload_and_track ( <str> , <str> , file , <str> = > <str> ) expect ( f . progress_bar . finished? ) . to eql ( true ) end end describe <str> do it <str> do headers = { <str> = > <str> , <str> = > <str> , <str> = > <str> } user = <str> password = <str> auth = <str> + Base64 . encode64 ( <str> user <str> password <str> ) . strip ssl_config = double ( <str> ) expect ( ssl_config ) . to receive ( <str> = ) . with ( OpenSSL :: SSL :: VERIFY_NONE ) expect ( ssl_config ) . to receive ( <str> = ) client = double ( <str> , <str> = > ssl_config ) expect ( client ) . to receive ( <str> = ) . with ( Bosh :: Cli :: Client :: Director :: API_TIMEOUT ) expect ( client ) . to receive ( <str> = ) . with ( Bosh :: Cli :: Client :: Director :: API_TIMEOUT ) expect ( client ) . to receive ( <str> = ) . with ( Bosh :: Cli :: Client :: Director :: CONNECT_TIMEOUT ) allow ( HTTPClient ) . to receive ( <str> ) . and_return ( client ) expect ( client ) . to receive ( <str> ) . with ( <str> , <str> , <str> = > <str> , <str> = > headers . merge ( <str> = > auth ) ) @director . send ( <str> , <str> , <str> , <str> , headers ) end end describe <str> do it <str> do mock_response = double ( <str> , <str> = > <int> , <str> = > <str> , <str> = > { } ) expect ( @director ) . to receive ( <str> ) . with ( <str> , <str> , <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> ) . and_return ( mock_response ) expect ( @director . send ( <str> , <str> , <str> , <str> , <str> , { <str> = > <str> , <str> = > <str> } ) ) . to eql ( [ <int> , <str> , { } ] ) end it <str> do [ <int> , <int> , <int> ] . each do | code | expect { body = JSON . generate ( <str> = > <str> , <str> = > <str> ) mock_response = double ( <str> , <str> = > code , <str> = > body , <str> = > { } ) expect ( @director ) . to receive ( <str> ) . and_return ( mock_response ) @director . send ( <str> , <str> , <str> , <str> , <str> , { <str> = > <str> , <str> = > <str> } ) } . to raise_error ( Bosh :: Cli :: DirectorError , <str> ) expect { mock_response = double ( <str> , <str> = > code , <str> = > <str> , <str> = > { } ) expect ( @director ) . to receive ( <str> ) . and_return ( mock_response ) @director . send ( <str> , <str> , <str> , <str> , <str> , { <str> = > <str> , <str> = > <str> } ) } . to raise_error ( Bosh :: Cli :: DirectorError , <str> code <str> + <str> ) expect { mock_response = double ( <str> , <str> = > code , <str> = > <str> , <str> = > { } ) expect ( @director ) . to receive ( <str> ) . and_return ( mock_response ) @director . send ( <str> , <str> , <str> , <str> , <str> , { <str> = > <str> , <str> = > <str> } ) } . to raise_error ( Bosh :: Cli :: DirectorError , <str> code <str> + <str> ) end end it <str> do expect ( File ) . to receive ( <str> ) . and_raise ( SystemCallError . new ( <str> , <int> ) ) expect { @director . send ( <str> , <str> , <str> , <str> , <str> , { } , <str> : true ) } . to raise_error ( Bosh :: Cli :: DirectorError ) end describe <str> do context <str> do it <str> do expect ( @director ) . to receive ( <str> ) . exactly ( <int> ) . times . and_raise ( Bosh :: Cli :: DirectorInaccessible , <str> ) expect ( @director ) . to receive ( <str> ) . with ( <int> ) . exactly ( <int> ) . times expect { @director . send ( <str> , <str> , <str> , <str> , { } , <int> , <int> ) } . to raise_error ( Bosh :: Cli :: DirectorInaccessible , <str> ) end end context <str> do it <str> do error = Exception . new ( <str> ) expect ( @director ) . to receive ( <str> ) . exactly ( <int> ) . and_raise ( error ) expect { @director . send ( <str> , <str> , <str> , <str> , { } , <int> , <int> ) } . to raise_error ( error ) end end end describe <str> do before { allow ( HTTPClient ) . to receive ( <str> ) . and_return ( http_client ) } let ( <str> ) { double ( <str> ) . as_null_object } [ URI :: Error . new ( <str> ) , SocketError . new ( <str> ) , Errno :: ECONNREFUSED . new , Errno :: ECONNRESET . new , Errno :: ETIMEDOUT . new , Timeout :: Error . new ( <str> ) , HTTPClient :: TimeoutError . new ( <str> ) , HTTPClient :: KeepAliveDisconnected . new ( <str> ) , OpenSSL :: SSL :: SSLError . new ( <str> ) , OpenSSL :: X509 :: StoreError . new ( <str> ) ] . each do | error | context <str> error <str> do it <str> do expect ( http_client ) . to receive ( <str> ) . and_raise ( error ) expect { @director . send ( <str> , <str> , <str> , <str> , { } ) } . to raise_error ( Bosh :: Cli :: DirectorInaccessible ) end end end context <str> do it <str> do expect ( http_client ) . to receive ( <str> ) . and_raise ( HTTPClient :: BadResponseError , <str> ) expect { @director . send ( <str> , <str> , <str> , <str> , { } ) } . to raise_error ( Bosh :: Cli :: CliError , <str> ) end end context <str> do it <str> do error_message = <str> uri = <str> expect ( http_client ) . to receive ( <str> ) . and_raise ( OpenSSL :: SSL :: SSLError , error_message ) expect { @director . send ( <str> , <str> , uri , <str> , { } ) } . to raise_error ( Bosh :: Cli :: CliError , <str> uri <str> error_message <str> ) end end context <str> do it <str> do expect ( http_client ) . to receive ( <str> ) . and_raise ( RuntimeError , <str> ) expect { @director . send ( <str> , <str> , <str> , <str> , { } ) } . to raise_error ( Bosh :: Cli :: CliError , <str> ) end end end it <str> do mock_response = double ( <str> , <str> = > <int> , <str> = > <str> , <str> = > { } ) expect ( @director ) . to receive ( <str> ) . and_yield ( <str> ) . and_return ( mock_response ) code , filename , headers = @director . send ( <str> , <str> , <str> , nil , nil , { } , { <str> = > true } ) expect ( code ) . to eql ( <int> ) expect ( File . read ( filename ) ) . to eql ( <str> ) expect ( headers ) . to eql ( { } ) end end end 
