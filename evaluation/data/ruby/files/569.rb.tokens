require <str> require <str> module Puppet::Network class AuthorizationError < Puppet :: Error ; end class Rights def allowed? ( name , * args ) ! is_forbidden_and_why? ( name , <str> = > args [ <int> ] , <str> = > args [ <int> ] ) end def is_request_forbidden_and_why? ( method , path , params ) methods_to_check = if method == <str> [ <str> , <str> ] else [ method ] end authorization_failure_exceptions = methods_to_check . map do | m | is_forbidden_and_why? ( path , params . merge ( { <str> = > m } ) ) end if authorization_failure_exceptions . include? nil nil else authorization_failure_exceptions . first end end def is_forbidden_and_why? ( name , args = { } ) res = <str> right = @rights . find do | acl | found = false if match = acl . match? ( name ) args [ <str> ] = match if ( res = acl . allowed? ( args [ <str> ] , args [ <str> ] , args ) ) != <str> return nil if res found = true end end found end host_description = args [ <str> ] ? <str> args [ <str> ] <str> args [ <str> ] <str> : args [ <str> ] msg = <str> host_description <str> name <str> args [ <str> ] <str> if args [ <str> ] msg += <str> end if right msg += <str> right . file <str> right . line <str> end AuthorizationError . new ( <str> msg <str> ) end def initialize @rights = [ ] end def [] ( name ) @rights . find { | acl | acl == name } end def empty? @rights . empty? end def include? ( name ) @rights . include? ( name ) end def each @rights . each { | r | yield r . name , r } end def newright ( name , line = nil , file = nil ) add_right ( Right . new ( name , line , file ) ) end private def add_right ( right ) @rights << right right end def right ( name ) self [ name ] end class Right < Puppet :: Network :: AuthStore attr_accessor <str> , <str> attr_accessor <str> , <str> , <str> attr_accessor <str> , <str> ALL = [ <str> , <str> , <str> , <str> ] Puppet :: Util . logmethods ( self , true ) def initialize ( name , line , file ) @methods = [ ] @environment = [ ] @authentication = true @name = name @line = line || <int> @file = file @methods = ALL case name when <str> @key = Regexp . new ( <str> + Regexp . escape ( name ) ) when <str> @name = name . gsub ( <str> , <str> ) @key = Regexp . new ( @name ) else raise ArgumentError , <str> name <str> end super ( ) end def to_s <str> @name <str> end def valid? true end def allowed? ( name , ip , args = { } ) if not @methods . include? ( args [ <str> ] ) return <str> elsif @environment . size > <int> and not @environment . include? ( args [ <str> ] ) return <str> elsif ( @authentication and not args [ <str> ] ) return <str> end begin interpolate ( args [ <str> ] ) if args [ <str> ] res = super ( name , ip ) ensure reset_interpolation end res end def restrict_method ( m ) m = m . intern if m . is_a? ( String ) raise ArgumentError , <str> m <str> unless ALL . include? ( m ) if @methods === ALL @methods = [ ] end raise ArgumentError , <str> m <str> name <str> if @methods . include? ( m ) @methods << m end def restrict_environment ( environment ) env = Puppet . lookup ( <str> ) . get ( environment ) raise ArgumentError , <str> env <str> name <str> if @environment . include? ( env ) @environment << env end def restrict_authenticated ( authentication ) case authentication when <str> , <str> , <str> , true authentication = true when <str> , <str> , <str> , false , <str> , <str> , <str> , <str> authentication = false else raise ArgumentError , <str> name <str> authentication <str> end @authentication = authentication end def match? ( key ) self . key . match ( key ) end def == ( name ) self . name == name . gsub ( <str> , <str> ) end end end end 
