require <str> class SemVer < Numeric include Comparable VERSION = <str> SIMPLE_RANGE = <str> def self . valid? ( ver ) VERSION =~ ver end def self . find_matching ( pattern , versions ) versions . select { | v | v . matched_by? ( <str> pattern <str> ) } . sort . last end def self . pre ( vstring ) vstring =~ <str> ? vstring : vstring + <str> end def self . [] ( range ) range . gsub ( <str> , <str> ) . split ( <str> ) . map do | r | case r when SemVer :: VERSION SemVer . new ( pre ( r ) ) .. SemVer . new ( r ) when SemVer :: SIMPLE_RANGE r += <str> unless SemVer . valid? ( r . gsub ( <str> , <str> ) ) SemVer . new ( r . gsub ( <str> , <str> ) ) ... SemVer . new ( r . gsub ( <str> ) { <str> $1 . to_i + <int> <str> } + <str> ) when <str> a , b = r . split ( <str> ) SemVer . new ( pre ( a ) ) .. SemVer . new ( b ) when <str> ver = r . sub ( <str> , <str> ) . split ( <str> ) . map ( & <str> ) start = ( ver + [ <int> ] * ( <int> - ver . length ) ) . join ( <str> ) ver . pop unless ver . length == <int> ver [ - <int> ] = ver . last + <int> finish = ( ver + [ <int> ] * ( <int> - ver . length ) ) . join ( <str> ) SemVer . new ( pre ( start ) ) ... SemVer . new ( pre ( finish ) ) when <str> ver = r . sub ( <str> , <str> ) SemVer . new ( pre ( ver ) ) .. SemVer :: MAX when <str> ver = r . sub ( <str> , <str> ) SemVer :: MIN .. SemVer . new ( ver ) when <str> if r =~ <str> ver = [ r [ <int> .. - <int> ] ] else ver = r . sub ( <str> , <str> ) . split ( <str> ) . map ( & <str> ) ver [ <int> ] = ver . last + <int> end SemVer . new ( ver . join ( <str> ) + <str> ) .. SemVer :: MAX when <str> ver = r . sub ( <str> , <str> ) SemVer :: MIN ... SemVer . new ( pre ( ver ) ) else ( <int> .. <int> ) end end . inject { | a , e | a & e } end attr_reader <str> , <str> , <str> , <str> def initialize ( ver ) unless SemVer . valid? ( ver ) raise ArgumentError . new ( <str> ver <str> ) end @major , @minor , @tiny , @special = VERSION . match ( ver ) . captures . map do | x | Float ( x ) . to_i rescue x end end def <=> ( other ) unless other . is_a? SemVer return nil unless SemVer . valid? ( other ) other = SemVer . new ( <str> other <str> ) end return self . major < = > other . major unless self . major == other . major return self . minor < = > other . minor unless self . minor == other . minor return self . tiny < = > other . tiny unless self . tiny == other . tiny return <int> if self . special == other . special return <int> if self . special == <str> return - <int> if other . special == <str> return self . special < = > other . special end def matched_by? ( pattern ) case pattern when SIMPLE_RANGE pattern = SIMPLE_RANGE . match ( pattern ) . captures pattern [ <int> ] = @minor unless pattern [ <int> ] && pattern [ <int> ] !~ <str> pattern [ <int> ] = @tiny unless pattern [ <int> ] && pattern [ <int> ] !~ <str> [ @major , @minor , @tiny ] == pattern . map { | x | x . to_i } when VERSION self == SemVer . new ( pattern ) else false end end def inspect @vstring || <str> @major <str> @minor <str> @tiny <str> @special <str> end alias <str> <str> MIN = SemVer . new ( <str> ) MIN . instance_variable_set ( <str> , <str> ) MAX = SemVer . new ( <str> ) MAX . instance_variable_set ( <str> , Float :: INFINITY ) MAX . instance_variable_set ( <str> , <str> ) end 
