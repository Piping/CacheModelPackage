require <str> module Msf class SessionManager < Hash include Framework :: Offspring LAST_SEEN_INTERVAL = <int> * <int> . <int> SCHEDULER_THREAD_COUNT = <int> def initialize ( framework ) self . framework = framework self . sid_pool = <int> self . mutex = Mutex . new self . scheduler_queue = :: Queue . new self . initialize_scheduler_threads self . monitor_thread = framework . threads . spawn ( <str> , true ) do last_seen_timer = Time . now . utc respawn_max = <int> respawn_cnt = <int> begin while true rings = values . select { | s | s . respond_to? ( <str> ) and s . ring and s . rstream } ready = :: IO . select ( rings . map { | s | s . rstream } , nil , nil , <int> . <int> ) || [ [ ] , [ ] , [ ] ] ready [ <int> ] . each do | fd | s = rings . select { | s | s . rstream == fd } . first next if not s begin buff = fd . get_once ( - <int> ) if buff s . ring . store_data ( buff ) framework . events . on_session_output ( s , buff ) rescue nil end rescue :: Exception = > e wlog ( <str> s . sid <str> e . class <str> e <str> ) unless e . kind_of? EOFError dlog ( <str> e . backtrace . join ( <str> ) <str> , <str> , LEV_3 ) end s . ring . clear_data rescue nil s . rstream . close rescue nil deregister ( s , <str> e . class <str> ) end end values . each do | s | if not s . alive? deregister ( s , <str> ) wlog ( <str> s . sid <str> ) next end end if ( Time . now . utc - last_seen_timer ) > = LAST_SEEN_INTERVAL last_seen_timer = Time . now . utc if framework . db . active :: ActiveRecord :: Base . connection_pool . with_connection do values . each do | s | if s . db_record s . db_record . last_seen = Time . now . utc s . db_record . save end end end end end next if not ( framework . db and framework . db . active ) :: ActiveRecord :: Base . connection_pool . with_connection do | conn | :: Mdm :: Session . where ( <str> : nil ) . each do | db_session | if db_session . last_seen . nil? or ( ( Time . now . utc - db_session . last_seen ) > ( <int> * LAST_SEEN_INTERVAL ) ) db_session . closed_at = db_session . last_seen || Time . now . utc db_session . close_reason = <str> db_session . save end end end end rescue :: Exception = > e respawn_cnt += <int> elog ( <str> respawn_cnt <str> respawn_max <str> e . class <str> e <str> ) elog ( <str> e . backtrace . join ( <str> ) <str> ) if respawn_cnt < respawn_max :: IO . select ( nil , nil , nil , <int> . <int> ) retry end end end end def initialize_scheduler_threads self . scheduler_threads = [ ] <int> . upto ( SCHEDULER_THREAD_COUNT ) do | i | self . scheduler_threads << framework . threads . spawn ( <str> i <str> , true ) do while true item = self . scheduler_queue . pop begin item . call ( ) rescue :: Exception = > e wlog ( <str> e . class <str> e <str> ) wlog ( <str> e . backtrace . join ( <str> ) <str> , <str> , LEV_3 ) end end end end end def schedule ( task ) self . scheduler_queue . push ( task ) end def each_sorted ( & block ) self . keys . sort . each ( & block ) end def each ( & block ) list = [ ] self . keys . sort . each do | sidx | list << [ sidx , self [ sidx ] ] end list . each ( & block ) end def register ( session ) if ( session . sid ) wlog ( <str> session . sid <str> ) return nil end next_sid = allocate_sid session . sid = next_sid session . framework = framework if session . register? self [ next_sid . to_i ] = session begin framework . events . on_session_open ( session ) rescue :: Exception = > e wlog ( <str> e . class <str> e <str> ) wlog ( <str> e . backtrace . join ( <str> ) <str> ) end if session . respond_to? ( <str> ) session . console . on_command_proc = Proc . new { | command , error | framework . events . on_session_command ( session , command ) } session . console . on_print_proc = Proc . new { | output | framework . events . on_session_output ( session , output ) } end end return next_sid end def deregister ( session , reason = <str> ) return if not session . register? if ( session . dead? and not self [ session . sid . to_i ] ) return end framework . events . on_session_close ( session , reason ) rescue nil if ( session . kind_of? ( Msf :: Session :: Comm ) ) Rex :: Socket :: SwitchBoard . remove_by_comm ( session ) end self . delete ( session . sid . to_i ) session . alive = false session . cleanup end def get ( sid ) session = nil sid = sid . to_i if sid > <int> session = self [ sid ] elsif sid == - <int> sid = self . keys . sort [ - <int> ] session = self [ sid ] end session end def allocate_sid self . mutex . synchronize do self . sid_pool += <int> end end protected attr_accessor <str> , <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> end end 
