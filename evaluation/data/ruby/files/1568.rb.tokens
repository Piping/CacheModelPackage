require_relative <str> require <str> require <str> require <str> module REXMLTests class ContribTester < Test :: Unit :: TestCase include REXMLTestUtils include REXML XML_STRING_01 = << <str> DELIMITER <str> <str> DELIMITER XML_STRING_02 = << <str> DELIMITER <str> <str> DELIMITER def test_bad_doctype_Tobias source = <<- <str> EOF <str> <str> EOF doc = REXML :: Document . new source doc . write ( out = <str> ) assert ( out [ <str> ] != nil , <str> ) assert ( out [ <str> ] != nil , <str> ) end def test_namespace_Peter source = <<- <str> EOF <str> <str> EOF doc = REXML :: Document . new source assert_equal <str> , doc . root . name count = <int> REXML :: XPath . each ( doc , <str> , { <str> = > <str> } ) { | element | assert_equal <str> , element . attributes [ <str> ] count += <int> ; } assert_equal <int> , count assert_equal <str> , doc . elements [ <str> ] . name end def test_complex_xpath_Tobias source = <<- <str> EOF <str> <str> EOF complex_path = <str> + <str> + <str> + <str> doc = REXML :: Document . new source results = REXML :: XPath . match ( doc . root , complex_path ) assert ( results ) assert_equal <int> , results . size assert_equal <str> , results [ <int> ] . name end def test_extra_newline_on_read_Chris text = <str> e = REXML :: Element . new ( <str> ) e . add_text ( text ) REXML :: Formatters :: Default . new . write ( e , out = <str> ) doc = REXML :: Document . new ( out ) outtext = doc . root . text assert_equal ( text , outtext ) end def test_other_xpath_Tobias schema = <<- <str> DELIM <str> <str> DELIM doc = REXML :: Document . new schema result = REXML :: XPath . first ( doc . root , <str> ) assert result assert_equal <str> , result . attributes [ <str> ] result = REXML :: XPath . first ( doc , <str> ) assert_nil result end def test_xpath_01_TobiasReif doc = Document . new XML_STRING_01 . dup desired_result = Document . new <str> xpath = <str> result = XPath . first ( doc , xpath ) assert_equal desired_result . to_s , result . to_s end def test_xpath_whitespace_TobiasReif doc = Document . new ( XML_STRING_01 . dup ) desired_result = Document . new ( <str> ) xpath = <str> result = XPath . first ( doc , xpath ) failure_message = <str> assert_equal ( desired_result . to_s , result . to_s , failure_message ) end def test_xpath_02_TobiasReif doc = Document . new XML_STRING_01 . dup desired_result = Document . new <str> xpath = <str> result = XPath . first ( doc , xpath ) failure_message = <str> xpath <str> assert_equal desired_result . to_s , result . to_s , failure_message end def test_xpath_03_TobiasReif doc = Document . new XML_STRING_02 . dup desired_result_string = <str> Document . new desired_result_string xpath = <str> result = XPath . first ( doc , xpath ) assert_equal desired_result_string , result . to_s end def test_umlaut koln_iso = <str> koln_utf = <str> source_iso = <str> koln_iso <str> source_utf = <str> koln_utf <str> if String . method_defined? <str> koln_iso . force_encoding ( <str> ) koln_utf . force_encoding ( <str> ) source_iso . force_encoding ( <str> ) source_utf . force_encoding ( <str> ) end doc = REXML :: Document . new ( source_iso ) assert_equal ( <str> , doc . xml_decl . encoding ) assert_equal ( koln_utf , doc . root . text ) doc . write ( out = <str> ) assert_equal ( source_iso , out ) doc . xml_decl . encoding = <str> doc . write ( out = <str> ) assert_equal ( source_utf , out ) doc = Document . new <<- <str> EOF <str> <str> EOF tn = XPath . first ( doc , <str> ) expected_iso = <str> expected_utf = expected_iso . unpack ( <str> ) . pack ( <str> ) expected_iso . force_encoding ( :: Encoding :: ISO_8859_1 ) expected_utf . force_encoding ( :: Encoding :: UTF_8 ) assert_equal ( expected_utf , tn . to_s . strip ) f = REXML :: Formatters :: Default . new f . write ( tn , Output . new ( o = <str> , <str> ) ) assert_equal ( expected_iso , o . strip ) doc = File . open ( fixture_path ( <str> ) ) { | file | Document . new file } tn = XPath . first ( doc , <str> ) assert_equal ( expected_utf , tn . to_s . strip ) f . write ( tn , Output . new ( o = <str> , <str> ) ) assert_equal ( expected_iso , o . strip ) end def test_element_cloning_namespace_Chris aDoc = REXML :: Document . new <str> anElement = anElement = aDoc . elements [ <int> ] elementAttrPrefix = anElement . attributes . get_attribute ( <str> ) . prefix aClone = anElement . clone cloneAttrPrefix = aClone . attributes . get_attribute ( <str> ) . prefix assert_equal ( elementAttrPrefix , cloneAttrPrefix ) end def test_namespaces_in_attlist_tobias in_string = File . open ( fixture_path ( <str> ) , <str> ) do | file | file . read end doc = Document . new in_string assert_nil XPath . first ( doc , <str> ) assert_equal <str> , doc . root . elements [ <int> ] . namespace assert_equal <str> , XPath . first ( doc , <str> , { <str> = > <str> } ) . to_s end def test_less_than_in_element_content doc = File . open ( fixture_path ( <str> ) ) do | source | REXML :: Document . new source end h = Hash . new doc . elements . each ( <str> ) { | el | h [ el . elements [ <str> ] . text ] = <str> } assert ( h . include? ( <str> ) ) end def test_various_xpath doc = REXML :: Document . new ( <str> ) [ [ <str> , REXML :: Element ] , [ <str> , REXML :: Element ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , Attribute ] , [ <str> , REXML :: Node ] , [ <str> , REXML :: Element ] , [ <str> , REXML :: Element ] , [ <str> , REXML :: Element ] , [ <str> , REXML :: Element ] ] . each do | xpath , kind | begin REXML :: XPath . each ( doc , xpath ) do | what | assert_kind_of ( kind , what , <str> what . class <str> xpath <str> kind . name <str> ) end rescue Exception puts <str> xpath <str> raise end end [ [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] , [ <str> , <str> , Attribute ] ] . each do | nodepath , xpath , kind | begin context = REXML :: XPath . first ( doc , nodepath ) REXML :: XPath . each ( context , xpath ) do | what | assert_kind_of kind , what , <str> what . class <str> xpath <str> kind . name <str> end rescue Exception puts <str> xpath <str> raise end end end def test_entities_Holden_Glova document = <<- <str> EOL <str> <str> EOL file_xpath = <str> root = REXML :: Document . new ( document ) root . elements . each ( file_xpath ) do | metadata | text = metadata . elements [ <str> ] . get_text . value assert text !~ <str> , <str> text <str> end end def test_whitespace_after_xml_decl Document . new << <str> EOL <str> <str> EOL end def test_external_entity xp = <str> <str> . each do | path | File . open ( File . join ( fixture_path ( path ) ) ) do | file | doc = REXML :: Document . new file . readlines . join ( <str> ) assert_equal ( doc . root . class , REXML :: Element ) assert_equal ( doc . root . elements . class , REXML :: Elements ) assert ( doc . root . elements [ xp ] . kind_of? ( REXML :: Element ) ) end end end def test_maintain_dtd src = <str> doc = Document . new ( src ) doc . write ( out = <str> ) src = src . tr ( <str> , <str> ) out = out . tr ( <str> , <str> ) assert_equal ( src , out ) end def test_text_nodes_nomatch source = <str> d = REXML :: Document . new ( source ) r = REXML :: XPath . match ( d , <str> ) assert_equal ( <int> , r . size ) end def test_raw_Terje_Elde f = REXML :: Formatters :: Default . new txt = <str> a = Text . new ( txt , false , nil , true ) f . write ( a , out = <str> ) assert_equal ( txt , out ) txt = <str> a = Document . new ( txt , { <str> = > [ <str> ] } ) f . write ( a , out = <str> ) assert_equal ( txt , out ) end def test_indenting_error a = Element . new ( <str> ) b = Element . new ( <str> ) c = Element . new ( <str> ) b << c a << b REXML :: Formatters :: Pretty . new . write ( a , <str> ) end def test_pos require <str> Tempfile . create ( <str> ) { | testfile | testdata = <str> testfile . puts testdata testfile . rewind assert_nothing_raised do REXML :: Document . new ( testfile ) end } end def test_deep_clone a = Document . new ( <str> ) b = a . deep_clone assert_equal a . to_s , b . to_s end def test_double_escaping data = <str> xml = <str> data <str> doc = REXML :: Document . new ( xml ) description = doc . find { | e | e . name == <str> } assert_equal data , description . text end def test_ticket_12 cfg = <str> config = REXML :: Document . new ( cfg ) assert_equal ( <str> , config . elements [ <str> ] . text ) end end end 
