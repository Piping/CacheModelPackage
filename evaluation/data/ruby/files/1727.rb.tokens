module Rex module Proto module IAX2 class Call attr_accessor <str> attr_accessor <str> , <str> attr_accessor <str> , <str> attr_accessor <str> , <str> attr_accessor <str> , <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> def initialize ( client , src_id ) self . client = client self . scall = src_id self . dcall = <int> self . iseq = <int> self . oseq = <int> self . state = nil self . itime = :: Time . now self . queue = :: Queue . new self . audio_buff = [ ] self . busy = false self . dtmf = <str> end def dprint ( msg ) self . client . dprint ( msg ) end def wait_for ( * stypes ) begin :: Timeout . timeout ( IAX_DEFAULT_TIMEOUT ) do while ( res = self . queue . pop ) if stypes . include? ( res [ <int> ] ) return res end end end rescue :: Timeout :: Error return nil end end def register self . client . send_regreq ( self ) res = wait_for ( IAX_SUBTYPE_REGAUTH , IAX_SUBTYPE_REGREJ ) return if not res if res [ <int> ] == IAX_SUBTYPE_REGREJ reason = res [ <int> ] [ IAX_IE_REGREJ_CAUSE ] || <str> dprint ( <str> reason <str> ) self . client . send_ack ( self ) return end chall = nil if res [ <int> ] [ <int> ] . unpack ( <str> ) [ <int> ] & <int> < = <int> dprint ( <str> ) return end if res [ <int> ] [ IAX_IE_CHALLENGE_DATA ] self . dcall = res [ <int> ] [ <int> ] chall = res [ <int> ] [ IAX_IE_CHALLENGE_DATA ] end if chall . nil? dprint ( <str> ) return end self . client . send_regreq_chall_response ( self , chall ) res = wait_for ( IAX_SUBTYPE_REGACK , IAX_SUBTYPE_REGREJ ) return if not res if res [ <int> ] == IAX_SUBTYPE_REGREJ reason = res [ <int> ] [ IAX_IE_REGREJ_CAUSE ] || <str> dprint ( <str> reason <str> ) return end if res [ <int> ] [ IAX_IE_APPARENT_ADDR ] r_fam , r_port , r_addr = res [ <int> ] [ IAX_IE_APPARENT_ADDR ] . unpack ( <str> ) r_addr = r_addr . unpack ( <str> ) . map { | x | x . to_s } . join ( <str> ) dprint ( <str> r_addr <str> r_port <str> ) end self . client . send_ack ( self ) self . state = <str> true end def dial ( number ) self . client . send_new ( self , number ) res = wait_for ( IAX_SUBTYPE_AUTHREQ , IAX_SUBTYPE_ACCEPT ) return if not res if res [ <int> ] == IAX_SUBTYPE_AUTHREQ chall = nil if res [ <int> ] [ <int> ] . unpack ( <str> ) [ <int> ] & <int> < = <int> dprint ( <str> ) return end if res [ <int> ] [ IAX_IE_CHALLENGE_DATA ] self . dcall = res [ <int> ] [ <int> ] chall = res [ <int> ] [ IAX_IE_CHALLENGE_DATA ] end if chall . nil? dprint ( <str> ) return end self . client . send_authrep_chall_response ( self , chall ) res = wait_for ( IAX_SUBTYPE_ACCEPT ) return if not res end self . codec = res [ <int> ] [ IAX_IE_DESIRED_CODEC ] . unpack ( <str> ) [ <int> ] self . state = <str> self . ring_start = :: Time . now . to_i self . client . send_ack ( self ) true end def hangup self . client . send_hangup ( self ) self . state = <str> true end def ring_time ( self . ring_finish || Time . now ) . to_i - self . ring_start . to_i end def timestamp ( ( :: Time . now - self . itime ) * <int> . <int> ) . to_i & <hex> end def process_elements ( data , off = <int> ) res = { } while ( off < data . length ) ie_type = data [ off , <int> ] . unpack ( <str> ) [ <int> ] ie_len = data [ off + <int> , <int> ] . unpack ( <str> ) [ <int> ] res [ ie_type ] = data [ off + <int> , ie_len ] off += ie_len + <int> end res end def handle_control ( pkt ) src_call , dst_call , tstamp , out_seq , inp_seq , itype = pkt . unpack ( <str> ) src_call ^= <hex> if ( src_call & <hex> != <int> ) dst_call ^= <hex> if ( dst_call & <hex> != <int> ) phdr = [ src_call , dst_call , tstamp , out_seq , inp_seq , itype ] info = nil stype = pkt [ <int> , <int> ] . unpack ( <str> ) [ <int> ] info = process_elements ( pkt , <int> ) if [ IAX_TYPE_IAX , IAX_TYPE_CONTROL ] . include? ( itype ) if dst_call != self . scall dprint ( <str> dst_call <str> self . scall <str> phdr . inspect <str> stype . inspect <str> info . inspect <str> ) return end self . iseq = ( self . iseq + <int> ) & <hex> if self . state == <str> dprint ( <str> ) self . client . send_invalid ( self ) return end case itype when IAX_TYPE_DTMF_BEGIN self . dprint ( <str> pkt [ <int> , <int> ] <str> ) self . dtmf << pkt [ <int> , <int> ] when IAX_TYPE_DTMF_END self . dprint ( <str> pkt [ <int> , <int> ] <str> ) when IAX_TYPE_CONTROL case stype when IAX_CTRL_HANGUP dprint ( <str> ) self . client . send_ack ( self ) self . state = <str> when IAX_CTRL_RINGING dprint ( <str> ) self . client . send_ack ( self ) when IAX_CTRL_BUSY dprint ( <str> ) self . busy = true self . state = <str> self . client . send_ack ( self ) when IAX_CTRL_ANSWER dprint ( <str> ) if self . state == <str> self . state = <str> self . ring_finish = :: Time . now . to_i end self . client . send_ack ( self ) when IAX_CTRL_PROGRESS dprint ( <str> ) when IAX_CTRL_PROCEED dprint ( <str> ) when <int> dprint ( <str> ) end when IAX_TYPE_IAX dprint ( [ <str> , phdr , stype , info ] . inspect ) case stype when IAX_SUBTYPE_HANGUP self . state = <str> self . client . send_ack ( self ) when IAX_SUBTYPE_LAGRQ self . client . send_lagrp ( self , tstamp ) when IAX_SUBTYPE_ACK when IAX_SUBTYPE_PING self . client . send_pong ( self , tstamp ) when IAX_SUBTYPE_PONG self . client . send_ack ( self ) else dprint ( [ <str> , phdr , stype , info ] . inspect ) self . queue . push ( [ phdr , stype , info ] ) end when IAX_TYPE_VOICE v_codec = stype if self . state == <str> handle_audio ( pkt ) end self . client . send_ack ( self ) when nil dprint ( <str> pkt . unpack ( <str> ) [ <int> ] <str> ) end end def handle_audio ( pkt ) return if self . state != <str> data = audio_packet_data ( pkt ) buff = decode_audio_frame ( data ) if self . audio_hook self . audio_buff ( buff ) else self . audio_buff << buff end end def each_audio_frame ( & block ) self . audio_buff . each do | frame | block . call ( frame ) end end def decode_audio_frame ( buff ) case self . codec when IAX_CODEC_G711_MULAW Rex :: Proto :: IAX2 :: Codecs :: MuLaw . decode ( buff ) when IAX_CODEC_G711_ALAW Rex :: Proto :: IAX2 :: Codecs :: ALaw . decode ( buff ) when IAX_CODEC_LINEAR_PCM buff else dprint ( <str> self . codec . inspect <str> ) <str> end end def audio_packet_data ( pkt ) ( pkt [ <int> , <int> ] . unpack ( <str> ) [ <int> ] & <hex> == <int> ) ? pkt [ <int> , pkt . length - <int> ] : pkt [ <int> , pkt . length - <int> ] end end end end end 
