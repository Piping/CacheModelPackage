require <str> Puppet :: Type . type ( <str> ) . provide ( <str> , <str> = > Puppet :: Provider :: ParsedFile , <str> = > <str> , <str> = > <str> ) do desc <str> text_line <str> , <str> = > <str> text_line <str> , <str> = > <str> record_line <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > Puppet :: Type . type ( <str> ) . keyline_regex , <str> = > proc { | h | h [ <str> ] = <str> if h [ <str> ] == <str> h [ <str> ] || = [ <str> ] h [ <str> ] = Puppet :: Type :: Ssh_authorized_key :: ProviderParsed . parse_options ( h [ <str> ] ) if h [ <str> ] . is_a? String } , <str> = > proc { | h | h [ <str> ] = <str> if h [ <str> ] h [ <str> ] = [ ] if h [ <str> ] . include? ( <str> ) h [ <str> ] = h [ <str> ] . join ( <str> ) } record_line <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> def dir_perm <oct> end def file_perm <oct> end def user uid = Puppet :: FileSystem . stat ( target ) . uid Etc . getpwuid ( uid ) . name end def flush raise Puppet :: Error , <str> unless @resource . should ( <str> ) raise Puppet :: Error , <str> @resource . should ( <str> ) <str> unless Puppet :: Util . uid ( @resource . should ( <str> ) ) self . class . backup_target ( target ) Puppet :: Util :: SUIDManager . asuser ( @resource . should ( <str> ) ) do unless Puppet :: FileSystem . exist? ( dir = File . dirname ( target ) ) Puppet . debug <str> dir <str> Dir . mkdir ( dir , dir_perm ) end super File . chmod ( file_perm , target ) end end def self . parse_options ( options ) result = [ ] scanner = StringScanner . new ( options ) while ! scanner . eos? scanner . skip ( <str> ) if out = scanner . scan ( <str> ) or out = scanner . scan ( <str> ) result << out else break end scanner . skip ( <str> ) end result end def self . prefetch_hook ( records ) name_index = <int> records . each do | record | if record [ <str> ] == <str> && record [ <str> ] . empty? record [ <str> ] = true record [ <str> ] = <str> record [ <str> ] <str> name_index += <int> <str> Puppet . debug ( <str> record [ <str> ] <str> record [ <str> ] <str> ) end end end end 
