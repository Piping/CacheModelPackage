require_relative <str> module DTrace class TestFunctionEntry < TestCase def test_function_entry probe = <<- <str> eoprobe <str> <str> eoprobe trap_probe ( probe , ruby_program ) { | d_file , rb_file , probes | foo_calls = probes . map { | line | line . split } . find_all { | row | row . first == <str> && row [ <int> ] == <str> } assert_equal <int> , foo_calls . length line = <str> foo_calls . each { | f | assert_equal line , f [ <int> ] } foo_calls . each { | f | assert_equal rb_file , f [ <int> ] } } end def test_function_return probe = <<- <str> eoprobe <str> <str> eoprobe trap_probe ( probe , ruby_program ) { | d_file , rb_file , probes | foo_calls = probes . map { | line | line . split } . find_all { | row | row . first == <str> && row [ <int> ] == <str> } assert_equal <int> , foo_calls . length line = <str> foo_calls . each { | f | assert_equal line , f [ <int> ] } foo_calls . each { | f | assert_equal rb_file , f [ <int> ] } } end def test_return_from_raise program = <<- <str> eoruby <str> <str> eoruby probe = <<- <str> eoprobe <str> <str> eoprobe trap_probe ( probe , program ) { | d_file , rb_file , probes | foo_calls = probes . map { | line | line . split } . find_all { | row | row . first == <str> && row [ <int> ] == <str> } assert foo_calls . any? } end private def ruby_program <<- <str> eoruby <str> <str> eoruby end end end if defined? ( DTrace :: TestCase ) 
