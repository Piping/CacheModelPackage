require <str> module Fog module Compute class Glesys class Server < Fog :: Compute :: Server extend Fog :: Deprecation identity <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> def ready? state == <str> end def start requires <str> service . start ( <str> = > identity ) end def stop requires <str> service . stop ( <str> = > identity ) end def reboot requires <str> service . reboot ( <str> = > identity ) end def destroy ( options = { } ) requires <str> service . destroy ( options . merge! ( { <str> = > identity } ) ) end def save if self . identity options = { <str> = > self . identity , <str> = > disksize , <str> = > memorysize , <str> = > cpucores , <str> = > hostname , <str> = > bandwidth } data = service . edit ( options ) else requires <str> , <str> options = { <str> = > datacenter || <str> , <str> = > platform || <str> , <str> = > hostname , <str> = > templatename || <str> , <str> = > disksize || <str> , <str> = > memorysize || <str> , <str> = > cpucores || <str> , <str> = > rootpassword } [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] . each do | k | options [ k ] = attributes [ k ] if attributes [ k ] end data = service . create ( options ) end merge_attributes ( data . body [ <str> ] [ <str> ] ) data . status == <int> ? true : false end def setup ( credentials = { } ) requires <str> , <str> attrs = attributes . dup attrs . delete ( <str> ) commands = [ <str> , <str> Fog :: JSON . encode ( Fog :: JSON . sanitize ( attrs ) ) <str> ] if public_key commands << <str> public_key <str> end if credentials [ <str> ] . nil? && ! rootpassword . nil? credentials [ <str> ] = rootpassword end wait_for { sshable? ( credentials ) } Fog :: SSH . new ( ssh_ip_address , username , credentials ) . run ( commands ) end def ssh ( command , options = { } , & block ) if options [ <str> ] . nil? && ! rootpassword . nil? options [ <str> ] = rootpassword end super ( command , options , & block ) end def ips Fog :: Compute :: Glesys :: Ips . new ( <str> = > identity , <str> = > self , <str> = > service ) . all end def ip ( ip ) Fog :: Compute :: Glesys :: Ips . new ( <str> = > identity , <str> = > self , <str> = > service ) . get ( ip ) end def public_ip_address ( options = { } ) return nil if iplist . nil? type = options [ <str> ] || nil ips = case type when <str> then iplist . select { | ip | ip [ <str> ] == <int> } when <str> then iplist . select { | ip | ip [ <str> ] == <int> } else iplist . sort_by { | ip | ip [ <str> ] } end if ips . empty? nil else ips . first [ <str> ] end end end end end end 
