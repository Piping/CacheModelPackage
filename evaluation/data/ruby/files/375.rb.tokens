require_dependency <str> class Search def self . per_facet <int> end def self . per_filter <int> end def self . burst_factor <int> end def self . facets <str> end def self . long_locale case SiteSetting . default_locale . to_sym when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> when <str> then <str> else <str> end end def self . rebuild_problem_posts ( limit = <int> ) posts = Post . joins ( <str> ) . where ( <str> , SiteSetting . default_locale ) . limit ( <int> ) posts . each do | post | post . cooked += <str> SearchObserver . index ( post ) end posts = Post . joins ( <str> ) . where ( <str> , SiteSetting . default_locale ) . limit ( <int> ) posts . each do | post | post . cooked += <str> SearchObserver . index ( post ) end nil end def self . prepare_data ( search_data ) data = search_data . squish if [ <str> , <str> , <str> , <str> ] . include? ( SiteSetting . default_locale ) || SiteSetting . search_tokenize_chinese_japanese_korean unless defined? RMMSeg require <str> RMMSeg :: Dictionary . load_dictionaries end algo = RMMSeg :: Algorithm . new ( search_data ) data = <str> while token = algo . next_token data << token . text << <str> end end data . force_encoding ( <str> ) data end def initialize ( term , opts = nil ) @opts = opts || { } @guardian = @opts [ <str> ] || Guardian . new @search_context = @opts [ <str> ] @include_blurbs = @opts [ <str> ] || false @blurb_length = @opts [ <str> ] @limit = Search . per_facet term = process_advanced_search! ( term ) if term . present? @term = Search . prepare_data ( term . to_s ) @original_term = PG :: Connection . escape_string ( @term ) end if @search_pms && @guardian . user @opts [ <str> ] = <str> @search_context = @guardian . user end if @opts [ <str> ] . present? @limit = Search . per_filter end @results = GroupedSearchResults . new ( @opts [ <str> ] , term , @search_context , @include_blurbs , @blurb_length ) end def self . execute ( term , opts = nil ) self . new ( term , opts ) . execute end def execute if @term . blank? || @term . length < ( @opts [ <str> ] || SiteSetting . min_search_term_length ) return nil unless @filters . present? end if @opts [ <str> ] && @results . type_filter == <str> if @term =~ <str> single_topic ( @term . to_i ) else begin route = Rails . application . routes . recognize_path ( @term ) single_topic ( route [ <str> ] ) if route [ <str> ] . present? rescue ActionController :: RoutingError end end end find_grouped_results unless @results . posts . present? @results end def self . advanced_filter ( trigger , & block ) ( @advanced_filters || = { } ) [ trigger ] = block end def self . advanced_filters @advanced_filters end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts , match | posts . where ( <str> , match . to_i ) end advanced_filter ( <str> ) do | posts | posts . where ( <str> ) end advanced_filter ( <str> ) do | posts , match | badge_id = Badge . where ( <str> , match , match . to_i ) . pluck ( <str> ) . first if badge_id posts . where ( <str> , badge_id ) else posts . where ( <str> ) end end advanced_filter ( <str> ) do | posts , match | if @guardian . user post_action_type = PostActionType . types [ <str> ] if match == <str> post_action_type = PostActionType . types [ <str> ] if match == <str> posts . where ( <str> @guardian . user . id <str> post_action_type <str> ) end end advanced_filter ( <str> ) do | posts | posts . where ( <str> @guardian . user . id <str> ) if @guardian . user end advanced_filter ( <str> ) do | posts , match | if @guardian . user level = TopicUser . notification_levels [ match . to_sym ] posts . where ( <str> @guardian . user . id <str> level <str> ) end end advanced_filter ( <str> ) do | posts , match | category_id = Category . where ( <str> , match , match . to_i ) . pluck ( <str> ) . first if category_id posts . where ( <str> , category_id ) else posts . where ( <str> ) end end advanced_filter ( <str> ) do | posts , match | group_id = Group . where ( <str> , match , match . to_i ) . pluck ( <str> ) . first if group_id posts . where ( <str> , group_id ) else posts . where ( <str> ) end end advanced_filter ( <str> ) do | posts , match | user_id = User . where ( <str> : false ) . where ( <str> , match . downcase , match . to_i ) . pluck ( <str> ) . first if user_id posts . where ( <str> user_id <str> ) else posts . where ( <str> ) end end advanced_filter ( <str> ) do | posts , match | n = match . to_i posts . where ( <str> , n . days . ago ) end advanced_filter ( <str> ) do | posts , match | n = match . to_i posts . where ( <str> , n . days . ago ) end private def process_advanced_search! ( term ) term . to_s . scan ( <str> ) . to_a . map do | ( word , _ ) | next if word . blank? found = false Search . advanced_filters . each do | matcher , block | cleaned = word . gsub ( <str> , <str> ) if cleaned =~ matcher ( @filters || = [ ] ) << [ block , $1 ] found = true end end if word == <str> @order = <str> nil elsif word =~ <str> topic_id = $1 . to_i if topic_id > <int> topic = Topic . find_by ( id : topic_id ) if @guardian . can_see? ( topic ) @search_context = topic end end nil elsif word == <str> @order = <str> nil elsif word == <str> @order = <str> nil elsif word == <str> @search_pms = true nil else found ? nil : word end end . compact . join ( <str> ) end def find_grouped_results if @results . type_filter . present? raise Discourse :: InvalidAccess . new ( <str> ) unless Search . facets . include? ( @results . type_filter ) send ( <str> @results . type_filter <str> ) else @limit = Search . per_facet + <int> unless @search_context user_search if @term . present? category_search if @term . present? end topic_search end add_more_topics_if_expected @results rescue ActiveRecord :: StatementInvalid end def add_more_topics_if_expected expected_topics = <int> expected_topics = Search . facets . size unless @results . type_filter . present? expected_topics = Search . per_facet * Search . facets . size if @results . type_filter == <str> expected_topics -= @results . posts . length if expected_topics > <int> extra_posts = posts_query ( expected_topics * Search . burst_factor ) extra_posts = extra_posts . where ( <str> , @results . posts . map ( & <str> ) ) if @results . posts . present? extra_posts . each do | post | @results . add ( post ) expected_topics -= <int> break if expected_topics == <int> end end end def single_topic ( id ) post = Post . find_by ( <str> : id , <str> : <int> ) return nil unless @guardian . can_see? ( post ) @results . add ( post ) @results end def secure_category_ids return @secure_category_ids unless @secure_category_ids . nil? @secure_category_ids = @guardian . secure_category_ids end def category_search secure_category_ids categories = Category . includes ( <str> ) . where ( <str> ts_query <str> ) . references ( <str> ) . order ( <str> ) . secured ( @guardian ) . limit ( @limit ) categories . each do | category | @results . add ( category ) end end def user_search return if SiteSetting . hide_user_profiles_from_public && ! @guardian . user users = User . includes ( <str> ) . references ( <str> ) . where ( <str> : true ) . where ( <str> : false ) . where ( <str> ts_query ( <str> ) <str> ) . order ( <str> @original_term . downcase <str> ) . order ( <str> ) . limit ( @limit ) users . each do | user | @results . add ( user ) end end def posts_query ( limit , opts = nil ) opts || = { } posts = Post . where ( <str> : Topic . visible_post_types ( @guardian . user ) ) . joins ( <str> , <str> ) . joins ( <str> ) . where ( <str> = > nil ) . where ( <str> ) is_topic_search = @search_context . present? && @search_context . is_a? ( Topic ) if opts [ <str> ] || ( is_topic_search && @search_context . private_message? ) posts = posts . where ( <str> , Archetype . private_message ) unless @guardian . is_admin? posts = posts . where ( <str> , @guardian . user . id ) end else posts = posts . where ( <str> , Archetype . private_message ) end if @term . present? if is_topic_search posts = posts . joins ( <str> ) posts = posts . where ( <str> , <str> @term <str> ) else posts = posts . where ( <str> ts_query <str> ) exact_terms = @term . scan ( <str> ) . flatten exact_terms . each do | exact | posts = posts . where ( <str> , <str> exact <str> ) end end end @filters . each do | block , match | if block . arity == <int> posts = instance_exec ( posts , & block ) || posts else posts = instance_exec ( posts , match , & block ) || posts end end if @filters if @search_context . present? if @search_context . is_a? ( User ) if opts [ <str> ] posts = posts . where ( <str> , <str> : @search_context . id ) else posts = posts . where ( <str> @search_context . id <str> ) end elsif @search_context . is_a? ( Category ) posts = posts . where ( <str> @search_context . id <str> ) elsif @search_context . is_a? ( Topic ) posts = posts . where ( <str> @search_context . id <str> ) . order ( <str> ) end end if @order == <str> || ( @term . blank? && ! @order ) if opts [ <str> ] posts = posts . order ( <str> ) else posts = posts . order ( <str> ) end elsif @order == <str> if opts [ <str> ] posts = posts . order ( <str> ) else posts = posts . order ( <str> ) end elsif @order == <str> if opts [ <str> ] posts = posts . order ( <str> ) else posts = posts . order ( <str> ) end else posts = posts . order ( <str> query_locale <str> ts_query <str> ) data_ranking = <str> ts_query <str> if opts [ <str> ] posts = posts . order ( <str> data_ranking <str> ) else posts = posts . order ( <str> data_ranking <str> ) end posts = posts . order ( <str> ) end if secure_category_ids . present? posts = posts . where ( <str> , secure_category_ids ) . references ( <str> ) else posts = posts . where ( <str> ) . references ( <str> ) end posts . limit ( limit ) end def self . query_locale @query_locale || = Post . sanitize ( Search . long_locale ) end def query_locale self . class . query_locale end def self . ts_query ( term , locale = nil , joiner = <str> ) data = Post . exec_sql ( <str> , <str> : locale || long_locale , <str> : term ) . values [ <int> ] [ <int> ] locale = Post . sanitize ( locale ) if locale all_terms = data . scan ( <str> ) . flatten all_terms . map! do | t | t . split ( <str> ) [ <int> ] end . compact! query = Post . sanitize ( all_terms . map { | t | <str> PG :: Connection . escape_string ( t ) <str> } . join ( <str> joiner <str> ) ) <str> locale || query_locale <str> query <str> end def ts_query ( locale = nil ) @ts_query_cache || = { } @ts_query_cache [ ( locale || query_locale ) + <str> + @term ] || = Search . ts_query ( @term , locale ) end def aggregate_search ( opts = { } ) min_or_max = @order == <str> ? <str> : <str> post_sql = if @order == <str> posts_query ( @limit , <str> : opts [ <str> ] ) . select ( <str> , <str> ) . to_sql else posts_query ( @limit , <str> : true , <str> : opts [ <str> ] ) . select ( <str> , <str> min_or_max <str> ) . group ( <str> ) . to_sql end post_sql = <str> post_sql <str> posts = Post . includes ( <str> = > <str> ) . joins ( <str> post_sql <str> ) . order ( <str> ) posts . each do | post | @results . add ( post ) end end def private_messages_search raise Discourse :: InvalidAccess . new ( <str> ) unless @guardian . user aggregate_search ( <str> : true ) end def topic_search if @search_context . is_a? ( Topic ) posts = posts_query ( @limit ) . where ( <str> , @search_context . id ) . includes ( <str> = > <str> ) posts . each do | post | @results . add ( post ) end else aggregate_search end end end 
