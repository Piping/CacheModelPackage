require <str> require <str> class TestBenchmark < Test :: Unit :: TestCase BENCH_FOR_TIMES_UPTO = lambda do | x | n = <int> tf = x . report ( <str> ) { for _ in <int> .. n ; <str> ; end } tt = x . report ( <str> ) { n . times do ; <str> ; end } tu = x . report ( <str> ) { <int> . upto ( n ) do ; <str> ; end } [ tf + tt + tu , ( tf + tt + tu ) / <int> ] end BENCH_FOR_TIMES_UPTO_NO_LABEL = lambda do | x | n = <int> x . report { for _ in <int> .. n ; <str> ; end } x . report { n . times do ; <str> ; end } x . report { <int> . upto ( n ) do ; <str> ; end } end def labels <str> end def bench ( type = <str> , * args , & block ) if block Benchmark . send ( type , * args , & block ) else Benchmark . send ( type , * args ) do | x | labels . each { | label | x . report ( label ) { } } end end end def capture_output capture_io { yield } . first . gsub ( <str> , <str> ) end def capture_bench_output ( type , * args , & block ) capture_output { bench ( type , * args , & block ) } end def test_tms_outputs_nicely assert_equal ( <str> , Benchmark :: Tms . new . to_s ) assert_equal ( <str> , Benchmark :: Tms . new ( <int> , <int> , <int> , <int> , <int> ) . to_s ) assert_equal ( <str> , Benchmark :: Tms . new ( <int> , <int> , <int> , <int> , <int> , <str> ) . format ( <str> ) ) assert_equal ( <str> , Benchmark :: Tms . new ( <int> ) . format ( <str> , <int> ) ) assert_equal ( <str> , Benchmark :: Tms . new ( <int> , <int> , <int> , <int> , <int> ) . to_s ) end def test_tms_wont_modify_the_format_String_given format = <str> Benchmark :: Tms . new . format ( format ) assert_equal ( <str> , format ) end BENCHMARK_OUTPUT_WITH_TOTAL_AVG = << <str> BENCH <str> <str> BENCH def test_benchmark_does_not_print_any_space_if_the_given_caption_is_empty assert_equal ( <<- <str> BENCH <str> , capture_bench_output ( <str> ) ) <str> BENCH end def test_benchmark_makes_extra_calcultations_with_an_Array_at_the_end_of_the_benchmark_and_show_the_result assert_equal ( BENCHMARK_OUTPUT_WITH_TOTAL_AVG , capture_bench_output ( <str> , Benchmark :: CAPTION , <int> , Benchmark :: FORMAT , <str> , <str> , & BENCH_FOR_TIMES_UPTO ) ) end def test_bm_returns_an_Array_of_the_times_with_the_labels [ <str> , <str> ] . each do | meth | capture_io do results = bench ( meth ) assert_instance_of ( Array , results ) assert_equal ( labels . size , results . size ) results . zip ( labels ) . each { | tms , label | assert_instance_of ( Benchmark :: Tms , tms ) assert_equal ( label , tms . label ) } end end end def test_bm_correctly_output_when_the_label_width_is_given assert_equal ( <<- <str> BENCH <str> , capture_bench_output ( <str> , <int> ) ) <str> BENCH end def test_bm_correctly_output_when_no_label_is_given assert_equal ( <<- <str> BENCH <str> , capture_bench_output ( <str> , & BENCH_FOR_TIMES_UPTO_NO_LABEL ) ) <str> BENCH end def test_bm_can_make_extra_calcultations_with_an_array_at_the_end_of_the_benchmark assert_equal ( BENCHMARK_OUTPUT_WITH_TOTAL_AVG , capture_bench_output ( <str> , <int> , <str> , <str> , & BENCH_FOR_TIMES_UPTO ) ) end BMBM_OUTPUT = << <str> BENCH <str> <str> BENCH def test_bmbm_correctly_guess_the_label_width_even_when_not_given assert_equal ( BMBM_OUTPUT , capture_bench_output ( <str> ) ) end def test_bmbm_correctly_output_when_the_label_width_is_given__bmbm_ignore_it__but_it_is_a_frequent_mistake assert_equal ( BMBM_OUTPUT , capture_bench_output ( <str> , <int> ) ) end def test_report_item_shows_the_title__even_if_not_a_string assert_operator ( capture_bench_output ( <str> ) { | x | x . report ( <str> ) { } } , <str> , <str> ) assert_operator ( capture_bench_output ( <str> ) { | x | x . report ( <str> ) { } } , <str> , <str> ) end def test_bugs_ruby_dev_40906_can_add_in_place_the_time_of_execution_of_the_block_given t = Benchmark :: Tms . new assert_equal ( <int> , t . real ) t . add! { sleep <int> . <int> } assert_not_equal ( <int> , t . real ) end def test_realtime_output sleeptime = <int> . <int> realtime = Benchmark . realtime { sleep sleeptime } assert_operator sleeptime , <str> , realtime end end 
