module Msf::DBManager::ExploitAttempt def report_exploit ( opts = { } ) wlog ( <str> + <str> opts . inspect <str> + <str> caller . join ( <str> ) <str> ) end def report_exploit_attempt ( host , opts ) :: ActiveRecord :: Base . connection_pool . with_connection { return if not host info = { } :: Mdm :: VulnAttempt . column_names . each do | kn | k = kn . to_sym next if [ <str> , <str> ] . include? ( kn ) info [ k ] = opts [ kn ] if opts [ kn ] info [ k ] = opts [ k ] if opts [ k ] end host . exploit_attempts . create ( info ) } end def report_exploit_failure ( opts ) return unless opts . has_key? ( <str> ) && ! opts [ <str> ] . blank? host = opts [ <str> ] || return wspace = opts [ <str> ] || workspace port = opts [ <str> ] prot = opts [ <str> ] || Msf :: DBManager :: DEFAULT_SERVICE_PROTO svc = opts [ <str> ] if port and svc . nil? svc = get_service ( wspace , host , prot , port ) end if ! host || ! host . kind_of? ( :: Mdm :: Host ) if svc . kind_of? :: Mdm :: Service host = svc . host else host = get_host ( <str> : wspace , <str> : host ) end end return if not host opts = opts . dup opts [ <str> ] = svc opts [ <str> ] = host do_report_failure_or_success ( opts ) end def report_exploit_success ( opts ) return unless opts [ <str> ] host = opts [ <str> ] || return wspace = opts [ <str> ] || workspace port = opts [ <str> ] prot = opts [ <str> ] || Msf :: DBManager :: DEFAULT_SERVICE_PROTO svc = opts [ <str> ] if port and svc . nil? opts = opts . dup opts [ <str> ] || = Msf :: DBManager :: DEFAULT_SERVICE_PROTO opts [ <str> ] = report_service ( <str> : wspace , <str> : host , <str> : port , <str> : prot ) end do_report_failure_or_success ( opts ) end private def do_report_failure_or_success ( opts ) return unless opts [ <str> ] :: ActiveRecord :: Base . connection_pool . with_connection { mrefs = opts [ <str> ] host = opts [ <str> ] port = opts [ <str> ] prot = opts [ <str> ] svc = opts [ <str> ] vuln = opts [ <str> ] timestamp = opts [ <str> ] freason = opts [ <str> ] fdetail = opts [ <str> ] username = opts [ <str> ] mname = opts [ <str> ] if vuln . nil? ref_names = mrefs . map { | ref | if ref . respond_to? ( <str> ) and ref . respond_to? ( <str> ) <str> ref . ctx_id <str> ref . ctx_val <str> else ref . to_s end } ref_objs = :: Mdm :: Ref . where ( name : ref_names ) vuln = find_vuln_by_refs ( ref_objs , host , svc ) end attempt_info = { <str> = > timestamp || Time . now . utc , <str> = > ( freason . nil? ? true : false ) , <str> = > fdetail , <str> = > freason , <str> = > mname , <str> = > username || <str> , } attempt_info [ <str> ] = opts [ <str> ] if opts [ <str> ] attempt_info [ <str> ] = opts [ <str> ] if opts [ <str> ] if vuln attempt_info [ <str> ] = vuln . id vuln . vuln_attempts . create ( attempt_info ) create_match_result_for_vuln ( vuln , opts ) if svc and vuln . service_id . nil? vuln . service = svc vuln . save end end if svc attempt_info [ <str> ] = svc . port attempt_info [ <str> ] = svc . proto end if port and svc . nil? attempt_info [ <str> ] = port attempt_info [ <str> ] = prot || Msf :: DBManager :: DEFAULT_SERVICE_PROTO end host . exploit_attempts . create ( attempt_info ) } end def create_match_result_for_vuln ( vuln , opts ) run = MetasploitDataModels :: AutomaticExploitation :: Run . where ( id <str> [ <str> ] ) . last if run . present? match = MetasploitDataModels :: AutomaticExploitation :: Match . by_run_and_vuln ( run , vuln ) . last unless match . present? match = create_match_for_vuln ( vuln , opts . merge ( <str> : run ) ) end create_match_result ( opts . merge ( <str> : match , <str> : run ) ) if match . present? end end def create_match_result ( opts ) if opts [ <str> ] state = MetasploitDataModels :: AutomaticExploitation :: MatchResult :: SUCCEEDED else state = MetasploitDataModels :: AutomaticExploitation :: MatchResult :: FAILED end MetasploitDataModels :: AutomaticExploitation :: MatchResult . create! ( <str> : opts [ <str> ] , <str> : opts [ <str> ] , <str> : state ) end def create_match_for_vuln ( vuln , opts ) wspace = opts [ <str> ] || workspace run = opts [ <str> ] module_fullname = opts [ <str> ] run . match_set . create_match_for_vuln ( vuln , <str> : wspace , <str> : module_fullname ) end end 
