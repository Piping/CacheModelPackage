require <str> require <str> module Puppet require <str> require <str> class ExecutionFailure < Puppet :: Error end end module Puppet::Util::Execution class ProcessOutput < String attr_reader <str> def initialize ( value , exitstatus ) super ( value ) @exitstatus = exitstatus end end def self . execpipe ( command , failonfail = true ) command_str = command . respond_to? ( <str> ) ? command . join ( <str> ) : command if respond_to? <str> debug <str> command_str <str> else Puppet . debug <str> command_str <str> end english_env = ENV . to_hash . merge ( { <str> = > <str> , <str> = > <str> } ) output = Puppet :: Util . withenv ( english_env ) do open ( <str> command_str <str> ) do | pipe | yield pipe end end if failonfail && exitstatus != <int> raise Puppet :: ExecutionFailure , output end output end def self . exitstatus $CHILD_STATUS . exitstatus end private_class_method <str> def self . execfail ( command , exception ) output = execute ( command ) return output rescue Puppet :: ExecutionFailure raise exception , output , exception . backtrace end NoOptionsSpecified = { } def self . execute ( command , options = NoOptionsSpecified ) default_options = { <str> = > NoOptionsSpecified . equal? ( options ) , <str> = > nil , <str> = > nil , <str> = > NoOptionsSpecified . equal? ( options ) , <str> = > nil , <str> = > false , <str> = > true , <str> = > { } , } options = default_options . merge ( options ) if command . is_a? ( Array ) command = command . flatten . map ( & <str> ) str = command . join ( <str> ) elsif command . is_a? ( String ) str = command end user_log_s = <str> if options [ <str> ] user_log_s << <str> options [ <str> ] <str> end if options [ <str> ] user_log_s << <str> options [ <str> ] <str> end if user_log_s != <str> user_log_s . prepend ( <str> ) end if respond_to? <str> debug <str> user_log_s <str> str <str> else Puppet . debug <str> user_log_s <str> str <str> end null_file = Puppet . features . microsoft_windows? ? <str> : <str> begin stdin = File . open ( options [ <str> ] || null_file , <str> ) stdout = options [ <str> ] ? File . open ( null_file , <str> ) : Puppet :: FileSystem :: Uniquefile . new ( <str> ) stderr = options [ <str> ] ? stdout : File . open ( null_file , <str> ) exec_args = [ command , options , stdin , stdout , stderr ] if execution_stub = Puppet :: Util :: ExecutionStub . current_value return execution_stub . call ( * exec_args ) elsif Puppet . features . posix? child_pid = nil begin child_pid = execute_posix ( * exec_args ) exit_status = Process . waitpid2 ( child_pid ) . last . exitstatus child_pid = nil rescue Timeout :: Error = > e unless child_pid . nil? Process . kill ( <str> , child_pid ) Thread . new { Process . waitpid ( child_pid ) } end raise e end elsif Puppet . features . microsoft_windows? process_info = execute_windows ( * exec_args ) begin exit_status = Puppet :: Util :: Windows :: Process . wait_process ( process_info . process_handle ) ensure FFI :: WIN32 . CloseHandle ( process_info . process_handle ) FFI :: WIN32 . CloseHandle ( process_info . thread_handle ) end end [ stdin , stdout , stderr ] . each { | io | io . close rescue nil } unless options [ <str> ] output = wait_for_output ( stdout ) Puppet . warning <str> unless output end if options [ <str> ] and exit_status != <int> raise Puppet :: ExecutionFailure , <str> str <str> exit_status <str> output . strip <str> end ensure if ! options [ <str> ] && stdout stdout . close! end end Puppet :: Util :: Execution :: ProcessOutput . new ( output || <str> , exit_status ) end def self . ruby_path ( ) File . join ( RbConfig :: CONFIG [ <str> ] , RbConfig :: CONFIG [ <str> ] + RbConfig :: CONFIG [ <str> ] ) . sub ( <str> , <str> ) end class << self alias util_execute execute end def self . execute_posix ( command , options , stdin , stdout , stderr ) child_pid = Puppet :: Util . safe_posix_fork ( stdin , stdout , stderr ) do command = [ command ] . flatten Process . setsid begin Puppet :: Util :: SUIDManager . change_privileges ( options [ <str> ] , options [ <str> ] , true ) if ( options [ <str> ] ) then Puppet :: Util :: POSIX :: LOCALE_ENV_VARS . each { | name | ENV . delete ( name ) } ENV [ <str> ] = <str> ENV [ <str> ] = <str> end Puppet :: Util :: POSIX :: USER_ENV_VARS . each { | name | ENV . delete ( name ) } options [ <str> ] || = { } Puppet :: Util . withenv ( options [ <str> ] ) do Kernel . exec ( * command ) end rescue = > detail Puppet . log_exception ( detail , <str> detail <str> ) exit! ( <int> ) end end child_pid end private_class_method <str> def self . execute_windows ( command , options , stdin , stdout , stderr ) command = command . map do | part | part . include? ( <str> ) ? <str> part . gsub ( <str> , <str> ) <str> : part end . join ( <str> ) if command . is_a? ( Array ) options [ <str> ] || = { } Puppet :: Util . withenv ( options [ <str> ] , <str> ) do Puppet :: Util :: Windows :: Process . execute ( command , options , stdin , stdout , stderr ) end end private_class_method <str> def self . wait_for_output ( stdout ) <int> . times do | try | if Puppet :: FileSystem . exist? ( stdout . path ) stdout . open begin return stdout . read ensure stdout . close stdout . unlink end else time_to_sleep = try / <int> . <int> Puppet . warning <str> time_to_sleep <str> sleep ( time_to_sleep ) end end nil end private_class_method <str> end 
