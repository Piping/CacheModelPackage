require <str> require <str> require <str> require <str> require <str> require <str> module Homebrew def update_ruby unless ARGV . named . empty? abort <<- <str> EOS <str> . undent <str> EOS end checks = Diagnostic :: Checks . new <str> . each do | check | out = checks . send ( check ) odie out unless out . nil? end Utils . ensure_git_installed! ENV . delete ( <str> ) cd HOMEBREW_REPOSITORY git_init_if_necessary migrate_taps report = Report . new master_updater = Updater . new ( HOMEBREW_REPOSITORY ) master_updater . pull! master_updated = master_updater . updated? if master_updated initial_short = shorten_revision ( master_updater . initial_revision ) current_short = shorten_revision ( master_updater . current_revision ) puts <str> initial_short <str> current_short <str> end report . update ( master_updater . report ) rename_taps_dir_if_necessary updated_taps = [ ] Tap . each do | tap | next unless tap . git? tap . path . cd do updater = Updater . new ( tap . path ) begin updater . pull! rescue onoe <str> tap <str> else updated_taps << tap . name if updater . updated? report . update ( updater . report ) do | _key , oldval , newval | oldval . concat ( newval ) end end end end unless updated_taps . empty? puts <str> updated_taps . size <str> plural ( updated_taps . size ) <str> \ <str> updated_taps . join ( <str> ) <str> end puts <str> unless master_updated || ! updated_taps . empty? Tap . clear_cache Tap . each ( & <str> ) report . select_formula ( <str> ) . each do | f | next unless ( dir = HOMEBREW_CELLAR / f ) . exist? migration = TAP_MIGRATIONS [ f ] next unless migration tap = Tap . fetch ( * migration . split ( <str> ) ) tap . install unless tap . installed? tabs = dir . subdirs . map { | d | Tab . for_keg ( Keg . new ( d ) ) } next if tabs . first . source [ <str> ] != <str> tabs . each { | tab | tab . source [ <str> ] = <str> tap . user <str> tap . repo <str> } tabs . each ( & <str> ) end if load_tap_migrations load_formula_renames report . update_renamed report . select_formula ( <str> ) . each do | oldname , newname | if oldname . include? ( <str> ) user , repo , oldname = oldname . split ( <str> , <int> ) newname = newname . split ( <str> , <int> ) . last else user = <str> repo = <str> end next unless ( dir = HOMEBREW_CELLAR / oldname ) . directory? && ! dir . subdirs . empty? begin f = Formulary . factory ( <str> user <str> repo <str> newname <str> ) rescue Exception end next unless f begin migrator = Migrator . new ( f ) migrator . migrate rescue Migrator :: MigratorDifferentTapsError end end if report . empty? puts <str> if master_updated || ! updated_taps . empty? else report . dump end Descriptions . update_cache ( report ) end private def shorten_revision ( revision ) <str> revision <str> . chomp end def git_init_if_necessary if Dir [ <str> ] . empty? safe_system <str> , <str> safe_system <str> , <str> , <str> , <str> safe_system <str> , <str> , <str> , <str> safe_system <str> , <str> , <str> , <str> safe_system <str> , <str> , <str> safe_system <str> , <str> , <str> , <str> end if <str> =~ <str> safe_system <str> , <str> , <str> , <str> , <str> safe_system <str> , <str> , <str> , <str> , <str> , <str> end rescue Exception FileUtils . rm_rf <str> raise end def rename_taps_dir_if_necessary Dir . glob ( <str> HOMEBREW_LIBRARY <str> ) do | tapd | begin if File . directory? ( tapd + <str> ) tapd_basename = File . basename ( tapd ) if tapd_basename . include? ( <str> ) user , repo = tapd_basename . reverse . sub ( <str> , <str> ) . reverse . split ( <str> ) FileUtils . mkdir_p ( <str> HOMEBREW_LIBRARY <str> user . downcase <str> ) FileUtils . mv ( tapd , <str> HOMEBREW_LIBRARY <str> user . downcase <str> repo . downcase <str> ) if tapd_basename . count ( <str> ) > = <int> opoo <str> \ + <str> HOMEBREW_LIBRARY <str> user . downcase <str> repo . downcase <str> end else opoo <str> \ <str> tapd <str> end end rescue = > ex onoe ex . message next end end end def load_tap_migrations load <str> rescue LoadError false end def load_formula_renames load <str> rescue LoadError false end end class Updater attr_reader <str> , <str> , <str> def initialize ( repository ) @repository = repository @stashed = false @quiet_args = [ ] @quiet_args << <str> unless ARGV . verbose? end def pull! ( options = { } ) begin @upstream_branch = <str> @upstream_branch = @upstream_branch . chomp . sub ( <str> , <str> ) rescue ErrorDuringExecution @upstream_branch = <str> end begin @initial_branch = <str> . chomp rescue ErrorDuringExecution @initial_branch = <str> end unless <str> . chomp . empty? if ARGV . verbose? puts <str> repository <str> system <str> , <str> , <str> , <str> end safe_system <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , * @quiet_args safe_system <str> , <str> , <str> , * @quiet_args @stashed = true end if ARGV . include? ( <str> ) @initial_revision = <str> @upstream_branch <str> . chomp @current_revision = read_current_revision begin safe_system <str> , <str> , <str> , @initial_revision , @current_revision rescue ErrorDuringExecution odie <str> @upstream_branch <str> end return end if @initial_branch != @upstream_branch && ! @initial_branch . empty? if system ( <str> , <str> , <str> , @upstream_branch , <str> @upstream_branch <str> ) safe_system <str> , <str> , <str> , @upstream_branch , * @quiet_args else safe_system <str> , <str> , <str> , <str> , @upstream_branch , <str> @upstream_branch <str> , * @quiet_args end end @initial_revision = read_current_revision safe_system <str> , <str> , <str> , <str> args = [ <str> ] args << <str> args << ( ( ARGV . include? <str> ) ? <str> : <str> ) args += @quiet_args args << <str> args << <str> @upstream_branch <str> @upstream_branch <str> reset_on_interrupt { safe_system <str> , * args } @current_revision = read_current_revision pop_stash_message end def pop_stash return unless @stashed safe_system <str> , <str> , <str> , * @quiet_args if ARGV . verbose? puts <str> repository <str> system <str> , <str> , <str> , <str> end @stashed = false end def pop_stash_message return unless @stashed puts <str> repository <str> puts <str> repository <str> @stashed = false end def reset_on_interrupt ignore_interrupts { yield } ensure if $? . signaled? && $? . termsig == <int> safe_system <str> , <str> , @initial_branch unless @initial_branch . empty? safe_system <str> , <str> , <str> , @initial_revision , * @quiet_args if @initial_branch pop_stash else pop_stash_message end end end def report map = Hash . new { | h , k | h [ k ] = [ ] } if initial_revision && initial_revision != current_revision wc_revision = read_current_revision diff . each_line do | line | status , * paths = line . split src = paths . first dst = paths . last next unless File . extname ( dst ) == <str> next unless paths . any? { | p | File . dirname ( p ) == formula_directory } case status when <str> , <str> map [ status . to_sym ] << repository . join ( src ) when <str> file = repository . join ( src ) begin formula = Formulary . factory ( file ) new_version = if wc_revision == current_revision formula . pkg_version else FormulaVersions . new ( formula ) . formula_at_revision ( @current_revision , & <str> ) end old_version = FormulaVersions . new ( formula ) . formula_at_revision ( @initial_revision , & <str> ) next if new_version == old_version rescue Exception = > e onoe e if ARGV . homebrew_developer? end map [ <str> ] << file when <str> map [ <str> ] << repository . join ( src ) if File . dirname ( src ) == formula_directory map [ <str> ] << repository . join ( dst ) if File . dirname ( dst ) == formula_directory end end end map end def updated? initial_revision && initial_revision != current_revision end private def formula_directory if repository == HOMEBREW_REPOSITORY <str> elsif repository . join ( <str> ) . directory? <str> elsif repository . join ( <str> ) . directory? <str> else <str> end end def read_current_revision <str> . chomp end def diff Utils . popen_read ( <str> , <str> , <str> , <str> , <str> , <str> , initial_revision , current_revision ) end def ` ( cmd ) out = super unless $? . success? $stderr . puts ( out ) unless out . empty? raise ErrorDuringExecution . new ( cmd ) end ohai ( cmd , out ) if ARGV . verbose? out end end class Report def initialize @hash = { } end def fetch ( * args , & block ) @hash . fetch ( * args , & block ) end def update ( * args , & block ) @hash . update ( * args , & block ) end def empty? @hash . empty? end def dump dump_formula_report <str> , <str> dump_formula_report <str> , <str> dump_formula_report <str> , <str> dump_formula_report <str> , <str> end def update_renamed renamed_formulae = [ ] fetch ( <str> , [ ] ) . each do | path | case path . to_s when HOMEBREW_TAP_PATH_REGEX oldname = path . basename ( <str> ) . to_s next unless newname = Tap . fetch ( $1 , $2 ) . formula_renames [ oldname ] else oldname = path . basename ( <str> ) . to_s next unless newname = CoreFormulaRepository . instance . formula_renames [ oldname ] end if fetch ( <str> , [ ] ) . include? ( newpath = path . dirname . join ( <str> newname <str> ) ) renamed_formulae << [ path , newpath ] end end unless renamed_formulae . empty? @hash [ <str> ] -= renamed_formulae . map ( & <str> ) if @hash [ <str> ] @hash [ <str> ] -= renamed_formulae . map ( & <str> ) if @hash [ <str> ] @hash [ <str> ] = renamed_formulae end end def select_formula ( key ) fetch ( key , [ ] ) . map do | path , newpath | if path . to_s =~ HOMEBREW_TAP_PATH_REGEX tap = Tap . fetch ( $1 , $2 ) if newpath [ <str> tap <str> path . basename ( <str> ) <str> , <str> tap <str> newpath . basename ( <str> ) <str> ] else <str> tap <str> path . basename ( <str> ) <str> end elsif newpath [ <str> path . basename ( <str> ) <str> , <str> newpath . basename ( <str> ) <str> ] else path . basename ( <str> ) . to_s end end . sort end def dump_formula_report ( key , title ) formula = select_formula ( key ) . map do | name , new_name | if key == <str> new_name = pretty_installed ( new_name ) if installed? ( name ) <str> name <str> new_name <str> else installed? ( name ) ? pretty_installed ( name ) : name end end unless formula . empty? ohai title puts_columns ( formula ) end end def installed? ( formula ) ( HOMEBREW_CELLAR / formula . split ( <str> ) . last ) . directory? end end 
