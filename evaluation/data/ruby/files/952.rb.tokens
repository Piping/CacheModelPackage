require <str> class TestSymbol < Test :: Unit :: TestCase def assert_eval_inspected ( sym , valid = true ) n = sym . inspect if valid bug5136 = <str> assert_not_match ( <str> , n , bug5136 ) end assert_nothing_raised ( SyntaxError ) { assert_equal ( sym , eval ( n ) ) } end def test_intern assert_equal ( <str> , <str> . intern . inspect ) assert_equal ( <str> , <str> . intern . inspect ) assert_equal ( <str> , <str> . intern . inspect ) assert_equal ( <str> , <str> . intern . inspect ) end def test_all_symbols x = Symbol . all_symbols assert_kind_of ( Array , x ) assert_empty ( x . reject { | s | s . is_a? ( Symbol ) } ) end def test_inspect_invalid assert_eval_inspected ( <str> ) assert_eval_inspected ( <str> , false ) assert_eval_inspected ( <str> , false ) assert_eval_inspected ( <str> ) assert_eval_inspected ( <str> , false ) assert_eval_inspected ( <str> , false ) assert_eval_inspected ( <str> , false ) assert_eval_inspected ( <str> , false ) end def assert_inspect_evaled ( n ) assert_nothing_raised ( SyntaxError ) { assert_equal ( n , eval ( n ) . inspect ) } end def test_inspect_suboptimal assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_raise ( SyntaxError ) { eval <str> } assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_raise ( SyntaxError ) { eval <str> } assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } end def test_inspect_dollar assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } assert_raise ( SyntaxError ) { eval <str> } end def test_inspect_number assert_inspect_evaled ( <str> ) assert_inspect_evaled ( <str> ) end def test_inspect valid = <str> valid . each do | sym | assert_equal ( <str> + sym , sym . intern . inspect ) end invalid = <str> invalid . each do | sym | assert_equal ( <str> + sym + <str> , sym . intern . inspect ) end end def test_to_proc assert_equal <str> , ( <int> .. <int> ) . map ( & <str> ) [ [ ] , [ <int> ] , [ <int> , <int> ] , [ <int> , [ <int> , <int> ] ] , ] . each do | ary | ary_id = ary . object_id assert_equal ary_id , <str> . to_proc . call ( ary ) ary_ids = ary . collect { | x | x . object_id } assert_equal ary_ids , ary . collect ( & <str> ) end end def test_to_proc_yield assert_ruby_status ( [ ] , << - <str> , <str> : <int> . <int> ) GC . stress = true true . tap ( & <str> ) end ; end def test_to_proc_new_proc assert_ruby_status ( [ ] , << - <str> , <str> : <int> . <int> ) GC . stress = true <int> . times { Proc . new ( & <str> ) } end ; end def test_to_proc_no_method assert_separately ( [ ] , << - <str> , <str> : <int> . <int> ) bug11566 = <str> assert_raise ( NoMethodError , bug11566 ) { Proc . new ( & <str> ) . ( <int> ) } assert_raise ( NoMethodError , bug11566 ) { <str> . to_proc . ( <int> ) } end ; end def test_to_proc_arg assert_separately ( [ ] , << - <str> , <str> : <int> . <int> ) def ( obj = Object . new ) . proc ( & b ) b ; end assert_same ( <str> . to_proc , obj . proc ( & <str> ) ) end ; end def test_to_proc_call_with_symbol_proc first = <int> bug11594 = <str> - > ( & blk ) { } . call ( & <str> ) assert_equal ( <int> , first , bug11594 ) end def test_to_proc_for_hash_each bug11830 = <str> assert_normal_exit ( << - <str> , bug11830 ) { } . each ( & <str> ) end ; end def test_to_proc_iseq assert_separately ( [ ] , << ~ <str> , <str> : <int> ) bug11845 = <str> assert_nil ( <str> . to_proc . source_location , bug11845 ) assert_equal ( [ [ <str> ] ] , <str> . to_proc . parameters , bug11845 ) c = Class . new { define_method ( <str> , <str> . to_proc ) } m = c . instance_method ( <str> ) assert_nil ( m . source_location , bug11845 ) assert_equal ( [ [ <str> ] ] , m . parameters , bug11845 ) end ; end def test_call o = Object . new def o . foo ( x , y ) ; x + y ; end assert_equal ( <int> , <str> . to_proc . call ( o , <int> , <int> ) ) assert_raise ( ArgumentError ) { <str> . to_proc . call } end def m_block_given? block_given? end def m2_block_given? ( m = nil ) if m [ block_given? , m . call ( self ) ] else block_given? end end def test_block_given_to_proc bug8531 = <str> m = <str> . to_proc assert ( ! m . call ( self ) , <str> bug8531 <str> ) assert ( m . call ( self ) { } , <str> bug8531 <str> ) assert ( ! m . call ( self ) , <str> bug8531 <str> ) end def test_block_persist_between_calls bug8531 = <str> m2 = <str> . to_proc assert_equal ( [ true , false ] , m2 . call ( self , m2 ) { } , <str> bug8531 <str> ) assert_equal ( [ false , false ] , m2 . call ( self , m2 ) , <str> bug8531 <str> ) end def test_succ assert_equal ( <str> , <str> . succ ) end def test_cmp assert_equal ( <int> , <str> < = > <str> ) assert_equal ( - <int> , <str> < = > <str> ) assert_equal ( <int> , <str> < = > <str> ) assert_nil ( <str> < = > <str> ) end def test_casecmp assert_equal ( <int> , <str> . casecmp ( <str> ) ) assert_equal ( <int> , <str> . casecmp ( <str> ) ) assert_equal ( - <int> , <str> . casecmp ( <str> ) ) assert_nil ( <str> . casecmp ( <str> ) ) end def test_length assert_equal ( <int> , <str> . length ) assert_equal ( <int> , <str> . size ) end def test_empty assert_equal ( false , <str> . empty? ) assert_equal ( true , <str> . empty? ) end def test_case assert_equal ( <str> , <str> . upcase ) assert_equal ( <str> , <str> . downcase ) assert_equal ( <str> , <str> . capitalize ) assert_equal ( <str> , <str> . swapcase ) end def test_MATCH assert_equal ( <int> , <str> =~ <str> ) assert_equal ( nil , <str> =~ <str> ) o = Object . new def o . = ~ ( x ) ; x + <str> ; end assert_equal ( <str> , <str> =~ o ) assert_raise ( TypeError ) { <str> =~ <str> } end def test_match_method assert_equal ( <str> , <str> . match ( <str> ) . to_s ) o = Regexp . new ( <str> ) def o . match ( x , y , z ) ; x + y + z ; end assert_equal ( <str> , <str> . match ( o , <str> , <str> ) ) x = nil <str> . match ( o , <str> , <str> ) { | y | x = y } assert_equal ( <str> , x ) assert_raise ( ArgumentError ) { <str> . match } end def test_symbol_poped assert_nothing_raised { eval ( <str> ) } end def test_ascii_incomat_inspect [ Encoding :: UTF_16LE , Encoding :: UTF_16BE , Encoding :: UTF_32LE , Encoding :: UTF_32BE ] . each do | e | assert_equal ( <str> , <str> . encode ( e ) . to_sym . inspect ) assert_equal ( <str> , <str> . encode ( e ) . to_sym . inspect ) end end def test_symbol_encoding assert_equal ( Encoding :: US_ASCII , <str> . force_encoding ( <str> ) . intern . encoding ) assert_equal ( Encoding :: US_ASCII , <str> . force_encoding ( <str> ) . intern . encoding ) assert_equal ( Encoding :: UTF_8 , <str> . intern . encoding ) assert_raise_with_message ( EncodingError , <str> ) { <str> . force_encoding ( <str> ) . intern } end def test_singleton_method assert_raise ( TypeError ) { a = <str> ; def a . foo ; end } end SymbolsForEval = [ <str> , <str> Random . rand ( <int> ) <str> Time . now <str> . to_sym ] def test_instance_eval bug11086 = <str> SymbolsForEval . each do | sym | assert_nothing_raised ( TypeError , sym , bug11086 ) { sym . instance_eval { } } assert_raise ( TypeError , sym , bug11086 ) { sym . instance_eval { def foo ; end } } end end def test_instance_exec bug11086 = <str> SymbolsForEval . each do | sym | assert_nothing_raised ( TypeError , sym , bug11086 ) { sym . instance_exec { } } assert_raise ( TypeError , sym , bug11086 ) { sym . instance_exec { def foo ; end } } end end def test_frozen_symbol assert_equal ( true , <str> . frozen? ) assert_equal ( true , <str> . frozen? ) assert_equal ( true , <str> . frozen? ) assert_equal ( true , <str> Time . now . to_i <str> . to_sym . frozen? ) assert_equal ( true , <str> . to_sym . frozen? ) end def test_symbol_gc_1 assert_normal_exit ( <str> , <str> , <str> : <str> ) assert_normal_exit ( <str> , <str> , <str> : <str> ) assert_normal_exit ( <str> , <str> , <str> : <str> ) assert_normal_exit ( <str> + <str> , <str> , <str> : <str> ) end def test_dynamic_attrset_id bug10259 = <str> class << ( obj = Object . new ) attr_writer <str> end assert_nothing_raised ( NoMethodError , bug10259 ) { obj . send ( <str> . intern , <int> ) } end def test_symbol_fstr_leak bug10686 = <str> x = x = <int> assert_no_memory_leak ( [ ] , <str> , << - <str> , bug10686 , <str> : <int> . <int> , <str> : true ) <int> . times { | i | ( i + <int> ) . to_s . to_sym } end ; end def test_hash_redefinition assert_separately ( [ ] , << - <str> ) bug11035 = <str> class Symbol def hash raise end end h = { } assert_nothing_raised ( RuntimeError , bug11035 ) { h [ <str> ] = <int> } assert_nothing_raised ( RuntimeError , bug11035 ) { h [ <str> . to_sym ] = <int> } end ; end def test_not_freeze bug11721 = <str> str = <str> . taint assert_not_predicate ( str , <str> ) assert_equal str , str . to_sym . to_s assert_not_predicate ( str , <str> , bug11721 ) end end 
