require File . expand_path ( <str> , __FILE__ ) with_feature <str> do describe <str> do before ( <str> ) do @perms = Encoding . name_list . permutation ( <int> ) . map do | pair | Encoding :: Converter . new ( pair . first , pair . last ) rescue nil end . compact . map { | ec | ec . convpath } end it <str> do ec = Encoding :: Converter . new ( <str> , <str> ) ec . convpath . should be_an_instance_of ( Array ) end it <str> do ec = Encoding :: Converter . new ( <str> , <str> ) ec . convpath . first . should be_an_instance_of ( Array ) ec . convpath . first . size . should == <int> end it <str> do ec = Encoding :: Converter . new ( <str> , <str> ) ec . convpath . first . first . should be_an_instance_of ( Encoding ) ec . convpath . first . last . should be_an_instance_of ( Encoding ) end it <str> do ec = Encoding :: Converter . new ( <str> , <str> ) ec . convpath . size . should == <int> ec . convpath . first . first . should == Encoding :: US_ASCII ec . convpath . first . last . should == ec . convpath . last . first ec . convpath . last . last . should == Encoding :: Big5 end it <str> do @perms . each do | convpath | next if convpath . size == <int> convpath . each_with_index do | pair , idx | break if idx == convpath . size - <int> pair . last . should == convpath [ idx + <int> ] . first end end end it <str> do @perms . each do | convpath | next if convpath . size < <int> seen = Hash . new ( false ) convpath . each_with_index do | pair , idx | seen . key? ( pair . first ) . should be_false if idx > <int> seen [ pair . first ] = true end end end it <str> do ec = Encoding :: Converter . new ( <str> , <str> , { <str> = > true } ) ec . convpath . last . should == <str> ec = Encoding :: Converter . new ( <str> , <str> , { <str> = > false } ) ec . convpath . last . should_not == <str> end end end 
