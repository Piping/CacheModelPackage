module Msf class Post module Windows module LDAP include Msf :: Post :: Windows :: Error include Msf :: Post :: Windows :: ExtAPI include Msf :: Post :: Windows :: Accounts LDAP_SIZELIMIT_EXCEEDED = <hex> LDAP_OPT_SIZELIMIT = <hex> LDAP_AUTH_NEGOTIATE = <hex> DEFAULT_PAGE_SIZE = <int> ERROR_CODE_TO_CONSTANT = { <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> , <hex> = > <str> } def initialize ( info = { } ) super register_options ( [ OptString . new ( <str> , [ false , <str> , nil ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) , ] , self . class ) end def dn_to_domain ( dn ) if dn . include? <str> return dn . gsub ( <str> , <str> ) . split ( <str> ) [ <int> .. - <int> ] . join ( <str> ) else return dn end end def query ( filter , max_results , fields , domain = nil ) domain || = datastore [ <str> ] domain || = get_domain if domain . blank? raise RuntimeError , <str> end if load_extapi return session . extapi . adsi . domain_query ( domain , filter , max_results , DEFAULT_PAGE_SIZE , fields ) else if domain and domain . include? <str> default_naming_context = domain domain = dn_to_domain ( domain ) else default_naming_context = get_default_naming_context ( domain ) end bind_default_ldap_server ( max_results , domain ) do | session_handle | return query_ldap ( session_handle , default_naming_context , <int> , filter , fields ) end end end def get_default_naming_context ( domain = nil ) bind_default_ldap_server ( <int> , domain ) do | session_handle | print_status ( <str> ) query_result = query_ldap ( session_handle , <str> , <int> , <str> , [ <str> ] ) first_entry_fields = query_result [ <str> ] . first default_naming_context = first_entry_fields . first [ <str> ] vprint_status ( <str> default_naming_context <str> ) return default_naming_context end end def query_ldap ( session_handle , base , scope , filter , fields ) vprint_status ( <str> ) search = wldap32 . ldap_search_sA ( session_handle , base , scope , filter , nil , <int> , <int> ) vprint_status ( <str> search <str> ) if search [ <str> ] == LDAP_SIZELIMIT_EXCEEDED print_error ( <str> ) elsif search [ <str> ] != Error :: SUCCESS print_error ( <str> ) wldap32 . ldap_msgfree ( search [ <str> ] ) return end search_count = wldap32 . ldap_count_entries ( session_handle , search [ <str> ] ) [ <str> ] if search_count == <int> print_error ( <str> ) wldap32 . ldap_msgfree ( search [ <str> ] ) return end print_status ( <str> search_count <str> ) pEntries = [ ] entry_results = [ ] if datastore [ <str> ] == <int> max_search = search_count else max_search = [ datastore [ <str> ] , search_count ] . min end <int> . upto ( max_search - <int> ) do | i | if ( i == <int> ) pEntries [ <int> ] = wldap32 . ldap_first_entry ( session_handle , search [ <str> ] ) [ <str> ] end if ( pEntries [ i ] == <int> ) print_error ( <str> ) wldap32 . ldap_msgfree ( search [ <str> ] ) return end vprint_status ( <str> i <str> pEntries [ i ] . to_s ( <int> ) <str> ) entry = get_entry ( pEntries [ i ] ) if client . platform =~ <str> pEntries [ i + <int> ] = entry [ <int> ] else pEntries [ i + <int> ] = entry [ <int> ] end ber = get_ber ( entry ) field_results = [ ] fields . each do | field | vprint_status ( <str> field <str> ) values = get_values_from_ber ( ber , field ) values_result = <str> values_result = values . join ( <str> ) if values vprint_status ( <str> values <str> ) field_results << { <str> = > <str> , <str> = > values_result } end entry_results << field_results end return { <str> = > fields , <str> = > entry_results } end def get_entry ( pEntry ) return client . railgun . memread ( pEntry , <int> ) . unpack ( <str> ) end def get_ber ( msg ) ber = client . railgun . memread ( msg [ <int> ] , <int> ) . unpack ( <str> ) if client . platform =~ <str> ber_data = client . railgun . memread ( ber [ <int> ] , ber [ <int> ] ) else ber_data = client . railgun . memread ( ber [ <int> ] , ber [ <int> ] ) end return ber_data end def get_values_from_ber ( ber_data , field ) field_offset = ber_data . index ( field ) unless field_offset vprint_status ( <str> field <str> ) return nil end values_offset = field_offset + field . length values_start_offset = values_offset + <int> values_len_offset = values_offset + <int> curr_len_offset = values_offset + <int> values_length = ber_data [ values_len_offset ] . unpack ( <str> ) [ <int> ] values_end_offset = values_start_offset + values_length curr_length = ber_data [ curr_len_offset ] . unpack ( <str> ) [ <int> ] curr_start_offset = values_start_offset if ( curr_length > = <int> ) curr_length = ber_data [ curr_len_offset + <int> , <int> ] . unpack ( <str> ) [ <int> ] curr_start_offset += <int> end curr_end_offset = curr_start_offset + curr_length values = [ ] while ( curr_end_offset < values_end_offset ) values << ber_data [ curr_start_offset .. curr_end_offset ] break unless ber_data [ curr_end_offset ] == <str> curr_len_offset = curr_end_offset + <int> curr_length = ber_data [ curr_len_offset ] . unpack ( <str> ) [ <int> ] curr_start_offset = curr_end_offset + <int> curr_end_offset = curr_end_offset + curr_length + <int> end values . map! { | x | x [ <int> .. x . length - <int> ] } return values end def wldap32 client . railgun . wldap32 end def bind_default_ldap_server ( size_limit , domain = nil ) vprint_status ( <str> ) init_result = wldap32 . ldap_sslinitA ( domain , <int> , <int> ) session_handle = init_result [ <str> ] if session_handle == <int> raise RuntimeError . new ( <str> init_result [ <str> ] <str> ) end vprint_status ( <str> session_handle <str> ) vprint_status ( <str> ) wldap32 . ldap_set_option ( session_handle , LDAP_OPT_SIZELIMIT , size_limit ) vprint_status ( <str> ) bind_result = wldap32 . ldap_bind_sA ( session_handle , nil , nil , LDAP_AUTH_NEGOTIATE ) bind = bind_result [ <str> ] unless bind == <int> wldap32 . ldap_unbind ( session_handle ) raise RuntimeError . new ( <str> ERROR_CODE_TO_CONSTANT [ bind ] <str> ) end if ( block_given? ) begin yield session_handle ensure vprint_status ( <str> ) wldap32 . ldap_unbind ( session_handle ) end else return session_handle end return session_handle end end end end end 
