require <str> if ARGV . empty? $stderr . puts <str> exit ( <int> ) end width = <int> TkButton . new ( <str> = > <str> , <str> = > proc { exit } ) . pack ( <str> = > <str> , <str> = > <str> ) b = TkButton . new ( <str> = > <str> ) . pack ( <str> = > <str> , <str> = > <str> ) f = TkFrame . new ( <str> = > <str> , <str> = > <int> ) . pack ( <str> = > <str> ) TkLabel . new ( f , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > <str> ) . pack ( <str> = > <str> , <str> = > <str> , <str> = > true ) now = TkLabel . new ( f , <str> = > width , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> % [ <int> , <int> ] ) . pack ( <str> = > <str> ) timers = [ TkRTTimer . new ( <int> ) { | tm | t = ( tm . return_value || <int> ) + <int> s , u = t . divmod ( <int> ) m , s = s . divmod ( <int> ) now . text ( <str> % [ m , s , u ] ) t } . set_start_proc ( <int> , proc { now . text ( <str> % [ <int> , <int> ] ) now . foreground ( <str> ) <int> } ) ] ARGV . collect { | arg | ( Float ( arg ) * <int> ) . to_i } . sort . each_with_index { | time , idx | f = TkFrame . new ( <str> = > <str> , <str> = > <int> ) . pack ( <str> = > <str> ) TkLabel . new ( f , <str> = > <str> , <str> = > <int> , <str> = > <str> % ( time . divmod ( <int> ) ) ) . pack ( <str> = > <str> ) l = TkLabel . new ( f , <str> = > width , <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > <str> % ( time . divmod ( <int> ) ) ) . pack ( <str> = > <str> ) timers << TkRTTimer . new ( <int> ) { | tm | t = ( tm . return_value || time ) - <int> if t < <int> l . text ( <str> % ( ( - t ) . divmod ( <int> ) ) ) else l . text ( <str> % ( t . divmod ( <int> ) ) ) end if t . zero? l . foreground ( <str> ) idx . times { Tk . bell } end t } . set_start_proc ( <int> , proc { l . text ( <str> % ( time . divmod ( <int> ) ) ) l . foreground ( <str> ) time } ) } mode = <str> b . command ( proc { if mode == <str> timers . each { | timer | timer . restart } b . text ( <str> ) mode = <str> else timers . each { | timer | timer . stop . reset } b . text ( <str> ) mode = <str> end } ) Tk . mainloop 
