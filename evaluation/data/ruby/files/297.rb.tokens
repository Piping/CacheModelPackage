require <str> require <str> module Msf::DBManager::Import::Nexpose::Raw def import_nexpose_raw_noko_stream ( args , & block ) if block doc = Rex :: Parser :: NexposeRawDocument . new ( args , framework . db ) { | type , data | yield type , data } else doc = Rex :: Parser :: NexposeRawDocument . new ( args , self ) end parser = :: Nokogiri :: XML :: SAX :: Parser . new ( doc ) parser . parse ( args [ <str> ] ) end def import_nexpose_rawxml ( args = { } , & block ) bl = validate_ips ( args [ <str> ] ) ? args [ <str> ] . split : [ ] wspace = args [ <str> ] || workspace if Rex :: Parser . nokogiri_loaded parser = <str> :: Nokogiri :: VERSION <str> noko_args = args . dup noko_args [ <str> ] = bl noko_args [ <str> ] = wspace if block yield ( <str> , parser ) import_nexpose_raw_noko_stream ( noko_args ) { | type , data | yield type , data } else import_nexpose_raw_noko_stream ( noko_args ) end return true end data = args [ <str> ] parser = Rex :: Parser :: NexposeXMLStreamParser . new hosts = [ ] vulns = [ ] parser . callback = Proc . new { | type , value | case type when <str> hosts . push ( value ) when <str> value [ <str> ] = value [ <str> ] . downcase if value [ <str> ] vulns . push ( value ) end } REXML :: Document . parse_stream ( data , parser ) vuln_refs = nexpose_refs_to_struct ( vulns ) hosts . each do | host | if bl . include? host [ <str> ] next else yield ( <str> , host [ <str> ] ) if block end nexpose_host_from_rawxml ( host , vuln_refs , wspace ) end end def import_nexpose_rawxml_file ( args = { } ) filename = args [ <str> ] wspace = args [ <str> ] || workspace data = <str> :: File . open ( filename , <str> ) do | f | data = f . read ( f . stat . size ) end import_nexpose_rawxml ( args . merge ( <str> = > data ) ) end def nexpose_host_from_rawxml ( h , vstructs , wspace , task = nil ) hobj = nil data = { <str> = > wspace } if h [ <str> ] addr = h [ <str> ] else return end data [ <str> ] = addr if ( h [ <str> ] ) data [ <str> ] = h [ <str> ] . gsub ( <str> , <str> ) . scan ( <str> ) . join ( <str> ) end data [ <str> ] = ( h [ <str> ] == <str> ) ? Msf :: HostState :: Alive : Msf :: HostState :: Dead if ( h [ <str> ] and h [ <str> ] . first ) data [ <str> ] = h [ <str> ] . first end if ( data [ <str> ] != Msf :: HostState :: Dead ) hobj = report_host ( data ) report_import_note ( wspace , hobj ) end if h [ <str> ] note = { <str> = > wspace , <str> = > ( hobj || addr ) , <str> = > <str> , <str> = > { } , <str> = > <str> , <str> = > task } h [ <str> ] . each do | v , k | note [ <str> ] [ v ] || = [ ] next if note [ <str> ] [ v ] . include? k note [ <str> ] [ v ] << k end report_note ( note ) end if h [ <str> ] note = { <str> = > wspace , <str> = > hobj || addr , <str> = > <str> , <str> = > task , <str> = > { <str> = > h [ <str> ] , <str> = > h [ <str> ] } } note [ <str> ] [ <str> ] = h [ <str> ] if h [ <str> ] note [ <str> ] [ <str> ] = h [ <str> ] if h [ <str> ] note [ <str> ] [ <str> ] = h [ <str> ] if h [ <str> ] note [ <str> ] [ <str> ] = h [ <str> ] if h [ <str> ] report_note ( note ) end h [ <str> ] . each { | p | extra = <str> extra << p [ <str> ] + <str> if p [ <str> ] extra << p [ <str> ] + <str> if p [ <str> ] next if p [ <str> ] . to_i == <int> data = { } data [ <str> ] = wspace data [ <str> ] = p [ <str> ] . downcase data [ <str> ] = p [ <str> ] . to_i data [ <str> ] = p [ <str> ] data [ <str> ] = hobj || addr data [ <str> ] = extra if not extra . empty? data [ <str> ] = task if p [ <str> ] != <str> data [ <str> ] = p [ <str> ] end report_service ( data ) } h [ <str> ] . each_pair { | k , v | next if v [ <str> ] !~ <str> vstruct = vstructs . select { | vs | vs . id . to_s . downcase == v [ <str> ] . to_s . downcase } . first next unless vstruct data = { } data [ <str> ] = wspace data [ <str> ] = hobj || addr data [ <str> ] = v [ <str> ] . downcase if v [ <str> ] data [ <str> ] = v [ <str> ] . to_i if v [ <str> ] data [ <str> ] = <str> + v [ <str> ] data [ <str> ] = vstruct . title data [ <str> ] = vstruct . refs data [ <str> ] = task report_vuln ( data ) } end def nexpose_refs_to_struct ( vulns ) ret = [ ] vulns . each do | vuln | next if ret . map { | v | v . id } . include? vuln [ <str> ] vstruct = Struct . new ( <str> , <str> , <str> , <str> ) . new vstruct . id = vuln [ <str> ] vstruct . title = vuln [ <str> ] vstruct . severity = vuln [ <str> ] vstruct . refs = [ ] vuln [ <str> ] . each do | ref | if ref [ <str> ] == <str> vstruct . refs . push ( <str> + ref [ <str> ] ) elsif ref [ <str> ] == <str> vstruct . refs . push ( ref [ <str> ] ) elsif ref [ <str> ] == <str> vstruct . refs . push ( <str> + ref [ <str> ] ) elsif ref [ <str> ] == <str> vstruct . refs . push ( <str> + ref [ <str> ] ) end end ret . push vstruct end return ret end end 
