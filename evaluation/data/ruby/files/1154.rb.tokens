require <str> require <str> C_ESC = { <str> = > <str> , <str> = > <str> , <str> = > <str> , } <hex> . upto ( <hex> ) { | ch | C_ESC [ [ ch ] . pack ( <str> ) ] || = <str> % ch } <hex> . upto ( <hex> ) { | ch | C_ESC [ [ ch ] . pack ( <str> ) ] = <str> % ch } C_ESC_PAT = Regexp . union ( * C_ESC . keys ) def c_str ( str ) <str> + str . gsub ( C_ESC_PAT ) { | s | C_ESC [ s ] } + <str> end opt = OptionParser . new opt . def_option ( <str> , <str> ) { puts opt exit <int> } opt_o = nil opt . def_option ( <str> , <str> ) { | filename | opt_o = filename } opt_H = nil opt . def_option ( <str> , <str> ) { | filename | opt_H = filename } opt . parse! h = { } COMMENTS = { } DATA . each_line { | s | next if <str> =~ s name , default_value , comment = s . chomp . split ( <str> , <int> ) default_value = nil if default_value == <str> if h . has_key? name warn <str> $. <str> name <str> next end h [ name ] = default_value COMMENTS [ name ] = comment if comment } DEFS = h . to_a def each_const DEFS . each { | name , default_value | yield name , default_value } end def each_name ( pat ) DEFS . each { | name , default_value | next if pat !~ name yield name } end ERB . new ( << <str> EOS <str> , nil , <str> ) . def_method ( Object , <str> ) <str> EOS ERB . new ( << <str> EOS <str> , nil , <str> ) . def_method ( Object , <str> ) <str> EOS header_result = ERB . new ( << <str> EOS <str> , nil , <str> ) . result ( binding ) <str> EOS result = ERB . new ( << <str> EOS <str> , nil , <str> ) . result ( binding ) <str> EOS if opt_H File . open ( opt_H , <str> ) { | f | f << header_result } else result = header_result + result end if opt_o File . open ( opt_o , <str> ) { | f | f << result } else $stdout << result end 
