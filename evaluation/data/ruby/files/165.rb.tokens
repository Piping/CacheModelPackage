require <str> require <str> require <str> module Puppet::MetaType module Manager include Puppet :: Util :: ClassGen def allclear @types . each { | name , type | type . clear } end def eachtype @types . each do | name , type | yield type end end def loadall typeloader . loadall end def newtype ( name , options = { } , & block ) unless options . is_a? ( Hash ) Puppet . warning <str> name <str> options . inspect <str> end name = name . intern newmethod = <str> name <str> selfobj = singleton_class @types || = { } if @types . include? ( name ) if self . respond_to? ( newmethod ) selfobj . send ( <str> , newmethod ) end end options = symbolize_options ( options ) klass = genclass ( name , <str> = > Puppet :: Type , <str> = > true , <str> = > @types , <str> = > options , & block ) if self . respond_to? newmethod Puppet . warning <str> name . to_s <str> else selfobj . send ( <str> , newmethod ) do | * args | klass . new ( * args ) end end klass . ensurable if klass . ensurable? and ! klass . validproperty? ( <str> ) klass . providerloader = Puppet :: Util :: Autoload . new ( klass , <str> klass . name . to_s <str> ) klass . providerloader . loadall Puppet . lookup ( <str> ) klass . providify unless klass . providers . empty? klass end def rmtype ( name ) rmclass ( name , <str> = > @types ) singleton_class . send ( <str> , <str> name <str> ) if respond_to? ( <str> name <str> ) end def type ( name ) if name . to_s . include? ( <str> ) return nil end @types || = { } return @types [ name ] if @types [ name ] if name . is_a? String name = name . downcase . intern return @types [ name ] if @types [ name ] end if typeloader . load ( name , Puppet . lookup ( <str> ) ) Puppet . warning <str> name <str> unless @types . include? name end return @types [ name ] end def typeloader unless defined? ( @typeloader ) @typeloader = Puppet :: Util :: Autoload . new ( self , <str> ) end @typeloader end end end 
