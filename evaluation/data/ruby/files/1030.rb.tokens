module Bosh module Director module DeploymentPlan class InstancePlanner def initialize ( instance_plan_factory , logger ) @instance_plan_factory = instance_plan_factory @logger = logger end def plan_job_instances ( job , desired_instances , existing_instance_models ) network_planner = NetworkPlanner :: Planner . new ( @logger ) placement_plan = PlacementPlanner :: Plan . new ( @instance_plan_factory , network_planner , @logger ) vip_networks , non_vip_networks = job . networks . to_a . partition ( & <str> ) instance_plans = placement_plan . create_instance_plans ( desired_instances , existing_instance_models , non_vip_networks , job . availability_zones , job . name ) log_outcome ( instance_plans ) desired_instance_plans = instance_plans . reject ( & <str> ) vip_static_ips_planner = NetworkPlanner :: VipStaticIpsPlanner . new ( network_planner , @logger ) vip_static_ips_planner . add_vip_network_plans ( desired_instance_plans , vip_networks ) reconcile_network_plans ( desired_instance_plans ) elect_bootstrap_instance ( desired_instance_plans ) instance_plans end def plan_obsolete_jobs ( desired_jobs , existing_instances ) desired_job_names = Set . new ( desired_jobs . map ( & <str> ) ) migrating_job_names = Set . new ( desired_jobs . map ( & <str> ) . flatten . map ( & <str> ) ) obsolete_existing_instances = existing_instances . reject do | existing_instance_model | desired_job_names . include? ( existing_instance_model . job ) || migrating_job_names . include? ( existing_instance_model . job ) end obsolete_existing_instances . map do | obsolete_existing_instance | @instance_plan_factory . obsolete_instance_plan ( obsolete_existing_instance ) end end private def elect_bootstrap_instance ( desired_instance_plans ) bootstrap_instance_plans = desired_instance_plans . select { | i | i . instance . bootstrap? } if bootstrap_instance_plans . size == <int> bootstrap_instance_plan = bootstrap_instance_plans . first instance = bootstrap_instance_plan . instance @logger . info ( <str> instance <str> bootstrap_instance_plan . desired_instance . availability_zone <str> ) else return if desired_instance_plans . empty? if bootstrap_instance_plans . size > <int> @logger . info ( <str> ) else @logger . info ( <str> ) end lowest_indexed_desired_instance_plan = desired_instance_plans . reject { | instance_plan | instance_plan . desired_instance . index . nil? } . sort_by { | instance_plan | instance_plan . desired_instance . index } . first desired_instance_plans . each do | instance_plan | instance = instance_plan . instance if instance_plan == lowest_indexed_desired_instance_plan @logger . info ( <str> instance <str> instance_plan . desired_instance . availability_zone <str> ) instance . mark_as_bootstrap else instance . unmark_as_bootstrap end end end end def reconcile_network_plans ( instance_plans ) instance_plans . each do | instance_plan | network_plans = NetworkPlanner :: ReservationReconciler . new ( instance_plan , @logger ) . reconcile ( instance_plan . instance . existing_network_reservations ) instance_plan . network_plans = network_plans end end def log_outcome ( instance_plans ) instance_plans . select ( & <str> ) . each do | instance_plan | instance = instance_plan . desired_instance @logger . info ( <str> instance . job . name <str> instance . index <str> instance . availability_zone <str> ) end instance_plans . select ( & <str> ) . each do | instance_plan | instance = instance_plan . existing_instance @logger . info ( <str> instance . job <str> instance . index <str> instance_plan . desired_instance . availability_zone <str> ) end instance_plans . select ( & <str> ) . each do | instance_plan | instance = instance_plan . existing_instance @logger . info ( <str> instance . job <str> instance . index <str> instance . availability_zone <str> ) end end end end end end 
