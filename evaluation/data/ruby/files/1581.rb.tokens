require <str> class TkMultiListFrame < TkListbox include TkComposite def initialize_composite ( lbox_height , title_info , keys = { } ) if ( ! title_info . kind_of? Array ) or ( title_info . size < <int> ) raise end @keep_minsize = true @show_each_hscr = true @show_win_hscr = true @base_list = [ ] @rel_list = [ ] @title_list = [ ] @title_cmd = [ ] @lbox_list = [ ] @hscr_list = [ ] @lbox_total = title_info . size @width_total = <int> title_info . each { | title , width , cmd | @width_total += width . to_f @title_cmd << cmd } @name_index = { } @window_width = @width_total @sash = <int> @scrbar_width = <int> @scrbar_border = <int> @lbox_border = <int> @title_border = <int> @h_l_thick = <int> @mode = <str> @v_scroll = TkYScrollbar . new ( @frame , <str> = > @h_l_thick , <str> = > @scrbar_border , <str> = > @scrbar_width ) @h_scroll = TkXScrollbar . new ( @frame , <str> = > @h_l_thick , <str> = > @scrbar_border , <str> = > @scrbar_width ) @c_title = TkCanvas . new ( @frame , <str> = > @h_l_thick , <str> = > @window_width ) @f_title = TkFrame . new ( @c_title , <str> = > @width_total ) @w_title = TkcWindow . new ( @c_title , <int> , <int> , <str> = > @f_title , <str> = > <str> ) @c_lbox = TkCanvas . new ( @frame , <str> = > @h_l_thick , <str> = > @window_width ) @f_lbox = TkFrame . new ( @c_lbox , <str> = > @width_total ) @w_lbox = TkcWindow . new ( @c_lbox , <int> , <int> , <str> = > @f_lbox , <str> = > <str> ) @c_hscr = TkCanvas . new ( @frame , <str> = > @h_l_thick , <str> = > @window_width ) @f_hscr = TkFrame . new ( @c_hscr , <str> = > @width_total ) @w_hscr = TkcWindow . new ( @c_hscr , <int> , <int> , <str> = > @f_hscr , <str> = > <str> ) sum = <int> . <int> @rel_list << sum / @width_total title_info . each_with_index { | ( label , width ) , idx | if @name_index . include? ( label ) @name_index [ label ] << idx else @name_index [ label ] = [ idx ] end sum += width @rel_list << sum / @width_total f = TkFrame . new ( @f_title , <str> = > width ) base = [ f ] title = TkLabel . new ( f , <str> = > label , <str> = > @title_border , <str> = > <str> , <str> = > @h_l_thick ) title_binding ( title , idx ) title . pack ( <str> = > <str> ) @title_list << title f . place ( <str> = > @rel_list [ idx ] , <str> = > <int> , <str> = > <str> , <str> = > <int> , <str> = > <int> . <int> , <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] ) f = TkFrame . new ( @f_lbox , <str> = > width ) base << f @lbox_list << TkListbox . new ( f , <str> = > @h_l_thick , <str> = > @lbox_border ) . pack ( <str> = > <str> , <str> = > true ) f . place ( <str> = > @rel_list [ idx ] , <str> = > <int> , <str> = > <str> , <str> = > <int> , <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] , <str> = > <int> . <int> ) f = TkFrame . new ( @f_hscr , <str> = > width ) base << f @hscr_list << TkXScrollbar . new ( f , <str> = > @scrbar_width , <str> = > @scrbar_border , <str> = > @h_l_thick ) . pack ( <str> = > <str> , <str> = > <str> ) f . place ( <str> = > @rel_list [ idx ] , <str> = > <int> , <str> = > <str> , <str> = > <int> , <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] ) @lbox_list [ idx ] . xscrollbar ( @hscr_list [ idx ] ) @base_list << base } @f_title_pad = TkFrame . new ( @frame , <str> = > <str> , <str> = > @title_border , <str> = > @h_l_thick ) @f_scr_pad = TkFrame . new ( @frame , <str> = > <str> , <str> = > <int> , <str> = > @h_l_thick ) title_height = <int> @title_list . each { | w | h = w . winfo_reqheight title_height = h if title_height < h } hscr_height = <int> @hscr_list . each { | w | h = w . winfo_reqheight hscr_height = h if hscr_height < h } @f_title . height title_height @f_lbox . height lbox_height @f_hscr . height hscr_height @v_scroll . assign ( * @lbox_list ) @h_scroll . assign ( @c_title , @c_lbox , @c_hscr ) @lbox_mode = { } @lbox_mode [ <str> ] = browse_mode_bindtag @lbox_mode [ <str> ] = single_mode_bindtag @lbox_mode [ <str> ] = extended_mode_bindtag @lbox_mode [ <str> ] = multiple_mode_bindtag @current_mode = <str> @lbox_list . each_with_index { | l , idx | l . bind ( <str> , proc { | w | focus_shift ( w , - <int> ) ; Tk . callback_break } , <str> ) l . bind ( <str> , proc { | w | focus_shift ( w , <int> ) ; Tk . callback_break } , <str> ) l . bind ( <str> , proc { | x , y | @lbox_mark_x = x @lbox_list . each { | lbox | lbox . scan_mark ( x , y ) } } , <str> ) l . bind ( <str> , proc { | x , y | @lbox_list . each { | lbox | lbox . scan_dragto ( @lbox_mark_x , y ) } l . scan_dragto ( x , y ) } , <str> ) l . bindtags ( l . bindtags . unshift ( @lbox_mode [ @current_mode ] ) ) } bbox = @w_title . bbox @c_title . height ( bbox [ <int> ] ) @c_title . scrollregion ( bbox ) bbox = @w_lbox . bbox @c_lbox . height ( bbox [ <int> ] ) @c_lbox . scrollregion ( bbox ) if @show_each_hscr bbox = @w_hscr . bbox @c_hscr . height ( bbox [ <int> ] ) @c_hscr . scrollregion ( bbox ) end TkGrid . rowconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . rowconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . rowconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . rowconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . columnconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . columnconfigure ( @frame , <int> , <str> = > <int> ) TkGrid . columnconfigure ( @frame , <int> , <str> = > <int> ) @v_scroll . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) @c_title . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) @f_title_pad . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) @c_lbox . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) @c_hscr . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) if @show_each_hscr @h_scroll . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) if @show_win_hscr @f_scr_pad . grid ( <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <str> ) @c_lbox . bind ( <str> , proc { | height , width | reconstruct ( height , width ) } , <str> ) @path = @lbox_list [ <int> ] . path keys = { } unless keys keys = _symbolkey2str ( keys ) sel_mode = keys . delete ( <str> ) mode ( sel_mode ) if sel_mode width = keys . delete ( <str> ) scrollbarwidth ( width ) if width title_font = keys . delete ( <str> ) titlefont ( title_font ) if title_font title_fg = keys . delete ( <str> ) titleforeground ( title_fg ) if title_fg title_bg = keys . delete ( <str> ) titlebackground ( title_bg ) if title_bg delegate ( <str> , * @lbox_list ) delegate ( <str> , @v_scroll , @h_scroll , * @hscr_list ) delegate ( <str> , @v_scroll , @h_scroll , * @hscr_list ) delegate ( <str> , @v_scroll , @h_scroll , * @hscr_list ) delegate ( <str> , @v_scroll , @h_scroll , * @hscr_list ) delegate ( <str> , @frame ) delegate ( <str> , @c_lbox , @c_title , @c_hscr ) delegate ( <str> , @frame ) configure ( keys ) if keys . size > <int> end private <str> def mode ( sel_mode ) @lbox_list . each { | l | tags = l . bindtags tags = tags - [ @lbox_mode [ @current_mode ] ] l . bindtags ( tags . unshift ( @lbox_mode [ sel_mode ] ) ) @current_mode = sel_mode } end def keep_minsize? @keep_minsize end def keep_minsize ( bool ) @keep_minsize = bool end def show_each_hscr @show_each_hscr = true @c_hscr . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) end def hide_each_hscr @show_each_hscr = false @c_hscr . ungrid end def show_win_hscr @show_win_hscr = true @h_scroll . grid ( <str> = > <int> , <str> = > <int> , <str> = > <str> ) end def hide_win_hscr @show_each_hscr = false @h_scroll . ungrid end def scrollbarwidth ( width ) @scrbar_width = width @v_scroll [ <str> ] = @scrbar_width @h_scroll [ <str> ] = @scrbar_width @hscr_list . each { | hscr | hscr [ <str> ] = @scrbar_width } self end def scrollbarborder ( width ) @scrbar_border = width @v_scroll [ <str> ] = @scrbar_border @h_scroll [ <str> ] = @scrbar_border @hscr_list . each { | hscr | hscr [ <str> ] = @scrbar_border } self end def listboxborder ( width ) @lbox_border = width @lbox_list . each { | w | w [ <str> ] = @lbox_border } self end def listboxrelief ( relief ) @lbox_list . each { | w | w [ <str> ] = relief } self end def titleborder ( width ) @title_border = width @f_title_pad [ <str> ] = @title_border @title_list . each { | label | label [ <str> ] = @title_border } self end def titlefont ( font ) @title_list . each { | label | label [ <str> ] = font } title_height = <int> @title_list . each { | w | h = w . winfo_reqheight title_height = h if title_height < h } @f_title . height title_height bbox = @w_title . bbox @c_title . height ( bbox [ <int> ] ) @c_title . scrollregion ( bbox ) self end def titleforeground ( fg ) @title_list . each { | label | label [ <str> ] = fg } self end def titlebackground ( bg ) @f_title_pad [ <str> ] = bg @title_list . each { | label | label [ <str> ] = bg } self end def titlecommand ( idx , cmd = Proc . new ) @title_cmd [ idx ] = cmd end def titleinvoke ( idx ) @title_cmd [ idx ] . call if @title_cmd [ idx ] end def titlelabels ( * indices ) @title_list [ * indices ] end def columns ( * indices ) @lbox_list [ * indices ] end def activate ( idx ) @lbox_list . each { | lbox | lbox . activate ( idx ) } end def bbox ( idx ) @lbox_list . collect { | lbox | lbox . bbox ( idx ) } end def delete ( * idx ) @lbox_list . collect { | lbox | lbox . delete ( * idx ) } end def get ( * idx ) if idx . size == <int> @lbox_list . collect { | lbox | lbox . get ( * idx ) } else list = @lbox_list . collect { | lbox | lbox . get ( * idx ) } result = [ ] list [ <int> ] . each_with_index { | line , index | result << list . collect { | lines | lines [ index ] } } result end end def _line_array_to_hash ( line ) result = { } @name_index . each_pair { | label , indices | if indices . size == <int> result [ label ] = line [ indices [ <int> ] ] else result [ label ] = indices . collect { | index | line [ index ] } end } result end private <str> def get_by_hash ( * idx ) get_result = get ( * idx ) if idx . size == <int> _line_array_to_hash ( get_result ) else get_result . collect { | line | _line_array_to_hash ( line ) } end end def insert ( idx , * lines ) lbox_ins = [ ] ( <int> .. @lbox_list . size ) . each { lbox_ins << [ ] } lines . each { | line | if line . kind_of? Hash array = [ ] @name_index . each_pair { | label , indices | if indices . size == <int> array [ indices [ <int> ] ] = line [ label ] else if line [ label ] . kind_of? Array indices . each_with_index { | index , num | array [ index ] = line [ label ] [ num ] } else array [ indices [ <int> ] ] = line [ label ] end end } line = array end @name_index . each_pair { | label , indices | if indices . size == <int> lbox_ins [ indices [ <int> ] ] << line [ indices [ <int> ] ] else indices . each { | index | lbox_ins [ index ] << line [ index ] } end } } @lbox_list . each_with_index { | lbox , index | lbox . insert ( idx , * lbox_ins [ index ] ) if lbox_ins [ index ] } end def selection_anchor ( index ) @lbox_list . each { | lbox | lbox . selection_anchor ( index ) } end def selection_clear ( first , last = None ) @lbox_list . each { | lbox | lbox . selection_clear ( first , last = None ) } end def selection_set ( first , last = None ) @lbox_list . each { | lbox | lbox . selection_set ( first , last = None ) } end private def reconstruct ( height , width ) if @keep_minsize && width < = @width_total @f_title . width ( @width_total ) @f_lbox . width ( @width_total ) @f_hscr . width ( @width_total ) if @show_each_hscr @window_width = @width_total else @f_title . width ( width ) @f_lbox . width ( width ) @f_hscr . width ( width ) if @show_each_hscr @window_width = width end @f_lbox . height ( height ) @c_title . scrollregion ( @w_title . bbox ) @c_lbox . scrollregion ( @w_lbox . bbox ) @c_hscr . scrollregion ( @w_hscr . bbox ) if @show_each_hscr ( <int> .. ( @rel_list . size - <int> ) ) . each { | idx | title , lbox , hscr = @base_list [ idx ] title . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] ) lbox . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] , <str> = > <int> . <int> ) hscr . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] ) } end def resize ( x ) idx = @sel_sash return if idx == <int> delta = ( x - @x ) / @frame_width if delta < @rel_list [ idx - <int> ] - @rel_list [ idx ] + ( <int> * @sash / @frame_width ) delta = @rel_list [ idx - <int> ] - @rel_list [ idx ] + ( <int> * @sash / @frame_width ) elsif delta > @rel_list [ idx + <int> ] - @rel_list [ idx ] - ( <int> * @sash / @frame_width ) delta = @rel_list [ idx + <int> ] - @rel_list [ idx ] - ( <int> * @sash / @frame_width ) end @rel_list [ idx ] += delta title , lbox , hscr = @base_list [ idx - <int> ] title . place ( <str> = > @rel_list [ idx ] - @rel_list [ idx - <int> ] ) lbox . place ( <str> = > @rel_list [ idx ] - @rel_list [ idx - <int> ] , <str> = > <int> . <int> ) hscr . place ( <str> = > @rel_list [ idx ] - @rel_list [ idx - <int> ] ) title , lbox , hscr = @base_list [ idx ] title . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] , <str> = > @rel_list [ idx ] ) lbox . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] , <str> = > @rel_list [ idx ] , <str> = > <int> . <int> ) hscr . place ( <str> = > @rel_list [ idx + <int> ] - @rel_list [ idx ] , <str> = > @rel_list [ idx ] ) @x = x end def motion_cb ( w , x , idx ) if x < = @sash && idx > <int> w . cursor <str> @mode = <str> @sel_sash = idx elsif x > = w . winfo_width - @sash && idx < @lbox_total - <int> w . cursor <str> @mode = <str> @sel_sash = idx + <int> else w . cursor <str> @mode = <str> @sel_sash = <int> end end def title_binding ( title , index ) title . bind ( <str> , proc { | w , x , idx | motion_cb ( w , x , idx . to_i ) } , <str> index <str> ) title . bind ( <str> , proc { | w , x , idx | motion_cb ( w , x , idx . to_i ) } , <str> index <str> ) title . bind ( <str> , proc { | w | w . cursor <str> } , <str> ) title . bind ( <str> , proc { | w , x | if @mode == <str> @x = x @frame_width = TkWinfo . width ( @f_title ) . to_f else title . relief <str> end } , <str> ) title . bind ( <str> , proc { | w , x , idx | i = idx . to_i if @mode == <str> && @title_cmd [ i ] . kind_of? ( Proc ) @title_cmd [ i ] . call end title . relief <str> motion_cb ( w , x , i ) } , <str> index <str> ) title . bind ( <str> , proc { | x | resize ( x ) if @mode == <str> } , <str> ) end def browse_mode_bindtag t = TkBindTag . new t . bind ( <str> , proc { | w , y | w . focus ; select_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | active_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w | select_shift ( w , - <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_shift ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t end def single_mode_bindtag t = TkBindTag . new t . bind ( <str> , proc { | w , y | w . focus ; select_only ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | active_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | active_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w | select_shift ( w , - <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_shift ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t . bind ( <str> , proc { | w | select_line ( w , w . index ( <str> ) . to_i ) } , <str> ) t . bind ( <str> , proc { @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) } } ) t end def extended_mode_bindtag t = TkBindTag . new t . bind ( <str> , proc { | w , y | w . focus ; select_only ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_range ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | active_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_range ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_range ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_toggle ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | select_drag ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w | active_shift ( w , - <int> ) } , <str> ) t . bind ( <str> , proc { | w | active_shift ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_expand ( w , - <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_expand ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line2 ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line2 ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | select_range ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_range ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | select_active ( w ) } , <str> ) t . bind ( <str> , proc { | w | select_active ( w ) } , <str> ) t . bind ( <str> , proc { | w | select_all } , <str> ) t . bind ( <str> , proc { | w | clear_all } , <str> ) t end def multiple_mode_bindtag t = TkBindTag . new t . bind ( <str> , proc { | w , y | w . focus ; select_line3 ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w , y | active_line ( w , w . nearest ( y ) ) } , <str> ) t . bind ( <str> , proc { | w | active_shift ( w , - <int> ) } , <str> ) t . bind ( <str> , proc { | w | active_shift ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line2 ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | select_line2 ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | active_line ( w , <int> ) } , <str> ) t . bind ( <str> , proc { | w | active_line ( w , <str> ) } , <str> ) t . bind ( <str> , proc { | w | select_active ( w ) } , <str> ) t . bind ( <str> , proc { | w | select_active ( w ) } , <str> ) t . bind ( <str> , proc { | w | select_all } , <str> ) t . bind ( <str> , proc { | w | clear_all } , <str> ) t end def active_line ( w , idx ) @lbox_list . each { | l | l . activate ( idx ) } end def select_only ( w , idx ) @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) l . selection_anchor ( idx ) l . selection_set ( <str> ) } end def select_range ( w , idx ) @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) l . selection_set ( <str> , idx ) } end def select_toggle ( w , idx ) st = w . selection_includes ( idx ) @lbox_list . each { | l | l . selection_anchor ( idx ) if st == <int> l . selection_clear ( idx ) else l . selection_set ( idx ) end } end def select_drag ( w , idx ) st = w . selection_includes ( <str> ) @lbox_list . each { | l | if st == <int> l . selection_set ( <str> , idx ) else l . selection_clear ( <str> , idx ) end } end def select_line ( w , idx ) @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) l . activate ( idx ) l . selection_anchor ( idx ) l . selection_set ( <str> ) } w . selection_set ( <str> ) end def select_line2 ( w , idx ) @lbox_list . each { | l | l . activate ( idx ) l . selection_anchor ( idx ) l . selection_set ( <str> ) } end def select_line3 ( w , idx ) @lbox_list . each { | l | l . selection_set ( idx ) } end def select_active ( w ) idx = l . activate ( idx ) @lbox_list . each { | l | l . selection_set ( idx ) } end def select_expand ( w , dir ) idx = w . index ( <str> ) . to_i + dir if idx < <int> idx = <int> elsif idx > = w . size idx = w . size - <int> end @lbox_list . each { | l | l . activate ( idx ) l . selection_set ( idx ) } end def active_shift ( w , dir ) idx = w . index ( <str> ) . to_i + dir if idx < <int> idx = <int> elsif idx > = w . size idx = w . size - <int> end @lbox_list . each { | l | l . activate ( idx ) l . selection_anchor ( idx ) } end def select_shift ( w , dir ) idx = w . index ( <str> ) . to_i + dir if idx < <int> idx = <int> elsif idx > = w . size idx = w . size - <int> end @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) l . activate ( idx ) l . selection_anchor ( idx ) l . selection_set ( <str> ) } end def select_all @lbox_list . each { | l | l . selection_set ( <int> , <str> ) } end def clear_all @lbox_list . each { | l | l . selection_clear ( <int> , <str> ) } end def focus_shift ( w , dir ) idx = @lbox_list . index ( w ) + dir return if idx < <int> return if idx > = @lbox_list . size @lbox_list [ idx ] . focus end end if __FILE__ == $0 l = TkMultiListFrame . new ( nil , <int> , [ [ <str> , <int> , proc { p <str> } ] , [ <str> , <int> ] , [ <str> , <int> ] ] , <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > <str> ) . pack ( <str> = > <str> , <str> = > true ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <str> , <str> , <str> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <str> , <str> , <str> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <str> , <str> , <str> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <str> , <str> , <str> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] ) l . insert ( <str> , [ <int> , <int> , <int> ] , [ <int> , <int> , <int> ] ) p l . columns ( <int> ) p l . columns ( <int> .. <int> ) p l . columns ( <int> , <int> ) Tk . mainloop end 
