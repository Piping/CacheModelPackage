module Rubinius class Mirror class Numeric < Mirror self . subject = :: Numeric def step_float_size ( value , limit , step , asc ) if ( asc && value > limit ) || ( ! asc && value < limit ) return <int> end if step . infinite? <int> else err = ( value . abs + limit . abs + ( limit - value ) . abs ) / step . abs * Float :: EPSILON if err . finite? err = <int> . <int> if err > <int> . <int> ( ( limit - value ) / step + err ) . floor + <int> else <int> end end end def step_size ( limit , step ) values = step_fetch_args ( limit , step ) value = values [ <int> ] limit = values [ <int> ] step = values [ <int> ] asc = values [ <int> ] is_float = values [ <int> ] if is_float step_float_size ( value , limit , step , asc ) else if ( asc && value > limit ) || ( ! asc && value < limit ) <int> else ( ( value - limit ) . abs + <int> ) . fdiv ( step . abs ) . ceil end end end def step_fetch_args ( limit , step ) raise ArgumentError , <str> if step == <int> value = @object asc = step > <int> if value . kind_of? Float or limit . kind_of? Float or step . kind_of? Float return FloatValue ( value ) , FloatValue ( limit ) , FloatValue ( step ) , asc , true else return value , limit , step , asc , false end end end end end 
