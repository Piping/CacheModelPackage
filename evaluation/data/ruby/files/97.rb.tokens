require <str> class TestFilters < JekyllUnitTest class JekyllFilter include Jekyll :: Filters attr_accessor <str> , <str> def initialize ( opts = { } ) @site = Jekyll :: Site . new ( Jekyll . configuration ( opts . merge ( <str> = > true ) ) ) @context = Liquid :: Context . new ( { } , { } , { <str> = > @site } ) end end context <str> do setup do @filter = JekyllFilter . new ( { <str> = > source_dir , <str> = > dest_dir , <str> = > <str> } ) @sample_time = Time . utc ( <int> , <oct> , <int> , <int> , <int> , <int> ) @sample_date = Date . parse ( <str> ) @time_as_string = <str> @time_as_numeric = <int> @array_of_objects = [ { <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> } ] end should <str> do assert_equal <str> , @filter . markdownify ( <str> ) end context <str> do should <str> do assert_equal <str> , @filter . smartify ( <str> ) assert_equal <str> , @filter . smartify ( <str> ) end should <str> do kramdown = JekyllFilter . new ( { <str> = > { <str> = > <str> } } ) assert_equal <str> , kramdown . smartify ( <str> ) end should <str> do assert_equal <str> , @filter . smartify ( <str> ) assert_equal <str> , @filter . smartify ( <str> ) end should <str> do assert_equal <str> , @filter . smartify ( <str> ) assert_equal <str> , @filter . smartify ( <str> ) end should <str> do assert_equal <str> , @filter . smartify ( <str> ) assert_equal <str> , @filter . smartify ( <str> ) assert_equal <str> , @filter . smartify ( <str> ) end end should <str> do assert_equal <str> , @filter . sassify ( <str> ) end should <str> do assert_equal <str> , @filter . scssify ( <str> ) end should <str> do assert_equal <str> , @filter . array_to_sentence_string ( [ ] ) end should <str> do assert_equal <str> , @filter . array_to_sentence_string ( [ <int> ] ) assert_equal <str> , @filter . array_to_sentence_string ( [ <str> ] ) end should <str> do assert_equal <str> , @filter . array_to_sentence_string ( [ <int> , <int> ] ) assert_equal <str> , @filter . array_to_sentence_string ( [ <str> , <str> ] ) end should <str> do assert_equal <str> , @filter . array_to_sentence_string ( [ <int> , <int> , <int> , <int> ] ) assert_equal <str> , @filter . array_to_sentence_string ( [ <str> , <str> , <str> , <str> ] ) end context <str> do context <str> do should <str> do assert_equal <str> , @filter . date_to_string ( @sample_time ) end should <str> do assert_equal <str> , @filter . date_to_long_string ( @sample_time ) end should <str> do assert_equal <str> , @filter . date_to_xmlschema ( @sample_time ) end should <str> do assert_equal <str> , @filter . date_to_rfc822 ( @sample_time ) end should <str> do t = Time . new ( <int> , <int> , <int> , <int> , <int> , <int> , <str> ) assert_equal <int> , t . utc_offset @filter . date_to_string ( t ) assert_equal <int> , t . utc_offset end end context <str> do should <str> do assert_equal <str> , @filter . date_to_string ( @sample_date ) end should <str> do assert_equal <str> , @filter . date_to_long_string ( @sample_date ) end should <str> do assert_equal <str> , @filter . date_to_xmlschema ( @sample_date ) end should <str> do assert_equal <str> , @filter . date_to_rfc822 ( @sample_date ) end end context <str> do should <str> do assert_equal <str> , @filter . date_to_string ( @time_as_string ) end should <str> do assert_equal <str> , @filter . date_to_long_string ( @time_as_string ) end should <str> do assert_equal <str> , @filter . date_to_xmlschema ( @time_as_string ) end should <str> do assert_equal <str> , @filter . date_to_rfc822 ( @time_as_string ) end end context <str> do should <str> do assert_equal <str> , @filter . date_to_string ( @time_as_numeric ) end should <str> do assert_equal <str> , @filter . date_to_long_string ( @time_as_numeric ) end should <str> do assert_match <str> , @filter . date_to_xmlschema ( @time_as_numeric ) end should <str> do assert_equal <str> , @filter . date_to_rfc822 ( @time_as_numeric ) end end end should <str> do assert_equal <str> , @filter . xml_escape ( <str> ) assert_equal <str> , @filter . xml_escape ( <str> ) end should <str> do assert_equal <str> , @filter . xml_escape ( nil ) end should <str> do assert_equal <str> , @filter . cgi_escape ( <str> ) end should <str> do assert_equal <str> , @filter . cgi_escape ( <str> ) end should <str> do assert_equal <str> , @filter . uri_escape ( <str> ) end context <str> do should <str> do assert_equal <str> , @filter . jsonify ( { <str> = > <int> } ) end should <str> do assert_equal <str> , @filter . jsonify ( [ <int> , <int> ] ) assert_equal <str> , @filter . jsonify ( [ { <str> = > <str> } , { <str> = > <str> } ] ) end class M < Struct . new ( <str> ) def to_liquid [ message ] end end class T < Struct . new ( <str> ) def to_liquid { <str> = > name , <str> = > <int> , <str> = > M . new ( { <str> = > <str> } ) , <str> = > true } end end should <str> do expected = [ { <str> = > <str> , <str> = > <int> , <str> = > [ { <str> = > <str> } ] , <str> = > true } , { <str> = > <str> , <str> = > <int> , <str> = > [ { <str> = > <str> } ] , <str> = > true } ] result = @filter . jsonify ( [ T . new ( <str> ) , T . new ( <str> ) ] ) assert_equal expected , JSON . parse ( result ) end should <str> do my_hash = { <str> = > Array . new ( <int> ) { | i | T . new ( i ) } } expected = { <str> = > [ { <str> = > <int> , <str> = > <int> , <str> = > [ { <str> = > <str> } ] , <str> = > true } , { <str> = > <int> , <str> = > <int> , <str> = > [ { <str> = > <str> } ] , <str> = > true } , { <str> = > <int> , <str> = > <int> , <str> = > [ { <str> = > <str> } ] , <str> = > true } ] } result = @filter . jsonify ( my_hash ) assert_equal expected , JSON . parse ( result ) end end context <str> do should <str> do @filter . site . process grouping = @filter . group_by ( @filter . site . pages , <str> ) grouping . each do | g | assert [ <str> , <str> , <str> ] . include? ( g [ <str> ] ) , <str> g [ <str> ] <str> case g [ <str> ] when <str> assert g [ <str> ] . is_a? ( Array ) , <str> assert_equal <int> , g [ <str> ] . size when <str> assert g [ <str> ] . is_a? ( Array ) , <str> assert_equal <int> , g [ <str> ] . size when <str> assert g [ <str> ] . is_a? ( Array ) , <str> assert_equal <int> , g [ <str> ] . size end end end should <str> do grouping = @filter . group_by ( @filter . site . pages , <str> ) grouping . each do | g | p g assert_equal g [ <str> ] . size , g [ <str> ] , <str> g [ <str> ] <str> end end end context <str> do should <str> do assert_equal <str> , @filter . where ( <str> , <str> , <str> ) end should <str> do hash = { <str> = > { <str> = > <str> } , <str> = > { <str> = > <str> } } assert_equal <int> , @filter . where ( hash , <str> , <str> ) . length assert_equal [ { <str> = > <str> } ] , @filter . where ( hash , <str> , <str> ) end should <str> do assert_equal <int> , @filter . where ( @array_of_objects , <str> , <str> ) . length end should <str> do hash = { <str> = > { <str> = > [ <str> , <str> ] } , <str> = > { <str> = > [ <str> ] } , <str> = > { <str> = > [ <str> , <str> ] } } assert_equal <int> , @filter . where ( hash , <str> , <str> ) . length end should <str> do hash = { <str> = > { <str> = > [ <str> , <str> ] } , <str> = > { <str> = > <str> } , <str> = > { <str> = > [ <str> , <str> ] } } assert_equal <int> , @filter . where ( hash , <str> , <str> ) . length end should <str> do hash = { <str> = > { <str> = > <str> } , <str> = > { <str> = > <str> } , <str> = > { <str> = > [ <str> , <str> ] } } assert_equal <int> , @filter . where ( hash , <str> , <str> ) . length end should <str> do hash = { <str> = > { <str> = > <int> . <int> , <str> = > false } , <str> = > { <str> = > <int> . <int> , <str> = > true } , <str> = > { <str> = > <int> . <int> , <str> = > true } , } results = @filter . where ( hash , <str> , <str> ) assert_equal <int> , results . length assert_equal <int> . <int> , results [ <int> ] [ <str> ] assert_equal <int> . <int> , results [ <int> ] [ <str> ] results = @filter . where ( hash , <str> , <int> . <int> ) assert_equal <int> , results . length assert_equal <int> . <int> , results [ <int> ] [ <str> ] end end context <str> do should <str> do err = assert_raises ArgumentError do @filter . sort ( nil ) end assert_equal <str> , err . message end should <str> do assert_equal [ <int> , <int> , <int> . <int> , <int> ] , @filter . sort ( [ <int> , <int> . <int> , <int> , <int> ] ) end should <str> do assert_equal [ <str> , <str> ] , @filter . sort ( [ <str> , <str> ] ) assert_equal [ { <str> = > <str> } , { <str> = > <str> } ] , @filter . sort ( [ { <str> = > <str> } , { <str> = > <str> } ] , <str> ) assert_equal [ <str> , <str> , <str> ] , @filter . sort ( [ <str> , <str> , <str> ] ) assert_equal [ <str> , <str> , <str> ] , @filter . sort ( [ <str> , <str> , <str> ] ) assert_equal [ <str> , <str> , <str> ] , @filter . sort ( [ <str> , <str> , <str> ] ) assert_equal [ <str> , <str> , <str> ] , @filter . sort ( [ <str> , <str> , <str> ] ) assert_equal [ <str> , <str> ] , @filter . sort ( [ <str> , <str> ] ) end should <str> do assert_equal [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] , @filter . sort ( [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] , <str> ) end should <str> do ary = [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] assert_equal [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] , @filter . sort ( ary , <str> ) assert_equal @filter . sort ( ary , <str> ) , @filter . sort ( ary , <str> , <str> ) end should <str> do assert_equal [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] , @filter . sort ( [ { <str> = > <int> } , { <str> = > <int> } , { <str> = > <int> } ] , <str> , <str> ) end end context <str> do should <str> do assert_equal <str> , @filter . inspect ( { <str> = > <int> } ) end end context <str> do should <str> do assert_equal <str> , @filter . slugify ( <str> ) end should <str> do assert_equal <str> , @filter . slugify ( <str> , <str> ) end end context <str> do should <str> do assert_equal <str> , @filter . push ( <str> , <str> ) end end context <str> do should <str> do assert_equal <str> , @filter . pop ( <str> ) end should <str> do assert_equal <str> , @filter . pop ( <str> , <int> ) end should <str> do assert_equal <str> , @filter . pop ( <str> , <str> ) end end context <str> do should <str> do assert_equal <str> , @filter . shift ( <str> ) end should <str> do assert_equal <str> , @filter . shift ( <str> , <int> ) end should <str> do assert_equal <str> , @filter . shift ( <str> , <str> ) end end context <str> do should <str> do assert_equal <str> , @filter . unshift ( <str> , <str> ) end end context <str> do should <str> do input = <str> assert_includes input , @filter . sample ( input ) end should <str> do input = <str> @filter . sample ( input , <int> ) . each do | val | assert_includes input , val end end end end end 
