require File . expand_path ( <str> , __FILE__ ) load_extension ( <str> ) describe <str> do before <str> do @s = CApiHashSpecs . new end describe <str> do it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . and_return ( <int> ) @s . rb_hash ( obj ) . should == <int> end it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . and_return ( bignum_value ( ) ) @s . rb_hash ( obj ) . should be_an_instance_of ( Fixnum ) end it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . and_return ( obj ) obj . should_receive ( <str> ) . and_return ( <int> ) @s . rb_hash ( obj ) . should == <int> end it <str> do obj = mock ( <str> ) obj . should_receive ( <str> ) . and_return ( nil ) lambda { @s . rb_hash ( obj ) } . should raise_error ( TypeError ) end end describe <str> do it <str> do @s . rb_hash_new . should == { } end it <str> do @s . rb_hash_new { } . default_proc . should be_nil end end describe <str> do it <str> do hsh = { } dup = @s . rb_hash_dup ( hsh ) dup . should == hsh dup . should_not equal ( hsh ) end end describe <str> do it <str> do @s . rb_hash_freeze ( { } ) . frozen? . should be_true end end describe <str> do it <str> do hsh = { <str> = > <str> } @s . rb_hash_aref ( hsh , <str> ) . should == <str> end it <str> do hsh = Hash . new ( <int> ) @s . rb_hash_aref ( hsh , <str> ) . should == <int> @s . rb_hash_aref_nil ( hsh , <str> ) . should be_false end it <str> do hsh = { } @s . rb_hash_aref ( hsh , <str> ) . should be_nil @s . rb_hash_aref_nil ( hsh , <str> ) . should be_true end end describe <str> do it <str> do hsh = { } @s . rb_hash_aset ( hsh , <str> , <str> ) . should == <str> hsh . should == { <str> = > <str> } end end describe <str> do it <str> do hsh = { <str> = > <str> } @s . rb_hash_clear ( hsh ) . should equal ( hsh ) hsh . should == { } end end describe <str> do it <str> do hsh = { <str> = > <str> } @s . rb_hash_delete ( hsh , <str> ) . should == <str> hsh . should == { } end end describe <str> do it <str> do h = { <str> = > <int> , <str> = > <int> , <str> = > <int> } @s . rb_hash_delete_if ( h ) { | k , v | v == <int> } h . should == { <str> = > <int> , <str> = > <int> } end it <str> do @s . rb_hash_delete_if ( { <str> = > <int> } ) . should be_an_instance_of ( enumerator_class ) end end describe <str> do it <str> do hsh = { <str> = > <str> , <str> = > <str> } out = @s . rb_hash_foreach ( hsh ) out . equal? ( hsh ) . should == false out . should == hsh end it <str> do hsh = { <str> = > <str> , <str> = > <str> } out = @s . rb_hash_foreach_stop ( hsh ) out . size . should == <int> end it <str> do hsh = { <str> = > <str> , <str> = > <str> } out = @s . rb_hash_foreach_delete ( hsh ) out . should == { <str> = > <str> , <str> = > <str> } hsh . should == { } end end extended_on <str> do describe <str> do it <str> do hsh = { <str> = > <str> , <str> = > <str> } @s . rb_hash_size ( hsh ) . should == <int> end it <str> do @s . rb_hash_size ( { } ) . should == <int> end end describe <str> do it <str> do hsh = { <str> = > <str> } @s . rb_hash_lookup ( hsh , <str> ) . should == <str> end it <str> do hsh = Hash . new ( <int> ) @s . rb_hash_lookup ( hsh , <str> ) . should be_nil @s . rb_hash_lookup_nil ( hsh , <str> ) . should be_true end it <str> do hsh = { } @s . rb_hash_lookup ( hsh , <str> ) . should be_nil @s . rb_hash_lookup_nil ( hsh , <str> ) . should be_true end end describe <str> do it <str> do hash = { <str> = > <str> } @s . rb_hash_lookup2 ( hash , <str> , nil ) . should == <str> end it <str> do hash = { } @s . rb_hash_lookup2 ( hash , <str> , <int> ) . should == <int> end end end describe <str> do it <str> do hash = { } @s . rb_hash_set_ifnone ( hash , <int> ) hash [ <str> ] . should == <int> end end end 
