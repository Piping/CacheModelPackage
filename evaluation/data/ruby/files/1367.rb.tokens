require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: MSSQL include Msf :: Auxiliary :: Scanner include Msf :: Auxiliary :: Report def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] ] , <str> = > [ [ <str> , { <str> = > <int> } ] ] ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptInt . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def print_with_underline ( str ) print_line ( str ) print_line ( <str> * str . length ) end def run_host ( ip ) sql_statement ( ) end def sql_statement ( ) headings = [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] sql = <str> datastore [ <str> ] <str> datastore [ <str> ] <str> print_line ( <str> ) print_status ( <str> rhost <str> rport <str> ) begin result = mssql_query ( sql , false ) if mssql_login_datastore column_data = result [ <str> ] print_status ( <str> rhost <str> rport <str> ) rescue print_status ( <str> rhost <str> rport <str> ) return end sql_data_tbl = Rex :: Ui :: Text :: Table . new ( <str> = > <str> , <str> = > <int> , <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) print_status ( <str> ) if ( column_data . count < <int> ) save_loot = <str> column_data . each { | row | print_status ( <str> row . to_s . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) <str> ) } return else save_loot = <str> column_data . each { | row | <int> . upto ( <int> ) { | col | row [ col ] = row [ col ] . strip . to_s } } print_line ( <str> ) end widths = [ <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ] ( column_data | headings ) . each { | row | <int> . upto ( <int> ) { | col | widths [ col ] = row [ col ] . to_s . length if row [ col ] . to_s . length > widths [ col ] } } buffer1 = <str> buffer2 = <str> headings . each { | row | <int> . upto ( <int> ) { | col | buffer1 += row [ col ] . ljust ( widths [ col ] + <int> ) buffer2 += row [ col ] + <str> } print_line ( buffer1 ) buffer2 = buffer2 . chomp ( <str> ) + <str> } buffer1 = <str> buffer2 = <str> headings . each { | row | <int> . upto ( <int> ) { | col | divider = <str> * widths [ col ] + <str> buffer1 += divider . ljust ( widths [ col ] + <int> ) } print_line ( buffer1 ) } buffer1 = <str> buffer2 = <str> print_line ( <str> ) column_data . each { | row | <int> . upto ( <int> ) { | col | buffer1 += row [ col ] . ljust ( widths [ col ] + <int> ) buffer2 += row [ col ] + <str> } print_line ( buffer1 ) buffer2 = buffer2 . chomp ( <str> ) + <str> sql_data_tbl << [ row [ <int> ] , row [ <int> ] , row [ <int> ] , row [ <int> ] , row [ <int> ] , row [ <int> ] , row [ <int> ] , row [ <int> ] ] buffer1 = <str> buffer2 = <str> print_line ( buffer1 ) } disconnect this_service = nil if framework . db and framework . db . active this_service = report_service ( <str> = > rhost , <str> = > rport , <str> = > <str> , <str> = > <str> ) end if ( save_loot == <str> ) filename = <str> datastore [ <str> ] <str> datastore [ <str> ] <str> path = store_loot ( <str> , <str> , datastore [ <str> ] , sql_data_tbl . to_csv , filename , <str> , this_service ) print_status ( <str> path <str> ) end end end 
