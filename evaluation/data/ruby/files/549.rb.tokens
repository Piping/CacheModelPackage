require <str> require <str> require <str> module Anemone class HTTP REDIRECT_LIMIT = <int> attr_reader <str> def initialize ( opts = { } ) @connections = { } @opts = opts @cookie_store = CookieStore . new ( @opts [ <str> ] ) end def fetch_page ( url , referer = nil , depth = nil ) fetch_pages ( url , referer , depth ) . last end def fetch_pages ( url , referer = nil , depth = nil ) begin url = URI ( url ) unless url . is_a? ( URI ) pages = [ ] get ( url , referer ) do | response , code , location , redirect_to , response_time | pages << Page . new ( location , <str> = > response . body . dup , <str> = > code , <str> = > response . to_hash , <str> = > referer , <str> = > depth , <str> = > redirect_to , <str> = > response_time ) end return pages rescue = > e if verbose? puts e . inspect puts e . backtrace end return [ Page . new ( url , <str> = > e ) ] end end def redirect_limit @opts [ <str> ] || REDIRECT_LIMIT end def user_agent @opts [ <str> ] end def accept_cookies? @opts [ <str> ] end private def get ( url , referer = nil ) limit = redirect_limit loc = url begin loc = url . merge ( loc ) if loc . relative? response , response_time = get_response ( loc , referer ) code = Integer ( response . code ) redirect_to = response . is_a? ( Net :: HTTPRedirection ) ? URI ( response [ <str> ] ) . normalize : nil yield response , code , loc , redirect_to , response_time limit -= <int> end while ( loc = redirect_to ) && allowed? ( redirect_to , url ) && limit > <int> end def get_response ( url , referer = nil ) full_path = url . query . nil? ? url . path : <str> url . path <str> url . query <str> opts = { } opts [ <str> ] = user_agent if user_agent opts [ <str> ] = referer . to_s if referer opts [ <str> ] = @cookie_store . to_s unless @cookie_store . empty? || ( ! accept_cookies? && @opts [ <str> ] . nil? ) if @opts [ <str> ] opts [ <str> ] = <str> + @opts [ <str> ] end if not @opts [ <str> ] . nil? @opts [ <str> ] . each do | hdr | k , v = hdr . split ( <str> , <int> ) opts [ k ] = v end end retries = <int> begin start = Time . now ( ) response = nil if @opts [ <str> ] response = @opts [ <str> ] . call ( connection ( url ) , full_path , opts ) else response = connection ( url ) . get ( full_path , opts ) end finish = Time . now ( ) response_time = ( ( finish - start ) * <int> ) . round @cookie_store . merge! ( response [ <str> ] ) if accept_cookies? return response , response_time rescue EOFError refresh_connection ( url ) retries += <int> retry unless retries > ( @opts [ <str> ] || <int> ) end end def connection ( url ) @connections [ url . host ] || = { } if conn = @connections [ url . host ] [ url . port ] return conn end refresh_connection url end def refresh_connection ( url ) http = nil if @opts [ <str> ] http = @opts [ <str> ] . call ( url ) else http = Net :: HTTP . new ( url . host , url . port ) if url . scheme == <str> http . use_ssl = true http . verify_mode = OpenSSL :: SSL :: VERIFY_NONE end end @connections [ url . host ] [ url . port ] = http . start end def verbose? @opts [ <str> ] end def allowed? ( to_url , from_url ) to_url . host . nil? || ( to_url . host == from_url . host ) end end end 
