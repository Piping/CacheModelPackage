require <str> class TestObjectSpace < Test :: Unit :: TestCase def self . deftest_id2ref ( obj ) <str> =~ caller [ <int> ] file = $` line = $1 . to_i code = << <str> End <str> <str> End eval code , binding , file , line end deftest_id2ref ( - <hex> ) deftest_id2ref ( - <hex> ) deftest_id2ref ( - <hex> ) deftest_id2ref ( - <hex> ) deftest_id2ref ( - <int> ) deftest_id2ref ( <int> ) deftest_id2ref ( <int> ) deftest_id2ref ( <hex> ) deftest_id2ref ( <hex> ) deftest_id2ref ( <hex> ) deftest_id2ref ( <hex> ) deftest_id2ref ( <str> ) deftest_id2ref ( <str> ) deftest_id2ref ( <str> ) deftest_id2ref ( Object . new ) deftest_id2ref ( self ) deftest_id2ref ( true ) deftest_id2ref ( false ) deftest_id2ref ( nil ) def test_count_objects h = { } ObjectSpace . count_objects ( h ) assert_kind_of ( Hash , h ) assert_empty ( h . keys . delete_if { | x | x . is_a? ( Symbol ) || x . is_a? ( Integer ) } ) assert_empty ( h . values . delete_if { | x | x . is_a? ( Integer ) } ) h = ObjectSpace . count_objects assert_kind_of ( Hash , h ) assert_empty ( h . keys . delete_if { | x | x . is_a? ( Symbol ) || x . is_a? ( Integer ) } ) assert_empty ( h . values . delete_if { | x | x . is_a? ( Integer ) } ) assert_raise ( TypeError ) { ObjectSpace . count_objects ( <int> ) } h0 = { <str> = > <int> } h = ObjectSpace . count_objects ( h0 ) assert_same ( h0 , h ) assert_equal ( <int> , h0 [ <str> ] ) end def test_finalizer assert_in_out_err ( [ <str> , <<- <str> END <str> ] , <str> , <str> , [ ] ) <str> END assert_raise ( ArgumentError ) { ObjectSpace . define_finalizer ( [ ] , Object . new ) } code = proc do | priv | <<- <str> CODE <str> <str> CODE end assert_in_out_err ( [ ] , code [ <str> ] , [ <str> ] ) assert_in_out_err ( [ ] , code [ <str> ] , [ <str> ] ) c = EnvUtil . labeled_class ( <str> ) . new o = Object . new assert_raise_with_message ( ArgumentError , <str> ) { ObjectSpace . define_finalizer ( o , c ) } end def test_each_object klass = Class . new new_obj = klass . new found = [ ] count = ObjectSpace . each_object ( klass ) do | obj | found << obj end assert_equal ( <int> , count ) assert_equal ( <int> , found . size ) assert_same ( new_obj , found [ <int> ] ) end def test_each_object_enumerator klass = Class . new new_obj = klass . new found = [ ] counter = ObjectSpace . each_object ( klass ) assert_equal ( <int> , counter . each { | obj | found << obj } ) assert_equal ( <int> , found . size ) assert_same ( new_obj , found [ <int> ] ) end def test_each_object_no_gabage assert_separately ( [ ] , <<- <str> End <str> ) <str> End end def test_each_object_recursive_key assert_normal_exit ( << - <str> , <str> ) h = { [ <str> ] = > nil } p Thread . current [ <str> ] end ; end def test_each_object_singleton_class assert_separately ( [ ] , <<- <str> End <str> ) <str> End klass = Class . new instance = klass . new sclass = instance . singleton_class meta = klass . singleton_class assert_kind_of ( meta , sclass ) assert_include ( ObjectSpace . each_object ( meta ) . to_a , sclass ) end end 
