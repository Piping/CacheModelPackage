require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Smtp include Msf :: Auxiliary :: Scanner include Msf :: Auxiliary :: Report def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > [ <str> , <str> , ] , <str> = > MSF_LICENSE ) register_options ( [ OptBool . new ( <str> , [ true , <str> , false ] ) , ] , self . class ) end def run_host ( ip ) begin connect banner_sanitized = Rex :: Text . to_hex_ascii ( banner . to_s ) print_status ( <str> banner_sanitized <str> ) report_service ( <str> = > rhost , <str> = > rport , <str> = > <str> , <str> = > banner ) if datastore [ <str> ] if banner_sanitized =~ <str> serverhost = $1 end mailfromuser = datastore [ <str> ] . split ( <str> ) . first mailfromdomain = datastore [ <str> ] . split ( <str> ) . last mailtouser = datastore [ <str> ] . split ( <str> ) . first mailtodomain = datastore [ <str> ] . split ( <str> ) . last do_test_relay ( <int> , <str> , <str> datastore [ <str> ] <str> ) do_test_relay ( <int> , <str> datastore [ <str> ] <str> , <str> datastore [ <str> ] <str> ) do_test_relay ( <int> , <str> mailfromuser <str> serverhost <str> , <str> datastore [ <str> ] <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> rhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> rhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> serverhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> rhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> rhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtouser <str> mailtodomain <str> serverhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> rhost <str> mailtouser <str> mailtodomain <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> serverhost <str> mailtouser <str> mailtodomain <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtodomain <str> mailtouser <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtodomain <str> mailtouser <str> rhost <str> ) do_test_relay ( <int> , <str> mailfromuser <str> rhost <str> , <str> mailtodomain <str> mailtouser <str> serverhost <str> ) else do_test_relay ( nil , <str> datastore [ <str> ] <str> , <str> datastore [ <str> ] <str> ) end rescue print_error ( <str> ) return end end def do_test_relay ( testnumber , mailfrom , mailto ) begin connect res = raw_send_recv ( <str> ) vprint_status ( <str> res . inspect <str> ) res = raw_send_recv ( <str> mailfrom <str> ) vprint_status ( <str> res . inspect <str> ) res = raw_send_recv ( <str> mailto <str> ) vprint_status ( <str> res . inspect <str> ) res = raw_send_recv ( <str> ) vprint_status ( <str> res . inspect <str> ) res = raw_send_recv ( <str> Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) <str> ) vprint_status ( <str> res . inspect <str> ) if res =~ <str> if testnumber . nil? print_good ( <str> mailfrom <str> mailto <str> ) else print_good ( <str> testnumber <str> mailfrom <str> mailto <str> ) end else if testnumber . nil? print_status <str> else print_status <str> testnumber <str> end end rescue print_error ( <str> testnumber <str> ) return end end end 
