require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Auxiliary :: Report include Msf :: Exploit :: Remote :: Udp include Msf :: Auxiliary :: UDPScanner include Msf :: Auxiliary :: NTP include Msf :: Auxiliary :: DRDoS def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > MSF_LICENSE ) end def scanner_process ( data , shost , sport ) @results [ shost ] || = [ ] @results [ shost ] << Rex :: Proto :: NTP :: NTPControl . new ( data ) end def scanner_prescan ( batch ) @results = { } @probe = Rex :: Proto :: NTP :: NTPControl . new @probe . version = datastore [ <str> ] @probe . operation = <int> end def scanner_postscan ( batch ) @results . keys . each do | k | response_map = { @probe = > @results [ k ] } report_service ( <str> = > k , <str> = > <str> , <str> = > rport , <str> = > <str> ) peer = <str> k <str> rport <str> vulnerable , proof = prove_amplification ( response_map ) what = <str> if vulnerable print_good ( <str> peer <str> what <str> proof <str> ) report_vuln ( { <str> = > k , <str> = > rport , <str> = > <str> , <str> = > what , <str> = > self . references } ) else vprint_status ( <str> peer <str> what <str> proof <str> ) end end end end 
