require <str> module Bosh::Director module Api::Controllers class DeploymentsController < BaseController get <str> do instance = @instance_manager . find_by_name ( params [ <str> ] , params [ <str> ] , params [ <str> ] ) response = { <str> : params [ <str> ] , <str> : instance . job , <str> : instance . index , id : instance . uuid , <str> : instance . state , <str> : instance . persistent_disks . map { | d | d . disk_cid } } json_encode ( response ) end put <str> , <str> = > <str> do options = { <str> = > { params [ <str> ] = > { <str> = > params [ <str> ] } } } options [ <str> ] = params [ <str> ] if params [ <str> ] == <str> deployment = @deployment_manager . find_by_name ( params [ <str> ] ) manifest = ( ( request . content_length . nil? || request . content_length . to_i == <int> ) && ( params [ <str> ] ) ) ? StringIO . new ( deployment . manifest ) : request . body latest_cloud_config = Bosh :: Director :: Api :: CloudConfigManager . new . latest task = @deployment_manager . create_deployment ( current_user , manifest , latest_cloud_config , options ) redirect <str> task . id <str> end put <str> , <str> = > <str> do validate_instance_index_or_id ( params [ <str> ] ) instance = @instance_manager . find_by_name ( params [ <str> ] , params [ <str> ] , params [ <str> ] ) index = instance . index options = { <str> = > { params [ <str> ] = > { <str> = > { index = > params [ <str> ] } , } } , } options [ <str> ] = params [ <str> ] if params [ <str> ] == <str> deployment = @deployment_manager . find_by_name ( params [ <str> ] ) manifest = ( request . content_length . nil? || request . content_length . to_i == <int> ) ? StringIO . new ( deployment . manifest ) : request . body latest_cloud_config = Bosh :: Director :: Api :: CloudConfigManager . new . latest task = @deployment_manager . create_deployment ( current_user , manifest , latest_cloud_config , options ) redirect <str> task . id <str> end get <str> do deployment = params [ <str> ] job = params [ <str> ] index_or_id = params [ <str> ] options = { <str> = > params [ <str> ] . to_s . strip , <str> = > params [ <str> ] . to_s . strip . split ( <str> ) } task = @instance_manager . fetch_logs ( current_user , deployment , job , index_or_id , options ) redirect <str> task . id <str> end get <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) json_encode ( @snapshot_manager . snapshots ( deployment ) ) end get <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) json_encode ( @snapshot_manager . snapshots ( deployment , params [ <str> ] , params [ <str> ] ) ) end post <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) options = { <str> : false } task = @snapshot_manager . create_deployment_snapshot_task ( current_user , deployment , options ) redirect <str> task . id <str> end put <str> , <str> : <str> do payload = json_decode ( request . body ) @resurrector_manager . set_pause_for_instance ( params [ <str> ] , params [ <str> ] , params [ <str> ] , payload [ <str> ] ) end post <str> do if params [ <str> ] . to_s =~ <str> instance = @instance_manager . find_by_name ( params [ <str> ] , params [ <str> ] , params [ <str> ] ) else instance = @instance_manager . filter_by ( <str> : params [ <str> ] ) . first end options = { <str> : false } task = @snapshot_manager . create_snapshot_task ( current_user , instance , options ) redirect <str> task . id <str> end delete <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) task = @snapshot_manager . delete_deployment_snapshots_task ( current_user , deployment ) redirect <str> task . id <str> end delete <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) @snapshot_manager . find_by_cid ( deployment , params [ <str> ] ) task = @snapshot_manager . delete_snapshots_task ( current_user , [ params [ <str> ] ] ) redirect <str> task . id <str> end get <str> , <str> : <str> do latest_cloud_config = Api :: CloudConfigManager . new . latest deployments = @deployment_manager . find_available ( token_scopes ) . map do | deployment | cloud_config = if deployment . cloud_config . nil? <str> elsif deployment . cloud_config == latest_cloud_config <str> else <str> end { <str> = > deployment . name , <str> = > deployment . release_versions . map do | rv | { <str> = > rv . release . name , <str> = > rv . version . to_s } end , <str> = > deployment . stemcells . map do | sc | { <str> = > sc . name , <str> = > sc . version } end , <str> = > cloud_config } end json_encode ( deployments ) end get <str> , <str> : <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) @deployment_manager . deployment_to_json ( deployment ) end get <str> , <str> : <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) format = params [ <str> ] if format == <str> task = @vm_state_manager . fetch_vm_state ( current_user , deployment , format ) redirect <str> task . id <str> else @deployment_manager . deployment_instances_to_json ( deployment ) end end delete <str> do deployment = @deployment_manager . find_by_name ( params [ <str> ] ) options = { } options [ <str> ] = true if params [ <str> ] == <str> options [ <str> ] = true if params [ <str> ] == <str> task = @deployment_manager . delete_deployment ( current_user , deployment , options ) redirect <str> task . id <str> end get <str> do properties = @property_manager . get_properties ( params [ <str> ] ) . map do | property | { <str> = > property . name , <str> = > property . value } end json_encode ( properties ) end get <str> do property = @property_manager . get_property ( params [ <str> ] , params [ <str> ] ) json_encode ( <str> = > property . value ) end post <str> , <str> = > [ <str> ] do payload = json_decode ( request . body ) @property_manager . create_property ( params [ <str> ] , payload [ <str> ] , payload [ <str> ] ) status ( <int> ) end post <str> , <str> = > [ <str> ] do payload = json_decode ( request . body ) task = @instance_manager . ssh ( current_user , payload ) redirect <str> task . id <str> end put <str> , <str> = > [ <str> ] do payload = json_decode ( request . body ) @property_manager . update_property ( params [ <str> ] , params [ <str> ] , payload [ <str> ] ) status ( <int> ) end delete <str> do @property_manager . delete_property ( params [ <str> ] , params [ <str> ] ) status ( <int> ) end post <str> do start_task { @problem_manager . perform_scan ( current_user , params [ <str> ] ) } end get <str> do problems = @problem_manager . get_problems ( params [ <str> ] ) . map do | problem | { <str> = > problem . id , <str> = > problem . type , <str> = > problem . data , <str> = > problem . description , <str> = > problem . resolutions } end json_encode ( problems ) end put <str> , <str> = > [ <str> ] do payload = json_decode ( request . body ) start_task { @problem_manager . apply_resolutions ( current_user , params [ <str> ] , payload [ <str> ] ) } end put <str> , <str> = > <str> do jobs_json = json_decode ( request . body ) [ <str> ] payload = convert_job_instance_hash ( jobs_json ) deployment = @deployment_manager . find_by_name ( params [ <str> ] ) if deployment_has_instance_to_resurrect? ( deployment ) start_task { @problem_manager . scan_and_fix ( current_user , params [ <str> ] , payload ) } end end post <str> , <str> = > <str> do options = { } options [ <str> ] = true if params [ <str> ] == <str> options [ <str> ] = params [ <str> ] if params [ <str> ] if params [ <str> ] @logger . debug ( <str> params [ <str> ] <str> ) context = JSON . parse ( params [ <str> ] ) cloud_config = Api :: CloudConfigManager . new . find_by_id ( context [ <str> ] ) else cloud_config = Api :: CloudConfigManager . new . latest end options . merge! ( <str> = > token_scopes ) task = @deployment_manager . create_deployment ( current_user , request . body , cloud_config , options ) redirect <str> task . id <str> end post <str> , <str> = > <str> do deployment = Models :: Deployment [ name : params [ <str> ] ] if deployment before_manifest = Manifest . load_from_text ( deployment . manifest , deployment . cloud_config ) before_manifest . resolve_aliases else before_manifest = Manifest . load_from_text ( nil , nil ) end after_cloud_config = Bosh :: Director :: Api :: CloudConfigManager . new . latest after_manifest = Manifest . load_from_text ( request . body , after_cloud_config ) after_manifest . resolve_aliases diff = before_manifest . diff ( after_manifest ) json_encode ( { <str> = > { <str> = > after_cloud_config ? after_cloud_config . id : nil , } , <str> = > diff . map { | l | [ l . to_s , l . status ] } } ) end post <str> do deployment_name = params [ <str> ] errand_name = params [ <str> ] keep_alive = json_decode ( request . body ) [ <str> ] || FALSE task = JobQueue . new . enqueue ( current_user , Jobs :: RunErrand , <str> errand_name <str> deployment_name <str> , [ deployment_name , errand_name , keep_alive ] , ) redirect <str> task . id <str> end get <str> , <str> : <str> do deployment_plan = load_deployment_plan errands = deployment_plan . jobs . select ( & <str> ) errand_data = errands . map do | errand | { <str> = > errand . name } end json_encode ( errand_data ) end private def load_deployment_plan deployment_model = @deployment_manager . find_by_name ( params [ <str> ] ) planner_factory = Bosh :: Director :: DeploymentPlan :: PlannerFactory . create ( Config . logger ) planner_factory . create_from_model ( deployment_model ) end def convert_job_instance_hash ( hash ) hash . reduce ( [ ] ) do | jobs , kv | job , indicies = kv jobs + indicies . map { | index | [ job , index ] } end end def deployment_has_instance_to_resurrect? ( deployment ) false if deployment . nil? filter = { <str> : deployment . id , <str> : false } instances = @instance_manager . filter_by ( filter ) instances . any? end def validate_instance_index_or_id ( str ) begin Integer ( str ) rescue ArgumentError if str !~ <str> raise InstanceInvalidIndex , <str> str <str> end end end end end end 
