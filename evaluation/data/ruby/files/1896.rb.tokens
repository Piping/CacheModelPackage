require <str> require <str> require <str> require <str> require <str> require <str> alias old_send send module Net module DNS include Logger :: Severity class Resolver class NextNameserver < RuntimeError end Defaults = { <str> = > <str> , <str> = > $stdout , <str> = > <int> , <str> = > [ ] , <str> = > [ IPAddr . new ( <str> ) ] , <str> = > <str> , <str> = > <int> , <str> = > IPAddr . new ( <str> ) , <str> = > <int> , <str> = > <int> , <str> = > true , <str> = > true , <str> = > true , <str> = > false , <str> = > false , <str> = > <int> , <str> = > TcpTimeout . new ( <int> ) , <str> = > UdpTimeout . new ( <int> ) } def initialize ( config = { } ) raise ResolverArgumentError , <str> unless config . kind_of? Hash @config = Defaults . merge config @raw = false @logger = Logger . new ( @config [ <str> ] ) @logger . level = $DEBUG ? Logger :: DEBUG : Logger :: WARN parse_config_file parse_environment_variables config . each do | key , val | next if key == <str> or key == <str> begin eval <str> key . to_s <str> rescue NoMethodError raise ResolverArgumentError , <str> key <str> end end end def searchlist @config [ <str> ] . inspect end def searchlist = ( arg ) case arg when String @config [ <str> ] = [ arg ] if valid? arg @logger . info <str> @config [ <str> ] . inspect <str> when Array @config [ <str> ] = arg if arg . all? { | x | valid? x } @logger . info <str> @config [ <str> ] . inspect <str> else raise ResolverArgumentError , <str> end end def nameservers arr = [ ] @config [ <str> ] . each do | x | arr << x . to_s end arr end alias_method <str> , <str> def nameservers = ( arg ) case arg when String begin @config [ <str> ] = [ IPAddr . new ( arg ) ] @logger . info <str> @config [ <str> ] . inspect <str> rescue ArgumentError nameservers_from_name ( arg ) end when IPAddr @config [ <str> ] = [ arg ] @logger . info <str> @config [ <str> ] . inspect <str> when Array @config [ <str> ] = [ ] arg . each do | x | @config [ <str> ] << case x when String begin IPAddr . new ( x ) rescue ArgumentError nameservers_from_name ( arg ) return end when IPAddr x else raise ResolverArgumentError , <str> end end @logger . info <str> @config [ <str> ] . inspect <str> else raise ResolverArgumentError , <str> end end alias_method ( <str> , <str> ) def domain @config [ <str> ] . inspect end def domain = ( name ) @config [ <str> ] = name if valid? name end def packet_size @config [ <str> ] end def port @config [ <str> ] end def port = ( num ) if ( <int> .. <int> ) . include? num @config [ <str> ] = num @logger . info <str> num <str> else raise ResolverArgumentError , <str> num <str> end end def source_port @config [ <str> ] end alias srcport source_port def source_port = ( num ) unless root? raise ResolverPermissionError , <str> end if ( <int> .. <int> ) . include? ( num ) @config [ <str> ] = num else raise ResolverArgumentError , <str> num <str> end end alias srcport = source_port = def source_address @config [ <str> ] . to_s end alias srcaddr source_address def source_address = ( addr ) unless addr . respond_to? <str> raise ResolverArgumentError , <str> addr <str> end begin port = rand ( <int> ) + <int> @logger . warn <str> addr <str> port <str> a = TCPServer . new ( addr . to_s , port ) rescue SystemCallError = > e case e . errno when <int> @logger . warn <str> retry when <int> @raw = true @logger . warn <str> else raise SystemCallError , e end ensure a . close end case addr when String @config [ <str> ] = IPAddr . new ( string ) @logger . info <str> @config [ <str> ] <str> when IPAddr @config [ <str> ] = addr @logger . info <str> @config [ <str> ] <str> else raise ArgumentError , <str> end end alias srcaddr = source_address = def retry_interval @config [ <str> ] end alias retrans retry_interval def retry_interval = ( num ) if num > <int> @config [ <str> ] = num @logger . info <str> num <str> else raise ResolverArgumentError , <str> end end alias retrans = retry_interval = def retry_number @config [ <str> ] end def retry_number = ( num ) if num . kind_of? Integer and num > <int> @config [ <str> ] = num @logger . info <str> num <str> else raise ResolverArgumentError , <str> end end alias_method ( <str> , <str> ) def recursive? @config [ <str> ] end alias_method <str> , <str> alias_method <str> , <str> def recursive = ( bool ) case bool when TrueClass , FalseClass @config [ <str> ] = bool @logger . info ( <str> bool <str> ) else raise ResolverArgumentError , <str> end end alias_method <str> = , <str> = def state str = <str> i = <int> @config . each do | key , val | if key == <str> or key == <str> str << <str> key <str> val <str> else str << <str> key <str> eval ( key . to_s ) <str> end str << <str> if i % <int> == <int> i += <int> end str end alias print state alias inspect state def defname? @config [ <str> ] end alias defname defname? def defname = ( bool ) case bool when TrueClass , FalseClass @config [ <str> ] = bool @logger . info ( <str> bool <str> ) else raise ResolverArgumentError , <str> end end def dns_search @config [ <str> ] end alias_method <str> , <str> def dns_search = ( bool ) case bool when TrueClass , FalseClass @config [ <str> ] = bool @logger . info ( <str> bool <str> ) else raise ResolverArgumentError , <str> end end alias_method ( <str> , <str> ) def use_tcp? @config [ <str> ] end alias_method <str> , <str> alias_method <str> , <str> def use_tcp = ( bool ) case bool when TrueClass , FalseClass @config [ <str> ] = bool @logger . info ( <str> bool <str> ) else raise ResolverArgumentError , <str> end end alias usevc = use_tcp = def ignore_truncated? @config [ <str> ] end alias_method <str> , <str> def ignore_truncated = ( bool ) case bool when TrueClass , FalseClass @config [ <str> ] = bool @logger . info ( <str> bool <str> ) else raise ResolverArgumentError , <str> end end def tcp_timeout @config [ <str> ] . to_s end def tcp_timeout = ( secs ) @config [ <str> ] = TcpTimeout . new ( secs ) @logger . info ( <str> @config [ <str> ] <str> ) end def udp_timeout @config [ <str> ] . to_s end def udp_timeout = ( secs ) @config [ <str> ] = UdpTimeout . new ( secs ) @logger . info ( <str> @config [ <str> ] <str> ) end def log_file = ( log ) @logger . close @config [ <str> ] = log @logger = Logger . new ( @config [ <str> ] ) @logger . level = $DEBUG ? Logger :: DEBUG : Logger :: WARN end def logger = ( logger ) if logger . kind_of? Logger @logger . close @logger = logger else raise ResolverArgumentError , <str> end end def log_level = ( level ) @logger . level = level end def search ( name , type = Net :: DNS :: A , cls = Net :: DNS :: IN ) if name . include? <str> @logger . debug <str> name <str> Net :: DNS :: RR :: Types . new ( type ) <str> Net :: DNS :: RR :: Classes . new ( cls ) <str> ans = query ( name , type , cls ) return ans if ans && ans . header && ans . header . anCount > <int> end if name !~ <str> and @config [ <str> ] @config [ <str> ] . each do | domain | newname = name + <str> + domain @logger . debug <str> newname <str> Net :: DNS :: RR :: Types . new ( type ) <str> Net :: DNS :: RR :: Classes . new ( cls ) <str> ans = query ( newname , type , cls ) return ans if ans && ans . header && ans . header . anCount > <int> end end @logger . debug <str> name <str> Net :: DNS :: RR :: Types . new ( type ) <str> Net :: DNS :: RR :: Classes . new ( cls ) <str> query ( name + <str> , type , cls ) end def query ( name , type = Net :: DNS :: A , cls = Net :: DNS :: IN ) if name !~ <str> and name !~ <str> and @config [ <str> ] name += <str> + @config [ <str> ] end @logger . debug <str> name <str> Net :: DNS :: RR :: Types . new ( type ) <str> Net :: DNS :: RR :: Classes . new ( cls ) <str> begin send ( name , type , cls ) rescue :: NoResponseError return end end def send ( argument , type = Net :: DNS :: A , cls = Net :: DNS :: IN ) if @config [ <str> ] . size == <int> raise ResolverError , <str> end method = <str> if argument . kind_of? Net :: DNS :: Packet packet = argument else packet = make_query_packet ( argument , type , cls ) end packet_data = packet . data packet_size = packet_data . size if packet_size > @config [ <str> ] if @raw @logger . info <str> packet_size <str> method = <str> else @logger . info <str> packet_size <str> method = <str> end else if @raw @logger . info <str> packet_size <str> method = <str> elsif use_tcp? @logger . info <str> packet_size <str> method = <str> else @logger . info <str> packet_size <str> end end if type == Net :: DNS :: AXFR if @raw @logger . warn <str> method = <str> else @logger . warn <str> method = <str> end end ans = self . old_send ( method , packet , packet_data ) unless ans @logger . fatal <str> raise NoResponseError end @logger . info <str> ans [ <int> ] . size <str> ans [ <int> ] [ <int> ] + <str> + ans [ <int> ] [ <int> ] . to_s <str> response = Net :: DNS :: Packet . parse ( ans [ <int> ] , ans [ <int> ] ) if response . header . truncated? and not ignore_truncated? @logger . warn <str> self . use_tcp = true begin return send ( argument , type , cls ) ensure self . use_tcp = false end end return response end def axfr ( name , cls = Net :: DNS :: IN ) @logger . info <str> name <str> cls <str> if @config [ <str> ] . size == <int> raise ResolverError , <str> end method = <str> packet = make_query_packet ( name , Net :: DNS :: AXFR , cls ) packet_data = packet . data packet_size = packet_data . size if @raw @logger . warn <str> method = <str> else @logger . warn <str> method = <str> end answers = [ ] soa = <int> self . old_send ( method , packet , packet_data ) do | ans | @logger . info <str> ans [ <int> ] . size <str> ans [ <int> ] [ <int> ] + <str> + ans [ <int> ] [ <int> ] . to_s <str> begin response = Net :: DNS :: Packet . parse ( ans [ <int> ] , ans [ <int> ] ) if response && response . answer && response . answer [ <int> ] && response . answer [ <int> ] . type == <str> soa += <int> if soa > = <int> break end end answers << response rescue NameError = > e @logger . warn <str> e . message <str> end end if answers . empty? @logger . fatal <str> raise NoResponseError end return answers end def mx ( name , cls = Net :: DNS :: IN ) arr = [ ] send ( name , Net :: DNS :: MX , cls ) . answer . each do | entry | arr << entry if entry . type == <str> end return arr . sort_by { | a | a . preference } end private def parse_config_file if RUBY_PLATFORM =~ <str> require <str> arr = Win32 :: Resolv . get_resolv_info self . domain = arr [ <int> ] self . nameservers = arr [ <int> ] else IO . foreach ( @config [ <str> ] ) do | line | line . gsub! ( <str> , <str> ) next unless line =~ <str> case line when <str> self . domain = $1 when <str> self . searchlist = $1 . split ( <str> ) when <str> self . nameservers = $1 . split ( <str> ) end end end end def parse_environment_variables if ENV [ <str> ] self . nameservers = ENV [ <str> ] . split ( <str> ) end if ENV [ <str> ] self . searchlist = ENV [ <str> ] . split ( <str> ) end if ENV [ <str> ] self . domain = ENV [ <str> ] end if ENV [ <str> ] ENV [ <str> ] . split ( <str> ) . each do | opt | name , val = opt . split ( <str> ) begin eval ( <str> name <str> val <str> ) rescue NoMethodError raise ResolverArgumentError , <str> name <str> end end end end def nameservers_from_name ( arg ) arr = [ ] arg . split ( <str> ) . each do | name | Resolver . new . search ( name ) . each_address do | ip | arr << ip end end @config [ <str> ] << arr end def make_query_packet ( string , type , cls ) case string when IPAddr name = string . reverse type = Net :: DNS :: PTR @logger . warn <str> string <str> when <str> begin name = IPAddr . new ( string ) . reverse type = Net :: DNS :: PTR rescue ArgumentError name = string if valid? string end else name = string if valid? string end packet = Net :: DNS :: Packet . new ( name , type , cls ) if packet . query? packet . header . recursive = @config [ <str> ] ? <int> : <int> end packet end def send_tcp ( packet , packet_data ) ans = nil length = [ packet_data . size ] . pack ( <str> ) @config [ <str> ] . each do | ns | begin socket = Socket . new ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) socket . bind ( Socket . pack_sockaddr_in ( @config [ <str> ] , @config [ <str> ] . to_s ) ) sockaddr = Socket . pack_sockaddr_in ( @config [ <str> ] , ns . to_s ) @config [ <str> ] . timeout do socket . connect ( sockaddr ) @logger . info <str> ns <str> @config [ <str> ] <str> socket . write ( length + packet_data ) got_something = false loop do buffer = <str> begin ans = socket . recv ( Net :: DNS :: INT16SZ ) rescue :: Errno :: ECONNRESET ans = <str> end if ans . size == <int> if got_something break else @logger . warn <str> ns <str> raise NextNameserver end end got_something = true len = ans . unpack ( <str> ) [ <int> ] @logger . info <str> len <str> if len == <int> @logger . warn <str> ns <str> raise NextNameserver end while ( buffer . size < len ) left = len - buffer . size temp , from = socket . recvfrom ( left ) buffer += temp end unless buffer . size == len @logger . warn <str> ns <str> raise NextNameserver end if block_given? yield [ buffer , [ <str> , @config [ <str> ] , ns . to_s , ns . to_s ] ] else return [ buffer , [ <str> , @config [ <str> ] , ns . to_s , ns . to_s ] ] end end end rescue NextNameserver next rescue Timeout :: Error @logger . warn <str> ns <str> next ensure socket . close end end return nil end def send_udp ( packet , packet_data ) socket = UDPSocket . new socket . bind ( @config [ <str> ] . to_s , @config [ <str> ] ) ans = nil response = <str> @config [ <str> ] . each do | ns | begin @config [ <str> ] . timeout do @logger . info <str> ns <str> @config [ <str> ] <str> socket . send ( packet_data , <int> , ns . to_s , @config [ <str> ] ) ans = socket . recvfrom ( @config [ <str> ] ) end break if ans rescue Timeout :: Error @logger . warn <str> ns <str> next end end ans end def valid? ( name ) if name =~ <str> raise ResolverArgumentError , <str> name <str> else true end end end end end class ResolverError < ArgumentError end class ResolverArgumentError < ArgumentError end class NoResponseError < StandardError end module ExtendHash def key_downcase! hsh = Hash . new self . each do | key , val | hsh [ key . downcase ] = val end self . replace ( hsh ) end end class Hash include ExtendHash end 
