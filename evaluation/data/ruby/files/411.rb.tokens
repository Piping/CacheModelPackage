require File . expand_path ( File . dirname ( __FILE__ ) + <str> ) describe InfoRequest do describe <str> do it <str> do expect ( InfoRequest . new . law_used ) . to eq ( <str> ) end it <str> do body = FactoryGirl . create ( <str> , <str> = > <str> ) expect ( body . info_requests . build . law_used ) . to eq ( <str> ) end it <str> do info_request = FactoryGirl . create ( <str> ) body = FactoryGirl . create ( <str> , <str> = > <str> ) info_request . update_attributes ( <str> = > body . id ) expect_any_instance_of ( InfoRequest ) . not_to receive ( <str> = ) . and_call_original InfoRequest . find ( info_request . id ) end it <str> do info_request = FactoryGirl . create ( <str> , <str> = > <str> ) expect ( info_request . url_title ) . to eq ( <str> ) end it <str> do info_request = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > <str> ) expect ( info_request . url_title ) . to eq ( <str> ) end it <str> do allow ( InfoRequest ) . to receive ( <str> ) . with ( <str> , <str> = > nil ) . and_return ( mock_model ( InfoRequest ) ) allow ( InfoRequest ) . to receive ( <str> ) . with ( <str> , <str> = > nil ) . and_return ( mock_model ( InfoRequest ) ) allow ( InfoRequest ) . to receive ( <str> ) . with ( <str> , <str> = > nil ) . and_return ( nil ) info_request = InfoRequest . new ( <str> = > <str> ) expect ( info_request . url_title ) . to eq ( <str> ) end context <str> do it <str> do public_body = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) first_request = InfoRequest . new ( <str> = > <str> , <str> = > user , <str> = > public_body ) second_request = FactoryGirl . create ( <str> , <str> = > <str> ) first_request . save! expect ( first_request . url_title ) . to eq ( <str> ) end end end describe <str> do it <str> do request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . months . ago ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end it <str> do request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . months . ago - <int> . day ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end it <str> do request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . year . ago - <int> . day ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end context <str> do it <str> do allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . months . ago ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end it <str> do allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . months . ago - <int> . day ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end it <str> do allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) request = FactoryGirl . create ( <str> ) request . update_attributes ( <str> = > <int> . months . ago - <int> . day ) described_class . stop_new_responses_on_old_requests expect ( request . reload . allow_new_responses_from ) . to eq ( <str> ) end end end describe <str> do it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( info_request . incoming_messages . size ) . to eq ( <int> ) expect ( info_request . incoming_messages . last ) . to be_persisted end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( info_request . incoming_messages . first . raw_email . data ) . to eq ( raw_email ) expect ( info_request . incoming_messages . first . raw_email ) . to be_persisted end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( info_request . awaiting_description ) . to be true end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( info_request . info_request_events . last . incoming_message . id ) . to eq ( info_request . incoming_messages . last . id ) expect ( info_request . info_request_events . last ) . to be_response end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email , false , <str> ) expect ( info_request . info_request_events . last . params [ <str> ] ) . to eq ( <str> ) end context <str> do it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) notification = ActionMailer :: Base . deliveries . last expect ( notification . to ) . to include ( info_request . user . email ) expect ( ActionMailer :: Base . deliveries . size ) . to eq ( <int> ) ActionMailer :: Base . deliveries . clear end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( ActionMailer :: Base . deliveries ) . to be_empty ActionMailer :: Base . deliveries . clear end end context <str> do it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) holding_pen = InfoRequest . holding_pen_request msg = <str> \ <str> expect ( info_request . incoming_messages . size ) . to eq ( <int> ) expect ( holding_pen . incoming_messages . size ) . to eq ( <int> ) expect ( holding_pen . info_request_events . last . params [ <str> ] ) . to eq ( msg ) end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( info_request . incoming_messages . size ) . to eq ( <int> ) end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) expect ( info_request . reload . incoming_messages . size ) . to eq ( <int> ) end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) expect ( info_request . reload . incoming_messages . size ) . to eq ( <int> ) holding_pen = InfoRequest . holding_pen_request expect ( holding_pen . incoming_messages . size ) . to eq ( <int> ) msg = <str> \ <str> expect ( holding_pen . info_request_events . last . params [ <str> ] ) . to eq ( msg ) end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) expect ( info_request . reload . incoming_messages . size ) . to eq ( <int> ) holding_pen = InfoRequest . holding_pen_request expect ( holding_pen . incoming_messages . size ) . to eq ( <int> ) msg = <str> \ <str> expect ( holding_pen . info_request_events . last . params [ <str> ] ) . to eq ( msg ) end it <str> do info_request = FactoryGirl . create ( <str> ) info_request . allow_new_responses_from = <str> email , raw_email = email_and_raw_email err = InfoRequest :: ResponseGatekeeper :: UnknownResponseGatekeeperError expect { info_request . receive ( email , raw_email ) } . to raise_error ( err ) end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email , true ) expect ( info_request . incoming_messages . size ) . to eq ( <int> ) end it <str> do mocked_default_config = { <str> = > <str> , <str> = > <str> , <str> = > <int> } const = <str> \ <str> \ <str> \ <str> stub_const ( const , mocked_default_config ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > spam_email ) info_request . receive ( email , raw_email , true ) expect ( info_request . incoming_messages . size ) . to eq ( <int> ) end end context <str> do it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) bounce = ActionMailer :: Base . deliveries . first expect ( bounce . to ) . to include ( <str> ) ActionMailer :: Base . deliveries . clear end it <str> do info_request = FactoryGirl . create ( <str> ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) expect ( ActionMailer :: Base . deliveries ) . to be_empty ActionMailer :: Base . deliveries . clear end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email ( <str> = > <str> ) info_request . receive ( email , raw_email ) expect ( ActionMailer :: Base . deliveries ) . to be_empty ActionMailer :: Base . deliveries . clear end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( InfoRequest . holding_pen_request . incoming_messages . size ) . to eq ( <int> ) expect ( ActionMailer :: Base . deliveries . size ) . to eq ( <int> ) ActionMailer :: Base . deliveries . clear end it <str> do attrs = { <str> = > <str> , <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) email , raw_email = email_and_raw_email info_request . receive ( email , raw_email ) expect ( ActionMailer :: Base . deliveries ) . to be_empty expect ( InfoRequest . holding_pen_request . incoming_messages . size ) . to eq ( <int> ) ActionMailer :: Base . deliveries . clear end it <str> do attrs = { <str> = > <str> } info_request = FactoryGirl . create ( <str> , attrs ) info_request . update_attribute ( <str> , <str> ) email , raw_email = email_and_raw_email err = InfoRequest :: ResponseRejection :: UnknownResponseRejectionError expect { info_request . receive ( email , raw_email ) } . to raise_error ( err ) end end it <str> do info_request = FactoryGirl . create ( <str> ) info_request . update_attributes! ( <str> = > <str> , <str> = > <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF receive_incoming_mail ( spam_email , info_request . incoming_email , <str> ) expect ( InfoRequest . holding_pen_request . incoming_messages . size ) . to eq ( <int> ) end it <str> do info_request = FactoryGirl . create ( <str> ) mocked_default_config = { <str> = > <str> , <str> = > <str> , <str> = > <int> } const = <str> \ <str> \ <str> \ <str> stub_const ( const , mocked_default_config ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF receive_incoming_mail ( spam_email , info_request . incoming_email , <str> ) expect ( InfoRequest . holding_pen_request . incoming_messages . size ) . to eq ( <int> ) end it <str> do info_request = FactoryGirl . create ( <str> ) mocked_default_config = { <str> = > <str> , <str> = > <str> , <str> = > <int> } const = <str> \ <str> \ <str> \ <str> stub_const ( const , mocked_default_config ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF receive_incoming_mail ( spam_email , info_request . incoming_email , <str> ) expect ( ActionMailer :: Base . deliveries ) . to be_empty ActionMailer :: Base . deliveries . clear end it <str> do info_request = FactoryGirl . create ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF receive_incoming_mail ( spam_email , info_request . incoming_email , <str> ) expect ( ActionMailer :: Base . deliveries . size ) . to eq ( <int> ) ActionMailer :: Base . deliveries . clear end it <str> do info_request = FactoryGirl . create ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <str> ) allow ( AlaveteliConfiguration ) . to receive ( <str> ) . and_return ( <int> ) spam_email = <<- <str> EOF <str> . strip_heredoc <str> EOF receive_incoming_mail ( spam_email , info_request . incoming_email , <str> ) expect ( info_request . incoming_messages . size ) . to eq ( <int> ) ActionMailer :: Base . deliveries . clear end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> , <str> = > <str> ) } it <str> do expect ( request . url_title ) . to eq ( <str> ) end it <str> do expect ( request . url_title ( <str> = > true ) ) . to eq ( <str> ) end end describe <str> do context <str> do it <str> do request = FactoryGirl . create ( <str> ) new_body = FactoryGirl . create ( <str> ) expect { request . move_to_public_body ( new_body ) } . to raise_error IndexError end end context <str> do it <str> do request = FactoryGirl . create ( <str> ) new_body = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) request . move_to_public_body ( new_body , <str> = > user ) request . reload expect ( request . public_body ) . to eq ( new_body ) end it <str> do request = FactoryGirl . create ( <str> ) old_body = request . public_body new_body = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) request . move_to_public_body ( new_body , <str> = > user ) request . reload event = request . info_request_events . last expect ( event . event_type ) . to eq ( <str> ) expect ( event . params [ <str> ] ) . to eq ( user ) expect ( event . params [ <str> ] ) . to eq ( new_body . url_name ) expect ( event . params [ <str> ] ) . to eq ( old_body . url_name ) end it <str> do request = FactoryGirl . create ( <str> ) new_body = FactoryGirl . create ( <str> , <str> = > <str> ) user = FactoryGirl . create ( <str> ) request . move_to_public_body ( new_body , <str> = > user ) request . reload expect ( request . law_used ) . to eq ( <str> ) end it <str> do request = FactoryGirl . create ( <str> ) new_body = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) expect ( request . move_to_public_body ( new_body , <str> = > user ) ) . to eq ( new_body ) end it <str> do request = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) existing_body = request . public_body request . move_to_public_body ( nil , <str> = > user ) request . reload expect ( request . public_body ) . to eq ( existing_body ) end it <str> do request = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) expect ( request . move_to_public_body ( nil , <str> = > user ) ) . to eq ( nil ) end it <str> do request = FactoryGirl . create ( <str> ) new_body = FactoryGirl . create ( <str> ) user = FactoryGirl . create ( <str> ) reindex_job = ActsAsXapian :: ActsAsXapianJob . where ( <str> = > <str> ) . delete_all request . move_to_public_body ( new_body , <str> = > user ) request . reload reindex_job = ActsAsXapian :: ActsAsXapianJob . where ( <str> = > <str> ) . last expect ( reindex_job . model_id ) . to eq ( request . info_request_events . last . id ) end end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> ) } it <str> do expect ( info_request ) . to receive ( <str> ) info_request . destroy end it <str> do expect ( info_request ) . to receive ( <str> ) info_request . destroy end it <str> do info_request . widget_votes . create ( <str> = > <str> * <int> ) info_request . destroy expect ( WidgetVote . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do censor_rule = FactoryGirl . create ( <str> , <str> = > info_request ) info_request . reload info_request . destroy expect ( CensorRule . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do comment = FactoryGirl . create ( <str> , <str> = > info_request ) info_request . reload info_request . destroy expect ( Comment . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do info_request . destroy expect ( InfoRequestEvent . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do info_request . destroy expect ( OutgoingMessage . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do ir_with_incoming = FactoryGirl . create ( <str> ) ir_with_incoming . destroy expect ( IncomingMessage . where ( <str> = > ir_with_incoming . id ) ) . to be_empty end it <str> do MailServerLog . create ( <str> = > <str> , <str> = > <int> , <str> = > info_request ) info_request . destroy expect ( MailServerLog . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do FactoryGirl . create ( <str> , <str> = > <str> , <str> = > info_request , <str> = > <str> ) info_request . destroy expect ( TrackThing . where ( <str> = > info_request . id ) ) . to be_empty end it <str> do UserInfoRequestSentAlert . create ( <str> = > info_request , <str> = > info_request . user , <str> = > <str> ) info_request . destroy expect ( UserInfoRequestSentAlert . where ( <str> = > info_request . id ) ) . to be_empty end end describe <str> do it <str> do info_request = FactoryGirl . create ( <str> ) first_message = info_request . outgoing_messages . first first_message . prominence = <str> first_message . save! expect ( info_request . initial_request_text ) . to eq ( <str> ) end it <str> do info_request = FactoryGirl . create ( <str> ) expect ( info_request . initial_request_text ) . to eq ( <str> ) end end describe <str> do it <str> do info_request = InfoRequest . new ( <str> = > <str> ) expect ( info_request . is_external? ) . to eq ( true ) end it <str> do info_request = InfoRequest . new ( <str> = > nil ) expect ( info_request . is_external? ) . to eq ( false ) end end describe <str> do it <str> do expect ( subject . late_calculator ) . to be_instance_of ( DefaultLateCalculator ) end it <str> do expect ( subject . late_calculator ) . to equal ( subject . late_calculator ) end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> ) } let ( <str> ) { FactoryGirl . create ( <str> ) } let ( <str> ) { FactoryGirl . create ( <str> , <str> = > <str> ) } context <str> do it <str> do expect ( valid_request . is_followupable? ( message_without_reply_to ) ) . to eq ( true ) end it <str> do valid_request . is_followupable? ( message_without_reply_to ) expect ( valid_request . followup_bad_reason ) . to be_nil end end context <str> do let ( <str> ) do FactoryGirl . create ( <str> , <str> = > unfollowupable_body ) end let ( <str> ) { double ( IncomingMessage ) } before do allow ( dummy_message ) . to receive ( <str> ) { true } end it <str> do expect ( request . is_followupable? ( dummy_message ) ) . to eq ( true ) end it <str> do request . is_followupable? ( dummy_message ) expect ( request . followup_bad_reason ) . to be_nil end end context <str> do let ( <str> ) { InfoRequest . new ( <str> = > <str> ) } it <str> do expect ( info_request . is_followupable? ( message_without_reply_to ) ) . to eq ( false ) end it <str> do info_request . is_followupable? ( message_without_reply_to ) expect ( info_request . followup_bad_reason ) . to eq ( <str> ) end end context <str> do let ( <str> ) do FactoryGirl . create ( <str> , <str> = > unfollowupable_body ) end it <str> do expect ( request . is_followupable? ( message_without_reply_to ) ) . to eq ( false ) end it <str> do request . is_followupable? ( message_without_reply_to ) expect ( request . followup_bad_reason ) . to eq ( unfollowupable_body . not_requestable_reason ) end end end describe <str> do context <str> do let ( <str> ) { InfoRequest . new ( <str> = > <str> ) } it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end end context <str> do let ( <str> ) { InfoRequest . new ( <str> = > <str> ) } it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( info_request . law_used_human ( <str> ) ) . to eq ( <str> ) end it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end end context <str> do let ( <str> ) { InfoRequest . new ( <str> = > <str> ) } it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end it <str> do expect { info_request . law_used_human ( <str> ) } . to raise_error . with_message ( <str> info_request . law_used <str> ) end end end describe <str> do it <str> do info_request = InfoRequest . new info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> ) end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to be_empty end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to be_empty end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> ) end it <str> do info_request = InfoRequest . new ( <str> = > <str> * <int> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> \ <str> ) end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> \ <str> \ <str> ) end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> \ <str> \ <str> ) end it <str> do info_request = InfoRequest . new ( <str> = > <str> ) info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> \ <str> ) end it <str> do info_request = InfoRequest . new info_request . valid? expect ( info_request . errors [ <str> ] ) . to include ( <str> ) end it <str> do info_request = InfoRequest . new info_request . is_batch_request_template = true info_request . valid? expect ( info_request . errors [ <str> ] ) . to be_empty end end describe <str> do before do @public_body = mock_model ( PublicBody , <str> = > <str> , <str> = > false ) @info_request = InfoRequest . new ( <str> = > <str> , <str> = > <str> , <str> = > @public_body ) end it <str> do expect ( @info_request . user_name_slug ) . to eq ( <str> ) end end describe <str> do before ( <str> ) do @im = incoming_messages ( <str> ) load_raw_emails_data end it <str> do @info_request = InfoRequest . new ( <str> = > <str> , <str> = > public_bodies ( <str> ) , <str> = > <int> ) @info_request . save! expect ( @info_request . idhash ) . not_to eq ( nil ) end it <str> do ir = info_requests ( <str> ) id = ir . id @im . mail . to = <str> id <str> guessed = InfoRequest . guess_by_incoming_email ( @im ) expect ( guessed [ <int> ] . idhash ) . to eq ( ir . idhash ) end it <str> do ir = info_requests ( <str> ) idhash = ir . idhash @im . mail . to = <str> idhash <str> guessed = InfoRequest . guess_by_incoming_email ( @im ) expect ( guessed [ <int> ] . id ) . to eq ( ir . id ) end end describe <str> do before do @info_request = InfoRequest . new end it <str> do @info_request . title = <str> expect ( @info_request . url_title ) . to eq ( <str> ) end it <str> do @info_request . title = <str> expect ( @info_request . url_title ) . to eq ( <str> ) end end describe <str> do before do @info_request = InfoRequest . new end it <str> do last_mock_event = mock_model ( InfoRequestEvent ) other_mock_event = mock_model ( InfoRequestEvent ) allow ( @info_request ) . to receive ( <str> ) . and_return ( [ other_mock_event , last_mock_event ] ) expect ( @info_request . last_event_id_needing_description ) . to eq ( last_mock_event . id ) end it <str> do allow ( @info_request ) . to receive ( <str> ) . and_return ( [ ] ) expect ( @info_request . last_event_id_needing_description ) . to eq ( <int> ) end end describe <str> do before do @info_request = info_requests ( <str> ) end it <str> do default_locale_path = File . join ( Rails . root , <str> , <str> , <str> , <str> , <str> ) expect ( @info_request . foi_fragment_cache_directories . include? ( default_locale_path ) ) . to eq ( true ) end it <str> do other_locale_path = File . join ( Rails . root , <str> , <str> , <str> , <str> , <str> , <str> ) expect ( @info_request . foi_fragment_cache_directories . include? ( other_locale_path ) ) . to eq ( true ) end end describe <str> do before do @info_request = info_requests ( <str> ) end it <str> do expect ( @info_request . incoming_email ) . not_to be_nil end it <str> do expect ( @info_request . incoming_name_and_email ) . to eq ( <str> + @info_request . incoming_email + <str> ) end it <str> do expect ( @info_request . recipient_name_and_email ) . to eq ( <str> ) end it <str> do incoming_email = @info_request . incoming_email found_info_request = InfoRequest . find_by_incoming_email ( incoming_email ) expect ( found_info_request ) . to eq ( @info_request ) end it <str> do incoming_email = @info_request . incoming_email . gsub ( <str> , <str> ) found_info_request = InfoRequest . find_by_incoming_email ( incoming_email ) expect ( found_info_request ) . to eq ( @info_request ) end it <str> do incoming_email = <str> + @info_request . incoming_email + <str> found_info_request = InfoRequest . find_by_incoming_email ( incoming_email ) expect ( found_info_request ) . to eq ( @info_request ) end it <str> do while true ir = InfoRequest . new ( <str> = > <str> , <str> = > public_bodies ( <str> ) , <str> = > users ( <str> ) ) ir . save! hash_part = ir . incoming_email . match ( <str> ) [ <int> ] break if hash_part . match ( <str> ) end test_email = ir . incoming_email new_hash_part = hash_part . gsub ( <str> , <str> ) test_email . gsub! ( hash_part , new_hash_part ) found_info_request = InfoRequest . find_by_incoming_email ( test_email ) expect ( found_info_request ) . to eq ( ir ) end it <str> do incoming_email = @info_request . magic_email ( <str> ) found_info_request = InfoRequest . find_by_incoming_email ( incoming_email ) expect ( found_info_request ) . to eq ( @info_request ) end it <str> do deleted_request_address = InfoRequest . magic_email_for_id ( <str> , <int> ) found_info_request = InfoRequest . find_by_incoming_email ( deleted_request_address ) expect ( found_info_request ) . to be_nil end it <str> do load_raw_emails_data IncomingMessage . find ( <str> ) . each { | x | x . parse_raw_email! } rebuild_xapian_index info_request_events ( <str> ) . save! info_request_events ( <str> ) . destroy update_xapian_index end end describe <str> do let ( <str> ) do FactoryGirl . create ( <str> , <str> = > <str> ) end context <str> do it <str> do request = FactoryGirl . create ( <str> , <str> = > public_body ) expect ( request . postal_email ) . to eq ( <str> ) end end context <str> do it <str> do request = FactoryGirl . create ( <str> , <str> = > public_body ) incoming_message = FactoryGirl . create ( <str> , <str> = > request ) request . log_event ( <str> , { <str> = > incoming_message . id } ) expect ( request . postal_email ) . to eq ( <str> ) end end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> , <str> = > <str> ) } context <str> do it <str> do request = FactoryGirl . create ( <str> , <str> = > public_body ) expect ( request . postal_email_name ) . to eq ( <str> ) end end context <str> do it <str> do request = FactoryGirl . create ( <str> , <str> = > public_body ) incoming_message = FactoryGirl . create ( <str> , <str> = > request ) request . log_event ( <str> , { <str> = > incoming_message . id } ) expect ( request . postal_email_name ) . to eq ( <str> ) end end end describe <str> do before do @ir = info_requests ( <str> ) end it <str> do expect ( @ir . last_event_forming_initial_request . outgoing_message . last_sent_at . strftime ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( @ir . date_response_required_by . strftime ( <str> ) ) . to eq ( <str> ) end it <str> do expect ( @ir . date_very_overdue_after . strftime ( <str> ) ) . to eq ( <str> ) end it <str> do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <int> , <int> ) ) expect ( @ir . calculate_status ) . to eq ( <str> ) end it <str> do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <oct> , <oct> ) ) expect ( @ir . calculate_status ) . to eq ( <str> ) end it <str> do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <int> , <int> ) ) expect ( @ir . calculate_status ) . to eq ( <str> ) end it <str> do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <oct> , <oct> ) ) expect ( @ir . calculate_status ) . to eq ( <str> ) end end describe <str> do before do InfoRequest . send ( <str> , File . expand_path ( File . dirname ( __FILE__ ) + <str> ) ) InfoRequest . send ( <str> , InfoRequestCustomStates ) InfoRequest . class_eval ( <str> ) @ir = info_requests ( <str> ) end it <str> do expect { @ir . set_described_state ( <str> ) } . to raise_error ( ActiveRecord :: RecordInvalid ) end it <str> do @ir . set_described_state ( <str> ) end it <str> do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <oct> , <oct> ) ) @ir . set_described_state ( <str> ) expect ( @ir . display_status ) . to eq ( <str> ) @ir . date_deadline_extended end it <str> do when_overdue = Time . utc ( <int> , <int> , <int> , <oct> , <oct> ) + <int> . days allow ( Time ) . to receive ( <str> ) . and_return ( when_overdue ) expect ( @ir . calculate_status ) . to eq ( <str> ) end end describe <str> do before do @mock_user = mock_model ( User ) @info_request = InfoRequest . new ( <str> = > @mock_user ) @other_mock_user = mock_model ( User ) end it <str> do expect ( @info_request . is_owning_user? ( nil ) ) . to be false end it <str> do expect ( @info_request . is_owning_user? ( @mock_user ) ) . to be true end it <str> do allow ( @other_mock_user ) . to receive ( <str> ) . and_return ( false ) expect ( @info_request . is_owning_user? ( @other_mock_user ) ) . to be false end it <str> do allow ( @other_mock_user ) . to receive ( <str> ) . and_return ( true ) expect ( @info_request . is_owning_user? ( @other_mock_user ) ) . to be true end end describe <str> do before do @info_request = InfoRequest . new end it <str> do @info_request . described_state = <str> expect ( @info_request . requires_admin? ) . to be true end it <str> do @info_request . described_state = <str> expect ( @info_request . requires_admin? ) . to be true end it <str> do @info_request . described_state = <str> expect ( @info_request . requires_admin? ) . to be false end end describe <str> do it <str> do expect ( InfoRequest ) . to receive ( <str> ) . with ( <str> , hash_including ( <str> = > <int> ) ) InfoRequest . find_old_unclassified ( <str> = > <int> ) end it <str> do expect ( InfoRequest ) . to receive ( <str> ) . with ( <str> , hash_including ( <str> = > <int> ) ) InfoRequest . find_old_unclassified ( <str> = > <int> ) end it <str> do expect ( InfoRequest ) . to receive ( <str> ) . with ( <str> , hash_excluding ( <str> = > anything ) ) InfoRequest . find_old_unclassified end it <str> do expect ( InfoRequest ) . to receive ( <str> ) . with ( <str> , hash_including ( { <str> = > include ( <str> ) } ) ) InfoRequest . find_old_unclassified ( { <str> = > [ <str> ] } ) end context <str> do let ( <str> ) { Time . zone . now - <int> . days } let ( <str> ) { Time . zone . now - <int> . days } let ( <str> ) { FactoryGirl . create ( <str> ) } def create_recent_unclassified_request request = FactoryGirl . create ( <str> , <str> = > user , <str> = > recent_date ) message = FactoryGirl . create ( <str> , <str> = > recent_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > message , <str> = > <str> , <str> = > request , <str> = > recent_date ) request . awaiting_description = true request . save request end def create_old_unclassified_request request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > message , <str> = > <str> , <str> = > request , <str> = > old_date ) request . awaiting_description = true request . save request end def create_old_unclassified_described request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > message , <str> = > <str> , <str> = > request , <str> = > old_date ) request end def create_old_unclassified_no_user request = FactoryGirl . create ( <str> , <str> = > nil , <str> = > <str> , <str> = > <str> , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > message , <str> = > <str> , <str> = > request , <str> = > old_date ) request . awaiting_description = true request . save request end def create_old_unclassified_holding_pen request = FactoryGirl . create ( <str> , <str> = > user , <str> = > <str> , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > message , <str> = > <str> , <str> = > request , <str> = > old_date ) request . awaiting_description = true request . save request end it <str> do old_unclassified_request = create_old_unclassified_request results = InfoRequest . find_old_unclassified expect ( results ) . to include ( old_unclassified_request ) end it <str> do recent_unclassified_request = create_recent_unclassified_request results = InfoRequest . find_old_unclassified expect ( results ) . not_to include ( recent_unclassified_request ) end it <str> do old_unclassified_no_user = create_old_unclassified_no_user results = InfoRequest . find_old_unclassified expect ( results ) . not_to include ( old_unclassified_no_user ) end it <str> do old_unclassified_described = create_old_unclassified_described results = InfoRequest . find_old_unclassified expect ( results ) . not_to include ( old_unclassified_described ) end it <str> do old_unclassified_holding_pen = create_old_unclassified_holding_pen results = InfoRequest . find_old_unclassified expect ( results ) . not_to include ( old_unclassified_holding_pen ) end end end describe <str> do it <str> do dog_request = info_requests ( <str> ) old_unclassified = InfoRequest . get_random_old_unclassified ( <int> , <str> = > [ <str> ] ) expect ( old_unclassified . length ) . to eq ( <int> ) expect ( old_unclassified . first ) . to eq ( dog_request ) dog_request . prominence = <str> dog_request . save! old_unclassified = InfoRequest . get_random_old_unclassified ( <int> , <str> = > [ <str> ] ) expect ( old_unclassified . length ) . to eq ( <int> ) dog_request . prominence = <str> dog_request . save! old_unclassified = InfoRequest . get_random_old_unclassified ( <int> , <str> = > [ <str> ] ) expect ( old_unclassified . length ) . to eq ( <int> ) end end describe <str> do it <str> do dog_request = info_requests ( <str> ) old_unclassified = InfoRequest . count_old_unclassified ( <str> = > [ <str> ] ) expect ( old_unclassified ) . to eq ( <int> ) dog_request . prominence = <str> dog_request . save! old_unclassified = InfoRequest . count_old_unclassified ( <str> = > [ <str> ] ) expect ( old_unclassified ) . to eq ( <int> ) dog_request . prominence = <str> dog_request . save! old_unclassified = InfoRequest . count_old_unclassified ( <str> = > [ <str> ] ) expect ( old_unclassified ) . to eq ( <int> ) end end describe <str> do before do allow ( Time ) . to receive ( <str> ) . and_return ( Time . utc ( <int> , <int> , <int> , <int> , <int> ) ) @info_request = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > true ) @comment_event = FactoryGirl . create ( <str> , <str> = > Time . now - <int> . days , <str> = > <str> , <str> = > @info_request ) @incoming_message = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > @info_request ) @response_event = FactoryGirl . create ( <str> , <str> = > @info_request , <str> = > Time . now - <int> . days , <str> = > <str> , <str> = > @incoming_message ) @info_request . update_attribute ( <str> , true ) end it <str> do allow ( @info_request ) . to receive ( <str> ) . and_return ( <str> ) expect ( @info_request . is_old_unclassified? ) . to be false end it <str> do allow ( @info_request ) . to receive ( <str> ) . and_return ( false ) expect ( @info_request . is_old_unclassified? ) . to be false end it <str> do @response_event . update_attribute ( <str> , Time . now - <int> . days ) expect ( @info_request . is_old_unclassified? ) . to be false end it <str> do expect ( @info_request . is_external? || @info_request . is_old_unclassified? ) . to be true end end describe <str> do it <str> do rule_1 = FactoryGirl . build ( <str> , <str> = > <str> ) rule_2 = FactoryGirl . build ( <str> , <str> = > <str> ) info_request = FactoryGirl . build ( <str> ) allow ( info_request ) . to receive ( <str> ) . and_return ( [ rule_1 , rule_2 ] ) expected = <str> expect ( info_request . apply_censor_rules_to_text ( <str> ) ) . to eq ( expected ) end end describe <str> do it <str> do rule_1 = FactoryGirl . build ( <str> , <str> = > <str> ) rule_2 = FactoryGirl . build ( <str> , <str> = > <str> ) info_request = FactoryGirl . build ( <str> ) allow ( info_request ) . to receive ( <str> ) . and_return ( [ rule_1 , rule_2 ] ) text = <str> text . force_encoding ( <str> ) if String . method_defined? ( <str> ) expect ( info_request . apply_censor_rules_to_binary ( text ) ) . to eq ( <str> ) end end describe <str> do before do @info_request = InfoRequest . new end it <str> do @info_request . prominence = <str> expect ( @info_request . all_can_view? ) . to eq ( true ) end it <str> do @info_request . prominence = <str> expect ( @info_request . all_can_view? ) . to eq ( true ) end it <str> do @info_request . prominence = <str> expect ( @info_request . all_can_view? ) . to eq ( false ) end it <str> do @info_request . prominence = <str> expect ( @info_request . all_can_view? ) . to eq ( false ) end end describe <str> do before do @info_request = FactoryGirl . create ( <str> ) @incoming_message = @info_request . incoming_messages . first end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . get_last_public_response_event ) . to eq ( nil ) end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . get_last_public_response_event ) . to eq ( nil ) end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . get_last_public_response_event ) . to eq ( @incoming_message . response_event ) end end describe <str> do let ( <str> ) { Time . zone . now - <int> . days } let ( <str> ) { Time . zone . now - <int> . days } let ( <str> ) { FactoryGirl . create ( <str> ) } it <str> do request = FactoryGirl . create ( <str> ) expect ( request . last_public_response_at ) . to be_nil end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message , <str> = > old_date , <str> = > <str> ) expect ( request . last_public_response_at ) . to eq ( old_date ) end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request , <str> = > <str> ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message , <str> = > old_date , <str> = > <str> ) expect ( request . last_public_response_at ) . to be_nil end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message , <str> = > old_date , <str> = > <str> ) message . prominence = <str> message . save expect ( request . last_public_response_at ) . to be_nil end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message1 = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) message2 = FactoryGirl . create ( <str> , <str> = > recent_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message1 , <str> = > old_date , <str> = > <str> ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message2 , <str> = > recent_date , <str> = > <str> ) expect ( request . last_public_response_at ) . to eq ( recent_date ) message2 . prominence = <str> message2 . save expect ( request . last_public_response_at ) . to eq ( old_date ) end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message , <str> = > old_date , <str> = > <str> ) message . destroy expect ( request . last_public_response_at ) . to be_nil end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message1 = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request ) message2 = FactoryGirl . create ( <str> , <str> = > recent_date , <str> = > request ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message1 , <str> = > old_date , <str> = > <str> ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message2 , <str> = > recent_date , <str> = > <str> ) expect ( request . last_public_response_at ) . to eq ( recent_date ) message2 . destroy expect ( request . last_public_response_at ) . to eq ( old_date ) end it <str> do request = FactoryGirl . create ( <str> , <str> = > user , <str> = > old_date ) message = FactoryGirl . create ( <str> , <str> = > old_date , <str> = > request , <str> = > <str> ) FactoryGirl . create ( <str> , <str> = > request , <str> = > message , <str> = > old_date , <str> = > <str> ) message . prominence = <str> message . save expect ( request . last_public_response_at ) . to eq ( old_date ) end end describe <str> do before do @info_request = FactoryGirl . create ( <str> ) @outgoing_message = @info_request . outgoing_messages . first end it <str> do @outgoing_message . prominence = <str> @outgoing_message . save! expect ( @info_request . get_last_public_outgoing_event ) . to eq ( nil ) end it <str> do @outgoing_message . prominence = <str> @outgoing_message . save! expect ( @info_request . get_last_public_outgoing_event ) . to eq ( nil ) end it <str> do @outgoing_message . prominence = <str> @outgoing_message . save! expect ( @info_request . get_last_public_outgoing_event ) . to eq ( @outgoing_message . info_request_events . first ) end end describe <str> do before do @info_request = FactoryGirl . create ( <str> ) @incoming_message = @info_request . incoming_messages . first @public_body = @info_request . public_body end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . who_can_followup_to ) . to eq ( [ [ @public_body . name , @public_body . request_email , nil ] ] ) end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . who_can_followup_to ) . to eq ( [ [ @public_body . name , @public_body . request_email , nil ] ] ) end it <str> do @incoming_message . prominence = <str> @incoming_message . save! expect ( @info_request . who_can_followup_to ) . to eq ( [ [ @public_body . name , @public_body . request_email , nil ] , [ <str> , <str> , @incoming_message . id ] ] ) end end describe <str> do before do @user = mock_model ( User , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } ) end it <str> do @info_request = InfoRequest . new ( <str> = > @user ) expect ( @info_request . user_json_for_api ) . to eq ( { <str> = > <int> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } ) end end describe <str> do it <str> do info_request = FactoryGirl . build ( <str> ) expected_text = <str> info_request . title <str> expect ( info_request . email_subject_request ) . to eq ( expected_text ) end end describe <str> do it <str> do ir = info_requests ( <str> ) im = mock_model ( IncomingMessage , <str> = > nil , <str> = > true ) subject = ir . email_subject_followup ( <str> = > im , <str> = > false ) expect ( subject ) . to match ( <str> ) end it <str> do @info_request = InfoRequest . new ( <str> = > <str> , <str> = > <str> ) expect ( @info_request . user_json_for_api ) . to eq ( { <str> = > <str> } ) end it <str> do @info_request = InfoRequest . new ( <str> = > <str> ) expect ( @info_request . user_json_for_api ) . to eq ( { <str> = > <str> } ) end end describe <str> do context <str> do let ( <str> ) { InfoRequest . create! ( <str> = > <str> , <str> = > public_bodies ( <str> ) , <str> = > users ( <str> ) ) } context <str> do it <str> do request . log_event ( <str> , { } ) request . set_described_state ( <str> ) events = request . info_request_events expect ( events . count ) . to eq ( <int> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) end it <str> do request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . awaiting_description = true request . log_event ( <str> , { } ) events = request . info_request_events expect ( events . count ) . to eq ( <int> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to be_nil expect ( events [ <int> ] . calculated_state ) . to be_nil end it <str> do request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . awaiting_description = true request . log_event ( <str> , { } ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) events = request . info_request_events expect ( events . count ) . to eq ( <int> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to be_nil expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) end it <str> do request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . awaiting_description = true request . log_event ( <str> , { } ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) events = request . info_request_events expect ( events . count ) . to eq ( <int> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to be_nil expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) end it <str> do request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . awaiting_description = true request . log_event ( <str> , { } ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) request . log_event ( <str> , { } ) request . set_described_state ( <str> ) events = request . info_request_events expect ( events . count ) . to eq ( <int> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to be_nil expect ( events [ <int> ] . calculated_state ) . to eq ( <str> ) expect ( events [ <int> ] . event_type ) . to eq ( <str> ) expect ( events [ <int> ] . described_state ) . to eq ( <str> ) 
