require File . expand_path ( File . dirname ( __FILE__ ) + <str> ) describe InfoRequestEvent do describe <str> do it <str> do ire = InfoRequestEvent . new ( <str> = > <str> ) ire . valid? expect ( ire . errors . messages [ <str> ] ) . to eq [ <str> ] end it <str> do ire = InfoRequestEvent . new ( <str> = > <str> ) ire . valid? expect ( ire . errors . messages [ <str> ] ) . to be_nil end end describe <str> do let ( <str> ) { InfoRequestEvent . new } it <str> do example_params = { <str> = > <str> , <str> = > <int> , <str> = > <str> } ire . params = example_params expect ( ire . params_yaml ) . to eq ( example_params . to_yaml ) expect ( ire . params ) . to eq ( example_params ) end it <str> do utf8_params = <str> ire . params_yaml = utf8_params expect ( ire . params [ <str> ] . encoding . to_s ) . to eq ( <str> ) if ire . params [ <str> ] . respond_to? ( <str> ) end it <str> do example_params = { <str> = > <int> , <str> = > <int> , <str> = > <int> } ire . params = example_params expect ( ire . params ) . to eq ( example_params ) end end describe <str> do let ( <str> ) { mock_model ( Comment ) } let ( <str> ) { mock_model ( IncomingMessage ) } let ( <str> ) { mock_model ( OutgoingMessage ) } let ( <str> ) { mock_model ( InfoRequest , <str> = > true ) } it <str> do allow ( comment ) . to receive ( <str> ) . and_return ( false ) info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > comment , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_falsey end it <str> do allow ( comment ) . to receive ( <str> ) . and_return ( true ) info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > comment , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_truthy end it <str> do allow ( incoming_message ) . to receive ( <str> ) . and_return false info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > incoming_message , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_falsey end it <str> do allow ( incoming_message ) . to receive ( <str> ) . and_return true info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > incoming_message , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_truthy end it <str> do allow ( outgoing_message ) . to receive ( <str> ) . and_return false info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > outgoing_message , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_falsey end it <str> do allow ( outgoing_message ) . to receive ( <str> ) . and_return true info_request_event = InfoRequestEvent . new ( <str> = > <str> , <str> = > outgoing_message , <str> = > info_request ) expect ( info_request_event . indexed_by_search? ) . to be_truthy end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> ) } it <str> do expect ( ire . described_at ) . to eq ( ire . created_at ) end it <str> do ire . set_calculated_state! ( <str> ) expect ( ire . described_at ) . to eq ( ire . last_described_at ) end end describe <str> do it <str> do ire = FactoryGirl . create ( <str> ) expect ( ire . requested_by ) . to eq ( ire . info_request . user_name_slug ) end end describe <str> do it <str> do ire = FactoryGirl . create ( <str> ) public_body = ire . info_request . public_body expect ( ire . requested_from ) . to eq ( [ public_body . url_name ] ) end end describe <str> do context <str> do it <str> do user = FactoryGirl . create ( <str> ) comment = FactoryGirl . create ( <str> , <str> = > user ) ire = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > comment ) expect ( ire . commented_by ) . to eq ( user . url_name ) end end context <str> do it <str> do ire = FactoryGirl . create ( <str> ) expect ( ire . commented_by ) . to eq ( <str> ) end end end describe <str> do it <str> do ire = FactoryGirl . create ( <str> ) expect ( ire . variety ) . to eq ( ire . event_type ) end end describe <str> do it <str> do ire = FactoryGirl . create ( <str> ) request = ire . info_request new_event = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > request ) request . reload expect ( ire . latest_variety ) . to eq ( <str> ) end end describe <str> do it <str> do ire = FactoryGirl . create ( <str> ) request = ire . info_request new_event = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > request ) new_event . set_calculated_state! ( <str> ) request . reload expect ( ire . latest_status ) . to eq ( <str> ) end end describe <str> do context <str> do it <str> do info_request = FactoryGirl . create ( <str> , <str> = > <str> ) ire = FactoryGirl . create ( <str> , <str> = > info_request , <str> = > <str> ) expect ( ire . title ) . to eq ( <str> ) end end context <str> do it <str> do ire = FactoryGirl . create ( <str> ) expect ( ire . title ) . to eq ( <str> ) end end end describe <str> do context <str> do let ( <str> ) { ire = FactoryGirl . create ( <str> ) } it <str> do expect { ire . filetype } . to raise_error . with_message ( <str> ) end it <str> do info_request = ire . info_request incoming = FactoryGirl . create ( <str> , <str> = > info_request ) ire . incoming_message = incoming expect ( ire . filetype ) . to eq ( <str> ) end it <str> do info_request = ire . info_request incoming = FactoryGirl . create ( <str> , <str> = > info_request ) ire . incoming_message = incoming expect ( ire . filetype ) . to eq ( <str> ) end end context <str> do it <str> do ire = FactoryGirl . create ( <str> , <str> = > <str> ) expect ( ire . filetype ) . to eq ( <str> ) end end end describe <str> do context <str> do it <str> do comment = FactoryGirl . create ( <str> , <str> = > false ) ire = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > comment ) expect ( ire . visible ) . to eq ( false ) end end context <str> do it <str> do ire = FactoryGirl . create ( <str> ) expect ( ire . visible ) . to eq ( true ) end end end describe <str> do let ( <str> ) { InfoRequestEvent . new } it <str> do ire . params = { <str> = > <str> , <str> = > <str> , <str> = > <int> } expected_hash = { <str> = > { <str> = > <str> } , <str> = > { <str> = > <str> } , <str> = > { <str> = > <str> } } expect ( ire . params_diff ) . to eq ( expected_hash ) end it <str> do ire . params = { <str> = > <str> , <str> = > <str> , <str> = > <int> } expected_hash = { <str> = > { } , <str> = > { } , <str> = > { <str> = > <str> } } expect ( ire . params_diff ) . to eq ( expected_hash ) end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> ) } it <str> do event = InfoRequestEvent . new ( <str> = > request , <str> = > <str> , <str> = > { } ) expect ( event ) . to receive ( <str> ) event . run_callbacks ( <str> ) end context <str> do it <str> do im = FactoryGirl . create ( <str> ) response_event = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > request , <str> = > im ) expect ( request . last_public_response_at ) . to be_within ( <int> . second ) . of response_event . created_at end end context <str> do it <str> do expect_any_instance_of ( InfoRequestEvent ) . not_to receive ( <str> ) event = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > request ) expect ( request . last_public_response_at ) . to be_nil end end context <str> do it <str> do im = FactoryGirl . create ( <str> , <str> = > <str> ) response_event = FactoryGirl . create ( <str> , <str> = > <str> , <str> = > request , <str> = > im ) expect ( request . last_public_response_at ) . to be_nil end end end describe <str> do it <str> do event = InfoRequestEvent . new ( <str> = > mock_model ( IncomingMessage ) ) expect ( event . is_incoming_message? ) . to be_truthy expect ( event . is_outgoing_message? ) . to be_falsey expect ( event . is_comment? ) . to be_falsey end it <str> do event = InfoRequestEvent . new ( <str> = > mock_model ( OutgoingMessage ) ) event . id = <int> expect ( event . is_incoming_message? ) . to be_falsey expect ( event . is_outgoing_message? ) . to be_truthy expect ( event . is_comment? ) . to be_falsey end it <str> do event = InfoRequestEvent . new ( <str> = > mock_model ( Comment ) ) event . id = <int> expect ( event . is_incoming_message? ) . to be_falsey expect ( event . is_outgoing_message? ) . to be_falsey expect ( event . is_comment? ) . to be_truthy end end describe <str> do before ( <str> ) do load_raw_emails_data parse_all_incoming_messages end it <str> do event = info_request_events ( <str> ) message = outgoing_messages ( <str> ) . body expect ( event . search_text_main ) . to eq ( message + <str> ) end it <str> do event = info_request_events ( <str> ) expect ( event . search_text_main . strip ) . to eq ( <str> ) end it <str> do event = info_request_events ( <str> ) event . incoming_message_selective_columns ( <str> ) . cached_main_body_text_folded = nil expect ( event . search_text_main ( true ) . strip ) . to eq ( <str> ) expect ( event . incoming_message_selective_columns ( <str> ) . cached_main_body_text_folded ) . not_to eq ( nil ) end end describe <str> do let ( <str> ) { InfoRequestEvent . new } it <str> do allow ( info_request_event ) . to receive ( <str> ) . and_return ( { } ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( nil ) expect ( info_request_event . same_email_as_previous_send? ) . to be true end it <str> do allow ( info_request_event ) . to receive ( <str> ) . and_return ( <str> = > <str> ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( nil ) expect ( info_request_event . same_email_as_previous_send? ) . to be false end it <str> do allow ( info_request_event ) . to receive ( <str> ) . and_return ( <str> = > <str> ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( <str> ) expect ( info_request_event . same_email_as_previous_send? ) . to be true end it <str> do allow ( info_request_event ) . to receive ( <str> ) . and_return ( <str> = > <str> ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( <str> ) expect ( info_request_event . same_email_as_previous_send? ) . to be false end it <str> do allow ( info_request_event ) . to receive ( <str> ) . and_return ( <str> = > <str> ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( <str> ) expect ( info_request_event . same_email_as_previous_send? ) . to be true end it <str> do address = <str> allow ( info_request_event ) . to receive ( <str> ) . and_return ( <str> = > address ) allow ( info_request_event ) . to receive_message_chain ( <str> , <str> ) . and_return ( address ) expect ( info_request_event . same_email_as_previous_send? ) . to be true end end describe <str> do let ( <str> ) { FactoryGirl . build ( <str> ) } before do info_request_event . set_calculated_state! ( <str> ) @timestamp = info_request_event . last_described_at end context <str> do it <str> do info_request_event . set_calculated_state! ( <str> ) expect ( info_request_event . last_described_at ) . to eql ( @timestamp ) end end context <str> do it <str> do info_request_event . set_calculated_state! ( <str> ) expect ( info_request_event . last_described_at ) . to be > @timestamp end it <str> do info_request_event . set_calculated_state! ( <str> ) expect ( info_request_event . calculated_state ) . to eql ( <str> ) end end end describe <str> do let ( <str> ) { FactoryGirl . create ( <str> ) } let ( <str> ) { InfoRequestEvent . create ( <str> = > info_request , <str> = > <str> , <str> = > { } ) } it <str> do event . destroy expect ( InfoRequestEvent . where ( <str> = > event . id ) ) . to be_empty end it <str> do user = FactoryGirl . create ( <str> ) UserInfoRequestSentAlert . create ( <str> = > event . id , <str> = > <str> , <str> = > user , <str> = > info_request ) event . destroy expect ( UserInfoRequestSentAlert . where ( <str> = > event . id ) ) . to be_empty end it <str> do track_thing = FactoryGirl . create ( <str> , <str> = > info_request ) TrackThingsSentEmail . create ( <str> = > track_thing , <str> = > event ) event . reload event . destroy expect ( TrackThingsSentEmail . where ( <str> = > event . id ) ) . to be_empty end end end 
