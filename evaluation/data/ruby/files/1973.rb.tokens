module Rubinius class Mirror class Array < Mirror self . subject = :: Array def self . reflect ( object ) m = super ( object ) if Rubinius :: Type . object_kind_of? m . object , :: Array m elsif ary = Rubinius :: Type . try_convert ( m . object , :: Array , <str> ) super ( ary ) else message = <str> Rubinius :: Type . object_class ( object ) <str> raise TypeError , message end end def total Rubinius . invoke_primitive <str> , @object , <str> end def total = ( value ) Rubinius . invoke_primitive <str> , @object , <str> , value end def tuple Rubinius . invoke_primitive <str> , @object , <str> end def tuple = ( value ) Rubinius . invoke_primitive <str> , @object , <str> , value end def start Rubinius . invoke_primitive <str> , @object , <str> end def start = ( value ) Rubinius . invoke_primitive <str> , @object , <str> , value end def binomial_coefficient ( comb , size ) comb = size - comb if ( comb > size - comb ) return <int> if comb < <int> descending_factorial ( size , comb ) / descending_factorial ( comb , comb ) end def combination_size ( num ) binomial_coefficient ( num , @object . size ) end def descending_factorial ( from , how_many ) cnt = how_many > = <int> ? <int> : <int> while ( how_many ) > <int> cnt = cnt * ( from ) from -= <int> how_many -= <int> end cnt end def permutation_size ( num ) n = @object . size if undefined . equal? num k = @object . size else k = Rubinius :: Type . coerce_to_collection_index num end descending_factorial ( n , k ) end def repeated_combination_size ( combination_size ) return <int> if combination_size == <int> return binomial_coefficient ( combination_size , @object . size + combination_size - <int> ) end def repeated_permutation_size ( combination_size ) return <int> if combination_size < <int> @object . size ** combination_size end end end end 
