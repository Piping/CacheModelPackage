require <str> require <str> require <str> require <str> require <str> require <str> class Puppet :: Transaction require <str> require <str> require <str> require <str> require <str> attr_accessor <str> , <str> , <str> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> include Puppet :: Util include Puppet :: Util :: Tagging def initialize ( catalog , report , prioritizer ) @catalog = catalog @report = report || Puppet :: Transaction :: Report . new ( <str> , catalog . version , catalog . environment ) @prioritizer = prioritizer @report . add_times ( <str> , @catalog . retrieval_duration || <int> ) @event_manager = Puppet :: Transaction :: EventManager . new ( self ) @resource_harness = Puppet :: Transaction :: ResourceHarness . new ( self ) @prefetched_providers = Hash . new { | h , k | h [ k ] = { } } end def perform_pre_run_checks prerun_errors = { } @catalog . vertices . each do | res | begin res . pre_run_check rescue Puppet :: Error = > detail prerun_errors [ res ] = detail end end unless prerun_errors . empty? prerun_errors . each do | res , detail | res . log_exception ( detail ) end raise Puppet :: Error , <str> end end def evaluate ( & block ) block || = method ( <str> ) generator = AdditionalResourceGenerator . new ( @catalog , nil , @prioritizer ) @catalog . vertices . each { | resource | generator . generate_additional_resources ( resource ) } perform_pre_run_checks Puppet . info <str> catalog . version <str> if catalog . version continue_while = lambda { ! stop_processing? } post_evalable_providers = Set . new pre_process = lambda do | resource | prov_class = resource . provider . class post_evalable_providers << prov_class if prov_class . respond_to? ( <str> ) prefetch_if_necessary ( resource ) relationship_graph . clear_blockers if generator . eval_generate ( resource ) end providerless_types = [ ] overly_deferred_resource_handler = lambda do | resource | return if missing_tags? ( resource ) if resource . provider resource . err <str> resource . provider . class . name <str> else providerless_types << resource . type end resource_status ( resource ) . failed = true end canceled_resource_handler = lambda do | resource | resource_status ( resource ) . skipped = true resource . debug <str> end teardown = lambda do providerless_types . uniq . each do | type | Puppet . err <str> type <str> end post_evalable_providers . each do | provider | begin provider . post_resource_eval rescue = > detail Puppet . log_exception ( detail , <str> provider <str> ) end end end generator . relationship_graph = relationship_graph relationship_graph . traverse ( <str> = > continue_while , <str> = > pre_process , <str> = > overly_deferred_resource_handler , <str> = > canceled_resource_handler , <str> = > teardown ) do | resource | if resource . is_a? ( Puppet :: Type :: Component ) Puppet . warning <str> else resource . info <str> if Puppet [ <str> ] and @catalog . host_config? seconds = thinmark { block . call ( resource ) } resource . info <str> % seconds if Puppet [ <str> ] and @catalog . host_config? end end Puppet . debug <str> object_id <str> end def stop_processing? Puppet :: Application . stop_requested? && catalog . host_config? end def any_failed? report . resource_statuses . values . detect { | status | status . failed? } end def changed? report . resource_statuses . values . find_all { | status | status . changed } . collect { | status | catalog . resource ( status . resource ) } end def relationship_graph catalog . relationship_graph ( @prioritizer ) end def resource_status ( resource ) report . resource_statuses [ resource . to_s ] || add_resource_status ( Puppet :: Resource :: Status . new ( resource ) ) end def tags self . tags = Puppet [ <str> ] unless defined? ( @tags ) super end def skip_tags @skip_tags || = Puppet :: Util :: SkipTags . new ( Puppet [ <str> ] ) . tags end def prefetch_if_necessary ( resource ) provider_class = resource . provider . class return unless provider_class . respond_to? ( <str> ) and ! prefetched_providers [ resource . type ] [ provider_class . name ] resources = resources_by_provider ( resource . type , provider_class . name ) if provider_class == resource . class . defaultprovider providerless_resources = resources_by_provider ( resource . type , nil ) providerless_resources . values . each { | res | res . provider = provider_class . name } resources . merge! providerless_resources end prefetch ( provider_class , resources ) end private def apply ( resource , ancestor = nil ) status = resource_harness . evaluate ( resource ) add_resource_status ( status ) event_manager . queue_events ( ancestor || resource , status . events ) unless status . failed? rescue = > detail resource . err <str> detail <str> end def eval_resource ( resource , ancestor = nil ) propagate_failure ( resource ) if skip? ( resource ) resource_status ( resource ) . skipped = true resource . debug ( <str> ) event_manager . dequeue_all_events_for_resource ( resource ) else resource_status ( resource ) . scheduled = true apply ( resource , ancestor ) event_manager . process_events ( resource ) end end def failed? ( resource ) s = resource_status ( resource ) and s . failed? end def failed_dependencies? ( resource ) suppress_report = ( resource . class == Puppet :: Type . type ( <str> ) ) s = resource_status ( resource ) if s && s . dependency_failed? unless suppress_report then s . failed_dependencies . each do | dep | resource . notice <str> dep <str> resource_status ( dep ) . failed <str> end end end s && s . dependency_failed? end def propagate_failure ( resource ) failed = Set . new relationship_graph . direct_dependencies_of ( resource ) . each do | dep | if ( s = resource_status ( dep ) ) failed . merge ( s . failed_dependencies ) if s . dependency_failed? if s . failed? failed . add ( dep ) end end end resource_status ( resource ) . failed_dependencies = failed . to_a end def generate_additional_resources ( resource ) return unless resource . respond_to? ( <str> ) begin made = resource . generate rescue = > detail resource . log_exception ( detail , <str> detail <str> ) end return unless made made = [ made ] unless made . is_a? ( Array ) made . uniq . each do | res | begin res . tag ( * resource . tags ) @catalog . add_resource ( res ) res . finish add_conditional_directed_dependency ( resource , res ) generate_additional_resources ( res ) rescue Puppet :: Resource :: Catalog :: DuplicateResourceError res . info <str> end end end def ignore_tags? ! @catalog . host_config? end def resources_by_provider ( type_name , provider_name ) unless @resources_by_provider @resources_by_provider = Hash . new { | h , k | h [ k ] = Hash . new { | h1 , k1 | h1 [ k1 ] = { } } } @catalog . vertices . each do | resource | if resource . class . attrclass ( <str> ) prov = resource . provider && resource . provider . class . name @resources_by_provider [ resource . type ] [ prov ] [ resource . name ] = resource end end end @resources_by_provider [ type_name ] [ provider_name ] || { } end def prefetch ( provider_class , resources ) type_name = provider_class . resource_type . name return if @prefetched_providers [ type_name ] [ provider_class . name ] Puppet . debug <str> provider_class . name <str> type_name <str> begin provider_class . prefetch ( resources ) rescue LoadError , Puppet :: MissingCommand = > detail Puppet . log_exception ( detail , <str> type_name <str> provider_class . name <str> detail <str> ) end @prefetched_providers [ type_name ] [ provider_class . name ] = true end def add_resource_status ( status ) report . add_resource_status ( status ) end def scheduled? ( resource ) self . ignoreschedules or resource_harness . scheduled? ( resource ) end def skip? ( resource ) if skip_tags? ( resource ) resource . debug <str> skip_tags . join ( <str> ) <str> elsif missing_tags? ( resource ) resource . debug <str> tags . join ( <str> ) <str> elsif ! scheduled? ( resource ) resource . debug <str> elsif failed_dependencies? ( resource ) unless resource . class == Puppet :: Type . type ( <str> ) then resource . warning <str> end elsif resource . virtual? resource . debug <str> elsif ! host_and_device_resource? ( resource ) && resource . appliable_to_host? && for_network_device resource . debug <str> elsif ! host_and_device_resource? ( resource ) && resource . appliable_to_device? && ! for_network_device resource . debug <str> else return false end true end def host_and_device_resource? ( resource ) resource . appliable_to_host? && resource . appliable_to_device? end def missing_tags? ( resource ) return false if ignore_tags? return false if tags . empty? not resource . tagged? ( * tags ) end def skip_tags? ( resource ) return false if ignore_tags? return false if skip_tags . empty? resource . tagged? ( * skip_tags ) end def split_qualified_tags? false end public <str> public <str> end require <str> 
