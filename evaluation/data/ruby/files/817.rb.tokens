require_dependency <str> class ListController < ApplicationController include TopicListResponder skip_before_filter <str> before_filter <str> , <str> : [ Discourse . filters . map { | f | <str> f <str> } , Discourse . filters . map { | f | <str> f <str> } , Discourse . filters . map { | f | <str> f <str> } , Discourse . filters . map { | f | <str> f <str> } , <str> , <str> , <str> , TopTopic . periods . map { | p | <str> p <str> } , TopTopic . periods . map { | p | <str> p <str> } , TopTopic . periods . map { | p | <str> p <str> } , <str> , ] . flatten before_filter <str> , <str> : [ <str> , Discourse . anonymous_filters , Discourse . anonymous_filters . map { | f | <str> f <str> } , Discourse . anonymous_filters . map { | f | <str> f <str> } , Discourse . anonymous_filters . map { | f | <str> f <str> } , Discourse . anonymous_filters . map { | f | <str> f <str> } , Discourse . anonymous_filters . map { | f | <str> f <str> } , <str> , <str> , <str> , <str> , <str> , TopTopic . periods . map { | p | <str> p <str> } , TopTopic . periods . map { | p | <str> p <str> } , TopTopic . periods . map { | p | <str> p <str> } , TopTopic . periods . map { | p | <str> p <str> } , ] . flatten Discourse . filters . each do | filter | define_method ( filter ) do | options = nil | list_opts = build_topic_list_options list_opts . merge! ( options ) if options user = list_target_user if params [ <str> ] . blank? if filter == <str> list_opts [ <str> ] = true end if filter . to_s == current_homepage list_opts [ <str> ] = get_excluded_category_ids ( list_opts [ <str> ] ) end end list = TopicQuery . new ( user , list_opts ) . public_send ( <str> filter <str> ) list . more_topics_url = construct_url_with ( <str> , list_opts ) list . prev_topics_url = construct_url_with ( <str> , list_opts ) if Discourse . anonymous_filters . include? ( filter ) @description = SiteSetting . site_description @rss = filter if ( filter . to_s != current_homepage ) && use_crawler_layout? filter_title = I18n . t ( <str> filter . to_s <str> , <str> : <int> ) if list_opts [ <str> ] @title = I18n . t ( <str> , <str> : filter_title , <str> : Category . find ( list_opts [ <str> ] ) . name ) else @title = I18n . t ( <str> , <str> : filter_title ) end end end respond_with_list ( list ) end define_method ( <str> filter <str> ) do canonical_url <str> Discourse . base_url_no_prefix <str> @category . url <str> self . send ( filter , <str> : @category . id ) end define_method ( <str> filter <str> ) do self . send ( filter , <str> : @category . id , <str> : true ) end define_method ( <str> filter <str> ) do canonical_url <str> Discourse . base_url_no_prefix <str> @category . url <str> self . send ( filter , <str> : @category . id ) end define_method ( <str> filter <str> ) do self . send ( filter , <str> : @category . id ) end end [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] . each do | action | define_method ( <str> action <str> ) do list_opts = build_topic_list_options target_user = fetch_user_from_params ( <str> : current_user . try ( <str> ) ) guardian . ensure_can_see_private_messages! ( target_user . id ) unless action == <str> list = generate_list_for ( action . to_s , target_user , list_opts ) url_prefix = <str> unless action == <str> list . more_topics_url = url_for ( construct_url_with ( <str> , list_opts , url_prefix ) ) list . prev_topics_url = url_for ( construct_url_with ( <str> , list_opts , url_prefix ) ) respond_with_list ( list ) end end def latest_feed discourse_expires_in <int> . minute @title = <str> SiteSetting . title <str> I18n . t ( <str> ) <str> @link = <str> Discourse . base_url <str> @atom_link = <str> Discourse . base_url <str> @description = I18n . t ( <str> ) @topic_list = TopicQuery . new ( nil , <str> : <str> ) . list_latest render <str> , <str> : [ <str> ] end def top_feed discourse_expires_in <int> . minute @title = <str> SiteSetting . title <str> I18n . t ( <str> ) <str> @link = <str> Discourse . base_url <str> @atom_link = <str> Discourse . base_url <str> @description = I18n . t ( <str> ) @topic_list = TopicQuery . new ( nil ) . list_top_for ( <str> ) render <str> , <str> : [ <str> ] end def category_feed guardian . ensure_can_see! ( @category ) discourse_expires_in <int> . minute @title = @category . name @link = <str> Discourse . base_url <str> @category . url <str> @atom_link = <str> Discourse . base_url <str> @category . url <str> @description = <str> I18n . t ( <str> , <str> : @category . name ) <str> @category . description <str> @topic_list = TopicQuery . new . list_new_in_category ( @category ) render <str> , <str> : [ <str> ] end def top ( options = nil ) options || = { } period = ListController . best_period_for ( current_user . try ( <str> ) , options [ <str> ] ) send ( <str> period <str> , options ) end def category_top top ( <str> : @category . id ) end def category_none_top top ( <str> : @category . id , <str> : true ) end def parent_category_category_top top ( <str> : @category . id ) end TopTopic . periods . each do | period | define_method ( <str> period <str> ) do | options = nil | top_options = build_topic_list_options top_options . merge! ( options ) if options top_options [ <str> ] = SiteSetting . topics_per_period_in_top_page if <str> . freeze == current_homepage top_options [ <str> ] = get_excluded_category_ids ( top_options [ <str> ] ) end user = list_target_user list = TopicQuery . new ( user , top_options ) . list_top_for ( period ) list . for_period = period list . more_topics_url = construct_url_with ( <str> , top_options ) list . prev_topics_url = construct_url_with ( <str> , top_options ) @rss = <str> if use_crawler_layout? @title = I18n . t ( <str> period <str> ) end respond_with_list ( list ) end define_method ( <str> period <str> ) do self . send ( <str> period <str> , <str> : @category . id ) end define_method ( <str> period <str> ) do self . send ( <str> period <str> , <str> : @category . id , <str> : true ) end define_method ( <str> period <str> ) do self . send ( <str> period <str> , <str> : @category . id ) end end protected def next_page_params ( opts = nil ) page_params ( opts ) . merge ( <str> : params [ <str> ] . to_i + <int> ) end def prev_page_params ( opts = nil ) pg = params [ <str> ] . to_i if pg > <int> page_params ( opts ) . merge ( <str> : pg - <int> ) else page_params ( opts ) . merge ( <str> : nil ) end end private def page_params ( opts = nil ) opts || = { } route_params = { format : <str> } route_params [ <str> ] = @category . slug_for_url if @category route_params [ <str> ] = @category . parent_category . slug_for_url if @category && @category . parent_category route_params [ <str> ] = opts [ <str> ] if opts [ <str> ] . present? route_params [ <str> ] = opts [ <str> ] if opts [ <str> ] . present? route_params end def set_category slug_or_id = params . fetch ( <str> ) parent_slug_or_id = params [ <str> ] id = params [ <str> ] . to_i parent_category_id = nil if parent_slug_or_id . present? parent_category_id = Category . query_parent_category ( parent_slug_or_id ) redirect_or_not_found and return if parent_category_id . blank? && ! id end @category = Category . query_category ( slug_or_id , parent_category_id ) if id category = Category . find_by_id ( id ) ( redirect_to category . url , <str> : <int> ) && return if category end redirect_or_not_found and return if ! @category @description_meta = @category . description_text raise Discourse :: NotFound unless guardian . can_see? ( @category ) end def build_topic_list_options options = { <str> : params [ <str> ] , <str> : param_to_integer_list ( <str> ) , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] , <str> : params [ <str> ] } options [ <str> ] = true if params [ <str> ] == <str> options [ <str> ] = true if slow_platform? options end def list_target_user if params [ <str> ] && guardian . is_staff? User . find ( params [ <str> ] . to_i ) else current_user end end def generate_list_for ( action , target_user , opts ) TopicQuery . new ( current_user , opts ) . send ( <str> action <str> , target_user ) end def construct_url_with ( action , opts , url_prefix = nil ) method = url_prefix . blank? ? <str> action_name <str> : <str> url_prefix <str> action_name <str> url = if action == <str> public_send ( method , opts . merge ( prev_page_params ( opts ) ) ) else public_send ( method , opts . merge ( next_page_params ( opts ) ) ) end url . sub ( <str> , <str> ) end def get_excluded_category_ids ( current_category = nil ) exclude_category_ids = Category . where ( <str> : true ) exclude_category_ids = exclude_category_ids . where . not ( id : current_category ) if current_category exclude_category_ids . pluck ( <str> ) end def self . best_period_for ( previous_visit_at , category_id = nil ) best_periods_for ( previous_visit_at ) . each do | period | top_topics = TopTopic . where ( <str> period <str> ) top_topics = top_topics . joins ( <str> ) . where ( <str> , category_id ) if category_id return period if top_topics . count > = SiteSetting . topics_per_period_in_top_page end SiteSetting . top_page_default_timeframe end def self . best_periods_for ( date ) date || = <int> . year . ago periods = [ ] periods << <str> if date > <int> . days . ago periods << <str> if date > <int> . days . ago periods << <str> if date > <int> . days . ago periods << <str> periods end def redirect_or_not_found url = request . fullpath permalink = Permalink . find_by_url ( url ) if permalink . present? if permalink . external_url redirect_to permalink . external_url , <str> : <str> elsif permalink . target_url redirect_to <str> Discourse :: base_uri <str> permalink . target_url <str> , <str> : <str> else raise Discourse :: NotFound end else raise Discourse :: NotFound end end end 
