require <str> require <str> require <str> require <str> module Puppet::ModuleTool module Applications class Application include Puppet :: Util :: Colors def self . run ( * args ) new ( * args ) . run end attr_accessor <str> def initialize ( options = { } ) @options = options end def run raise NotImplementedError , <str> end def discuss ( response , success , failure ) case response when Net :: HTTPOK , Net :: HTTPCreated Puppet . notice success else errors = JSON . parse ( response . body ) [ <str> ] rescue <str> response . code <str> response . body <str> Puppet . warning <str> failure <str> errors <str> end end def metadata ( require_metadata = false ) return @metadata if @metadata @metadata = Puppet :: ModuleTool :: Metadata . new unless @path raise ArgumentError , <str> end if require_metadata && ! Puppet :: ModuleTool . is_module_root? ( @path ) raise ArgumentError , <str> @path <str> end metadata_path = File . join ( @path , <str> ) if File . file? ( metadata_path ) File . open ( metadata_path ) do | f | begin @metadata . update ( JSON . load ( f ) ) rescue JSON :: ParserError = > ex raise ArgumentError , <str> metadata_path <str> , ex . backtrace end end end if File . file? ( File . join ( @path , <str> ) ) Puppet . warning <str> end return @metadata end def load_metadata! @metadata = nil metadata ( true ) end def parse_filename ( filename ) if match = <str> . match ( File . basename ( filename , <str> ) ) module_name , author , shortname , version = match . captures else raise ArgumentError , <str> @release_name <str> end unless SemVer . valid? ( version ) raise ArgumentError , <str> version <str> end return { <str> = > module_name , <str> = > author , <str> = > shortname , <str> = > version } end end end end 
