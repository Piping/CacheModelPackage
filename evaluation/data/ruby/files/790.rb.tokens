require <str> require <str> require <str> require <str> require <str> require <str> describe Puppet :: Application :: Inspect do include PuppetSpec :: Files before <str> do @inspect = Puppet :: Application [ <str> ] @inspect . preinit end it <str> do expect ( @inspect . class . run_mode . name ) . to eq ( <str> ) end describe <str> do it <str> do Puppet [ <str> ] = <str> Puppet . settings . expects ( <str> ) . returns ( true ) expect { @inspect . setup } . to exit_with <int> end it <str> do Puppet [ <str> ] = false expect { @inspect . setup } . to raise_error ( <str> ) end end describe <str> , <str> = > true do before <str> do Puppet [ <str> ] = true @inspect . options [ <str> ] = true Puppet :: Transaction :: Report :: Rest . any_instance . stubs ( <str> ) @inspect . setup end it <str> do Puppet :: Resource :: Catalog :: Yaml . any_instance . expects ( <str> ) . with { | request | request . key == Puppet [ <str> ] } . returns ( Puppet :: Resource :: Catalog . new ) @inspect . run_command end it <str> do Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( Puppet :: Resource :: Catalog . new ) Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with { | request | request . instance . host == Puppet [ <str> ] } @inspect . run_command end with_digest_algorithms do it <str> do catalog = Puppet :: Resource :: Catalog . new file = Tempfile . new ( <str> ) file . binmode file . print plaintext file . close resource = Puppet :: Resource . new ( <str> , file . path , <str> = > { <str> = > <str> } ) catalog . add_resource ( resource ) Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( catalog ) events = nil Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with do | request | events = request . instance . resource_statuses . values . first . events end @inspect . run_command properties = events . inject ( { } ) do | property_values , event | property_values . merge ( event . property = > event . previous_value ) end expect ( properties [ <str> ] ) . to eq ( <str> ) expect ( properties [ <str> ] ) . to eq ( <str> digest_algorithm <str> checksum <str> ) expect ( properties . has_key? ( <str> ) ) . to eq ( false ) end end it <str> do catalog = Puppet :: Resource :: Catalog . new file = Tempfile . new ( <str> ) resource = Puppet :: Resource . new ( <str> , file . path , <str> = > { <str> = > <str> } ) catalog . add_resource ( resource ) Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( catalog ) events = nil Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with do | request | events = request . instance . resource_statuses . values . first . events end @inspect . run_command events . each do | event | expect ( event . audited ) . to eq ( true ) end end it <str> do catalog = Puppet :: Resource :: Catalog . new file = Tempfile . new ( <str> ) resource = Puppet :: Resource . new ( <str> , file . path , <str> = > { <str> = > <str> } ) file . close file . delete catalog . add_resource ( resource ) Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( catalog ) events = nil Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with do | request | events = request . instance . resource_statuses . values . first . events end @inspect . run_command properties = events . inject ( { } ) do | property_values , event | property_values . merge ( event . property = > event . previous_value ) end expect ( properties ) . to eq ( { <str> = > <str> } ) end describe <str> do before <str> do Puppet [ <str> ] = true Puppet [ <str> ] = <str> @catalog = Puppet :: Resource :: Catalog . new Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( @catalog ) end describe <str> do before <str> do @file = tmpfile ( <str> ) @resource = Puppet :: Resource . new ( <str> , @file , <str> = > { <str> = > <str> } ) @catalog . add_resource ( @resource ) end it <str> do File . open ( @file , <str> ) { | f | f . write ( <str> ) } Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . with do | request | request . server == Puppet [ <str> ] end . returns ( false ) Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . with do | request | request . server == Puppet [ <str> ] and request . instance . contents == <str> end @inspect . run_command end it <str> , <str> = > ( Puppet . features . microsoft_windows? || Puppet . features . root? ) do File . open ( @file , <str> ) { | f | f . write ( <str> ) } File . chmod ( <int> , @file ) Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never @inspect . run_command end it <str> do Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never @inspect . run_command end it <str> do @resource [ <str> ] = <str> Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never @inspect . run_command end it <str> do File . open ( @file , <str> ) { | f | f . write ( <str> ) } Puppet :: FileBucketFile :: Rest . any_instance . stubs ( <str> ) . returns false Puppet :: FileBucketFile :: Rest . any_instance . stubs ( <str> ) . raises <str> Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with do | request | @report = request . instance end @inspect . run_command expect ( @report . logs . first ) . not_to eq ( nil ) expect ( @report . logs . first . message ) . to match ( <str> ) end end describe <str> do before <str> do Puppet :: Type . newtype ( <str> ) do newparam ( <str> ) do desc <str> isnamevar end newproperty ( <str> ) do desc <str> def retrieve <str> end end end @resource = Puppet :: Resource . new ( <str> , <str> , <str> = > { <str> = > <str> } ) @catalog . add_resource ( @resource ) end after <str> do Puppet :: Type . rmtype ( <str> ) end it <str> do Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . never @inspect . run_command end end end describe <str> do before <str> do Puppet :: Type . newtype ( <str> ) do newparam ( <str> ) do desc <str> isnamevar end newproperty ( <str> ) do desc <str> def retrieve raise <str> end end end @catalog = Puppet :: Resource :: Catalog . new Puppet :: Resource :: Catalog :: Yaml . any_instance . stubs ( <str> ) . returns ( @catalog ) Puppet :: Transaction :: Report :: Rest . any_instance . expects ( <str> ) . with do | request | @report = request . instance end end after <str> do Puppet :: Type . rmtype ( <str> ) end it <str> do @resource = Puppet :: Resource . new ( <str> , <str> , <str> = > { <str> = > <str> } ) @catalog . add_resource ( @resource ) @inspect . run_command expect ( @report . status ) . to eq ( <str> ) expect ( @report . logs . select { | log | log . message =~ <str> } . size ) . to eq ( <int> ) expect ( @report . resource_statuses . size ) . to eq ( <int> ) expect ( @report . resource_statuses [ <str> ] . events . size ) . to eq ( <int> ) event = @report . resource_statuses [ <str> ] . events . first expect ( event . property ) . to eq ( <str> ) expect ( event . status ) . to eq ( <str> ) expect ( event . audited ) . to eq ( true ) expect ( event . instance_variables ) . not_to include <str> expect ( event . instance_variables ) . not_to include <str> end it <str> do @resource = Puppet :: Resource . new ( <str> , <str> , <str> = > { <str> = > <str> } ) @other_resource = Puppet :: Resource . new ( <str> , <str> , <str> = > { <str> = > <str> } ) @catalog . add_resource ( @resource ) @catalog . add_resource ( @other_resource ) @inspect . run_command expect ( @report . resource_statuses . size ) . to eq ( <int> ) expect ( @report . resource_statuses . keys ) . to match_array ( [ <str> , <str> ] ) end end end after <str> do Puppet :: Resource :: Catalog . indirection . reset_terminus_class Puppet :: Transaction :: Report . indirection . terminus_class = <str> end end 
