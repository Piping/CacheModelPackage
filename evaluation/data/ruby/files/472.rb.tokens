require <str> require <str> require <str> begin require <str> rescue LoadError end class TestIOWait < Test :: Unit :: TestCase def setup if <str> =~ RUBY_PLATFORM @r , @w = Socket . pair ( Socket :: AF_INET , Socket :: SOCK_STREAM , <int> ) else @r , @w = IO . pipe end end def teardown @r . close unless @r . closed? @w . close unless @w . closed? end def test_nread assert_equal <int> , @r . nread @w . syswrite <str> sleep <int> . <int> assert_equal <int> , @r . nread end def test_nread_buffered @w . syswrite <str> assert_equal <str> , @r . gets assert_equal <int> , @r . nread end def test_ready? assert_not_predicate @r , <str> , <str> @w . syswrite <str> sleep <int> . <int> assert_predicate @r , <str> , <str> end def test_buffered_ready? @w . syswrite <str> assert_equal <str> , @r . gets assert_predicate @r , <str> end def test_wait assert_nil @r . wait ( <int> ) @w . syswrite <str> sleep <int> . <int> assert_equal @r , @r . wait ( <int> ) end def test_wait_buffered @w . syswrite <str> assert_equal <str> , @r . gets assert_equal true , @r . wait ( <int> ) end def test_wait_forever th = Thread . new { sleep <int> . <oct> ; @w . syswrite <str> } assert_equal @r , @r . wait ensure th . join end def test_wait_eof th = Thread . new { sleep <int> . <oct> ; @w . close } ret = nil assert_nothing_raised ( Timeout :: Error ) do Timeout . timeout ( <int> . <int> ) { ret = @r . wait } end assert_equal @r , ret ensure th . join end def test_wait_readable assert_nil @r . wait_readable ( <int> ) @w . syswrite <str> sleep <int> . <int> assert_equal @r , @r . wait_readable ( <int> ) end def test_wait_readable_buffered @w . syswrite <str> assert_equal <str> , @r . gets assert_equal true , @r . wait_readable ( <int> ) end def test_wait_readable_forever th = Thread . new { sleep <int> . <oct> ; @w . syswrite <str> } assert_equal @r , @r . wait_readable ensure th . join end def test_wait_readable_eof th = Thread . new { sleep <int> . <oct> ; @w . close } ret = nil assert_nothing_raised ( Timeout :: Error ) do Timeout . timeout ( <int> . <int> ) { ret = @r . wait_readable } end assert_equal @r , ret ensure th . join end def test_wait_writable assert_equal @w , @w . wait_writable end def test_wait_writable_timeout assert_equal @w , @w . wait_writable ( <int> . <oct> ) written = fill_pipe assert_nil @w . wait_writable ( <int> . <oct> ) @r . read ( written ) assert_equal @w , @w . wait_writable ( <int> . <oct> ) end def test_wait_writable_EPIPE fill_pipe @r . close assert_equal @w , @w . wait_writable end def test_wait_writable_closed @w . close assert_raise ( IOError ) { @w . wait_writable } end def test_wait_readwrite assert_equal @r . wait ( <int> , <str> ) , @r . wait ( <int> , <str> ) end def test_wait_readwrite_timeout assert_equal @w , @w . wait ( <int> . <oct> , <str> ) written = fill_pipe assert_nil @w . wait ( <int> . <oct> , <str> ) @r . read ( written ) assert_equal @w , @w . wait ( <int> . <oct> , <str> ) end private def fill_pipe written = <int> buf = <str> * <int> begin written += @w . write_nonblock ( buf ) rescue Errno :: EAGAIN , Errno :: EWOULDBLOCK return written end while true end end if IO . method_defined? ( <str> ) 
