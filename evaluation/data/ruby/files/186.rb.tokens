module Gem::Resolver::Molinillo class Resolver class Resolution Conflict = Struct . new ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> def initialize ( specification_provider , resolver_ui , requested , base ) @specification_provider = specification_provider @resolver_ui = resolver_ui @original_requested = requested @base = base @states = [ ] @iteration_counter = <int> end def resolve start_resolution while state break unless state . requirements . any? || state . requirement indicate_progress if state . respond_to? ( <str> ) debug ( depth ) { <str> requirement <str> possibilities . count <str> } state . pop_possibility_state . tap { | s | states . push ( s ) if s } end process_topmost_state end activated . freeze ensure end_resolution end attr_accessor <str> private <str> attr_accessor <str> private <str> attr_accessor <str> private <str> private def start_resolution @started_at = Time . now handle_missing_or_push_dependency_state ( initial_state ) debug { <str> @started_at <str> } resolver_ui . before_resolution end def end_resolution resolver_ui . after_resolution debug do <str> @iteration_counter <str> \ <str> ( ended_at = Time . now ) - @started_at <str> ended_at <str> end debug { <str> + Hash [ activated . vertices . reject { | _n , v | v . payload } ] . keys . join ( <str> ) } if state debug { <str> + Hash [ activated . vertices . select { | _n , v | v . payload } ] . keys . join ( <str> ) } if state end require <str> require <str> ResolutionState . new . members . each do | member | define_method member do | * args , & block | current_state = state || ResolutionState . empty current_state . send ( member , * args , & block ) end end SpecificationProvider . instance_methods ( false ) . each do | instance_method | define_method instance_method do | * args , & block | begin specification_provider . send ( instance_method , * args , & block ) rescue NoSuchDependencyError = > error if state vertex = activated . vertex_named ( name_for error . dependency ) error . required_by += vertex . incoming_edges . map { | e | e . origin . name } error . required_by << name_for_explicit_dependency_source unless vertex . explicit_requirements . empty? end raise end end end def process_topmost_state if possibility attempt_to_activate else create_conflict if state . is_a? PossibilityState unwind_for_conflict until possibility && state . is_a? ( DependencyState ) end end def possibility possibilities . last end def state states . last end def initial_state graph = DependencyGraph . new . tap do | dg | original_requested . each { | r | dg . add_vertex ( name_for ( r ) , nil , true ) . tap { | v | v . explicit_requirements << r } } end requirements = sort_dependencies ( original_requested , graph , { } ) initial_requirement = requirements . shift DependencyState . new ( initial_requirement && name_for ( initial_requirement ) , requirements , graph , initial_requirement , initial_requirement && search_for ( initial_requirement ) , <int> , { } ) end def unwind_for_conflict debug ( depth ) { <str> requirement <str> } conflicts . tap do | c | states . slice! ( ( state_index_for_unwind + <int> ) .. - <int> ) raise VersionConflict . new ( c ) unless state state . conflicts = c end end def state_index_for_unwind current_requirement = requirement existing_requirement = requirement_for_existing_name ( name ) until current_requirement . nil? current_state = find_state_for ( current_requirement ) return states . index ( current_state ) if state_any? ( current_state ) current_requirement = parent_of ( current_requirement ) end until existing_requirement . nil? existing_state = find_state_for ( existing_requirement ) return states . index ( existing_state ) if state_any? ( existing_state ) existing_requirement = parent_of ( existing_requirement ) end - <int> end def parent_of ( requirement ) return nil unless requirement seen = false state = states . reverse_each . find do | s | seen || = s . requirement == requirement || s . requirements . include? ( requirement ) seen && s . requirement != requirement && ! s . requirements . include? ( requirement ) end state && state . requirement end def requirement_for_existing_name ( name ) return nil unless activated . vertex_named ( name ) . payload states . reverse_each . find { | s | ! s . activated . vertex_named ( name ) . payload } . requirement end def find_state_for ( requirement ) return nil unless requirement states . reverse_each . find { | i | requirement == i . requirement && i . is_a? ( DependencyState ) } end def state_any? ( state ) state && state . possibilities . any? end def create_conflict vertex = activated . vertex_named ( name ) requirements = { name_for_explicit_dependency_source = > vertex . explicit_requirements , name_for_locking_dependency_source = > Array ( locked_requirement_named ( name ) ) , } vertex . incoming_edges . each { | edge | ( requirements [ edge . origin . payload ] || = [ ] ) . unshift ( edge . requirement ) } conflicts [ name ] = Conflict . new ( requirement , Hash [ requirements . select { | _ , r | ! r . empty? } ] , vertex . payload , possibility , locked_requirement_named ( name ) , requirement_trees , Hash [ activated . map { | v | [ v . name , v . payload ] } . select ( & <str> ) ] ) end def requirement_trees vertex = activated . vertex_named ( name ) vertex . requirements . map { | r | requirement_tree_for ( r ) } end def requirement_tree_for ( requirement ) tree = [ ] while requirement tree . unshift ( requirement ) requirement = parent_of ( requirement ) end tree end def indicate_progress @iteration_counter += <int> @progress_rate || = resolver_ui . progress_rate if iteration_rate . nil? if Time . now - started_at > = @progress_rate self . iteration_rate = @iteration_counter end end if iteration_rate && ( @iteration_counter % iteration_rate ) == <int> resolver_ui . indicate_progress end end def debug ( depth = <int> , & block ) resolver_ui . debug ( depth , & block ) end def attempt_to_activate debug ( depth ) { <str> + possibility . to_s } existing_node = activated . vertex_named ( name ) if existing_node . payload debug ( depth ) { <str> existing_node . payload <str> } attempt_to_activate_existing_spec ( existing_node ) else attempt_to_activate_new_spec end end def attempt_to_activate_existing_spec ( existing_node ) existing_spec = existing_node . payload if requirement_satisfied_by? ( requirement , activated , existing_spec ) new_requirements = requirements . dup push_state_for_requirements ( new_requirements , false ) else return if attempt_to_swap_possibility create_conflict debug ( depth ) { <str> existing_node . payload <str> } unwind_for_conflict end end def attempt_to_swap_possibility swapped = activated . dup swapped . vertex_named ( name ) . payload = possibility return unless swapped . vertex_named ( name ) . requirements . all? { | r | requirement_satisfied_by? ( r , swapped , possibility ) } attempt_to_activate_new_spec end def attempt_to_activate_new_spec satisfied = begin locked_requirement = locked_requirement_named ( name ) requested_spec_satisfied = requirement_satisfied_by? ( requirement , activated , possibility ) locked_spec_satisfied = ! locked_requirement || requirement_satisfied_by? ( locked_requirement , activated , possibility ) debug ( depth ) { <str> } unless requested_spec_satisfied debug ( depth ) { <str> } unless locked_spec_satisfied requested_spec_satisfied && locked_spec_satisfied end if satisfied activate_spec else create_conflict unwind_for_conflict end end def locked_requirement_named ( requirement_name ) vertex = base . vertex_named ( requirement_name ) vertex && vertex . payload end def activate_spec conflicts . delete ( name ) debug ( depth ) { <str> + name + <str> + possibility . to_s } vertex = activated . vertex_named ( name ) vertex . payload = possibility require_nested_dependencies_for ( possibility ) end def require_nested_dependencies_for ( activated_spec ) nested_dependencies = dependencies_for ( activated_spec ) debug ( depth ) { <str> nested_dependencies . map ( & <str> ) . join ( <str> ) <str> } nested_dependencies . each { | d | activated . add_child_vertex ( name_for ( d ) , nil , [ name_for ( activated_spec ) ] , d ) } push_state_for_requirements ( requirements + nested_dependencies , nested_dependencies . size > <int> ) end def push_state_for_requirements ( new_requirements , requires_sort = true , new_activated = activated . dup ) new_requirements = sort_dependencies ( new_requirements . uniq , new_activated , conflicts ) if requires_sort new_requirement = new_requirements . shift new_name = new_requirement ? name_for ( new_requirement ) : <str> possibilities = new_requirement ? search_for ( new_requirement ) : [ ] handle_missing_or_push_dependency_state DependencyState . new ( new_name , new_requirements , new_activated , new_requirement , possibilities , depth , conflicts . dup ) end def handle_missing_or_push_dependency_state ( state ) if state . requirement && state . possibilities . empty? && allow_missing? ( state . requirement ) state . activated . detach_vertex_named ( state . name ) push_state_for_requirements ( state . requirements . dup , false , state . activated ) else states . push state end end end end end 
