module HighlightHelper include ERB :: Util def highlight_matches ( text , phrases , options = { } ) text = ActionController :: Base . helpers . sanitize ( text ) . try ( <str> ) if options . fetch ( <str> , true ) if text . blank? || phrases . blank? text else match = Array ( phrases ) . map do | p | Regexp === p ? p . to_s : Regexp . escape ( p ) end . join ( <str> ) if block_given? text . gsub ( <str> match <str> ) { | found | yield found } else highlighter = options . fetch ( <str> , <str> ) text . gsub ( <str> match <str> , highlighter ) end end . html_safe end def highlight_words ( t , words , html = true ) if html highlight_matches ( h ( t ) , words , <str> = > <str> ) . html_safe else highlight_matches ( t , words , <str> = > <str> ) end end def highlight_and_excerpt ( t , words , excount , html = true ) newt = excerpt ( t , words [ <int> ] , <str> = > excount ) if not newt newt = excerpt ( t , <str> , <str> = > excount ) end t = newt t = highlight_words ( t , words , html ) return t end def excerpt ( text , phrase , options = { } ) return unless text && phrase separator = options . fetch ( <str> , nil ) || <str> case phrase when Regexp regex = phrase else regex = <str> Regexp . escape ( phrase ) <str> end return unless matches = text . match ( regex ) phrase = matches [ <int> ] unless separator . empty? text . split ( separator ) . each do | value | if value . match ( regex ) regex = phrase = value break end end end first_part , second_part = text . split ( phrase , <int> ) prefix , first_part = cut_excerpt_part ( <str> , first_part , separator , options ) postfix , second_part = cut_excerpt_part ( <str> , second_part , separator , options ) affix = [ first_part , separator , phrase , separator , second_part ] . join . strip [ prefix , affix , postfix ] . join end private def cut_excerpt_part ( part_position , part , separator , options ) return <str> , <str> unless part radius = options . fetch ( <str> , <int> ) omission = options . fetch ( <str> , <str> ) part = part . split ( separator ) part . delete ( <str> ) affix = part . size > radius ? omission : <str> part = if part_position == <str> drop_index = [ part . length - radius , <int> ] . max part . drop ( drop_index ) else part . first ( radius ) end return affix , part . join ( separator ) end end 
