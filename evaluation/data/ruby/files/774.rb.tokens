class MatchData def begin ( idx ) if idx == <int> start = @full . at ( <int> ) else start = @region . at ( idx - <int> ) . at ( <int> ) return nil if start == - <int> end m = Rubinius :: Mirror . reflect @source m . byte_to_character_index start end def end ( idx ) if idx == <int> fin = @full . at ( <int> ) else fin = @region . at ( idx - <int> ) . at ( <int> ) return nil if fin == - <int> end m = Rubinius :: Mirror . reflect @source m . byte_to_character_index fin end def offset ( idx ) out = [ ] out << self . begin ( idx ) out << self . end ( idx ) return out end def [] ( idx , len = nil ) return to_a [ idx , len ] if len case idx when Fixnum if idx < = <int> return matched_area ( ) if idx == <int> return to_a [ idx ] elsif idx < = @region . size tup = @region [ idx - <int> ] x = tup . at ( <int> ) return nil if x == - <int> y = tup . at ( <int> ) return @source . byteslice ( x , y - x ) end when String if @regexp . name_table return self [ idx . to_sym ] end raise IndexError , <str> idx <str> when Symbol if @regexp . name_table if nums = @regexp . name_table [ idx ] nums . reverse_each do | num | val = self [ num ] return val if val end return nil end end raise IndexError , <str> idx <str> end return to_a [ idx ] end attr_reader <str> def == ( other ) other . kind_of? ( MatchData ) && string == other . string && regexp == other . regexp && captures == other . captures end alias_method <str> , <str> def string @source . dup . freeze end def source @source end def full @full end def length @region . fields + <int> end def captures out = Array . new ( @region . fields ) idx = <int> @region . each do | tup | x = tup . at ( <int> ) if x == - <int> val = nil else y = tup . at ( <int> ) val = @source . byteslice ( x , y - x ) end out [ idx ] = val idx += <int> end return out end def names @regexp . names end def pre_match return @source . byteslice ( <int> , <int> ) if @full . at ( <int> ) == <int> nd = @full . at ( <int> ) - <int> @source . byteslice ( <int> , nd + <int> ) end def pre_match_from ( idx ) return @source . byteslice ( <int> , <int> ) if @full . at ( <int> ) == <int> nd = @full . at ( <int> ) - <int> @source . byteslice ( idx , nd - idx + <int> ) end def collapsing? @full [ <int> ] == @full [ <int> ] end def post_match nd = @source . bytesize - <int> st = @full . at ( <int> ) @source . byteslice ( st , nd - st + <int> ) end def inspect capts = captures if capts . empty? <str> matched_area <str> else idx = <int> capts . map! { | capture | <str> idx += <int> <str> capture . inspect <str> } <str> matched_area <str> capts . join ( <str> ) <str> end end def select unless block_given? raise LocalJumpError , <str> end out = [ ] ma = matched_area ( ) out << ma if yield ma each_capture do | str | if yield ( str ) out << str end end return out end alias_method <str> , <str> def to_a ary = captures ( ) ary . unshift matched_area ( ) return ary end def values_at ( * indexes ) indexes . map { | i | self [ i ] } . flatten ( <int> ) end def matched_area x = @full . at ( <int> ) y = @full . at ( <int> ) @source . byteslice ( x , y - x ) end alias_method <str> , <str> private <str> def get_capture ( num ) x , y = @region [ num ] return nil if ! y or x == - <int> return @source . byteslice ( x , y - x ) end private <str> def each_capture @region . each do | tup | x , y = * tup yield @source . byteslice ( x , y - x ) end end private <str> end 
