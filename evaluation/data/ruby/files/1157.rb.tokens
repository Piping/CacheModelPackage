class Keg PREFIX_PLACEHOLDER = <str> . freeze CELLAR_PLACEHOLDER = <str> . freeze def fix_install_names mach_o_files . each do | file | file . ensure_writable do change_dylib_id ( dylib_id_for ( file ) , file ) if file . dylib? each_install_name_for ( file ) do | bad_name | next if bad_name . start_with? ( <str> ) && ! bad_name . start_with? ( HOMEBREW_TEMP . to_s ) new_name = fixed_name ( file , bad_name ) change_install_name ( bad_name , new_name , file ) unless new_name == bad_name end end end symlink_files . each do | file | link = file . readlink next unless link . absolute? if link . to_s . start_with? ( HOMEBREW_CELLAR . to_s ) || link . to_s . start_with? ( HOMEBREW_PREFIX . to_s ) FileUtils . ln_sf ( link . relative_path_from ( file . parent ) , file ) end end end def relocate_install_names ( old_prefix , new_prefix , old_cellar , new_cellar ) mach_o_files . each do | file | file . ensure_writable do if file . dylib? id = dylib_id_for ( file ) . sub ( old_prefix , new_prefix ) change_dylib_id ( id , file ) end each_install_name_for ( file ) do | old_name | if old_name . start_with? old_cellar new_name = old_name . sub ( old_cellar , new_cellar ) elsif old_name . start_with? old_prefix new_name = old_name . sub ( old_prefix , new_prefix ) end change_install_name ( old_name , new_name , file ) if new_name end end end end def relocate_text_files ( old_prefix , new_prefix , old_cellar , new_cellar ) files = text_files | libtool_files files . group_by { | f | f . stat . ino } . each_value do | first , * rest | s = first . open ( <str> , & <str> ) changed = s . gsub! ( old_cellar , new_cellar ) changed = s . gsub! ( old_prefix , new_prefix ) || changed next unless changed begin first . atomic_write ( s ) rescue SystemCallError first . ensure_writable do first . open ( <str> ) { | f | f . write ( s ) } end else rest . each { | file | FileUtils . ln ( first , file , <str> = > true ) } end end end def detect_cxx_stdlibs ( options = { } ) skip_executables = options . fetch ( <str> , false ) results = Set . new mach_o_files . each do | file | next if file . mach_o_executable? && skip_executables dylibs = file . dynamically_linked_libraries results << <str> unless dylibs . grep ( <str> ) . empty? results << <str> unless dylibs . grep ( <str> ) . empty? end results . to_a end def each_unique_file_matching ( string ) Utils . popen_read ( <str> , <str> , string , to_s ) do | io | hardlinks = Set . new until io . eof? file = Pathname . new ( io . readline . chomp ) next if file . symlink? yield file if hardlinks . add? file . stat . ino end end end def fixed_name ( file , bad_name ) if bad_name . start_with? PREFIX_PLACEHOLDER bad_name . sub ( PREFIX_PLACEHOLDER , HOMEBREW_PREFIX . to_s ) elsif bad_name . start_with? CELLAR_PLACEHOLDER bad_name . sub ( CELLAR_PLACEHOLDER , HOMEBREW_CELLAR . to_s ) elsif ( file . dylib? || file . mach_o_bundle? ) && ( file . parent + bad_name ) . exist? <str> bad_name <str> elsif file . mach_o_executable? && ( lib + bad_name ) . exist? <str> lib <str> bad_name <str> elsif ( abs_name = find_dylib ( bad_name ) ) && abs_name . exist? abs_name . to_s else opoo <str> bad_name <str> file <str> bad_name end end def lib path . join ( <str> ) end def each_install_name_for ( file , & block ) dylibs = file . dynamically_linked_libraries dylibs . reject! { | fn | fn =~ <str> } dylibs . each ( & block ) end def dylib_id_for ( file ) basename = File . basename ( file . dylib_id ) relative_dirname = file . dirname . relative_path_from ( path ) opt_record . join ( relative_dirname , basename ) . to_s end FRAMEWORK_RX = <str> . freeze def find_dylib_suffix_from ( bad_name ) if ( framework = bad_name . match ( FRAMEWORK_RX ) ) framework [ <int> ] else File . basename ( bad_name ) end end def find_dylib ( bad_name ) return unless lib . directory? suffix = <str> find_dylib_suffix_from ( bad_name ) <str> lib . find { | pn | break pn if pn . to_s . end_with? ( suffix ) } end def mach_o_files mach_o_files = [ ] path . find do | pn | next if pn . symlink? || pn . directory? mach_o_files << pn if pn . dylib? || pn . mach_o_bundle? || pn . mach_o_executable? end mach_o_files end def text_files text_files = [ ] path . find do | pn | next if pn . symlink? || pn . directory? next if Metafiles :: EXTENSIONS . include? pn . extname if Utils . popen_read ( <str> , <str> , pn ) . include? ( <str> ) || pn . text_executable? text_files << pn end end text_files end def libtool_files libtool_files = [ ] lib . find do | pn | next if pn . symlink? || pn . directory? || pn . extname != <str> libtool_files << pn end if lib . directory? libtool_files end def symlink_files symlink_files = [ ] path . find do | pn | symlink_files << pn if pn . symlink? end symlink_files end end 
