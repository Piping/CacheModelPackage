require <str> require <str> require <str> require <str> if Tk :: TK_MAJOR_VERSION > <int> || ( Tk :: TK_MAJOR_VERSION == <int> && Tk :: TK_MINOR_VERSION > = <int> ) begin TkPackage . require ( <str> ) rescue RuntimeError end pkgname = <str> else pkgname = <str> end begin verstr = TkPackage . require ( pkgname ) rescue RuntimeError module Tk module Tile CANNOT_FIND_PACKAGE = true def self . const_missing ( sym ) TkPackage . require ( PACKAGE_NAME ) end def self . method_missing ( * args ) TkPackage . require ( PACKAGE_NAME ) end end end Tk . __cannot_find_tk_package_for_widget_set__ ( <str> , pkgname ) if pkgname == <str> verstr = Tk :: TK_PATCHLEVEL else verstr = <str> end end ver = verstr . split ( <str> ) if ver [ <int> ] . to_i == <int> if ver [ <int> ] . to_i < = <int> module Tk module Tile USE_TILE_NAMESPACE = true USE_TTK_NAMESPACE = false TILE_SPEC_VERSION_ID = <int> end end elsif ver [ <int> ] . to_i < = <int> module Tk module Tile USE_TILE_NAMESPACE = true USE_TTK_NAMESPACE = true TILE_SPEC_VERSION_ID = <int> end end elsif ver [ <int> ] . to_i < = <int> module Tk module Tile USE_TILE_NAMESPACE = false USE_TTK_NAMESPACE = true TILE_SPEC_VERSION_ID = <int> end end else module Tk module Tile USE_TILE_NAMESPACE = false USE_TTK_NAMESPACE = true TILE_SPEC_VERSION_ID = <int> end end end module Tk::Tile PACKAGE_NAME = <str> . freeze end else module Tk module Tile USE_TILE_NAMESPACE = false USE_TTK_NAMESPACE = true TILE_SPEC_VERSION_ID = <int> PACKAGE_NAME = <str> . freeze end end end module Tk module Tile TkComm :: TkExtlibAutoloadModule . unshift ( self ) def self . package_name PACKAGE_NAME end def self . package_version begin TkPackage . require ( PACKAGE_NAME ) rescue <str> end end def self . __Import_Tile_Widgets__! warn <str> << <str> Tk . tk_call ( <str> , <str> , <str> , <str> ) end def self . __define_LoadImages_proc_for_compatibility__! klass_name = self . name proc_name = <str> if Tk :: Tile :: USE_TTK_NAMESPACE ns_list = [ <str> ] if Tk . info ( <str> , <str> proc_name <str> ) . empty? ns_list << <str> end else ns_list = [ <str> ] if Tk . info ( <str> , <str> proc_name <str> ) . empty? ns_list << <str> end end ns_list . each { | ns | cmd = <str> ns <str> proc_name <str> unless Tk . info ( <str> , cmd ) . empty? warn <str> cmd <str> if $DEBUG next end TkNamespace . eval ( ns ) { TkCore :: INTERP . add_tk_procs ( proc_name , <str> , <<- <str> EOS <str> ) <str> EOS } } end def self . load_images ( imgdir , pat = nil ) if Tk :: Tile :: TILE_SPEC_VERSION_ID < <int> if Tk :: Tile :: USE_TTK_NAMESPACE cmd = <str> else cmd = <str> end pat || = TkComm :: None images = Hash [ * TkComm . simplelist ( Tk . tk_call ( cmd , imgdir , pat ) ) ] images . keys . each { | k | images [ k ] = TkPhotoImage . new ( <str> = > images [ k ] , <str> = > true ) } else pat || = <str> if pat . kind_of? ( Array ) pat_list = pat else pat_list = [ pat ] end Dir . chdir ( imgdir ) { pat_list . each { | pat | Dir . glob ( pat ) . each { | f | img = File . basename ( f , <str> ) unless TkComm . bool ( Tk . info ( <str> , <str> img <str> ) ) Tk . tk_call ( <str> , <str> img <str> , Tk . tk_call ( <str> , <str> , <str> , <str> , f ) ) end } } } images = Hash [ * TkComm . simplelist ( Tk . tk_call ( <str> , <str> , <str> ) ) ] images . keys . each { | k | images [ k ] = TkPhotoImage . new ( <str> = > images [ k ] , <str> = > true ) } end images end def self . style ( * args ) args . map! { | arg | TkComm . _get_eval_string ( arg ) } . join ( <str> ) end def self . themes ( glob_ptn = nil ) if TILE_SPEC_VERSION_ID < <int> && Tk . info ( <str> , <str> ) . empty? fail RuntimeError , <str> if glob_ptn cmd = [ <str> ] else glob_ptn = <str> unless glob_ptn cmd = [ <str> , glob_ptn ] end begin TkComm . simplelist ( Tk . tk_call_without_enc ( * cmd ) ) rescue TkComm . simplelist ( Tk . tk_call ( <str> , <str> , <str> , Tk :: Tile :: Style . theme_names , glob_ptn ) ) end end def self . set_theme ( theme ) if TILE_SPEC_VERSION_ID < <int> && Tk . info ( <str> , <str> ) . empty? cmd = <str> else cmd = <str> end begin Tk . tk_call_without_enc ( cmd , theme ) rescue Tk :: Tile :: Style . theme_use ( theme ) end end module KeyNav if Tk :: Tile :: TILE_SPEC_VERSION_ID < <int> def self . enableMnemonics ( w ) Tk . tk_call ( <str> , w ) end def self . defaultButton ( w ) Tk . tk_call ( <str> , w ) end else def self . enableMnemonics ( w ) <str> end def self . defaultButton ( w ) <str> end end end module Font Default = <str> Text = <str> Heading = <str> Caption = <str> Tooltip = <str> Fixed = <str> Menu = <str> SmallCaption = <str> Icon = <str> TkFont :: SYSTEM_FONT_NAMES . add [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] end module ParseStyleLayout def _style_layout ( lst ) ret = [ ] until lst . empty? sub = [ lst . shift ] keys = { } until lst . empty? if lst [ <int> ] [ <int> ] == <str> k = lst . shift [ <int> .. - <int> ] children = lst . shift children = _style_layout ( children ) if children . kind_of? ( Array ) keys [ k ] = children else break end end sub << keys unless keys . empty? ret << sub end ret end private <str> end module TileWidget include Tk :: Tile :: ParseStyleLayout def __val2ruby_optkeys super ( ) . update ( <str> = > proc { | v | _style_layout ( list ( v ) ) } ) end private <str> def ttk_instate ( state , script = nil , & b ) if script tk_send ( <str> , state , script ) elsif b tk_send ( <str> , state , Proc . new ( & b ) ) else bool ( tk_send ( <str> , state ) ) end end alias tile_instate ttk_instate def ttk_state ( state = nil ) if state tk_send ( <str> , state ) else list ( tk_send ( <str> ) ) end end alias tile_state ttk_state def ttk_identify ( x , y ) ret = tk_send_without_enc ( <str> , x , y ) ( ret . empty? ) ? nil : ret end alias tile_identify ttk_identify if Tk . const_defined? ( <str> ) && Tk :: USE_OBSOLETE_TILE_STATE_METHOD alias instate ttk_instate alias state ttk_state alias identify ttk_identify end end autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> autoload <str> , <str> end end Ttk = Tk :: Tile 
