require <str> module Rex module Proto module NTLM class Base CONST = Rex :: Proto :: NTLM :: Constants class Field attr_accessor <str> , <str> def initialize ( opts ) @value = opts [ <str> ] @active = opts [ <str> ] . nil? ? true : opts [ <str> ] end def size @active ? @size : <int> end end class String < Field def initialize ( opts ) super ( opts ) @size = opts [ <str> ] end def parse ( str , offset = <int> ) if @active and str . size > = offset + @size @value = str [ offset , @size ] @size else <int> end end def serialize if @active @value else <str> end end def value = ( val ) @value = val @size = @value . nil? ? <int> : @value . size @active = ( @size > <int> ) end end class Int16LE < Field def initialize ( opt ) super ( opt ) @size = <int> end def parse ( str , offset = <int> ) if @active and str . size > = offset + @size @value = str [ offset , @size ] . unpack ( <str> ) [ <int> ] @size else <int> end end def serialize [ @value ] . pack ( <str> ) end end class Int32LE < Field def initialize ( opt ) super ( opt ) @size = <int> end def parse ( str , offset = <int> ) if @active and str . size > = offset + @size @value = str . slice ( offset , @size ) . unpack ( <str> ) [ <int> ] @size else <int> end end def serialize [ @value ] . pack ( <str> ) if @active end end class Int64LE < Field def initialize ( opt ) super ( opt ) @size = <int> end def parse ( str , offset = <int> ) if @active and str . size > = offset + @size d , u = str . slice ( offset , @size ) . unpack ( <str> ) @value = ( u * <hex> + d ) @size else <int> end end def serialize [ @value & <hex> , @value >> <int> ] . pack ( <str> ) if @active end end class FieldSet class << FieldSet def define ( & block ) klass = Class . new ( self ) do def self . inherited ( subclass ) proto = @proto subclass . instance_eval do @proto = proto end end end klass . module_eval ( & block ) klass end def string ( name , opts ) add_field ( name , String , opts ) end def int16LE ( name , opts ) add_field ( name , Int16LE , opts ) end def int32LE ( name , opts ) add_field ( name , Int32LE , opts ) end def int64LE ( name , opts ) add_field ( name , Int64LE , opts ) end def security_buffer ( name , opts ) add_field ( name , SecurityBuffer , opts ) end def prototypes @proto end def names @proto . map { | n , t , o | n } end def types @proto . map { | n , t , o | t } end def opts @proto . map { | n , t , o | o } end private def add_field ( name , type , opts ) ( @proto || = [ ] ) . push [ name , type , opts ] define_accessor name end def define_accessor ( name ) module_eval ( <<- <str> End <str> , __FILE__ , __LINE__ + <int> ) <str> End end end def initialize @alist = self . class . prototypes . map { | n , t , o | [ n , t . new ( o ) ] } end def serialize @alist . map { | n , f | f . serialize } . join end def parse ( str , offset = <int> ) @alist . inject ( offset ) { | cur , a | cur += a [ <int> ] . parse ( str , cur ) } end def size @alist . inject ( <int> ) { | sum , a | sum += a [ <int> ] . size } end def [] ( name ) a = @alist . assoc ( name . to_s . intern ) raise ArgumentError , <str> name <str> unless a a [ <int> ] end def []= ( name , val ) a = @alist . assoc ( name . to_s . intern ) raise ArgumentError , <str> name <str> unless a a [ <int> ] = val end def enable ( name ) self [ name ] . active = true end def disable ( name ) self [ name ] . active = false end end Blob = FieldSet . define { int32LE <str> , { <str> = > CONST :: BLOB_SIGN } int32LE <str> , { <str> = > <int> } int64LE <str> , { <str> = > <int> } string <str> , { <str> = > <str> , <str> = > <int> } int32LE <str> , { <str> = > <int> } string <str> , { <str> = > <str> , <str> = > <int> } int32LE <str> , { <str> = > <int> } } SecurityBuffer = FieldSet . define { int16LE <str> , { <str> = > <int> } int16LE <str> , { <str> = > <int> } int32LE <str> , { <str> = > <int> } } class SecurityBuffer attr_accessor <str> def initialize ( opts ) super ( ) @value = opts [ <str> ] @active = opts [ <str> ] . nil? ? true : opts [ <str> ] @size = <int> end def parse ( str , offset = <int> ) if @active and str . size > = offset + @size super ( str , offset ) @value = str [ self . offset , self . length ] @size else <int> end end def serialize super if @active end def value @value end def value = ( val ) @value = val self . length = self . allocated = val . size end def data_size @active ? @value . size : <int> end end end end end end 
