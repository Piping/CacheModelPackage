require <str> require <str> require <str> require <str> require <str> require <str> shared_examples_for <str> do let ( <str> ) { tmpfile ( <str> ) } describe <str> do with_digest_algorithms do it <str> do request = nil klass . any_instance . expects ( <str> ) . with { | r | request = r } . returns ( Puppet :: FileBucket :: File . new ( plaintext ) ) expect ( dipper . restore ( dest , checksum ) ) . to eq ( checksum ) expect ( digest ( Puppet :: FileSystem . binread ( dest ) ) ) . to eq ( checksum ) expect ( request . key ) . to eq ( <str> digest_algorithm <str> checksum <str> ) expect ( request . server ) . to eq ( server ) expect ( request . port ) . to eq ( port ) end it <str> do File . open ( dest , <str> ) { | f | f . print ( plaintext ) } dipper . expects ( <str> ) . never expect ( dipper . restore ( dest , checksum ) ) . to be_nil end it <str> do klass . any_instance . expects ( <str> ) . returns ( Puppet :: FileBucket :: File . new ( plaintext ) ) File . open ( dest , <str> ) { | f | f . print ( <str> ) } expect ( dipper . restore ( dest , checksum ) ) . to eq ( checksum ) end end end end describe Puppet :: FileBucket :: Dipper , <str> = > true do include PuppetSpec :: Files def make_tmp_file ( contents ) file = tmpfile ( <str> ) File . open ( file , <str> ) { | f | f . write ( contents ) } file end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > make_absolute ( <str> ) ) file = make_tmp_file ( <str> ) Puppet :: FileBucket :: File . indirection . expects ( <str> ) . raises ArgumentError expect { @dipper . backup ( file ) } . to raise_error ( Puppet :: Error ) end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > make_absolute ( <str> ) ) file = make_tmp_file ( <str> ) Puppet :: FileBucket :: File . indirection . expects ( <str> ) . returns false Puppet :: FileBucket :: File . indirection . expects ( <str> ) . raises ArgumentError expect { @dipper . backup ( file ) } . to raise_error ( Puppet :: Error ) end describe <str> do describe <str> , <str> = > Puppet . features . microsoft_windows? do with_digest_algorithms do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > tmpdir ( <str> ) ) wrong_checksum = <str> expect { @dipper . diff ( wrong_checksum , <str> , nil , nil ) } . to raise_error ( RuntimeError , <str> wrong_checksum . inspect <str> ) file = make_tmp_file ( plaintext ) @dipper . backup ( file ) expect { @dipper . diff ( checksum , wrong_checksum , nil , nil ) } . to raise_error ( RuntimeError , <str> wrong_checksum <str> ) end it <str> do file1 = make_tmp_file ( <str> ) file2 = make_tmp_file ( <str> ) @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > tmpdir ( <str> ) ) checksum1 = @dipper . backup ( file1 ) checksum2 = @dipper . backup ( file2 ) diff12 = <str> file1 <str> file2 <str> diff21 = <str> file2 <str> file1 <str> expect ( @dipper . diff ( checksum1 , checksum2 , nil , nil ) ) . to include ( diff12 ) expect ( @dipper . diff ( checksum1 , nil , nil , file2 ) ) . to include ( diff12 ) expect ( @dipper . diff ( nil , checksum2 , file1 , nil ) ) . to include ( diff12 ) expect ( @dipper . diff ( nil , nil , file1 , file2 ) ) . to include ( diff12 ) expect ( @dipper . diff ( checksum2 , checksum1 , nil , nil ) ) . to include ( diff21 ) expect ( @dipper . diff ( checksum2 , nil , nil , file1 ) ) . to include ( diff21 ) expect ( @dipper . diff ( nil , checksum1 , file2 , nil ) ) . to include ( diff21 ) expect ( @dipper . diff ( nil , nil , file2 , file1 ) ) . to include ( diff21 ) end end describe <str> , <str> = > Puppet . features . microsoft_windows? do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > tmpdir ( <str> ) ) wrong_checksum = <str> expect { @dipper . diff ( wrong_checksum , <str> , nil , nil ) } . to raise_error ( RuntimeError , <str> ) expect { @dipper . diff ( checksum , wrong_checksum , nil , nil ) } . to raise_error ( RuntimeError , <str> ) end end end end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> ) Puppet :: FileBucket :: File . indirection . expects ( <str> ) . returns nil expect { @dipper . list ( nil , nil ) } . to raise_error ( Puppet :: Error ) end describe <str> do with_digest_algorithms do it <str> do Puppet [ <str> ] = <str> file_bucket = tmpdir ( <str> ) @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > file_bucket ) onehour = <int> * <int> twohours = onehour * <int> file1 = make_tmp_file ( plaintext ) real_path = Pathname . new ( file1 ) . realpath expect ( digest ( plaintext ) ) . to eq ( checksum ) expect ( @dipper . backup ( file1 ) ) . to eq ( checksum ) expected_list1_1 = <str> checksum <str> real_path <str> File . open ( file1 , <str> ) { | f | f . write ( <str> ) } new_checksum = digest ( <str> ) expect ( @dipper . backup ( file1 ) ) . to eq ( new_checksum ) expected_list1_2 = <str> new_checksum <str> real_path <str> content = <str> file2 = make_tmp_file ( content ) real_path = Pathname . new ( file2 ) . realpath checksum = digest ( content ) expect ( @dipper . backup ( file2 ) ) . to eq ( checksum ) expected_list2 = <str> checksum <str> real_path <str> file3 = make_tmp_file ( plaintext ) real_path = Pathname . new ( file3 ) . realpath checksum = digest ( plaintext ) expect ( digest ( plaintext ) ) . to eq ( checksum ) expect ( @dipper . backup ( file3 ) ) . to eq ( checksum ) date = Time . now expected_list3 = <str> checksum <str> real_path <str> result = @dipper . list ( nil , nil ) expect ( result ) . to match ( expected_list1_1 ) expect ( result ) . to match ( expected_list1_2 ) expect ( result ) . to match ( expected_list2 ) expect ( result ) . to match ( expected_list3 ) end it <str> do Puppet [ <str> ] = <str> file_bucket = tmpdir ( <str> ) twentyminutes = <int> * <int> thirtyminutes = <int> * <int> onehour = <int> * <int> twohours = onehour * <int> threehours = onehour * <int> @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > file_bucket ) file1 = make_tmp_file ( plaintext ) real_path = Pathname . new ( file1 ) . realpath expect ( digest ( plaintext ) ) . to eq ( checksum ) expect ( @dipper . backup ( file1 ) ) . to eq ( checksum ) expected_list1 = <str> checksum <str> real_path <str> content = <str> file2 = make_tmp_file ( content ) real_path = Pathname . new ( file2 ) . realpath checksum = digest ( content ) expect ( @dipper . backup ( file2 ) ) . to eq ( checksum ) onehourago = Time . now - onehour bucketed_paths_file = Dir . glob ( <str> file_bucket <str> checksum <str> ) FileUtils . touch ( bucketed_paths_file , <str> = > onehourago ) expected_list2 = <str> checksum <str> real_path <str> now = Time . now expect ( @dipper . list ( ( now + threehours ) . strftime ( <str> ) , nil ) ) . to eq ( <str> ) expect ( @dipper . list ( nil , ( now + twohours ) . strftime ( <str> ) ) ) . to match ( expected_list1 ) expect ( @dipper . list ( nil , ( now + twohours ) . strftime ( <str> ) ) ) . to match ( expected_list2 ) expect ( @dipper . list ( ( now + <int> ) . strftime ( <str> ) , ( now + twohours ) . strftime ( <str> ) ) ) . to eq ( <str> ) expect ( @dipper . list ( ( now - thirtyminutes ) . strftime ( <str> ) , ( now - twentyminutes ) . strftime ( <str> ) ) ) . to eq ( <str> ) expect ( @dipper . list ( ( now - twohours ) . strftime ( <str> ) , ( now - thirtyminutes ) . strftime ( <str> ) ) ) . to match ( expected_list2 ) expect ( @dipper . list ( ( now - twohours ) . strftime ( <str> ) , ( now - thirtyminutes ) . strftime ( <str> ) ) ) . not_to match ( expected_list1 ) expect ( @dipper . list ( ( now - thirtyminutes ) . strftime ( <str> ) , now . strftime ( <str> ) ) ) . to match ( expected_list1 ) expect ( @dipper . list ( ( now - thirtyminutes ) . strftime ( <str> ) , now . strftime ( <str> ) ) ) . not_to match ( expected_list2 ) end end end describe <str> do describe <str> , <str> = > Puppet . features . microsoft_windows? do with_digest_algorithms do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) wrong_checksum = <str> Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . returns ( nil ) expect { @dipper . diff ( wrong_checksum , <str> , nil , nil ) } . to raise_error ( Puppet :: Error , <str> ) end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . returns ( <str> ) expect ( @dipper . diff ( <str> , <str> , nil , nil ) ) . to eq ( <str> ) end end end describe <str> , <str> = > Puppet . features . microsoft_windows? do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) wrong_checksum = <str> expect { @dipper . diff ( wrong_checksum , <str> , nil , nil ) } . to raise_error ( RuntimeError , <str> ) expect { @dipper . diff ( wrong_checksum , nil , nil , nil ) } . to raise_error ( RuntimeError , <str> ) end end end describe <str> do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) expect { @dipper . list ( nil , nil ) } . to raise_error ( Puppet :: Error , <str> ) end end describe <str> do with_digest_algorithms do it <str> do Puppet [ <str> ] = <str> file_bucket = tmpdir ( <str> ) @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > file_bucket ) file = make_tmp_file ( plaintext ) expect ( digest ( plaintext ) ) . to eq ( checksum ) expect ( @dipper . backup ( file ) ) . to eq ( checksum ) expect ( Puppet :: FileSystem . exist? ( <str> file_bucket <str> bucket_dir <str> ) ) . to eq ( true ) end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> ) file = make_tmp_file ( plaintext ) Puppet :: FileBucket :: File . indirection . expects ( <str> ) . returns true Puppet :: FileBucket :: File . indirection . expects ( <str> ) . never expect ( @dipper . backup ( file ) ) . to eq ( checksum ) end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> ) request = nil Puppet :: FileBucketFile :: File . any_instance . expects ( <str> ) . with { | r | request = r } . once . returns ( Puppet :: FileBucket :: File . new ( plaintext ) ) expect ( @dipper . getfile ( checksum ) ) . to eq ( plaintext ) expect ( request . key ) . to eq ( <str> digest_algorithm <str> checksum <str> ) end end end describe <str> do with_digest_algorithms do it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) file = make_tmp_file ( plaintext ) real_path = Pathname . new ( file ) . realpath request1 = nil request2 = nil Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . with { | r | request1 = r } . once . returns ( nil ) Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . with { | r | request2 = r } . once expect ( @dipper . backup ( file ) ) . to eq ( checksum ) [ request1 , request2 ] . each do | r | expect ( r . server ) . to eq ( <str> ) expect ( r . port ) . to eq ( <int> ) expect ( r . key ) . to eq ( <str> digest_algorithm <str> checksum <str> real_path <str> ) end end it <str> do @dipper = Puppet :: FileBucket :: Dipper . new ( <str> = > <str> , <str> = > <str> ) request = nil Puppet :: FileBucketFile :: Rest . any_instance . expects ( <str> ) . with { | r | request = r } . returns ( Puppet :: FileBucket :: File . new ( plaintext ) ) expect ( @dipper . getfile ( checksum ) ) . to eq ( plaintext ) expect ( request . server ) . to eq ( <str> ) expect ( request . port ) . to eq ( <int> ) expect ( request . key ) . to eq ( <str> digest_algorithm <str> checksum <str> ) end end end describe <str> do describe <str> do let ( <str> ) { Puppet :: FileBucketFile :: Rest } let ( <str> ) { <str> } let ( <str> ) { <int> } it_behaves_like <str> do let ( <str> ) { Puppet :: FileBucket :: Dipper . new ( <str> = > server , <str> = > port . to_s ) } end end describe <str> do let ( <str> ) { Puppet :: FileBucketFile :: File } let ( <str> ) { nil } let ( <str> ) { nil } it_behaves_like <str> do let ( <str> ) { Puppet :: FileBucket :: Dipper . new ( <str> = > <str> ) } end end end end 
