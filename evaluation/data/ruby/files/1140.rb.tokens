require <str> module Tk module RbWidget class AutoScrollListbox < TkListbox end class Combobox < TkEntry end end end class Tk :: RbWidget :: AutoScrollListbox include TkComposite @@up_bmp = TkBitmapImage . new ( <str> = > << <str> EOD <str> ) <str> EOD @@down_bmp = TkBitmapImage . new ( <str> = > << <str> EOD <str> ) <str> EOD private def initialize_composite ( keys = { } ) keys = _symbolkey2str ( keys ) @initwait = keys . delete ( <str> ) { <int> } @interval = keys . delete ( <str> ) { <int> } @initwait -= @interval @initwait = <int> if @initwait < <int> @lbox = TkListbox . new ( @frame , <str> = > <int> ) @path = @lbox . path TkPack . propagate ( @lbox , false ) @scr = TkScrollbar . new ( @frame , <str> = > <int> ) @lbox . yscrollcommand ( proc { | * args | @scr . set ( * args ) ; _config_proc } ) @scr . command ( proc { | * args | @lbox . yview ( * args ) ; _config_proc } ) @up_arrow = TkLabel . new ( @lbox , <str> = > @@up_bmp , <str> = > <str> , <str> = > <int> ) @down_arrow = TkLabel . new ( @lbox , <str> = > @@down_bmp , <str> = > <str> , <str> = > <int> ) _init_binding @lbox . pack ( <str> = > <str> , <str> = > <str> , <str> = > <str> ) delegate ( <str> , @lbox ) delegate ( <str> , @frame , @scr ) delegate ( <str> , @scr ) delegate ( <str> , @scr ) delegate ( <str> , @scr ) delegate ( <str> , @scr ) delegate ( <str> , @frame ) delegate ( <str> , @frame ) delegate_alias ( <str> , <str> , @up_arrow , @down_arrow ) delegate_alias ( <str> , <str> , @up_arrow , @down_arrow ) scrollbar ( keys . delete ( <str> ) ) { false } configure keys unless keys . empty? end def _show_up_arrow unless @up_arrow . winfo_mapped? @up_arrow . pack ( <str> = > <str> , <str> = > <str> ) end end def _show_down_arrow unless @down_arrow . winfo_mapped? @down_arrow . pack ( <str> = > <str> , <str> = > <str> ) end end def _set_sel ( idx ) @lbox . activate ( idx ) @lbox . selection_clear ( <int> , <str> ) @lbox . selection_set ( idx ) end def _check_sel ( cidx , tidx = nil , bidx = nil ) _set_sel ( cidx ) unless tidx tidx = @lbox . nearest ( <int> ) tidx += <int> if tidx > <int> end unless bidx bidx = @lbox . nearest ( <int> ) bidx -= <int> if bidx < @lbox . index ( <str> ) - <int> end if cidx > bidx _set_sel ( bidx ) end if cidx < tidx _set_sel ( tidx ) end end def _up_proc cidx = @lbox . curselection [ <int> ] idx = @lbox . nearest ( <int> ) if idx > = <int> @lbox . see ( idx - <int> ) _set_sel ( idx ) @up_arrow . pack_forget if idx == <int> @up_timer . stop if idx == <int> _show_down_arrow if @lbox . bbox ( <str> ) == [ ] end if cidx && cidx > <int> && ( idx == <int> || cidx == @lbox . nearest ( <int> ) ) _set_sel ( cidx - <int> ) end end def _down_proc cidx = @lbox . curselection [ <int> ] eidx = @lbox . index ( <str> ) - <int> idx = @lbox . nearest ( <int> ) if idx < = eidx @lbox . see ( idx + <int> ) _set_sel ( cidx + <int> ) if cidx < eidx @down_arrow . pack_forget if idx + <int> == eidx @down_timer . stop if idx == eidx _show_up_arrow if @lbox . bbox ( <int> ) == [ ] end if cidx && cidx < eidx && ( eidx == idx || cidx == @lbox . nearest ( <int> ) ) _set_sel ( cidx + <int> ) end end def _key_UP_proc cidx = @lbox . curselection [ <int> ] _set_sel ( cidx = @lbox . index ( <str> ) ) unless cidx cidx -= <int> if cidx == <int> @up_arrow . pack_forget elsif cidx == @lbox . nearest ( <int> ) @lbox . see ( cidx - <int> ) end end def _key_DOWN_proc cidx = @lbox . curselection [ <int> ] _set_sel ( cidx = @lbox . index ( <str> ) ) unless cidx cidx += <int> if cidx == @lbox . index ( <str> ) - <int> @down_arrow . pack_forget elsif cidx == @lbox . nearest ( <int> ) @lbox . see ( cidx + <int> ) end end def _config_proc if @lbox . size == <int> @up_arrow . pack_forget @down_arrow . pack_forget return end tidx = @lbox . nearest ( <int> ) bidx = @lbox . nearest ( <int> ) if tidx > <int> _show_up_arrow tidx += <int> else @up_arrow . pack_forget unless @up_timer . running? end if bidx < @lbox . index ( <str> ) - <int> _show_down_arrow bidx -= <int> else @down_arrow . pack_forget unless @down_timer . running? end cidx = @lbox . curselection [ <int> ] _check_sel ( cidx , tidx , bidx ) if cidx end def _init_binding @up_timer = TkAfter . new ( @interval , - <int> , proc { _up_proc } ) @down_timer = TkAfter . new ( @interval , - <int> , proc { _down_proc } ) @up_timer . set_start_proc ( @initwait , proc { } ) @down_timer . set_start_proc ( @initwait , proc { } ) @up_arrow . bind ( <str> , proc { @up_timer . start } ) @up_arrow . bind ( <str> , proc { @up_timer . stop if @up_arrow . winfo_mapped? } ) @down_arrow . bind ( <str> , proc { @down_timer . start } ) @down_arrow . bind ( <str> , proc { @down_timer . stop if @down_arrow . winfo_mapped? } ) @lbox . bind ( <str> , proc { _config_proc } ) @lbox . bind ( <str> , proc { | y | _set_sel ( @lbox . nearest ( y ) ) } , <str> ) @lbox . bind ( <str> , proc { | y | @up_timer . stop if @up_timer . running? @down_timer . stop if @down_timer . running? _check_sel ( @lbox . nearest ( y ) ) } , <str> ) @lbox . bind ( <str> , proc { _key_UP_proc } ) @lbox . bind ( <str> , proc { _key_DOWN_proc } ) end public def scrollbar ( mode ) if mode @scr . pack ( <str> = > <str> , <str> = > <str> ) else @scr . pack_forget end end end class Tk :: RbWidget :: Combobox < TkEntry include TkComposite @@down_btn_bmp = TkBitmapImage . new ( <str> = > << <str> EOD <str> ) <str> EOD @@up_btn_bmp = TkBitmapImage . new ( <str> = > << <str> EOD <str> ) <str> EOD def _button_proc ( dir = true ) return if @ent . state == <str> @btn . relief ( <str> ) x = @frame . winfo_rootx y = @frame . winfo_rooty if dir @top . geometry ( <str> x <str> y + @frame . winfo_height <str> ) else @btn . image ( @@up_btn_bmp ) @top . geometry ( <str> x <str> y - @top . winfo_reqheight <str> ) end @top . deiconify @lst . focus if ( idx = values . index ( @ent . value ) ) @lst . see ( idx - <int> ) @lst . activate ( idx ) @lst . selection_set ( idx ) elsif @lst . size > <int> @lst . see ( <int> ) @lst . activate ( <int> ) @lst . selection_set ( <int> ) end @top . grab begin @wait_var . tkwait if ( idx = @wait_var . to_i ) > = <int> _set_entry_value ( @lst . get ( idx ) ) end @top . withdraw @btn . relief ( <str> ) @btn . image ( @@down_btn_bmp ) rescue ensure begin @top . grab ( <str> ) @ent . focus rescue end end end private <str> def _init_bindings @btn . bind ( <str> , proc { _button_proc ( true ) } ) @btn . bind ( <str> , proc { _button_proc ( false ) } ) @lst . bind ( <str> , proc { | y | @wait_var . value = @lst . nearest ( y ) } , <str> ) @lst . bind ( <str> , proc { @wait_var . value = @lst . curselection [ <int> ] } ) cancel = TkVirtualEvent . new ( <str> , <str> , <str> ) @lst . bind ( cancel , proc { @wait_var . value = - <int> } ) end private <str> def _set_entry_value ( val ) @ent . textvariable . value = val end private <str> def _state_control ( value = None ) if value == None @ent . state else @ent . state ( value . to_s ) case value = @ent . state when <str> , <str> @btn . state <str> when <str> @btn . state <str> else end end end private <str> def __methodcall_optkeys { <str> = > <str> } end private <str> def _textvariable_control ( var = None ) if var == None ( ( var = @ent . textvariable ) === @default_var ) ? nil : var else @var = var tk_send ( <str> , <str> , ( @var ) ? <str> : @default_var ) end end private <str> def initialize_composite ( keys = { } ) keys = _symbolkey2str ( keys ) @btn = TkLabel . new ( @frame , <str> = > <str> , <str> = > <int> , <str> = > @@down_btn_bmp ) . pack ( <str> = > <str> , <str> = > <int> , <str> = > <str> ) @ent = TkEntry . new ( @frame ) . pack ( <str> = > <str> ) @path = @ent . path @top = TkToplevel . new ( @btn , <str> = > <int> , <str> = > <str> ) { withdraw transient overrideredirect ( true ) } startwait = keys . delete ( <str> ) { <int> } interval = keys . delete ( <str> ) { <int> } @lst = Tk :: RbWidget :: AutoScrollListbox . new ( @top , <str> = > true , <str> = > startwait , <str> = > interval ) @lst . pack ( <str> = > <str> , <str> = > true ) @ent_list = [ ] @wait_var = TkVariable . new @var = @default_var = TkVariable . new @ent . textvariable @default_var _init_bindings option_methods ( <str> = > <str> ) delegate ( <str> , @ent ) delegate ( <str> , @lst ) delegate ( <str> , @frame ) delegate ( <str> , @frame ) delegate ( <str> , @lst ) delegate ( <str> , @lst ) delegate ( <str> , false ) if mode = keys . delete ( <str> ) scrollbar ( mode ) end configure keys unless keys . empty? end private <str> def scrollbar ( mode ) @lst . scrollbar ( mode ) end def _reset_width len = @ent . width @lst . get ( <int> , <str> ) . each { | l | len = l . length if l . length > len } @lst . width ( len + <int> ) end private <str> def add ( ent ) ent = ent . to_s unless @ent_list . index ( ent ) @ent_list << ent @lst . insert ( <str> , ent ) end _reset_width self end def remove ( ent ) ent = ent . to_s @ent_list . delete ( ent ) if idx = @lst . get ( <int> , <str> ) . index ( ent ) @lst . delete ( idx ) end _reset_width self end def values ( ary = nil ) if ary @lst . delete ( <int> , <str> ) @ent_list . clear ary . each { | ent | add ( ent ) } _reset_width self else @lst . get ( <int> , <str> ) end end def see ( idx ) @lst . see ( @lst . index ( idx ) - <int> ) end def list_index ( idx ) @lst . index ( idx ) end end if __FILE__ == $0 v = TkVariable . new e = Tk :: RbWidget :: Combobox . new ( <str> = > <int> , <str> = > true , <str> = > v , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > <int> ) . pack e . values ( <str> ) e . value = <str> TkFrame . new { | f | fnt = TkFont . new ( <str> ) TkLabel . new ( f , <str> = > fnt , <str> = > <str> ) . pack ( <str> = > <str> ) TkLabel . new ( f , <str> = > fnt , <str> = > v ) . pack ( <str> = > <str> ) } . pack TkFrame . new ( <str> = > <str> , <str> = > <int> , <str> = > <int> ) . pack ( <str> = > <str> , <str> = > true , <str> = > <int> , <str> = > <int> ) l = Tk :: RbWidget :: AutoScrollListbox . new ( nil , <str> = > <str> , <str> = > <int> , <str> = > <int> , <str> = > <int> ) . pack ( <str> = > <str> , <str> = > true ) ( <int> .. <int> ) . each { | i | l . insert ( <str> , <str> i <str> ) } TkFrame . new ( <str> = > <str> , <str> = > <int> ) { TkButton . new ( self , <str> = > <str> , <str> = > proc { l . scrollbar ( true ) } ) . pack ( <str> = > <str> ) TkButton . new ( self , <str> = > <str> , <str> = > proc { l . scrollbar ( false ) } ) . pack ( <str> = > <str> ) pack ( <str> = > <str> ) } Tk . mainloop end 
