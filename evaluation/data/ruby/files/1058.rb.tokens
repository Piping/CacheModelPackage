module Bosh::Cli class ParseTreeNode < Hash attr_accessor <str> end class Runner attr_reader <str> attr_reader <str> def self . run ( args ) new ( args ) . run end def initialize ( args , options = { } ) @args = args @options = options . dup banner = <str> @option_parser = OptionParser . new ( banner ) Config . colorize = nil if ENV . has_key? ( <str> ) && ENV [ <str> ] == <str> Config . colorize = false end Config . output || = STDOUT parse_global_options end def run ( exit_on_success = true ) Config . interactive = ! @options [ <str> ] Config . poll_interval = @options [ <str> ] load_plugins build_parse_tree add_shortcuts @args = <str> if @args . empty? command = search_parse_tree ( @parse_tree ) if command . nil? && Config . interactive command = try_alias end if command . nil? err ( <str> @args . join ( <str> ) <str> ) end command . runner = self begin exit_code , info = command . run ( @args , @options ) exit ( exit_code ) if exit_on_success || exit_code != <int> [ exit_code , info ] rescue OptionParser :: ParseError = > e say_err ( e . message ) nl say_err ( <str> command . usage_with_params . columnize ( <int> , <int> ) <str> ) nl if command . has_options? say ( command . options_summary . indent ( <int> ) ) end exit ( <int> ) end rescue OptionParser :: ParseError = > e say_err ( e . message ) say_err ( @option_parser . to_s ) exit ( <int> ) rescue Bosh :: Cli :: CliError = > e say_err ( e . message ) nl exit ( e . exit_code ) end def find_completions ( words , node = @parse_tree , index = <int> ) word = words [ index ] if node [ word ] && words . length != index find_completions ( words , node [ word ] , index + <int> ) elsif node [ word ] node [ word ] . values else node . keys . grep ( <str> word <str> ) end end def parse_global_options if @args . size == <int> && ( @args [ <int> ] == <str> || @args [ <int> ] == <str> ) @args = <str> return end opts = @option_parser config_desc = <str> + <str> + <str> + <str> opts . on ( <str> , <str> , config_desc ) do | file | @options [ <str> ] = file end opts . on ( <str> , <str> ) do | max | Config . max_parallel_downloads = Integer ( max ) end opts . on ( <str> , <str> ) do | v | Config . colorize = v end opts . on ( <str> , <str> , <str> ) do @options [ <str> ] = true end opts . on ( <str> , <str> , <str> ) do Config . output = nil end opts . on ( <str> , <str> , <str> ) do @options [ <str> ] = true end opts . on ( <str> , <str> , <str> ) do @options [ <str> ] = true end opts . on ( <str> , <str> , <str> ) do | interval | @options [ <str> ] = Integer ( interval ) end opts . on ( <str> , <str> , <str> ) do | target | @options [ <str> ] = target end opts . on ( <str> , <str> , <str> ) do | user | @options [ <str> ] = user end opts . on ( <str> , <str> , <str> ) do | pass | @options [ <str> ] = pass end opts . on ( <str> , <str> , <str> ) do | file | @options [ <str> ] = file end opts . on ( <str> , <str> , <str> ) do @args << <str> end opts . on ( <str> , <str> ) do | file | @options [ <str> ] = file end @args = @option_parser . order! ( @args ) end def plugins_glob ; <str> ; end def load_plugins load_local_plugins load_gem_plugins end def load_local_plugins Dir . glob ( File . join ( <str> , plugins_glob ) ) . each do | file | say ( <str> file <str> ) require_plugin ( file ) end end def load_gem_plugins get_gem_plugins . each do | plugin_path | original_commands = Config . commands . size begin next unless require_plugin plugin_path rescue Exception = > e err ( <str> plugin_path <str> e . message <str> . make_red ) end if Config . commands =~ original_commands say ( ( <str> plugin_path <str> + <str> + <str> ) . columnize ( <int> ) . make_yellow ) end end end def get_gem_plugins Gem :: Specification . latest_specs ( true ) . map { | spec | spec . matches_for_glob ( plugins_glob ) } . flatten . uniq rescue err ( <str> . make_yellow + <str> . make_yellow + <str> . make_yellow ) end def require_plugin ( file ) require File . absolute_path ( file ) end def build_parse_tree @parse_tree = ParseTreeNode . new Config . commands . each_value do | command | p = @parse_tree n_kw = command . keywords . size command . keywords . each_with_index do | kw , i | p [ kw ] || = ParseTreeNode . new p = p [ kw ] p . command = command if i == n_kw - <int> end end end def add_shortcuts { <str> = > <str> , <str> = > <str> , <str> = > <str> } . each do | short , long | @parse_tree [ short ] = @parse_tree [ long ] end end def usage @option_parser . to_s end def search_parse_tree ( node ) return nil if node . nil? arg = @args . shift longer_command = search_parse_tree ( node [ arg ] ) if longer_command . nil? @args . unshift ( arg ) if arg node . command else longer_command end end def try_alias config = Bosh :: Cli :: Config . new ( @options [ <str> ] ) candidate = [ ] best_match = nil save_args = @args . dup while ( arg = @args . shift ) candidate << arg resolved = config . resolve_alias ( <str> , candidate . join ( <str> ) ) if best_match && resolved . nil? @args . unshift ( arg ) break end best_match = resolved end if best_match . nil? @args = save_args return end best_match . split ( <str> ) . reverse . each do | keyword | @args . unshift ( keyword ) end search_parse_tree ( @parse_tree ) end private def say_err ( message ) $stderr << message . make_red end end end 
