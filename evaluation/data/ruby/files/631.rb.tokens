require <str> require <str> require <str> require <str> require <str> require <str> module Rex module Text @@codepage_map_cache = nil TLDs = [ <str> , <str> , <str> , <str> , <str> , <str> ] States = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] UpperAlpha = <str> LowerAlpha = <str> Numerals = <str> Base32 = <str> Base64 = UpperAlpha + LowerAlpha + Numerals + <str> Base64Url = UpperAlpha + LowerAlpha + Numerals + <str> Alpha = UpperAlpha + LowerAlpha AlphaNumeric = Alpha + Numerals HighAscii = [ * ( <hex> .. <hex> ) ] . pack ( <str> ) LowAscii = [ * ( <hex> .. <hex> ) ] . pack ( <str> ) DefaultWrap = <int> AllChars = [ * ( <hex> .. <hex> ) ] . pack ( <str> ) Punctuation = ( [ * ( <hex> .. <hex> ) ] + [ * ( <hex> .. <hex> ) ] + [ * ( <hex> .. <hex> ) ] + [ * ( <hex> .. <hex> ) ] ) . flatten . pack ( <str> ) DefaultPatternSets = [ Rex :: Text :: UpperAlpha , Rex :: Text :: LowerAlpha , Rex :: Text :: Numerals ] Iconv_IBM1047 = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] Iconv_ISO8859_1 = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] Iconv_EBCDIC = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , nil , <str> , nil , nil , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil ] Iconv_ASCII = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , nil , <str> , nil , nil , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil , nil ] Surnames = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] Names_Male = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] Names_Female = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] def self . to_ruby ( str , wrap = DefaultWrap , name = <str> ) return hexify ( str , wrap , <str> , <str> , <str> name <str> , <str> ) end def self . to_num ( str , wrap = DefaultWrap ) code = str . unpack ( <str> ) buff = <str> <int> . upto ( code . length - <int> ) do | byte | if ( byte % <int> == <int> ) and ( buff . length > <int> ) buff << <str> end buff << sprintf ( <str> , code [ byte ] ) end buff = buff . chomp ( <str> ) buff << <str> return buff end def self . to_dword ( str , wrap = DefaultWrap ) code = str alignnr = str . length % <int> if ( alignnr > <int> ) code << <str> * ( <int> - alignnr ) end codevalues = Array . new code . split ( <str> ) . each_slice ( <int> ) do | chars4 | chars4 = chars4 . join ( <str> ) dwordvalue = chars4 . unpack ( <str> ) codevalues . push ( dwordvalue [ <int> ] ) end buff = <str> <int> . upto ( codevalues . length - <int> ) do | byte | if ( byte % <int> == <int> ) and ( buff . length > <int> ) buff << <str> end buff << sprintf ( <str> , codevalues [ byte ] ) end buff = buff . chomp ( <str> ) buff << <str> return buff end def self . to_ruby_comment ( str , wrap = DefaultWrap ) return wordwrap ( str , <int> , wrap , <str> , <str> ) end def self . to_c ( str , wrap = DefaultWrap , name = <str> ) return hexify ( str , wrap , <str> , <str> , <str> name <str> , <str> ) end def self . to_csharp ( str , wrap = DefaultWrap , name = <str> ) ret = <str> name <str> str . length <str> i = - <int> ; while ( i += <int> ) < str . length ret << <str> if i <str> == <int> ret << <str> << str [ i ] . unpack ( <str> ) [ <int> ] << <str> end ret = ret [ <int> .. ret . length - <int> ] ret << <str> end def self . to_c_comment ( str , wrap = DefaultWrap ) return <str> + wordwrap ( str , <int> , wrap , <str> , <str> ) + <str> end def self . to_js_comment ( str , wrap = DefaultWrap ) return wordwrap ( str , <int> , wrap , <str> , <str> ) end def self . to_perl ( str , wrap = DefaultWrap , name = <str> ) return hexify ( str , wrap , <str> , <str> , <str> name <str> , <str> ) end def self . to_python ( str , wrap = DefaultWrap , name = <str> ) return hexify ( str , wrap , <str> name <str> , <str> , <str> name <str> , <str> ) end def self . to_bash ( str , wrap = DefaultWrap , name = <str> ) return hexify ( str , wrap , <str> , <str> , <str> name <str> , <str> ) end def self . to_java ( str , name = <str> ) buff = <str> name <str> cnt = <int> max = <int> str . unpack ( <str> ) . each do | c | buff << <str> if max > <int> buff << <str> if max == <int> buff << sprintf ( <str> , c ) max += <int> cnt += <int> if ( max > <int> ) buff << <str> if cnt != str . length max = <int> end end buff << <str> return buff end def self . to_powershell ( str , name = <str> ) return Rex :: Powershell :: Script . to_byte_array ( str , name ) end def self . to_vbscript ( str , name = <str> ) return <str> name <str> if str . nil? or str . empty? code = str . unpack ( <str> ) buff = <str> name <str> code [ <int> ] <str> <int> . upto ( code . length - <int> ) do | byte | if ( byte % <int> == <int> ) buff << <str> name <str> name <str> end buff << <str> code [ byte ] <str> end return buff end def self . to_vbapplication ( str , name = <str> ) return <str> name <str> if str . nil? or str . empty? code = str . unpack ( <str> ) buff = <str> name <str> maxbytes = <int> <int> . upto ( code . length ) do | idx | buff << code [ idx ] . to_s buff << <str> if idx < code . length - <int> buff << <str> if ( idx > <int> and ( idx % maxbytes ) == <int> ) end buff << <str> return buff end def self . to_perl_comment ( str , wrap = DefaultWrap ) return wordwrap ( str , <int> , wrap , <str> , <str> ) end def self . to_bash_comment ( str , wrap = DefaultWrap ) return wordwrap ( str , <int> , wrap , <str> , <str> ) end def self . to_raw ( str ) return str end def self . to_utf8 ( str ) str . encode ( <str> , { <str> = > <str> , <str> = > <str> , <str> = > <str> } ) end class IllegalSequence < ArgumentError ; end def self . to_ebcdic ( str ) new_str = [ ] str . each_byte do | x | if Iconv_ASCII . index ( x . chr ) new_str << Iconv_EBCDIC [ Iconv_ASCII . index ( x . chr ) ] else raise Rex :: Text :: IllegalSequence , ( <str> % x ) end end new_str . join end def self . from_ebcdic ( str ) new_str = [ ] str . each_byte do | x | if Iconv_EBCDIC . index ( x . chr ) new_str << Iconv_ASCII [ Iconv_EBCDIC . index ( x . chr ) ] else raise Rex :: Text :: IllegalSequence , ( <str> % x ) end end new_str . join end def self . to_ibm1047 ( str ) return str if str . nil? new_str = [ ] str . each_byte do | x | new_str << Iconv_IBM1047 [ x . ord ] end new_str . join end def self . from_ibm1047 ( str ) return str if str . nil? new_str = [ ] str . each_byte do | x | new_str << Iconv_ISO8859_1 [ x . ord ] end new_str . join end def self . to_words ( str , strict = false ) splits = str . split ( <str> ) splits . reject! { | w | ! ( w =~ <str> ) } if strict splits end def self . refine ( str1 , str2 ) return str1 if str1 == str2 s_words = to_words ( str1 ) o_words = to_words ( str2 ) ( s_words - ( s_words - o_words ) ) . join end def self . to_unescape ( data , endian = ENDIAN_LITTLE , prefix = <str> ) data << <str> if ( data . length % <int> != <int> ) dptr = <int> buff = <str> while ( dptr < data . length ) c1 = data [ dptr , <int> ] . unpack ( <str> ) [ <int> ] dptr += <int> c2 = data [ dptr , <int> ] . unpack ( <str> ) [ <int> ] dptr += <int> if ( endian == ENDIAN_LITTLE ) buff << sprintf ( <str> prefix <str> , c2 , c1 ) else buff << sprintf ( <str> prefix <str> , c1 , c2 ) end end return buff end def self . to_octal ( str , prefix = <str> ) octal = <str> str . each_byte { | b | octal << <str> prefix <str> b . to_s <int> <str> } return octal end def self . to_hex ( str , prefix = <str> , count = <int> ) raise :: RuntimeError , <str> count <str> if ( ( str . length % count ) > <int> ) return str . unpack ( <str> ) [ <int> ] . gsub ( Regexp . new ( <str> count * <int> <str> , nil , <str> ) ) { | s | prefix + s } end def self . to_hex_ascii ( str , prefix = <str> , count = <int> , suffix = nil ) raise :: RuntimeError , <str> count <str> if ( ( str . length % count ) > <int> ) return str . unpack ( <str> ) [ <int> ] . gsub ( Regexp . new ( <str> count * <int> <str> , nil , <str> ) ) { | s | ( <hex> .. <hex> ) === s . to_i ( <int> ) ? s . to_i ( <int> ) . chr : prefix + s + suffix . to_s } end def self . to_unicode ( str = <str> , type = <str> , mode = <str> , size = <str> ) return <str> if not str case type when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> case mode when <str> return str . gsub ( <str> ) { | a | out = <str> if <str> != <str> out = encode_base64 ( to_unicode ( a , <str> ) ) . gsub ( <str> , <str> ) end <str> + out + <str> } else return str . gsub ( <str> ) { | a | out = <str> if a != <str> out = encode_base64 ( to_unicode ( a , <str> ) ) . gsub ( <str> , <str> ) end <str> + out + <str> } end when <str> if size == <str> size = <int> end if size > = <int> and size < = <int> string = <str> str . each_byte { | a | if ( a < <int> || a > <hex> ) || mode != <str> bin = [ a ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] . split ( <str> ) bin . collect! { | a_ | a_ . to_i } out = Array . new ( <int> * size , <int> ) <int> . upto ( size - <int> ) { | i | out [ i ] = <int> out [ i * <int> ] = <int> } i = <int> byte = <int> bin . reverse . each { | bit | if i < <int> mod = ( ( ( size * <int> ) - <int> ) - byte * <int> ) - i out [ mod ] = bit else byte = byte + <int> i = <int> redo end i = i + <int> } if mode != <str> case mode when <str> when <str> done = <int> while done == <int> bits = [ <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ] bits . each { | bit | bit = ( size * <int> ) - bit if bit > <int> set = rand ( <int> ) if out [ bit ] != set out [ bit ] = set done = <int> end end } end else raise TypeError , <str> end end string << [ out . join ( <str> ) ] . pack ( <str> ) else string << [ a ] . pack ( <str> ) end } return string else raise TypeError , <str> end when <str> load_codepage ( ) string = <str> if mode == <str> mode = <int> else mode = mode . to_i end if @@codepage_map_cache [ mode ] . nil? raise TypeError , <str> mode <str> end str . each_byte { | byte | char = [ byte ] . pack ( <str> ) possible = @@codepage_map_cache [ mode ] [ <str> ] [ char ] if possible . nil? raise TypeError , <str> mode <str> char . unpack ( <str> ) [ <int> ] <str> end string << possible [ rand ( possible . length ) ] } return string when <str> load_codepage ( ) string = <str> if mode == <str> mode = <int> else mode = mode . to_i end if mode != <int> raise TypeError , <str> mode <str> end str . each_byte { | byte | if ( ( byte > = <int> && byte < = <int> ) || ( byte > = <int> && byte < = <int> ) ) string << <str> + [ byte ^ <int> ] . pack ( <str> ) elsif ( byte > = <int> && byte < = <int> ) string << <str> + [ byte ^ <int> ] . pack ( <str> ) else char = [ byte ] . pack ( <str> ) possible = @@codepage_map_cache [ mode ] [ <str> ] [ char ] if possible . nil? raise TypeError , <str> mode <str> char . unpack ( <str> ) [ <int> ] <str> end string << possible [ rand ( possible . length ) ] end } return string else raise TypeError , <str> end end def self . to_ascii ( str = <str> , type = <str> , mode = <str> , size = <str> ) return <str> if not str case type when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> return str . unpack ( <str> ) . pack ( <str> ) when <str> raise TypeError , <str> when <str> raise TypeError , <str> when <str> raise TypeError , <str> when <str> raise TypeError , <str> else raise TypeError , <str> end end def self . uri_encode ( str , mode = <str> ) return <str> if str == nil return str if mode == <str> all = <str> noslashes = <str> normal = <str> case mode when <str> return str . gsub ( all ) { | s | Rex :: Text . to_hex ( s , <str> ) } when <str> return str . gsub ( normal ) { | s | Rex :: Text . to_hex ( s , <str> ) } when <str> return str . gsub ( noslashes ) { | s | Rex :: Text . to_hex ( s , <str> ) } when <str> res = <str> str . each_byte do | c | b = c . chr res << ( ( rand ( <int> ) == <int> ) ? b . gsub ( all ) { | s | Rex :: Text . to_hex ( s , <str> ) } : b . gsub ( normal ) { | s | Rex :: Text . to_hex ( s , <str> ) } ) end return res when <str> return str . gsub ( all ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } when <str> return str . gsub ( normal ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } when <str> return str . gsub ( noslashes ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } when <str> res = <str> str . each_byte do | c | b = c . chr res << ( ( rand ( <int> ) == <int> ) ? b . gsub ( all ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } : b . gsub ( normal ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } ) end return res when <str> return str . gsub ( all ) { | s | Rex :: Text . to_hex ( Rex :: Text . to_unicode ( s , <str> ) , <str> , <int> ) } else raise TypeError , <str> mode . inspect <str> end end def self . html_encode ( str , mode = <str> ) case mode when <str> return str . unpack ( <str> ) . collect { | i | <str> + ( <str> % i ) + <str> } . join when <str> return str . unpack ( <str> ) . collect { | i | <str> + i . to_s + <str> } . join when <str> return str . unpack ( <str> ) . collect { | i | <str> + ( <str> * ( <int> - i . to_s . length ) ) + i . to_s + <str> } . join else raise TypeError , <str> end end def self . html_decode ( str ) decoded_str = CGI . unescapeHTML ( str ) return decoded_str end def self . xml_char_encode ( str ) self . to_hex_ascii ( str , <str> , <int> , <str> ) end def self . uri_decode ( str ) str . gsub ( <str> ) { | c | [ c [ <int> , <int> ] ] . pack ( <str> ) } end def self . to_rand_case ( str ) buf = str . dup <int> . upto ( str . length ) do | i | buf [ i , <int> ] = rand ( <int> ) == <int> ? str [ i , <int> ] . upcase : str [ i , <int> ] . downcase end return buf end def self . to_mixed_case_array ( str ) letters = [ ] str . scan ( <str> ) . each { | l | letters << [ l . downcase , l . upcase ] } coords = [ ] ( <int> << str . size ) . times { | i | coords << ( <str> str . size <str> % i ) } mixed = [ ] coords . each do | coord | c = coord . scan ( <str> ) . map { | x | x . to_i } this_str = <str> c . each_with_index { | d , i | this_str << letters [ i ] [ d ] } mixed << this_str end return mixed . uniq end def self . to_hex_dump ( str , width = <int> , base = nil ) buf = <str> idx = <int> cnt = <int> snl = false lst = <int> lft_col_len = ( base . to_i + str . length ) . to_s ( <int> ) . length lft_col_len = <int> if lft_col_len < <int> while ( idx < str . length ) chunk = str [ idx , width ] addr = base ? <str> lft_col_len <str> <str> : <str> line = chunk . unpack ( <str> ) [ <int> ] . scan ( <str> ) . join ( <str> ) buf << addr + line if ( lst == <int> ) lst = line . length buf << <str> * <int> else buf << <str> * ( ( lst - line . length ) + <int> ) . abs end buf << <str> chunk . unpack ( <str> ) . each do | c | if ( c > <hex> and c < <hex> ) buf << c . chr else buf << <str> end end buf << <str> idx += width end buf << <str> end def self . hex_to_raw ( str ) [ str . downcase . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) ] . pack ( <str> ) end def self . ascii_safe_hex ( str , whitespace = false ) if whitespace str . gsub ( <str> ) { | x | <str> % x . unpack ( <str> ) [ <int> ] } else str . gsub ( <str> ) { | x | <str> % x . unpack ( <str> ) [ <int> ] } end end def self . wordwrap ( str , indent = <int> , col = DefaultWrap , append = <str> , prepend = <str> ) return str . gsub ( <str> col - indent <str> ) { ( ( <str> * indent ) + prepend + $& + append + <int> . chr ) . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) } end def self . hexify ( str , col = DefaultWrap , line_start = <str> , line_end = <str> , buf_start = <str> , buf_end = <str> ) output = buf_start cur = <int> count = <int> new_line = true str . each_byte { | byte | count += <int> append = <str> if ( new_line == true ) append << line_start new_line = false end append << sprintf ( <str> , byte ) cur += append . length if ( ( cur + line_end . length > = col ) or ( cur + buf_end . length > = col ) ) new_line = true cur = <int> if ( count == str . length ) append << buf_end + <str> else append << line_end + <str> end end output << append } if ( new_line == false ) output << buf_end + <str> end return output end def self . cowsay ( text , width = <int> ) text_lines = text . scan ( Regexp . new ( <str> width - <int> <str> ) ) max_length = text_lines . map ( & <str> ) . sort . last cloud_parts = [ ] cloud_parts << <str> * ( max_length + <int> ) <str> if text_lines . size == <int> cloud_parts << <str> text <str> else cloud_parts << <str> text_lines . first . ljust ( max_length , <str> ) <str> if text_lines . size > <int> text_lines [ <int> , text_lines . length - <int> ] . each do | line | cloud_parts << <str> line . ljust ( max_length , <str> ) <str> end end cloud_parts << <str> text_lines . last . ljust ( max_length , <str> ) <str> end cloud_parts << <str> * ( max_length + <int> ) <str> cloud_parts << << <str> EOS <str> <str> EOS cloud_parts . join ( <str> ) end def self . b32encode ( bytes_in ) n = ( bytes_in . length * <int> . <int> / <int> . <int> ) . ceil p = n < <int> ? <int> - ( bytes_in . length * <int> ) % <int> : <int> c = bytes_in . inject ( <int> ) { | m , o | ( m << <int> ) + o } << p [ ( <int> .. n - <int> ) . to_a . reverse . collect { | i | Base32 [ ( c >> i * <int> ) & <hex> ] . chr } , ( <str> * ( <int> - n ) ) ] end def self . encode_base32 ( str ) bytes = str . bytes result = <str> size = <int> while bytes . any? do bytes . each_slice ( size ) do | a | bytes_out = b32encode ( a ) . flatten . join result << bytes_out bytes = bytes . drop ( size ) end end return result end def self . b32decode ( bytes_in ) bytes = bytes_in . take_while { | c | c != <int> } n = ( bytes . length * <int> . <int> / <int> . <int> ) . floor p = bytes . length < <int> ? <int> - ( n * <int> ) % <int> : <int> c = bytes . inject ( <int> ) { | m , o | ( m << <int> ) + Base32 . index ( o . chr ) } >> p ( <int> .. n - <int> ) . to_a . reverse . collect { | i | ( ( c >> i * <int> ) & <hex> ) . chr } end def self . decode_base32 ( str ) bytes = str . bytes result = <str> size = <int> while bytes . any? do bytes . each_slice ( size ) do | a | bytes_out = b32decode ( a ) . flatten . join result << bytes_out bytes = bytes . drop ( size ) end end return result end def self . encode_base64 ( str , delim = <str> ) [ str . to_s ] . pack ( <str> ) . gsub ( <str> , delim ) end def self . decode_base64 ( str ) str . to_s . unpack ( <str> ) [ <int> ] end def self . encode_base64url ( str , delim = <str> ) encode_base64 ( str , delim ) . tr ( <str> , <str> ) . gsub ( <str> , <str> ) end def self . decode_base64url ( str ) decode_base64 ( str . gsub ( <str> , <str> ) . tr ( <str> , <str> ) ) end def self . md5_raw ( str ) Digest :: MD5 . digest ( str ) end def self . md5 ( str ) Digest :: MD5 . hexdigest ( str ) end def self . sha1_raw ( str ) Digest :: SHA1 . digest ( str ) end def self . sha1 ( str ) Digest :: SHA1 . hexdigest ( str ) end def self . dehex ( str ) return str unless str . respond_to? <str> return str unless str . respond_to? <str> regex = <str> if str . match ( regex ) str . gsub ( regex ) { | x | x [ <int> , <int> ] . to_i ( <int> ) . chr } else str end end def self . dehex! ( str ) return str unless str . respond_to? <str> return str unless str . respond_to? <str> regex = <str> str . gsub! ( regex ) { | x | x [ <int> , <int> ] . to_i ( <int> ) . chr } end def self . rand_char ( bad , chars = AllChars ) rand_text ( <int> , bad , chars ) end def self . rand_base ( len , bad , * foo ) cset = ( foo . join . unpack ( <str> ) - bad . to_s . unpack ( <str> ) ) . uniq return <str> if cset . length == <int> outp = [ ] len . times { outp << cset [ rand ( cset . length ) ] } outp . pack ( <str> ) end def self . rand_text ( len , bad = <str> , chars = AllChars ) foo = chars . split ( <str> ) rand_base ( len , bad , * foo ) end def self . rand_text_alpha ( len , bad = <str> ) foo = [ ] foo += ( <str> .. <str> ) . to_a foo += ( <str> .. <str> ) . to_a rand_base ( len , bad , * foo ) end def self . rand_text_alpha_lower ( len , bad = <str> ) rand_base ( len , bad , * ( <str> .. <str> ) . to_a ) end def self . rand_text_alpha_upper ( len , bad = <str> ) rand_base ( len , bad , * ( <str> .. <str> ) . to_a ) end def self . rand_text_alphanumeric ( len , bad = <str> ) foo = [ ] foo += ( <str> .. <str> ) . to_a foo += ( <str> .. <str> ) . to_a foo += ( <str> .. <str> ) . to_a rand_base ( len , bad , * foo ) end def self . rand_text_hex ( len , bad = <str> ) foo = [ ] foo += ( <str> .. <str> ) . to_a foo += ( <str> .. <str> ) . to_a rand_base ( len , bad , * foo ) end def self . rand_text_numeric ( len , bad = <str> ) foo = ( <str> .. <str> ) . to_a rand_base ( len , bad , * foo ) end def self . rand_text_english ( len , bad = <str> ) foo = [ ] foo += ( <hex> .. <hex> ) . map { | c | c . chr } rand_base ( len , bad , * foo ) end def self . rand_text_highascii ( len , bad = <str> ) foo = [ ] foo += ( <hex> .. <hex> ) . map { | c | c . chr } rand_base ( len , bad , * foo ) end def self . rand_text_base64 ( len , bad = <str> ) foo = Base64 . unpack ( <str> ) . map { | c | c . chr } rand_base ( len , bad , * foo ) end def self . rand_text_base64url ( len , bad = <str> ) foo = Base64Url . unpack ( <str> ) . map { | c | c . chr } rand_base ( len , bad , * foo ) end def self . rand_guid <str> [ <int> , <int> , <int> , <int> , <int> ] . map <str> | a | rand_text_hex ( a ) <str> . join ( <str> ) <str> end def self . to_guid ( bytes ) return nil unless bytes s = bytes . unpack ( <str> ) [ <int> ] parts = [ s [ <int> , <int> ] + s [ <int> , <int> ] + s [ <int> , <int> ] + s [ <int> , <int> ] , s [ <int> , <int> ] + s [ <int> , <int> ] , s [ <int> , <int> ] + s [ <int> , <int> ] , s [ <int> , <int> ] , s [ <int> , <int> ] ] <str> parts . join ( <str> ) <str> end def self . rand_4byte_utf8 [ rand ( <hex> .. <hex> ) ] . pack ( <str> ) end def self . pattern_create ( length , sets = nil ) buf = <str> offsets = [ ] sets || = [ UpperAlpha , LowerAlpha , Numerals ] return <str> if length . to_i < <int> return sets [ <int> ] [ <int> ] . chr * length if sets . size == <int> and sets [ <int> ] . size == <int> sets . length . times { offsets << <int> } until buf . length > = length begin buf << converge_sets ( sets , <int> , offsets , length ) end end if ( buf . length < length ) buf = buf * ( length / buf . length . to_f ) . ceil end buf [ <int> , length ] end def self . patt2 ( len , sets = nil ) buf = <str> counter = [ ] sets || = [ UpperAlpha , LowerAlpha , Numerals ] len || = len . to_i return <str> if len . zero? sets = sets . map { | a | a . split ( <str> ) } sets . size . times { counter << <int> } <int> . upto ( len - <int> ) do | i | setnum = i % sets . size end return buf end def self . pattern_offset ( pattern , value , start = <int> ) if ( value . kind_of? ( String ) ) pattern . index ( value , start ) elsif ( value . kind_of? ( Fixnum ) or value . kind_of? ( Bignum ) ) pattern . index ( [ value ] . pack ( <str> ) , start ) else raise :: ArgumentError , <str> value . class <str> end end def self . compress ( str ) str . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) end def self . randomize_space ( str ) set = [ <str> , <str> , <str> , <str> ] str . gsub ( <str> ) { | s | len = rand ( <int> ) + <int> buf = <str> while ( buf . length < len ) buf << set . sample end buf } end def self . zlib_present? begin temp = Zlib return true rescue return false end end def self . gzip_present? self . zlib_present? end def self . zlib_deflate ( str , level = Zlib :: BEST_COMPRESSION ) if self . zlib_present? z = Zlib :: Deflate . new ( level ) dst = z . deflate ( str , Zlib :: FINISH ) z . close return dst else raise RuntimeError , <str> end end def self . zlib_inflate ( str ) if ( self . zlib_present? ) zstream = Zlib :: Inflate . new buf = zstream . inflate ( str ) zstream . finish zstream . close return buf else raise RuntimeError , <str> end end def self . gzip ( str , level = <int> ) raise RuntimeError , <str> if ( ! zlib_present? ) raise RuntimeError , <str> if ( level < <int> or level > <int> ) s = <str> s . force_encoding ( <str> ) if s . respond_to? ( <str> ) gz = Zlib :: GzipWriter . new ( StringIO . new ( s , <str> ) , level ) gz << str gz . close return s end def self . ungzip ( str ) raise RuntimeError , <str> if ( ! zlib_present? ) s = <str> s . force_encoding ( <str> ) if s . respond_to? ( <str> ) gz = Zlib :: GzipReader . new ( StringIO . new ( str , <str> ) ) s << gz . read gz . close return s end def self . badchar_index ( data , badchars = <str> ) badchars . unpack ( <str> ) . each { | badchar | pos = data . index ( badchar . chr ) return pos if pos } return nil end def self . remove_badchars ( data , badchars = <str> ) return data if badchars . length == <int> badchars_pat = badchars . unpack ( <str> ) . map { | c | <str> % c } . join data . gsub! ( <str> badchars_pat <str> , <str> ) data end def self . charset_exclude ( keepers ) excluded_bytes = [ * ( <int> .. <int> ) ] - keepers . unpack ( <str> ) excluded_bytes . pack ( <str> ) end def self . shuffle_s ( str ) shuffle_a ( str . unpack ( <str> ) ) . pack ( <str> ) end def self . shuffle_a ( arr ) len = arr . length max = len - <int> cyc = [ * ( <int> .. max ) ] for d in cyc e = rand ( d + <int> ) next if e == d f = arr [ d ] ; g = arr [ e ] ; arr [ d ] = g ; arr [ e ] = f ; end return arr end def self . permute_case ( word , idx = <int> ) res = [ ] if ( ( UpperAlpha + LowerAlpha ) . index ( word [ idx , <int> ] ) ) word_ucase = word . dup word_ucase [ idx , <int> ] = word [ idx , <int> ] . upcase word_lcase = word . dup word_lcase [ idx , <int> ] = word [ idx , <int> ] . downcase if ( idx == word . length ) return [ word ] else res << permute_case ( word_ucase , idx + <int> ) res << permute_case ( word_lcase , idx + <int> ) end else res << permute_case ( word , idx + <int> ) end res . flatten end def self . rand_hostname host = [ ] ( rand ( <int> ) + <int> ) . times { host . push ( Rex :: Text . rand_text_alphanumeric ( rand ( <int> ) + <int> ) ) } host . push ( TLDs . sample ) host . join ( <str> ) . downcase end def self . rand_state ( ) States . sample end def self . rand_surname Surnames . sample end def self . rand_name if rand ( <int> ) % <int> == <int> Names_Male . sample else Names_Female . sample end end def self . rand_name_male Names_Male . sample end def self . rand_name_female Names_Female . sample end def self . rand_mail_address mail_address = <str> mail_address << Rex :: Text . rand_name mail_address << <str> mail_address << Rex :: Text . rand_surname mail_address << <str> mail_address << Rex :: Text . rand_hostname end def self . block_api_hash ( mod , fun ) unicode_mod = ( mod . upcase + <str> ) . unpack ( <str> ) . pack ( <str> ) mod_hash = self . ror13_hash ( unicode_mod ) fun_hash = self . ror13_hash ( fun + <str> ) <str> ( mod_hash + fun_hash & <hex> ) . to_s ( <int> ) <str> end def self . ror13_hash ( name ) hash = <int> name . unpack ( <str> ) . each { | c | hash = ror ( hash , <int> ) ; hash += c } hash end def self . ror ( val , cnt ) bits = [ val ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] . split ( <str> ) <int> . upto ( cnt ) do | c | bits . unshift ( bits . pop ) end [ bits . join ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] end def self . rol ( val , cnt ) bits = [ val ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] . split ( <str> ) <int> . upto ( cnt ) do | c | bits . push ( bits . shift ) end [ bits . join ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] end def self . split_to_a ( str , n ) if n > <int> s = str . dup until s . empty? ( ret || = [ ] ) . push s . slice! ( <int> , n ) end else ret = str end ret end def self . pack_int64le ( val ) [ val & <hex> , val >> <int> ] . pack ( <str> ) end def self . unicode_filter_encode ( str ) if ( str . to_s . unpack ( <str> ) & ( LowAscii + HighAscii + <str> ) . unpack ( <str> ) ) . length > <int> str = <str> + str . unpack ( <str> ) . select { | c | c < <hex> and c > <hex> and c != <hex> } . pack ( <str> ) + <str> + str . unpack ( <str> ) [ <int> ] else str end end def self . unicode_filter_decode ( str ) str . to_s . gsub ( <str> ) { | m | [ $2 ] . pack ( <str> ) } end protected def self . converge_sets ( sets , idx , offsets , length ) buf = sets [ idx ] [ offsets [ idx ] ] . chr if ( sets [ idx + <int> ] ) buf << converge_sets ( sets , idx + <int> , offsets , length ) else while ( idx > = <int> and ( ( offsets [ idx ] = ( offsets [ idx ] + <int> ) % sets [ idx ] . length ) ) == <int> ) idx -= <int> end if ( idx < <int> ) return buf end end buf end def self . load_codepage ( ) return if ( ! @@codepage_map_cache . nil? ) file = File . join ( File . dirname ( __FILE__ ) , <str> ) page = <str> name = <str> map = { } File . open ( file ) . each { | line | next if line =~ <str> next if line =~ <str> data = line . split if data [ <int> ] =~ <str> page = data . shift . to_i name = data . join ( <str> ) . sub ( <str> , <str> ) . sub ( <str> , <str> ) map [ page ] = { } map [ page ] [ <str> ] = name map [ page ] [ <str> ] = { } else data . each { | entry | wide , char = entry . split ( <str> ) char = [ char ] . pack ( <str> ) wide = [ wide ] . pack ( <str> ) if map [ page ] [ <str> ] [ char ] . nil? map [ page ] [ <str> ] [ char ] = [ wide ] else map [ page ] [ <str> ] [ char ] . push ( wide ) end } end } @@codepage_map_cache = map end def self . checksum8 ( str ) ( str . unpack ( <str> ) . inject ( <str> ) || <int> ) % <hex> end 
