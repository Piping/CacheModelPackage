require_relative <str> require <str> module Psych_Tests StructTest = Struct :: new ( <str> ) end class Psych_Unit_Tests < Psych :: TestCase def teardown Psych . domain_types . clear end def test_y_method assert_raises ( NoMethodError ) do OpenStruct . new . y <int> end end def test_syck_compat time = Time . utc ( <int> , <int> , <int> ) yaml = Psych . dump time assert_match <str> , yaml end def test_multiline_regexp assert_cycle ( Regexp . new ( <str> ) ) end def test_regexp_with_n assert_cycle ( Regexp . new ( <str> , <int> , <str> ) ) end def test_basic_map assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_basic_strings assert_cycle ( <str> ) assert_cycle ( <str> ) assert_cycle ( <str> ) assert_parse_only ( { <int> = > <str> , <int> = > <int> , <int> = > <str> , <int> = > <str> , <int> = > <str> , <int> = > <str> , <int> = > <str> , <int> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_simple_implicit_sequence assert_to_yaml ( [ <str> , <str> , <str> ] , << <str> EOY <str> <str> EOY ) end def test_spec_simple_implicit_map assert_to_yaml ( { <str> = > <int> , <str> = > <int> . <int> , <str> = > <int> } , << <str> EOY <str> <str> EOY ) end def test_spec_simple_map_with_nested_sequences assert_to_yaml ( { <str> = > [ <str> , <str> , <str> ] , <str> = > [ <str> , <str> , <str> ] } , << <str> EOY <str> <str> EOY ) end def test_spec_simple_sequence_with_nested_map assert_to_yaml ( [ { <str> = > <str> , <str> = > <int> , <str> = > <int> . <int> } , { <str> = > <str> , <str> = > <int> , <str> = > <int> . <int> } ] , << <str> EOY <str> <str> EOY ) end def test_spec_sequence_of_sequences assert_parse_only ( [ [ <str> , <str> , <str> ] , [ <str> , <int> , <int> . <int> ] , [ <str> , <int> , <int> . <int> ] ] , << <str> EOY <str> <str> EOY ) end def test_spec_mapping_of_mappings assert_parse_only ( { <str> = > { <str> = > <int> , <str> = > <int> . <int> } , <str> = > { <str> = > <int> , <str> = > <int> . <int> } } , << <str> EOY <str> <str> EOY ) end def test_ambiguous_comments assert_to_yaml ( <str> , << <str> EOY <str> ) <str> EOY end def test_spec_nested_comments assert_parse_only ( { <str> = > [ <str> , <str> ] , <str> = > [ <str> , <str> ] } , << <str> EOY <str> <str> EOY ) end def test_spec_anchors_and_aliases assert_parse_only ( { <str> = > [ <str> , <str> ] , <str> = > [ <str> , <str> ] } , << <str> EOY <str> <str> EOY ) assert_to_yaml ( [ { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } ] , << <str> EOY <str> <str> EOY ) assert_to_yaml ( { <str> = > [ <str> , <str> , <str> , <str> ] , <str> = > [ { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } ] } , << <str> EOY <str> <str> EOY ) end def test_spec_mapping_between_sequences assert_parse_only ( { [ <str> , <str> ] = > [ Date . new ( <int> , <int> , <int> ) ] , [ <str> , <str> ] = > [ Date . new ( <int> , <int> , <int> ) , Date . new ( <int> , <int> , <int> ) , Date . new ( <int> , <int> , <int> ) ] } , << <str> EOY <str> <str> EOY ) assert_parse_only ( { [ <str> , <str> ] = > [ Date . new ( <int> , <int> , <int> ) , Date . new ( <int> , <int> , <int> ) , Date . new ( <int> , <int> , <int> ) ] , [ <str> , <str> ] = > [ Date . new ( <int> , <int> , <int> ) ] } , << <str> EOY <str> <str> EOY ) end def test_spec_sequence_key_shortcut assert_parse_only ( { <str> = > <int> , <str> = > Date . new ( <int> , <int> , <int> ) , <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > <int> } , { <str> = > <str> , <str> = > <int> } , { <str> = > <str> , <str> = > <int> } ] } , << <str> EOY <str> <str> EOY ) end def test_spec_sequence_in_sequence_shortcut assert_parse_only ( [ [ [ <str> , <str> , <str> ] ] ] , << <str> EOY <str> ) <str> EOY end def test_spec_sequence_shortcuts assert_parse_only ( [ [ [ [ <str> ] ] , [ <str> , <str> ] , { <str> = > nil } , [ { <str> = > [ <str> ] } ] , [ <str> ] ] , [ <str> , <str> ] ] , << <str> EOY <str> ) <str> EOY end def test_spec_single_literal assert_parse_only ( [ <str> ] , << <str> EOY <str> ) <str> EOY end def test_spec_single_folded assert_parse_only ( [ <str> ] , << <str> EOY <str> <str> EOY ) end def test_spec_preserve_indent assert_parse_only ( <str> , << <str> EOY <str> <str> EOY ) end def test_spec_indentation_determines_scope assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_multiline_scalars assert_parse_only ( { <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_type_int assert_parse_only ( { <str> = > <int> , <str> = > <int> , <str> = > <str> . oct , <str> = > <str> . hex } , << <str> EOY <str> <str> EOY ) assert_parse_only ( { <str> = > <int> , <str> = > <int> , <str> = > <oct> , <str> = > <hex> , <str> = > <int> } , << <str> EOY <str> ) <str> EOY end def test_spec_type_float assert_parse_only ( { <str> = > <int> . <int> , <str> = > <int> . <int> , <str> = > <int> . <int> , <str> = > - <int> . <int> / <int> . <int> } , << <str> EOY <str> ) <str> EOY nan = Psych :: load ( << <str> EOY <str> ) <str> EOY assert ( nan [ <str> ] . nan? ) end def test_spec_type_misc assert_parse_only ( { nil = > nil , true = > true , false = > false , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_complex_invoice id001 = { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <int> } } assert_parse_only ( { <str> = > <int> , <str> = > Date . new ( <int> , <int> , <int> ) , <str> = > id001 , <str> = > id001 , <str> = > [ { <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > <int> . <oct> } , { <str> = > <str> , <str> = > <int> , <str> = > <str> , <str> = > <int> . <oct> } ] , <str> = > <int> . <int> , <str> = > <int> . <int> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_log_file doc_ct = <int> Psych :: load_documents ( << <str> EOY <str> <str> EOY ) { | doc | case doc_ct when <int> assert_equal ( doc , { <str> = > mktime ( <int> , <int> , <int> , <int> , <oct> , <int> , <oct> , <str> ) , <str> = > <str> , <str> = > <str> } ) when <int> assert_equal ( doc , { <str> = > mktime ( <int> , <int> , <int> , <int> , <oct> , <int> , <oct> , <str> ) , <str> = > <str> , <str> = > <str> } ) when <int> assert_equal ( doc , { <str> = > mktime ( <int> , <int> , <int> , <int> , <oct> , <int> , <oct> , <str> ) , <str> = > <str> , <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > <int> , <str> = > <str> } , { <str> = > <str> , <str> = > <int> , <str> = > <str> } ] } ) end doc_ct += <int> } assert_equal ( doc_ct , <int> ) end def test_spec_root_fold y = Psych :: load ( << <str> EOY <str> <str> EOY ) assert_equal ( y , <str> ) end def test_spec_root_mapping y = Psych :: load ( << <str> EOY <str> <str> EOY ) assert_equal ( y , { <str> = > <int> , <str> = > Date . new ( <int> , <int> , <int> ) , <str> = > <int> . <int> } ) end def test_spec_oneline_docs doc_ct = <int> Psych :: load_documents ( << <str> EOY <str> <str> EOY ) { | doc | case doc_ct when <int> assert_equal ( doc , { } ) when <int> assert_equal ( doc , [ ] ) when <int> assert_equal ( doc , <str> ) end doc_ct += <int> } assert_equal ( doc_ct , <int> ) end def test_spec_domain_prefix customer_proc = proc { | type , val | if Hash === val _ , _ , type = type . split ( <str> , <int> ) val [ <str> ] = <str> type <str> val else raise ArgumentError , <str> + val . inspect end } Psych . add_domain_type ( <str> , <str> , & customer_proc ) Psych . add_domain_type ( <str> , <str> , & customer_proc ) assert_parse_only ( { <str> = > { <str> = > [ { <str> = > <str> , <str> = > <str> , <str> = > <str> } ] , <str> = > <str> } } , << <str> EOY <str> <str> EOY ) end def test_spec_throwaway assert_parse_only ( { <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_force_implicit assert_parse_only ( { <str> = > <int> , <str> = > <int> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_override_anchor a001 = <str> assert_parse_only ( { <str> = > <str> , <str> = > a001 , <str> = > a001 } , << <str> EOY <str> <str> EOY ) end def test_spec_explicit_families Psych . add_domain_type ( <str> , <str> ) { | type , val | <str> val <str> } assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_application_family Psych . add_domain_type ( <str> , <str> ) { | type , val | if Array === val val << <str> val else raise ArgumentError , <str> val . class <str> + val . inspect end } one_shape_proc = Proc . new { | type , val | if Hash === val type = type . split ( <str> ) val [ <str> ] = <str> type [ <int> ] <str> val else raise ArgumentError , <str> val . class <str> + val . inspect end } Psych . add_domain_type ( <str> , <str> , & one_shape_proc ) Psych . add_domain_type ( <str> , <str> , & one_shape_proc ) Psych . add_domain_type ( <str> , <str> , & one_shape_proc ) assert_parse_only ( [ [ { <str> = > <int> , <str> = > { <str> = > <int> , <str> = > <int> } , <str> = > <str> } , { <str> = > { <str> = > <int> , <str> = > <int> } , <str> = > <str> , <str> = > { <str> = > <int> , <str> = > <int> } } , { <str> = > <str> , <str> = > <str> , <str> = > { <str> = > <int> , <str> = > <int> } , <str> = > <int> } , <str> ] ] , << <str> EOY <str> <str> EOY ) end def test_spec_float_explicit assert_parse_only ( [ <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> ] , << <str> EOY <str> <str> EOY ) end def test_spec_builtin_seq assert_parse_only ( { <str> = > [ ] , <str> = > [ <str> , <str> , <str> , <str> , <str> ] , <str> = > [ <str> , [ <str> ] , <str> , <str> ] } , << <str> EOY <str> <str> EOY ) end def test_spec_builtin_map assert_parse_only ( { <str> = > { } , <str> = > { <str> = > <int> , <str> = > <int> } , <str> = > { <str> = > <int> , <str> = > <int> } , <str> = > { <str> = > <str> , <str> = > { <str> = > <str> } , <str> = > [ <str> , { } , <str> , { <str> = > <str> , <str> = > <str> } , <str> , { <str> = > <str> , <str> = > <str> } ] , <int> . <int> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , [ <str> , <str> ] = > [ <str> ] } } , << <str> EOY <str> <str> EOY ) end def test_spec_builtin_literal_blocks assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) str1 = <str> str2 = <str> str3 = <str> assert_parse_only ( { <str> = > str1 , <str> = > str1 , <str> = > str2 , <str> = > str2 , <str> = > str3 , <str> = > str3 } , << <str> EOY <str> <str> EOY ) end def test_spec_span_single_quote assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_span_double_quote assert_parse_only ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_spec_builtin_time assert_parse_only ( { <str> = > mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <str> , <str> ) , <str> = > mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <str> ) , <str> = > Date . new ( <int> , <int> , <int> ) , <str> = > mktime ( <int> , <int> , <int> , <int> , <int> , <int> , <str> , <str> ) } , << <str> EOY <str> <str> EOY ) end def test_spec_builtin_binary arrow_gif = <str> assert_parse_only ( { <str> = > arrow_gif , <str> = > arrow_gif , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_ruby_regexp assert_to_yaml ( { <str> = > <str> , <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) end def test_ranges assert_to_yaml ( <int> .. <int> , << <str> EOY <str> ) <str> EOY assert_to_yaml ( <str> .. <str> , << <str> EOY <str> ) <str> EOY assert_to_yaml ( <int> . <int> ... <int> . <int> , << <str> EOY <str> ) <str> EOY end def test_ruby_struct book_struct = Struct :: new ( <str> , <str> , <str> , <str> , <str> ) assert_to_yaml ( [ book_struct . new ( <str> , <str> , <int> , <str> ) , book_struct . new ( [ <str> , <str> ] , <str> , <int> , book_struct . new ( <str> , <str> , <int> , <str> ) ) ] , << <str> EOY <str> <str> EOY ) assert_to_yaml ( Psych_Tests :: StructTest . new ( <int> ) , << <str> EOY <str> ) <str> EOY end def test_ruby_rational assert_to_yaml ( Rational ( <int> , <int> ) , << <str> EOY <str> ) <str> EOY assert_to_yaml ( Rational ( <int> , <int> ) , <str> ) assert_raises ( ArgumentError ) { Psych . load ( <str> ) } end def test_ruby_complex assert_to_yaml ( Complex ( <int> , <int> ) , << <str> EOY <str> ) <str> EOY assert_to_yaml ( Complex ( <int> , <int> ) , <str> ) assert_raises ( ArgumentError ) { Psych . load ( <str> ) } end def test_emitting_indicators assert_to_yaml ( <str> , << <str> EOY <str> <str> EOY ) end def test_akira assert_to_yaml ( { <str> = > <str> , <str> = > <str> } , << <str> EOY <str> <str> EOY ) assert_to_yaml ( { <str> = > <int> , <str> = > <int> } , << <str> EOY <str> <str> EOY ) assert_to_yaml ( [ { <str> = > <str> } ] * <int> , << <str> EOY <str> <str> EOY ) end def test_time_now_cycle t = Time . now t = Time . at ( t . tv_sec , t . tv_usec ) <int> . times do assert_cycle ( t ) end end def test_range_cycle assert_cycle ( <str> .. <str> ) assert_cycle ( <int> .. <int> ) assert_cycle ( <int> . <int> e20 .. <int> . <int> e20 ) assert_cycle ( <str> .. <str> ) assert_cycle ( <str> ... <str> ) assert_cycle ( <str> .. <str> ) assert_cycle ( <str> ... <str> ) assert_cycle ( <str> ... <str> ) assert_cycle ( <str> ... <str> ) end def test_circular_references a = [ ] ; a [ <int> ] = a ; a [ <int> ] = a inspect_str = <str> assert_equal ( inspect_str , Psych :: load ( Psych . dump ( a ) ) . inspect ) end def test_symbol_cycle assert_cycle ( <str> ) end class NumericTest < Numeric def initialize ( value ) @value = value end def == ( other ) @value == other . instance_eval { @value } end end def test_numeric_cycle assert_cycle ( <int> ) assert_cycle ( <int> ) assert_cycle ( NumericTest . new ( <int> ) ) end def test_empty_map_key assert_cycle ( { [ ] = > <str> } ) assert_cycle ( { { } = > <str> } ) end def test_object_id_collision omap = Psych :: Omap . new <int> . times { | i | omap [ <str> i <str> ] = { <str> = > i } } raise <str> if Psych . dump ( omap ) =~ <str> end def test_date_out_of_range Psych :: load ( <str> ) end def test_normal_exit Psych . load ( <str> * <int> <str> ) end def test_multiline_string_uses_literal_style yaml = Psych . dump ( <str> ) assert_match ( <str> , yaml ) end def test_string_starting_with_non_word_character_uses_double_quotes_without_exclamation_mark yaml = Psych . dump ( <str> ) refute_match ( <str> , yaml ) end def test_string_dump_with_colon yaml = Psych . dump <str> refute_match <str> , yaml end def test_string_dump_starting_with_star yaml = Psych . dump <str> refute_match <str> , yaml end end 
