require <str> require <str> class RawSocket @@id_arr = [ ] def initialize ( src_addr , dest_addr ) begin @socket = Socket . new PF_INET , SOCK_RAW , IPPROTO_RAW rescue SystemCallError = > e raise SystemCallError , <str> e <str> end @socket . setsockopt IPPROTO_IP , IP_HDRINCL , <int> @src_addr = check_addr src_addr @dest_addr = check_addr dest_addr @src_port = <int> @dest_port = <int> @version = @dest_addr . ipv4? ? <str> : <str> @tot_lenght = <int> @protocol = <int> @id = <int> @to = Socket . pack_sockaddr_in @dest_port , @dest_addr . to_s end def send ( payload = <str> ) packet = make_ip_header ( [ [ @version + <str> , <str> ] , [ <int> , <str> ] , [ @tot_lenght + payload . size , <str> ] , [ @id , <str> ] , [ <int> , <str> ] , [ <int> , <str> ] , [ @protocol , <str> ] , [ <int> , <str> ] , [ @src_addr . to_i , <str> ] , [ @dest_addr . to_i , <str> ] , ] ) packet << make_transport_header ( payload . size ) packet << [ payload ] . pack ( <str> ) @socket . send ( packet , <int> , @to ) end private def check_addr addr case addr when String IPAddr . new addr when IPAddr addr else raise ArgumentError , <str> addr <str> end end def check_port port if ( <int> .. <int> ) . include? port and port . kind_of? Integer port else raise ArgumentError , <str> port <str> end end def genID while ( @@id_arr . include? ( q = rand ( <int> ) ) ) end @@id_arr . push ( q ) q end def ipchecksum ( data ) checksum = data . unpack ( <str> ) . inject ( <int> ) { | s , x | s + x } ( ( checksum >> <int> ) + ( checksum & <hex> ) ) ^ <hex> end def make_ip_header ( parts ) template = <str> data = [ ] parts . each do | part | data += part [ <int> .. - <int> ] template << part [ - <int> ] end data_str = data . pack ( template ) checksum = ipchecksum ( data_str ) data [ - <int> ] = checksum data . pack ( template ) end def make_transport_header <str> end end class UdpRawSocket < RawSocket def initialize ( src_addr , src_port , dest_addr , dest_port ) super ( src_addr , dest_addr ) @src_port = check_port src_port @dest_port = check_port dest_port @tot_lenght = <int> + <int> @protocol = <int> @to = Socket . pack_sockaddr_in @dest_port , @dest_addr . to_s end private def make_udp_header ( parts ) template = <str> data = [ ] parts . each do | part | data += part [ <int> .. - <int> ] template << part [ - <int> ] end data . pack ( template ) end def make_transport_header ( pay_size ) make_udp_header ( [ [ @src_port , <str> ] , [ @dest_port , <str> ] , [ <int> + pay_size , <str> ] , [ <int> , <str> ] ] ) end end 
