module ActiveRecord module Validations class UniquenessValidator < ActiveModel :: EachValidator def initialize ( options ) if options [ <str> ] && ! options [ <str> ] . respond_to? ( <str> ) raise ArgumentError , <str> options [ <str> ] <str> \ <str> end super ( { <str> : true } . merge! ( options ) ) @klass = options [ <str> ] end def validate_each ( record , attribute , value ) finder_class = find_finder_class_for ( record ) table = finder_class . arel_table value = map_enum_attribute ( finder_class , attribute , value ) relation = build_relation ( finder_class , table , attribute , value ) if record . persisted? if finder_class . primary_key relation = relation . where . not ( finder_class . primary_key = > record . id_was ) else raise UnknownPrimaryKey . new ( finder_class , <str> ) end end relation = scope_relation ( record , table , relation ) relation = relation . merge ( options [ <str> ] ) if options [ <str> ] if relation . exists? error_options = options . except ( <str> , <str> , <str> ) error_options [ <str> ] = value record . errors . add ( attribute , <str> , error_options ) end end protected def find_finder_class_for ( record ) class_hierarchy = [ record . class ] while class_hierarchy . first != @klass class_hierarchy . unshift ( class_hierarchy . first . superclass ) end class_hierarchy . detect { | klass | ! klass . abstract_class? } end def build_relation ( klass , table , attribute , value ) if reflection = klass . _reflect_on_association ( attribute ) attribute = reflection . foreign_key value = value . attributes [ reflection . klass . primary_key ] unless value . nil? end if klass . attribute_alias? ( attribute ) attribute = klass . attribute_alias ( attribute ) end attribute_name = attribute . to_s column = klass . columns_hash [ attribute_name ] cast_type = klass . type_for_attribute ( attribute_name ) value = cast_type . serialize ( value ) value = klass . connection . type_cast ( value ) if value . is_a? ( String ) && column . limit value = value . to_s [ <int> , column . limit ] end comparison = if ! options [ <str> ] && ! value . nil? klass . connection . case_insensitive_comparison ( table , attribute , column , value ) else klass . connection . case_sensitive_comparison ( table , attribute , column , value ) end if value . nil? klass . unscoped . where ( comparison ) else bind = Relation :: QueryAttribute . new ( attribute_name , value , Type :: Value . new ) klass . unscoped . where ( comparison , bind ) end rescue RangeError klass . none end def scope_relation ( record , table , relation ) Array ( options [ <str> ] ) . each do | scope_item | if reflection = record . class . _reflect_on_association ( scope_item ) scope_value = record . send ( reflection . foreign_key ) scope_item = reflection . foreign_key else scope_value = record . _read_attribute ( scope_item ) end relation = relation . where ( scope_item = > scope_value ) end relation end def map_enum_attribute ( klass , attribute , value ) mapping = klass . defined_enums [ attribute . to_s ] value = mapping [ value ] if value && mapping value end end module ClassMethods def validates_uniqueness_of ( * attr_names ) validates_with UniquenessValidator , _merge_attributes ( attr_names ) end end end end 
