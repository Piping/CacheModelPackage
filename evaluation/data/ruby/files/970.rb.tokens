require <str> require <str> module ActiveRecord module Delegation module DelegateCache def relation_delegate_class ( klass ) @relation_delegate_cache [ klass ] end def initialize_relation_delegate_cache @relation_delegate_cache = cache = { } [ ActiveRecord :: Relation , ActiveRecord :: Associations :: CollectionProxy , ActiveRecord :: AssociationRelation ] . each do | klass | delegate = Class . new ( klass ) { include ClassSpecificRelation } const_set klass . name . gsub ( <str> . freeze , <str> . freeze ) , delegate cache [ klass ] = delegate end end def inherited ( child_class ) child_class . initialize_relation_delegate_cache super end end extend ActiveSupport :: Concern delegate <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> : <str> delegate <str> , <str> , <str> , <str> , <str> , <str> , <str> = > <str> module ClassSpecificRelation extend ActiveSupport :: Concern included do @delegation_mutex = Mutex . new end module ClassMethods def name superclass . name end def delegate_to_scoped_klass ( method ) @delegation_mutex . synchronize do return if method_defined? ( method ) if method . to_s =~ <str> module_eval <<- <str> RUBY <str> , __FILE__ , __LINE__ + <int> <str> RUBY else define_method method do | * args , & block | scoping { @klass . public_send ( method , * args , & block ) } end end end end def delegate ( method , opts = { } ) @delegation_mutex . synchronize do return if method_defined? ( method ) super end end end protected def method_missing ( method , * args , & block ) if @klass . respond_to? ( method ) self . class . delegate_to_scoped_klass ( method ) scoping { @klass . public_send ( method , * args , & block ) } elsif arel . respond_to? ( method ) self . class . delegate method , <str> = > <str> arel . public_send ( method , * args , & block ) else super end end end module ClassMethods def create ( klass , * args ) relation_class_for ( klass ) . new ( klass , * args ) end private def relation_class_for ( klass ) klass . relation_delegate_class ( self ) end end def respond_to? ( method , include_private = false ) super || @klass . respond_to? ( method , include_private ) || arel . respond_to? ( method , include_private ) end protected def method_missing ( method , * args , & block ) if @klass . respond_to? ( method ) scoping { @klass . public_send ( method , * args , & block ) } elsif arel . respond_to? ( method ) arel . public_send ( method , * args , & block ) else super end end end end 
