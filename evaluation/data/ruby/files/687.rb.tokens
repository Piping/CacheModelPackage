class Gem :: BasicSpecification attr_writer <str> attr_writer <str> attr_writer <str> attr_accessor <str> attr_writer <str> def initialize internal_init end def self . default_specifications_dir File . join ( Gem . default_dir , <str> , <str> ) end def gem_build_complete_path File . join extension_dir , <str> end def activated? raise NotImplementedError end def base_dir raise NotImplementedError end def contains_requirable_file? file if @ignored then return false elsif missing_extensions? then @ignored = true warn <str> full_name <str> + <str> name <str> version <str> return false end have_file? file , Gem . suffixes end def default_gem? loaded_from && File . dirname ( loaded_from ) == self . class . default_specifications_dir end def extension_dir @extension_dir || = File . expand_path ( File . join ( extensions_dir , full_name ) ) . untaint end def extensions_dir @extensions_dir || = Gem . default_ext_dir_for ( base_dir ) || File . join ( base_dir , <str> , Gem :: Platform . local . to_s , Gem . extension_api_version ) end def find_full_gem_path path = File . expand_path File . join ( gems_dir , full_name ) path . untaint path end private <str> def full_gem_path @full_gem_path || = find_full_gem_path end def full_name if platform == Gem :: Platform :: RUBY or platform . nil? then <str> name <str> version <str> . untaint else <str> name <str> version <str> platform <str> . untaint end end def full_require_paths @full_require_paths || = begin full_paths = raw_require_paths . map do | path | File . join full_gem_path , path . untaint end full_paths << extension_dir if have_extensions? full_paths end end def datadir File . expand_path ( File . join ( gems_dir , full_name , <str> , name ) ) . untaint end def to_fullpath path if activated? then @paths_map || = { } @paths_map [ path ] || = begin fullpath = nil suffixes = Gem . suffixes suffixes . find do | suf | full_require_paths . find do | dir | File . file? ( fullpath = <str> dir <str> path <str> suf <str> ) end end ? fullpath : nil end else nil end end def gem_dir @gem_dir || = File . expand_path File . join ( gems_dir , full_name ) end def gems_dir raise NotImplementedError end def internal_init @extension_dir = nil @extensions_dir = nil @full_gem_path = nil @gem_dir = nil @ignored = nil end def name raise NotImplementedError end def platform raise NotImplementedError end def raw_require_paths raise NotImplementedError end def require_paths return raw_require_paths unless have_extensions? [ extension_dir ] . concat raw_require_paths end def source_paths paths = raw_require_paths . dup if have_extensions? then ext_dirs = extensions . map do | extension | extension . split ( File :: SEPARATOR , <int> ) . first end . uniq paths . concat ext_dirs end paths . uniq end def matches_for_glob glob glob = File . join ( self . lib_dirs_glob , glob ) Dir [ glob ] . map { | f | f . untaint } end def lib_dirs_glob dirs = if self . require_paths . size > <int> then <str> self . require_paths . join ( <str> ) <str> else self . require_paths . first end <str> self . full_gem_path <str> dirs <str> . untaint end def to_spec raise NotImplementedError end def version raise NotImplementedError end def stubbed? raise NotImplementedError end private def have_extensions? ; ! extensions . empty? ; end def have_file? file , suffixes return true if raw_require_paths . any? do | path | base = File . join ( gems_dir , full_name , path . untaint , file ) . untaint suffixes . any? { | suf | File . file? base + suf } end if have_extensions? base = File . join extension_dir , file suffixes . any? { | suf | File . file? base + suf } else false end end end 
