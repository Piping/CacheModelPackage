require <str> require <str> module ActionController module Instrumentation extend ActiveSupport :: Concern include AbstractController :: Logger attr_internal <str> def process_action ( * args ) raw_payload = { <str> = > self . class . name , <str> = > self . action_name , <str> = > request . filtered_parameters , <str> = > request . format . ref , <str> = > request . request_method , <str> = > request . fullpath } ActiveSupport :: Notifications . instrument ( <str> , raw_payload . dup ) ActiveSupport :: Notifications . instrument ( <str> , raw_payload ) do | payload | begin result = super payload [ <str> ] = response . status result ensure append_info_to_payload ( payload ) end end end def render ( * args ) render_output = nil self . view_runtime = cleanup_view_runtime do Benchmark . ms { render_output = super } end render_output end def send_file ( path , options = { } ) ActiveSupport :: Notifications . instrument ( <str> , options . merge ( <str> = > path ) ) do super end end def send_data ( data , options = { } ) ActiveSupport :: Notifications . instrument ( <str> , options ) do super end end def redirect_to ( * args ) ActiveSupport :: Notifications . instrument ( <str> ) do | payload | result = super payload [ <str> ] = response . status payload [ <str> ] = response . filtered_location result end end private def halted_callback_hook ( filter ) ActiveSupport :: Notifications . instrument ( <str> , <str> = > filter ) end def cleanup_view_runtime yield end def append_info_to_payload ( payload ) payload [ <str> ] = view_runtime end module ClassMethods def log_process_action ( payload ) messages , view_runtime = [ ] , payload [ <str> ] messages << ( <str> % view_runtime . to_f ) if view_runtime messages end end end end 
