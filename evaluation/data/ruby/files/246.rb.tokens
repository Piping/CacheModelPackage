require <str> require <str> class Gem :: ConfigFile include Gem :: UserInteraction DEFAULT_BACKTRACE = false DEFAULT_BULK_THRESHOLD = <int> DEFAULT_VERBOSITY = true DEFAULT_UPDATE_SOURCES = true OPERATING_SYSTEM_DEFAULTS = { } PLATFORM_DEFAULTS = { } SYSTEM_CONFIG_PATH = begin require <str> Etc . sysconfdir rescue LoadError , NoMethodError begin require <str> CSIDL_COMMON_APPDATA = <hex> path = <int> . chr * <int> if RUBY_VERSION > <str> then SHGetFolderPath = Win32API . new <str> , <str> , <str> , <str> , <str> SHGetFolderPath . call nil , CSIDL_COMMON_APPDATA , nil , <int> , path else SHGetFolderPath = Win32API . new <str> , <str> , <str> , <str> SHGetFolderPath . call <int> , CSIDL_COMMON_APPDATA , <int> , <int> , path end path . strip rescue LoadError RbConfig :: CONFIG [ <str> ] || <str> end end SYSTEM_WIDE_CONFIG_FILE = File . join SYSTEM_CONFIG_PATH , <str> attr_reader <str> attr_accessor <str> attr_accessor <str> attr_writer <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_reader <str> attr_accessor <str> attr_reader <str> def initialize ( args ) @config_file_name = nil need_config_file_name = false arg_list = [ ] args . each do | arg | if need_config_file_name then @config_file_name = arg need_config_file_name = false elsif arg =~ <str> then @config_file_name = $1 elsif arg =~ <str> then need_config_file_name = true else arg_list << arg end end @backtrace = DEFAULT_BACKTRACE @bulk_threshold = DEFAULT_BULK_THRESHOLD @verbose = DEFAULT_VERBOSITY @update_sources = DEFAULT_UPDATE_SOURCES operating_system_config = Marshal . load Marshal . dump ( OPERATING_SYSTEM_DEFAULTS ) platform_config = Marshal . load Marshal . dump ( PLATFORM_DEFAULTS ) system_config = load_file SYSTEM_WIDE_CONFIG_FILE user_config = load_file config_file_name . dup . untaint environment_config = ( ENV [ <str> ] || <str> ) . split ( <str> ) . inject ( { } ) do | result , file | result . merge load_file file end @hash = operating_system_config . merge platform_config unless arg_list . index <str> @hash = @hash . merge system_config @hash = @hash . merge user_config @hash = @hash . merge environment_config end @backtrace = @hash [ <str> ] if @hash . key? <str> @bulk_threshold = @hash [ <str> ] if @hash . key? <str> @home = @hash [ <str> ] if @hash . key? <str> @path = @hash [ <str> ] if @hash . key? <str> @update_sources = @hash [ <str> ] if @hash . key? <str> @verbose = @hash [ <str> ] if @hash . key? <str> @disable_default_gem_server = @hash [ <str> ] if @hash . key? <str> @ssl_verify_mode = @hash [ <str> ] if @hash . key? <str> @ssl_ca_cert = @hash [ <str> ] if @hash . key? <str> @ssl_client_cert = @hash [ <str> ] if @hash . key? <str> @api_keys = nil @rubygems_api_key = nil Gem . sources = @hash [ <str> ] if @hash . key? <str> handle_arguments arg_list end def api_keys load_api_keys unless @api_keys @api_keys end def check_credentials_permissions return if Gem . win_platform? return unless File . exist? credentials_path existing_permissions = File . stat ( credentials_path ) . mode & <oct> return if existing_permissions == <oct> alert_error <<- <str> ERROR <str> <str> ERROR terminate_interaction <int> end def credentials_path File . join Gem . user_home , <str> , <str> end def load_api_keys check_credentials_permissions @api_keys = if File . exist? credentials_path then load_file ( credentials_path ) else @hash end if @api_keys . key? <str> then @rubygems_api_key = @api_keys [ <str> ] @api_keys [ <str> ] = @api_keys . delete <str> unless @api_keys . key? <str> end end def rubygems_api_key load_api_keys unless @rubygems_api_key @rubygems_api_key end def rubygems_api_key = api_key check_credentials_permissions config = load_file ( credentials_path ) . merge ( <str> = > api_key ) dirname = File . dirname credentials_path Dir . mkdir ( dirname ) unless File . exist? dirname Gem . load_yaml permissions = <oct> & ( ~ File . umask ) File . open ( credentials_path , <str> , permissions ) do | f | f . write config . to_yaml end @rubygems_api_key = api_key end def load_file ( filename ) Gem . load_yaml yaml_errors = [ ArgumentError ] yaml_errors << Psych :: SyntaxError if defined? ( Psych :: SyntaxError ) return { } unless filename and File . exist? filename begin content = YAML . load ( File . read ( filename ) ) unless content . kind_of? Hash warn <str> filename <str> return { } end return content rescue * yaml_errors = > e warn <str> filename <str> e <str> rescue Errno :: EACCES warn <str> filename <str> end { } end def backtrace @backtrace or $DEBUG end def config_file_name @config_file_name || Gem . config_file end def each ( & block ) hash = @hash . dup hash . delete <str> hash . delete <str> hash . delete <str> hash . delete <str> yield <str> , @update_sources yield <str> , @verbose yield <str> , @backtrace yield <str> , @bulk_threshold yield <str> , @config_file_name if @config_file_name hash . each ( & block ) end def handle_arguments ( arg_list ) @args = [ ] arg_list . each do | arg | case arg when <str> then @backtrace = true when <str> then $DEBUG = true warn <str> else @args << arg end end end def really_verbose case verbose when true , false , nil then false else true end end def to_yaml yaml_hash = { } yaml_hash [ <str> ] = if @hash . key? ( <str> ) @hash [ <str> ] else DEFAULT_BACKTRACE end yaml_hash [ <str> ] = if @hash . key? ( <str> ) @hash [ <str> ] else DEFAULT_BULK_THRESHOLD end yaml_hash [ <str> ] = Gem . sources . to_a yaml_hash [ <str> ] = if @hash . key? ( <str> ) @hash [ <str> ] else DEFAULT_UPDATE_SOURCES end yaml_hash [ <str> ] = if @hash . key? ( <str> ) @hash [ <str> ] else DEFAULT_VERBOSITY end yaml_hash [ <str> ] = @hash [ <str> ] if @hash . key? <str> yaml_hash [ <str> ] = @hash [ <str> ] if @hash . key? <str> yaml_hash [ <str> ] = @hash [ <str> ] if @hash . key? <str> keys = yaml_hash . keys . map { | key | key . to_s } keys << <str> re = Regexp . union ( * keys ) @hash . each do | key , value | key = key . to_s next if key =~ re yaml_hash [ key . to_s ] = value end yaml_hash . to_yaml end def write open config_file_name , <str> do | io | io . write to_yaml end end def [] ( key ) @hash [ key . to_s ] end def []= ( key , value ) @hash [ key . to_s ] = value end def == ( other ) self . class === other and @backtrace == other . backtrace and @bulk_threshold == other . bulk_threshold and @verbose == other . verbose and @update_sources == other . update_sources and @hash == other . hash end attr_reader <str> protected <str> end 
