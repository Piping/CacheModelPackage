require <str> module Fog module Vcloud class Compute class Server < Fog :: Vcloud :: Model include Fog :: Vcloud :: Compute :: Helpers :: Status identity <str> , <str> = > <str> attribute <str> , <str> = > <str> , <str> = > <str> ignore_attributes <str> , <str> , <str> , <str> attribute <str> attribute <str> attribute <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> , <str> = > <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> attribute <str> , <str> = > <str> , <str> = > <str> has_up <str> def tags Fog :: Vcloud :: Compute :: Tags . new ( <str> = > service , <str> = > href + <str> ) end def customization_script load_unless_loaded! self . guest_customization [ <str> ] end def customization_script = ( custom_script ) @changed = true @update_custom_script = custom_script end def computer_name load_unless_loaded! self . guest_customization [ <str> ] end def os_desc load_unless_loaded! self . operating_system [ <str> ] end def os_type load_unless_loaded! self . operating_system [ <str> ] end def ip_addresses load_unless_loaded! [ self . network_connections ] . flatten . map { | n | n [ <str> ] } end def ready? reload_status running_tasks = self . tasks && self . tasks . flatten . any? { | ti | ti . kind_of? ( Hash ) && ti [ <str> ] == <str> } status != <str> && ! running_tasks end def power_on power_operation ( <str> = > <str> ) end def power_off power_operation ( <str> = > <str> ) end def shutdown power_operation ( <str> = > <str> ) end def power_reset power_operation ( <str> = > <str> ) end def undeploy service . undeploy href end def graceful_restart requires <str> shutdown wait_for { off? } power_on end def name = ( new_name ) attributes [ <str> ] = new_name @changed = true end def password guest_customization [ <str> ] end def password = ( password ) return if password . nil? or password . size == <int> @changed = true @update_password = password end def cpus if cpu_mess { <str> = > cpu_mess [ <str> ] . to_i , <str> = > cpu_mess [ <str> ] } end end def cpus = ( qty ) return if qty . nil? or qty . size == <int> @changed = true @update_cpu_value = qty qty end def memory if memory_mess { <str> = > memory_mess [ <str> ] . to_i , <str> = > memory_mess [ <str> ] } end end def memory = ( amount ) return if amount . nil? or amount . size == <int> @changed = true @update_memory_value = amount amount end def network network_connections [ <str> ] if network_connections end def network = ( network_info ) @changed = true @update_network = network_info network_info end def disks disk_mess . map do | dm | { <str> = > dm [ <str> ] . to_i , <str> = > dm [ <str> ] [ <str> ] . to_i , <str> = > dm [ <str> ] , <str> = > dm } end end def add_disk ( size ) if @disk_change == <str> raise RuntimeError , <str> else load_unless_loaded! @disk_change = <str> @add_disk = { <str> = > { <str> = > size } , <str> = > ( disk_mess . map { | dm | dm [ <str> ] } . sort . last . to_i + <int> ) . to_s , <str> = > <str> } end true end def delete_disk ( number ) if @disk_change == <str> raise RuntimeError , <str> else load_unless_loaded! unless number == <int> @disk_change = <str> @remove_disk = number end end true end def description = ( description ) @description_changed = true unless attributes [ <str> ] == description || attributes [ <str> ] == nil attributes [ <str> ] = description end def name = ( name ) @name_changed = true unless attributes [ <str> ] == name || attributes [ <str> ] == nil attributes [ <str> ] = name end def reload reset_tracking super end def save unless persisted? raise RuntimeError , <str> else if on? if @changed raise RuntimeError , <str> end end if @update_custom_script guest_customization [ <str> ] = @update_custom_script . to_s service . configure_vm_customization_script ( guest_customization ) wait_for { ready? } end if @update_password guest_customization [ <str> ] = @update_password . to_s service . configure_vm_password ( guest_customization ) wait_for { ready? } end if @update_cpu_value cpu_mess [ <str> ] = @update_cpu_value . to_s service . configure_vm_cpus ( cpu_mess ) wait_for { ready? } end if @update_memory_value memory_mess [ <str> ] = @update_memory_value . to_s service . configure_vm_memory ( memory_mess ) wait_for { ready? } end if @update_network network_connections [ <str> ] [ <str> ] = @update_network [ <str> ] network_connections [ <str> ] [ <str> ] = @update_network [ <str> ] service . configure_vm_network ( network_connections ) wait_for { ready? } end if @disk_change == <str> data = disk_mess . delete_if do | vh | vh [ <str> ] == <str> && vh [ <str> ] . to_s == @remove_disk . to_s end service . configure_vm_disks ( self . href , data ) wait_for { ready? } end if @disk_change == <str> data = disk_mess data << @add_disk service . configure_vm_disks ( self . href , data ) wait_for { ready? } end if @name_changed || @description_changed edit_uri = links . select { | i | i [ <str> ] == <str> } edit_uri = edit_uri . kind_of? ( Array ) ? edit_uri . flatten [ <int> ] [ <str> ] : edit_uri [ <str> ] service . configure_vm_name_description ( edit_uri , self . name , self . description ) wait_for { ready? } end end reset_tracking true end def destroy if on? undeploy wait_for { off? } end wait_for { off? } wait_for { ready? } sleep <int> service . delete_vapp ( href ) . body [ <str> ] == <str> end alias_method <str> , <str> private def reset_tracking @disk_change = false @changed = false @update_password = nil @update_cpu_value = nil @update_memory_value = nil @update_network = nil @name_changed = false @description_changed = nil end def _compose_vapp_data { <str> = > name , <str> = > cpus [ <str> ] , <str> = > memory [ <str> ] , <str> = > disks } end def memory_mess load_unless_loaded! if virtual_hardware virtual_hardware . find { | item | item [ <str> ] == <str> } end end def cpu_mess load_unless_loaded! if virtual_hardware virtual_hardware . find { | item | item [ <str> ] == <str> } end end def disk_mess load_unless_loaded! if virtual_hardware virtual_hardware . select { | item | item [ <str> ] == <str> } else [ ] end end def power_operation ( op ) requires <str> begin service . send ( op . keys . first , href + <str> op . values . first <str> ) rescue Excon :: Errors :: InternalServerError = > e raise e unless e . to_s =~ <str> end true end def reload_status server = service . get_server ( href ) self . status = server . status self . tasks = server . tasks end end end end end 
