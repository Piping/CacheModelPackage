require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Auxiliary :: Report include Msf :: Auxiliary :: UDPScanner def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > <str> ) register_options ( [ Opt :: RPORT ( <int> ) ] , self . class ) end def scanner_prescan ( batch ) print_status ( <str> batch [ <int> ] <str> batch [ - <int> ] <str> batch . length <str> ) @res = { } end def scan_host ( ip ) console_session_id = Rex :: Text . rand_text ( <int> ) scanner_send ( Rex :: Proto :: IPMI :: Utils . create_ipmi_session_open_cipher_zero_request ( console_session_id ) , ip , datastore [ <str> ] ) end def scanner_process ( data , shost , sport ) info = Rex :: Proto :: IPMI :: Open_Session_Reply . new ( data ) rescue nil return if not info return if not info . session_payload_type == Rex :: Proto :: IPMI :: PAYLOAD_RMCPPLUSOPEN_REP return if @res [ shost ] @res [ shost ] || = info if info . error_code == <int> print_good ( <str> shost <str> sport <str> ) report_vuln ( <str> = > shost , <str> = > datastore [ <str> ] . to_i , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > self . references ) else vprint_status ( <str> shost <str> sport <str> info . error_code <str> ) end end end 
