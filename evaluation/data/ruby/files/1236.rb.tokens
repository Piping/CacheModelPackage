require <str> class GrandParent include ActiveSupport :: Callbacks attr_reader <str> , <str> def initialize ( action_name ) @action_name , @log = action_name , [ ] end define_callbacks <str> set_callback <str> , <str> , <str> , <str> , <str> = > proc { | c | c . action_name == <str> || c . action_name == <str> } set_callback <str> , <str> , <str> , <str> , <str> = > proc { | c | c . action_name == <str> || c . action_name == <str> } def before1 @log << <str> end def before2 @log << <str> end def after1 @log << <str> end def after2 @log << <str> end def dispatch run_callbacks <str> do @log << action_name end self end end class Parent < GrandParent skip_callback <str> , <str> , <str> , <str> = > proc { | c | c . action_name == <str> } skip_callback <str> , <str> , <str> , <str> = > proc { | c | c . action_name == <str> } end class Child < GrandParent skip_callback <str> , <str> , <str> , <str> = > proc { | c | c . action_name == <str> } , <str> = > <str> def state_open? @state == <str> end def initialize ( action_name , state ) super ( action_name ) @state = state end end class EmptyParent include ActiveSupport :: Callbacks def performed? @performed || = false end define_callbacks <str> def perform! @performed = true end def dispatch run_callbacks <str> self end end class EmptyChild < EmptyParent set_callback <str> , <str> , <str> def do_nothing end end class CountingParent include ActiveSupport :: Callbacks attr_reader <str> define_callbacks <str> def initialize @count = <int> end def count! @count += <int> end def dispatch run_callbacks ( <str> ) self end end class CountingChild < CountingParent end class BasicCallbacksTest < ActiveSupport :: TestCase def setup @index = GrandParent . new ( <str> ) . dispatch @update = GrandParent . new ( <str> ) . dispatch @delete = GrandParent . new ( <str> ) . dispatch end def test_basic_conditional_callback1 assert_equal <str> , @index . log end def test_basic_conditional_callback2 assert_equal <str> , @update . log end def test_basic_conditional_callback3 assert_equal <str> , @delete . log end end class InheritedCallbacksTest < ActiveSupport :: TestCase def setup @index = Parent . new ( <str> ) . dispatch @update = Parent . new ( <str> ) . dispatch @delete = Parent . new ( <str> ) . dispatch end def test_inherited_excluded assert_equal <str> , @index . log end def test_inherited_not_excluded assert_equal <str> , @update . log end def test_partially_excluded assert_equal <str> , @delete . log end end class InheritedCallbacksTest2 < ActiveSupport :: TestCase def setup @update1 = Child . new ( <str> , <str> ) . dispatch @update2 = Child . new ( <str> , <str> ) . dispatch end def test_crazy_mix_on assert_equal <str> , @update1 . log end def test_crazy_mix_off assert_equal <str> , @update2 . log end end class DynamicInheritedCallbacks < ActiveSupport :: TestCase def test_callbacks_looks_to_the_superclass_before_running child = EmptyChild . new . dispatch assert ! child . performed? EmptyParent . set_callback <str> , <str> , <str> child = EmptyChild . new . dispatch assert child . performed? end def test_callbacks_should_be_performed_once_in_child_class CountingParent . set_callback ( <str> , <str> ) { count! } child = CountingChild . new . dispatch assert_equal <int> , child . count end end 
