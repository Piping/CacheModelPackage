require_relative <str> if defined? ( OpenSSL :: TestUtils ) class OpenSSL :: TestCipher < Test :: Unit :: TestCase class << self def has_cipher? ( name ) ciphers = OpenSSL :: Cipher . ciphers define_singleton_method <str> do | name | ciphers . include? ( name ) end has_cipher? ( name ) end def has_ciphers? ( list ) list . all? { | name | has_cipher? ( name ) } end end def setup @c1 = OpenSSL :: Cipher :: Cipher . new ( <str> ) @c2 = OpenSSL :: Cipher :: DES . new ( <str> , <str> ) @key = <str> @iv = <str> @hexkey = <str> @hexiv = <str> @data = <str> end def teardown @c1 = @c2 = nil end def test_crypt @c1 . encrypt . pkcs5_keyivgen ( @key , @iv ) @c2 . encrypt . pkcs5_keyivgen ( @key , @iv ) s1 = @c1 . update ( @data ) + @c1 . final s2 = @c2 . update ( @data ) + @c2 . final assert_equal ( s1 , s2 , <str> ) @c1 . decrypt . pkcs5_keyivgen ( @key , @iv ) @c2 . decrypt . pkcs5_keyivgen ( @key , @iv ) assert_equal ( @data , @c1 . update ( s1 ) + @c1 . final , <str> ) assert_equal ( @data , @c2 . update ( s2 ) + @c2 . final , <str> ) end def test_info assert_equal ( <str> , @c1 . name , <str> ) assert_equal ( <str> , @c2 . name , <str> ) assert_kind_of ( Fixnum , @c1 . key_len , <str> ) assert_kind_of ( Fixnum , @c1 . iv_len , <str> ) end def test_dup assert_equal ( @c1 . name , @c1 . dup . name , <str> ) assert_equal ( @c1 . name , @c1 . clone . name , <str> ) @c1 . encrypt @c1 . key = @key @c1 . iv = @iv tmpc = @c1 . dup s1 = @c1 . update ( @data ) + @c1 . final s2 = tmpc . update ( @data ) + tmpc . final assert_equal ( s1 , s2 , <str> ) end def test_reset @c1 . encrypt @c1 . key = @key @c1 . iv = @iv s1 = @c1 . update ( @data ) + @c1 . final @c1 . reset s2 = @c1 . update ( @data ) + @c1 . final assert_equal ( s1 , s2 , <str> ) end def test_empty_data @c1 . encrypt assert_raise ( ArgumentError ) { @c1 . update ( <str> ) } end def test_initialize assert_raise ( RuntimeError ) { @c1 . __send__ ( <str> , <str> ) } assert_raise ( RuntimeError ) { OpenSSL :: Cipher . allocate . final } end def test_ctr_if_exists begin cipher = OpenSSL :: Cipher . new ( <str> ) cipher . encrypt cipher . pkcs5_keyivgen ( <str> ) c = cipher . update ( <str> ) + cipher . final cipher . decrypt cipher . pkcs5_keyivgen ( <str> ) assert_equal ( <str> , cipher . update ( c ) + cipher . final ) end end if has_cipher? ( <str> ) if OpenSSL :: OPENSSL_VERSION_NUMBER > <hex> def test_ciphers OpenSSL :: Cipher . ciphers . each { | name | next if <str> =~ RUBY_PLATFORM && <str> =~ name begin assert_kind_of ( OpenSSL :: Cipher :: Cipher , OpenSSL :: Cipher :: Cipher . new ( name ) ) rescue OpenSSL :: Cipher :: CipherError = > e next if <str> =~ name and e . message == <str> raise end } end def test_AES pt = File . read ( __FILE__ ) <str> . each { | mode | c1 = OpenSSL :: Cipher :: AES256 . new ( mode ) c1 . encrypt c1 . pkcs5_keyivgen ( <str> ) ct = c1 . update ( pt ) + c1 . final c2 = OpenSSL :: Cipher :: AES256 . new ( mode ) c2 . decrypt c2 . pkcs5_keyivgen ( <str> ) assert_equal ( pt , c2 . update ( ct ) + c2 . final ) } end def test_AES_crush <int> . times do assert_nothing_raised ( <str> ) do OpenSSL :: Cipher :: AES128 . new ( <str> ) . update <str> * <int> end end end end if has_ciphers? ( [ <str> , <str> , <str> ] ) def test_authenticated cipher = OpenSSL :: Cipher . new ( <str> ) assert_predicate ( cipher , <str> ) cipher = OpenSSL :: Cipher . new ( <str> ) assert_not_predicate ( cipher , <str> ) end def test_aes_gcm [ <str> , <str> , <str> ] . each do | algo | pt = <str> cipher , key , iv = new_encryptor ( algo ) cipher . auth_data = <str> ct = cipher . update ( pt ) + cipher . final tag = cipher . auth_tag assert_equal ( <int> , tag . size ) decipher = new_decryptor ( algo , key , iv ) decipher . auth_tag = tag decipher . auth_data = <str> assert_equal ( pt , decipher . update ( ct ) + decipher . final ) end end def test_aes_gcm_short_tag [ <str> , <str> , <str> ] . each do | algo | pt = <str> cipher , key , iv = new_encryptor ( algo ) cipher . auth_data = <str> ct = cipher . update ( pt ) + cipher . final tag = cipher . auth_tag ( <int> ) assert_equal ( <int> , tag . size ) decipher = new_decryptor ( algo , key , iv ) decipher . auth_tag = tag decipher . auth_data = <str> assert_equal ( pt , decipher . update ( ct ) + decipher . final ) end end def test_aes_gcm_wrong_tag pt = <str> cipher , key , iv = new_encryptor ( <str> ) cipher . auth_data = <str> ct = cipher . update ( pt ) + cipher . final tag = cipher . auth_tag decipher = new_decryptor ( <str> , key , iv ) tag . setbyte ( - <int> , ( tag . getbyte ( - <int> ) + <int> ) & <hex> ) decipher . auth_tag = tag decipher . auth_data = <str> assert_raise OpenSSL :: Cipher :: CipherError do decipher . update ( ct ) + decipher . final end end def test_aes_gcm_wrong_auth_data pt = <str> cipher , key , iv = new_encryptor ( <str> ) cipher . auth_data = <str> ct = cipher . update ( pt ) + cipher . final tag = cipher . auth_tag decipher = new_decryptor ( <str> , key , iv ) decipher . auth_tag = tag decipher . auth_data = <str> assert_raise OpenSSL :: Cipher :: CipherError do decipher . update ( ct ) + decipher . final end end def test_aes_gcm_wrong_ciphertext pt = <str> cipher , key , iv = new_encryptor ( <str> ) cipher . auth_data = <str> ct = cipher . update ( pt ) + cipher . final tag = cipher . auth_tag decipher = new_decryptor ( <str> , key , iv ) decipher . auth_tag = tag decipher . auth_data = <str> assert_raise OpenSSL :: Cipher :: CipherError do decipher . update ( ct [ <int> .. - <int> ] << ct [ - <int> ] . succ ) + decipher . final end end end private def new_encryptor ( algo ) cipher = OpenSSL :: Cipher . new ( algo ) cipher . encrypt key = cipher . random_key iv = cipher . random_iv [ cipher , key , iv ] end def new_decryptor ( algo , key , iv ) OpenSSL :: Cipher . new ( algo ) . tap do | cipher | cipher . decrypt cipher . key = key cipher . iv = iv end end end end 
