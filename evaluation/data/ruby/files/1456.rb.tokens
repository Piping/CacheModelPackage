require <str> require <str> EnvUtil . suppress_warning { require <str> } require <str> class TestFiber < Test :: Unit :: TestCase def test_normal assert_equal ( <str> , Fiber . new { | e | assert_equal ( <str> , e ) Fiber . yield <str> } . resume ( <str> ) ) assert_equal ( [ <str> , <str> ] , Fiber . new { | a , b | [ a , b ] } . resume ( <str> , <str> ) ) end def test_argument assert_equal ( <int> , Fiber . new { | i = <int> | i } . resume ) end def test_term assert_equal ( <str> , Fiber . new { <str> } . resume ) assert_equal ( [ <str> , <str> , <str> , <str> , <str> ] , Fiber . new { Fiber . new { Fiber . new { Fiber . new { [ <str> ] } . resume + [ <str> ] } . resume + [ <str> ] } . resume + [ <str> ] } . resume + [ <str> ] ) end def test_many_fibers max = <int> assert_equal ( max , max . times { Fiber . new { } } ) GC . start assert_equal ( max , max . times { | i | Fiber . new { } . resume } ) GC . start end def test_many_fibers_with_threads assert_normal_exit <<- <str> SRC <str> , <str> : <int> <str> SRC end def test_error assert_raise ( ArgumentError ) { Fiber . new } assert_raise ( FiberError ) { f = Fiber . new { } Thread . new { f . resume } . join } assert_raise ( FiberError ) { f = Fiber . new { } f . resume f . resume } assert_raise ( RuntimeError ) { Fiber . new { @c = callcc { | c | @c = c } } . resume @c . call } assert_raise ( RuntimeError ) { Fiber . new { raise } . resume } assert_raise ( FiberError ) { Fiber . yield } assert_raise ( FiberError ) { fib = Fiber . new { fib . resume } fib . resume } assert_raise ( FiberError ) { fib = Fiber . new { Fiber . new { fib . resume } . resume } fib . resume } end def test_return assert_raise ( LocalJumpError ) { Fiber . new do return end . resume } end def test_throw assert_raise ( UncaughtThrowError ) { Fiber . new do throw <str> end . resume } end def test_transfer ary = [ ] f2 = nil f1 = Fiber . new { ary << f2 . transfer ( <str> ) <str> } f2 = Fiber . new { ary << f1 . transfer ( <str> ) <str> } assert_equal ( <str> , f1 . transfer ) assert_equal ( [ <str> ] , ary ) end def test_tls def tvar ( var , val ) old = Thread . current [ var ] begin Thread . current [ var ] = val yield ensure Thread . current [ var ] = old end end fb = Fiber . new { assert_equal ( nil , Thread . current [ <str> ] ) ; tvar ( <str> , <str> ) { assert_equal ( <str> , Thread . current [ <str> ] ) ; Fiber . yield assert_equal ( <str> , Thread . current [ <str> ] ) ; } assert_equal ( nil , Thread . current [ <str> ] ) ; Fiber . yield raise } assert_equal ( nil , Thread . current [ <str> ] ) ; tvar ( <str> , <int> ) { assert_equal ( <int> , Thread . current [ <str> ] ) ; tvar ( <str> , <int> ) { assert_equal ( <int> , Thread . current [ <str> ] ) ; fb . resume assert_equal ( <int> , Thread . current [ <str> ] ) ; } assert_equal ( <int> , Thread . current [ <str> ] ) ; } assert_equal ( nil , Thread . current [ <str> ] ) ; fb . resume assert_equal ( nil , Thread . current [ <str> ] ) ; end def test_alive fib = Fiber . new { Fiber . yield } assert_equal ( true , fib . alive? ) fib . resume assert_equal ( true , fib . alive? ) fib . resume assert_equal ( false , fib . alive? ) end def test_resume_self f = Fiber . new { f . resume } assert_raise ( FiberError , <str> ) { f . transfer } end def test_fiber_transfer_segv assert_normal_exit <str> , <str> assert_normal_exit <str> end def test_resume_root_fiber assert_raise ( FiberError ) do Thread . new do Fiber . current . resume end . join end end def test_gc_root_fiber bug4612 = <str> assert_normal_exit <str> , bug4612 end def test_no_valid_cfp bug5083 = <str> assert_equal ( [ ] , Fiber . new ( & Module . method ( <str> ) ) . resume , bug5083 ) assert_instance_of ( Class , Fiber . new ( & Class . new . method ( <str> ) ) . resume ( <str> ) , bug5083 ) end def test_prohibit_resume_transfered_fiber assert_raise ( FiberError ) { root_fiber = Fiber . current f = Fiber . new { root_fiber . transfer } f . transfer f . resume } assert_raise ( FiberError ) { g = nil f = Fiber . new { g . resume g . resume } g = Fiber . new { f . resume f . resume } f . transfer } end def test_fork_from_fiber begin pid = Process . fork { } rescue NotImplementedError return else Process . wait ( pid ) end bug5700 = <str> assert_nothing_raised ( bug5700 ) do Fiber . new { pid = fork { } } . resume end pid , status = Process . waitpid2 ( pid ) assert_equal ( <int> , status . exitstatus , bug5700 ) assert_equal ( false , status . signaled? , bug5700 ) end def test_exit_in_fiber bug5993 = <str> assert_nothing_raised ( bug5993 ) do Thread . new { Fiber . new { Thread . exit } . resume ; raise <str> } . join end end def test_fatal_in_fiber assert_in_out_err ( [ <str> , <str> , <<- <str> EOS <str> ] , <str> , [ ] , <str> ) <str> EOS end def invoke_rec script , vm_stack_size , machine_stack_size , use_length = true env = { } env [ <str> ] = vm_stack_size . to_s if vm_stack_size env [ <str> ] = machine_stack_size . to_s if machine_stack_size out , _ = Dir . mktmpdir ( <str> ) { | tmpdir | EnvUtil . invoke_ruby ( [ env , <str> , script ] , <str> , true , true , <str> : tmpdir , <str> : <int> ) } use_length ? out . length : out end def test_stack_size h_default = eval ( invoke_rec ( <str> , nil , nil , false ) ) h_0 = eval ( invoke_rec ( <str> , <int> , <int> , false ) ) h_large = eval ( invoke_rec ( <str> , <int> * <int> * <int> , <int> * <int> * <int> , false ) ) assert_operator ( h_default [ <str> ] , <str> , h_0 [ <str> ] ) assert_operator ( h_default [ <str> ] , <str> , h_large [ <str> ] ) assert_operator ( h_default [ <str> ] , <str> , h_0 [ <str> ] ) assert_operator ( h_default [ <str> ] , <str> = , h_large [ <str> ] ) script = <str> size_default = invoke_rec script , nil , nil assert_operator ( size_default , <str> , <int> ) size_0 = invoke_rec script , <int> , nil assert_operator ( size_default , <str> , size_0 ) size_large = invoke_rec script , <int> * <int> * <int> , nil assert_operator ( size_default , <str> , size_large ) return if <str> =~ RUBY_PLATFORM script = <str> vm_stack_size = <int> * <int> size_default = invoke_rec script , vm_stack_size , nil size_0 = invoke_rec script , vm_stack_size , <int> assert_operator ( size_default , <str> , size_0 ) size_large = invoke_rec script , vm_stack_size , <int> * <int> * <int> assert_operator ( size_default , <str> = , size_large ) end def test_separate_lastmatch bug7678 = <str> <str> =~ <str> m1 = $~ m2 = nil Fiber . new do <str> =~ <str> m2 = $~ end . resume assert_equal ( <str> , m2 [ <int> ] ) assert_equal ( m1 , $~ , bug7678 ) end def test_separate_lastline bug7678 = <str> $_ = s1 = <str> s2 = nil Fiber . new do s2 = <str> end . resume assert_equal ( <str> , s2 ) assert_equal ( s1 , $_ , bug7678 ) end end 
