require File . expand_path ( <str> , __FILE__ ) $: . unshift ( File . dirname ( __FILE__ ) + <str> ) $: . unshift ( File . dirname ( __FILE__ ) + <str> ) $: . unshift ( File . dirname ( __FILE__ ) + <str> ) ENV [ <str> ] = File . join ( File . dirname ( __FILE__ ) , <str> ) require <str> silence_warnings do Encoding . default_internal = <str> Encoding . default_external = <str> end require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> module Rails class << self def env @_env || = ActiveSupport :: StringInquirer . new ( ENV [ <str> ] || ENV [ <str> ] || <str> ) end end end ActiveSupport :: Dependencies . hook! Thread . abort_on_exception = true ActiveSupport :: Deprecation . debug = true I18n . enforce_available_locales = false I18n . backend . store_translations <str> , { } I18n . backend . store_translations <str> , { } ORIGINAL_LOCALES = I18n . available_locales . map ( & <str> ) . sort FIXTURE_LOAD_PATH = File . join ( File . dirname ( __FILE__ ) , <str> ) module RenderERBUtils def view @view || = begin path = ActionView :: FileSystemResolver . new ( FIXTURE_LOAD_PATH ) view_paths = ActionView :: PathSet . new ( [ path ] ) ActionView :: Base . new ( view_paths ) end end def render_erb ( string ) @virtual_path = nil template = ActionView :: Template . new ( string . strip , <str> , ActionView :: Template :: Handlers :: ERB , { } ) template . render ( self , { } ) . strip end end SharedTestRoutes = ActionDispatch :: Routing :: RouteSet . new module ActionDispatch module SharedRoutes def before_setup @routes = SharedTestRoutes super end end module DrawOnce class << self attr_accessor <str> end self . drew = false def before_setup super return if DrawOnce . drew SharedTestRoutes . draw do get <str> end ActionDispatch :: IntegrationTest . app . routes . draw do get <str> end DrawOnce . drew = true end end end module ActiveSupport class TestCase include ActionDispatch :: DrawOnce end end class RoutedRackApp attr_reader <str> def initialize ( routes , & blk ) @routes = routes @stack = ActionDispatch :: MiddlewareStack . new ( & blk ) . build ( @routes ) end def call ( env ) @stack . call ( env ) end end class BasicController attr_accessor <str> def config @config || = ActiveSupport :: InheritableOptions . new ( ActionController :: Base . config ) . tap do | config | public_dir = File . expand_path ( <str> , __FILE__ ) config . assets_dir = public_dir config . javascripts_dir = <str> public_dir <str> config . stylesheets_dir = <str> public_dir <str> config . assets = ActiveSupport :: InheritableOptions . new ( { <str> = > <str> } ) config end end end class ActionDispatch :: IntegrationTest < ActiveSupport :: TestCase include ActionDispatch :: SharedRoutes def self . build_app ( routes = nil ) RoutedRackApp . new ( routes || ActionDispatch :: Routing :: RouteSet . new ) do | middleware | middleware . use ActionDispatch :: ShowExceptions , ActionDispatch :: PublicExceptions . new ( <str> FIXTURE_LOAD_PATH <str> ) middleware . use ActionDispatch :: DebugExceptions middleware . use ActionDispatch :: Callbacks middleware . use ActionDispatch :: Cookies middleware . use ActionDispatch :: Flash middleware . use Rack :: Head yield ( middleware ) if block_given? end end self . app = build_app class StubDispatcher < :: ActionDispatch :: Routing :: RouteSet :: Dispatcher protected def controller_reference ( controller_param ) controller_param end def dispatch ( controller , action , env ) [ <int> , { <str> = > <str> } , [ <str> controller <str> action <str> ] ] end end def self . stub_controllers old_dispatcher = ActionDispatch :: Routing :: RouteSet :: Dispatcher ActionDispatch :: Routing :: RouteSet . module_eval { remove_const <str> } ActionDispatch :: Routing :: RouteSet . module_eval { const_set <str> , StubDispatcher } yield ActionDispatch :: Routing :: RouteSet . new ensure ActionDispatch :: Routing :: RouteSet . module_eval { remove_const <str> } ActionDispatch :: Routing :: RouteSet . module_eval { const_set <str> , old_dispatcher } end def with_routing ( & block ) temporary_routes = ActionDispatch :: Routing :: RouteSet . new old_app , self . class . app = self . class . app , self . class . build_app ( temporary_routes ) old_routes = SharedTestRoutes silence_warnings { Object . const_set ( <str> , temporary_routes ) } yield temporary_routes ensure self . class . app = old_app silence_warnings { Object . const_set ( <str> , old_routes ) } end def with_autoload_path ( path ) path = File . join ( File . dirname ( __FILE__ ) , <str> , path ) if ActiveSupport :: Dependencies . autoload_paths . include? ( path ) yield else begin ActiveSupport :: Dependencies . autoload_paths << path yield ensure ActiveSupport :: Dependencies . autoload_paths . reject! { | p | p == path } ActiveSupport :: Dependencies . clear end end end end ActionView :: RoutingUrlFor . include ( ActionDispatch :: Routing :: UrlFor ) module ActionController class Base include SharedTestRoutes . url_helpers include SharedTestRoutes . mounted_helpers self . view_paths = FIXTURE_LOAD_PATH def self . test_routes ( & block ) routes = ActionDispatch :: Routing :: RouteSet . new routes . draw ( & block ) include routes . url_helpers end end class TestCase include ActionDispatch :: TestProcess include ActionDispatch :: SharedRoutes end end module ActionView class TestCase include ActionDispatch :: SharedRoutes end end class Workshop extend ActiveModel :: Naming include ActiveModel :: Conversion attr_accessor <str> def initialize ( id ) @id = id end def persisted? id . present? end def to_s id . to_s end end module ActionDispatch class DebugExceptions private remove_method <str> def stderr_logger nil end end end def rubinius_skip ( message = <str> ) skip message if RUBY_ENGINE == <str> end def jruby_skip ( message = <str> ) skip message if defined? ( JRUBY_VERSION ) end class ActiveSupport :: TestCase include ActiveSupport :: Testing :: MethodCallAssertions end 
