require <str> class TestFloat < Test :: Unit :: TestCase include EnvUtil def test_float assert_equal ( <int> , <int> . <int> . floor ) assert_equal ( - <int> , ( - <int> . <int> ) . floor ) assert_equal ( <int> , <int> . <int> . ceil ) assert_equal ( - <int> , ( - <int> . <int> ) . ceil ) assert_equal ( <int> , <int> . <int> . truncate ) assert_equal ( - <int> , ( - <int> . <int> ) . truncate ) assert_equal ( <int> , <int> . <int> . round ) assert_equal ( - <int> , ( - <int> . <int> ) . truncate ) assert_in_delta ( <int> . <int> % <int> , <int> . <int> , <int> . <oct> ) assert_equal ( <int> , <int> . <int> . to_i ) end def nan_test ( x , y ) extend Test :: Unit :: Assertions assert_operator ( x , : != , y ) assert_not_operator ( x , <str> , y ) assert_not_operator ( x , <str> , y ) assert_not_operator ( x , <str> = , y ) assert_not_operator ( x , <str> , y ) end def test_nan nan = Float :: NAN nan_test ( nan , nan ) nan_test ( nan , <int> ) nan_test ( nan , <int> ) nan_test ( nan , - <int> ) nan_test ( nan , <int> ) nan_test ( nan , - <int> ) nan_test ( nan , <int> ) nan_test ( nan , - <int> ) nan_test ( nan , <int> . <int> ) ; nan_test ( nan , - <int> . <int> ) ; nan_test ( nan , <int> . <oct> ) ; nan_test ( nan , - <int> . <oct> ) ; nan_test ( nan , <int> . <int> / <int> ) ; nan_test ( nan , - <int> . <int> / <int> ) ; end def test_precision u = <int> . <int> e + <int> v = sprintf ( <str> , u ) . to_f assert_in_delta ( u , v , u . abs * Float :: EPSILON ) assert_in_delta ( u , v , v . abs * Float :: EPSILON ) end def test_symmetry_bignum a = <int> b = <int> . <int> assert_equal ( a == b , b == a ) end def test_cmp_int <int> . times { | i | int0 = <int> << i [ int0 , - int0 ] . each { | int | flt = int . to_f bigger = int + <int> smaller = int - <int> assert_operator ( flt , <str> , int ) assert_operator ( flt , <str> , smaller ) assert_operator ( flt , <str> , smaller ) assert_operator ( flt , <str> , bigger ) assert_operator ( flt , <str> = , bigger ) assert_equal ( <int> , flt < = > int ) assert_equal ( - <int> , flt < = > bigger ) assert_equal ( <int> , flt < = > smaller ) assert_operator ( int , <str> , flt ) assert_operator ( bigger , <str> , flt ) assert_operator ( bigger , <str> , flt ) assert_operator ( smaller , <str> , flt ) assert_operator ( smaller , <str> = , flt ) assert_equal ( <int> , int < = > flt ) assert_equal ( - <int> , smaller < = > flt ) assert_equal ( <int> , bigger < = > flt ) [ [ int , flt + <int> . <int> , bigger ] , [ smaller , flt - <int> . <int> , int ] ] . each { | smaller2 , flt2 , bigger2 | next if flt2 == flt2 . round assert_operator ( flt2 , : != , smaller2 ) assert_operator ( flt2 , : != , bigger2 ) assert_operator ( flt2 , <str> , smaller2 ) assert_operator ( flt2 , <str> , smaller2 ) assert_operator ( flt2 , <str> , bigger2 ) assert_operator ( flt2 , <str> = , bigger2 ) assert_equal ( - <int> , flt2 < = > bigger2 ) assert_equal ( <int> , flt2 < = > smaller2 ) assert_operator ( smaller2 , : != , flt2 ) assert_operator ( bigger2 , : != , flt2 ) assert_operator ( bigger2 , <str> , flt2 ) assert_operator ( bigger2 , <str> , flt2 ) assert_operator ( smaller2 , <str> , flt2 ) assert_operator ( smaller2 , <str> = , flt2 ) assert_equal ( - <int> , smaller2 < = > flt2 ) assert_equal ( <int> , bigger2 < = > flt2 ) } } } end def test_strtod a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_not_equal ( <int> . <int> , a ) a = Float ( <str> ) assert_not_equal ( <int> . <int> , a ) a = Float ( <str> ) assert_not_equal ( <int> . <int> , a ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) a = Float ( <str> ) assert_in_delta ( a , <int> , Float :: EPSILON ) assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_equal ( <int> , Float ( <str> ) ) assert_equal ( [ <int> . <int> ] . pack ( <str> ) , [ Float ( <str> ) . to_f ] . pack ( <str> ) ) assert_equal ( [ - <int> . <int> ] . pack ( <str> ) , [ Float ( <str> ) . to_f ] . pack ( <str> ) ) assert_equal ( <int> . <int> , Float ( <str> ) ) assert_equal ( <int> . <int> , Float ( <str> ) ) assert_equal ( <int> . <int> , Float ( <str> ) ) assert_equal ( <int> . <oct> <int> , Float ( <str> ) ) assert_equal ( <int> . <int> e + <int> , Float ( <str> ) ) assert_equal ( - <int> . <int> e - <int> , Float ( <str> ) ) assert_equal ( <int> . <int> * <int> ** <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( <int> . <int> * <int> ** <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( - <int> . <int> * <int> ** <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( - <int> . <int> * <int> ** <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) suppress_warning do assert_equal ( <int> . <int> * <int> ** - <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( <int> . <int> * <int> ** - <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( - <int> . <int> * <int> ** - <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) assert_equal ( - <int> . <int> * <int> ** - <int> , Float ( <str> + ( <str> * <int> ) + <str> ) ) end end def test_divmod assert_equal ( [ <int> , <int> . <int> ] , <int> . <int> . divmod ( <int> ) ) assert_equal ( [ - <int> , - <int> . <int> ] , <int> . <int> . divmod ( - <int> ) ) assert_equal ( [ - <int> , <int> . <int> ] , ( - <int> . <int> ) . divmod ( <int> ) ) assert_equal ( [ <int> , - <int> . <int> ] , ( - <int> . <int> ) . divmod ( - <int> ) ) assert_raise ( FloatDomainError ) { Float :: NAN . divmod ( <int> ) } assert_raise ( FloatDomainError ) { Float :: INFINITY . divmod ( <int> ) } end def test_div assert_equal ( <int> , <int> . <int> . div ( <int> ) ) assert_equal ( - <int> , <int> . <int> . div ( - <int> ) ) assert_equal ( - <int> , ( - <int> . <int> ) . div ( <int> ) ) assert_equal ( <int> , ( - <int> . <int> ) . div ( - <int> ) ) assert_raise ( FloatDomainError ) { <int> . <int> . div ( Float :: NAN ) . nan? } assert_raise ( FloatDomainError ) { Float :: NAN . div ( <int> ) . nan? } assert_raise ( FloatDomainError ) { Float :: NAN . div ( <int> . <int> ) . nan? } end def test_modulo assert_equal ( <int> . <int> , <int> . <int> . modulo ( <int> ) ) assert_equal ( - <int> . <int> , <int> . <int> . modulo ( - <int> ) ) assert_equal ( <int> . <int> , ( - <int> . <int> ) . modulo ( <int> ) ) assert_equal ( - <int> . <int> , ( - <int> . <int> ) . modulo ( - <int> ) ) end def test_remainder assert_equal ( <int> . <int> , <int> . <int> . remainder ( <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . remainder ( - <int> ) ) assert_equal ( - <int> . <int> , ( - <int> . <int> ) . remainder ( <int> ) ) assert_equal ( - <int> . <int> , ( - <int> . <int> ) . remainder ( - <int> ) ) assert_predicate ( Float :: NAN . remainder ( <int> ) , <str> ) assert_predicate ( <int> . remainder ( Float :: NAN ) , <str> ) end def test_to_s inf = Float :: INFINITY assert_equal ( <str> , inf . to_s ) assert_equal ( <str> , ( - inf ) . to_s ) assert_equal ( <str> , ( inf / inf ) . to_s ) assert_equal ( <str> , <int> . <int> . to_s ) bug3273 = <str> [ <int> . <int> , <int> . <int> ] . each do | f | s = f . to_s assert_equal ( f , s . to_f , bug3273 ) assert_not_equal ( f , s . chop . to_f , bug3273 ) end end def test_coerce assert_equal ( Float , <int> . <int> . coerce ( <int> ) . first . class ) end def test_plus assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> . <int> ) ) assert_equal ( Float :: INFINITY , <int> . <int> . send ( <str> , Float :: INFINITY ) ) assert_predicate ( <int> . <int> . send ( <str> , Float :: NAN ) , <str> ) assert_raise ( TypeError ) { <int> . <int> . send ( <str> , nil ) } end def test_minus assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> . <int> ) ) assert_equal ( - Float :: INFINITY , <int> . <int> . send ( <str> , Float :: INFINITY ) ) assert_predicate ( <int> . <int> . send ( <str> , Float :: NAN ) , <str> ) assert_raise ( TypeError ) { <int> . <int> . send ( <str> , nil ) } end def test_mul assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> . <int> ) ) assert_equal ( Float :: INFINITY , <int> . <int> . send ( <str> , Float :: INFINITY ) ) assert_raise ( TypeError ) { <int> . <int> . send ( <str> , nil ) } end def test_div2 assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> . <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , Float :: INFINITY ) ) assert_raise ( TypeError ) { <int> . <int> . send ( <str> , nil ) } end def test_modulo2 assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , <int> . <int> ) ) assert_raise ( TypeError ) { <int> . <int> . send ( <str> , nil ) } end def test_modulo3 bug6048 = <str> assert_equal ( <int> . <int> , <int> . <int> . send ( <str> , Float :: INFINITY ) , bug6048 ) assert_equal ( <int> . <int> , <int> . <int> % Float :: INFINITY , bug6048 ) assert_is_minus_zero ( - <int> . <int> % <int> . <int> ) assert_is_minus_zero ( - <int> . <int> . send <str> , <int> . <int> ) assert_raise ( ZeroDivisionError , bug6048 ) { <int> . <int> . send ( <str> , <int> . <int> ) } assert_raise ( ZeroDivisionError , bug6048 ) { <int> . <int> % <int> . <int> } assert_raise ( ZeroDivisionError , bug6048 ) { <int> . send ( <str> , <int> ) } assert_raise ( ZeroDivisionError , bug6048 ) { <int> % <int> } end def test_modulo4 assert_predicate ( ( <int> . <int> ) . modulo ( Float :: NAN ) , <str> ) assert_predicate ( ( <int> . <int> ) . modulo ( Float :: NAN ) , <str> ) assert_predicate ( Float :: INFINITY . modulo ( <int> ) , <str> ) end def test_divmod2 assert_equal ( [ <int> . <int> , <int> . <int> ] , <int> . <int> . divmod ( <int> ) ) assert_equal ( [ <int> . <int> , <int> . <int> ] , <int> . <int> . divmod ( ( <int> ** <int> ) . coerce ( <int> ) . first ) ) assert_equal ( [ <int> . <int> , <int> . <int> ] , <int> . <int> . divmod ( <int> . <int> ) ) assert_raise ( TypeError ) { <int> . <int> . divmod ( nil ) } inf = Float :: INFINITY assert_raise ( ZeroDivisionError ) { inf . divmod ( <int> ) } a , b = ( <int> . <int> ** <int> ) . divmod ( <int> . <int> ) assert_equal ( <int> ** <int> , a ) assert_equal ( <int> , b ) end def test_pow assert_equal ( <int> . <int> , <int> . <int> ** ( <int> ** <int> ) ) assert_equal ( <int> . <int> , <int> . <int> ** <int> . <int> ) assert_raise ( TypeError ) { <int> . <int> ** nil } end def test_eql inf = Float :: INFINITY nan = Float :: NAN assert_operator ( <int> . <int> , <str> , <int> . <int> ) assert_operator ( inf , <str> , inf ) assert_not_operator ( nan , <str> , nan ) assert_not_operator ( <int> . <int> , <str> , nil ) assert_equal ( <int> . <int> , <int> ) assert_not_equal ( <int> . <int> , <int> ** <int> ) assert_not_equal ( <int> . <int> , nan ) assert_not_equal ( <int> . <int> , nil ) end def test_cmp inf = Float :: INFINITY nan = Float :: NAN assert_equal ( <int> , <int> . <int> < = > <int> . <int> ) assert_equal ( <int> , <int> . <int> < = > <int> . <int> ) assert_equal ( - <int> , <int> . <int> < = > <int> . <int> ) assert_nil ( <int> . <int> < = > nil ) assert_nil ( <int> . <int> < = > nan ) assert_nil ( nan < = > <int> . <int> ) assert_equal ( <int> , <int> . <int> < = > <int> ) assert_equal ( <int> , <int> . <int> < = > <int> ) assert_equal ( - <int> , <int> . <int> < = > <int> ) assert_equal ( - <int> , <int> . <int> < = > <int> ** <int> ) assert_equal ( <int> , inf < = > ( Float :: MAX . to_i * <int> ) ) assert_equal ( - <int> , - inf < = > ( - Float :: MAX . to_i * <int> ) ) assert_equal ( - <int> , ( Float :: MAX . to_i * <int> ) < = > inf ) assert_equal ( <int> , ( - Float :: MAX . to_i * <int> ) < = > - inf ) bug3609 = <str> def ( pinf = Object . new ) . infinite? ; + <int> end def ( ninf = Object . new ) . infinite? ; - <int> end def ( fin = Object . new ) . infinite? ; nil end nonum = Object . new assert_equal ( <int> , inf < = > pinf , bug3609 ) assert_equal ( <int> , inf < = > fin , bug3609 ) assert_equal ( <int> , inf < = > ninf , bug3609 ) assert_nil ( inf < = > nonum , bug3609 ) assert_equal ( - <int> , - inf < = > pinf , bug3609 ) assert_equal ( - <int> , - inf < = > fin , bug3609 ) assert_equal ( <int> , - inf < = > ninf , bug3609 ) assert_nil ( - inf < = > nonum , bug3609 ) assert_raise ( ArgumentError ) { <int> . <int> > nil } assert_raise ( ArgumentError ) { <int> . <int> > = nil } assert_raise ( ArgumentError ) { <int> . <int> < nil } assert_raise ( ArgumentError ) { <int> . <int> < = nil } end def test_zero_p assert_predicate ( <int> . <int> , <str> ) assert_not_predicate ( <int> . <int> , <str> ) end def test_positive_p assert_predicate ( + <int> . <int> , <str> ) assert_not_predicate ( + <int> . <int> , <str> ) assert_not_predicate ( - <int> . <int> , <str> ) assert_not_predicate ( - <int> . <int> , <str> ) assert_predicate ( + ( <int> . <int> . next_float ) , <str> ) assert_not_predicate ( - ( <int> . <int> . next_float ) , <str> ) assert_predicate ( Float :: INFINITY , <str> ) assert_not_predicate ( - Float :: INFINITY , <str> ) assert_not_predicate ( Float :: NAN , <str> ) end def test_negative_p assert_predicate ( - <int> . <int> , <str> ) assert_not_predicate ( - <int> . <int> , <str> ) assert_not_predicate ( + <int> . <int> , <str> ) assert_not_predicate ( + <int> . <int> , <str> ) assert_predicate ( - ( <int> . <int> . next_float ) , <str> ) assert_not_predicate ( + ( <int> . <int> . next_float ) , <str> ) assert_predicate ( - Float :: INFINITY , <str> ) assert_not_predicate ( Float :: INFINITY , <str> ) assert_not_predicate ( Float :: NAN , <str> ) end def test_infinite_p inf = Float :: INFINITY assert_equal ( <int> , inf . infinite? ) assert_equal ( - <int> , ( - inf ) . infinite? ) assert_nil ( <int> . <int> . infinite? ) end def test_finite_p inf = Float :: INFINITY assert_not_predicate ( inf , <str> ) assert_not_predicate ( - inf , <str> ) assert_predicate ( <int> . <int> , <str> ) end def test_floor_ceil_round_truncate assert_equal ( <int> , <int> . <int> . floor ) assert_equal ( <int> , <int> . <int> . ceil ) assert_equal ( <int> , <int> . <int> . round ) assert_equal ( <int> , <int> . <int> . truncate ) assert_equal ( <int> , <int> . <int> . floor ) assert_equal ( <int> , <int> . <int> . ceil ) assert_equal ( <int> , <int> . <int> . round ) assert_equal ( <int> , <int> . <int> . truncate ) assert_equal ( - <int> , ( - <int> . <int> ) . floor ) assert_equal ( - <int> , ( - <int> . <int> ) . ceil ) assert_equal ( - <int> , ( - <int> . <int> ) . round ) assert_equal ( - <int> , ( - <int> . <int> ) . truncate ) assert_equal ( - <int> , ( - <int> . <int> ) . floor ) assert_equal ( - <int> , ( - <int> . <int> ) . ceil ) assert_equal ( - <int> , ( - <int> . <int> ) . round ) assert_equal ( - <int> , ( - <int> . <int> ) . truncate ) inf = Float :: INFINITY assert_raise ( FloatDomainError ) { inf . floor } assert_raise ( FloatDomainError ) { inf . ceil } assert_raise ( FloatDomainError ) { inf . round } assert_raise ( FloatDomainError ) { inf . truncate } end def test_round_with_precision assert_equal ( <int> . <int> , <int> . <int> . round ( <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . round ( <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . round ( - <int> ) ) assert_equal ( <int> . <int> , <int> . <int> . round ( - <int> ) ) assert_equal ( <int> ** <int> , <int> . <int> e300 . round ( - <int> ) ) assert_equal ( - <int> ** <int> , - <int> . <int> e300 . round ( - <int> ) ) assert_equal ( <int> . <int> e - <int> , <int> . <int> e - <int> . round ( <int> ) ) assert_equal ( - <int> . <int> e - <int> , - <int> . <int> e - <int> . round ( <int> ) ) bug5227 = <str> assert_equal ( <int> . <int> , <int> . <int> . round ( <int> ) , bug5227 ) assert_equal ( <int> . <int> e307 , <int> . <int> e307 . round ( <int> ) , bug5227 ) assert_raise ( TypeError ) { <int> . <int> . round ( <str> ) } assert_raise ( TypeError ) { <int> . <int> . round ( nil ) } def ( prec = Object . new ) . to_int ; <int> ; end assert_equal ( <int> . <int> , <int> . <int> . round ( prec ) ) end VS = [ <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , - <int> . <int> , ] def test_truncate VS . each { | f | i = f . truncate assert_equal ( i , f . to_i ) if f < <int> assert_operator ( i , <str> , <int> ) else assert_operator ( i , <str> , <int> ) end assert_operator ( i . abs , <str> = , f . abs ) d = f . abs - i . abs assert_operator ( <int> , <str> = , d ) assert_operator ( d , <str> , <int> ) } end def test_ceil VS . each { | f | i = f . ceil if f < <int> assert_operator ( i , <str> , <int> ) else assert_operator ( i , <str> , <int> ) end assert_operator ( i , <str> , f ) d = f - i assert_operator ( - <int> , <str> , d ) assert_operator ( d , <str> = , <int> ) } end def test_floor VS . each { | f | i = f . floor if f < <int> assert_operator ( i , <str> , <int> ) else assert_operator ( i , <str> , <int> ) end assert_operator ( i , <str> = , f ) d = f - i assert_operator ( <int> , <str> = , d ) assert_operator ( d , <str> , <int> ) } end def test_round VS . each { | f | msg = <str> f <str> i = f . round if f < <int> assert_operator ( i , <str> , <int> , msg ) else assert_operator ( i , <str> , <int> , msg ) end d = f - i assert_operator ( - <int> . <int> , <str> = , d , msg ) assert_operator ( d , <str> = , <int> . <int> , msg ) } end def test_Float assert_in_delta ( <int> . <int> , Float ( <str> ) , <int> . <oct> ) assert_in_delta ( <int> . <int> , <str> . to_f , <int> . <oct> ) assert_equal ( <int> , suppress_warning { Float ( ( [ <int> ] * <int> ) . join ) } . infinite? ) assert_not_predicate ( Float ( ( [ <int> ] * <int> ) . join ( <str> ) ) , <str> ) assert_raise ( ArgumentError ) { Float ( <str> ) } assert_equal ( <int> . <int> , Float ( <str> ) ) assert_raise ( ArgumentError ) { Float ( <str> ) } assert_equal ( <int> , Float ( <str> ) ) assert_equal ( <int> , Float ( <str> ) ) assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_raise ( ArgumentError ) { Float ( <str> ) } assert_equal ( Float :: INFINITY , Float ( <str> ) ) assert_equal ( <int> , suppress_warning { Float ( <str> ) } . infinite? ) assert_raise ( TypeError ) { Float ( nil ) } o = Object . new def o . to_f ; inf = Float :: INFINITY ; inf / inf ; end assert_predicate ( Float ( o ) , <str> ) end def test_invalid_str bug4310 = <str> assert_raise ( ArgumentError , bug4310 ) { under_gc_stress { Float ( <str> * <int> ) } } end def test_num2dbl assert_raise ( ArgumentError ) do <int> . <int> . step ( <int> . <int> , <str> ) { } end assert_raise ( TypeError ) do <int> . <int> . step ( <int> . <int> , nil ) { } end end def test_sleep_with_Float assert_nothing_raised ( <str> ) do sleep ( <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> + <int> . <int> ) end end def test_step <int> . times do a = rand b = a + rand * <int> s = ( b - a ) / <int> assert_equal ( <int> , ( a .. b ) . step ( s ) . to_a . length ) end ( <int> . <int> .. <int> . <int> ) . step ( <int> . <int> ) . each do | n | assert_operator ( n , <str> = , <int> . <int> ) end assert_equal ( [ <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> ] , <int> . <int> . step ( <int> . <int> , - <int> ) . to_a ) end def test_step2 assert_equal ( [ <int> . <int> ] , <int> . <int> . step ( <int> . <int> , Float :: INFINITY ) . to_a ) end def test_step_excl <int> . times do a = rand b = a + rand * <int> s = ( b - a ) / <int> assert_equal ( <int> , ( a ... b ) . step ( s ) . to_a . length ) end assert_equal ( [ <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> ] , ( <int> . <int> ... <int> . <int> ) . step ( <int> . <int> ) . to_a ) e = <int> + <int> E - <int> ( <int> . <int> ... e ) . step ( <int> E - <int> ) do | n | assert_operator ( n , <str> = , e ) end end def test_singleton_method assert_raise ( TypeError ) { a = <int> . <int> ; def a . foo ; end } assert_raise ( TypeError ) { a = Float :: INFINITY ; def a . foo ; end } end def test_long_string assert_separately ( [ ] , << - <str> ) assert_in_epsilon ( <int> . <int> , ( <str> + <str> * <int> ) . to_f * <int> ) end ; end def test_next_float smallest = <int> . <int> . next_float assert_equal ( - Float :: MAX , ( - Float :: INFINITY ) . next_float ) assert_operator ( - Float :: MAX , <str> , ( - Float :: MAX ) . next_float ) assert_equal ( Float :: EPSILON / <int> , ( - <int> . <int> ) . next_float + <int> . <int> ) assert_operator ( <int> . <int> , <str> , smallest ) assert_operator ( [ <int> . <int> , smallest ] , <str> , smallest / <int> ) assert_equal ( Float :: EPSILON , <int> . <int> . next_float - <int> . <int> ) assert_equal ( Float :: INFINITY , Float :: MAX . next_float ) assert_equal ( Float :: INFINITY , Float :: INFINITY . next_float ) assert_predicate ( Float :: NAN . next_float , <str> ) end def test_prev_float smallest = <int> . <int> . next_float assert_equal ( - Float :: INFINITY , ( - Float :: INFINITY ) . prev_float ) assert_equal ( - Float :: INFINITY , ( - Float :: MAX ) . prev_float ) assert_equal ( - Float :: EPSILON , ( - <int> . <int> ) . prev_float + <int> . <int> ) assert_equal ( - smallest , <int> . <int> . prev_float ) assert_operator ( [ <int> . <int> , <int> . <int> . prev_float ] , <str> , <int> . <int> . prev_float / <int> ) assert_equal ( - Float :: EPSILON / <int> , <int> . <int> . prev_float - <int> . <int> ) assert_operator ( Float :: MAX , <str> , Float :: MAX . prev_float ) assert_equal ( Float :: MAX , Float :: INFINITY . prev_float ) assert_predicate ( Float :: NAN . prev_float , <str> ) end def test_next_prev_float_zero z = <int> . <int> . next_float . prev_float assert_equal ( <int> . <int> , z ) assert_equal ( Float :: INFINITY , <int> . <int> / z ) z = <int> . <int> . prev_float . next_float assert_equal ( <int> . <int> , z ) assert_equal ( - Float :: INFINITY , <int> . <int> / z ) end def test_hash_0 bug10979 = <str> assert_equal ( + <int> . <int> . hash , - <int> . <int> . hash ) assert_operator ( + <int> . <int> , <str> , - <int> . <int> ) h = { <int> . <int> = > bug10979 } assert_equal ( bug10979 , h [ - <int> . <int> ] ) end end 
