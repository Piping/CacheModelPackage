require <str> require <str> require <str> class TestGemDependencyInstaller < Gem :: TestCase def setup super common_installer_setup @gems_dir = File . join @tempdir , <str> @cache_dir = File . join @gemhome , <str> FileUtils . mkdir @gems_dir Gem :: RemoteFetcher . fetcher = @fetcher = Gem :: FakeFetcher . new @original_platforms = Gem . platforms Gem . platforms = [ ] end def teardown Gem . platforms = @original_platforms super end def util_setup_gems @a1 , @a1_gem = util_gem <str> , <str> do | s | s . executables << <str> end @a1_pre , @a1_pre_gem = util_gem <str> , <str> @b1 , @b1_gem = util_gem <str> , <str> do | s | s . add_dependency <str> s . add_development_dependency <str> end @c1 , @c1_gem = util_gem <str> , <str> do | s | s . add_development_dependency <str> end @d1 , @d1_gem = util_gem <str> , <str> do | s | s . add_development_dependency <str> end util_clear_gems util_reset_gems end def test_available_set_for_name util_setup_gems p1a , = util_gem <str> , <str> util_setup_spec_fetcher p1a , @a1 , @a1_pre inst = Gem :: DependencyInstaller . new available = inst . available_set_for <str> , Gem :: Requirement . default assert_equal <str> , available . set . map { | s | s . spec . full_name } end def test_available_set_for_name_prerelease util_setup_gems p1a , = util_gem <str> , <str> util_setup_spec_fetcher p1a , @a1 , @a1_pre inst = Gem :: DependencyInstaller . new <str> = > true available = inst . available_set_for <str> , Gem :: Requirement . default assert_equal <str> , available . sorted . map { | s | s . spec . full_name } end def test_available_set_for_dep util_setup_gems p1a , = util_gem <str> , <str> util_setup_spec_fetcher p1a , @a1 , @a1_pre inst = Gem :: DependencyInstaller . new dep = Gem :: Dependency . new <str> , Gem :: Requirement . default available = inst . available_set_for dep , Gem :: Requirement . default assert_equal <str> , available . set . map { | s | s . spec . full_name } end def test_available_set_for_dep_prerelease util_setup_gems p1a , = util_gem <str> , <str> util_setup_spec_fetcher p1a , @a1 , @a1_pre inst = Gem :: DependencyInstaller . new <str> = > true dep = Gem :: Dependency . new <str> , Gem :: Requirement . default dep . prerelease = true available = inst . available_set_for dep , Gem :: Requirement . default assert_equal <str> , available . sorted . map { | s | s . spec . full_name } end def test_install util_setup_gems FileUtils . mv @a1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal [ @a1 ] , inst . installed_gems end def test_install_prerelease util_setup_gems p1a , gem = util_gem <str> , <str> util_setup_spec_fetcher ( p1a , @a1 , @a1_pre ) util_clear_gems p1a_data = Gem . read_binary ( gem ) @fetcher . data [ <str> ] = p1a_data dep = Gem :: Dependency . new <str> inst = Gem :: DependencyInstaller . new <str> = > true inst . install dep assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal [ p1a ] , inst . installed_gems end def test_install_prerelease_bug_990 spec_fetcher do | fetcher | fetcher . gem <str> , <str> do | s | s . add_dependency <str> , <str> end fetcher . gem <str> , <str> do | s | s . add_dependency <str> , <str> end fetcher . gem <str> , <str> end dep = Gem :: Dependency . new <str> inst = Gem :: DependencyInstaller . new <str> = > true inst . install dep assert_equal <str> , Gem :: Specification . map ( & <str> ) end def test_install_when_only_prerelease p1a , gem = util_gem <str> , <str> util_setup_spec_fetcher ( p1a ) util_clear_gems p1a_data = Gem . read_binary ( gem ) @fetcher . data [ <str> ] = p1a_data dep = Gem :: Dependency . new <str> inst = Gem :: DependencyInstaller . new assert_raises Gem :: UnsatisfiableDependencyError do inst . install dep end assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal [ ] , inst . installed_gems end def test_install_prerelease_skipped_when_normal_ver util_setup_gems util_setup_spec_fetcher ( @a1 , @a1_pre ) util_clear_gems p1a_data = Gem . read_binary ( @a1_gem ) @fetcher . data [ <str> ] = p1a_data dep = Gem :: Dependency . new <str> inst = Gem :: DependencyInstaller . new <str> = > true inst . install dep assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal [ @a1 ] , inst . installed_gems end def test_install_all_dependencies util_setup_gems _ , e1_gem = util_gem <str> , <str> do | s | s . add_dependency <str> end util_clear_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir FileUtils . mv e1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } , <str> Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_cache_dir util_setup_gems dir = <str> Dir . mkdir dir FileUtils . mv @a1_gem , dir FileUtils . mv @b1_gem , dir inst = nil Dir . chdir dir do inst = Gem :: DependencyInstaller . new <str> = > @tempdir inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } assert File . exist? File . join ( @gemhome , <str> , @a1 . file_name ) assert File . exist? File . join ( @gemhome , <str> , @b1 . file_name ) end def test_install_dependencies_satisfied util_setup_gems a2 , a2_gem = util_gem <str> , <str> FileUtils . rm_rf File . join ( @gemhome , <str> ) Gem :: Specification . reset FileUtils . mv @a1_gem , @tempdir FileUtils . mv a2_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> , req ( <str> ) end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } , <str> FileUtils . rm File . join ( @tempdir , a2 . file_name ) Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_doesnt_upgrade_installed_dependencies util_setup_gems a2 , a2_gem = util_gem <str> , <str> a3 , a3_gem = util_gem <str> , <str> util_setup_spec_fetcher @a1 , a3 , @b1 FileUtils . rm_rf File . join ( @gemhome , <str> ) Gem :: Specification . reset FileUtils . mv @a1_gem , @tempdir FileUtils . mv a2_gem , @tempdir FileUtils . mv @b1_gem , @tempdir FileUtils . mv a3_gem , @tempdir Dir . chdir @tempdir do Gem :: DependencyInstaller . new . install <str> , req ( <str> ) end FileUtils . rm File . join ( @tempdir , a2 . file_name ) inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dependency util_setup_gems done_installing_ran = false inst = nil Gem . done_installing do | installer , specs | done_installing_ran = true refute_nil installer assert_equal [ @a1 , @b1 ] , specs end FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new ( <str> = > false ) inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } assert done_installing_ran , <str> end def test_install_dependency_development util_setup_gems @aa1 , @aa1_gem = util_gem <str> , <str> util_reset_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @aa1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new ( <str> = > true ) inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dependency_development_deep util_setup_gems @aa1 , @aa1_gem = util_gem <str> , <str> util_reset_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @aa1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir FileUtils . mv @c1_gem , @tempdir FileUtils . mv @d1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new ( <str> = > true ) inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dependency_development_shallow util_setup_gems @aa1 , @aa1_gem = util_gem <str> , <str> util_reset_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @aa1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir FileUtils . mv @c1_gem , @tempdir FileUtils . mv @d1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new ( <str> = > true , <str> = > true ) inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dependency_existing util_setup_gems Gem :: Installer . at ( @a1_gem ) . install FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dependency_existing_extension extconf_rb = File . join @gemhome , <str> , <str> , <str> FileUtils . mkdir_p File . dirname extconf_rb open extconf_rb , <str> do | io | io . write <<- <str> EXTCONF_RB <str> <str> EXTCONF_RB end e1 = new_spec <str> , <str> , nil , <str> do | s | s . extensions << <str> end e1_gem = File . join @tempdir , <str> , <str> e1 . full_name <str> _ , f1_gem = util_gem <str> , <str> , <str> = > nil Gem :: Installer . at ( e1_gem ) . install FileUtils . rm_r e1 . extension_dir FileUtils . mv e1_gem , @tempdir FileUtils . mv f1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } assert_path_exists e1 . extension_dir end def test_install_dependency_old _ , e1_gem = util_gem <str> , <str> _ , f1_gem = util_gem <str> , <str> , <str> = > nil _ , f2_gem = util_gem <str> , <str> FileUtils . mv e1_gem , @tempdir FileUtils . mv f1_gem , @tempdir FileUtils . mv f2_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_local util_setup_gems FileUtils . mv @a1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_local_prerelease util_setup_gems FileUtils . mv @a1_pre_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_local_dependency util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_local_dependency_installed util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do Gem :: Installer . at ( <str> ) . install inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_local_subdir util_setup_gems inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_minimal_deps util_setup_gems _ , e1_gem = util_gem <str> , <str> do | s | s . add_dependency <str> end _ , b2_gem = util_gem <str> , <str> do | s | s . add_dependency <str> end util_clear_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir FileUtils . mv b2_gem , @tempdir FileUtils . mv e1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true inst . install <str> , req ( <str> ) end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } , <str> Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_no_document util_setup_gems done_installing_called = false Gem . done_installing do | dep_installer , specs | done_installing_called = true assert_empty dep_installer . document end inst = Gem :: DependencyInstaller . new <str> = > <str> , <str> = > [ ] inst . install @a1_gem assert done_installing_called end def test_install_env_shebang util_setup_gems FileUtils . mv @a1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true , <str> = > true , <str> = > false inst . install <str> end env = <str> unless Gem . win_platform? assert_match <str> env <str> RbConfig :: CONFIG [ <str> ] <str> , File . read ( File . join ( @gemhome , <str> , <str> ) ) end def test_install_force util_setup_gems FileUtils . mv @b1_gem , @tempdir si = util_setup_spec_fetcher @b1 @fetcher . data [ <str> ] = si . to_yaml inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_build_args util_setup_gems FileUtils . mv @a1_gem , @tempdir inst = nil build_args = <str> Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new ( <str> = > build_args ) inst . install <str> end assert_equal build_args . join ( <str> ) , File . read ( inst . installed_gems . first . build_info_file ) . strip end def test_install_ignore_dependencies util_setup_gems FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > true inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_install_dir util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = Gem :: Installer . at @a1 . file_name inst . install gemhome2 = File . join @tempdir , <str> Dir . mkdir gemhome2 inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > gemhome2 inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } assert File . exist? ( File . join ( gemhome2 , <str> , @a1 . spec_name ) ) assert File . exist? ( File . join ( gemhome2 , <str> , @a1 . file_name ) ) end def test_install_domain_both util_setup_gems a1_data = nil File . open @a1_gem , <str> do | fp | a1_data = fp . read end @fetcher . data [ <str> ] = a1_data FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } a1 , b1 = inst . installed_gems assert_equal a1 . spec_file , a1 . loaded_from assert_equal b1 . spec_file , b1 . loaded_from end def test_install_domain_both_no_network util_setup_gems @fetcher . data [ <str> @marshal_version <str> ] = proc do raise Gem :: RemoteFetcher :: FetchError end FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_domain_local util_setup_gems FileUtils . mv @b1_gem , @tempdir inst = nil Dir . chdir @tempdir do e = assert_raises Gem :: UnsatisfiableDependencyError do inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> end expected = <str> assert_equal expected , e . message end assert_equal [ ] , inst . installed_gems . map { | s | s . full_name } end def test_install_domain_remote util_setup_gems a1_data = nil File . open @a1_gem , <str> do | fp | a1_data = fp . read end @fetcher . data [ <str> ] = a1_data inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_dual_repository util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = nil gemhome2 = <str> @gemhome <str> Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new <str> = > gemhome2 inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } , <str> ENV [ <str> ] = @gemhome ENV [ <str> ] = [ @gemhome , gemhome2 ] . join File :: PATH_SEPARATOR Gem . clear_paths Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_reinstall util_setup_gems Gem :: Installer . at ( @a1_gem ) . install FileUtils . mv @a1_gem , @tempdir inst = nil Dir . chdir @tempdir do inst = Gem :: DependencyInstaller . new inst . install <str> end assert_equal <str> , Gem :: Specification . map ( & <str> ) assert_equal <str> , inst . installed_gems . map ( & <str> ) end def test_install_remote util_setup_gems a1_data = nil File . open @a1_gem , <str> do | fp | a1_data = fp . read end @fetcher . data [ <str> ] = a1_data inst = Gem :: DependencyInstaller . new Dir . chdir @tempdir do inst . install <str> end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_remote_dep util_setup_gems a1_data = nil File . open @a1_gem , <str> do | fp | a1_data = fp . read end @fetcher . data [ <str> ] = a1_data inst = Gem :: DependencyInstaller . new Dir . chdir @tempdir do dep = Gem :: Dependency . new @a1 . name , @a1 . version inst . install dep end assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_remote_platform_newer util_setup_gems a2_o , a2_o_gem = util_gem <str> , <str> do | s | s . platform = Gem :: Platform . new <str> end si = util_setup_spec_fetcher @a1 , a2_o util_clear_gems @fetcher . data [ <str> ] = si . to_yaml a1_data = nil a2_o_data = nil File . open @a1_gem , <str> do | fp | a1_data = fp . read end File . open a2_o_gem , <str> do | fp | a2_o_data = fp . read end @fetcher . data [ <str> @a1 . file_name <str> ] = a1_data @fetcher . data [ <str> a2_o . file_name <str> ] = a2_o_data inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install <str> assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_platform_is_ignored_when_a_file_is_specified _ , a_gem = util_gem <str> , <str> do | s | s . platform = Gem :: Platform . new <str> end inst = Gem :: DependencyInstaller . new <str> = > <str> inst . install a_gem assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end if defined? OpenSSL then def test_install_security_policy util_setup_gems data = File . open ( @a1_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data data = File . open ( @b1_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data policy = Gem :: Security :: HighSecurity inst = Gem :: DependencyInstaller . new <str> = > policy e = assert_raises Gem :: Security :: Exception do inst . install <str> end assert_equal <str> , e . message assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end end unless win_platform? then def test_install_no_wrappers util_setup_gems @fetcher . data [ <str> ] = read_binary ( @a1_gem ) inst = Gem :: DependencyInstaller . new <str> = > false , <str> = > false inst . install <str> refute_match ( <str> , File . read ( File . join ( @gemhome , <str> , <str> ) ) ) end end def test_install_version util_setup_d data = File . open ( @d2_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data data = File . open ( @d1_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data inst = Gem :: DependencyInstaller . new inst . install <str> , <str> assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_install_version_default util_setup_d data = File . open ( @d2_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data data = File . open ( @d1_gem , <str> ) { | f | f . read } @fetcher . data [ <str> ] = data inst = Gem :: DependencyInstaller . new inst . install <str> assert_equal <str> , inst . installed_gems . map { | s | s . full_name } end def test_find_gems_gems_with_sources util_setup_gems inst = Gem :: DependencyInstaller . new dep = Gem :: Dependency . new <str> , <str> Gem :: Specification . reset set = inst . find_gems_with_sources ( dep ) assert_kind_of Gem :: AvailableSet , set s = set . set . first assert_equal @b1 , s . spec assert_equal Gem :: Source . new ( @gem_repo ) , s . source end def test_find_spec_by_name_and_version_wildcard util_gem <str> , <int> FileUtils . mv <str> , @tempdir FileUtils . touch <str> inst = Gem :: DependencyInstaller . new available = inst . find_spec_by_name_and_version ( <str> ) assert_equal <str> , available . each_spec . map { | spec | spec . full_name } end def test_find_spec_by_name_and_version_wildcard_bad_gem FileUtils . touch <str> inst = Gem :: DependencyInstaller . new assert_raises Gem :: Package :: FormatError do inst . find_spec_by_name_and_version <str> end end def test_find_spec_by_name_and_version_bad_gem FileUtils . touch <str> inst = Gem :: DependencyInstaller . new e = assert_raises Gem :: Package :: FormatError do inst . find_spec_by_name_and_version <str> end full_path = File . join @tempdir , <str> assert_equal <str> full_path <str> , e . message end def test_find_spec_by_name_and_version_directory Dir . mkdir <str> inst = Gem :: DependencyInstaller . new e = assert_raises Gem :: SpecificGemNotFoundException do inst . find_spec_by_name_and_version <str> end assert_equal <str> + <str> , e . message end def test_find_spec_by_name_and_version_file FileUtils . touch <str> inst = Gem :: DependencyInstaller . new e = assert_raises Gem :: SpecificGemNotFoundException do inst . find_spec_by_name_and_version <str> end assert_equal <str> + <str> , e . message end def test_find_gems_with_sources_local util_setup_gems FileUtils . mv @a1_gem , @tempdir inst = Gem :: DependencyInstaller . new dep = Gem :: Dependency . new <str> , <str> set = nil Dir . chdir @tempdir do set = inst . find_gems_with_sources dep end gems = set . sorted assert_equal <int> , gems . length remote , local = gems assert_equal <str> , local . spec . full_name , <str> assert_equal File . join ( @tempdir , @a1 . file_name ) , local . source . download ( local . spec ) , <str> assert_equal <str> , remote . spec . full_name , <str> assert_equal Gem :: Source . new ( @gem_repo ) , remote . source , <str> end def test_find_gems_with_sources_prerelease util_setup_gems installer = Gem :: DependencyInstaller . new dependency = Gem :: Dependency . new ( <str> , Gem :: Requirement . default ) releases = installer . find_gems_with_sources ( dependency ) . all_specs assert releases . any? { | s | s . name == <str> and s . version . to_s == <str> } refute releases . any? { | s | s . name == <str> and s . version . to_s == <str> } dependency . prerelease = true prereleases = installer . find_gems_with_sources ( dependency ) . all_specs assert_equal [ @a1_pre , @a1 ] , prereleases end def test_find_gems_with_sources_with_best_only_and_platform util_setup_gems a1_x86_mingw32 , = util_gem <str> , <str> do | s | s . platform = <str> end util_setup_spec_fetcher @a1 , a1_x86_mingw32 Gem . platforms << Gem :: Platform . new ( <str> ) installer = Gem :: DependencyInstaller . new dependency = Gem :: Dependency . new ( <str> , Gem :: Requirement . default ) releases = installer . find_gems_with_sources ( dependency , true ) . all_specs assert_equal [ a1_x86_mingw32 ] , releases end def test_find_gems_with_sources_with_bad_source Gem . sources . replace [ <str> ] installer = Gem :: DependencyInstaller . new dep = Gem :: Dependency . new ( <str> ) out = installer . find_gems_with_sources ( dep ) assert out . empty? assert_kind_of Gem :: SourceFetchProblem , installer . errors . first end def test_resolve_dependencies util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = Gem :: DependencyInstaller . new request_set = inst . resolve_dependencies <str> , req ( <str> ) requests = request_set . sorted_requests . map { | req | req . full_name } assert_equal <str> , requests end def test_resolve_dependencies_ignore_dependencies util_setup_gems FileUtils . mv @a1_gem , @tempdir FileUtils . mv @b1_gem , @tempdir inst = Gem :: DependencyInstaller . new <str> = > true request_set = inst . resolve_dependencies <str> , req ( <str> ) requests = request_set . sorted_requests . map { | req | req . full_name } assert request_set . ignore_dependencies assert_equal <str> , requests end def test_resolve_dependencies_local util_setup_gems @a2 , @a2_gem = util_gem <str> , <str> FileUtils . mv @a1_gem , @tempdir FileUtils . mv @a2_gem , @tempdir inst = Gem :: DependencyInstaller . new request_set = inst . resolve_dependencies <str> , req ( <str> ) requests = request_set . sorted_requests . map { | req | req . full_name } assert_equal <str> , requests end def util_write_a1_bin write_file File . join ( <str> , <str> , <str> , <str> ) do | fp | fp . puts <str> end end def util_setup_c1_pre @c1_pre , @c1_pre_gem = util_spec <str> , <str> do | s | s . add_dependency <str> , <str> s . add_dependency <str> , <str> end util_reset_gems end def util_setup_d @d1 , @d1_gem = util_gem <str> , <str> @d2 , @d2_gem = util_gem <str> , <str> util_reset_gems end def util_setup_wxyz @x1_m , @x1_m_gem = util_spec <str> , <str> do | s | s . platform = Gem :: Platform . new <str> end @x1_o , @x1_o_gem = util_spec <str> , <str> do | s | s . platform = Gem :: Platform . new <str> end @w1 , @w1_gem = util_spec <str> , <str> , <str> = > nil @y1 , @y1_gem = util_spec <str> , <str> @y1_1_p , @y1_1_p_gem = util_spec <str> , <str> do | s | s . platform = Gem :: Platform . new <str> end @z1 , @z1_gem = util_spec <str> , <str> , <str> = > nil util_reset_gems end def util_reset_gems @a1 || = nil @b1 || = nil @a1_pre || = nil @c1_pre || = nil @d1 || = nil @d2 || = nil @w1 || = nil @x1_m || = nil @x1_o || = nil @y1 || = nil @y1_1_p || = nil @z1 || = nil util_setup_spec_fetcher ( * [ @a1 , @a1_pre , @b1 , @c1_pre , @d1 , @d2 , @x1_m , @x1_o , @w1 , @y1 , @y1_1_p , @z1 ] . compact ) util_clear_gems end end 
