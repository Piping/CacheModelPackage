msfbase = __FILE__ while File . symlink? ( msfbase ) msfbase = File . expand_path ( File . readlink ( msfbase ) , File . dirname ( msfbase ) ) end $: . unshift ( File . expand_path ( File . join ( File . dirname ( msfbase ) , <str> , <str> , <str> ) ) ) require <str> $: . unshift ( ENV [ <str> ] ) if ENV [ <str> ] require <str> require <str> require <str> ranks = Hash . new ranks [ <str> ] = <int> ranks [ <str> ] = <int> ranks [ <str> ] = <int> ranks [ <str> ] = <int> ranks [ <str> ] = <int> ranks [ <str> ] = <int> ranks [ <str> ] = <int> minrank = <int> maxrank = <int> sort = <int> filter = <str> filters = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] opts = Rex :: Parser :: Arguments . new ( <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ true , <str> filters . map <str> | f | f . capitalize <str> . join ( <str> ) <str> ] , ) opts . parse ( ARGV ) { | opt , idx , val | case opt when <str> puts <str> puts <str> puts opts . usage exit when <str> unless ranks . include? ( val ) puts <str> val <str> puts <str> exit end puts <str> val <str> maxrank = ranks [ val ] when <str> unless ranks . include? ( val ) puts <str> val <str> puts <str> exit end puts <str> val <str> minrank = ranks [ val ] when <str> puts <str> sort = <int> when <str> puts <str> sort = <int> when <str> unless filters . include? ( val . downcase ) puts <str> val <str> puts <str> filters . map <str> | f | f . capitalize <str> . join ( <str> ) <str> exit end puts <str> val <str> filter = val end } Indent = <str> framework_opts = { <str> = > true } if filter . downcase != <str> framework_opts [ <str> ] = [ filter . downcase ] end $framework = Msf :: Simple :: Framework . create ( framework_opts ) tbl = Rex :: Ui :: Text :: Table . new ( <str> = > <str> , <str> = > Indent . length , <str> = > [ <str> , <str> ] ) $framework . modules . each { | name , mod | x = mod . new modrank = x . rank if modrank > = minrank and modrank < = maxrank tbl << [ x . fullname , modrank ] end } if sort == <int> tbl . sort_rows ( <int> ) end if sort == <int> tbl . sort_rows ( <int> ) tbl . rows . reverse end puts tbl . to_s 
