require <str> module ActiveRecord module Associations class JoinDependency class JoinAssociation < JoinPart attr_reader <str> attr_accessor <str> def initialize ( reflection , children ) super ( reflection . klass , children ) @reflection = reflection @tables = nil end def match? ( other ) return true if self == other super && reflection == other . reflection end JoinInformation = Struct . new <str> , <str> def join_constraints ( foreign_table , foreign_klass , node , join_type , tables , scope_chain , chain ) joins = [ ] binds = [ ] tables = tables . reverse scope_chain_index = <int> scope_chain = scope_chain . reverse chain . reverse_each do | reflection | table = tables . shift klass = reflection . klass join_keys = reflection . join_keys ( klass ) key = join_keys . key foreign_key = join_keys . foreign_key constraint = build_constraint ( klass , table , key , foreign_table , foreign_key ) predicate_builder = PredicateBuilder . new ( TableMetadata . new ( klass , table ) ) scope_chain_items = scope_chain [ scope_chain_index ] . map do | item | if item . is_a? ( Relation ) item else ActiveRecord :: Relation . create ( klass , table , predicate_builder ) . instance_exec ( node , & item ) end end scope_chain_index += <int> klass_scope = if klass . current_scope klass . current_scope . clone else relation = ActiveRecord :: Relation . create ( klass , table , predicate_builder , ) klass . send ( <str> , relation ) end scope_chain_items . concat [ klass_scope ] . compact rel = scope_chain_items . inject ( scope_chain_items . shift ) do | left , right | left . merge right end if rel && ! rel . arel . constraints . empty? binds += rel . bound_attributes constraint = constraint . and rel . arel . constraints end if reflection . type value = foreign_klass . base_class . name column = klass . columns_hash [ reflection . type . to_s ] binds << Relation :: QueryAttribute . new ( column . name , value , klass . type_for_attribute ( column . name ) ) constraint = constraint . and klass . arel_attribute ( reflection . type , table ) . eq ( Arel :: Nodes :: BindParam . new ) end joins << table . create_join ( table , table . create_on ( constraint ) , join_type ) foreign_table , foreign_klass = table , klass end JoinInformation . new joins , binds end def build_constraint ( klass , table , key , foreign_table , foreign_key ) constraint = table [ key ] . eq ( foreign_table [ foreign_key ] ) if klass . finder_needs_type_condition? constraint = table . create_and ( [ constraint , klass . send ( <str> , table ) ] ) end constraint end def table tables . first end def aliased_table_name table . table_alias || table . name end end end end end 
