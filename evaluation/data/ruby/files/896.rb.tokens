require <str> require <str> module ActionController module HttpAuthentication module Basic extend self module ControllerMethods extend ActiveSupport :: Concern module ClassMethods def http_basic_authenticate_with ( options = { } ) before_action ( options . except ( <str> , <str> , <str> ) ) do authenticate_or_request_with_http_basic ( options [ <str> ] || <str> ) do | name , password | ActiveSupport :: SecurityUtils . variable_size_secure_compare ( name , options [ <str> ] ) & ActiveSupport :: SecurityUtils . variable_size_secure_compare ( password , options [ <str> ] ) end end end end def authenticate_or_request_with_http_basic ( realm = <str> , message = nil , & login_procedure ) authenticate_with_http_basic ( & login_procedure ) || request_http_basic_authentication ( realm , message ) end def authenticate_with_http_basic ( & login_procedure ) HttpAuthentication :: Basic . authenticate ( request , & login_procedure ) end def request_http_basic_authentication ( realm = <str> , message = nil ) HttpAuthentication :: Basic . authentication_request ( self , realm , message ) end end def authenticate ( request , & login_procedure ) if has_basic_credentials? ( request ) login_procedure . call ( * user_name_and_password ( request ) ) end end def has_basic_credentials? ( request ) request . authorization . present? && ( auth_scheme ( request ) . downcase == <str> ) end def user_name_and_password ( request ) decode_credentials ( request ) . split ( <str> , <int> ) end def decode_credentials ( request ) :: Base64 . decode64 ( auth_param ( request ) || <str> ) end def auth_scheme ( request ) request . authorization . to_s . split ( <str> , <int> ) . first end def auth_param ( request ) request . authorization . to_s . split ( <str> , <int> ) . second end def encode_credentials ( user_name , password ) <str> :: Base64 . strict_encode64 ( <str> user_name <str> password <str> ) <str> end def authentication_request ( controller , realm , message ) message || = <str> controller . headers [ <str> ] = <str> realm . tr ( <str> . freeze , <str> . freeze ) <str> controller . status = <int> controller . response_body = message end end module Digest extend self module ControllerMethods def authenticate_or_request_with_http_digest ( realm = <str> , message = nil , & password_procedure ) authenticate_with_http_digest ( realm , & password_procedure ) || request_http_digest_authentication ( realm , message ) end def authenticate_with_http_digest ( realm = <str> , & password_procedure ) HttpAuthentication :: Digest . authenticate ( request , realm , & password_procedure ) end def request_http_digest_authentication ( realm = <str> , message = nil ) HttpAuthentication :: Digest . authentication_request ( self , realm , message ) end end def authenticate ( request , realm , & password_procedure ) request . authorization && validate_digest_response ( request , realm , & password_procedure ) end def validate_digest_response ( request , realm , & password_procedure ) secret_key = secret_token ( request ) credentials = decode_credentials_header ( request ) valid_nonce = validate_nonce ( secret_key , request , credentials [ <str> ] ) if valid_nonce && realm == credentials [ <str> ] && opaque ( secret_key ) == credentials [ <str> ] password = password_procedure . call ( credentials [ <str> ] ) return false unless password method = request . get_header ( <str> ) || request . get_header ( <str> ) uri = credentials [ <str> ] [ true , false ] . any? do | trailing_question_mark | [ true , false ] . any? do | password_is_ha1 | _uri = trailing_question_mark ? uri + <str> : uri expected = expected_response ( method , _uri , credentials , password , password_is_ha1 ) expected == credentials [ <str> ] end end end end def expected_response ( http_method , uri , credentials , password , password_is_ha1 = true ) ha1 = password_is_ha1 ? password : ha1 ( credentials , password ) ha2 = :: Digest :: MD5 . hexdigest ( [ http_method . to_s . upcase , uri ] . join ( <str> ) ) :: Digest :: MD5 . hexdigest ( [ ha1 , credentials [ <str> ] , credentials [ <str> ] , credentials [ <str> ] , credentials [ <str> ] , ha2 ] . join ( <str> ) ) end def ha1 ( credentials , password ) :: Digest :: MD5 . hexdigest ( [ credentials [ <str> ] , credentials [ <str> ] , password ] . join ( <str> ) ) end def encode_credentials ( http_method , credentials , password , password_is_ha1 ) credentials [ <str> ] = expected_response ( http_method , credentials [ <str> ] , credentials , password , password_is_ha1 ) <str> + credentials . sort_by { | x | x [ <int> ] . to_s } . map { | v | <str> v [ <int> ] <str> v [ <int> ] <str> } . join ( <str> ) end def decode_credentials_header ( request ) decode_credentials ( request . authorization ) end def decode_credentials ( header ) ActiveSupport :: HashWithIndifferentAccess [ header . to_s . gsub ( <str> , <str> ) . split ( <str> ) . map do | pair | key , value = pair . split ( <str> , <int> ) [ key . strip , value . to_s . gsub ( <str> , <str> ) . delete ( <str> ) ] end ] end def authentication_header ( controller , realm ) secret_key = secret_token ( controller . request ) nonce = self . nonce ( secret_key ) opaque = opaque ( secret_key ) controller . headers [ <str> ] = <str> realm <str> nonce <str> opaque <str> end def authentication_request ( controller , realm , message = nil ) message || = <str> authentication_header ( controller , realm ) controller . status = <int> controller . response_body = message end def secret_token ( request ) key_generator = request . key_generator http_auth_salt = request . http_auth_salt key_generator . generate_key ( http_auth_salt ) end def nonce ( secret_key , time = Time . now ) t = time . to_i hashed = [ t , secret_key ] digest = :: Digest :: MD5 . hexdigest ( hashed . join ( <str> ) ) :: Base64 . strict_encode64 ( <str> t <str> digest <str> ) end def validate_nonce ( secret_key , request , value , seconds_to_timeout = <int> * <int> ) return false if value . nil? t = :: Base64 . decode64 ( value ) . split ( <str> ) . first . to_i nonce ( secret_key , t ) == value && ( t - Time . now . to_i ) . abs < = seconds_to_timeout end def opaque ( secret_key ) :: Digest :: MD5 . hexdigest ( secret_key ) end end module Token TOKEN_KEY = <str> TOKEN_REGEX = <str> AUTHN_PAIR_DELIMITERS = <str> extend self module ControllerMethods def authenticate_or_request_with_http_token ( realm = <str> , message = nil , & login_procedure ) authenticate_with_http_token ( & login_procedure ) || request_http_token_authentication ( realm , message ) end def authenticate_with_http_token ( & login_procedure ) Token . authenticate ( self , & login_procedure ) end def request_http_token_authentication ( realm = <str> , message = nil ) Token . authentication_request ( self , realm , message ) end end def authenticate ( controller , & login_procedure ) token , options = token_and_options ( controller . request ) unless token . blank? login_procedure . call ( token , options ) end end def token_and_options ( request ) authorization_request = request . authorization . to_s if authorization_request [ TOKEN_REGEX ] params = token_params_from authorization_request [ params . shift [ <int> ] , Hash [ params ] . with_indifferent_access ] end end def token_params_from ( auth ) rewrite_param_values params_array_from raw_params auth end def params_array_from ( raw_params ) raw_params . map { | param | param . split <str> } end def rewrite_param_values ( array_params ) array_params . each { | param | ( param [ <int> ] || <str> ) . gsub! <str> , <str> } end def raw_params ( auth ) _raw_params = auth . sub ( TOKEN_REGEX , <str> ) . split ( <str> AUTHN_PAIR_DELIMITERS <str> ) if ! ( _raw_params . first =~ <str> TOKEN_KEY <str> ) _raw_params [ <int> ] = <str> TOKEN_KEY <str> _raw_params . first <str> end _raw_params end def encode_credentials ( token , options = { } ) values = [ <str> TOKEN_KEY <str> token . to_s . inspect <str> ] + options . map do | key , value | <str> key <str> value . to_s . inspect <str> end <str> values * <str> end def authentication_request ( controller , realm , message = nil ) message || = <str> controller . headers [ <str> ] = <str> realm . tr ( <str> . freeze , <str> . freeze ) <str> controller . __send__ <str> , <str> : message , <str> : <str> end end end end 
