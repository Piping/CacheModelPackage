require <str> require <str> module FileUtils @fileutils_output = $stdout end def setup ( options = <str> , * long_options ) caller = caller_locations ( <int> , <int> ) [ <int> ] . label opt_hash = { } argv = [ ] OptionParser . new do | o | options . scan ( <str> ) do | s | opt_name = s . delete ( <str> ) . intern o . on ( <str> + s . tr ( <str> , <str> ) ) do | val | opt_hash [ opt_name ] = val end end long_options . each do | s | opt_name , arg_name = s . split ( <str> , <int> ) opt_name . sub! ( <str> , <str> ) s = <str> opt_name . gsub ( <str> , <str> ) . downcase <str> arg_name <str> puts <str> opt_name <str> s <str> if $DEBUG opt_name = opt_name . intern o . on ( s ) do | val | opt_hash [ opt_name ] = val end end o . on ( <str> ) do opt_hash [ <str> ] = true end o . on ( <str> ) do UN . help ( [ caller ] ) exit end o . order! ( ARGV ) do | x | if <str> =~ x argv . concat ( Dir [ x ] ) else argv << x end end end yield argv , opt_hash end def cp setup ( <str> ) do | argv , options | cmd = <str> cmd += <str> if options . delete <str> options [ <str> ] = true if options . delete <str> dest = argv . pop argv = argv [ <int> ] if argv . size == <int> FileUtils . send cmd , argv , dest , options end end def ln setup ( <str> ) do | argv , options | cmd = <str> cmd += <str> if options . delete <str> options [ <str> ] = true if options . delete <str> dest = argv . pop argv = argv [ <int> ] if argv . size == <int> FileUtils . send cmd , argv , dest , options end end def mv setup do | argv , options | dest = argv . pop argv = argv [ <int> ] if argv . size == <int> FileUtils . mv argv , dest , options end end def rm setup ( <str> ) do | argv , options | cmd = <str> cmd += <str> if options . delete <str> options [ <str> ] = true if options . delete <str> FileUtils . send cmd , argv , options end end def mkdir setup ( <str> ) do | argv , options | cmd = <str> cmd += <str> if options . delete <str> FileUtils . send cmd , argv , options end end def rmdir setup ( <str> ) do | argv , options | options [ <str> ] = true if options . delete <str> FileUtils . rmdir argv , options end end def install setup ( <str> ) do | argv , options | options [ <str> ] = ( mode = options . delete <str> ) ? mode . oct : <oct> options [ <str> ] = true if options . delete <str> dest = argv . pop argv = argv [ <int> ] if argv . size == <int> FileUtils . install argv , dest , options end end def chmod setup do | argv , options | mode = argv . shift . oct FileUtils . chmod mode , argv , options end end def touch setup do | argv , options | FileUtils . touch argv , options end end def wait_writable setup ( <str> ) do | argv , options | verbose = options [ <str> ] n = options [ <str> ] and n = Integer ( n ) wait = ( wait = options [ <str> ] ) ? Float ( wait ) : <int> . <int> argv . each do | file | begin open ( file , <str> ) rescue Errno :: ENOENT break rescue Errno :: EACCES = > e raise if n and ( n -= <int> ) < = <int> if verbose puts e STDOUT . flush end sleep wait retry end end end end def mkmf setup ( <str> , <str> ) do | argv , options | require <str> opt = options [ <str> ] and opt . split ( <str> ) . each { | n | dir_config ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_header ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_library ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_func ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_var ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_type ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_macro ( * n . split ( <str> ) ) } opt = options [ <str> ] and opt . split ( <str> ) . each { | n | have_const ( * n . split ( <str> ) ) } $configure_args [ <str> ] = true if options [ <str> ] create_makefile ( * argv ) end end def httpd setup ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) do | argv , options | require <str> opt = options [ <str> ] and options [ <str> ] = opt . to_i [ <str> , <str> ] . each do | name | opt = options [ name ] and ( options [ name ] = Integer ( opt ) ) rescue nil end options [ <str> ] || = <int> options [ <str> ] = argv . shift || <str> s = WEBrick :: HTTPServer . new ( options ) shut = proc { s . shutdown } siglist = <str> siglist . concat ( <str> ) if STDIN . tty? siglist & = Signal . list . keys siglist . each do | sig | Signal . trap ( sig , shut ) end s . start end end def help setup do | argv , | UN . help ( argv ) end end module UN module_function def help ( argv , <str> : $stdout ) all = argv . empty? cmd = nil if all store = proc { | msg | output << msg } else messages = { } store = proc { | msg | messages [ cmd ] = msg } end open ( __FILE__ ) do | me | while me . gets ( <str> ) if help = me . gets ( <str> ) if all or argv . include? ( cmd = help [ <str> , <int> ] ) store [ help . gsub ( <str> , <str> ) ] break unless all or argv . size > messages . size end end end end if messages argv . each { | arg | output << messages [ arg ] } end end end 
