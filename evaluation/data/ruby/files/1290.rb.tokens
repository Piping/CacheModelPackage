module Jekyll module Tags class IncludeTagError < StandardError attr_accessor <str> def initialize ( msg , path ) super ( msg ) @path = path end end class IncludeTag < Liquid :: Tag attr_reader <str> VALID_SYNTAX = <str> VARIABLE_SYNTAX = <str> def initialize ( tag_name , markup , tokens ) super matched = markup . strip . match ( VARIABLE_SYNTAX ) if matched @file = matched [ <str> ] . strip @params = matched [ <str> ] . strip else @file , @params = markup . strip . split ( <str> , <int> ) end validate_params if @params @tag_name = tag_name end def syntax_example <str> @tag_name <str> end def parse_params ( context ) params = { } markup = @params while match = VALID_SYNTAX . match ( markup ) do markup = markup [ match . end ( <int> ) .. - <int> ] value = if match [ <int> ] match [ <int> ] . gsub ( <str> , <str> ) elsif match [ <int> ] match [ <int> ] . gsub ( <str> , <str> ) elsif match [ <int> ] context [ match [ <int> ] ] end params [ match [ <int> ] ] = value end params end def validate_file_name ( file ) if file !~ <str> || file =~ <str> || file =~ <str> raise ArgumentError . new <<- <str> eos <str> <str> eos end end def validate_params full_valid_syntax = Regexp . compile ( <str> + VALID_SYNTAX . to_s + <str> ) unless @params =~ full_valid_syntax raise ArgumentError . new <<- <str> eos <str> <str> eos end end def file_read_opts ( context ) context . registers [ <str> ] . file_read_opts end def render_variable ( context ) if @file . match ( VARIABLE_SYNTAX ) partial = context . registers [ <str> ] . liquid_renderer . file ( <str> ) . parse ( @file ) partial . render! ( context ) end end def tag_includes_dir ( context ) context . registers [ <str> ] . config [ <str> ] . freeze end def render ( context ) site = context . registers [ <str> ] @includes_dir = tag_includes_dir ( context ) dir = resolved_includes_dir ( context ) file = render_variable ( context ) || @file validate_file_name ( file ) path = File . join ( dir , file ) validate_path ( path , dir , site . safe ) if context . registers [ <str> ] && context . registers [ <str> ] . key? ( <str> ) site . regenerator . add_dependency ( site . in_source_dir ( context . registers [ <str> ] [ <str> ] ) , path ) end begin partial = load_cached_partial ( path , context ) context . stack do context [ <str> ] = parse_params ( context ) if @params partial . render! ( context ) end rescue = > e raise IncludeTagError . new e . message , File . join ( @includes_dir , @file ) end end def load_cached_partial ( path , context ) context . registers [ <str> ] || = { } cached_partial = context . registers [ <str> ] if cached_partial . key? ( path ) cached_partial [ path ] else cached_partial [ path ] = context . registers [ <str> ] . liquid_renderer . file ( path ) . parse ( read_file ( path , context ) ) end end def resolved_includes_dir ( context ) context . registers [ <str> ] . in_source_dir ( @includes_dir ) end def validate_path ( path , dir , safe ) if safe && ! realpath_prefixed_with? ( path , dir ) raise IOError . new <str> path <str> elsif ! File . exist? ( path ) raise IOError . new <str> path_relative_to_source ( dir , path ) <str> end end def path_relative_to_source ( dir , path ) File . join ( @includes_dir , path . sub ( Regexp . new ( <str> dir <str> ) , <str> ) ) end def realpath_prefixed_with? ( path , dir ) File . exist? ( path ) && File . realpath ( path ) . start_with? ( dir ) end def read_file ( file , context ) File . read ( file , file_read_opts ( context ) ) end end class IncludeRelativeTag < IncludeTag def tag_includes_dir ( context ) <str> . freeze end def page_path ( context ) context . registers [ <str> ] . nil? ? includes_dir : File . dirname ( context . registers [ <str> ] [ <str> ] ) end def resolved_includes_dir ( context ) context . registers [ <str> ] . in_source_dir ( page_path ( context ) ) end end end end Liquid :: Template . register_tag ( <str> , Jekyll :: Tags :: IncludeTag ) Liquid :: Template . register_tag ( <str> , Jekyll :: Tags :: IncludeRelativeTag ) 
