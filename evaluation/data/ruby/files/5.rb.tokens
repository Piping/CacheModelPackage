module Msf::Post::Common def rhost return nil unless session case session . type when <str> session . sock . peerhost when <str> session . session_host end end def rport case session . type when <str> session . sock . peerport when <str> session . session_port end end def peer <str> rhost <str> rport <str> end def has_pid? ( pid ) pid_list = [ ] case client . type when <str> pid_list = client . sys . process . processes . collect { | e | e [ <str> ] } when <str> if client . platform =~ <str> o = cmd_exec ( <str> ) pid_list = o . scan ( <str> ) . flatten else o = cmd_exec ( <str> ) pid_list = o . scan ( <str> ) . flatten end pid_list = pid_list . collect { | e | e . to_i } end pid_list . include? ( pid ) end def get_target_arch arch = nil case session . type when <str> arch = get_recognizable_arch ( client . sys . config . sysinfo [ <str> ] ) when <str> if session . platform =~ <str> arch = get_recognizable_arch ( get_env ( <str> ) . strip ) else arch = get_recognizable_arch ( get_env ( <str> ) . strip ) end end arch end def get_target_os os = nil info = <str> case session . type when <str> info = client . sys . config . sysinfo [ <str> ] when <str> if session . platform =~ <str> info = get_env ( <str> ) . strip else info = cmd_exec ( <str> ) . strip end end case info when <str> os = Msf :: Module :: Platform :: Windows . realname . downcase when <str> os = Msf :: Module :: Platform :: OSX . realname . downcase when <str> os = Msf :: Module :: Platform :: FreeBSD . realname . downcase when <str> , <str> os = Msf :: Module :: Platform :: BSD . realname . downcase else os = Msf :: Module :: Platform :: Linux . realname . downcase end os end def cmd_exec ( cmd , args = nil , time_out = <int> ) case session . type when <str> start = Time . now . to_i if args . nil? and cmd =~ <str> args = <str> end session . response_timeout = time_out process = session . sys . process . execute ( cmd , args , { <str> = > true , <str> = > true } ) o = <str> while ( d = process . channel . read ) if d == <str> if ( Time . now . to_i - start < time_out ) && ( o == <str> ) sleep <int> . <int> else break end else o << d end end o . chomp! if o begin process . channel . close rescue IOError = > e end process . close when <str> if args . nil? || args . empty? o = session . shell_command ( <str> cmd <str> , time_out ) else o = session . shell_command ( <str> cmd <str> args <str> , time_out ) end o . chomp! if o when <str> if args . nil? || args . empty? o = session . shell_command_token ( <str> cmd <str> , time_out ) else o = session . shell_command_token ( <str> cmd <str> args <str> , time_out ) end o . chomp! if o end return <str> if o . nil? return o end def cmd_exec_get_pid ( cmd , args = nil , time_out = <int> ) case session . type when <str> if args . nil? and cmd =~ <str> args = <str> end session . response_timeout = time_out process = session . sys . process . execute ( cmd , args , { <str> = > true , <str> = > true } ) process . channel . close pid = process . pid process . close pid else print_error <str> end end def report_vm ( vm ) return unless session return unless vm vm_normal = vm . to_s . strip return if vm_normal . empty? vm_data = { <str> = > session . target_host , <str> = > vm_normal } report_host ( vm_data ) end def get_env ( env ) case session . type when <str> return session . sys . config . getenv ( env ) when <str> if session . platform =~ <str> if env [ <int> , <int> ] == <str> unless env [ - <int> , <int> ] == <str> env << <str> end else env = <str> env <str> end return cmd_exec ( <str> env <str> ) else unless env [ <int> , <int> ] == <str> env = <str> env <str> end return cmd_exec ( <str> env <str> ) end end nil end def get_envs ( * envs ) case session . type when <str> return session . sys . config . getenvs ( * envs ) when <str> result = { } envs . each do | env | res = get_env ( env ) result [ env ] = res unless res . blank? end return result end nil end private def get_recognizable_arch ( target_arch ) arch = nil case target_arch when <str> return ARCH_X86 when <str> return ARCH_X86_64 end recognizable_archs = ARCH_TYPES recognizable_archs = recognizable_archs . sort_by { | a | a . length } . reverse recognizable_archs . each do | a | if target_arch =~ <str> a <str> arch = a break end end arch end end 
