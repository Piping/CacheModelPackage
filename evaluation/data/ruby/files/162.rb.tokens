require File . expand_path ( <str> , __FILE__ ) require File . expand_path ( <str> , __FILE__ ) require File . expand_path ( <str> , __FILE__ ) describe <str> do it <str> do EnumerableSpecs :: Numerous . new ( <int> ) . minmax_by . should be_an_instance_of ( enumerator_class ) end it <str> do EnumerableSpecs :: Empty . new . minmax_by { | o | o . nonesuch } . should == [ nil , nil ] end it <str> do EnumerableSpecs :: Numerous . new ( * <str> ) . minmax_by { | obj | obj . to_i } . should == [ <str> , <str> ] EnumerableSpecs :: Numerous . new ( * <str> ) . minmax_by { | obj | obj . length } . should == [ <str> , <str> ] end it <str> do a , b , c , d = <str> , <str> , <str> , <str> mm = EnumerableSpecs :: Numerous . new ( a , b , c , d ) . minmax_by { | obj | obj . to_i } mm [ <int> ] . should equal ( a ) mm [ <int> ] . should equal ( c ) end it <str> do a , b , c = ( <int> .. <int> ) . map { | n | EnumerableSpecs :: ReverseComparable . new ( n ) } EnumerableSpecs :: Numerous . new ( a , b , c ) . minmax_by { | obj | obj } . should == [ c , a ] end it <str> do enum = EnumerableSpecs :: Numerous . new ( nil , nil , true ) enum . minmax_by { | o | o . nil? ? <int> : <int> } . should == [ nil , true ] end it <str> do multi = EnumerableSpecs :: YieldsMulti . new multi . minmax_by { | e | e . size } . should == [ [ <int> , <int> ] , [ <int> , <int> , <int> , <int> ] ] end it_behaves_like <str> , <str> end 
