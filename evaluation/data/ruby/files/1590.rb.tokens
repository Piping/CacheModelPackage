require <str> require <str> class Deprecatee def initialize @request = ActiveSupport :: Deprecation :: DeprecatedInstanceVariableProxy . new ( self , <str> ) @_request = <str> end def request ; @_request end def old_request ; @request end def partially ( foo = nil ) ActiveSupport :: Deprecation . warn ( <str> ) if foo . nil? end def not ( ) <int> end def none ( ) <int> end def one ( a ) a end def multi ( a , b , c ) [ a , b , c ] end deprecate <str> , <str> , <str> def a ; end def b ; end def c ; end def d ; end def e ; end deprecate <str> , <str> , <str> = > <str> , <str> = > <str> def f = ( v ) ; end deprecate <str> = module B C = <int> end A = ActiveSupport :: Deprecation :: DeprecatedConstantProxy . new ( <str> , <str> ) end class DeprecationTest < ActiveSupport :: TestCase include ActiveSupport :: Testing :: Stream def setup @old_behavior = ActiveSupport :: Deprecation . behavior @last_message = nil ActiveSupport :: Deprecation . behavior = Proc . new { | message | @last_message = message } @dtc = Deprecatee . new end def teardown ActiveSupport :: Deprecation . behavior = @old_behavior end def test_inline_deprecation_warning assert_deprecated ( <str> ) do @dtc . partially end end def test_undeprecated assert_not_deprecated do assert_equal <int> , @dtc . not end end def test_deprecate_class_method assert_deprecated ( <str> ) do assert_equal <int> , @dtc . none end assert_deprecated ( <str> ) do assert_equal <int> , @dtc . one ( <int> ) end assert_deprecated ( <str> ) do assert_equal [ <int> , <int> , <int> ] , @dtc . multi ( <int> , <int> , <int> ) end end def test_deprecate_object deprecated_object = ActiveSupport :: Deprecation :: DeprecatedObjectProxy . new ( Object . new , <str> ) assert_deprecated ( <str> ) { deprecated_object . to_s } end def test_nil_behavior_is_ignored ActiveSupport :: Deprecation . behavior = nil assert_deprecated ( <str> ) { @dtc . partially } end def test_several_behaviors @a , @b = nil , nil ActiveSupport :: Deprecation . behavior = [ Proc . new { | msg , callstack | @a = msg } , Proc . new { | msg , callstack | @b = msg } ] @dtc . partially assert_match ( <str> , @a ) assert_match ( <str> , @b ) end def test_raise_behaviour ActiveSupport :: Deprecation . behavior = <str> message = <str> callstack = caller_locations e = assert_raise ActiveSupport :: DeprecationException do ActiveSupport :: Deprecation . behavior . first . call ( message , callstack ) end assert_equal message , e . message assert_equal callstack . map ( & <str> ) , e . backtrace . map ( & <str> ) end def test_default_stderr_behavior ActiveSupport :: Deprecation . behavior = <str> behavior = ActiveSupport :: Deprecation . behavior . first content = capture ( <str> ) { assert_nil behavior . call ( <str> , [ <str> ] ) } assert_match ( <str> , content ) assert_match ( <str> , content ) end def test_default_stderr_behavior_with_warn_method ActiveSupport :: Deprecation . behavior = <str> content = capture ( <str> ) { ActiveSupport :: Deprecation . warn ( <str> , [ <str> ] ) } assert_match ( <str> , content ) assert_match ( <str> , content ) end def test_default_silence_behavior ActiveSupport :: Deprecation . behavior = <str> behavior = ActiveSupport :: Deprecation . behavior . first stderr_output = capture ( <str> ) { assert_nil behavior . call ( <str> , [ <str> ] ) } assert stderr_output . blank? end def test_deprecated_instance_variable_proxy assert_not_deprecated { @dtc . request . size } assert_deprecated ( <str> ) { assert_equal @dtc . request . size , @dtc . old_request . size } assert_deprecated ( <str> ) { assert_equal @dtc . request . to_s , @dtc . old_request . to_s } end def test_deprecated_instance_variable_proxy_shouldnt_warn_on_inspect assert_not_deprecated { assert_equal @dtc . request . inspect , @dtc . old_request . inspect } end def test_deprecated_constant_proxy assert_not_deprecated { Deprecatee :: B :: C } assert_deprecated ( <str> ) { assert_equal Deprecatee :: B :: C , Deprecatee :: A } assert_not_deprecated { assert_equal Deprecatee :: B :: C . class , Deprecatee :: A . class } end def test_assert_deprecated_raises_when_method_not_deprecated assert_raises ( Minitest :: Assertion ) { assert_deprecated { @dtc . not } } end def test_assert_not_deprecated assert_raises ( Minitest :: Assertion ) { assert_not_deprecated { @dtc . partially } } end def test_assert_deprecation_without_match assert_deprecated do @dtc . partially end end def test_assert_deprecated_matches_any_warning assert_deprecated <str> do ActiveSupport :: Deprecation . warn <str> ActiveSupport :: Deprecation . warn <str> end rescue Minitest :: Assertion flunk <str> end def test_assert_not_deprecated_returns_result_of_block assert_equal <int> , assert_not_deprecated { <int> } end def test_assert_deprecated_returns_result_of_block result = assert_deprecated ( <str> ) do ActiveSupport :: Deprecation . warn <str> <int> end assert_equal <int> , result end def test_assert_deprecated_warn_work_with_default_behavior ActiveSupport :: Deprecation . instance_variable_set ( <str> , nil ) assert_deprecated ( <str> ) do ActiveSupport :: Deprecation . warn <str> end end def test_silence ActiveSupport :: Deprecation . silence do assert_not_deprecated { @dtc . partially } end ActiveSupport :: Deprecation . silenced = true assert_not_deprecated { @dtc . partially } ActiveSupport :: Deprecation . silenced = false end def test_deprecation_without_explanation assert_deprecated { @dtc . a } assert_deprecated { @dtc . b } assert_deprecated { @dtc . f = <str> } end def test_deprecation_with_alternate_method assert_deprecated ( <str> ) { @dtc . c } end def test_deprecation_with_explicit_message assert_deprecated ( <str> ) { @dtc . d } end def test_deprecation_in_other_object messages = [ ] klass = Class . new do delegate <str> , <str> = , <str> : ActiveSupport :: Deprecation end o = klass . new o . behavior = Proc . new { | message , callstack | messages << message } assert_difference ( <str> ) do o . warn ( <str> ) end end def test_deprecated_method_with_custom_method_warning deprecator = deprecator_with_messages class << deprecator private def deprecated_method_warning ( method , message ) <str> method <str> end end deprecatee = Class . new do def method end deprecate <str> , <str> : deprecator end deprecatee . new . method assert deprecator . messages . first . match ( <str> ) end def test_deprecate_with_custom_deprecator custom_deprecator = Struct . new ( <str> ) . new assert_called_with ( custom_deprecator , <str> , [ <str> , nil ] ) do klass = Class . new do def method end deprecate <str> , <str> : custom_deprecator end klass . new . method end end def test_deprecated_constant_with_deprecator_given deprecator = deprecator_with_messages klass = Class . new klass . const_set ( <str> , ActiveSupport :: Deprecation :: DeprecatedConstantProxy . new ( <str> , <str> , deprecator ) ) assert_difference ( <str> ) do klass :: OLD . to_s end end def test_deprecated_instance_variable_with_instance_deprecator deprecator = deprecator_with_messages klass = Class . new ( ) do def initialize ( deprecator ) @request = ActiveSupport :: Deprecation :: DeprecatedInstanceVariableProxy . new ( self , <str> , <str> , deprecator ) @_request = <str> end def request ; @_request end def old_request ; @request end end assert_difference ( <str> ) { klass . new ( deprecator ) . old_request . to_s } end def test_deprecated_instance_variable_with_given_deprecator deprecator = deprecator_with_messages klass = Class . new do define_method ( <str> ) do @request = ActiveSupport :: Deprecation :: DeprecatedInstanceVariableProxy . new ( self , <str> , <str> , deprecator ) @_request = <str> end def request ; @_request end def old_request ; @request end end assert_difference ( <str> ) { klass . new . old_request . to_s } end def test_delegate_deprecator_instance klass = Class . new do attr_reader <str> delegate <str> , <str> = , <str> : ActiveSupport :: Deprecation def initialize self . behavior = [ Proc . new { | message | @last_message = message } ] end def deprecated_method warn ( deprecated_method_warning ( <str> , <str> ) ) end private def deprecated_method_warning ( method_name , message = nil ) message || <str> method_name <str> end end object = klass . new object . deprecated_method assert_match ( <str> , object . last_message ) end def test_default_deprecation_horizon_should_always_bigger_than_current_rails_version assert ActiveSupport :: Deprecation . new . deprecation_horizon > ActiveSupport :: VERSION :: STRING end def test_default_gem_name deprecator = ActiveSupport :: Deprecation . new deprecator . send ( <str> , <str> , <str> ) . tap do | message | assert_match ( <str> , message ) end end def test_custom_gem_name deprecator = ActiveSupport :: Deprecation . new ( <str> , <str> ) deprecator . send ( <str> , <str> , <str> ) . tap do | message | assert_match ( <str> , message ) end end private def deprecator_with_messages klass = Class . new ( ActiveSupport :: Deprecation ) deprecator = klass . new deprecator . behavior = Proc . new { | message , callstack | deprecator . messages << message } def deprecator . messages @messages || = [ ] end deprecator end end 
