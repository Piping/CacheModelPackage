require <str> module Rex module ElfScan module Scanner class Generic attr_accessor <str> , <str> def initialize ( elf ) self . elf = elf end def config ( param ) end def scan ( param ) config ( param ) $stdout . puts <str> param [ <str> ] <str> elf . program_header . each do | program_header | if program_header . p_type == Rex :: ElfParsey :: ElfBase :: PT_LOAD hits = scan_segment ( program_header , param ) hits . each do | hit | rva = hit [ <int> ] message = hit [ <int> ] . is_a? ( Array ) ? hit [ <int> ] . join ( <str> ) : hit [ <int> ] $stdout . puts elf . ptr_s ( rva ) + <str> + message if ( param [ <str> ] ) message . gsub! ( <str> , <str> ) if message . include? ( <str> ) message . gsub! ( <str> , <str> ) end begin d2 = Metasm :: Shellcode . assemble ( Metasm :: Ia32 . new , message ) . disassemble rescue Metasm :: ParseError d2 = Metasm :: Shellcode . disassemble ( Metasm :: Ia32 . new , [ message ] . pack ( <str> ) ) end addr = <int> while ( ( di = d2 . disassemble_instruction ( addr ) ) ) disasm = <str> % ( rva + addr ) disasm << di . instruction . to_s $stdout . puts disasm addr = di . next_addr end end end end end end def scan_segment ( program_header , param = { } ) [ ] end end class JmpRegScanner < Generic def config ( param ) regnums = param [ <str> ] calls = _build_byte_list ( <hex> , regnums - [ <int> ] ) jmps = _build_byte_list ( <hex> , regnums ) pushs1 = _build_byte_list ( <hex> , regnums ) pushs2 = _build_byte_list ( <hex> , regnums ) regexstr = <str> if ! calls . empty? regexstr += <str> calls <str> end regexstr += <str> jmps <str> pushs1 <str> pushs2 <str> self . regex = Regexp . new ( regexstr , nil , <str> ) end def _build_byte_list ( base , regnums ) regnums . collect { | regnum | Regexp . escape ( ( base | regnum ) . chr ) } . join ( <str> ) end def _ret_size ( offset ) case elf . read ( offset , <int> ) when <str> return <int> when <str> return <int> end raise <str> offset <str> end def _parse_ret ( data ) if data . length == <int> return <str> else return <str> % data [ <int> , <int> ] . unpack ( <str> ) [ <int> ] end end def scan_segment ( program_header , param = { } ) offset = program_header . p_offset hits = [ ] while ( offset = elf . index ( regex , offset ) ) != nil rva = elf . offset_to_rva ( offset ) message = <str> parse_ret = false byte1 = elf . read ( offset , <int> ) . unpack ( <str> ) [ <int> ] if byte1 == <hex> byte2 = elf . read ( offset + <int> , <int> ) . unpack ( <str> ) [ <int> ] regname = Rex :: Arch :: X86 . reg_name32 ( byte2 & <hex> ) case byte2 & <hex> when <hex> message = <str> regname <str> offset += <int> when <hex> message = <str> regname <str> offset += <int> when <hex> retsize = _ret_size ( offset + <int> ) message = <str> regname <str> + _parse_ret ( elf . read ( offset + <int> , retsize ) ) offset += <int> + retsize else raise <str> offset <str> end else regname = Rex :: Arch :: X86 . reg_name32 ( byte1 & <hex> ) retsize = _ret_size ( offset + <int> ) message = <str> regname <str> + _parse_ret ( elf . read ( offset + <int> , retsize ) ) offset += <int> + retsize end hits << [ rva , message ] end return hits end end class PopPopRetScanner < JmpRegScanner def config ( param ) pops = _build_byte_list ( <hex> , ( <int> .. <int> ) . to_a - [ <int> ] ) self . regex = Regexp . new ( <str> pops <str> pops <str> , nil , <str> ) end def scan_segment ( program_header , param = { } ) offset = program_header . p_offset hits = [ ] while offset < program_header . p_offset + program_header . p_filesz && ( offset = elf . index ( regex , offset ) ) != nil rva = elf . offset_to_rva ( offset ) message = <str> pops = elf . read ( offset , <int> ) reg1 = Rex :: Arch :: X86 . reg_name32 ( pops [ <int> , <int> ] . unpack ( <str> ) [ <int> ] & <hex> ) reg2 = Rex :: Arch :: X86 . reg_name32 ( pops [ <int> , <int> ] . unpack ( <str> ) [ <int> ] & <hex> ) message = <str> reg1 <str> reg2 <str> retsize = _ret_size ( offset + <int> ) message += _parse_ret ( elf . read ( offset + <int> , retsize ) ) offset += <int> + retsize hits << [ rva , message ] end return hits end end class RegexScanner < JmpRegScanner def config ( param ) self . regex = Regexp . new ( param [ <str> ] , nil , <str> ) end def scan_segment ( program_header , param = { } ) offset = program_header . p_offset hits = [ ] while offset < program_header . p_offset + program_header . p_filesz && ( offset = elf . index ( regex , offset ) ) != nil idx = offset buf = <str> mat = nil while ( ! ( mat = buf . match ( regex ) ) ) buf << elf . read ( idx , <int> ) idx += <int> end rva = elf . offset_to_rva ( offset ) hits << [ rva , buf . unpack ( <str> ) ] offset += buf . length end return hits end end end end end 
