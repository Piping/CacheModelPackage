module Scheduler class ScheduleInfo attr_accessor <str> , <str> , <str> , <str> , <str> def initialize ( klass , manager ) @klass = klass @manager = manager data = nil if data = $redis . get ( key ) data = JSON . parse ( data ) end if data @next_run = data [ <str> ] @prev_run = data [ <str> ] @prev_result = data [ <str> ] @prev_duration = data [ <str> ] @current_owner = data [ <str> ] end rescue @next_run = @prev_run = @prev_result = @prev_duration = @current_owner = nil end def valid? return false unless @next_run ( ! @prev_run && @next_run < Time . now . to_i + <int> . minutes ) || valid_every? || valid_daily? end def valid_every? return false unless @klass . every ! ! @prev_run && @prev_run < = Time . now . to_i && @next_run < @prev_run + @klass . every * ( <int> + @manager . random_ratio ) end def valid_daily? return false unless @klass . daily ! ! @prev_run && @prev_run < = Time . now . to_i && @next_run < @prev_run + <int> . day end def schedule_every! if ! valid? && @prev_run mixup = @klass . every * @manager . random_ratio mixup = ( mixup * Random . rand - mixup / <int> ) . to_i @next_run = @prev_run + mixup + @klass . every end if ! valid? @next_run = Time . now . to_i + <int> . minutes * Random . rand end end def schedule_daily! return if valid? at = @klass . daily [ <str> ] || <int> today_begin = Time . now . midnight . to_i today_offset = DateTime . now . seconds_since_midnight if at > today_offset @next_run = today_begin + at else @next_run = today_begin + <int> . day + at end end def schedule! if @klass . every schedule_every! elsif @klass . daily schedule_daily! end write! end def write! clear! redis . set key , { <str> : @next_run , <str> : @prev_run , <str> : @prev_duration , <str> : @prev_result , <str> : @current_owner } . to_json redis . zadd queue_key , @next_run , @klass end def del! clear! @next_run = @prev_run = @prev_result = @prev_duration = @current_owner = nil end def key if @klass . is_per_host Manager . schedule_key ( @klass , @manager . hostname ) else Manager . schedule_key ( @klass ) end end def queue_key if @klass . is_per_host Manager . queue_key ( @manager . hostname ) else Manager . queue_key end end def redis @manager . redis end private def clear! redis . del key redis . zrem queue_key , @klass end end end 
