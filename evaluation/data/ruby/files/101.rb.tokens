require <str> require <str> module ActiveRecord class TestCase < ActiveSupport :: TestCase include ActiveSupport :: Testing :: Stream def teardown SQLCounter . clear_log end def assert_date_from_db ( expected , actual , message = nil ) assert_equal expected . to_s , actual . to_s , message end def capture_sql SQLCounter . clear_log yield SQLCounter . log_all . dup end def assert_sql ( * patterns_to_match ) capture_sql { yield } ensure failed_patterns = [ ] patterns_to_match . each do | pattern | failed_patterns << pattern unless SQLCounter . log_all . any? { | sql | pattern === sql } end assert failed_patterns . empty? , <str> failed_patterns . map ( & <str> ) . join ( <str> ) <str> SQLCounter . log . size == <int> ? <str> : <str> SQLCounter . log . join ( <str> ) <str> end def assert_queries ( num = <int> , options = { } ) ignore_none = options . fetch ( <str> ) { num == <str> } SQLCounter . clear_log x = yield the_log = ignore_none ? SQLCounter . log_all : SQLCounter . log if num == <str> assert_operator the_log . size , <str> , <int> , <str> else mesg = <str> the_log . size <str> num <str> the_log . size == <int> ? <str> : <str> the_log . join ( <str> ) <str> assert_equal num , the_log . size , mesg end x end def assert_no_queries ( options = { } , & block ) options . reverse_merge! <str> : true assert_queries ( <int> , options , & block ) end def assert_column ( model , column_name , msg = nil ) assert has_column? ( model , column_name ) , msg end def assert_no_column ( model , column_name , msg = nil ) assert_not has_column? ( model , column_name ) , msg end def has_column? ( model , column_name ) model . reset_column_information model . column_names . include? ( column_name . to_s ) end end class PostgreSQLTestCase < TestCase def self . run ( * args ) super if current_adapter? ( <str> ) end end class Mysql2TestCase < TestCase def self . run ( * args ) super if current_adapter? ( <str> ) end end class SQLite3TestCase < TestCase def self . run ( * args ) super if current_adapter? ( <str> ) end end class SQLCounter class << self attr_accessor <str> , <str> , <str> def clear_log ; self . log = [ ] ; self . log_all = [ ] ; end end self . clear_log self . ignored_sql = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] oracle_ignored = [ <str> , <str> , <str> , <str> , <str> , <str> ] mysql_ignored = [ <str> , <str> , <str> , <str> , <str> ] postgresql_ignored = [ <str> , <str> , <str> , <str> ] sqlite3_ignored = [ <str> , <str> ] [ oracle_ignored , mysql_ignored , postgresql_ignored , sqlite3_ignored ] . each do | db_ignored_sql | ignored_sql . concat db_ignored_sql end attr_reader <str> def initialize ( ignore = Regexp . union ( self . class . ignored_sql ) ) @ignore = ignore end def call ( name , start , finish , message_id , values ) sql = values [ <str> ] return if <str> == values [ <str> ] self . class . log_all << sql self . class . log << sql unless ignore =~ sql end end ActiveSupport :: Notifications . subscribe ( <str> , SQLCounter . new ) end 
