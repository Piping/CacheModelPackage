module Msf module Ui module Console module CommandDispatcher class Post include Msf :: Ui :: Console :: ModuleCommandDispatcher @@post_opts = Rex :: Parser :: Arguments . new ( <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] ) def commands super . update ( { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , } ) . merge ( ( mod ? mod . post_commands : { } ) ) end def method_missing ( meth , * args ) if ( mod and mod . respond_to? ( meth . to_s ) ) mod . init_ui ( driver . input , driver . output ) return mod . send ( meth . to_s , * args ) end return end def name <str> end def cmd_rexploit ( * args ) cmd_rerun ( * args ) end def cmd_rerun ( * args ) if reload ( true ) cmd_run ( * args ) end end alias cmd_rexploit cmd_rerun def cmd_run ( * args ) defanged? opt_str = nil jobify = false quiet = false @@post_opts . parse ( args ) { | opt , idx , val | case opt when <str> jobify = true when <str> opt_str = val when <str> action = val when <str> quiet = true when <str> print ( <str> + <str> + @@post_opts . usage ) return false end } if ( mod . passive ) jobify = true end begin mod . run_simple ( <str> = > opt_str , <str> = > driver . input , <str> = > driver . output , <str> = > jobify , <str> = > quiet ) rescue :: Timeout :: Error print_error ( <str> ) rescue :: Interrupt print_error ( <str> ) rescue :: Exception = > e print_error ( <str> e . class <str> e <str> ) if ( e . class . to_s != <str> ) print_error ( <str> ) e . backtrace . each do | line | break if line =~ <str> print_error ( <str> line <str> ) end end return false end if ( jobify ) print_status ( <str> ) else print_status ( <str> ) end end alias cmd_exploit cmd_run def cmd_run_help print_line <str> print_line print_line <str> print @@auxiliary_opts . usage end alias cmd_exploit_help cmd_run_help end end end end end 
