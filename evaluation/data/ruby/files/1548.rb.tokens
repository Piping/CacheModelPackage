require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Auxiliary :: Report include Msf :: Auxiliary :: UDPScanner include Msf :: Auxiliary :: DRDoS def initialize super ( <str> = > <str> , <str> = > <str> , <str> = > [ <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] ] , ) register_options ( [ Opt :: RPORT ( <int> ) , ] , self . class ) end def rport datastore [ <str> ] end def xid_summary @xid_summary || = [ Rex :: Text :: rand_text_numeric ( <int> ) . to_i ] . pack ( <str> ) end def xid_dump @xid_dump || = [ Rex :: Text :: rand_text_numeric ( <int> ) . to_i ] . pack ( <str> ) end def xid_metrics @xid_metrics || = [ Rex :: Text :: rand_text_numeric ( <int> ) . to_i ] . pack ( <str> ) end def setup super @portmap_summary = <str> @portmap_summary << xid_summary @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_summary << <str> @portmap_dump = <str> @portmap_dump << xid_dump @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_dump << <str> @portmap_metrics = <str> @portmap_metrics << xid_metrics @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> @portmap_metrics << <str> end def scanner_prescan ( batch ) print_status ( <str> batch [ <int> ] <str> batch [ - <int> ] <str> batch . length <str> ) @results_summary = { } @results_dump = { } @results_metrics = { } end def scan_host ( ip ) if spoofed? datastore [ <str> ] = <int> scanner_spoof_send ( @portmap_summary , ip , rport , datastore [ <str> ] , datastore [ <str> ] ) scanner_spoof_send ( @portmap_dump , ip , rport , datastore [ <str> ] , datastore [ <str> ] ) scanner_spoof_send ( @portmap_metrics , ip , rport , datastore [ <str> ] , datastore [ <str> ] ) else scanner_send ( @portmap_summary , ip , rport ) scanner_send ( @portmap_dump , ip , rport ) scanner_send ( @portmap_metrics , ip , rport ) end end def scanner_process ( data , shost , sport ) if data =~ <str> @xid_summary <str> @results_summary [ shost ] || = [ ] @results_summary [ shost ] << data elsif data =~ <str> @xid_metrics <str> @results_metrics [ shost ] || = [ ] @results_metrics [ shost ] << data elsif data =~ <str> @xid_dump <str> @results_dump [ shost ] || = [ ] @results_dump [ shost ] << data else vprint_error ( <str> data . size <str> shost <str> sport <str> ) end end def scanner_postscan ( batch ) @results_summary . keys . each do | k | response_map_summary = { @portmap_summary = > @results_summary [ k ] } what = <str> report_result ( k , what , response_map_summary ) end @results_dump . keys . each do | k | response_map_dump = { @portmap_dump = > @results_dump [ k ] } what = <str> report_result ( k , what , response_map_dump ) end @results_metrics . keys . each do | k | response_map_metrics = { @portmap_summary = > @results_metrics [ k ] } what = <str> report_result ( k , what , response_map_metrics ) end end def report_result ( host , attack , map ) report_service ( <str> : host , <str> : <str> , <str> : rport , name : <str> ) peer = <str> host <str> rport <str> vulnerable , proof = prove_amplification ( map ) if vulnerable print_good ( <str> peer <str> attack <str> proof <str> ) report_vuln ( <str> : host , <str> : rport , <str> : <str> , name : attack , <str> : references ) else vprint_status ( <str> peer <str> attack <str> proof <str> ) end end end 
