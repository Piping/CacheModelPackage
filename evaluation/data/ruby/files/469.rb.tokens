require <str> require_dependency <str> describe User do it { is_expected . to validate_presence_of <str> } it { is_expected . to validate_presence_of <str> } describe <str> do before ( <str> ) do User . destroy_all Timecop . freeze Fabricate ( <str> ) Fabricate ( <str> , <str> : <int> . day . ago ) Fabricate ( <str> , <str> : <int> . day . ago ) Fabricate ( <str> , <str> : <int> . days . ago ) Fabricate ( <str> , <str> : <int> . days . ago ) end after ( <str> ) { Timecop . return } let ( <str> ) { { <int> . day . ago . to_date = > <int> , <int> . days . ago . to_date = > <int> , Time . now . utc . to_date = > <int> } } it <str> do expect ( User . count_by_signup_date ( <int> . days . ago , Time . now ) ) . to include ( signups_by_day ) expect ( User . count_by_signup_date ( <int> . days . ago , Time . now ) ) . not_to include ( { <int> . days . ago . to_date = > <int> } ) end end context <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do Jobs . expects ( <str> ) . with ( <str> , <str> : user . id , <str> : <str> ) user . enqueue_welcome_message ( <str> ) end it <str> do SiteSetting . expects ( <str> ) . returns ( false ) Jobs . expects ( <str> ) . with ( <str> , <str> : user . id , <str> : <str> ) . never user . enqueue_welcome_message ( <str> ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } it <str> do SiteSetting . stubs ( <str> ) . returns ( true ) Jobs . expects ( <str> ) . with ( <str> , has_entries ( <str> : <str> ) ) user . approve ( admin ) end it <str> do SiteSetting . stubs ( <str> ) . returns ( false ) Jobs . expects ( <str> ) . never user . approve ( admin ) end context <str> do before do user . approve ( admin ) end it <str> do expect ( user ) . to be_approved end it <str> do expect ( user . approved_by ) . to eq ( admin ) end it <str> do expect ( user . approved_at ) . to be_present end end end describe <str> do before do @post = Fabricate ( <str> ) end it <str> do expect { PostAction . act ( @post . user , @post , PostActionType . types [ <str> ] ) } . to change ( PostAction , <str> ) . by ( <int> ) end describe <str> do before do PostAction . act ( @post . user , @post , PostActionType . types [ <str> ] ) end it <str> do active = PostAction . where ( <str> : nil ) expect { PostAction . remove_act ( @post . user , @post , PostActionType . types [ <str> ] ) } . to change ( active , <str> ) . by ( - <int> ) end end end describe <str> do before do @post1 = Fabricate ( <str> ) @user = @post1 . user @post2 = Fabricate ( <str> , <str> : @post1 . topic , <str> : @user ) @post3 = Fabricate ( <str> , <str> : @user ) @posts = [ @post1 , @post2 , @post3 ] @guardian = Guardian . new ( Fabricate ( <str> ) ) @queued_post = Fabricate ( <str> , <str> : @user ) end it <str> do @user . delete_all_posts! ( @guardian ) expect ( Post . where ( id : @posts . map ( & <str> ) ) ) . to be_empty expect ( QueuedPost . where ( <str> : @user . id ) . count ) . to eq ( <int> ) @posts . each do | p | if p . is_first_post? expect ( Topic . find_by ( id : p . topic_id ) ) . to be_nil end end end it <str> do invalid_guardian = Guardian . new ( Fabricate ( <str> ) ) expect do @user . delete_all_posts! ( invalid_guardian ) end . to raise_error Discourse :: InvalidAccess @posts . each do | p | p . reload expect ( p ) . to be_present expect ( p . topic ) . to be_present end end end describe <str> do subject { Fabricate . build ( <str> ) } it { is_expected . to be_valid } it { is_expected . not_to be_admin } it { is_expected . not_to be_approved } it <str> do expect ( subject . approved_at ) . to be_blank expect ( subject . approved_by_id ) . to be_blank end context <str> do before { subject . save } it <str> do expect ( subject . email_tokens ) . to be_present expect ( subject . user_option . email_private_messages ) . to eq ( true ) expect ( subject . user_option . email_direct ) . to eq ( true ) end end it <str> do user = Fabricate . build ( <str> , <str> : <str> ) user . valid? expect ( user . email ) . to eq ( <str> ) end it <str> do user = Fabricate . build ( <str> , <str> : <str> ) user . valid? expect ( user . email ) . to eq ( <str> ) end end describe <str> do it <str> do u = Fabricate . build ( <str> ) AllowedIpAddressValidator . any_instance . expects ( <str> ) . with ( u , <str> , u . ip_address ) u . valid? end it <str> do u = Fabricate ( <str> ) u . ip_address = <str> AllowedIpAddressValidator . any_instance . expects ( <str> ) . never u . valid? end end describe <str> do let ( <str> ) { Fabricate . build ( <str> , <str> : TrustLevel [ <int> ] ) } it <str> do SiteSetting . default_trust_level = TrustLevel [ <int> ] expect ( User . new . trust_level ) . to eq ( TrustLevel [ <int> ] ) end describe <str> do it <str> do expect { user . has_trust_level? ( <str> ) } . to raise_error end it <str> do expect ( user . has_trust_level? ( TrustLevel [ <int> ] ) ) . to eq ( true ) end it <str> do expect ( user . has_trust_level? ( TrustLevel [ <int> ] ) ) . to eq ( false ) end it <str> do user . trust_level = TrustLevel [ <int> ] expect ( user . has_trust_level? ( TrustLevel [ <int> ] ) ) . to eq ( true ) end it <str> do user . trust_level = TrustLevel [ <int> ] user . admin = true expect ( user . has_trust_level? ( TrustLevel [ <int> ] ) ) . to eq ( true ) end end describe <str> do it <str> do expect ( user . moderator? ) . to eq ( false ) end it <str> do user . moderator = true expect ( user . has_trust_level? ( TrustLevel [ <int> ] ) ) . to eq ( true ) end it <str> do user . admin = true expect ( user . staff? ) . to eq ( true ) end end end describe <str> do let ( <str> ) { Fabricate . build ( <str> ) } describe <str> do subject { user . staff? } it { is_expected . to eq ( false ) } context <str> do before { user . moderator = true } it { is_expected . to eq ( true ) } end context <str> do before { user . admin = true } it { is_expected . to eq ( true ) } end end describe <str> do subject { user . regular? } it { is_expected . to eq ( true ) } context <str> do before { user . moderator = true } it { is_expected . to eq ( false ) } end context <str> do before { user . admin = true } it { is_expected . to eq ( false ) } end end end describe <str> do before do @user = Fabricate ( <str> ) end it <str> do expect ( @user . email_hash ) . to match ( <str> ) end it <str> do @user . email = <str> @user2 = Fabricate ( <str> ) @user2 . email = <str> expect ( @user . email_hash ) . to eq ( @user2 . email_hash ) end it <str> do @user . email = <str> @user2 = Fabricate ( <str> ) @user2 . email = <str> expect ( @user . email_hash ) . to eq ( @user2 . email_hash ) end end describe <str> do it <str> do user = Fabricate ( <str> ) expect ( user . associated_accounts ) . to eq ( I18n . t ( <str> ) ) TwitterUserInfo . create ( <str> : user . id , <str> : <str> , <str> : <int> ) FacebookUserInfo . create ( <str> : user . id , <str> : <str> , <str> : <int> ) GoogleUserInfo . create ( <str> : user . id , <str> : <str> , <str> : <int> ) GithubUserInfo . create ( <str> : user . id , <str> : <str> , <str> : <int> ) user . reload expect ( user . associated_accounts ) . to eq ( <str> ) end end describe <str> do it <str> do expect ( User . suggest_name ( <str> ) ) . to eq ( <str> ) end end describe <str> do def assert_bad ( username ) user = Fabricate . build ( <str> ) user . username = username expect ( user . valid? ) . to eq ( false ) end def assert_good ( username ) user = Fabricate . build ( <str> ) user . username = username expect ( user . valid? ) . to eq ( true ) end it <str> do SiteSetting . min_username_length = <int> assert_bad ( <str> ) assert_good ( <str> ) end <str> . each do | username | it <str> username <str> do assert_good ( username ) end end <str> . each do | username | it <str> username <str> do assert_bad ( username ) end end end describe <str> do before do @user = Fabricate . build ( <str> ) @user . save! @codinghorror = Fabricate . build ( <str> ) end it <str> do @codinghorror . username = @user . username expect ( @codinghorror . save ) . to eq ( false ) end it <str> do @codinghorror . username = @user . username . upcase expect ( @codinghorror . save ) . to eq ( false ) end end context <str> do it <str> do expect ( User . username_available? ( <str> ) ) . to eq ( true ) end it <str> do expect ( User . username_available? ( Fabricate ( <str> ) . username ) ) . to eq ( false ) end end describe <str> do it <str> do user = Fabricate . build ( <str> , <str> : <str> ) expect ( user ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid end it <str> do Rails . configuration . stubs ( <str> ) . returns ( <str> ) SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do u = Fabricate ( <str> , <str> : <str> ) SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( u ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) u = Fabricate ( <str> , <str> : <str> ) u . email = <str> expect ( u ) . not_to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . not_to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do Rails . configuration . stubs ( <str> ) . returns ( <str> ) SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( Fabricate . build ( <str> , <str> : <str> ) ) . to be_valid end it <str> do u = Fabricate ( <str> , <str> : <str> ) SiteSetting . stubs ( <str> ) . returns ( <str> ) expect ( u ) . to be_valid end it <str> do SiteSetting . stubs ( <str> ) . returns ( <str> ) u = Fabricate ( <str> , <str> : <str> ) u . email = <str> expect ( u ) . not_to be_valid end end describe <str> do it <str> do @user = Fabricate . build ( <str> , <str> : false ) @user . password = <str> @user . save! @user . auth_token = SecureRandom . hex ( <int> ) @user . save! expect ( @user . active ) . to eq ( false ) expect ( @user . confirm_password? ( <str> ) ) . to eq ( true ) email_token = @user . email_tokens . create ( <str> : <str> ) old_token = @user . auth_token @user . password = <str> @user . save! expect ( @user . auth_token ) . to_not eq ( old_token ) email_token . reload expect ( email_token . expired ) . to eq ( true ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Time . zone . now } let! ( <str> ) { <int> . hours . from_now } let! ( <str> ) { <int> . hours . from_now } before do SiteSetting . stubs ( <str> ) . returns ( <int> ) SiteSetting . stubs ( <str> ) . returns ( <int> ) end it <str> do expect ( user . previous_visit_at ) . to eq ( nil ) user . update_last_seen! ( first_visit_date ) expect ( user . previous_visit_at ) . to eq ( nil ) user . update_last_seen! ( first_visit_date ) user . reload expect ( user . previous_visit_at ) . to eq ( nil ) user . update_last_seen! ( second_visit_date ) user . reload expect ( user . previous_visit_at ) . to be_within_one_second_of ( first_visit_date ) user . update_last_seen! ( third_visit_date ) user . reload expect ( user . previous_visit_at ) . to be_within_one_second_of ( second_visit_date ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( user . last_seen_at ) . to eq ( nil ) end it <str> do expect ( user . user_stat . days_visited ) . to eq ( <int> ) end describe <str> do let! ( <str> ) { Time . zone . now } before do Timecop . freeze ( date ) user . update_last_seen! end after do Timecop . return end it <str> do expect ( user . last_seen_at ) . to be_within_one_second_of ( date ) end it <str> do user . reload expect ( user . user_stat . days_visited ) . to eq ( <int> ) end it <str> do expect ( user . user_visits . first . visited_at ) . to eq ( date . to_date ) end context <str> do before do Timecop . freeze ( date ) user . update_last_seen! user . update_last_seen! user . reload end after do Timecop . return end it <str> do expect ( user . user_stat . days_visited ) . to eq ( <int> ) end end describe <str> do let! ( <str> ) { <int> . days . from_now } before do Timecop . freeze ( future_date ) user . update_last_seen! end after do Timecop . return end it <str> do expect ( user . user_visits . count ) . to eq ( <int> ) end end end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } context <str> do it <str> do expect ( user . email_confirmed? ) . to eq ( false ) end end context <str> do it <str> do token = user . email_tokens . find_by ( <str> : user . email ) EmailToken . confirm ( token . token ) expect ( user . email_confirmed? ) . to eq ( true ) end end context <str> do it <str> do user . email_tokens . each { | t | t . destroy } user . reload expect ( user . email_confirmed? ) . to eq ( true ) end end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { PostCreator . new ( user , <str> : <str> , <str> : <str> ) . create } let! ( <str> ) { PostCreator . new ( user , <str> : <str> , <str> : <str> ) . create } let! ( <str> ) { PostCreator . new ( user , <str> : <str> , <str> : <str> ) . create } it <str> do user . flag_linked_posts_as_spam post . reload expect ( post . spam_count ) . to eq ( <int> ) another_post . reload expect ( another_post . spam_count ) . to eq ( <int> ) post_without_link . reload expect ( post_without_link . spam_count ) . to eq ( <int> ) user . flag_linked_posts_as_spam end it <str> do user . flag_linked_posts_as_spam post . reload expect ( post . spam_count ) . to eq ( <int> ) PostAction . clear_flags! ( post , admin ) user . flag_linked_posts_as_spam post . reload expect ( post . spam_count ) . to eq ( <int> ) end end describe <str> do context <str> do it <str> do expect ( Fabricate ( <str> , <str> : <str> , name : nil ) . readable_name ) . to eq ( <str> ) end end context <str> do it <str> do expect ( Fabricate ( <str> , <str> : <str> , name : <str> ) . readable_name ) . to eq ( <str> ) end end context <str> do it <str> do expect ( Fabricate ( <str> , <str> : <str> , name : <str> ) . readable_name ) . to eq ( <str> ) end end end describe <str> do it <str> do bob = Fabricate ( <str> , <str> : <str> , <str> : <str> ) found_user = User . find_by_username_or_email ( <str> ) expect ( found_user ) . to eq bob found_user = User . find_by_username_or_email ( <str> ) expect ( found_user ) . to eq bob found_user = User . find_by_username_or_email ( <str> ) expect ( found_user ) . to eq bob found_user = User . find_by_username_or_email ( <str> ) expect ( found_user ) . to be_nil found_user = User . find_by_email ( <str> ) expect ( found_user ) . to eq bob found_user = User . find_by_email ( <str> ) expect ( found_user ) . to eq bob found_user = User . find_by_email ( <str> ) expect ( found_user ) . to be_nil found_user = User . find_by_username ( <str> ) expect ( found_user ) . to eq bob end end describe <str> do def test_user? ( opts = { } ) Fabricate . build ( <str> , { <str> : Time . now } . merge ( opts ) ) . first_day_user? end it <str> do expect ( test_user? ) . to eq ( true ) expect ( test_user? ( <str> : true ) ) . to eq ( false ) expect ( test_user? ( <str> : TrustLevel [ <int> ] ) ) . to eq ( false ) expect ( test_user? ( <str> : <int> . days . ago ) ) . to eq ( false ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } describe <str> do it <str> do expect ( user . api_key ) . to be_blank api_key = user . generate_api_key ( admin ) expect ( api_key . user ) . to eq ( user ) expect ( api_key . key ) . to be_present expect ( api_key . created_by ) . to eq ( admin ) user . reload expect ( user . api_key ) . to eq ( api_key ) new_key = user . generate_api_key ( other_admin ) expect ( new_key . id ) . to eq ( api_key . id ) expect ( new_key . key ) . to_not eq ( api_key . key ) expect ( new_key . created_by ) . to eq ( other_admin ) end end describe <str> do it <str> do expect ( user . api_key ) . to be_blank user . revoke_api_key user . reload expect ( user . api_key ) . to be_blank user . generate_api_key ( admin ) user . reload user . revoke_api_key user . reload expect ( user . api_key ) . to be_blank end end end describe <str> do let! ( <str> ) { Fabricate ( <str> , <str> : TrustLevel [ <int> ] ) } let! ( <str> ) { Fabricate ( <str> ) . topic } before do SiteSetting . stubs ( <str> ) . returns ( <int> ) end context <str> do let! ( <str> ) { Fabricate ( <str> , <str> : topic , <str> : user ) } it <str> do user . stubs ( <str> ) . returns ( true ) expect ( user . posted_too_much_in_topic? ( topic . id ) ) . to eq ( false ) end it <str> do expect ( user . posted_too_much_in_topic? ( topic . id ) ) . to eq ( true ) end context <str> do before do PostCreator . new ( Fabricate ( <str> ) , <str> : <str> , <str> : topic . id , <str> : post . post_number ) . create end it <str> do expect ( user . posted_too_much_in_topic? ( topic . id ) ) . to eq ( false ) end end end it <str> do topic_user = topic . user topic_user . trust_level = TrustLevel [ <int> ] expect ( topic . user . posted_too_much_in_topic? ( topic . id ) ) . to eq ( false ) end end describe <str> do let ( <str> ) { Fabricate ( <str> , <str> : <str> ) } context <str> do before { user . stubs ( <str> ) . returns ( <str> ) } it <str> do expect ( user . find_email ) . to eq ( <str> ) end end context <str> do before { user . stubs ( <str> ) . returns ( nil ) } it <str> do expect ( user . find_email ) . to eq ( user . email ) end end end describe <str> do it <str> do expect ( User . gravatar_template ( <str> ) ) . to eq ( <str> ) end end describe <str> do let ( <str> ) { build ( <str> , <str> : <str> ) } it <str> do SiteSetting . external_system_avatars_enabled = false expect ( user . small_avatar_url ) . to eq ( <str> LetterAvatar . version <str> ) SiteSetting . external_system_avatars_enabled = true expect ( user . small_avatar_url ) . to eq ( <str> ) end end describe <str> do let ( <str> ) { build ( <str> , <str> : <int> , <str> : <str> ) } it <str> do expect ( user . avatar_template_url ) . to eq ( <str> OptimizedImage :: VERSION <str> ) end it <str> do Rails . configuration . action_controller . stubs ( <str> ) . returns ( <str> ) expect ( user . avatar_template_url ) . to eq ( <str> OptimizedImage :: VERSION <str> ) end end describe <str> do context <str> do let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Time . zone . now } before { user . update_last_seen! ( now ) } it <str> do expect { user_visit = user . update_posts_read! ( <int> ) expect ( user_visit . posts_read ) . to eq ( <int> ) } . to_not change { UserVisit . count } end it <str> do expect { user_visit = user . update_posts_read! ( <int> , <str> : <int> . days . ago ) expect ( user_visit . posts_read ) . to eq ( <int> ) } . to change { UserVisit . count } . by ( <int> ) end end end describe <str> do let! ( <str> ) { Fabricate ( <str> ) } it <str> do expect ( user . primary_group_id ) . to eq ( nil ) end context <str> do let! ( <str> ) { Fabricate ( <str> ) } before do group . usernames = user . username group . save user . primary_group_id = group . id user . save user . reload end it <str> do expect ( user . primary_group_id ) . to eq ( group . id ) group . usernames = <str> group . save user . reload expect ( user . primary_group_id ) . to eq ( nil ) end end end describe <str> do it <str> do SiteSetting . external_system_avatars_enabled = false u = User . create! ( <str> : <str> , <str> : <str> ) u . reload expect ( u . uploaded_avatar_id ) . to eq ( nil ) expect ( u . avatar_template ) . to eq ( <str> LetterAvatar . version <str> ) end end describe <str> do it <str> do user = Fabricate ( <str> ) expect ( user . custom_fields [ <str> ] ) . to eq ( nil ) user . custom_fields [ <str> ] = <str> user . custom_fields [ <str> ] = <str> user . save user = User . find ( user . id ) expect ( user . custom_fields [ <str> ] ) . to eq ( <str> ) expect ( user . custom_fields [ <str> ] ) . to eq ( <str> ) user . custom_fields . delete ( <str> ) user . custom_fields [ <str> ] = <str> user . save user = User . find ( user . id ) expect ( user . custom_fields ) . to eq ( { <str> = > <str> } ) end end describe <str> do it <str> do SiteSetting . automatically_download_gravatars = true user = Fabricate ( <str> ) Jobs . expects ( <str> ) . with ( <str> , anything ) user . refresh_avatar end end describe <str> do let! ( <str> ) { Fabricate ( <str> ) } let! ( <str> ) { Fabricate ( <str> , <str> : false ) } let! ( <str> ) { Fabricate ( <str> , <str> : false , <str> : <int> . month . ago ) } it <str> do User . purge_unactivated all_users = User . all expect ( all_users . include? ( user ) ) . to eq ( true ) expect ( all_users . include? ( inactive ) ) . to eq ( true ) expect ( all_users . include? ( inactive_old ) ) . to eq ( false ) end end describe <str> do let ( <str> ) { <str> * ( User . max_password_length + <int> ) } def hash ( password , salt ) User . new . send ( <str> , password , salt ) end it <str> do expect ( hash ( <str> , <str> ) ) . to eq ( hash ( <str> , <str> ) ) end it <str> do expect ( hash ( <str> , <str> ) ) . not_to eq ( hash ( <str> , <str> ) ) end it <str> do expect ( hash ( <str> , <str> ) ) . not_to eq ( hash ( <str> , <str> ) ) end it <str> do expect { hash ( too_long , <str> ) } . to raise_error end end describe <str> do it <str> do group = Fabricate ( <str> , <str> : <str> ) user = Fabricate ( <str> , <str> : <str> ) group . reload expect ( group . users . include? ( user ) ) . to eq ( true ) end end describe <str> do let ( <str> ) { Fabricate ( <str> ) } let ( <str> ) { Fabricate ( <str> ) } it <str> do post_agreed = Fabricate ( <str> ) PostAction . act ( user , post_agreed , PostActionType . types [ <str> ] ) PostAction . agree_flags! ( post_agreed , moderator ) post_deferred = Fabricate ( <str> ) PostAction . act ( user , post_deferred , PostActionType . types [ <str> ] ) PostAction . defer_flags! ( post_deferred , moderator ) post_disagreed = Fabricate ( <str> ) PostAction . act ( user , post_disagreed , PostActionType . types [ <str> ] ) PostAction . clear_flags! ( post_disagreed , moderator ) expect ( user . number_of_flags_given ) . to eq ( <int> ) end end describe <str> do let ( <str> ) { Fabricate ( <str> , id : <int> ) } let ( <str> ) { Fabricate ( <str> ) } it <str> do Fabricate ( <str> , <str> : user ) post_deleted_by_moderator = Fabricate ( <str> , <str> : user ) PostDestroyer . new ( moderator , post_deleted_by_moderator ) . destroy post_deleted_by_user = Fabricate ( <str> , <str> : user , <str> : <int> ) PostDestroyer . new ( user , post_deleted_by_user ) . destroy post_deleted_by_user . update_columns ( <str> : <int> . days . ago ) PostDestroyer . destroy_stubs expect ( user . number_of_deleted_posts ) . to eq ( <int> ) end end describe <str> do it <str> do user = User . new ( <str> : Time . now , <str> : TrustLevel [ <int> ] ) expect ( user . new_user? ) . to eq ( true ) user . trust_level = TrustLevel [ <int> ] expect ( user . new_user? ) . to eq ( true ) user . trust_level = TrustLevel [ <int> ] expect ( user . new_user? ) . to eq ( false ) user . trust_level = TrustLevel [ <int> ] user . moderator = true expect ( user . new_user? ) . to eq ( false ) end end context <str> do before do SiteSetting . default_email_digest_frequency = <int> SiteSetting . default_email_private_messages = false SiteSetting . default_email_direct = false SiteSetting . default_email_mailing_list_mode = true SiteSetting . default_email_always = true SiteSetting . default_other_new_topic_duration_minutes = - <int> SiteSetting . default_other_auto_track_topics_after_msecs = <int> SiteSetting . default_other_external_links_in_new_tab = true SiteSetting . default_other_enable_quoting = false SiteSetting . default_other_dynamic_favicon = true SiteSetting . default_other_disable_jump_reply = true SiteSetting . default_other_edit_history_public = true SiteSetting . default_topics_automatic_unpin = false SiteSetting . default_categories_watching = <str> SiteSetting . default_categories_tracking = <str> SiteSetting . default_categories_muted = <str> end it <str> do user = Fabricate ( <str> ) options = user . user_option expect ( options . email_always ) . to eq ( true ) expect ( options . mailing_list_mode ) . to eq ( true ) expect ( options . digest_after_minutes ) . to eq ( <int> ) expect ( options . email_private_messages ) . to eq ( false ) expect ( options . external_links_in_new_tab ) . to eq ( true ) expect ( options . enable_quoting ) . to eq ( false ) expect ( options . dynamic_favicon ) . to eq ( true ) expect ( options . disable_jump_reply ) . to eq ( true ) expect ( options . edit_history_public ) . to eq ( true ) expect ( options . automatically_unpin_topics ) . to eq ( false ) expect ( options . email_direct ) . to eq ( false ) expect ( options . new_topic_duration_minutes ) . to eq ( - <int> ) expect ( options . auto_track_topics_after_msecs ) . to eq ( <int> ) expect ( CategoryUser . lookup ( user , <str> ) . pluck ( <str> ) ) . to eq ( [ <int> ] ) expect ( CategoryUser . lookup ( user , <str> ) . pluck ( <str> ) ) . to eq ( [ <int> ] ) expect ( CategoryUser . lookup ( user , <str> ) . pluck ( <str> ) ) . to eq ( [ <int> ] ) end end context UserOption do it <str> do user = Fabricate ( <str> ) expect ( user . user_option . email_always ) . to eq ( false ) user_id = user . id user . destroy! expect ( UserOption . find_by ( <str> : user_id ) ) . to eq ( nil ) end end end 
