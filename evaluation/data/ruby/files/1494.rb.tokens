require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> class AttributeMethodsTest < ActiveRecord :: TestCase include InTimeZone fixtures <str> , <str> , <str> , <str> def setup @old_matchers = ActiveRecord :: Base . send ( <str> ) . dup @target = Class . new ( ActiveRecord :: Base ) @target . table_name = <str> end teardown do ActiveRecord :: Base . send ( <str> ) . clear ActiveRecord :: Base . send ( <str> ) . concat ( @old_matchers ) end def test_attribute_for_inspect t = topics ( <str> ) t . title = <str> assert_equal <str> t . written_on . to_s ( <str> ) <str> , t . attribute_for_inspect ( <str> ) assert_equal <str> , t . attribute_for_inspect ( <str> ) end def test_attribute_present t = Topic . new t . title = <str> t . written_on = Time . now t . author_name = <str> assert t . attribute_present? ( <str> ) assert t . attribute_present? ( <str> ) assert ! t . attribute_present? ( <str> ) assert ! t . attribute_present? ( <str> ) end def test_attribute_present_with_booleans b1 = Boolean . new b1 . value = false assert b1 . attribute_present? ( <str> ) b2 = Boolean . new b2 . value = true assert b2 . attribute_present? ( <str> ) b3 = Boolean . new assert ! b3 . attribute_present? ( <str> ) b4 = Boolean . new b4 . value = false b4 . save! assert Boolean . find ( b4 . id ) . attribute_present? ( <str> ) end def test_caching_nil_primary_key klass = Class . new ( Minimalistic ) assert_called ( klass , <str> , <str> : nil ) do <int> . times { klass . primary_key } end end def test_attribute_keys_on_new_instance t = Topic . new assert_equal nil , t . title , <str> assert_raise ( NoMethodError ) { t . title2 } end def test_boolean_attributes assert ! Topic . find ( <int> ) . approved? assert Topic . find ( <int> ) . approved? end def test_set_attributes topic = Topic . find ( <int> ) topic . attributes = { <str> = > <str> , <str> = > <str> } topic . save assert_equal ( <str> , topic . title ) assert_equal ( <str> , topic . author_name ) assert_equal ( topics ( <str> ) . author_email_address , Topic . find ( <int> ) . author_email_address ) end def test_set_attributes_without_hash topic = Topic . new assert_raise ( ArgumentError ) { topic . attributes = <str> } end def test_integers_as_nil test = AutoId . create ( <str> = > <str> ) assert_nil AutoId . find ( test . id ) . value end def test_set_attributes_with_block topic = Topic . new do | t | t . title = <str> t . author_name = <str> end assert_equal ( <str> , topic . title ) assert_equal ( <str> , topic . author_name ) end def test_respond_to? topic = Topic . find ( <int> ) assert_respond_to topic , <str> assert_respond_to topic , <str> assert_respond_to topic , <str> assert_respond_to topic , <str> assert_respond_to topic , <str> assert_respond_to topic , <str> = assert_respond_to topic , <str> assert_respond_to topic , <str> assert ! topic . respond_to? ( <str> ) assert ! topic . respond_to? ( <str> ) end def test_respond_to_with_custom_primary_key keyboard = Keyboard . create assert_not_nil keyboard . key_number assert_equal keyboard . key_number , keyboard . id assert keyboard . respond_to? ( <str> ) assert keyboard . respond_to? ( <str> ) end def test_id_before_type_cast_with_custom_primary_key keyboard = Keyboard . create keyboard . key_number = <str> assert_equal <str> , keyboard . id_before_type_cast assert_equal nil , keyboard . read_attribute_before_type_cast ( <str> ) assert_equal <str> , keyboard . read_attribute_before_type_cast ( <str> ) assert_equal <str> , keyboard . read_attribute_before_type_cast ( <str> ) end def test_respond_to_with_allocated_object klass = Class . new ( ActiveRecord :: Base ) do self . table_name = <str> end topic = klass . allocate assert ! topic . respond_to? ( <str> ) assert ! topic . respond_to? ( <str> ) assert_respond_to topic , <str> assert_respond_to topic , <str> end def test_allocated_object_can_be_inspected topic = Topic . allocate assert_equal <str> , topic . inspect end def test_array_content topic = Topic . new topic . content = <str> topic . save assert_equal ( <str> , Topic . find ( topic . id ) . content ) end def test_read_attributes_before_type_cast category = Category . new ( { <str> = > <str> , <str> = > nil } ) category_attrs = { <str> = > <str> , <str> = > nil , <str> = > nil , <str> = > nil } assert_equal category_attrs , category . attributes_before_type_cast end if current_adapter? ( <str> ) def test_read_attributes_before_type_cast_on_boolean bool = Boolean . create! ( { <str> = > false } ) if RUBY_PLATFORM =~ <str> assert_equal <str> , bool . reload . attributes_before_type_cast [ <str> ] else assert_equal <int> , bool . reload . attributes_before_type_cast [ <str> ] end end end def test_read_attributes_before_type_cast_on_datetime in_time_zone <str> do record = @target . new record . written_on = <str> assert_equal <str> , record . written_on_before_type_cast assert_equal nil , record . written_on record . written_on = <str> assert_equal <str> , record . written_on_before_type_cast assert_equal Time . zone . parse ( <str> ) , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone end end def test_read_attributes_after_type_cast_on_datetime tz = <str> in_time_zone tz do record = @target . new date_string = <str> time = Time . zone . parse date_string record . written_on = date_string assert_equal date_string , record . written_on_before_type_cast assert_equal time , record . written_on assert_equal ActiveSupport :: TimeZone [ tz ] , record . written_on . time_zone record . save record . reload assert_equal time , record . written_on end end def test_hash_content topic = Topic . new topic . content = { <str> = > <int> , <str> = > <int> } topic . save assert_equal <int> , Topic . find ( topic . id ) . content [ <str> ] topic . content_will_change! topic . content [ <str> ] = <int> topic . save assert_equal <int> , Topic . find ( topic . id ) . content [ <str> ] end def test_update_array_content topic = Topic . new topic . content = <str> topic . content . push <str> assert_equal ( <str> , topic . content ) topic . save topic = Topic . find ( topic . id ) topic . content << <str> assert_equal ( <str> , topic . content ) end def test_case_sensitive_attributes_hash return true if current_adapter? ( <str> ) assert_equal @loaded_fixtures [ <str> ] [ <str> ] . to_hash , Computer . first . attributes end def test_attributes_without_primary_key klass = Class . new ( ActiveRecord :: Base ) do self . table_name = <str> end assert_equal klass . column_names , klass . new . attributes . keys assert_not klass . new . has_attribute? ( <str> ) end def test_hashes_not_mangled new_topic = { <str> = > <str> } new_topic_values = { <str> = > <str> } topic = Topic . new ( new_topic ) assert_equal new_topic [ <str> ] , topic . title topic . attributes = new_topic_values assert_equal new_topic_values [ <str> ] , topic . title end def test_create_through_factory topic = Topic . create ( <str> = > <str> ) topicReloaded = Topic . find ( topic . id ) assert_equal ( topic , topicReloaded ) end def test_write_attribute topic = Topic . new topic . send ( <str> , <str> , <str> ) assert_equal <str> , topic . title topic [ <str> ] = <str> assert_equal <str> , topic . title topic . send ( <str> , <str> , <str> ) assert_equal <str> , topic . title topic [ <str> ] = <str> assert_equal <str> , topic . title end def test_read_attribute topic = Topic . new topic . title = <str> assert_equal <str> , topic . read_attribute ( <str> ) assert_equal <str> , topic [ <str> ] assert_equal <str> , topic . read_attribute ( <str> ) assert_equal <str> , topic [ <str> ] end def test_read_attribute_raises_missing_attribute_error_when_not_exists computer = Computer . select ( <str> ) . first assert_raises ( ActiveModel :: MissingAttributeError ) { computer [ <str> ] } assert_raises ( ActiveModel :: MissingAttributeError ) { computer [ <str> ] } assert_raises ( ActiveModel :: MissingAttributeError ) { computer [ <str> ] = <str> } assert_nothing_raised { computer [ <str> ] = <str> } end def test_read_attribute_when_false topic = topics ( <str> ) topic . approved = false assert ! topic . approved? , <str> topic . approved = <str> assert ! topic . approved? , <str> end def test_read_attribute_when_true topic = topics ( <str> ) topic . approved = true assert topic . approved? , <str> topic . approved = <str> assert topic . approved? , <str> end def test_read_write_boolean_attribute topic = Topic . new topic . approved = <str> assert ! topic . approved? , <str> topic . approved = <str> assert ! topic . approved? , <str> topic . approved = <str> assert topic . approved? , <str> topic . approved = <str> assert topic . approved? , <str> end def test_overridden_write_attribute topic = Topic . new def topic . write_attribute ( attr_name , value ) super ( attr_name , value . downcase ) end topic . send ( <str> , <str> , <str> ) assert_equal <str> , topic . title topic [ <str> ] = <str> assert_equal <str> , topic . title topic . send ( <str> , <str> , <str> ) assert_equal <str> , topic . title topic [ <str> ] = <str> assert_equal <str> , topic . title end def test_overridden_read_attribute topic = Topic . new topic . title = <str> def topic . read_attribute ( attr_name ) super ( attr_name ) . upcase end assert_equal <str> , topic . read_attribute ( <str> ) assert_equal <str> , topic [ <str> ] assert_equal <str> , topic . read_attribute ( <str> ) assert_equal <str> , topic [ <str> ] end def test_read_overridden_attribute topic = Topic . new ( <str> = > <str> ) def topic . title ( ) <str> end assert_equal <str> , topic [ <str> ] end def test_query_attribute_string [ nil , <str> , <str> ] . each do | value | assert_equal false , Topic . new ( <str> = > value ) . author_name? end assert_equal true , Topic . new ( <str> = > <str> ) . author_name? end def test_query_attribute_number [ nil , <int> , <str> ] . each do | value | assert_equal false , Developer . new ( <str> = > value ) . salary? end assert_equal true , Developer . new ( <str> = > <int> ) . salary? assert_equal true , Developer . new ( <str> = > <str> ) . salary? end def test_query_attribute_boolean [ nil , <str> , false , <str> , <str> , <int> ] . each do | value | assert_equal false , Topic . new ( <str> = > value ) . approved? end [ true , <str> , <str> , <int> ] . each do | value | assert_equal true , Topic . new ( <str> = > value ) . approved? end end def test_query_attribute_with_custom_fields object = Company . find_by_sql ( <<- <str> SQL <str> ) . first <str> SQL assert_equal <str> , object . string_value assert object . string_value? object . string_value = <str> assert ! object . string_value? assert_equal <int> , object . int_value . to_i assert object . int_value? object . int_value = <str> assert ! object . int_value? end def test_non_attribute_access_and_assignment topic = Topic . new assert ! topic . respond_to? ( <str> ) assert_raise ( NoMethodError ) { topic . mumbo } assert_raise ( NoMethodError ) { topic . mumbo = <int> } end def test_undeclared_attribute_method_does_not_affect_respond_to_and_method_missing topic = @target . new ( <str> = > <str> ) assert topic . respond_to? ( <str> ) assert_equal <str> , topic . title assert ! topic . respond_to? ( <str> ) assert_raise ( NoMethodError ) { topic . title_hello_world } end def test_declared_prefixed_attribute_method_affects_respond_to_and_method_missing topic = @target . new ( <str> = > <str> ) <str> . each do | prefix | @target . class_eval <str> prefix <str> @target . attribute_method_prefix prefix meth = <str> prefix <str> assert topic . respond_to? ( meth ) assert_equal [ <str> ] , topic . send ( meth ) assert_equal [ <str> , <str> ] , topic . send ( meth , <str> ) assert_equal [ <str> , <int> , <int> , <int> ] , topic . send ( meth , <int> , <int> , <int> ) end end def test_declared_suffixed_attribute_method_affects_respond_to_and_method_missing <str> . each do | suffix | @target . class_eval <str> suffix <str> @target . attribute_method_suffix suffix topic = @target . new ( <str> = > <str> ) meth = <str> suffix <str> assert topic . respond_to? ( meth ) assert_equal [ <str> ] , topic . send ( meth ) assert_equal [ <str> , <str> ] , topic . send ( meth , <str> ) assert_equal [ <str> , <int> , <int> , <int> ] , topic . send ( meth , <int> , <int> , <int> ) end end def test_declared_affixed_attribute_method_affects_respond_to_and_method_missing [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] . each do | prefix , suffix | @target . class_eval <str> prefix <str> suffix <str> @target . attribute_method_affix ( { <str> = > prefix , <str> = > suffix } ) topic = @target . new ( <str> = > <str> ) meth = <str> prefix <str> suffix <str> assert topic . respond_to? ( meth ) assert_equal [ <str> ] , topic . send ( meth ) assert_equal [ <str> , <str> ] , topic . send ( meth , <str> ) assert_equal [ <str> , <int> , <int> , <int> ] , topic . send ( meth , <int> , <int> , <int> ) end end def test_should_unserialize_attributes_for_frozen_records myobj = { <str> = > <str> } topic = Topic . create ( <str> = > myobj ) topic . freeze assert_equal myobj , topic . content end def test_typecast_attribute_from_select_to_false Topic . create ( <str> = > <str> ) if current_adapter? ( <str> , <str> ) topic = Topic . all . merge! ( <str> = > <str> ) . first else topic = Topic . all . merge! ( <str> = > <str> ) . first end assert ! topic . is_test? end def test_typecast_attribute_from_select_to_true Topic . create ( <str> = > <str> ) if current_adapter? ( <str> , <str> ) topic = Topic . all . merge! ( <str> = > <str> ) . first else topic = Topic . all . merge! ( <str> = > <str> ) . first end assert topic . is_test? end def test_raises_dangerous_attribute_error_when_defining_activerecord_method_in_model <str> . each do | method | klass = Class . new ActiveRecord :: Base klass . class_eval <str> method <str> method <str> assert_raise ActiveRecord :: DangerousAttributeError do klass . instance_method_already_implemented? ( method ) end end end def test_converted_values_are_returned_after_assignment developer = Developer . new ( name : <int> , <str> : <str> ) assert_equal <str> , developer . salary_before_type_cast assert_equal <int> , developer . name_before_type_cast assert_equal <int> , developer . salary assert_equal <str> , developer . name developer . save! assert_equal <int> , developer . salary assert_equal <str> , developer . name end def test_write_nil_to_time_attributes in_time_zone <str> do record = @target . new record . written_on = nil assert_nil record . written_on end end def test_write_time_to_date_attributes in_time_zone <str> do record = @target . new record . last_read = Time . utc ( <int> , <int> , <int> , <int> ) assert_equal Date . civil ( <int> , <int> , <int> ) , record . last_read end end def test_time_attributes_are_retrieved_in_current_time_zone in_time_zone <str> do utc_time = Time . utc ( <int> , <int> , <int> ) record = @target . new record [ <str> ] = utc_time assert_equal utc_time , record . written_on assert_kind_of ActiveSupport :: TimeWithZone , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record . written_on . time end end def test_setting_time_zone_aware_attribute_to_utc in_time_zone <str> do utc_time = Time . utc ( <int> , <int> , <int> ) record = @target . new record . written_on = utc_time assert_equal utc_time , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record . written_on . time end end def test_setting_time_zone_aware_attribute_in_other_time_zone utc_time = Time . utc ( <int> , <int> , <int> ) cst_time = utc_time . in_time_zone ( <str> ) in_time_zone <str> do record = @target . new record . written_on = cst_time assert_equal utc_time , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record . written_on . time end end def test_setting_time_zone_aware_read_attribute utc_time = Time . utc ( <int> , <int> , <int> ) cst_time = utc_time . in_time_zone ( <str> ) in_time_zone <str> do record = @target . create ( <str> = > cst_time ) . reload assert_equal utc_time , record [ <str> ] assert_equal ActiveSupport :: TimeZone [ <str> ] , record [ <str> ] . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record [ <str> ] . time end end def test_setting_time_zone_aware_attribute_with_string utc_time = Time . utc ( <int> , <int> , <int> ) ( - <int> .. <int> ) . each do | timezone_offset | time_string = utc_time . in_time_zone ( timezone_offset ) . to_s in_time_zone <str> do record = @target . new record . written_on = time_string assert_equal Time . zone . parse ( time_string ) , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record . written_on . time end end end def test_time_zone_aware_attribute_saved in_time_zone <int> do record = @target . create ( <str> = > <str> ) record . written_on = <str> record . save assert_equal Time . zone . local ( <int> , <oct> , <int> , <int> ) , record . reload . written_on end end def test_setting_time_zone_aware_attribute_to_blank_string_returns_nil in_time_zone <str> do record = @target . new record . written_on = <str> assert_nil record . written_on assert_nil record [ <str> ] end end def test_setting_time_zone_aware_attribute_interprets_time_zone_unaware_string_in_time_zone time_string = <str> ( - <int> .. <int> ) . each do | timezone_offset | in_time_zone timezone_offset do record = @target . new record . written_on = time_string assert_equal Time . zone . parse ( time_string ) , record . written_on assert_equal ActiveSupport :: TimeZone [ timezone_offset ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> ) , record . written_on . time end end end def test_setting_time_zone_aware_datetime_in_current_time_zone utc_time = Time . utc ( <int> , <int> , <int> ) in_time_zone <str> do record = @target . new record . written_on = utc_time . in_time_zone assert_equal utc_time , record . written_on assert_equal ActiveSupport :: TimeZone [ <str> ] , record . written_on . time_zone assert_equal Time . utc ( <int> , <int> , <int> , <int> ) , record . written_on . time end end def test_yaml_dumping_record_with_time_zone_aware_attribute in_time_zone <str> do record = Topic . new ( id : <int> ) record . written_on = <str> assert_equal record , YAML . load ( YAML . dump ( record ) ) end end def test_setting_time_zone_aware_time_in_current_time_zone in_time_zone <str> do record = @target . new time_string = <str> expected_time = Time . zone . parse ( <str> time_string <str> ) record . bonus_time = time_string assert_equal expected_time , record . bonus_time assert_equal ActiveSupport :: TimeZone [ <str> ] , record . bonus_time . time_zone record . bonus_time = <str> assert_nil record . bonus_time end end def test_setting_time_zone_aware_time_with_dst in_time_zone <str> do current_time = Time . zone . local ( <int> , <oct> , <int> , <int> ) record = @target . new ( <str> : current_time ) time_before_save = record . bonus_time record . save record . reload assert_equal time_before_save , record . bonus_time assert_equal ActiveSupport :: TimeZone [ <str> ] , record . bonus_time . time_zone end end def test_removing_time_zone_aware_types with_time_zone_aware_types ( <str> ) do in_time_zone <str> do record = @target . new ( <str> : <str> ) expected_time = Time . utc ( <int> , <oct> , <oct> , <int> ) assert_equal expected_time , record . bonus_time assert record . bonus_time . utc? end end end def test_time_zone_aware_attributes_dont_recurse_infinitely_on_invalid_values in_time_zone <str> do record = @target . new ( <str> : [ ] ) assert_equal nil , record . bonus_time end end def test_setting_time_zone_conversion_for_attributes_should_write_value_on_class_variable Topic . skip_time_zone_conversion_for_attributes = [ <str> ] Minimalistic . skip_time_zone_conversion_for_attributes = [ <str> ] assert_equal [ <str> ] , Topic . skip_time_zone_conversion_for_attributes assert_equal [ <str> ] , Minimalistic . skip_time_zone_conversion_for_attributes end def test_read_attributes_respect_access_control privatize ( <str> ) topic = @target . new ( <str> = > <str> ) assert ! topic . respond_to? ( <str> ) exception = assert_raise ( NoMethodError ) { topic . title } assert exception . message . include? ( <str> ) assert_equal <str> , topic . send ( <str> ) end def test_write_attributes_respect_access_control privatize ( <str> ) topic = @target . new assert ! topic . respond_to? ( <str> = ) exception = assert_raise ( NoMethodError ) { topic . title = <str> } assert exception . message . include? ( <str> ) topic . send ( <str> = , <str> ) end def test_question_attributes_respect_access_control privatize ( <str> ) topic = @target . new ( <str> = > <str> ) assert ! topic . respond_to? ( <str> ) exception = assert_raise ( NoMethodError ) { topic . title? } assert exception . message . include? ( <str> ) assert topic . send ( <str> ) end def test_bulk_update_respects_access_control privatize ( <str> ) assert_raise ( ActiveRecord :: UnknownAttributeError ) { @target . new ( <str> = > <str> ) } assert_raise ( ActiveRecord :: UnknownAttributeError ) { @target . new . attributes = { <str> = > <str> } } end def test_bulk_update_raise_unknown_attribute_error error = assert_raises ( ActiveRecord :: UnknownAttributeError ) { Topic . new ( <str> : <str> ) } assert_instance_of Topic , error . record assert_equal <str> , error . attribute assert_equal <str> , error . message end def test_methods_override_in_multi_level_subclass klass = Class . new ( Developer ) do def name <str> read_attribute ( <str> ) <str> end end <int> . times { klass = Class . new klass } dev = klass . new ( name : <str> ) dev . save! assert_equal <str> , dev . reload . name end def test_global_methods_are_overwritten klass = Class . new ( ActiveRecord :: Base ) do self . table_name = <str> end assert ! klass . instance_method_already_implemented? ( <str> ) computer = klass . new assert_nil computer . system end def test_global_methods_are_overwritten_when_subclassing klass = Class . new ( ActiveRecord :: Base ) { self . abstract_class = true } subklass = Class . new ( klass ) do self . table_name = <str> end assert ! klass . instance_method_already_implemented? ( <str> ) assert ! subklass . instance_method_already_implemented? ( <str> ) computer = subklass . new assert_nil computer . system end def test_instance_method_should_be_defined_on_the_base_class subklass = Class . new ( Topic ) Topic . define_attribute_methods instance = subklass . new instance . id = <int> assert_equal <int> , instance . id assert subklass . method_defined? ( <str> ) , <str> Topic . undefine_attribute_methods assert_equal <int> , instance . id assert subklass . method_defined? ( <str> ) , <str> end def test_read_attribute_with_nil_should_not_asplode assert_equal nil , Topic . new . read_attribute ( nil ) end def test_inherited_custom_accessors klass = new_topic_like_ar_class do self . abstract_class = true def title ; <str> ; end def title = ( val ) ; self . author_name = val ; end end subklass = Class . new ( klass ) [ klass , subklass ] . each ( & <str> ) topic = subklass . find ( <int> ) assert_equal <str> , topic . title topic . title = <str> assert_equal <str> , topic . author_name end def test_inherited_custom_accessors_with_reserved_names klass = Class . new ( ActiveRecord :: Base ) do self . table_name = <str> self . abstract_class = true def system ; <str> ; end def system = ( val ) ; self . developer = val ; end end subklass = Class . new ( klass ) [ klass , subklass ] . each ( & <str> ) computer = subklass . find ( <int> ) assert_equal <str> , computer . system computer . developer = <int> assert_equal <int> , computer . developer end def test_on_the_fly_super_invokable_generated_attribute_methods_via_method_missing klass = new_topic_like_ar_class do def title super + <str> end end real_topic = topics ( <str> ) assert_equal real_topic . title + <str> , klass . find ( real_topic . id ) . title end def test_on_the_fly_super_invokable_generated_predicate_attribute_methods_via_method_missing klass = new_topic_like_ar_class do def title? ! super end end real_topic = topics ( <str> ) assert_equal ! real_topic . title? , klass . find ( real_topic . id ) . title? end def test_calling_super_when_parent_does_not_define_method_raises_error klass = new_topic_like_ar_class do def some_method_that_is_not_on_super super end end assert_raise ( NoMethodError ) do klass . new . some_method_that_is_not_on_super end end def test_attribute_method? assert @target . attribute_method? ( <str> ) assert @target . attribute_method? ( <str> = ) assert_not @target . attribute_method? ( <str> ) end def test_attribute_method_returns_false_if_table_does_not_exist @target . table_name = <str> assert_not @target . attribute_method? ( <str> ) end def test_attribute_names_on_new_record model = @target . new assert_equal @target . column_names , model . attribute_names end def test_attribute_names_on_queried_record model = @target . last! assert_equal @target . column_names , model . attribute_names end def test_attribute_names_with_custom_select model = @target . select ( <str> ) . last! assert_equal [ <str> ] , model . attribute_names assert_not_equal [ <str> ] , @target . column_names end def test_came_from_user model = @target . first assert_not model . id_came_from_user? model . id = <str> assert model . id_came_from_user? end def test_accessed_fields model = @target . first assert_equal [ ] , model . accessed_fields model . title assert_equal [ <str> ] , model . accessed_fields end private def new_topic_like_ar_class ( & block ) klass = Class . new ( ActiveRecord :: Base ) do self . table_name = <str> class_eval ( & block ) end assert_empty klass . generated_attribute_methods . instance_methods ( false ) klass end def with_time_zone_aware_types ( * types ) old_types = ActiveRecord :: Base . time_zone_aware_types ActiveRecord :: Base . time_zone_aware_types = types yield ensure ActiveRecord :: Base . time_zone_aware_types = old_types end def cached_columns Topic . columns . map ( & <str> ) end def time_related_columns_on_topic Topic . columns . select { | c | [ <str> , <str> , <str> , <str> ] . include? ( c . type ) } end def privatize ( method_signature ) @target . class_eval ( <<- <str> private_method <str> , __FILE__ , __LINE__ + <int> ) <str> private_method end end 
