require <str> module Net::SSH::Transport module CTR def self . extended ( orig ) orig . instance_eval { @remaining = <str> @counter = nil @counter_len = orig . block_size orig . encrypt orig . padding = <int> } class << orig alias <str> <str> private <str> undef <str> def iv @counter end def iv_len block_size end def iv = ( iv_s ) @counter = iv_s if @counter . nil? end def encrypt end def decrypt end def padding = ( pad ) end def reset @remaining = <str> end def update ( data ) @remaining += data encrypted = <str> while @remaining . bytesize > = block_size encrypted += xor! ( @remaining . slice! ( <int> , block_size ) , _update ( @counter ) ) increment_counter! end encrypted end def final unless @remaining . empty? s = xor! ( @remaining , _update ( @counter ) ) else s = <str> end @remaining = <str> s end private def xor! ( s1 , s2 ) s = [ ] s1 . unpack ( <str> ) . zip ( s2 . unpack ( <str> ) ) { | a , b | s . push ( a ^ b ) } s . pack ( <str> ) end def increment_counter! c = @counter_len while ( ( c -= <int> ) > <int> ) if @counter . setbyte ( c , ( @counter . getbyte ( c ) + <int> ) & <hex> ) != <int> break end end end end end end end 
