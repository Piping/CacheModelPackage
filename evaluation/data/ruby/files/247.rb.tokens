gem <str> , <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> module ActiveRecord module ConnectionHandling def postgresql_connection ( config ) conn_params = config . symbolize_keys conn_params . delete_if { | _ , v | v . nil? } conn_params [ <str> ] = conn_params . delete ( <str> ) if conn_params [ <str> ] conn_params [ <str> ] = conn_params . delete ( <str> ) if conn_params [ <str> ] valid_conn_param_keys = PGconn . conndefaults_hash . keys + [ <str> ] conn_params . slice! ( * valid_conn_param_keys ) ConnectionAdapters :: PostgreSQLAdapter . new ( nil , logger , conn_params , config ) end end module ConnectionAdapters class PostgreSQLAdapter < AbstractAdapter ADAPTER_NAME = <str> . freeze NATIVE_DATABASE_TYPES = { <str> : <str> , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , <str> : { name : <str> } , } OID = PostgreSQL :: OID include PostgreSQL :: Quoting include PostgreSQL :: ReferentialIntegrity include PostgreSQL :: SchemaStatements include PostgreSQL :: DatabaseStatements include PostgreSQL :: ColumnDumper include Savepoints def schema_creation PostgreSQL :: SchemaCreation . new self end def supports_statement_cache? true end def supports_index_sort_order? true end def supports_partial_index? true end def supports_transaction_isolation? true end def supports_foreign_keys? true end def supports_views? true end def supports_datetime_with_precision? true end def supports_json? postgresql_version > = <int> end def index_algorithms { <str> : <str> } end class StatementPool < ConnectionAdapters :: StatementPool def initialize ( connection , max ) super ( max ) @connection = connection @counter = <int> end def next_key <str> @counter + <int> <str> end def []= ( sql , key ) super . tap { @counter += <int> } end private def dealloc ( key ) @connection . query <str> key <str> if connection_active? end def connection_active? @connection . status == PGconn :: CONNECTION_OK rescue PGError false end end def initialize ( connection , logger , connection_parameters , config ) super ( connection , logger , config ) @visitor = Arel :: Visitors :: PostgreSQL . new self if self . class . type_cast_config_to_boolean ( config . fetch ( <str> ) { true } ) @prepared_statements = true @visitor . extend ( DetermineIfPreparableVisitor ) else @prepared_statements = false end @connection_parameters = connection_parameters @local_tz = nil @table_alias_length = nil connect add_pg_encoders @statements = StatementPool . new @connection , self . class . type_cast_config_to_integer ( config . fetch ( <str> ) { <int> } ) if postgresql_version < <int> raise <str> postgresql_version <str> end add_pg_decoders @type_map = Type :: HashLookupTypeMap . new initialize_type_map ( type_map ) @local_tz = execute ( <str> , <str> ) . first [ <str> ] @use_insert_returning = @config . key? ( <str> ) ? self . class . type_cast_config_to_boolean ( @config [ <str> ] ) : true end def clear_cache! @statements . clear end def truncate ( table_name , name = nil ) exec_query <str> quote_table_name ( table_name ) <str> , name , [ ] end def active? @connection . query <str> true rescue PGError false end def reconnect! super @connection . reset configure_connection end def reset! clear_cache! reset_transaction unless @connection . transaction_status == :: PG :: PQTRANS_IDLE @connection . query <str> end @connection . query <str> configure_connection end def disconnect! super @connection . close rescue nil end def native_database_types NATIVE_DATABASE_TYPES end def supports_migrations? true end def supports_primary_key? true end def set_standard_conforming_strings execute ( <str> , <str> ) end def supports_ddl_transactions? true end def supports_advisory_locks? true end def supports_explain? true end def supports_extensions? true end def supports_ranges? postgresql_version > = <int> end def supports_materialized_views? postgresql_version > = <int> end def get_advisory_lock ( lock_id ) unless lock_id . is_a? ( Integer ) && lock_id . bit_length < = <int> raise ( ArgumentError , <str> ) end select_value ( <str> lock_id <str> ) end def release_advisory_lock ( lock_id ) unless lock_id . is_a? ( Integer ) && lock_id . bit_length < = <int> raise ( ArgumentError , <str> ) end select_value ( <str> lock_id <str> ) end def enable_extension ( name ) exec_query ( <str> name <str> ) . tap { reload_type_map } end def disable_extension ( name ) exec_query ( <str> name <str> ) . tap { reload_type_map } end def extension_enabled? ( name ) if supports_extensions? res = exec_query <str> name <str> , <str> res . cast_values . first end end def extensions if supports_extensions? exec_query ( <str> , <str> ) . cast_values else super end end def table_alias_length @table_alias_length || = query ( <str> , <str> ) [ <int> ] [ <int> ] . to_i end def session_auth = ( user ) clear_cache! exec_query <str> user <str> end def use_insert_returning? @use_insert_returning end def valid_type? ( type ) ! native_database_types [ type ] . nil? end def update_table_definition ( table_name , base ) PostgreSQL :: Table . new ( table_name , base ) end def lookup_cast_type ( sql_type ) oid = execute ( <str> quote ( sql_type ) <str> , <str> ) . first [ <str> ] . to_i super ( oid ) end def column_name_for_operation ( operation , node ) OPERATION_ALIASES . fetch ( operation ) { operation . downcase } end OPERATION_ALIASES = { <str> = > <str> , <str> = > <str> , <str> = > <str> , } def postgresql_version @connection . server_version end protected FOREIGN_KEY_VIOLATION = <str> UNIQUE_VIOLATION = <str> def translate_exception ( exception , message ) return exception unless exception . respond_to? ( <str> ) case exception . result . try ( <str> , PGresult :: PG_DIAG_SQLSTATE ) when UNIQUE_VIOLATION RecordNotUnique . new ( message ) when FOREIGN_KEY_VIOLATION InvalidForeignKey . new ( message ) else super end end private def get_oid_type ( oid , fmod , column_name , sql_type = <str> ) if ! type_map . key? ( oid ) load_additional_types ( type_map , [ oid ] ) end type_map . fetch ( oid , fmod , sql_type ) { warn <str> oid <str> column_name <str> Type :: Value . new . tap do | cast_type | type_map . register_type ( oid , cast_type ) end } end def initialize_type_map ( m ) register_class_with_limit m , <str> , Type :: Integer register_class_with_limit m , <str> , Type :: Integer register_class_with_limit m , <str> , Type :: Integer m . alias_type <str> , <str> m . register_type <str> , Type :: Float . new m . alias_type <str> , <str> m . register_type <str> , Type :: Text . new register_class_with_limit m , <str> , Type :: String m . alias_type <str> , <str> m . alias_type <str> , <str> m . alias_type <str> , <str> m . register_type <str> , Type :: Boolean . new register_class_with_limit m , <str> , OID :: Bit register_class_with_limit m , <str> , OID :: BitVarying m . alias_type <str> , <str> m . register_type <str> , Type :: Date . new m . register_type <str> , OID :: Money . new m . register_type <str> , OID :: Bytea . new m . register_type <str> , OID :: Point . new m . register_type <str> , OID :: Hstore . new m . register_type <str> , OID :: Json . new m . register_type <str> , OID :: Jsonb . new m . register_type <str> , OID :: Cidr . new m . register_type <str> , OID :: Inet . new m . register_type <str> , OID :: Uuid . new m . register_type <str> , OID :: Xml . new m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . register_type <str> , OID :: SpecializedString . new ( <str> ) m . alias_type <str> , <str> register_class_with_precision m , <str> , Type :: Time register_class_with_precision m , <str> , OID :: DateTime m . register_type <str> do | _ , fmod , sql_type | precision = extract_precision ( sql_type ) scale = extract_scale ( sql_type ) if fmod && ( fmod - <int> & <hex> ) . zero? Type :: DecimalWithoutScale . new ( <str> : precision ) else OID :: Decimal . new ( <str> : precision , <str> : scale ) end end load_additional_types ( m ) end def extract_limit ( sql_type ) case sql_type when <str> , <str> <int> when <str> <int> else super end end def extract_value_from_default ( default ) case default when <str> if $1 == <str> . freeze && $2 == <str> . freeze nil else $1 . gsub ( <str> . freeze , <str> . freeze ) end when <str> . freeze , <str> . freeze default when <str> $1 when <str> $1 else nil end end def extract_default_function ( default_value , default ) default if has_default_function? ( default_value , default ) end def has_default_function? ( default_value , default ) ! default_value && ( <str> === default ) end def load_additional_types ( type_map , oids = nil ) initializer = OID :: TypeMapInitializer . new ( type_map ) if supports_ranges? query = <<- <str> SQL <str> <str> SQL else query = <<- <str> SQL <str> <str> SQL end if oids query += <str> % oids . join ( <str> ) else query += initializer . query_conditions_for_initial_load ( type_map ) end execute_and_clear ( query , <str> , [ ] ) do | records | initializer . run ( records ) end end FEATURE_NOT_SUPPORTED = <str> def execute_and_clear ( sql , name , binds , <str> : false ) if without_prepared_statement? ( binds ) result = exec_no_cache ( sql , name , [ ] ) elsif ! prepare result = exec_no_cache ( sql , name , binds ) else result = exec_cache ( sql , name , binds ) end ret = yield result result . clear ret end def exec_no_cache ( sql , name , binds ) type_casted_binds = binds . map { | attr | type_cast ( attr . value_for_database ) } log ( sql , name , binds ) { @connection . async_exec ( sql , type_casted_binds ) } end def exec_cache ( sql , name , binds ) stmt_key = prepare_statement ( sql ) type_casted_binds = binds . map { | attr | type_cast ( attr . value_for_database ) } log ( sql , name , binds , stmt_key ) do @connection . exec_prepared ( stmt_key , type_casted_binds ) end rescue ActiveRecord :: StatementInvalid = > e pgerror = e . cause begin code = pgerror . result . result_error_field ( PGresult :: PG_DIAG_SQLSTATE ) rescue raise e end if FEATURE_NOT_SUPPORTED == code @statements . delete sql_key ( sql ) retry else raise e end end def sql_key ( sql ) <str> schema_search_path <str> sql <str> end def prepare_statement ( sql ) sql_key = sql_key ( sql ) unless @statements . key? sql_key nextkey = @statements . next_key begin @connection . prepare nextkey , sql rescue = > e raise translate_exception_class ( e , sql ) end @connection . get_last_result @statements [ sql_key ] = nextkey end @statements [ sql_key ] end def connect @connection = PGconn . connect ( @connection_parameters ) configure_connection rescue :: PG :: Error = > error if error . message . include? ( <str> ) raise ActiveRecord :: NoDatabaseError else raise end end def configure_connection if @config [ <str> ] @connection . set_client_encoding ( @config [ <str> ] ) end self . client_min_messages = @config [ <str> ] || <str> self . schema_search_path = @config [ <str> ] || @config [ <str> ] set_standard_conforming_strings if ActiveRecord :: Base . default_timezone == <str> execute ( <str> , <str> ) elsif @local_tz execute ( <str> @local_tz <str> , <str> ) end variables = @config [ <str> ] || { } variables . map do | k , v | if v == <str> || v == <str> execute ( <str> k <str> , <str> ) elsif ! v . nil? execute ( <str> k <str> quote ( v ) <str> , <str> ) end end end def last_insert_id_result ( sequence_name ) exec_query ( <str> sequence_name <str> , <str> ) end def column_definitions ( table_name ) query ( <<- <str> end_sql <str> , <str> ) <str> end_sql end def extract_table_ref_from_insert_sql ( sql ) sql [ <str> ] $1 . strip if $1 end def create_table_definition ( name , temporary = false , options = nil , as = nil ) PostgreSQL :: TableDefinition . new ( name , temporary , options , as ) end def can_perform_case_insensitive_comparison_for? ( column ) @case_insensitive_cache || = { } @case_insensitive_cache [ column . sql_type ] || = begin sql = <<- <str> end_sql <str> <str> end_sql execute_and_clear ( sql , <str> , [ ] ) do | result | result . getvalue ( <int> , <int> ) end end end def add_pg_encoders map = PG :: TypeMapByClass . new map [ Integer ] = PG :: TextEncoder :: Integer . new map [ TrueClass ] = PG :: TextEncoder :: Boolean . new map [ FalseClass ] = PG :: TextEncoder :: Boolean . new map [ Float ] = PG :: TextEncoder :: Float . new @connection . type_map_for_queries = map end def add_pg_decoders coders_by_name = { <str> = > PG :: TextDecoder :: Integer , <str> = > PG :: TextDecoder :: Integer , <str> = > PG :: TextDecoder :: Integer , <str> = > PG :: TextDecoder :: Integer , <str> = > PG :: TextDecoder :: Float , <str> = > PG :: TextDecoder :: Float , <str> = > PG :: TextDecoder :: Boolean , } known_coder_types = coders_by_name . keys . map { | n | quote ( n ) } query = <<- <str> SQL <str> % known_coder_types . join ( <str> ) <str> SQL coders = execute_and_clear ( query , <str> , [ ] ) do | result | result . map { | row | construct_coder ( row , coders_by_name [ row [ <str> ] ] ) } . compact end map = PG :: TypeMapByOid . new coders . each { | coder | map . add_coder ( coder ) } @connection . type_map_for_results = map end def construct_coder ( row , coder_class ) return unless coder_class coder_class . new ( <str> : row [ <str> ] . to_i , name : row [ <str> ] ) end ActiveRecord :: Type . add_modifier ( { <str> : true } , OID :: Array , <str> : <str> ) ActiveRecord :: Type . add_modifier ( { <str> : true } , OID :: Range , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Bit , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: BitVarying , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Bytea , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Cidr , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: DateTime , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Decimal , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Enum , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Hstore , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Inet , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Json , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Jsonb , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Money , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Rails51Point , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Point , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Uuid , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Vector , <str> : <str> ) ActiveRecord :: Type . register ( <str> , OID :: Xml , <str> : <str> ) end end end 
