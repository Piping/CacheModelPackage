require <str> require <str> class RequestController < ApplicationController before_filter <str> , <str> = > [ <str> , <str> , <str> ] before_filter <str> , <str> = > [ <str> , <str> ] MAX_RESULTS = <int> PER_PAGE = <int> @@custom_states_loaded = false begin require <str> include RequestControllerCustomStates @@custom_states_loaded = true rescue MissingSourceFile , NameError end def select_authority if AlaveteliConfiguration :: force_registration_on_new_request && ! authenticated? ( <str> = > _ ( <str> ) , <str> = > _ ( <str> ) , <str> = > _ ( <str> ) ) return end if ! params [ <str> ] . nil? query = params [ <str> ] flash [ <str> ] = params . slice ( <str> , <str> , <str> ) @xapian_requests = perform_search_typeahead ( query , PublicBody ) end medium_cache end def select_authorities if ! params [ <str> ] . nil? @search_bodies = perform_search_typeahead ( params [ <str> ] , PublicBody , <int> ) end respond_to do | format | format . html do if ! params [ <str> ] . nil? if ! params [ <str> ] . nil? body_ids = params [ <str> ] - params [ <str> ] else body_ids = params [ <str> ] end @public_bodies = PublicBody . where ( { <str> = > body_ids } ) . all end end format . json do if @search_bodies render <str> = > @search_bodies . results . map { | result | { <str> = > result [ <str> ] . name , <str> = > result [ <str> ] . id } } else render <str> = > [ ] end end end end def show if ! AlaveteliConfiguration :: varnish_host . blank? long_cache else medium_cache end @locale = I18n . locale . to_s I18n . with_locale ( @locale ) do if params [ <str> ] . match ( <str> ) @info_request = InfoRequest . find ( params [ <str> ] . to_i ) redirect_to request_url ( @info_request , <str> = > params [ <str> ] ) return end @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) if ! @info_request . user_can_view? ( authenticated_user ) return render_hidden end set_last_request ( @info_request ) @collapse_quotes = ! params [ <str> ] if @info_request . is_external? @update_status = false else @update_status = params [ <str> ] end assign_variables_for_show_template ( @info_request ) if @update_status return if ! @is_owning_user && ! authenticated_as_user? ( @info_request . user , <str> = > _ ( <str> ) , <str> = > _ ( <str> ) + @info_request . public_body . name + <str> , <str> = > _ ( <str> ) + @info_request . public_body . name ) end @sidebar = true @similar_cache_key = cache_key_for_similar_requests ( @info_request , @locale ) @track_thing = TrackThing . create_track_for_request ( @info_request ) @feed_autodetect = [ { <str> = > do_track_url ( @track_thing , <str> ) , <str> = > @track_thing . params [ <str> ] , <str> = > true } ] respond_to do | format | format . html { @has_json = true ; render <str> = > <str> } format . json { render <str> = > @info_request . json_for_api ( true ) } end end end def details long_cache @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) if ! @info_request . user_can_view? ( authenticated_user ) return render_hidden end @columns = [ <str> , <str> , <str> , <str> , <str> , <str> ] end def similar short_cache @per_page = <int> @page = ( params [ <str> ] || <str> ) . to_i if @page > MAX_RESULTS / PER_PAGE raise ActiveRecord :: RecordNotFound . new ( <str> MAX_RESULTS / PER_PAGE <str> ) end @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) raise ActiveRecord :: RecordNotFound . new ( <str> ) if @info_request . nil? if ! @info_request . user_can_view? ( authenticated_user ) return render_hidden end @xapian_object = ActsAsXapian :: Similar . new ( [ InfoRequestEvent ] , @info_request . info_request_events , <str> = > ( @page - <int> ) * @per_page , <str> = > @per_page , <str> = > <str> ) @matches_estimated = @xapian_object . matches_estimated @show_no_more_than = ( @matches_estimated > MAX_RESULTS ) ? MAX_RESULTS : @matches_estimated end def list medium_cache @view = params [ <str> ] @locale = I18n . locale . to_s @page = get_search_page_from_params if ! @page @per_page = PER_PAGE @max_results = MAX_RESULTS if @view == <str> return redirect_to request_list_all_url ( <str> = > <str> , <str> = > <str> , <str> = > @page ) , <str> = > <str> end if @page > MAX_RESULTS / PER_PAGE raise ActiveRecord :: RecordNotFound . new ( <str> MAX_RESULTS / PER_PAGE <str> ) end @filters = params . merge ( <str> = > @view ) @title = _ ( <str> ) @title = @title + <str> + @page . to_s + <str> if ( @page > <int> ) @track_thing = TrackThing . create_track_for_search_query ( InfoRequestEvent . make_query_from_params ( @filters ) ) @feed_autodetect = [ { <str> = > do_track_url ( @track_thing , <str> ) , <str> = > @track_thing . params [ <str> ] , <str> = > true } ] if @page > <int> @no_crawl = true end end def new_batch if params [ <str> ] . blank? redirect_to select_authorities_path and return end if ! authenticated_user . can_file_requests? @details = authenticated_user . can_fail_html render <str> = > <str> and return end @batch = true I18n . with_locale ( @locale ) do @public_bodies = PublicBody . where ( { <str> = > params [ <str> ] } ) . includes ( <str> ) . order ( <str> ) . all end if params [ <str> ] . nil? || params [ <str> ] return render_new_compose ( batch = true ) end @existing_batch = InfoRequestBatch . find_existing ( authenticated_user , params [ <str> ] [ <str> ] , params [ <str> ] [ <str> ] , params [ <str> ] ) @info_request = InfoRequest . create_from_attributes ( params [ <str> ] , params [ <str> ] , authenticated_user ) @outgoing_message = @info_request . outgoing_messages . first @info_request . is_batch_request_template = true if ! @existing_batch . nil? || ! @info_request . valid? @info_request . errors . delete ( <str> ) render <str> = > <str> return end if params [ <str> ] . to_i == <int> return render_new_preview end @info_request_batch = InfoRequestBatch . create! ( <str> = > params [ <str> ] [ <str> ] , <str> = > params [ <str> ] [ <str> ] , <str> = > @public_bodies , <str> = > authenticated_user ) flash [ <str> ] = true redirect_to info_request_batch_path ( @info_request_batch ) end def new if ! params [ <str> ] . nil? params [ <str> ] [ <str> ] = <str> end if ! @user . nil? && params [ <str> ] . nil? @undescribed_requests = @user . get_undescribed_requests if @undescribed_requests . size > <int> render <str> = > <str> return end end user_exceeded_limit = false if ! authenticated_user . nil? && ! authenticated_user . can_file_requests? user_exceeded_limit = authenticated_user . exceeded_limit? if ! user_exceeded_limit @details = authenticated_user . can_fail_html render <str> = > <str> return end @next_request_permitted_at = authenticated_user . next_request_permitted_at end if params [ <str> ] . nil? || params [ <str> ] if user_exceeded_limit render <str> = > <str> return end return render_new_compose ( batch = false ) end if params [ <str> ] [ <str> ] . blank? redirect_to frontpage_path and return end @existing_request = InfoRequest . find_existing ( params [ <str> ] [ <str> ] , params [ <str> ] [ <str> ] , params [ <str> ] [ <str> ] ) @info_request = InfoRequest . create_from_attributes ( params [ <str> ] , params [ <str> ] ) @outgoing_message = @info_request . outgoing_messages . first unless @info_request . public_body . is_requestable? render <str> = > <str> + @info_request . public_body . not_requestable_reason return end if @existing_request || ! @info_request . valid? @info_request . errors . delete ( <str> ) render <str> = > <str> return end if params [ <str> ] . to_i == <int> return render_new_preview end if user_exceeded_limit render <str> = > <str> return end if ! authenticated? ( <str> = > _ ( <str> ) . to_str , <str> = > _ ( <str> , <str> = > @info_request . public_body . name ) , <str> = > _ ( <str> , <str> = > @info_request . public_body . name ) ) return end if params [ <str> ] @info_request . user = params [ <str> ] else @info_request . user = authenticated_user end @info_request . save! if @outgoing_message . sendable? mail_message = OutgoingMailer . initial_request ( @outgoing_message . info_request , @outgoing_message ) . deliver @outgoing_message . record_email_delivery ( mail_message . to_addrs . join ( <str> ) , mail_message . message_id ) end flash [ <str> ] = true redirect_to show_new_request_path ( <str> = > @info_request . url_title ) end def describe_state info_request = InfoRequest . find ( params [ <str> ] . to_i ) set_last_request ( info_request ) if info_request . is_external? redirect_to request_url ( info_request ) return end unless Ability :: can_update_request_state? ( authenticated_user , info_request ) authenticated_as_user? ( info_request . user , <str> = > _ ( <str> ) , <str> = > _ ( <str> ) + info_request . public_body . name + <str> , <str> = > _ ( <str> ) + info_request . public_body . name ) return end if ! params [ <str> ] flash [ <str> ] = _ ( <str> ) redirect_to request_url ( info_request ) return end if params [ <str> ] . to_i != info_request . last_event_id_needing_description flash [ <str> ] = _ ( <str> ) redirect_to request_url ( info_request ) return end described_state = params [ <str> ] [ <str> ] message = params [ <str> ] [ <str> ] if [ <str> , <str> ] . include? ( described_state ) && message . nil? redirect_to describe_state_message_url ( <str> = > info_request . url_title , <str> = > described_state ) return end event = info_request . log_event ( <str> , { <str> = > authenticated_user . id , <str> = > info_request . described_state , <str> = > described_state , } ) info_request . set_described_state ( described_state , authenticated_user , message ) if ! info_request . is_actual_owning_user? ( authenticated_user ) RequestClassification . create! ( <str> = > authenticated_user . id , <str> = > event . id ) if session [ <str> ] flash [ <str> ] = _ ( <str> , <str> = > CGI . escapeHTML ( info_request . title ) , <str> = > CGI . escapeHTML ( request_path ( info_request ) ) ) redirect_to categorise_play_url else flash [ <str> ] = _ ( <str> ) redirect_to request_url ( info_request ) end return end calculated_status = info_request . calculate_status partial_path = <str> if template_exists? ( calculated_status , [ partial_path ] , true ) flash [ <str> ] = render_to_string ( <str> = > <str> partial_path <str> calculated_status <str> , <str> = > { <str> = > info_request } ) . html_safe end case calculated_status when <str> , <str> , <str> , <str> , <str> , <str> , <str> redirect_to request_url ( info_request ) when <str> , <str> , <str> redirect_to unhappy_url ( info_request ) when <str> , <str> redirect_to respond_to_last_url ( info_request ) when <str> redirect_to respond_to_last_url ( info_request ) + <str> else if @@custom_states_loaded return self . theme_describe_state ( info_request ) else raise <str> info_request . calculate_status <str> end end end def describe_state_message @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) @described_state = params [ <str> ] @last_info_request_event_id = @info_request . last_event_id_needing_description @title = case @described_state when <str> _ ( <str> ) when <str> _ ( <str> ) else raise <str> end end def show_request_event @info_request_event = InfoRequestEvent . find ( params [ <str> ] ) if @info_request_event . is_incoming_message? redirect_to incoming_message_url ( @info_request_event . incoming_message ) , <str> = > <str> elsif @info_request_event . is_outgoing_message? redirect_to outgoing_message_url ( @info_request_event . outgoing_message ) , <str> = > <str> else redirect_to request_url ( @info_request_event . info_request ) , <str> = > <str> end end before_filter <str> , <str> = > [ <str> , <str> ] def authenticate_attachment incoming_message = IncomingMessage . find ( params [ <str> ] ) raise ActiveRecord :: RecordNotFound . new ( <str> ) if incoming_message . nil? if ! incoming_message . info_request . user_can_view? ( authenticated_user ) @info_request = incoming_message . info_request return render_hidden end if ! incoming_message . user_can_view? ( authenticated_user ) @incoming_message = incoming_message return render_hidden ( <str> ) end if incoming_message . info_request . all_can_view? && incoming_message . all_can_view? @files_can_be_cached = true end end around_filter <str> , <str> = > [ <str> , <str> ] def cache_attachments if ! params [ <str> ] . nil? yield else key = params . merge ( <str> = > true ) key_path = foi_fragment_cache_path ( key ) if foi_fragment_cache_exists? ( key_path ) logger . info ( <str> key_path <str> ) if File . directory? ( key_path ) render <str> = > <str> , <str> = > <int> else render <str> = > foi_fragment_cache_read ( key_path ) , <str> = > ( AlaveteliFileTypes . filename_to_mimetype ( params [ <str> ] ) || <str> ) end return end yield if params [ <str> ] . nil? && response . status == <int> if @files_can_be_cached == true logger . info ( <str> key_path <str> ) foi_fragment_cache_write ( key_path , response . body ) end end end end def get_attachment get_attachment_internal ( false ) return unless @attachment response . content_type = AlaveteliFileTypes . filename_to_mimetype ( params [ <str> ] ) || <str> body = @incoming_message . apply_masks ( @attachment . default_body , @attachment . content_type ) if response . content_type == <str> body = ActionController :: Base . helpers . sanitize ( body ) end render <str> = > body end def get_attachment_as_html if @files_can_be_cached != true raise ActiveRecord :: RecordNotFound . new ( <str> ) end get_attachment_internal ( true ) return unless @attachment key = params . merge ( <str> = > true ) key_path = foi_fragment_cache_path ( key ) image_dir = File . dirname ( key_path ) FileUtils . mkdir_p ( image_dir ) html = @attachment . body_as_html ( image_dir , <str> = > Rack :: Utils . escape ( @attachment_url ) , <str> = > { <str> = > render_to_string ( <str> = > <str> ) , <str> = > render_to_string ( <str> = > <str> ) } ) response . content_type = <str> html = @incoming_message . apply_masks ( html , response . content_type ) render <str> = > html end def get_attachment_internal ( html_conversion ) @incoming_message = IncomingMessage . find ( params [ <str> ] ) @requested_request = InfoRequest . find ( params [ <str> ] ) @incoming_message . parse_raw_email! @info_request = @incoming_message . info_request if @incoming_message . info_request_id != params [ <str> ] . to_i message = <str> % [ @incoming_message . info_request_id , params [ <str> ] ] raise ActiveRecord :: RecordNotFound . new ( message ) end @part_number = params [ <str> ] . to_i @filename = params [ <str> ] if html_conversion @original_filename = @filename . gsub ( <str> , <str> ) else @original_filename = @filename end raise <str> if ! @info_request . user_can_view? ( authenticated_user ) @attachment = IncomingMessage . get_attachment_by_url_part_number_and_filename ( @incoming_message . get_attachments_for_display , @part_number , @original_filename ) unless @attachment return redirect_to incoming_message_url ( @incoming_message ) , <str> = > <int> end if @attachment . display_filename != @original_filename && @attachment . old_display_filename != @original_filename msg = <str> msg += <str> @attachment . display_filename <str> msg += <str> msg += <str> @attachment . old_display_filename <str> msg += <str> msg += <str> @original_filename <str> raise ActiveRecord :: RecordNotFound . new ( msg ) end @attachment_url = get_attachment_url ( <str> = > @incoming_message . info_request_id , <str> = > @incoming_message . id , <str> = > @part_number , <str> = > @original_filename ) end def upload_response @locale = I18n . locale . to_s I18n . with_locale ( @locale ) do @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) @reason_params = { <str> = > _ ( <str> ) + CGI . escapeHTML ( @info_request . public_body . name ) , <str> = > _ ( <str> ) , <str> = > _ ( <str> , <str> = > site_name ) } if ! authenticated? ( @reason_params ) return end if ! @info_request . public_body . is_foi_officer? ( @user ) domain_required = @info_request . public_body . foi_officer_domain_required if domain_required . nil? render <str> = > <str> return end @reason_params [ <str> ] = <str> + domain_required render <str> = > <str> return end end if params [ <str> ] file_name = nil file_content = nil if ! params [ <str> ] . nil? file_name = params [ <str> ] . original_filename file_content = params [ <str> ] . read end body = params [ <str> ] || <str> if file_name . nil? && body . empty? flash [ <str> ] = _ ( <str> ) return end mail = RequestMailer . fake_response ( @info_request , @user , body , file_name , file_content ) @info_request . receive ( mail , mail . encoded , true ) flash [ <str> ] = _ ( <str> ) + CGI . escapeHTML ( @info_request . user . name ) + <str> redirect_to request_url ( @info_request ) return end end def search_typeahead @query = <str> if params . key? ( <str> ) @query << <str> params [ <str> ] <str> end @per_page = ( params . fetch ( <str> ) { <int> } ) . to_i @query << params [ <str> ] @xapian_requests = perform_search_typeahead ( @query , InfoRequestEvent , @per_page ) render <str> = > <str> end def download_entire_request @locale = I18n . locale . to_s I18n . with_locale ( @locale ) do @info_request = InfoRequest . find_by_url_title! ( params [ <str> ] ) if authenticated? ( <str> = > _ ( <str> ) , <str> = > _ ( <str> , <str> = > @info_request . title ) , <str> = > _ ( <str> , <str> = > @info_request . title ) ) if ! @info_request . user_can_view? ( @user ) return render_hidden end cache_file_path = @info_request . make_zip_cache_path ( @user ) if ! File . exists? ( cache_file_path ) FileUtils . mkdir_p ( File . dirname ( cache_file_path ) ) make_request_zip ( @info_request , cache_file_path ) File . chmod ( <oct> , cache_file_path ) end send_file ( cache_file_path , <str> = > <str> @info_request . url_title <str> ) end end end private def assign_variables_for_show_template ( info_request ) @info_request = info_request @info_request_events = info_request . info_request_events @status = info_request . calculate_status @old_unclassified = info_request . is_old_unclassified? && ! authenticated_user . nil? @is_owning_user = info_request . is_owning_user? ( authenticated_user ) @last_info_request_event_id = info_request . last_event_id_needing_description @new_responses_count = info_request . events_needing_description . select { | i | i . event_type == <str> } . size @last_response = info_request . get_last_public_response end def make_request_zip ( info_request , file_path ) Zip :: ZipFile . open ( file_path , Zip :: ZipFile :: CREATE ) do | zipfile | file_info = make_request_summary_file ( info_request ) zipfile . get_output_stream ( file_info [ <str> ] ) { | f | f . puts ( file_info [ <str> ] ) } message_index = <int> info_request . incoming_messages . each do | message | next unless message . user_can_view? ( authenticated_user ) message_index += <int> message . get_attachments_for_display . each do | attachment | filename = <str> message_index <str> attachment . url_part_number <str> attachment . display_filename <str> zipfile . get_output_stream ( filename ) { | f | f . puts ( attachment . body ) } end end end end def make_request_summary_file ( info_request ) done = false convert_command = AlaveteliConfiguration :: html_to_pdf_command assign_variables_for_show_template ( info_request ) if ! convert_command . blank? && File . exists? ( convert_command ) @render_to_file = true html_output = render_to_string ( <str> = > <str> ) tmp_input = Tempfile . new ( [ <str> , <str> ] ) tmp_input . write ( html_output ) tmp_input . close tmp_output = Tempfile . new ( <str> ) output = AlaveteliExternalCommand . run ( convert_command , tmp_input . path , tmp_output . path ) if ! output . nil? file_info = { <str> = > <str> , <str> = > File . open ( tmp_output . path ) . read } done = true else logger . error ( <str> info_request . id <str> convert_command <str> tmp_input . path <str> tmp_output . path <str> ) end tmp_output . close tmp_input . delete tmp_output . delete else logger . warn ( <str> convert_command <str> ) end if ! done file_info = { <str> = > <str> , <str> = > render_to_string ( <str> = > <str> , <str> = > false , <str> = > [ <str> ] ) } end file_info end def cache_key_for_similar_requests ( info_request , locale ) <str> info_request . id <str> locale <str> end def check_batch_requests_and_user_allowed if ! AlaveteliConfiguration :: allow_batch_requests raise RouteNotFound . new ( <str> ) end if ! authenticated? ( <str> = > _ ( <str> ) , <str> = > _ ( <str> ) , <str> = > _ ( <str> ) , <str> = > <str> ) return end if ! @user . can_make_batch_requests? return render_hidden ( <str> ) end end def render_new_compose ( batch ) params [ <str> ] = { } if ! params [ <str> ] unless batch if params [ <str> ] if params [ <str> ] . match ( <str> ) params [ <str> ] [ <str> ] = PublicBody . find ( params [ <str> ] ) else public_body = PublicBody . find_by_url_name_with_historic ( params [ <str> ] ) raise ActiveRecord :: RecordNotFound . new ( <str> ) if public_body . nil? params [ <str> ] [ <str> ] = public_body end elsif params [ <str> ] params [ <str> ] [ <str> ] = PublicBody . find ( params [ <str> ] ) elsif params [ <str> ] [ <str> ] params [ <str> ] [ <str> ] = PublicBody . find ( params [ <str> ] [ <str> ] ) end if ! params [ <str> ] [ <str> ] redirect_to frontpage_url return end end params [ <str> ] [ <str> ] = params [ <str> ] if params [ <str> ] params [ <str> ] [ <str> ] = params [ <str> ] if params [ <str> ] @info_request = InfoRequest . new ( params [ <str> ] ) if batch @info_request . is_batch_request_template = true end params [ <str> ] = @info_request . id params [ <str> ] = { } if ! params [ <str> ] params [ <str> ] [ <str> ] = params [ <str> ] if params [ <str> ] params [ <str> ] [ <str> ] = params [ <str> ] if params [ <str> ] params [ <str> ] [ <str> ] = @info_request @outgoing_message = OutgoingMessage . new ( params [ <str> ] ) @outgoing_message . set_signature_name ( @user . name ) if ! @user . nil? if batch render <str> = > <str> else if @info_request . public_body . is_requestable? render <str> = > <str> else if @info_request . public_body . not_requestable_reason == <str> render <str> = > <str> else redirect_to public_body_url ( @info_request . public_body ) end end end return end def render_new_preview message = <str> if @outgoing_message . contains_email? if @user . nil? message += _ ( <str> \ <str> \ <str> \ <str> , <str> = > ( help_privacy_path + <str> ) . html_safe ) else message += _ ( <str> \ <str> \ <str> , <str> = > ( help_privacy_path + <str> ) . html_safe ) end message += _ ( <str> \ <str> \ <str> \ <str> ) end if @outgoing_message . contains_postcode? message += _ ( <str> \ <str> \ <str> \ <str> ) end if not message . empty? flash . now [ <str> ] = message . html_safe end render <str> = > <str> end end 
