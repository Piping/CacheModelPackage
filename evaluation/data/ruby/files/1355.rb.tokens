require <str> module Bosh::Director describe DeploymentPlan :: JobMigrator do subject ( <str> ) { described_class . new ( deployment_plan , logger ) } let ( <str> ) do DeploymentPlan :: Job . parse ( deployment_plan , job_spec , Config . event_log , logger ) end let ( <str> ) do spec = Bosh :: Spec :: Deployments . simple_job ( name : <str> , <str> : <int> ) spec [ <str> ] = [ <str> , <str> ] spec end let ( <str> ) do manifest = Bosh :: Spec :: Deployments . simple_manifest manifest [ <str> ] = [ etcd_job_spec ] manifest end let ( <str> ) do deployment_manifest [ <str> ] . first end let ( <str> ) do manifest = Bosh :: Spec :: Deployments . simple_cloud_config manifest [ <str> ] = [ { <str> = > <str> } , { <str> = > <str> } , ] manifest [ <str> ] [ <str> ] = <str> manifest [ <str> ] . first [ <str> ] = [ { <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ ] , <str> = > { } , <str> = > <str> } , { <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ ] , <str> = > { } , <str> = > <str> } ] manifest [ <str> ] << { <str> = > <str> , <str> = > [ { <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ ] , <str> = > { } , } ] } manifest end let ( <str> ) do cloud_config = Models :: CloudConfig . make ( <str> : cloud_config_manifest ) Models :: Deployment . make ( name : deployment_manifest [ <str> ] , <str> : YAML . dump ( deployment_manifest ) , <str> : cloud_config , ) end let ( <str> ) do planner_factory = DeploymentPlan :: PlannerFactory . create ( logger ) plan = planner_factory . create_from_model ( deployment_model ) plan end before do fake_locks prepare_deploy ( deployment_manifest , cloud_config_manifest ) allow ( logger ) . to receive ( <str> ) end describe <str> do context <str> do let ( <str> ) do job = Bosh :: Spec :: Deployments . simple_job ( name : <str> , <str> : <int> ) job [ <str> ] = [ <str> , <str> ] job [ <str> ] = [ { <str> = > <str> , <str> = > <str> } , { <str> = > <str> , <str> = > <str> } , ] job end context <str> do context <str> do let! ( <str> ) do instances = [ ] instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances end it <str> do migrated_instances = job_migrator . find_existing_instances ( etcd_job ) expect ( migrated_instances ) . to contain_exactly ( be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , ) end it <str> do expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) job_migrator . find_existing_instances ( etcd_job ) end end context <str> do let! ( <str> ) do job_instances = [ ] job_instances << Models :: Instance . make ( <str> : <str> , <str> : deployment_model , <str> : <int> , <str> : true , <str> : <str> ) job_instances << Models :: Instance . make ( <str> : <str> , <str> : deployment_model , <str> : <int> , <str> : <str> ) job_instances end let! ( <str> ) do instances = [ ] instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances << Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) instances end it <str> do migrated_instances = job_migrator . find_existing_instances ( etcd_job ) expect ( migrated_instances ) . to contain_exactly ( be_a_migrated_instance ( existing_job_instances [ <int> ] , nil ) , be_a_migrated_instance ( existing_job_instances [ <int> ] , nil ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , be_a_migrated_instance ( migrated_job_instances [ <int> ] , <str> ) , ) end it <str> do expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) expect ( logger ) . to receive ( <str> ) . with ( <str> ) job_migrator . find_existing_instances ( etcd_job ) end end end context <str> do let ( <str> ) do manifest = Bosh :: Spec :: Deployments . simple_manifest manifest [ <str> ] = [ etcd_job_spec , Bosh :: Spec :: Deployments . simple_job ( name : <str> ) . merge ( { <str> = > [ <str> ] } ) , Bosh :: Spec :: Deployments . simple_job ( name : <str> ) . merge ( { <str> = > [ <str> ] } ) , ] manifest end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . to raise_error ( DeploymentInvalidMigratedFromJob , <str> ) end end context <str> do let ( <str> ) do job = Bosh :: Spec :: Deployments . simple_job ( name : <str> , <str> : <int> ) job [ <str> ] = [ <str> ] job [ <str> ] = [ { <str> = > <str> , <str> = > <str> } , ] job end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . not_to raise_error end it <str> do Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) expect ( job_migrator . find_existing_instances ( etcd_job ) . count ) . to eq ( <int> ) end end context <str> do let ( <str> ) do manifest = Bosh :: Spec :: Deployments . simple_manifest another_job_spec = Bosh :: Spec :: Deployments . simple_job ( name : <str> ) another_job_spec [ <str> ] = etcd_job_spec [ <str> ] another_job_spec [ <str> ] = etcd_job_spec [ <str> ] manifest [ <str> ] = [ etcd_job_spec , another_job_spec ] manifest end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . to raise_error ( DeploymentInvalidMigratedFromJob , <str> ) end end context <str> do before do Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : <str> ) end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . to raise_error ( DeploymentInvalidMigratedFromJob , <str> ) end end context <str> do before do Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : nil ) end it <str> do job_migrator . find_existing_instances ( etcd_job ) etcd_z1_instance = Models :: Instance . find ( <str> : <str> , <str> : <int> ) expect ( etcd_z1_instance . availability_zone ) . to eq ( <str> ) end end context <str> do context <str> do let ( <str> ) do job = Bosh :: Spec :: Deployments . simple_job ( name : <str> , <str> : <int> ) job [ <str> ] = [ { <str> = > <str> } , ] job [ <str> ] = [ <str> , <str> ] job end before do Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : nil ) end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . to raise_error ( DeploymentInvalidMigratedFromJob , <str> ) end end context <str> do let ( <str> ) do job = Bosh :: Spec :: Deployments . simple_job ( name : <str> , <str> : <int> ) job [ <str> ] = [ { <str> = > <str> } ] job [ <str> ] = [ { <str> = > <str> } ] job end before do Models :: Instance . make ( <str> : <str> , <str> : <int> , <str> : deployment_model , <str> : nil ) end it <str> do expect { job_migrator . find_existing_instances ( etcd_job ) } . to_not raise_error end end end end context <str> do let! ( <str> ) do job_instances = [ ] job_instances << Models :: Instance . make ( <str> : <str> , <str> : deployment_model ) job_instances << Models :: Instance . make ( <str> : <str> , <str> : deployment_model ) job_instances end it <str> do migrated_instances = job_migrator . find_existing_instances ( etcd_job ) expect ( migrated_instances ) . to contain_exactly ( be_a_migrated_instance ( existing_job_instances [ <int> ] , nil ) , be_a_migrated_instance ( existing_job_instances [ <int> ] , nil ) ) end end end end end RSpec :: Matchers . define <str> do | expected , az | match do | actual | actual . reload == expected . reload && actual . availability_zone == az end end 
