require <str> class Msf :: Encoder :: Xor < Msf :: Encoder def encode_block ( state , block ) encoder = case state . decoder_key_size when Rex :: Encoding :: Xor :: Qword . keysize then Rex :: Encoding :: Xor :: Qword when Rex :: Encoding :: Xor :: Dword . keysize then Rex :: Encoding :: Xor :: Dword when Rex :: Encoding :: Xor :: Word . keysize then Rex :: Encoding :: Xor :: Word when Rex :: Encoding :: Xor :: Byte . keysize then Rex :: Encoding :: Xor :: Byte else Rex :: Encoding :: Xor :: Dword end encoder . encode ( block , [ state . key ] . pack ( state . decoder_key_pack ) ) [ <int> ] end def find_bad_keys ( buf , badchars ) return super if badchars . length == <int> bad_keys = Array . new ( decoder_key_size ) { Hash . new } byte_idx = <int> buf . each_byte { | byte | badchars . each_byte { | badchar | bad_keys [ byte_idx % decoder_key_size ] [ byte ^ badchar ] = true } byte_idx += <int> } badchars . each_byte { | badchar | <int> . upto ( decoder_key_size - <int> ) { | i | bad_keys [ i ] [ badchar ] = true } } return bad_keys end end 
