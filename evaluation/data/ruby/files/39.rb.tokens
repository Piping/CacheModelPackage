require <str> require <str> require_relative <str> class TestDigestExtend < Test :: Unit :: TestCase extend DifferentOFS class MyDigest < Digest :: Class def initialize ( * arg ) super @buf = [ ] end def initialize_copy ( org ) @buf = org . buf . dup end def update ( arg ) @buf << arg self end alias << update def finish ( @buf . join ( <str> ) . length % <int> ) . chr end def reset @buf . clear self end protected def buf @buf end end def setup @MyDigest = Class . new ( MyDigest ) end def test_digest_s_hexencode assert_equal ( <str> , Digest . hexencode ( <str> ) ) assert_equal ( <str> , Digest . hexencode ( <str> ) ) assert_equal ( ( <int> .. <hex> ) . to_a . map { | c | sprintf ( <str> , c ) } . join ( <str> ) , Digest . hexencode ( ( <int> .. <hex> ) . to_a . map { | c | c . chr } . join ( <str> ) ) ) assert_equal ( Encoding :: US_ASCII , Digest . hexencode ( <str> ) . encoding ) end def test_class_reset a = Digest :: SHA1 . new base = a . to_s assert_equal ( base , a . reset . to_s ) b = a . new assert_equal ( base , b . to_s ) b . update ( <str> ) assert_not_equal ( base , b . to_s ) assert_equal ( base , b . reset . to_s ) end def test_digest assert_equal ( <str> , MyDigest . digest ( <str> ) ) end def test_hexdigest assert_equal ( <str> , @MyDigest . hexdigest ( <str> ) ) end def test_context digester = @MyDigest . new digester . update ( <str> ) assert_equal ( <str> , digester . digest ) digester . update ( <str> ) assert_equal ( <str> , digester . digest ) digester . update ( <str> ) assert_equal ( <str> , digester . digest ) end def test_new a = Digest :: SHA1 . new b = a . new obj = a . to_s assert_equal ( obj , a . to_s ) assert_equal ( obj , b . to_s ) a . update ( <str> ) assert_not_equal ( obj , a . to_s ) assert_equal ( obj , b . to_s ) end def test_digest_hexdigest [ <str> , <str> ] . each do | m | exp_1st = <str> ; exp_1st = Digest . hexencode ( exp_1st ) if m == <str> exp_2nd = <str> ; exp_2nd = Digest . hexencode ( exp_2nd ) if m == <str> digester = @MyDigest . new digester . update ( <str> ) obj = digester . send ( m ) assert_equal ( exp_1st , obj ) digester . update ( <str> ) obj = digester . send ( m ) assert_equal ( exp_2nd , obj ) obj = digester . send ( m , <str> ) assert_equal ( exp_1st , obj ) end end def test_digest_hexdigest_bang [ <str> , <str> ] . each do | m | exp_1st = <str> ; exp_1st = Digest . hexencode ( exp_1st ) if m == <str> digester = @MyDigest . new digester . update ( <str> ) obj = digester . send ( m ) assert_equal ( exp_1st , obj ) digester . update ( <str> ) obj = digester . send ( m ) assert_equal ( exp_1st , obj ) end end def test_to_s digester = @MyDigest . new digester . update ( <str> ) assert_equal ( <str> , digester . to_s ) end def test_length @MyDigest . class_eval do def digest_length <int> end end digester = @MyDigest . new assert_equal ( <int> , digester . length ) assert_equal ( <int> , digester . size ) end def test_digest_length assert_equal ( <int> , @MyDigest . new . digest_length ) @MyDigest . class_eval do def digest_length <int> end end assert_equal ( <int> , @MyDigest . new . digest_length ) end def test_block_length assert_raise ( RuntimeError ) do @MyDigest . new . block_length end end end 
