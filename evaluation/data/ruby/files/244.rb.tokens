require <str> require <str> class Msf :: Modules :: Loader :: Directory < Msf :: Modules :: Loader :: Base def loadable? ( path ) if File . directory? ( path ) true else false end end protected def each_module_reference_name ( path , opts = { } ) whitelist = opts [ <str> ] || [ ] :: Dir . foreach ( path ) do | entry | if entry . downcase == <str> next end full_entry_path = :: File . join ( path , entry ) type = entry . singularize unless :: File . directory? ( full_entry_path ) and module_manager . type_enabled? type next end full_entry_pathname = Pathname . new ( full_entry_path ) Rex :: Find . find ( full_entry_path ) do | entry_descendant_path | if module_path? ( entry_descendant_path ) entry_descendant_pathname = Pathname . new ( entry_descendant_path ) relative_entry_descendant_pathname = entry_descendant_pathname . relative_path_from ( full_entry_pathname ) relative_entry_descendant_path = relative_entry_descendant_pathname . to_s module_reference_name = module_reference_name_from_path ( relative_entry_descendant_path ) yield path , type , module_reference_name end end end end def module_path ( parent_path , type , module_reference_name ) typed_path = self . typed_path ( type , module_reference_name ) full_path = File . join ( parent_path , typed_path ) full_path end def read_module_content ( parent_path , type , module_reference_name ) full_path = module_path ( parent_path , type , module_reference_name ) module_content = <str> begin File . open ( full_path , <str> ) do | f | module_content = f . read ( f . stat . size ) end rescue Errno :: ENOENT = > error load_error ( full_path , error ) end module_content end end 
