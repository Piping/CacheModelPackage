require <str> describe Bosh :: Cli :: Command :: Biff do let ( <str> ) { Bosh :: Cli :: Command :: Biff . new } let ( <str> ) { spec_asset ( <str> ) } before ( <str> ) do Bosh :: Cli :: Command :: Biff . send ( <str> , * Bosh :: Cli :: Command :: Biff . private_instance_methods ) end after do biff . delete_temp_diff_files end describe <str> do context <str> do it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect { biff . biff ( template_file ) } . to raise_error ( Bosh :: Cli :: CliError , <str> + <str> ) end it <str> do config_file = spec_asset ( <str> ) golden_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect ( biff ) . to receive ( <str> ) . with ( <str> ) . once biff . biff ( template_file ) expect ( biff . template_output ) . to eq ( File . read ( golden_file ) ) end end context <str> do let ( <str> ) { spec_asset ( <str> ) } it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect ( biff ) . to receive ( <str> ) . with ( <str> ) . once . and_return ( false ) biff . biff ( template_file ) end it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect ( biff ) . to receive ( <str> ) . and_return ( false ) expect ( biff ) . to receive ( <str> ) . twice biff . biff ( template_file ) end it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect { biff . biff ( template_file ) } . to raise_error ( Bosh :: Cli :: CliError , <str> + <str> ) end it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect { biff . biff ( template_file ) } . to raise_error ( Bosh :: Cli :: CliError , <str> + <str> ) end it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect { biff . biff ( template_file ) } . to raise_error ( Bosh :: Cli :: CliError , <str> + <str> ) end it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect { biff . biff ( template_file ) } . to raise_error ( Bosh :: Cli :: CliError , <str> ) end end context <str> do let ( <str> ) { spec_asset ( <str> ) } it <str> do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect ( biff ) . to receive ( <str> ) . with ( <str> ) . once expect ( biff ) . to receive ( <str> ) . with ( <str> template_file <str> + <str> config_file <str> ) . once expect ( biff ) . to receive ( <str> ) . with ( <str> ) . once expect { biff . biff ( template_file ) } . to raise_error Bosh :: Cli :: CliError , <str> end end context <str> do let ( <str> ) { spec_asset ( <str> ) } let ( <str> ) { spec_asset ( <str> ) } before { allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) expect ( biff ) . to receive ( <str> ) . with ( <str> ) . once . and_return ( false ) } subject { biff . biff ( template_file ) Psych . load ( biff . template_output ) [ <str> ] } it <str> do expect ( subject [ <str> ] [ <str> ] ) . to_not be_nil end it <str> do expect ( subject [ <str> ] [ <str> ] ) . to eq <str> end it <str> do expect ( subject [ <str> ] [ <str> ] ) . to eq subject [ <str> ] [ <str> ] end it <str> do expect ( subject [ <str> ] [ <str> ] . length ) . to eq ( <int> ) end it <str> do expect ( subject [ <str> ] [ <str> ] . length ) . to eq ( <int> ) end end end context <str> do before do config_file = spec_asset ( <str> ) allow ( biff ) . to receive ( <str> ) . and_return ( config_file ) biff . setup ( template_file ) end describe <str> do it <str> do obj = { <str> = > { <str> = > { <str> = > <int> } } } expect ( biff . find_in ( <str> , obj ) ) . to eq ( <int> ) end it <str> do obj = { <str> = > { <str> = > { <str> = > false } } } expect ( biff . find_in ( <str> , obj ) ) . to eq ( false ) end it <str> do obj = { <str> = > <int> , <str> = > [ { <str> = > <str> } ] } expect ( biff . find_in ( <str> , obj ) ) . to eq ( { <str> = > <str> } ) end it <str> do obj = { <str> = > { <str> = > { <str> = > <str> } } } expect ( biff . find_in ( <str> , obj ) ) . to be_nil end end describe <str> do before do biff . ip_helper = ip_helper end context <str> do let ( <str> ) do { <str> = > { <str> = > NetAddr :: CIDR . create ( <str> ) } } end it <str> do biff . ip_helper = expect ( biff . ip_range ( - <int> .. - <int> , <str> ) ) . to eq ( <str> ) end end context <str> do let ( <str> ) do { <str> = > { <str> = > [ NetAddr :: CIDR . create ( <str> ) , NetAddr :: CIDR . create ( <str> ) , NetAddr :: CIDR . create ( <str> ) ] } } end it <str> do expect ( biff . ip_range ( ( <int> .. <int> ) , <str> ) ) . to eq ( <str> ) end it <str> do expect ( biff . ip ( <int> , <str> ) ) . to eq ( <str> ) end end end describe <str> do it <str> do obj = { <str> = > <int> , <str> = > [ { <str> = > <str> } ] } expect ( biff . delete_all_except ( obj , <str> ) ) . to eq ( { <str> = > <int> } ) end it <str> do obj = [ { <str> = > <str> } , { <str> = > <str> } , { <str> = > <str> } ] expect ( biff . delete_all_except ( obj , <str> ) ) . to eq ( [ { <str> = > <str> } ] ) end end end end 
