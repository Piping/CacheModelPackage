ARGF = Rubinius :: ARGFClass . new class Module def alias_method ( new_name , current_name ) new_name = Rubinius :: Type . coerce_to_symbol ( new_name ) current_name = Rubinius :: Type . coerce_to_symbol ( current_name ) mod , entry = lookup_method ( current_name , true , false ) if entry method_visibility = visibility_for_aliased_method ( new_name , entry . visibility ) if mod == self and entry . get_method @method_table . store new_name , entry . method_id , entry . method , entry . scope , entry . serial , method_visibility else @method_table . alias new_name , method_visibility , current_name , entry . get_method , mod end Rubinius :: VM . reset_method_cache self , new_name if ai = Rubinius :: Type . singleton_class_object ( self ) Rubinius . privately do ai . singleton_method_added new_name end else method_added new_name end self else if ai = Rubinius :: Type . singleton_class_object ( self ) raise NameError , <str> current_name <str> ai . inspect <str> else thing = Rubinius :: Type . object_kind_of? ( self , Class ) ? <str> : <str> raise NameError , <str> current_name <str> thing <str> self . name <str> end end end private <str> def const_set ( name , value ) name = Rubinius :: Type . coerce_to_constant_name name Rubinius . check_frozen if Rubinius :: Type . object_kind_of? value , Module Rubinius :: Type . set_module_name value , name , self if Object . equal? self value . constant_table . each do | n , c , _ | if Rubinius :: Type . object_kind_of? c , Module and ! c . name Rubinius :: Type . set_module_name c , n , value end end end end @constant_table . store ( name , value , <str> ) Rubinius . inc_global_serial return value end def module_function ( * args ) if kind_of? Class raise TypeError , <str> __class__ <str> end if args . empty? vs = Rubinius :: VariableScope . of_sender vs . method_visibility = <str> else sc = Rubinius :: Type . object_singleton_class ( self ) args . each do | meth | method_name = Rubinius :: Type . coerce_to_symbol meth mod , entry = lookup_method ( method_name ) sc . method_table . store method_name , entry . method_id , entry . method , entry . scope , entry . serial , <str> Rubinius :: VM . reset_method_cache self , method_name set_visibility method_name , <str> end end return self end private <str> def public ( * args ) if args . empty? vs = Rubinius :: VariableScope . of_sender vs . method_visibility = nil else args . each { | meth | set_visibility ( meth , <str> ) } end self end private <str> def private ( * args ) if args . empty? vs = Rubinius :: VariableScope . of_sender vs . method_visibility = <str> else args . each { | meth | set_visibility ( meth , <str> ) } end self end private <str> def protected ( * args ) if args . empty? vs = Rubinius :: VariableScope . of_sender vs . method_visibility = <str> else args . each { | meth | set_visibility ( meth , <str> ) } end self end private <str> def private_class_method ( * args ) args . each do | meth | set_class_visibility ( meth , <str> ) end self end def public_class_method ( * args ) args . each do | meth | set_class_visibility ( meth , <str> ) end self end def include ( * modules ) modules . reverse_each do | mod | if ! mod . kind_of? ( Module ) or mod . kind_of? ( Class ) raise TypeError , <str> mod . class <str> end Rubinius . privately do mod . append_features self end Rubinius . privately do mod . included self end end self end def include_into ( klass ) unless klass . kind_of? Module raise TypeError , <str> klass . class <str> end if kind_of? Class raise TypeError , <str> __class__ <str> end Rubinius :: Type . include_modules_from ( self , klass . origin ) Rubinius :: Type . infect ( klass , self ) self end alias_method <str> , <str> private <str> def attr_reader ( * names ) vis = Rubinius :: VariableScope . of_sender . method_visibility names . each { | name | Rubinius . add_reader name , self , vis } return nil end private <str> def attr_writer ( * names ) vis = Rubinius :: VariableScope . of_sender . method_visibility names . each { | name | Rubinius :: add_writer name , self , vis } return nil end private <str> def attr_accessor ( * names ) vis = Rubinius :: VariableScope . of_sender . method_visibility names . each do | name | Rubinius . add_reader name , self , vis Rubinius . add_writer name , self , vis end return nil end private <str> def undef_method ( * names ) return self if names . empty? names . map! { | name | Rubinius :: Type . coerce_to_symbol name } Rubinius . check_frozen names . each do | name | instance_method name undef_method! name end self end private <str> def undef_method! ( name ) Rubinius . check_frozen name = Rubinius :: Type . coerce_to_symbol ( name ) @method_table . store name , nil , nil , nil , <int> , <str> Rubinius :: VM . reset_method_cache self , name if obj = Rubinius :: Type . singleton_class_object ( self ) Rubinius . privately do obj . singleton_method_undefined ( name ) end else method_undefined ( name ) end name end def remove_method ( * names ) names . each do | name | name = Rubinius :: Type . coerce_to_symbol ( name ) Rubinius . check_frozen unless @method_table . lookup ( name ) raise NameError . new ( <str> name <str> self . name <str> , name ) end @method_table . delete name Rubinius :: VM . reset_method_cache self , name if obj = Rubinius :: Type . singleton_class_object ( self ) Rubinius . privately do obj . singleton_method_removed ( name ) end else method_removed ( name ) end end self end private <str> def name Rubinius :: Type . module_name self end def to_s Rubinius :: Type . module_inspect self end def inspect to_s end end module Rubinius Config = Configuration . new Globals = GlobalVariables . new @add_method_hook = Rubinius :: Hook . new def self . open_class ( name , sup , scope ) if scope under = scope . module else under = Object end open_class_under name , sup , under end def self . open_class_under ( name , sup , mod ) unless Type . object_kind_of? mod , Module raise TypeError , <str> mod . inspect <str> end tbl = mod . constant_table if ! tbl . has_name? ( name ) sup = Object unless sup obj = Class . new sup , name , mod else entry = tbl . lookup ( name ) if entry . visibility == <str> unless self == Object mod_name = <str> Rubinius :: Type . module_name mod <str> end raise NameError , <str> mod_name <str> name <str> end obj = entry . constant if Type . object_kind_of? obj , Autoload obj = begin obj . call ( mod , true ) rescue NameError nil end unless obj supr = sup ? sup : Object obj = Class . new supr , name , mod end end if Type . object_kind_of? obj , Class if sup and obj . superclass != sup raise TypeError , <str> obj . superclass <str> sup <str> end else raise TypeError , <str> name <str> end end return obj end def self . open_module ( name , scope ) if scope under = scope . module else under = Object end open_module_under name , under end def self . open_module_under ( name , mod ) unless Type . object_kind_of? mod , Module raise TypeError , <str> mod . inspect <str> end tbl = mod . constant_table found = tbl . has_name? ( name ) if ! found and mod . equal? Object check = mod . direct_superclass while check tbl = check . constant_table found = tbl . has_name? ( name ) break if found check = check . direct_superclass end end if ! found obj = Module . new mod . const_set name , obj else entry = tbl . lookup ( name ) if entry . visibility == <str> unless self == Object mod_name = <str> Rubinius :: Type . module_name mod <str> end raise NameError , <str> mod_name <str> name <str> end obj = entry . constant if Type . object_kind_of? obj , Autoload obj = obj . call ( mod , true ) unless obj obj = Module . new mod . const_set name , obj end end if Type . object_kind_of? ( obj , Class ) || ! Type . object_kind_of? ( obj , Module ) raise TypeError , <str> name <str> obj . class <str> end end return obj end def self . add_defn_method ( name , executable , constant_scope , vis ) unless Type . object_kind_of? executable , String executable . serial = <int> if executable . respond_to? <str> = if constant_scope and script = constant_scope . current_script if script . eval? executable = executable . dup end end executable . scope = constant_scope end end mod = constant_scope . for_method_definition if ai = Type . singleton_class_object ( mod ) if Type . object_kind_of? ai , Numeric unless Type . object_respond_to? ai , <str> raise TypeError , <str> end end end add_method name , executable , mod , constant_scope , <int> , vis name end def self . attach_method ( name , executable , constant_scope , recv ) unless Type . object_kind_of? executable , String executable . serial = <int> if executable . respond_to? <str> = if constant_scope and script = constant_scope . current_script if script . eval? executable = executable . dup end end executable . scope = constant_scope end end mod = Rubinius :: Type . object_singleton_class recv add_method name , executable , mod , constant_scope , <int> , <str> name end def self . add_reader ( name , mod , vis ) normalized = Rubinius :: Type . coerce_to_symbol ( name ) add_method normalized , AccessVariable . get_ivar ( normalized ) , mod , nil , <int> , vis end def self . add_writer ( name , mod , vis ) normalized = Rubinius :: Type . coerce_to_symbol ( name ) writer_name = <str> normalized <str> . to_sym add_method writer_name , AccessVariable . set_ivar ( normalized ) , mod , nil , <int> , vis end class << self attr_reader <str> end module CAPI INTEGER_PACK_MSWORD_FIRST = <hex> INTEGER_PACK_LSWORD_FIRST = <hex> INTEGER_PACK_MSBYTE_FIRST = <hex> INTEGER_PACK_LSBYTE_FIRST = <hex> INTEGER_PACK_NATIVE_BYTE_ORDER = <hex> INTEGER_PACK_2COMP = <hex> INTEGER_PACK_FORCE_BIGNUM = <hex> INTEGER_PACK_NEGATIVE = <hex> INTEGER_PACK_LITTLE_ENDIAN = INTEGER_PACK_LSWORD_FIRST | INTEGER_PACK_LSBYTE_FIRST INTEGER_PACK_BIG_ENDIAN = INTEGER_PACK_MSWORD_FIRST | INTEGER_PACK_MSBYTE_FIRST INTEGER_PACK_DIGITS = [ <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , ] end class CodeLoader Lock = Object . new @compiled_hook = Rubinius :: Hook . new @loaded_hook = Rubinius :: Hook . new @loaded_features_index = Hash . new ( false ) end module CType Printed = Rubinius :: Tuple . new <int> i = <int> while i < <int> Printed [ i ] = toprint ( i ) i += <int> end Lowered = Rubinius :: Tuple . new <int> i = <int> while i < <int> Lowered [ i ] = tolower ( i ) . chr i += <int> end end module FFI CURRENT_PROCESS = nil TypeDefs = Rubinius :: LookupTable . new add_typedef TYPE_CHAR , <str> add_typedef TYPE_UCHAR , <str> add_typedef TYPE_BOOL , <str> add_typedef TYPE_SHORT , <str> add_typedef TYPE_USHORT , <str> add_typedef TYPE_INT , <str> add_typedef TYPE_UINT , <str> add_typedef TYPE_LONG , <str> add_typedef TYPE_ULONG , <str> add_typedef TYPE_ULONG , <str> add_typedef TYPE_LL , <str> add_typedef TYPE_ULL , <str> add_typedef TYPE_FLOAT , <str> add_typedef TYPE_DOUBLE , <str> add_typedef TYPE_PTR , <str> add_typedef TYPE_VOID , <str> add_typedef TYPE_STRING , <str> add_typedef TYPE_STRPTR , <str> add_typedef TYPE_STRPTR , <str> add_typedef TYPE_CHARARR , <str> add_typedef TYPE_CHAR , <str> add_typedef TYPE_UCHAR , <str> add_typedef TYPE_SHORT , <str> add_typedef TYPE_USHORT , <str> add_typedef TYPE_INT , <str> add_typedef TYPE_UINT , <str> add_typedef TYPE_VARARGS , <str> if Rubinius :: L64 add_typedef TYPE_LONG , <str> add_typedef TYPE_ULONG , <str> else add_typedef TYPE_LL , <str> add_typedef TYPE_ULL , <str> end TypeSizes = Rubinius :: LookupTable . new TypeSizes [ <int> ] = <str> TypeSizes [ <int> ] = <str> TypeSizes [ <int> ] = <str> TypeSizes [ <int> ] = Rubinius :: L64 ? <str> : <str> Rubinius :: Config . section ( <str> ) do | key , value | add_typedef ( find_type ( value . to_sym ) , key . substring ( <int> , key . length ) . to_sym ) end class DynamicLibrary extend FFI :: Library pointer_as_function <str> , FFI :: Pointer :: DLSYM , [ <str> , <str> ] , <str> pointer_as_function <str> , FFI :: Pointer :: DLOPEN , [ <str> , <str> ] , <str> pointer_as_function <str> , FFI :: Pointer :: DLERROR , [ ] , <str> if Rubinius . windows? RTLD_LAZY = <int> RTLD_NOW = <int> RTLD_GLOBAL = <int> RTLD_LOCAL = <int> else RTLD_LAZY = Rubinius :: Config [ <str> ] RTLD_NOW = Rubinius :: Config [ <str> ] RTLD_GLOBAL = Rubinius :: Config [ <str> ] RTLD_LOCAL = Rubinius :: Config [ <str> ] end class << self alias_method <str> , <str> end def initialize ( name , flags = nil ) flags || = RTLD_LAZY | RTLD_GLOBAL unless name @name = <str> @handle = FFI :: Pointer :: CURRENT_PROCESS return end @name = name @handle = DynamicLibrary . open_library name , flags unless @handle orig_error = last_error libnames = FFI :: LIB_SUFFIXES . map { | suffix | <str> name <str> suffix <str> } libnames << <str> name <str> libnames += FFI :: LIB_SUFFIXES . map { | suffix | <str> name <str> suffix <str> } libnames . detect do | libname | @name = libname @handle = DynamicLibrary . open_library libname , flags end end unless @handle orig_error = orig_error . split ( <str> ) . first raise LoadError , <str> name <str> orig_error <str> end end attr_reader <str> def find_symbol ( name ) ptr = DynamicLibrary . find_symbol @handle , name return nil unless ptr FFI :: DynamicLibrary :: Symbol . new ( self , ptr , name ) end alias_method <str> , <str> alias_method <str> , <str> def last_error DynamicLibrary . last_error end CURRENT_PROCESS = DynamicLibrary . new ( nil ) end module Platform ARCH = Rubinius :: CPU LONG_SIZE = Rubinius :: SIZEOF_LONG * <int> ADDRESS_SIZE = Rubinius :: WORDSIZE case when Rubinius . windows? LIBSUFFIX = <str> IS_WINDOWS = true OS = <str> when Rubinius . darwin? LIBSUFFIX = <str> IS_WINDOWS = false OS = <str> else LIBSUFFIX = <str> IS_WINDOWS = false OS = <str> end module File SEPARATOR = <str> ALT_SEPARATOR = nil PATH_SEPARATOR = <str> end module Math extend FFI :: Library attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> def self . log2 ( x ) log10 ( x ) / log10 ( <int> . <int> ) end end module POSIX extend FFI :: Library attach_function <str> , <str> , [ ] , <str> attach_function <str> = , <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , [ ] , <str> attach_function <str> , <str> , [ <str> ] , <str> attach_function <str> , <str> , [ <str> ] , <str> class TimeVal < FFI :: Struct config <str> , <str> , <str> end end end end module EnvironmentAccess extend FFI :: Library attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , [ <str> , <str> , <str> ] , <str> attach_function <str> , [ <str> ] , <str> attach_function <str> , <str> , [ ] , <str> end class EnvironmentVariables include EnvironmentAccess end :: ENV = EnvironmentVariables . new module Metrics class Data MetricsHash = Hash . new end end class Stat S_IRUSR = Rubinius :: Config [ <str> ] S_IWUSR = Rubinius :: Config [ <str> ] S_IXUSR = Rubinius :: Config [ <str> ] S_IRGRP = Rubinius :: Config [ <str> ] S_IWGRP = Rubinius :: Config [ <str> ] S_IXGRP = Rubinius :: Config [ <str> ] S_IROTH = Rubinius :: Config [ <str> ] S_IWOTH = Rubinius :: Config [ <str> ] S_IXOTH = Rubinius :: Config [ <str> ] S_IRUGO = S_IRUSR | S_IRGRP | S_IROTH S_IWUGO = S_IWUSR | S_IWGRP | S_IWOTH S_IXUGO = S_IXUSR | S_IXGRP | S_IXOTH S_IFMT = Rubinius :: Config [ <str> ] S_IFIFO = Rubinius :: Config [ <str> ] S_IFCHR = Rubinius :: Config [ <str> ] S_IFDIR = Rubinius :: Config [ <str> ] S_IFBLK = Rubinius :: Config [ <str> ] S_IFREG = Rubinius :: Config [ <str> ] S_IFLNK = Rubinius :: Config [ <str> ] S_IFSOCK = Rubinius :: Config [ <str> ] S_IFWHT = Rubinius :: Config [ <str> ] S_ISUID = Rubinius :: Config [ <str> ] S_ISGID = Rubinius :: Config [ <str> ] S_ISVTX = Rubinius :: Config [ <str> ] end end code = Class . method_table . lookup ( <str> ) . get_method code . serial = Rubinius :: CompiledCode :: KernelMethodSerial class Class undef_method <str> undef_method <str> undef_method <str> undef_method <str> end class Complex < Numeric I = Complex ( <int> , <int> ) end class NilClass include ImmediateValue end class FalseClass include ImmediateValue end class TrueClass include ImmediateValue end class Symbol include ImmediateValue end class Fixnum include ImmediateValue end DEFAULT_RECORD_SEPARATOR = <str> class Dir PrivateFile = :: File FFI = Rubinius :: FFI module Glob total = Rubinius :: Config [ <str> ] case total when Fixnum if total == <int> @glob_cache = nil else @glob_cache = Rubinius :: LRUCache . new ( total ) end when false @glob_cache = nil else @glob_cache = Rubinius :: LRUCache . new ( <int> ) end end end class Encoding class Converter class TranscodingPath @paths = { } @load_cache = true @cache_valid = false @transcoders_count = TranscodingMap . size end end end Enumerator = Enumerable :: Enumerator module Errno FFI = Rubinius :: FFI end Fiber = Rubinius :: Fiber class File < IO DOSISH = false CASEFOLD_FILESYSTEM = DOSISH FNM_SYSCASE = CASEFOLD_FILESYSTEM ? FNM_CASEFOLD : <int> module Constants F_GETFL = Rubinius :: Config [ <str> ] F_SETFL = Rubinius :: Config [ <str> ] ACCMODE = Rubinius :: Config [ <str> ] F_GETFD = Rubinius :: Config [ <str> ] F_SETFD = Rubinius :: Config [ <str> ] FD_CLOEXEC = Rubinius :: Config [ <str> ] RDONLY = Rubinius :: Config [ <str> ] WRONLY = Rubinius :: Config [ <str> ] RDWR = Rubinius :: Config [ <str> ] CREAT = Rubinius :: Config [ <str> ] EXCL = Rubinius :: Config [ <str> ] NOCTTY = Rubinius :: Config [ <str> ] TRUNC = Rubinius :: Config [ <str> ] APPEND = Rubinius :: Config [ <str> ] NONBLOCK = Rubinius :: Config [ <str> ] SYNC = Rubinius :: Config [ <str> ] LOCK_SH = <hex> LOCK_EX = <hex> LOCK_NB = <hex> LOCK_UN = <hex> BINARY = <hex> F_OK = <int> X_OK = <int> W_OK = <int> R_OK = <int> FNM_NOESCAPE = <hex> FNM_PATHNAME = <hex> FNM_DOTMATCH = <hex> FNM_CASEFOLD = <hex> FNM_EXTGLOB = <hex> FNM_SYSCASE = File :: FNM_SYSCASE if Rubinius . windows? NULL = <str> else NULL = <str> end end Stat = Rubinius :: Stat class Stat @module_name = <str> def world_readable? if mode & S_IROTH == S_IROTH tmp = mode & ( S_IRUGO | S_IWUGO | S_IXUGO ) return Rubinius :: Type . coerce_to tmp , Fixnum , <str> end end def world_writable? if mode & S_IWOTH == S_IWOTH tmp = mode & ( S_IRUGO | S_IWUGO | S_IXUGO ) return Rubinius :: Type . coerce_to tmp , Fixnum , <str> end end end FFI = Rubinius :: FFI SEPARATOR = FFI :: Platform :: File :: SEPARATOR Separator = FFI :: Platform :: File :: SEPARATOR ALT_SEPARATOR = FFI :: Platform :: File :: ALT_SEPARATOR PATH_SEPARATOR = FFI :: Platform :: File :: PATH_SEPARATOR POSIX = FFI :: Platform :: POSIX end class Float FFI = Rubinius :: FFI end class IO include File :: Constants FFI = Rubinius :: FFI SEEK_SET = Rubinius :: Config [ <str> ] SEEK_CUR = Rubinius :: Config [ <str> ] SEEK_END = Rubinius :: Config [ <str> ] end class NilClass include ImmediateValue end class FalseClass include ImmediateValue end class TrueClass include ImmediateValue end class Symbol include ImmediateValue end class Fixnum include ImmediateValue end module Rubinius class Mirror module Process class Execute OFLAGS = { <str> = > :: File :: RDONLY , <str> = > :: File :: RDWR | :: File :: CREAT , <str> = > :: File :: WRONLY | :: File :: CREAT | :: File :: TRUNC , <str> = > :: File :: RDWR | :: File :: CREAT | :: File :: TRUNC , <str> = > :: File :: WRONLY | :: File :: APPEND | :: File :: CREAT , <str> = > :: File :: RDWR | :: File :: APPEND | :: File :: CREAT } end end end end class Regexp IGNORECASE = <int> EXTENDED = <int> MULTILINE = <int> FIXEDENCODING = <int> NOENCODING = <int> DONT_CAPTURE_GROUP = <int> CAPTURE_GROUP = <int> KCODE_NONE = ( <int> << <int> ) KCODE_EUC = ( <int> << <int> ) KCODE_SJIS = ( <int> << <int> ) KCODE_UTF8 = ( <int> << <int> ) KCODE_MASK = KCODE_NONE | KCODE_EUC | KCODE_SJIS | KCODE_UTF8 OPTION_MASK = IGNORECASE | EXTENDED | MULTILINE | FIXEDENCODING | NOENCODING | DONT_CAPTURE_GROUP | CAPTURE_GROUP ESCAPE_TABLE = Rubinius :: Tuple . new ( <int> ) i = <int> while i < <int> ESCAPE_TABLE [ i ] = i . chr i += <int> end ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> ESCAPE_TABLE [ <int> ] = <str> class SourceParser class Part OPTIONS_MAP = { <str> = > Regexp :: MULTILINE , <str> = > Regexp :: IGNORECASE , <str> = > Regexp :: EXTENDED } end PossibleOptions = [ [ MULTILINE , <str> ] , [ IGNORECASE , <str> ] , [ EXTENDED , <str> ] ] end end class String class Rationalizer SPACE = <str> DIGITS = <str> NUMERATOR = <str> DIGITS <str> DIGITS <str> DIGITS <str> DENOMINATOR = DIGITS RATIONAL = <str> SPACE <str> NUMERATOR <str> DENOMINATOR <str> SPACE <str> PATTERN = Regexp . new RATIONAL end class Complexifier SPACE = Rationalizer :: SPACE NUMERATOR = Rationalizer :: NUMERATOR DENOMINATOR = Rationalizer :: DENOMINATOR NUMBER = <str> NUMERATOR <str> DENOMINATOR <str> NUMBERNOS = <str> NUMERATOR <str> DENOMINATOR <str> PATTERN0 = Regexp . new <str> SPACE <str> NUMBER <str> NUMBER <str> SPACE <str> PATTERN1 = Regexp . new <str> SPACE <str> NUMBER <str> SPACE <str> PATTERN2 = Regexp . new <str> SPACE <str> NUMBER <str> NUMBERNOS <str> SPACE <str> end end module Signal Names = { <str> = > <int> } Numbers = { <int> = > <str> } @threads = { } @handlers = { } Rubinius :: Config . section <str> do | key , value | name = key [ <int> , key . length ] number = value . to_i Names [ name ] = number Numbers [ number ] = name end if Names [ <str> ] Names [ <str> ] = Names [ <str> ] end end class Integer < Numeric alias_method <str> , <str> end module Kernel def extend ( * modules ) raise ArgumentError , <str> if modules . empty? Rubinius . check_frozen modules . reverse_each do | mod | Rubinius . privately do mod . extend_object self end Rubinius . privately do mod . extended self end end self end alias_method <str> , <str> def method_missing ( meth , * args ) cls = NoMethodError case Rubinius . method_missing_reason when <str> msg = <str> meth <str> when <str> msg = <str> meth <str> when <str> msg = <str> meth <str> when <str> msg = <str> meth <str> cls = NameError else msg = <str> meth <str> end object_class = Rubinius :: Type . object_class ( self ) if Rubinius :: Type . object_kind_of? ( self , Module ) msg << <str> self <str> object_class <str> elsif nil . equal? ( self ) msg << <str> elsif ImmediateValue === self msg << <str> self <str> object_class <str> else msg << <str> object_class <str> end Kernel . raise ( cls . new ( msg , meth , args , <str> : self ) ) end private <str> def raise ( exc = undefined , msg = undefined , ctx = nil ) skip = false if undefined . equal? exc exc = $! if exc skip = true else exc = RuntimeError . new ( <str> ) end elsif exc . respond_to? <str> if undefined . equal? msg exc = exc . exception else exc = exc . exception msg end raise :: TypeError , <str> unless exc . kind_of? ( :: Exception ) elsif exc . kind_of? String exc = :: RuntimeError . exception exc else raise :: TypeError , <str> end unless skip exc . set_context ctx if ctx exc . capture_backtrace! ( <int> ) unless exc . backtrace? end if $DEBUG and $VERBOSE != nil if loc = exc . locations and loc [ <int> ] pos = loc [ <int> ] . position else pos = Rubinius :: VM . backtrace ( <int> ) [ <int> ] . position end STDERR . puts <str> exc . class <str> pos <str> exc . message <str> end Rubinius . raise_exception exc end module_function <str> alias_method <str> , <str> module_function <str> def to_s Rubinius :: Type . infect ( <str> self . class <str> self . __id__ . to_s ( <int> ) <str> , self ) end Rubinius :: Globals . set_hook ( : $! ) { $! } get = proc do raise TypeError , <str> end set = proc do | key , val | if val . nil? || val . kind_of? ( MatchData ) Rubinius . invoke_primitive <str> , val else raise TypeError , <str> val . class <str> end end Rubinius :: Globals . set_hook ( : $~ , get , set ) Rubinius :: Globals . set_hook ( : $* ) { ARGV } Rubinius :: Globals . set_hook ( : $@ ) { $! ? $! . backtrace : nil } Rubinius :: Globals . set_hook ( : $$ ) { Process . pid } prc = proc { ARGF . filename } Rubinius :: Globals . set_hook ( : $FILENAME , prc , <str> ) write_filter = proc do | key , io | unless io . respond_to? <str> raise :: TypeError , <str> key <str> io . class <str> end io end get = proc { | key | Thread . current [ : $_ ] } set = proc { | key , val | Thread . current [ : $_ ] = val } Rubinius :: Globals . set_hook ( : $_ , get , set ) Rubinius :: Globals . add_alias : $stdout , : $> Rubinius :: Globals . set_filter ( : $stdout , write_filter ) Rubinius :: Globals . set_filter ( : $stderr , write_filter ) get = proc do warn <str> nil end set = proc do | key , io | warn <str> nil end Rubinius :: Globals . set_hook ( : $KCODE , get , set ) set = proc do | key , val | val = Rubinius :: Type . coerce_to val , String , <str> Rubinius . invoke_primitive <str> , val end Rubinius :: Globals . set_hook ( : $0 , <str> , set ) set = proc { | key , val | STDERR . puts ( <str> ) ; val } Rubinius :: Globals . set_hook ( : $SAFE , <str> , set ) Rubinius :: Globals . add_alias ( : $0 , : $PROGRAM_NAME ) Rubinius :: Globals . read_only : $: , : $LOAD_PATH , : $- I Rubinius :: Globals . read_only : $" , : $LOADED_FEATURES Rubinius :: Globals . read_only : $< Rubinius :: Globals [ : $- a ] = false Rubinius :: Globals [ : $- l ] = false Rubinius :: Globals [ : $- p ] = false Rubinius :: Globals . read_only : $- a , : $- l , : $- p Rubinius :: Globals . add_alias : $DEBUG , : $- d Rubinius :: Globals . add_alias : $VERBOSE , : $- v Rubinius :: Globals . add_alias : $VERBOSE , : $- w set_string = proc do | key , value | unless value . nil? or value . kind_of? String raise TypeError , <str> key <str> end Rubinius :: Globals . set! key , value end Rubinius :: Globals . set_filter : $/ , set_string Rubinius :: Globals . add_alias : $/ , : $- <int> Rubinius :: Globals . set_filter : $, , set_string end module Math FFI = Rubinius :: FFI PI = <int> . <int> E = <int> . <int> FactorialTable = [ <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> , <int> . <int> ] if Errno . const_defined? <str> DomainError = Errno :: EDOM elsif Errno . const_defined? <str> DomainError = Errno :: ERANGE else class DomainError < SystemCallError end end end module Process module Constants EXIT_SUCCESS = Rubinius :: Config [ <str> ] || <int> EXIT_FAILURE = Rubinius :: Config [ <str> ] || <int> PRIO_PGRP = Rubinius :: Config [ <str> ] PRIO_PROCESS = Rubinius :: Config [ <str> ] PRIO_USER = Rubinius :: Config [ <str> ] RLIM_INFINITY = Rubinius :: Config [ <str> ] RLIM_SAVED_MAX = Rubinius :: Config [ <str> ] RLIM_SAVED_CUR = Rubinius :: Config [ <str> ] RLIMIT_AS = Rubinius :: Config [ <str> ] RLIMIT_CORE = Rubinius :: Config [ <str> ] RLIMIT_CPU = Rubinius :: Config [ <str> ] RLIMIT_DATA = Rubinius :: Config [ <str> ] RLIMIT_FSIZE = Rubinius :: Config [ <str> ] RLIMIT_MEMLOCK = Rubinius :: Config [ <str> ] RLIMIT_NOFILE = Rubinius :: Config [ <str> ] RLIMIT_NPROC = Rubinius :: Config [ <str> ] RLIMIT_RSS = Rubinius :: Config [ <str> ] RLIMIT_SBSIZE = Rubinius :: Config [ <str> ] RLIMIT_STACK = Rubinius :: Config [ <str> ] RLIMIT_RTPRIO = Rubinius :: Config [ <str> ] RLIMIT_RTTIME = Rubinius :: Config [ <str> ] RLIMIT_SIGPENDING = Rubinius :: Config [ <str> ] RLIMIT_MSGQUEUE = Rubinius :: Config [ <str> ] RLIMIT_NICE = Rubinius :: Config [ <str> ] WNOHANG = <int> WUNTRACED = <int> end include Constants FFI = Rubinius :: FFI class Rlimit < FFI :: Struct config <str> , <str> , <str> end Rubinius :: Globals . read_only : $? Rubinius :: Globals . set_hook ( : $? ) { Thread . current [ : $? ] } end module Rubinius begin is_tty = STDIN . tty? rescue IOError is_tty = false end Terminal = is_tty AtExit = [ ] class Sprinter total = Rubinius :: Config [ <str> ] case total when Fixnum if total == <int> @cache = nil else @cache = Rubinius :: LRUCache . new ( total ) end when false @cache = nil else @cache = Rubinius :: LRUCache . new ( <int> ) end class Builder RADIX = { <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> } PREFIX = { <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } AtomMap = Rubinius :: LookupTable . new AtomMap [ <str> ] = CharAtom AtomMap [ <str> ] = StringAtom AtomMap [ <str> ] = InspectAtom AtomMap [ <str> ] = FloatAtom AtomMap [ <str> ] = FloatAtom AtomMap [ <str> ] = FloatAtom AtomMap [ <str> ] = FloatAtom AtomMap [ <str> ] = FloatAtom AtomMap [ <str> ] = IntegerAtom AtomMap [ <str> ] = IntegerAtom AtomMap [ <str> ] = IntegerAtom AtomMap [ <str> ] = ExtIntegerAtom AtomMap [ <str> ] = ExtIntegerAtom AtomMap [ <str> ] = ExtIntegerAtom AtomMap [ <str> ] = ExtIntegerAtom AtomMap [ <str> ] = ExtIntegerAtom RE = <str> end end end class Struct Struct . new <str> , <str> , <str> , <str> , <str> , <str> , <str> class Tms def initialize ( utime = nil , stime = nil , cutime = nil , cstime = nil , tutime = nil , tstime = nil ) @utime = utime @stime = stime @cutime = cutime @cstime = cstime @tutime = tutime @tstime = tstime end end def self . _specialize ( attrs ) return unless superclass . equal? Struct args , assigns , hashes , vars = [ ] , [ ] , [ ] , [ ] attrs . each_with_index do | name , i | name = <str> name <str> if name =~ <str> assigns << <str> name <str> i <str> vars << name else assigns << <str> name . inspect <str> i <str> vars << <str> name . inspect <str> end args << <str> i <str> hashes << <str> vars [ - <int> ] <str> end code = <<- <str> CODE <str> <str> CODE begin mod = Module . new do module_eval code end include mod rescue SyntaxError end end end class Thread MUTEX_FOR_THREAD_EXCLUSIVE = Mutex . new Thread . initialize_main_thread ( Thread . current ) dg = ThreadGroup :: Default Default = dg dg . add Thread . current end class Time MonthValue = { <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> , <str> = > <int> } end module Rubinius class CodeDB class << self undef <str> end end module FFI module Library def ffi_function_missing ( name , * args ) raise FFI :: NotFoundError , <str> name <str> end end end end 
