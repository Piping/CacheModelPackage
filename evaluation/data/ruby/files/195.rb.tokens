require <str> require <str> [ <str> , <str> ] . each do | call_type | describe <str> call_type <str> do let! ( <str> ) { [ <str> , <str> , <str> , <str> ] } let! ( <str> ) { [ <str> , <str> , <str> , <str> ] } let! ( <str> ) { ( <str> .. <str> ) . to_a } let ( <str> ) { call_type } let ( <str> ) { Puppet :: Parser :: Compiler . new ( Puppet :: Node . new ( <str> ) ) } def collect_notices ( code ) logs = [ ] Puppet [ <str> ] = code Puppet :: Util :: Log . with_destination ( Puppet :: Test :: LogCollector . new ( logs ) ) do compiler . compile yield end logs . select { | log | log . level == <str> } . map { | log | log . message } end def eval_collect_notices ( arg_list , body , call_params ) call = call_params . is_a? ( String ) ? call_params : <str> call_params . join ( <str> ) <str> body = func_bodies [ body ] if body . is_a? ( Integer ) evaluator = Puppet :: Pops :: Parser :: EvaluatingParser . new ( ) collect_notices ( <str> arg_list <str> body <str> ) do evaluator . evaluate_string ( compiler . topscope , call ) end end def epp_eval_collect_notices ( arg_list , body , call_params , code , inline_epp ) body = body . is_a? ( Integer ) ? epp_bodies [ body ] : body . strip source = <str> arg_list <str> body <str> named_params = call_params . reduce ( { } ) { | h , v | h [ param_names [ h . size ] ] = v ; h } collect_notices ( code ) do if inline_epp Puppet :: Pops :: Evaluator :: EppEvaluator . inline_epp ( compiler . topscope , source , named_params ) else file = Tempfile . new ( [ <str> , <str> ] ) begin file . write ( source ) file . close Puppet :: Pops :: Evaluator :: EppEvaluator . epp ( compiler . topscope , file . path , <str> , named_params ) ensure file . unlink end end end end def expect_log ( decl , call_params , result , code = <str> , inline_epp = true ) if call_type == <str> expect ( eval_collect_notices ( decl [ <int> ] , decl [ <int> ] , call_params ) ) . to include ( * result ) else expect ( epp_eval_collect_notices ( decl [ <int> ] , decl [ <int> ] , call_params , code , inline_epp ) ) . to include ( * result ) end end def expect_fail ( decl , call , text , inline_epp = true ) if call_type == <str> expect { eval_collect_notices ( decl [ <int> ] , decl [ <int> ] , call ) } . to raise_error ( StandardError , text ) else expect { epp_eval_collect_notices ( decl [ <int> ] , decl [ <int> ] , call , <str> , inline_epp ) } . to raise_error ( StandardError , text ) end end context <str> do let! ( <str> ) { [ <<- <str> SOURCE <str> , <int> ] <str> SOURCE } it <str> , <str> = > call_type == <str> do expect_fail ( params , [ ] , <str> ) end it <str> , <str> = > call_type == <str> do expect_fail ( params , [ ] , <str> ) end it <str> do expect_log ( params , [ <int> ] , [ <str> , <str> ] ) end it <str> do expect_log ( params , [ <int> , <int> ] , [ <str> , <str> ] ) end end context <str> do let! ( <str> ) { [ <<- <str> SOURCE <str> , <int> ] <str> SOURCE } it <str> do expect_log ( params , [ ] , [ <str> , <str> ] ) end it <str> do expect_log ( params , [ <int> ] , [ <str> , <str> ] ) end it <str> do expect_log ( params , [ <int> , <int> ] , [ <str> , <str> ] ) end end context <str> do let! ( <str> ) { [ <<- <str> SOURCE <str> , <int> ] <str> SOURCE } it <str> do expect_fail ( params , [ <int> ] , <str> ) end it <str> do expect_log ( params , [ <int> , <int> ] , [ <str> , <str> , <str> ] ) end it <str> do expect_log ( params , [ <int> , <int> , <int> ] , [ <str> , <str> , <str> ] ) end end context <str> do it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> ] ) <str> SOURCE end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> ] ) <str> SOURCE end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> , <str> ] ) <str> SOURCE end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> ] ) <str> SOURCE end it <str> , <str> = > call_type == <str> do expect_log ( [ <<- <str> SOURCE <str> , <<- <str> BODY <str> ] , <<- <str> CALL <str> , [ <str> ] ) <str> SOURCE <str> BODY <str> CALL end context <str> , <str> = > call_type == <str> do it <str> do expect_log ( [ <<- <str> SOURCE <str> , <<- <str> BODY <str> ] , [ ] , [ <str> , <str> ] , <<- <str> CODE <str> , true ) <str> SOURCE <str> BODY <str> CODE end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <<- <str> BODY <str> ] , [ ] , [ <str> , <str> ] , <<- <str> CODE <str> , false ) <str> SOURCE <str> BODY <str> CODE end end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> ] ) <str> SOURCE end it <str> call_type <str> do expect_log ( [ <<- <str> SOURCE <str> , call_type == <str> ? <<- <str> BODY <str> : <<- <str> EPP_BODY <str> ] , [ ] , [ <str> ] ) <str> SOURCE <str> BODY <str> EPP_BODY end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> , <str> ] ) <str> SOURCE end end context <str> do it <str> do expect_fail ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , <str> ) <str> SOURCE end it <str> do expect_fail ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , <str> ) <str> SOURCE end it <str> do expect_fail ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , <str> ) <str> SOURCE end it <str> do expect_fail ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , <str> ) <str> SOURCE end end it <str> do expect_log ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , [ <str> , <str> , <str> ] ) <str> SOURCE end it <str> do expect_fail ( [ <<- <str> SOURCE <str> , <int> ] , [ ] , <str> ) <str> SOURCE end end end 
