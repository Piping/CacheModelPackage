require <str> require <str> class Puppet :: SSL :: CertificateRequest < Puppet :: SSL :: Base wraps OpenSSL :: X509 :: Request extend Puppet :: Indirector module AutoSigner def save ( instance , key = nil ) super if ca = Puppet :: SSL :: CertificateAuthority . instance ca . autosign ( instance ) end end end indirects <str> , <str> = > <str> , <str> = > AutoSigner , <str> = > << <str> DOC <str> <str> DOC def self . supported_formats [ <str> ] end def extension_factory @ef || = OpenSSL :: X509 :: ExtensionFactory . new end def generate ( key , options = { } ) Puppet . info <str> name <str> key = key . content if key . is_a? ( Puppet :: SSL :: Key ) common_name = name == Puppet :: SSL :: CA_NAME ? Puppet . settings [ <str> ] : name csr = OpenSSL :: X509 :: Request . new csr . version = <int> csr . subject = OpenSSL :: X509 :: Name . new ( [ [ <str> , common_name ] ] ) csr . public_key = key . public_key if options [ <str> ] add_csr_attributes ( csr , options [ <str> ] ) end if ( ext_req_attribute = extension_request_attribute ( options ) ) csr . add_attribute ( ext_req_attribute ) end signer = Puppet :: SSL :: CertificateSigner . new signer . sign ( csr , key ) raise Puppet :: Error , <str> name <str> unless csr . verify ( key . public_key ) @content = csr Puppet . info <str> digest . name <str> digest . to_hex <str> @content end def ext_value_to_ruby_value ( asn1_arr ) @non_convertable || = [ OpenSSL :: ASN1 :: EndOfContent , OpenSSL :: ASN1 :: BitString , OpenSSL :: ASN1 :: Null , OpenSSL :: ASN1 :: Enumerated , OpenSSL :: ASN1 :: UTCTime , OpenSSL :: ASN1 :: GeneralizedTime , OpenSSL :: ASN1 :: Sequence , OpenSSL :: ASN1 :: Set ] begin asn1_val = OpenSSL :: ASN1 . decode ( asn1_arr . last . value ) rescue OpenSSL :: ASN1 :: ASN1Error return asn1_arr . last . value end if @non_convertable . include? ( asn1_val . class ) then OpenSSL :: X509 :: Extension . new ( asn1_arr . first . value , asn1_val . to_der ) . value else asn1_val . value end end def request_extensions raise Puppet :: Error , <str> unless @content attribute = @content . attributes . find { | x | x . oid == <str> } attribute || = @content . attributes . find { | x | x . oid == <str> } return [ ] unless attribute extensions = unpack_extension_request ( attribute ) index = - <int> extensions . map do | ext_values | index += <int> value = ext_value_to_ruby_value ( ext_values ) case ext_values . length when <int> { <str> = > ext_values [ <int> ] . value , <str> = > value } when <int> { <str> = > ext_values [ <int> ] . value , <str> = > value , <str> = > ext_values [ <int> ] . value } else raise Puppet :: Error , <str> attribute . oid <str> index <str> ext_values . length <str> end end end def subject_alt_names @subject_alt_names || = request_extensions . select { | x | x [ <str> ] == <str> } . map { | x | x [ <str> ] . split ( <str> ) } . flatten . sort . uniq end def custom_attributes x509_attributes = @content . attributes . reject do | attr | PRIVATE_CSR_ATTRIBUTES . include? attr . oid end x509_attributes . map do | attr | { <str> = > attr . oid , <str> = > attr . value . first . value } end end private PRIVATE_CSR_ATTRIBUTES = [ <str> , <str> , <str> , <str> , ] def add_csr_attributes ( csr , csr_attributes ) csr_attributes . each do | oid , value | begin if PRIVATE_CSR_ATTRIBUTES . include? oid raise ArgumentError , <str> oid <str> end encoded = OpenSSL :: ASN1 :: PrintableString . new ( value . to_s ) attr_set = OpenSSL :: ASN1 :: Set . new ( [ encoded ] ) csr . add_attribute ( OpenSSL :: X509 :: Attribute . new ( oid , attr_set ) ) Puppet . debug ( <str> oid <str> attr_set . inspect <str> ) rescue OpenSSL :: X509 :: AttributeError = > e raise Puppet :: Error , <str> oid <str> e . message <str> , e . backtrace end end end private PRIVATE_EXTENSIONS = [ <str> , <str> , ] def extension_request_attribute ( options ) extensions = [ ] if options [ <str> ] options [ <str> ] . each_pair do | oid , value | begin if PRIVATE_EXTENSIONS . include? oid raise Puppet :: Error , <str> oid <str> end ext = OpenSSL :: X509 :: Extension . new ( oid , OpenSSL :: ASN1 :: UTF8String . new ( value . to_s ) . to_der , false ) extensions << ext rescue OpenSSL :: X509 :: ExtensionError = > e raise Puppet :: Error , <str> oid <str> e . message <str> , e . backtrace end end end if options [ <str> ] names = options [ <str> ] . split ( <str> ) . map ( & <str> ) + [ name ] names = names . sort . uniq . map { | name | <str> name <str> } . join ( <str> ) alt_names_ext = extension_factory . create_extension ( <str> , names , false ) extensions << alt_names_ext end unless extensions . empty? seq = OpenSSL :: ASN1 :: Sequence ( extensions ) ext_req = OpenSSL :: ASN1 :: Set ( [ seq ] ) OpenSSL :: X509 :: Attribute . new ( <str> , ext_req ) end end def unpack_extension_request ( attribute ) unless attribute . value . is_a? OpenSSL :: ASN1 :: Set raise Puppet :: Error , <str> attribute . oid <str> attribute . value . class <str> end unless attribute . value . value . is_a? Array raise Puppet :: Error , <str> attribute . oid <str> attribute . value . value . class <str> end unless attribute . value . value . size == <int> raise Puppet :: Error , <str> attribute . oid <str> attribute . value . value . size <str> end unless attribute . value . value . first . is_a? OpenSSL :: ASN1 :: Sequence raise Puppet :: Error , <str> attribute . oid <str> extension . class <str> end unless attribute . value . value . first . value . is_a? Array raise Puppet :: Error , <str> attribute . oid <str> extension . value . class <str> end extensions = attribute . value . value . first . value extensions . map ( & <str> ) end end 
