require_relative <str> require_relative <str> module Gitlab class Upgrader def execute puts <str> current_version . major <str> puts <str> current_version <str> puts <str> current_version . major <str> latest_version <str> if latest_version? puts <str> else puts <str> answer = if ARGV . first == <str> <str> else prompt ( <str> , <str> ) end if answer == <str> upgrade else exit <int> end end end def latest_version? current_version > = latest_version end def current_version @current_version || = Gitlab :: VersionInfo . parse ( current_version_raw ) end def latest_version @latest_version || = Gitlab :: VersionInfo . parse ( latest_version_raw ) end def current_version_raw File . read ( File . join ( gitlab_path , <str> ) ) . strip end def latest_version_raw git_tags = fetch_git_tags git_tags = git_tags . select { | version | version =~ <str> } git_versions = git_tags . map { | tag | Gitlab :: VersionInfo . parse ( tag . match ( <str> ) . to_s ) } <str> git_versions . sort . last . to_s <str> end def fetch_git_tags remote_tags , _ = Gitlab :: Popen . popen ( <str> Gitlab . config . git . bin_path <str> ) remote_tags . split ( <str> ) . grep ( <str> current_version . major <str> ) end def update_commands { <str> = > <str> Gitlab . config . git . bin_path <str> , <str> = > <str> Gitlab . config . git . bin_path <str> , <str> = > <str> Gitlab . config . git . bin_path <str> latest_version <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > <str> } end def env { <str> = > <str> } end def upgrade update_commands . each do | title , cmd | puts title puts <str> cmd . join ( <str> ) <str> if system ( env , * cmd ) puts <str> else puts <str> puts <str> exit <int> end end puts <str> end def gitlab_path File . expand_path ( File . join ( File . dirname ( __FILE__ ) , <str> ) ) end def prompt ( message , choices = nil ) begin print ( message ) answer = STDIN . gets . chomp end while ! choices . include? ( answer ) answer end end end 
