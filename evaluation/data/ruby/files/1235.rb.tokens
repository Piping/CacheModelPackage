begin require_relative <str> require <str> rescue LoadError end module Fiddle module LIBC extend Importer dlload LIBC_SO , LIBM_SO typealias <str> , <str> typealias <str> , <str> extern <str> extern <str> extern <str> extern <str> extern <str> extern <str> extern <str> rescue nil BoundQsortCallback = bind ( <str> ) { | ptr1 , ptr2 | ptr1 [ <int> ] < = > ptr2 [ <int> ] } Timeval = struct [ <str> , <str> , ] Timezone = struct [ <str> , <str> , ] MyStruct = struct [ <str> , <str> , <str> , ] CallCallback = bind ( <str> ) { | ptr1 , ptr2 | f = Function . new ( ptr1 . to_i , [ TYPE_VOIDP ] , TYPE_VOID ) f . call ( ptr2 ) } end class TestImport < TestCase def test_ensure_call_dlload err = assert_raises ( RuntimeError ) do Class . new do extend Importer extern <str> end end assert_match ( <str> , err . message ) end def test_malloc ( ) s1 = LIBC :: Timeval . malloc ( ) s2 = LIBC :: Timeval . malloc ( ) refute_equal ( s1 . to_ptr . to_i , s2 . to_ptr . to_i ) end def test_sizeof ( ) assert_equal ( SIZEOF_VOIDP , LIBC . sizeof ( <str> ) ) assert_equal ( LIBC :: MyStruct . size ( ) , LIBC . sizeof ( LIBC :: MyStruct ) ) assert_equal ( LIBC :: MyStruct . size ( ) , LIBC . sizeof ( LIBC :: MyStruct . malloc ( ) ) ) assert_equal ( SIZEOF_LONG_LONG , LIBC . sizeof ( <str> ) ) end Fiddle . constants . grep ( <str> ) do type = $& size = Fiddle . const_get ( <str> $1 <str> ) name = $1 . sub ( <str> , <str> ) . gsub ( <str> , <str> ) . downcase define_method ( <str> name <str> ) do assert_equal ( size , Fiddle :: Importer . sizeof ( name ) , type ) end end def test_unsigned_result ( ) d = ( <int> ** <int> ) + <int> r = LIBC . strtoul ( d . to_s , <int> , <int> ) assert_equal ( d , r ) end def test_io ( ) if ( RUBY_PLATFORM != BUILD_RUBY_PLATFORM ) return end io_in , io_out = IO . pipe ( ) LIBC . fprintf ( io_out , <str> ) io_out . flush ( ) io_out . close ( ) str = io_in . read ( ) io_in . close ( ) assert_equal ( <str> , str ) end def test_value ( ) i = LIBC . value ( <str> , <int> ) assert_equal ( <int> , i . value ) d = LIBC . value ( <str> , <int> . <int> ) assert_equal ( <int> . <int> , d . value ) ary = LIBC . value ( <str> , [ <int> , <int> , <int> ] ) assert_equal ( [ <int> , <int> , <int> ] , ary . value ) end def test_struct ( ) s = LIBC :: MyStruct . malloc ( ) s . num = [ <int> , <int> , <int> , <int> , <int> ] s . c = <str> . ord s . buff = <str> assert_equal ( [ <int> , <int> , <int> , <int> , <int> ] , s . num ) assert_equal ( <str> . ord , s . c ) assert_equal ( [ <str> . ord , <str> . ord , <str> . ord , <str> . ord , <str> . ord , <str> . ord , <str> . ord ] , s . buff ) end def test_gettimeofday ( ) if ( defined? ( LIBC . gettimeofday ) ) timeval = LIBC :: Timeval . malloc ( ) timezone = LIBC :: Timezone . malloc ( ) LIBC . gettimeofday ( timeval , timezone ) cur = Time . now ( ) assert ( cur . to_i - <int> < = timeval . tv_sec && timeval . tv_sec < = cur . to_i ) end end def test_strcpy ( ) buff = <str> str = LIBC . strcpy ( buff , <str> ) assert_equal ( <str> , buff ) assert_equal ( <str> , str . to_s ) end def test_isdigit r1 = LIBC . isdigit ( <str> . ord ) r2 = LIBC . isdigit ( <str> . ord ) rr = LIBC . isdigit ( <str> . ord ) assert_operator ( r1 , <str> , <int> ) assert_operator ( r2 , <str> , <int> ) assert_equal ( <int> , rr ) end def test_atof r = LIBC . atof ( <str> ) assert_includes ( <int> . <oct> .. <int> . <oct> , r ) end end end if defined? ( Fiddle ) 
