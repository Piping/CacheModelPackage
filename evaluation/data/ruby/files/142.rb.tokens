module Rex module Proto module SMB class Client require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> require <str> CONST = Rex :: Proto :: SMB :: Constants CRYPT = Rex :: Proto :: SMB :: Crypt UTILS = Rex :: Proto :: SMB :: Utils XCEPT = Rex :: Proto :: SMB :: Exceptions EVADE = Rex :: Proto :: SMB :: Evasions NTLM_CRYPT = Rex :: Proto :: NTLM :: Crypt NTLM_CONST = Rex :: Proto :: NTLM :: Constants NTLM_UTILS = Rex :: Proto :: NTLM :: Utils def initialize ( socket ) self . socket = socket self . native_os = <str> self . native_lm = <str> self . encrypt_passwords = true self . extended_security = false self . multiplex_id = rand ( <hex> ) self . process_id = rand ( <hex> ) self . read_timeout = <int> self . evasion_opts = { <str> = > EVADE :: EVASION_NONE , <str> = > EVADE :: EVASION_NONE , <str> = > EVADE :: EVASION_NONE , } self . verify_signature = false self . use_ntlmv2 = false self . usentlm2_session = true self . send_lm = true self . use_lanman_key = false self . send_ntlm = true self . sequence_counter = <int> self . signing_key = <str> self . require_signing = false self . spnopt = { } end def smb_recv data = socket . timed_read ( <int> , self . read_timeout ) if ( data . nil? or data . length < <int> ) raise XCEPT :: NoReply end recv_len = data [ <int> , <int> ] . unpack ( <str> ) [ <int> ] if ( recv_len == <int> ) return data end recv_len += <int> while ( data . length != recv_len ) buff = <str> begin buff << self . socket . timed_read ( recv_len - data . length , self . read_timeout ) rescue Timeout :: Error rescue raise XCEPT :: ReadPacket end if ( buff . nil? or buff . length == <int> ) raise XCEPT :: ReadPacket end data << buff end if self . require_signing && self . signing_key != <str> if self . verify_signature raise XCEPT :: IncorrectSigningError if not CRYPT :: is_signature_correct? ( self . signing_key , self . sequence_counter , data ) end self . sequence_counter += <int> end return data end def smb_send ( data , evasion_level = <int> ) size = <int> wait = <int> if self . require_signing && self . signing_key != <str> data = CRYPT :: sign_smb_packet ( self . signing_key , self . sequence_counter , data ) self . sequence_counter += <int> end begin if ( size == <int> or size > = data . length ) return self . socket . put ( data ) end ret = <int> while ( ( chunk = data . slice! ( <int> , size ) ) . length > <int> ) ret = self . socket . put ( chunk ) if ( wait > <int> ) :: IO . select ( nil , nil , nil , wait ) end end return ret end end def smb_defaults ( packet ) packet . v [ <str> ] = self . multiplex_id . to_i packet . v [ <str> ] = self . last_tree_id . to_i packet . v [ <str> ] = self . auth_user_id . to_i packet . v [ <str> ] = self . process_id . to_i end def smb_recv_and_cache @smb_recv_cache || = [ ] data = self . smb_recv pkt = CONST :: SMB_BASE_PKT . make_struct pkt . from_s ( data ) @smb_recv_cache << [ pkt , data , Time . now ] end def smb_recv_cache_find_match ( expected_type ) clean = [ ] found = nil @smb_recv_cache . each do | cent | pkt , data , tstamp = cent if pkt [ <str> ] [ <str> ] . v [ <str> ] == expected_type found = [ pkt , data ] clean << cent end if Time . now . to_i - tstamp . to_i > <int> clean << cent end break if found end clean . each do | cent | @smb_recv_cache . delete ( cent ) end found end def smb_recv_parse ( expected_type , ignore_errors = false ) pkt = nil data = nil <int> . upto ( <int> ) do | attempt | smb_recv_and_cache pkt , data = smb_recv_cache_find_match ( expected_type ) break if pkt end begin case pkt [ <str> ] [ <str> ] . v [ <str> ] when CONST :: SMB_COM_NEGOTIATE res = smb_parse_negotiate ( pkt , data ) when CONST :: SMB_COM_SESSION_SETUP_ANDX res = smb_parse_session_setup ( pkt , data ) when CONST :: SMB_COM_TREE_CONNECT_ANDX res = smb_parse_tree_connect ( pkt , data ) when CONST :: SMB_COM_TREE_DISCONNECT res = smb_parse_tree_disconnect ( pkt , data ) when CONST :: SMB_COM_NT_CREATE_ANDX res = smb_parse_create ( pkt , data ) when CONST :: SMB_COM_TRANSACTION , CONST :: SMB_COM_TRANSACTION2 res = smb_parse_trans ( pkt , data ) when CONST :: SMB_COM_NT_TRANSACT res = smb_parse_nttrans ( pkt , data ) when CONST :: SMB_COM_NT_TRANSACT_SECONDARY res = smb_parse_nttrans ( pkt , data ) when CONST :: SMB_COM_OPEN_ANDX res = smb_parse_open ( pkt , data ) when CONST :: SMB_COM_WRITE_ANDX res = smb_parse_write ( pkt , data ) when CONST :: SMB_COM_READ_ANDX res = smb_parse_read ( pkt , data ) when CONST :: SMB_COM_CLOSE res = smb_parse_close ( pkt , data ) when CONST :: SMB_COM_DELETE res = smb_parse_delete ( pkt , data ) else raise XCEPT :: InvalidCommand end if ( ignore_errors == false and pkt [ <str> ] [ <str> ] . v [ <str> ] != <int> ) raise XCEPT :: ErrorCode end rescue XCEPT :: InvalidWordCount , XCEPT :: InvalidCommand , XCEPT :: ErrorCode $! . word_count = pkt [ <str> ] [ <str> ] . v [ <str> ] $! . command = pkt [ <str> ] [ <str> ] . v [ <str> ] $! . error_code = pkt [ <str> ] [ <str> ] . v [ <str> ] raise $! end return res end def smb_parse_negotiate ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_NEG_RES_NT_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_NEG_RES_LM_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_NEG_RES_ERR_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_session_setup ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_SETUP_NTLMV2_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_SETUP_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_tree_connect ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_TREE_CONN_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_tree_disconnect ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_TREE_DISCONN_RES_PKT . make_struct res . from_s ( data ) return res end raise XCEPT :: InvalidWordCount end def smb_parse_create ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_CREATE_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_CREATE_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_trans ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_TRANS_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_nttrans ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] > = <int> ) res = CONST :: SMB_NTTRANS_RES_PKT . make_struct res . from_s ( data ) return res end raise XCEPT :: InvalidWordCount end def smb_parse_open ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_OPEN_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_write ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_WRITE_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_read ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_READ_RES_PKT . make_struct res . from_s ( data ) return res end if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_close ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) return pkt end raise XCEPT :: InvalidWordCount end def smb_parse_delete ( pkt , data ) if ( pkt [ <str> ] [ <str> ] . v [ <str> ] == <int> ) res = CONST :: SMB_DELETE_RES_PKT . make_struct res . from_s ( data ) return res end raise XCEPT :: InvalidWordCount end def session_request ( name = <str> , do_recv = true ) name || = <str> data = <str> data << <str> + UTILS . nbname_encode ( name ) + <str> data << <str> + CONST :: NETBIOS_REDIR + <str> pkt = CONST :: NBRAW_PKT . make_struct pkt . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s , EVADE :: EVASION_NONE ) return ret if not do_recv res = self . smb_recv ack = CONST :: NBRAW_PKT . make_struct ack . from_s ( res ) if ( ack . v [ <str> ] != <int> ) raise XCEPT :: NetbiosSessionFailed end return ack end def negotiate ( smb_extended_security = true , do_recv = true ) dialects = [ <str> , <str> ] if ( self . encrypt_passwords ) dialects . push ( <str> , <str> ) end data = dialects . collect { | dialect | <str> + dialect + <str> } . join ( <str> ) pkt = CONST :: SMB_NEG_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_NEGOTIATE pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if ( smb_extended_security ) pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s , EVADE :: EVASION_NONE ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_NEGOTIATE ) idx = ack [ <str> ] . v [ <str> ] if ( idx < <int> or idx > = dialects . length ) return nil end self . dialect = dialects [ idx ] if ( ack [ <str> ] . v [ <str> ] & <hex> != <int> ) self . extended_security = true end self . security_mode = ack [ <str> ] . v [ <str> ] if ( ack [ <str> ] . v [ <str> ] & <hex> != <int> ) self . require_signing = true end if ( ack [ <str> ] . v [ <str> ] != nil ) self . challenge_key = ack [ <str> ] . v [ <str> ] else if ( ack [ <str> ] . v [ <str> ] > <int> ) self . challenge_key = ack [ <str> ] . v [ <str> ] [ <int> , ack [ <str> ] . v [ <str> ] ] end end if ( ack [ <str> ] . v [ <str> ] != nil ) self . session_id = ack [ <str> ] . v [ <str> ] end buf = ack [ <str> ] . v [ <str> ] || <str> if ( self . extended_security and buf . length > = <int> ) self . server_guid = buf [ <int> , <int> ] end if ( self . extended_security and buf . length > <int> ) end self . system_time = UTILS . time_smb_to_unix ( ack [ <str> ] . v [ <str> ] , ack [ <str> ] . v [ <str> ] ) self . system_time = :: Time . at ( self . system_time ) system_zone = ack [ <str> ] . v [ <str> ] if ( system_zone & <hex> ) == <hex> system_zone = ( ( ( ~ system_zone ) & <hex> ) + <int> ) else system_zone *= - <int> end self . system_zone = system_zone * <int> return ack end def session_setup ( * args ) if ( self . dialect =~ <str> ) if ( self . challenge_key ) return self . session_setup_no_ntlmssp ( * args ) end if ( self . extended_security ) return self . session_setup_with_ntlmssp ( * args ) end end return self . session_setup_clear ( * args ) end def session_setup_clear ( user = <str> , pass = <str> , domain = <str> , do_recv = true ) data = [ pass , user , domain , self . native_os , self . native_lm ] . collect { | a | a + <str> } . join ( <str> ) ; pkt = CONST :: SMB_SETUP_LANMAN_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = pass . length + <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX ) if ( ack [ <str> ] . v [ <str> ] != <int> and user . length > <int> ) self . auth_user = user end self . auth_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] info = ack [ <str> ] . v [ <str> ] . split ( <str> ) self . peer_native_os = info [ <int> ] self . peer_native_lm = info [ <int> ] self . default_domain = info [ <int> ] return ack end def session_setup_no_ntlmssp ( user = <str> , pass = <str> , domain = <str> , do_recv = true ) raise XCEPT :: NTLM1MissingChallenge if not self . challenge_key self . require_signing = false if self . require_signing if NTLM_UTILS . is_pass_ntlm_hash? ( pass ) arglm = { <str> = > [ pass . upcase ( ) [ <int> , <int> ] ] . pack ( <str> ) , <str> = > self . challenge_key } hash_lm = NTLM_CRYPT :: lm_response ( arglm ) argntlm = { <str> = > [ pass . upcase ( ) [ <int> , <int> ] ] . pack ( <str> ) , <str> = > self . challenge_key } hash_nt = NTLM_CRYPT :: ntlm_response ( argntlm ) else hash_lm = pass . length > <int> ? NTLM_CRYPT . lanman_des ( pass , self . challenge_key ) : <str> hash_nt = pass . length > <int> ? NTLM_CRYPT . ntlm_md4 ( pass , self . challenge_key ) : <str> end data = <str> data << hash_lm data << hash_nt data << user + <str> data << domain + <str> data << self . native_os + <str> data << self . native_lm + <str> pkt = CONST :: SMB_SETUP_NTLMV1_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = hash_lm . length pkt [ <str> ] . v [ <str> ] = hash_nt . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX ) if ( ack [ <str> ] . v [ <str> ] != <int> and user . length > <int> ) self . auth_user = user end self . auth_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] info = ack [ <str> ] . v [ <str> ] . split ( <str> ) self . peer_native_os = info [ <int> ] self . peer_native_lm = info [ <int> ] self . default_domain = info [ <int> ] return ack end def session_setup_no_ntlmssp_prehash ( user , domain , hash_lm , hash_nt , do_recv = true ) data = <str> data << hash_lm data << hash_nt data << user + <str> data << domain + <str> data << self . native_os + <str> data << self . native_lm + <str> pkt = CONST :: SMB_SETUP_NTLMV1_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = hash_lm . length pkt [ <str> ] . v [ <str> ] = hash_nt . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX ) if ( ack [ <str> ] . v [ <str> ] != <int> and user . length > <int> ) self . auth_user = user end self . auth_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] info = ack [ <str> ] . v [ <str> ] . split ( <str> ) self . peer_native_os = info [ <int> ] self . peer_native_lm = info [ <int> ] self . default_domain = info [ <int> ] return ack end def session_setup_with_ntlmssp ( user = <str> , pass = <str> , domain = <str> , name = nil , do_recv = true ) ntlm_options = { <str> = > self . require_signing , <str> = > self . usentlm2_session , <str> = > self . use_ntlmv2 , <str> = > self . send_lm , <str> = > self . send_ntlm , <str> = > self . use_lanman_key } ntlmssp_flags = NTLM_UTILS . make_ntlm_flags ( ntlm_options ) if ( name == nil ) name = Rex :: Text . rand_text_alphanumeric ( <int> ) end blob = NTLM_UTILS . make_ntlmssp_secblob_init ( domain , name , ntlmssp_flags ) native_data = <str> native_data << self . native_os + <str> native_data << self . native_lm + <str> pkt = CONST :: SMB_SETUP_NTLMV2_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = blob . length pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = blob + native_data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX , true ) if ( ack [ <str> ] [ <str> ] . v [ <str> ] == <hex> ) return session_setup_no_ntlmssp ( user , pass , domain ) end if ( ack [ <str> ] [ <str> ] . v [ <str> ] != <hex> ) failure = XCEPT :: ErrorCode . new failure . word_count = ack [ <str> ] [ <str> ] . v [ <str> ] failure . command = ack [ <str> ] [ <str> ] . v [ <str> ] failure . error_code = ack [ <str> ] [ <str> ] . v [ <str> ] raise failure end data = ack [ <str> ] . v [ <str> ] blob = data . slice! ( <int> , ack [ <str> ] . v [ <str> ] ) info = data . split ( <str> ) self . peer_native_os = info [ <int> ] self . peer_native_lm = info [ <int> ] temp_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] blob_data = NTLM_UTILS . parse_ntlm_type_2_blob ( blob ) self . challenge_key = blob_data [ <str> ] server_ntlmssp_flags = blob_data [ <str> ] self . default_name = blob_data [ <str> ] || <str> self . default_domain = blob_data [ <str> ] || <str> self . dns_host_name = blob_data [ <str> ] || <str> self . dns_domain_name = blob_data [ <str> ] || <str> chall_MsvAvTimestamp = blob_data [ <str> ] || <str> resp_lm , resp_ntlm , client_challenge , ntlm_cli_challenge = NTLM_UTILS . create_lm_ntlm_responses ( user , pass , self . challenge_key , domain , default_name , default_domain , dns_host_name , dns_domain_name , chall_MsvAvTimestamp , self . spnopt , ntlm_options ) enc_session_key = <str> self . sequence_counter = <int> if self . require_signing self . signing_key , enc_session_key , ntlmssp_flags = NTLM_UTILS . create_session_key ( ntlmssp_flags , server_ntlmssp_flags , user , pass , domain , self . challenge_key , client_challenge , ntlm_cli_challenge , ntlm_options ) end blob = NTLM_UTILS . make_ntlmssp_secblob_auth ( domain , name , user , resp_lm , resp_ntlm , enc_session_key , ntlmssp_flags ) pkt = CONST :: SMB_SETUP_NTLMV2_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] [ <str> ] . v [ <str> ] = temp_user_id pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = blob . length pkt [ <str> ] . v [ <str> ] = blob + native_data self . smb_send ( pkt . to_s ) ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX , true ) if ( ack [ <str> ] [ <str> ] . v [ <str> ] != <int> ) if ( user . length == <int> ) self . require_signing = false return self . session_setup_no_ntlmssp ( user , pass , domain ) end failure = XCEPT :: ErrorCode . new failure . word_count = ack [ <str> ] [ <str> ] . v [ <str> ] failure . command = ack [ <str> ] [ <str> ] . v [ <str> ] failure . error_code = ack [ <str> ] [ <str> ] . v [ <str> ] raise failure end self . auth_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] if ( ack [ <str> ] . v [ <str> ] != <int> and user . length > <int> ) self . auth_user = user end return ack end def session_setup_with_ntlmssp_blob ( blob = <str> , do_recv = true , userid = <int> ) native_data = <str> native_data << self . native_os + <str> native_data << self . native_lm + <str> pkt = CONST :: SMB_SETUP_NTLMV2_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] [ <str> ] . v [ <str> ] = userid pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = blob . length pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = blob + native_data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX , false ) end def session_setup_with_ntlmssp_temp ( domain = <str> , name = nil , do_recv = true ) if ( name == nil ) name = Rex :: Text . rand_text_alphanumeric ( <int> ) end blob = NTLM_UTILS . make_ntlmssp_secblob_init ( domain , name ) native_data = <str> native_data << self . native_os + <str> native_data << self . native_lm + <str> pkt = CONST :: SMB_SETUP_NTLMV2_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_SESSION_SETUP_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = blob . length pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = self . session_id pkt [ <str> ] . v [ <str> ] = blob + native_data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_SESSION_SETUP_ANDX , true ) if ( ack [ <str> ] [ <str> ] . v [ <str> ] == <hex> ) return session_setup_no_ntlmssp ( user , pass , domain ) end if ( ack [ <str> ] [ <str> ] . v [ <str> ] != <hex> ) failure = XCEPT :: ErrorCode . new failure . word_count = ack [ <str> ] [ <str> ] . v [ <str> ] failure . command = ack [ <str> ] [ <str> ] . v [ <str> ] failure . error_code = ack [ <str> ] [ <str> ] . v [ <str> ] raise failure end data = ack [ <str> ] . v [ <str> ] blob = data . slice! ( <int> , ack [ <str> ] . v [ <str> ] ) info = data . split ( <str> ) self . peer_native_os = info [ <int> ] self . peer_native_lm = info [ <int> ] self . auth_user_id = ack [ <str> ] [ <str> ] . v [ <str> ] cidx = blob . index ( <str> ) if ( cidx == - <int> ) raise XCEPT :: NTLM2MissingChallenge end self . challenge_key = blob [ cidx + <int> , <int> ] return ack end def tree_connect ( share = <str> , pass = <str> , do_recv = true ) data = [ pass , share , <str> ] . collect { | a | a + <str> } . join ( <str> ) ; pkt = CONST :: SMB_TREE_CONN_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TREE_CONNECT_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = pass . length + <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_TREE_CONNECT_ANDX ) self . last_tree_id = ack [ <str> ] [ <str> ] . v [ <str> ] return ack end def tree_disconnect ( tree_id = self . last_tree_id , do_recv = true ) pkt = CONST :: SMB_TREE_DISCONN_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TREE_DISCONNECT pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] [ <str> ] . v [ <str> ] = tree_id ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_TREE_DISCONNECT ) if ( tree_id == self . last_tree_id ) self . last_tree_id = <int> end return ack end def create_pipe ( filename , disposition = <int> , impersonation = <int> ) self . create ( filename ) end def create ( filename , disposition = <int> , impersonation = <int> , do_recv = true ) pkt = CONST :: SMB_CREATE_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_NT_CREATE_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = filename . length pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = impersonation pkt [ <str> ] . v [ <str> ] = disposition pkt [ <str> ] . v [ <str> ] = filename + <str> ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_NT_CREATE_ANDX ) if ( ack [ <str> ] . v [ <str> ] > <int> ) self . last_file_id = ack [ <str> ] . v [ <str> ] end return ack end def delete ( filename , tree_id = self . last_tree_id , do_recv = true ) pkt = CONST :: SMB_DELETE_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_DELETE pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = tree_id pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = filename + <str> ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_DELETE ) return ack end def open ( filename , mode = <hex> , access = <hex> , do_recv = true ) pkt = CONST :: SMB_OPEN_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_OPEN_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = access pkt [ <str> ] . v [ <str> ] = <hex> pkt [ <str> ] . v [ <str> ] = mode pkt [ <str> ] . v [ <str> ] = filename + <str> ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_OPEN_ANDX ) if ( ack [ <str> ] . v [ <str> ] > <int> ) self . last_file_id = ack [ <str> ] . v [ <str> ] end return ack end def close ( file_id = self . last_file_id , tree_id = self . last_tree_id , do_recv = true ) pkt = CONST :: SMB_CLOSE_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_CLOSE pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = tree_id pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = file_id pkt [ <str> ] . v [ <str> ] = - <int> ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_CLOSE ) return ack end def write ( file_id = self . last_file_id , offset = <int> , data = <str> , do_recv = true ) pkt = CONST :: SMB_WRITE_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) data_offset = pkt . to_s . length - <int> filler = EVADE . make_offset_filler ( evasion_opts [ <str> ] , <int> - data . length - data_offset ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_WRITE_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = file_id pkt [ <str> ] . v [ <str> ] = offset pkt [ <str> ] . v [ <str> ] = - <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = data . length pkt [ <str> ] . v [ <str> ] = ( data . length % <int> ) . to_i pkt [ <str> ] . v [ <str> ] = data_offset + filler . length pkt [ <str> ] . v [ <str> ] = filler + data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_WRITE_ANDX ) return ack end def read ( file_id = self . last_file_id , offset = <int> , data_length = <int> , do_recv = true ) pkt = CONST :: SMB_READ_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_READ_ANDX pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = file_id pkt [ <str> ] . v [ <str> ] = offset pkt [ <str> ] . v [ <str> ] = ( data_length % <int> ) . to_i pkt [ <str> ] . v [ <str> ] = data_length pkt [ <str> ] . v [ <str> ] = - <int> ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_READ_ANDX , true ) err = ack [ <str> ] [ <str> ] . v [ <str> ] if ( err != <int> && err != CONST :: SMB_ERROR_BUFFER_OVERFLOW ) failure = XCEPT :: ErrorCode . new failure . word_count = ack [ <str> ] [ <str> ] . v [ <str> ] failure . command = ack [ <str> ] [ <str> ] . v [ <str> ] failure . error_code = ack [ <str> ] [ <str> ] . v [ <str> ] raise failure end return ack end def trans_named_pipe ( file_id , data = <str> , no_response = nil ) pipe = EVADE . make_trans_named_pipe_name ( evasion_opts [ <str> ] ) self . trans ( pipe , <str> , data , <int> , [ <hex> , file_id ] . pack ( <str> ) , no_response ) end def trans_mailslot ( name , data = <str> ) self . trans_maxzero ( name , <str> , data , <int> , [ <int> , <int> , <int> ] . pack ( <str> ) , true ) end def trans ( pipe , param = <str> , body = <str> , setup_count = <int> , setup_data = <str> , no_response = false , do_recv = true ) if ( pipe [ - <int> , <int> ] != <str> ) pipe << <str> end pkt = CONST :: SMB_TRANS_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) mlen = <int> xlen = pipe . length + param . length + body . length filler1 = <str> filler2 = <str> if ( xlen < mlen ) filler1 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) filler2 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) end data = pipe + filler1 + param + filler2 + body if ( data . length > mlen ) end base_offset = pkt . to_s . length + ( setup_count * <int> ) - <int> param_offset = base_offset + pipe . length + filler1 . length data_offset = param_offset + filler2 . length + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TRANSACTION pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> + setup_count pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = setup_count pkt [ <str> ] . v [ <str> ] = setup_data pkt [ <str> ] . v [ <str> ] = data if no_response pkt [ <str> ] . v [ <str> ] = <int> end ret = self . smb_send ( pkt . to_s ) return ret if no_response or not do_recv self . smb_recv_parse ( CONST :: SMB_COM_TRANSACTION ) end def trans_maxzero ( pipe , param = <str> , body = <str> , setup_count = <int> , setup_data = <str> , no_response = false , do_recv = true ) if ( pipe [ - <int> ] != <int> ) pipe << <str> end pkt = CONST :: SMB_TRANS_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) mlen = <int> xlen = pipe . length + param . length + body . length filler1 = <str> filler2 = <str> if ( xlen < mlen ) filler1 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) filler2 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) end data = pipe + filler1 + param + filler2 + body if ( data . length > mlen ) end base_offset = pkt . to_s . length + ( setup_count * <int> ) - <int> param_offset = base_offset + pipe . length + filler1 . length data_offset = param_offset + filler2 . length + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TRANSACTION pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> + setup_count pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = setup_count pkt [ <str> ] . v [ <str> ] = setup_data pkt [ <str> ] . v [ <str> ] = data if no_response pkt [ <str> ] . v [ <str> ] = <int> end ret = self . smb_send ( pkt . to_s ) return ret if no_response or not do_recv self . smb_recv_parse ( CONST :: SMB_COM_TRANSACTION ) end def trans_nonull ( pipe , param = <str> , body = <str> , setup_count = <int> , setup_data = <str> , no_response = false , do_recv = true ) pkt = CONST :: SMB_TRANS_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) mlen = <int> xlen = pipe . length + param . length + body . length filler1 = <str> filler2 = <str> if ( xlen < mlen ) filler1 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) filler2 = EVADE . make_offset_filler ( evasion_opts [ <str> ] , ( mlen - xlen ) / <int> ) end data = pipe + filler1 + param + filler2 + body if ( data . length > mlen ) end base_offset = pkt . to_s . length + ( setup_count * <int> ) - <int> param_offset = base_offset + pipe . length + filler1 . length data_offset = param_offset + filler2 . length + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TRANSACTION pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> + setup_count pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = setup_count pkt [ <str> ] . v [ <str> ] = setup_data pkt [ <str> ] . v [ <str> ] = data if no_response pkt [ <str> ] . v [ <str> ] = <int> end ret = self . smb_send ( pkt . to_s ) return ret if no_response or not do_recv self . smb_recv_parse ( CONST :: SMB_COM_TRANSACTION ) end def trans2 ( subcommand , param = <str> , body = <str> , do_recv = true ) setup_count = <int> setup_data = [ subcommand ] . pack ( <str> ) data = param + body pkt = CONST :: SMB_TRANS2_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) base_offset = pkt . to_s . length + ( setup_count * <int> ) - <int> param_offset = base_offset data_offset = param_offset + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_TRANSACTION2 pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> + setup_count pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = setup_count pkt [ <str> ] . v [ <str> ] = setup_data pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_TRANSACTION2 ) return ack end def nttrans ( subcommand , param = <str> , body = <str> , setup_count = <int> , setup_data = <str> , do_recv = true ) data = param + body pkt = CONST :: SMB_NTTRANS_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) base_offset = pkt . to_s . length + ( setup_count * <int> ) - <int> param_offset = base_offset data_offset = param_offset + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_NT_TRANSACT pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> + setup_count pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = setup_count pkt [ <str> ] . v [ <str> ] = setup_data pkt [ <str> ] . v [ <str> ] = subcommand pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_NT_TRANSACT ) return ack end def nttrans_secondary ( param = <str> , body = <str> , do_recv = true ) data = param + body pkt = CONST :: SMB_NTTRANS_SECONDARY_PKT . make_struct self . smb_defaults ( pkt [ <str> ] [ <str> ] ) base_offset = pkt . to_s . length - <int> param_offset = base_offset data_offset = param_offset + param . length pkt [ <str> ] [ <str> ] . v [ <str> ] = CONST :: SMB_COM_NT_TRANSACT_SECONDARY pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> if self . require_signing pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> else pkt [ <str> ] [ <str> ] . v [ <str> ] = <hex> end pkt [ <str> ] [ <str> ] . v [ <str> ] = <int> pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = param . length pkt [ <str> ] . v [ <str> ] = param_offset pkt [ <str> ] . v [ <str> ] = body . length pkt [ <str> ] . v [ <str> ] = data_offset pkt [ <str> ] . v [ <str> ] = data ret = self . smb_send ( pkt . to_s ) return ret if not do_recv ack = self . smb_recv_parse ( CONST :: SMB_COM_NT_TRANSACT_SECONDARY ) return ack end def queryfs ( level ) parm = [ level ] . pack ( <str> ) begin resp = trans2 ( CONST :: TRANS2_QUERY_FS_INFO , parm , <str> ) pcnt = resp [ <str> ] . v [ <str> ] dcnt = resp [ <str> ] . v [ <str> ] poff = resp [ <str> ] . v [ <str> ] doff = resp [ <str> ] . v [ <str> ] resp_rpkt = resp . to_s resp_rpkt . slice! ( <int> , <int> ) resp_parm = resp_rpkt [ poff , pcnt ] resp_data = resp_rpkt [ doff , dcnt ] return resp_data rescue :: Exception raise $! end end def symlink ( src , dst ) parm = [ <int> , <hex> ] . pack ( <str> ) + src + <str> begin resp = trans2 ( CONST :: TRANS2_SET_PATH_INFO , parm , dst + <str> ) pcnt = resp [ <str> ] . v [ <str> ] dcnt = resp [ <str> ] . v [ <str> ] poff = resp [ <str> ] . v [ <str> ] doff = resp [ <str> ] . v [ <str> ] resp_rpkt = resp . to_s resp_rpkt . slice! ( <int> , <int> ) resp_parm = resp_rpkt [ poff , pcnt ] resp_data = resp_rpkt [ doff , dcnt ] return resp_data rescue :: Exception raise $! end end def queryfs_info_allocation data = queryfs ( CONST :: SMB_INFO_ALLOCATION ) head = <str> vals = data . unpack ( <str> ) info = { } head . each_index { | i | info [ head [ i ] ] = vals [ i ] } return info end def queryfs_info_volume data = queryfs ( CONST :: SMB_INFO_VOLUME ) vals = data . unpack ( <str> ) return { <str> = > vals [ <int> ] , <str> = > vals [ <int> ] [ <int> , vals [ <int> ] ] . gsub ( <str> , <str> ) } end def queryfs_fs_volume data = queryfs ( CONST :: SMB_QUERY_FS_VOLUME_INFO ) vals = data . unpack ( <str> ) return { <str> = > ( vals [ <int> ] << <int> ) + vals [ <int> ] , 
