require <str> module Rex module IO class RingBuffer attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> attr_accessor <str> def initialize ( socket , opts = { } ) self . size = opts [ <str> ] || ( <int> * <int> ) self . fd = socket self . seq = <int> self . beg = <int> self . cur = <int> self . queue = Array . new ( self . size ) self . mutex = Mutex . new end def inspect <str> size <str> fd <str> seq <str> beg <str> cur <str> end def start_monitor self . monitor = monitor_thread if not self . monitor end def stop_monitor self . monitor . kill if self . monitor self . monitor = nil end def monitor_thread Thread . new do begin while self . fd buff = self . fd . get_once ( - <int> , <int> . <int> ) next if not buff store_data ( buff ) end rescue :: Exception = > e self . monitor_thread_error = e end end end def put ( data , opts = { } ) self . fd . put ( data , opts = { } ) end def clear_data self . mutex . synchronize do self . seq = <int> self . beg = <int> self . cur = <int> self . queue = Array . new ( self . size ) end end def store_data ( data ) self . mutex . synchronize do loc = <int> if self . seq > <int> loc = ( self . cur + <int> ) % self . size if loc < = self . beg self . beg = ( self . beg + <int> ) % self . size end end self . queue [ loc ] = [ self . seq += <int> , data ] self . cur = loc end end def read_data ( ptr = nil ) self . mutex . synchronize do return [ nil , nil ] if not self . queue [ self . beg ] ptr || = self . queue [ self . beg ] [ <int> ] return [ nil , nil ] if not ptr if ptr < self . queue [ self . beg ] [ <int> ] ptr = self . queue [ self . beg ] [ <int> ] end dis = self . seq - ptr return [ nil , nil ] if dis < <int> off = ptr - self . queue [ self . beg ] [ <int> ] set = ( self . beg + off ) % self . size buff = <str> cnt = <int> lst = ptr ptr . upto ( self . seq ) do | i | block = self . queue [ ( set + cnt ) % self . size ] lst , data = block [ <int> ] , block [ <int> ] buff += data cnt += <int> end return [ lst + <int> , buff ] end end def base_sequence self . mutex . synchronize do return <int> if not self . queue [ self . beg ] return self . queue [ self . beg ] [ <int> ] end end def last_sequence self . seq end def create_stream Stream . new ( self ) end def select :: IO . select ( [ self . fd ] , nil , [ self . fd ] , <int> . <int> ) end def wait ( seq ) nseq = nil while not nseq nseq , data = read_data ( seq ) select end end def wait_for ( seq , timeout = <int> ) begin :: Timeout . timeout ( timeout ) do wait ( seq ) end rescue :: Timeout :: Error end end class Stream attr_accessor <str> attr_accessor <str> attr_accessor <str> def initialize ( ring ) self . ring = ring self . seq = ring . base_sequence self . buff = <str> end def read ( len = nil ) if len and self . buff . length > = len data = self . buff . slice! ( <int> , len ) return data end while true lseq , data = self . ring . read_data ( self . seq ) return if not lseq self . seq = lseq self . buff << data if len if self . buff . length > = len return self . buff . slice! ( <int> , len ) else IO . select ( nil , nil , nil , <int> . <int> ) next end end data = self . buff self . buff = <str> return data break end end def write ( data ) self . ring . write ( data ) end end end end end 
