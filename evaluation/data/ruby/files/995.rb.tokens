if defined? ( $tree_demo ) && $tree_demo $tree_demo . destroy $tree_demo = nil end $tree_demo = TkToplevel . new { | w | title ( <str> ) iconname ( <str> ) positionWindow ( w ) } base_frame = TkFrame . new ( $tree_demo ) . pack ( <str> = > <str> , <str> = > true ) Ttk :: Label . new ( base_frame , <str> = > $font , <str> = > <str> , <str> = > <str> , <str> = > <str> , <str> = > [ <int> , <int> , <int> , <int> ] , <str> = > << <str> EOL <str> ) . pack ( <str> = > <str> ) <str> EOL Ttk :: Frame . new ( base_frame ) { | frame | sep = Ttk :: Separator . new ( frame ) Tk . grid ( sep , <str> = > <int> , <str> = > <int> , <str> = > <str> , <str> = > <int> ) TkGrid ( <str> , Ttk :: Button . new ( frame , <str> = > <str> , <str> = > $image [ <str> ] , <str> = > <str> , <str> = > proc { showCode <str> } ) , Ttk :: Button . new ( frame , <str> = > <str> , <str> = > $image [ <str> ] , <str> = > <str> , <str> = > proc { $tree_demo . destroy $tree_demo = nil } ) , <str> = > <int> , <str> = > <int> ) grid_columnconfigure ( <int> , <str> = > <int> ) pack ( <str> = > <str> , <str> = > <str> ) } def populate_roots ( tree ) TkComm . simplelist ( Tk . tk_call ( <str> , <str> ) ) . sort . each { | dir | populate_tree ( tree , tree . insert ( nil , <str> , <str> = > dir , <str> = > [ dir , <str> ] ) ) } end def populate_tree ( tree , node ) return if tree . get ( node , <str> ) != <str> path = tree . get ( node , <str> ) tree . delete ( tree . children ( node ) ) Dir . glob ( <str> path <str> ) . sort . each { | f | type = File . ftype ( f ) rescue nil id = tree . insert ( node , <str> , <str> = > File . basename ( f ) , <str> = > [ f , type ] ) . id if type == <str> tree . insert ( id , <int> , <str> = > <str> ) tree . itemconfigure ( id , <str> = > File . basename ( f ) ) elsif type == <str> size = File . size ( f ) if size > = <int> * <int> * <int> size = <str> % ( size . to_f / <int> / <int> / <int> ) elsif size > = <int> * <int> size = <str> % ( size . to_f / <int> / <int> ) elsif size > = <int> size = <str> % ( size . to_f / <int> ) else size = <str> % ( size . to_f / <int> ) end tree . set ( id , <str> , size ) end } tree . set ( node , <str> , <str> ) end tree = Ttk :: Treeview . new ( base_frame , <str> = > <str> , <str> = > [ <str> ] ) if Tk . windowingsystem != <str> vsb = tree . yscrollbar ( Ttk :: Scrollbar . new ( base_frame ) ) hsb = tree . xscrollbar ( Ttk :: Scrollbar . new ( base_frame ) ) else vsb = tree . yscrollbar ( Tk :: Scrollbar . new ( base_frame ) ) hsb = tree . xscrollbar ( Tk :: Scrollbar . new ( base_frame ) ) end tree . heading_configure ( <str> , <str> = > <str> ) tree . heading_configure ( <str> , <str> = > <str> ) tree . column_configure ( <str> , <str> = > <int> , <str> = > <int> ) populate_roots ( tree ) tree . bind ( <str> , <str> ) { | w | populate_tree ( w , w . focus_item ) } container = Ttk :: Frame . new ( base_frame ) . pack ( <str> = > <str> , <str> = > true ) container . lower Tk . grid ( tree , vsb , <str> = > container , <str> = > <str> ) Tk . grid ( hsb , <str> = > container , <str> = > <str> ) container . grid_columnconfigure ( <int> , <str> = > <int> ) container . grid_rowconfigure ( <int> , <str> = > <int> ) 
