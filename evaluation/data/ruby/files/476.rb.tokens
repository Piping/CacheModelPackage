require <str> require Rails . root . join ( <str> , <str> , <str> ) describe Comment , <str> = > <str> do let ( <str> ) { alice . aspects . first } let ( <str> ) { bob . post ( <str> , <str> : <str> , <str> : bob . aspects . first . id ) } let ( <str> ) { alice . comment! ( status_bob , <str> ) } describe <str> do it <str> do comment_alice expect { comment_alice . destroy } . to change { Participation . count } . by ( - <int> ) end it <str> do alice . comment! ( status_bob , <str> ) comment_alice . destroy participations = Participation . where ( <str> : comment_alice . commentable_id , <str> : comment_alice . author_id ) expect ( participations . first . count ) . to eq ( <int> ) end end describe <str> do it <str> do expect ( comment_alice . notification_type ( bob , alice . person ) ) . to eq ( Notifications :: CommentOnPost ) end it <str> do eve . participate! status_bob expect ( comment_alice . notification_type ( eve , alice . person ) ) . to eq ( Notifications :: AlsoCommented ) end it <str> do expect ( comment_alice . notification_type ( eve , alice . person ) ) . to be false end context <str> do let ( <str> ) { eve . comment! ( status_bob , <str> ) } before do comment_alice end it <str> do expect ( comment_eve . notification_type ( eve , alice . person ) ) . to eq ( false ) end it <str> do expect ( comment_eve . notification_type ( alice , alice . person ) ) . to eq ( Notifications :: AlsoCommented ) end end end describe <str> do it <str> do bob . comment! ( status_bob , <str> ) expect ( status_bob . reload . comments . first . text ) . to eq ( <str> ) end it <str> do comment_alice expect ( status_bob . reload . comments . first . text ) . to eq ( <str> ) end it <str> do expect { comment_alice } . to change { Comment . count } . by ( <int> ) end it <str> do comment_alice participations = Participation . where ( <str> : comment_alice . commentable_id , <str> : comment_alice . author_id ) expect ( participations . count ) . to eq ( <int> ) end it <str> do begin alice . comment! ( status_bob , <str> ) rescue ActiveRecord :: RecordInvalid end participations = Participation . where ( <str> : status_bob , <str> : alice . person . id ) expect ( participations . count ) . to eq ( <int> ) end end describe <str> do it <str> do expect { comment_alice } . to change { status_bob . reload . comments_count } . by ( <int> ) end end describe <str> do let ( <str> ) { create ( <str> ) } let ( <str> ) { commenter . aspects . create ( name : <str> ) } let ( <str> ) { alice . post <str> , <str> : <str> , <str> : alices_aspect . id } let ( <str> ) { commenter . comment! ( post , <str> ) } let ( <str> ) { comment . to_xml . to_s } before do connect_users ( alice , alices_aspect , commenter , commenter_aspect ) end it <str> do expect ( xml . include? ( commenter . diaspora_handle ) ) . to be true end it <str> do expect ( xml ) . to include ( post . guid ) end describe <str> do let ( <str> ) { Comment . from_xml ( xml ) } it <str> do expect ( marshalled_comment . author ) . to eq ( commenter . person ) end it <str> do expect ( marshalled_comment . post ) . to eq ( post ) end it <str> do guid = post . guid marshalled_comment post . destroy expect_any_instance_of ( Comment ) . to receive ( <str> ) . with ( guid ) . and_return ( nil ) Comment . from_xml ( xml ) end end end describe <str> do let ( <str> ) { build ( <str> , <str> : remote_raphael ) } let ( <str> ) { local_luke . post <str> , <str> : <str> , <str> : local_luke . aspects . first } let ( <str> ) { local_luke . comment! ( local_parent , <str> ) } let ( <str> ) { local_leia . build_comment ( <str> : <str> , <str> : local_parent ) } let ( <str> ) { object_by_parent_author . dup } let ( <str> ) { local_luke . comment! ( remote_parent , <str> ) } before do @object_by_parent_author = object_by_parent_author @object_by_recipient = object_by_recipient @dup_object_by_parent_author = dup_object_by_parent_author @object_on_remote_parent = object_on_remote_parent end let ( <str> ) { alice . build_comment ( <str> : status_bob , <str> : <str> ) } it_should_behave_like <str> end describe <str> do let ( <str> ) { build ( <str> ) } before do @object = object end it_should_behave_like <str> end end 
