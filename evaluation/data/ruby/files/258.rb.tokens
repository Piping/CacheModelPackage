require <str> class Shell class SystemCommand < Filter def initialize ( sh , command , * opts ) if t = opts . find { | opt | ! opt . kind_of? ( String ) && opt . class } Shell . Fail Error :: TypeError , t . class , <str> end super ( sh ) @command = command @opts = opts @input_queue = Queue . new @pid = nil sh . process_controller . add_schedule ( self ) end attr_reader <str> alias name command def wait? @shell . process_controller . waiting_job? ( self ) end def active? @shell . process_controller . active_job? ( self ) end def input = ( inp ) super if active? start_export end end def start notify ( [ @command , * @opts ] . join ( <str> ) ) @pid , @pipe_in , @pipe_out = @shell . process_controller . sfork ( self ) { Dir . chdir @shell . pwd $0 = @command exec ( @command , * @opts ) } if @input start_export end start_import end def flush @pipe_out . flush if @pipe_out and ! @pipe_out . closed? end def terminate begin @pipe_in . close rescue IOError end begin @pipe_out . close rescue IOError end end def kill ( sig ) if @pid Process . kill ( sig , @pid ) end end def start_import notify <str> , @shell . debug? _eop = true Thread . start { begin while l = @pipe_in . gets @input_queue . push l end _eop = false rescue Errno :: EPIPE _eop = false ensure if ! ProcessController :: USING_AT_EXIT_WHEN_PROCESS_EXIT and _eop notify ( <str> , <str> , <str> ) redo end notify <str> , @shell . debug? @input_queue . push <str> @pipe_in . close end } end def start_export notify <str> , @shell . debug? _eop = true Thread . start { begin @input . each do | l | ProcessController :: block_output_synchronize do @pipe_out . print l end end _eop = false rescue Errno :: EPIPE , Errno :: EIO _eop = false ensure if ! ProcessController :: USING_AT_EXIT_WHEN_PROCESS_EXIT and _eop notify ( <str> , <str> , <str> ) redo end notify <str> , @shell . debug? @pipe_out . close end } end alias super_each each def each ( rs = nil ) while ( l = @input_queue . pop ) != <str> yield l end end def notify ( * opts ) @shell . notify ( * opts ) do | mes | yield mes if iterator? mes . gsub! ( <str> , <str> @command <str> @pid <str> ) mes . gsub! ( <str> , <str> @command <str> ) mes . gsub! ( <str> , <str> @pid <str> ) mes end end end end 
