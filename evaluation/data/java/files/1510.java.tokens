package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . NavigableSetTestSuiteBuilder ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . TestSetGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestSuite ; import java . math . BigInteger ; import java . util . List ; import java . util . Set ; @GwtIncompatible ( <str> ) public class ImmutableRangeSetTest extends AbstractRangeSetTest { static final class ImmutableRangeSetIntegerAsSetGenerator implements TestSetGenerator < Integer > { @Override public SampleElements < Integer > samples ( ) { return new SampleElements < Integer > ( <int> , <int> , <int> , <int> , <int> ) ; } @Override public Integer [ ] createArray ( int length ) { return new Integer [ length ] ; } @Override public Iterable < Integer > order ( List < Integer > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } @Override public Set < Integer > create ( Object . . . elements ) { ImmutableRangeSet . Builder < Integer > builder = ImmutableRangeSet . builder ( ) ; for ( Object o : elements ) { Integer i = ( Integer ) o ; builder . add ( Range . singleton ( i ) ) ; } return builder . build ( ) . asSet ( DiscreteDomain . integers ( ) ) ; } } static final class ImmutableRangeSetBigIntegerAsSetGenerator implements TestSetGenerator < BigInteger > { @Override public SampleElements < BigInteger > samples ( ) { return new SampleElements < BigInteger > ( BigInteger . valueOf ( <int> ) , BigInteger . valueOf ( <int> ) , BigInteger . valueOf ( <int> ) , BigInteger . valueOf ( <int> ) , BigInteger . valueOf ( <int> ) ) ; } @Override public BigInteger [ ] createArray ( int length ) { return new BigInteger [ length ] ; } @Override public Iterable < BigInteger > order ( List < BigInteger > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } @Override public Set < BigInteger > create ( Object . . . elements ) { ImmutableRangeSet . Builder < BigInteger > builder = ImmutableRangeSet . builder ( ) ; for ( Object o : elements ) { BigInteger i = ( BigInteger ) o ; builder . add ( Range . closedOpen ( i , i . add ( BigInteger . ONE ) ) ) ; } return builder . build ( ) . asSet ( DiscreteDomain . bigIntegers ( ) ) ; } } public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableRangeSetTest . class ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableRangeSetIntegerAsSetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES , CollectionFeature . KNOWN_ORDER , CollectionFeature . NON_STANDARD_TOSTRING , CollectionFeature . SERIALIZABLE ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableRangeSetBigIntegerAsSetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES , CollectionFeature . KNOWN_ORDER , CollectionFeature . NON_STANDARD_TOSTRING , CollectionFeature . SERIALIZABLE ) . createTestSuite ( ) ) ; return suite ; } public void testEmpty ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . of ( ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; assertEquals ( ImmutableRangeSet . < Integer > all ( ) , rangeSet . complement ( ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . encloses ( Range . singleton ( <int> ) ) ) ; assertTrue ( rangeSet . enclosesAll ( rangeSet ) ) ; assertTrue ( rangeSet . isEmpty ( ) ) ; } public void testAll ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . all ( ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . < Integer > all ( ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertTrue ( rangeSet . encloses ( Range . < Integer > all ( ) ) ) ; assertTrue ( rangeSet . enclosesAll ( rangeSet ) ) ; assertEquals ( ImmutableRangeSet . < Integer > of ( ) , rangeSet . complement ( ) ) ; } public void testSingleBoundedRange ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . of ( Range . closedOpen ( <int> , <int> ) ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( <int> , <int> ) ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . closedOpen ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . closedOpen ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . greaterThan ( <int> ) ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; RangeSet < Integer > expectedComplement = TreeRangeSet . create ( ) ; expectedComplement . add ( Range . lessThan ( <int> ) ) ; expectedComplement . add ( Range . atLeast ( <int> ) ) ; assertEquals ( expectedComplement , rangeSet . complement ( ) ) ; } public void testSingleBoundedBelowRange ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . of ( Range . greaterThan ( <int> ) ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . greaterThan ( <int> ) ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . greaterThan ( <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . closedOpen ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertEquals ( ImmutableRangeSet . of ( Range . atMost ( <int> ) ) , rangeSet . complement ( ) ) ; } public void testSingleBoundedAboveRange ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . of ( Range . atMost ( <int> ) ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . atMost ( <int> ) ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . lessThan ( <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . closedOpen ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; assertEquals ( ImmutableRangeSet . of ( Range . greaterThan ( <int> ) ) , rangeSet . complement ( ) ) ; } public void testMultipleBoundedRanges ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . closedOpen ( <int> , <int> ) , Range . closed ( <int> , <int> ) ) . inOrder ( ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . open ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . greaterThan ( <int> ) ) ) ; RangeSet < Integer > expectedComplement = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . lessThan ( <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . add ( Range . greaterThan ( <int> ) ) . build ( ) ; assertEquals ( expectedComplement , rangeSet . complement ( ) ) ; } public void testMultipleBoundedBelowRanges ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . greaterThan ( <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . closedOpen ( <int> , <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . open ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . greaterThan ( <int> ) ) ) ; RangeSet < Integer > expectedComplement = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . lessThan ( <int> ) ) . add ( Range . closed ( <int> , <int> ) ) . build ( ) ; assertEquals ( expectedComplement , rangeSet . complement ( ) ) ; } public void testMultipleBoundedAboveRanges ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . atMost ( <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . atMost ( <int> ) , Range . closedOpen ( <int> , <int> ) ) . inOrder ( ) ; assertTrue ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertTrue ( rangeSet . encloses ( Range . open ( - <int> , - <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . closed ( <int> , <int> ) ) ) ; assertFalse ( rangeSet . encloses ( Range . greaterThan ( <int> ) ) ) ; RangeSet < Integer > expectedComplement = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . open ( <int> , <int> ) ) . add ( Range . atLeast ( <int> ) ) . build ( ) ; assertEquals ( expectedComplement , rangeSet . complement ( ) ) ; } public void testAddUnsupported ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; try { rangeSet . add ( Range . open ( <int> , <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testAddAllUnsupported ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; try { rangeSet . addAll ( ImmutableRangeSet . < Integer > of ( ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testRemoveUnsupported ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; try { rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testRemoveAllUnsupported ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . build ( ) ; try { rangeSet . removeAll ( ImmutableRangeSet . < Integer > of ( ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } try { rangeSet . removeAll ( ImmutableRangeSet . of ( Range . closed ( <int> , <int> ) ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } @AndroidIncompatible public void testExhaustive ( ) { @SuppressWarnings ( <str> ) ImmutableSet < Range < Integer > > ranges = ImmutableSet . of ( Range . < Integer > all ( ) , Range . < Integer > closedOpen ( <int> , <int> ) , Range . singleton ( <int> ) , Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) , Range . atMost ( <int> ) , Range . atLeast ( <int> ) , Range . closed ( <int> , <int> ) , Range . closedOpen ( <int> , <int> ) , Range . openClosed ( <int> , <int> ) , Range . open ( <int> , <int> ) ) ; for ( Set < Range < Integer > > subset : Sets . powerSet ( ranges ) ) { RangeSet < Integer > mutable = TreeRangeSet . create ( ) ; ImmutableRangeSet . Builder < Integer > builder = ImmutableRangeSet . builder ( ) ; for ( Range < Integer > range : subset ) { boolean overlaps = false ; for ( Range < Integer > other : mutable . asRanges ( ) ) { if ( other . isConnected ( range ) & & ! other . intersection ( range ) . isEmpty ( ) ) { overlaps = true ; } } try { builder . add ( range ) ; assertFalse ( overlaps ) ; mutable . add ( range ) ; } catch ( IllegalArgumentException e ) { assertTrue ( overlaps ) ; } } ImmutableRangeSet < Integer > built = builder . build ( ) ; assertEquals ( mutable , built ) ; assertEquals ( ImmutableRangeSet . copyOf ( mutable ) , built ) ; assertEquals ( mutable . complement ( ) , built . complement ( ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) { assertEquals ( mutable . contains ( i ) , built . contains ( i ) ) ; } SerializableTester . reserializeAndAssert ( built ) ; SerializableTester . reserializeAndAssert ( built . asRanges ( ) ) ; } } public void testAsSet ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . open ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . add ( Range . openClosed ( <int> , <int> ) ) . build ( ) ; ImmutableSortedSet < Integer > expectedSet = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > asSet = rangeSet . asSet ( DiscreteDomain . integers ( ) ) ; assertEquals ( expectedSet , asSet ) ; assertThat ( asSet ) . containsExactlyElementsIn ( expectedSet ) . inOrder ( ) ; assertTrue ( asSet . containsAll ( expectedSet ) ) ; SerializableTester . reserializeAndAssert ( asSet ) ; } public void testAsSetHeadSet ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . open ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . add ( Range . openClosed ( <int> , <int> ) ) . build ( ) ; ImmutableSortedSet < Integer > expectedSet = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > asSet = rangeSet . asSet ( DiscreteDomain . integers ( ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) { assertEquals ( asSet . headSet ( i , false ) , expectedSet . headSet ( i , false ) ) ; assertEquals ( asSet . headSet ( i , true ) , expectedSet . headSet ( i , true ) ) ; } } public void testAsSetTailSet ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . open ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . add ( Range . openClosed ( <int> , <int> ) ) . build ( ) ; ImmutableSortedSet < Integer > expectedSet = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > asSet = rangeSet . asSet ( DiscreteDomain . integers ( ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) { assertEquals ( asSet . tailSet ( i , false ) , expectedSet . tailSet ( i , false ) ) ; assertEquals ( asSet . tailSet ( i , true ) , expectedSet . tailSet ( i , true ) ) ; } } public void testAsSetSubSet ( ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( Range . closed ( <int> , <int> ) ) . add ( Range . open ( <int> , <int> ) ) . add ( Range . closedOpen ( <int> , <int> ) ) . add ( Range . openClosed ( <int> , <int> ) ) . build ( ) ; ImmutableSortedSet < Integer > expectedSet = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > asSet = rangeSet . asSet ( DiscreteDomain . integers ( ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) { for ( int j = i + <int> ; j < = <int> ; j + + ) { assertEquals ( expectedSet . subSet ( i , false , j , false ) , asSet . subSet ( i , false , j , false ) ) ; assertEquals ( expectedSet . subSet ( i , true , j , false ) , asSet . subSet ( i , true , j , false ) ) ; assertEquals ( expectedSet . subSet ( i , false , j , true ) , asSet . subSet ( i , false , j , true ) ) ; assertEquals ( expectedSet . subSet ( i , true , j , true ) , asSet . subSet ( i , true , j , true ) ) ; } } } public void testSubRangeSet ( ) { ImmutableList . Builder < Range < Integer > > rangesBuilder = ImmutableList . builder ( ) ; rangesBuilder . add ( Range . < Integer > all ( ) ) ; for ( int i = - <int> ; i < = <int> ; i + + ) { for ( BoundType boundType : BoundType . values ( ) ) { rangesBuilder . add ( Range . upTo ( i , boundType ) ) ; rangesBuilder . add ( Range . downTo ( i , boundType ) ) ; } for ( int j = i + <int> ; j < = <int> ; j + + ) { for ( BoundType lbType : BoundType . values ( ) ) { for ( BoundType ubType : BoundType . values ( ) ) { rangesBuilder . add ( Range . range ( i , lbType , j , ubType ) ) ; } } } } ImmutableList < Range < Integer > > ranges = rangesBuilder . build ( ) ; for ( int i = - <int> ; i < = <int> ; i + + ) { rangesBuilder . add ( Range . closedOpen ( i , i ) ) ; rangesBuilder . add ( Range . openClosed ( i , i ) ) ; } ImmutableList < Range < Integer > > subRanges = rangesBuilder . build ( ) ; for ( Range < Integer > range1 : ranges ) { for ( Range < Integer > range2 : ranges ) { if ( ! range1 . isConnected ( range2 ) | | range1 . intersection ( range2 ) . isEmpty ( ) ) { ImmutableRangeSet < Integer > rangeSet = ImmutableRangeSet . < Integer > builder ( ) . add ( range1 ) . add ( range2 ) . build ( ) ; for ( Range < Integer > subRange : subRanges ) { RangeSet < Integer > expected = TreeRangeSet . create ( ) ; for ( Range < Integer > range : rangeSet . asRanges ( ) ) { if ( range . isConnected ( subRange ) ) { expected . add ( range . intersection ( subRange ) ) ; } } ImmutableRangeSet < Integer > subRangeSet = rangeSet . subRangeSet ( subRange ) ; assertEquals ( expected , subRangeSet ) ; assertEquals ( expected . asRanges ( ) , subRangeSet . asRanges ( ) ) ; if ( ! expected . isEmpty ( ) ) { assertEquals ( expected . span ( ) , subRangeSet . span ( ) ) ; } for ( int i = - <int> ; i < = <int> ; i + + ) { assertEquals ( expected . contains ( i ) , subRangeSet . contains ( i ) ) ; } } } } } } }