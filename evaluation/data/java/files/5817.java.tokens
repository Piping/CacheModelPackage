package rx . internal . operators ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . Map ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import rx . Observable ; import rx . Observer ; import rx . exceptions . TestException ; import rx . functions . Func0 ; import rx . functions . Func1 ; import rx . internal . operators . OperatorToMultimap . DefaultMultimapCollectionFactory ; import rx . internal . operators . OperatorToMultimap . DefaultToMultimapFactory ; import rx . internal . util . UtilityFunctions ; import rx . observers . TestSubscriber ; public class OperatorToMultimapTest { @Mock Observer < Object > objectObserver ; @Before public void before ( ) { MockitoAnnotations . initMocks ( this ) ; } Func1 < String , Integer > lengthFunc = new Func1 < String , Integer > ( ) { @Override public Integer call ( String t1 ) { return t1 . length ( ) ; } } ; Func1 < String , String > duplicate = new Func1 < String , String > ( ) { @Override public String call ( String t1 ) { return t1 + t1 ; } } ; @Test public void testToMultimap ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( <int> ) ) . onNext ( expected ) ; verify ( objectObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithValueSelector ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicate ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( <int> ) ) . onNext ( expected ) ; verify ( objectObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithMapFactory ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> , <str> , <str> ) ; Func0 < Map < Integer , Collection < String > > > mapFactory = new Func0 < Map < Integer , Collection < String > > > ( ) { @Override public Map < Integer , Collection < String > > call ( ) { return new LinkedHashMap < Integer , Collection < String > > ( ) { private static final long serialVersionUID = - <int> ; @Override protected boolean removeEldestEntry ( Map . Entry < Integer , Collection < String > > eldest ) { return size ( ) > <int> ; } } ; } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , UtilityFunctions . < String > identity ( ) , mapFactory , new DefaultMultimapCollectionFactory < Integer , String > ( ) ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( <int> ) ) . onNext ( expected ) ; verify ( objectObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithCollectionFactory ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Func1 < Integer , Collection < String > > collectionFactory = new Func1 < Integer , Collection < String > > ( ) { @Override public Collection < String > call ( Integer t1 ) { if ( t1 = = <int> ) { return new ArrayList < String > ( ) ; } else { return new HashSet < String > ( ) ; } } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , UtilityFunctions . < String > identity ( ) , new DefaultToMultimapFactory < Integer , String > ( ) , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , new HashSet < String > ( Arrays . asList ( <str> ) ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( <int> ) ) . onNext ( expected ) ; verify ( objectObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithError ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Func1 < String , Integer > lengthFuncErr = new Func1 < String , Integer > ( ) { @Override public Integer call ( String t1 ) { if ( <str> . equals ( t1 ) ) { throw new RuntimeException ( <str> ) ; } return t1 . length ( ) ; } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFuncErr ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithErrorInValueSelector ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Func1 < String , String > duplicateErr = new Func1 < String , String > ( ) { @Override public String call ( String t1 ) { if ( <str> . equals ( t1 ) ) { throw new RuntimeException ( <str> ) ; } return t1 + t1 ; } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicateErr ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithMapThrowingFactory ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> , <str> , <str> ) ; Func0 < Map < Integer , Collection < String > > > mapFactory = new Func0 < Map < Integer , Collection < String > > > ( ) { @Override public Map < Integer , Collection < String > > call ( ) { throw new RuntimeException ( <str> ) ; } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , UtilityFunctions . < String > identity ( ) , mapFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onCompleted ( ) ; } @Test public void testToMultimapWithThrowingCollectionFactory ( ) { Observable < String > source = Observable . just ( <str> , <str> , <str> , <str> ) ; Func1 < Integer , Collection < String > > collectionFactory = new Func1 < Integer , Collection < String > > ( ) { @Override public Collection < String > call ( Integer t1 ) { if ( t1 = = <int> ) { throw new RuntimeException ( <str> ) ; } else { return new HashSet < String > ( ) ; } } } ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , UtilityFunctions . < String > identity ( ) , new DefaultToMultimapFactory < Integer , String > ( ) , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < Integer , Collection < String > > ( ) ; expected . put ( <int> , Arrays . asList ( <str> , <str> ) ) ; expected . put ( <int> , Collections . singleton ( <str> ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onCompleted ( ) ; } @Test public void testKeySelectorThrows ( ) { TestSubscriber < Object > ts = TestSubscriber . create ( ) ; Observable . just ( <int> , <int> ) . toMultimap ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { throw new TestException ( ) ; } } ) . subscribe ( ts ) ; ts . assertError ( TestException . class ) ; ts . assertNoValues ( ) ; ts . assertNotCompleted ( ) ; } @Test public void testValueSelectorThrows ( ) { TestSubscriber < Object > ts = TestSubscriber . create ( ) ; Observable . just ( <int> , <int> ) . toMultimap ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { return v ; } } , new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { throw new TestException ( ) ; } } ) . subscribe ( ts ) ; ts . assertError ( TestException . class ) ; ts . assertNoValues ( ) ; ts . assertNotCompleted ( ) ; } @Test public void testMapFactoryThrows ( ) { TestSubscriber < Object > ts = TestSubscriber . create ( ) ; Observable . just ( <int> , <int> ) . toMultimap ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { return v ; } } , new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { return v ; } } , new Func0 < Map < Integer , Collection < Integer > > > ( ) { @Override public Map < Integer , Collection < Integer > > call ( ) { throw new TestException ( ) ; } } ) . subscribe ( ts ) ; ts . assertError ( TestException . class ) ; ts . assertNoValues ( ) ; ts . assertNotCompleted ( ) ; } @Test public void testCollectionFactoryThrows ( ) { TestSubscriber < Object > ts = TestSubscriber . create ( ) ; Observable . just ( <int> , <int> ) . toMultimap ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { return v ; } } , new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer v ) { return v ; } } , new Func0 < Map < Integer , Collection < Integer > > > ( ) { @Override public Map < Integer , Collection < Integer > > call ( ) { return new HashMap < Integer , Collection < Integer > > ( ) ; } } , new Func1 < Integer , Collection < Integer > > ( ) { @Override public Collection < Integer > call ( Integer k ) { throw new TestException ( ) ; } } ) . subscribe ( ts ) ; ts . assertError ( TestException . class ) ; ts . assertNoValues ( ) ; ts . assertNotCompleted ( ) ; } }