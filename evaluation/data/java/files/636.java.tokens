package org . elasticsearch . cache . recycler ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . recycler . AbstractRecyclerC ; import org . elasticsearch . common . recycler . Recycler ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . Arrays ; import java . util . Locale ; import static org . elasticsearch . common . recycler . Recyclers . * ; public class PageCacheRecycler extends AbstractComponent { public static final String TYPE = <str> ; public static final String LIMIT_HEAP = <str> ; public static final String WEIGHT = <str> ; private final Recycler < byte [ ] > bytePage ; private final Recycler < int [ ] > intPage ; private final Recycler < long [ ] > longPage ; private final Recycler < Object [ ] > objectPage ; public void close ( ) { bytePage . close ( ) ; intPage . close ( ) ; longPage . close ( ) ; objectPage . close ( ) ; } private static int maximumSearchThreadPoolSize ( ThreadPool threadPool , Settings settings ) { ThreadPool . Info searchThreadPool = threadPool . info ( ThreadPool . Names . SEARCH ) ; assert searchThreadPool ! = null ; final int maxSize = searchThreadPool . getMax ( ) ; if ( maxSize < = <int> ) { return <int> * EsExecutors . boundedNumberOfProcessors ( settings ) ; } else { return maxSize ; } } @Inject public PageCacheRecycler ( Settings settings , ThreadPool threadPool ) { super ( settings ) ; final Type type = Type . parse ( settings . get ( TYPE ) ) ; final long limit = settings . getAsMemory ( LIMIT_HEAP , <str> ) . bytes ( ) ; final int availableProcessors = EsExecutors . boundedNumberOfProcessors ( settings ) ; final int searchThreadPoolSize = maximumSearchThreadPoolSize ( threadPool , settings ) ; final double bytesWeight = settings . getAsDouble ( WEIGHT + <str> , <int> d ) ; final double intsWeight = settings . getAsDouble ( WEIGHT + <str> , <int> d ) ; final double longsWeight = settings . getAsDouble ( WEIGHT + <str> , <int> d ) ; final double objectsWeight = settings . getAsDouble ( WEIGHT + <str> , <float> ) ; final double totalWeight = bytesWeight + intsWeight + longsWeight + objectsWeight ; final int maxPageCount = ( int ) Math . min ( Integer . MAX_VALUE , limit / BigArrays . PAGE_SIZE_IN_BYTES ) ; final int maxBytePageCount = ( int ) ( bytesWeight * maxPageCount / totalWeight ) ; bytePage = build ( type , maxBytePageCount , searchThreadPoolSize , availableProcessors , new AbstractRecyclerC < byte [ ] > ( ) { @Override public byte [ ] newInstance ( int sizing ) { return new byte [ BigArrays . BYTE_PAGE_SIZE ] ; } @Override public void recycle ( byte [ ] value ) { } } ) ; final int maxIntPageCount = ( int ) ( intsWeight * maxPageCount / totalWeight ) ; intPage = build ( type , maxIntPageCount , searchThreadPoolSize , availableProcessors , new AbstractRecyclerC < int [ ] > ( ) { @Override public int [ ] newInstance ( int sizing ) { return new int [ BigArrays . INT_PAGE_SIZE ] ; } @Override public void recycle ( int [ ] value ) { } } ) ; final int maxLongPageCount = ( int ) ( longsWeight * maxPageCount / totalWeight ) ; longPage = build ( type , maxLongPageCount , searchThreadPoolSize , availableProcessors , new AbstractRecyclerC < long [ ] > ( ) { @Override public long [ ] newInstance ( int sizing ) { return new long [ BigArrays . LONG_PAGE_SIZE ] ; } @Override public void recycle ( long [ ] value ) { } } ) ; final int maxObjectPageCount = ( int ) ( objectsWeight * maxPageCount / totalWeight ) ; objectPage = build ( type , maxObjectPageCount , searchThreadPoolSize , availableProcessors , new AbstractRecyclerC < Object [ ] > ( ) { @Override public Object [ ] newInstance ( int sizing ) { return new Object [ BigArrays . OBJECT_PAGE_SIZE ] ; } @Override public void recycle ( Object [ ] value ) { Arrays . fill ( value , null ) ; } } ) ; assert BigArrays . PAGE_SIZE_IN_BYTES * ( maxBytePageCount + maxIntPageCount + maxLongPageCount + maxObjectPageCount ) < = limit ; } public Recycler . V < byte [ ] > bytePage ( boolean clear ) { final Recycler . V < byte [ ] > v = bytePage . obtain ( ) ; if ( v . isRecycled ( ) & & clear ) { Arrays . fill ( v . v ( ) , ( byte ) <int> ) ; } return v ; } public Recycler . V < int [ ] > intPage ( boolean clear ) { final Recycler . V < int [ ] > v = intPage . obtain ( ) ; if ( v . isRecycled ( ) & & clear ) { Arrays . fill ( v . v ( ) , <int> ) ; } return v ; } public Recycler . V < long [ ] > longPage ( boolean clear ) { final Recycler . V < long [ ] > v = longPage . obtain ( ) ; if ( v . isRecycled ( ) & & clear ) { Arrays . fill ( v . v ( ) , <int> ) ; } return v ; } public Recycler . V < Object [ ] > objectPage ( ) { return objectPage . obtain ( ) ; } private static < T > Recycler < T > build ( Type type , int limit , int estimatedThreadPoolSize , int availableProcessors , Recycler . C < T > c ) { final Recycler < T > recycler ; if ( limit = = <int> ) { recycler = none ( c ) ; } else { recycler = type . build ( c , limit , estimatedThreadPoolSize , availableProcessors ) ; } return recycler ; } public static enum Type { QUEUE { @Override < T > Recycler < T > build ( Recycler . C < T > c , int limit , int estimatedThreadPoolSize , int availableProcessors ) { return concurrentDeque ( c , limit ) ; } } , CONCURRENT { @Override < T > Recycler < T > build ( Recycler . C < T > c , int limit , int estimatedThreadPoolSize , int availableProcessors ) { return concurrent ( dequeFactory ( c , limit / availableProcessors ) , availableProcessors ) ; } } , NONE { @Override < T > Recycler < T > build ( Recycler . C < T > c , int limit , int estimatedThreadPoolSize , int availableProcessors ) { return none ( c ) ; } } ; public static Type parse ( String type ) { if ( Strings . isNullOrEmpty ( type ) ) { return CONCURRENT ; } try { return Type . valueOf ( type . toUpperCase ( Locale . ROOT ) ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + type + <str> ) ; } } abstract < T > Recycler < T > build ( Recycler . C < T > c , int limit , int estimatedThreadPoolSize , int availableProcessors ) ; } } 
