package com . badlogic . gdx . graphics . glutils ; import com . badlogic . gdx . graphics . GLTexture ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . TextureData ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class MipMapTextureData implements TextureData { TextureData [ ] mips ; public MipMapTextureData ( TextureData . . . mipMapData ) { mips = new TextureData [ mipMapData . length ] ; System . arraycopy ( mipMapData , <int> , mips , <int> , mipMapData . length ) ; } @Override public TextureDataType getType ( ) { return TextureDataType . Custom ; } @Override public boolean isPrepared ( ) { return true ; } @Override public void prepare ( ) { } @Override public Pixmap consumePixmap ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public boolean disposePixmap ( ) { return false ; } @Override public void consumeCustomData ( int target ) { for ( int i = <int> ; i < mips . length ; + + i ) { GLTexture . uploadImageData ( target , mips [ i ] , i ) ; } } @Override public int getWidth ( ) { return mips [ <int> ] . getWidth ( ) ; } @Override public int getHeight ( ) { return mips [ <int> ] . getHeight ( ) ; } @Override public Format getFormat ( ) { return mips [ <int> ] . getFormat ( ) ; } @Override public boolean useMipMaps ( ) { return false ; } @Override public boolean isManaged ( ) { return true ; } } 
