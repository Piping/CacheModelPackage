package rx . internal . schedulers ; import java . util . concurrent . Future ; import java . util . concurrent . atomic . * ; import rx . Subscription ; import rx . exceptions . OnErrorNotImplementedException ; import rx . functions . Action0 ; import rx . internal . util . SubscriptionList ; import rx . plugins . RxJavaPlugins ; import rx . subscriptions . CompositeSubscription ; public final class ScheduledAction extends AtomicReference < Thread > implements Runnable , Subscription { private static final long serialVersionUID = - <int> ; final SubscriptionList cancel ; final Action0 action ; public ScheduledAction ( Action0 action ) { this . action = action ; this . cancel = new SubscriptionList ( ) ; } public ScheduledAction ( Action0 action , CompositeSubscription parent ) { this . action = action ; this . cancel = new SubscriptionList ( new Remover ( this , parent ) ) ; } public ScheduledAction ( Action0 action , SubscriptionList parent ) { this . action = action ; this . cancel = new SubscriptionList ( new Remover2 ( this , parent ) ) ; } @Override public void run ( ) { try { lazySet ( Thread . currentThread ( ) ) ; action . call ( ) ; } catch ( Throwable e ) { IllegalStateException ie = null ; if ( e instanceof OnErrorNotImplementedException ) { ie = new IllegalStateException ( <str> , e ) ; } else { ie = new IllegalStateException ( <str> , e ) ; } RxJavaPlugins . getInstance ( ) . getErrorHandler ( ) . handleError ( ie ) ; Thread thread = Thread . currentThread ( ) ; thread . getUncaughtExceptionHandler ( ) . uncaughtException ( thread , ie ) ; } finally { unsubscribe ( ) ; } } @Override public boolean isUnsubscribed ( ) { return cancel . isUnsubscribed ( ) ; } @Override public void unsubscribe ( ) { if ( ! cancel . isUnsubscribed ( ) ) { cancel . unsubscribe ( ) ; } } public void add ( Subscription s ) { cancel . add ( s ) ; } public void add ( final Future < ? > f ) { cancel . add ( new FutureCompleter ( f ) ) ; } public void addParent ( CompositeSubscription parent ) { cancel . add ( new Remover ( this , parent ) ) ; } public void addParent ( SubscriptionList parent ) { cancel . add ( new Remover2 ( this , parent ) ) ; } private final class FutureCompleter implements Subscription { private final Future < ? > f ; private FutureCompleter ( Future < ? > f ) { this . f = f ; } @Override public void unsubscribe ( ) { if ( ScheduledAction . this . get ( ) ! = Thread . currentThread ( ) ) { f . cancel ( true ) ; } else { f . cancel ( false ) ; } } @Override public boolean isUnsubscribed ( ) { return f . isCancelled ( ) ; } } private static final class Remover extends AtomicBoolean implements Subscription { private static final long serialVersionUID = <int> ; final ScheduledAction s ; final CompositeSubscription parent ; public Remover ( ScheduledAction s , CompositeSubscription parent ) { this . s = s ; this . parent = parent ; } @Override public boolean isUnsubscribed ( ) { return s . isUnsubscribed ( ) ; } @Override public void unsubscribe ( ) { if ( compareAndSet ( false , true ) ) { parent . remove ( s ) ; } } } private static final class Remover2 extends AtomicBoolean implements Subscription { private static final long serialVersionUID = <int> ; final ScheduledAction s ; final SubscriptionList parent ; public Remover2 ( ScheduledAction s , SubscriptionList parent ) { this . s = s ; this . parent = parent ; } @Override public boolean isUnsubscribed ( ) { return s . isUnsubscribed ( ) ; } @Override public void unsubscribe ( ) { if ( compareAndSet ( false , true ) ) { parent . remove ( s ) ; } } } }