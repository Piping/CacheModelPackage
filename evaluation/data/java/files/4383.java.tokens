package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . MessageToMessageCodec ; import io . netty . util . ReferenceCountUtil ; import java . util . ArrayDeque ; import java . util . List ; import java . util . Queue ; public abstract class HttpContentEncoder extends MessageToMessageCodec < HttpRequest , HttpObject > { private enum State { PASS_THROUGH , AWAIT_HEADERS , AWAIT_CONTENT } private static final CharSequence ZERO_LENGTH_HEAD = <str> ; private static final CharSequence ZERO_LENGTH_CONNECT = <str> ; private static final int CONTINUE_CODE = HttpResponseStatus . CONTINUE . code ( ) ; private final Queue < CharSequence > acceptEncodingQueue = new ArrayDeque < CharSequence > ( ) ; private CharSequence acceptEncoding ; private EmbeddedChannel encoder ; private State state = State . AWAIT_HEADERS ; @Override public boolean acceptOutboundMessage ( Object msg ) throws Exception { return msg instanceof HttpContent | | msg instanceof HttpResponse ; } @Override protected void decode ( ChannelHandlerContext ctx , HttpRequest msg , List < Object > out ) throws Exception { CharSequence acceptedEncoding = msg . headers ( ) . get ( HttpHeaderNames . ACCEPT_ENCODING ) ; if ( acceptedEncoding = = null ) { acceptedEncoding = HttpContentDecoder . IDENTITY ; } HttpMethod meth = msg . method ( ) ; if ( meth = = HttpMethod . HEAD ) { acceptedEncoding = ZERO_LENGTH_HEAD ; } else if ( meth = = HttpMethod . CONNECT ) { acceptedEncoding = ZERO_LENGTH_CONNECT ; } acceptEncodingQueue . add ( acceptedEncoding ) ; out . add ( ReferenceCountUtil . retain ( msg ) ) ; } @Override protected void encode ( ChannelHandlerContext ctx , HttpObject msg , List < Object > out ) throws Exception { final boolean isFull = msg instanceof HttpResponse & & msg instanceof LastHttpContent ; switch ( state ) { case AWAIT_HEADERS : { ensureHeaders ( msg ) ; assert encoder = = null ; final HttpResponse res = ( HttpResponse ) msg ; final int code = res . status ( ) . code ( ) ; if ( code = = CONTINUE_CODE ) { acceptEncoding = null ; } else { acceptEncoding = acceptEncodingQueue . poll ( ) ; if ( acceptEncoding = = null ) { throw new IllegalStateException ( <str> ) ; } } if ( isPassthru ( code , acceptEncoding ) ) { if ( isFull ) { out . add ( ReferenceCountUtil . retain ( res ) ) ; } else { out . add ( res ) ; state = State . PASS_THROUGH ; } break ; } if ( isFull ) { if ( ! ( ( ByteBufHolder ) res ) . content ( ) . isReadable ( ) ) { out . add ( ReferenceCountUtil . retain ( res ) ) ; break ; } } final Result result = beginEncode ( res , acceptEncoding . toString ( ) ) ; if ( result = = null ) { if ( isFull ) { out . add ( ReferenceCountUtil . retain ( res ) ) ; } else { out . add ( res ) ; state = State . PASS_THROUGH ; } break ; } encoder = result . contentEncoder ( ) ; res . headers ( ) . set ( HttpHeaderNames . CONTENT_ENCODING , result . targetContentEncoding ( ) ) ; res . headers ( ) . remove ( HttpHeaderNames . CONTENT_LENGTH ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; if ( isFull ) { HttpResponse newRes = new DefaultHttpResponse ( res . protocolVersion ( ) , res . status ( ) ) ; newRes . headers ( ) . set ( res . headers ( ) ) ; out . add ( newRes ) ; } else { out . add ( res ) ; state = State . AWAIT_CONTENT ; if ( ! ( msg instanceof HttpContent ) ) { break ; } } } case AWAIT_CONTENT : { ensureContent ( msg ) ; if ( encodeContent ( ( HttpContent ) msg , out ) ) { state = State . AWAIT_HEADERS ; } break ; } case PASS_THROUGH : { ensureContent ( msg ) ; out . add ( ReferenceCountUtil . retain ( msg ) ) ; if ( msg instanceof LastHttpContent ) { state = State . AWAIT_HEADERS ; } break ; } } } private static boolean isPassthru ( int code , CharSequence httpMethod ) { return code < <int> | | code = = <int> | | code = = <int> | | ( httpMethod = = ZERO_LENGTH_HEAD | | ( httpMethod = = ZERO_LENGTH_CONNECT & & code = = <int> ) ) ; } private static void ensureHeaders ( HttpObject msg ) { if ( ! ( msg instanceof HttpResponse ) ) { throw new IllegalStateException ( <str> + msg . getClass ( ) . getName ( ) + <str> + HttpResponse . class . getSimpleName ( ) + <str> ) ; } } private static void ensureContent ( HttpObject msg ) { if ( ! ( msg instanceof HttpContent ) ) { throw new IllegalStateException ( <str> + msg . getClass ( ) . getName ( ) + <str> + HttpContent . class . getSimpleName ( ) + <str> ) ; } } private boolean encodeContent ( HttpContent c , List < Object > out ) { ByteBuf content = c . content ( ) ; encode ( content , out ) ; if ( c instanceof LastHttpContent ) { finishEncode ( out ) ; LastHttpContent last = ( LastHttpContent ) c ; HttpHeaders headers = last . trailingHeaders ( ) ; if ( headers . isEmpty ( ) ) { out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } else { out . add ( new ComposedLastHttpContent ( headers ) ) ; } return true ; } return false ; } protected abstract Result beginEncode ( HttpResponse headers , String acceptEncoding ) throws Exception ; @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; super . handlerRemoved ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; super . channelInactive ( ctx ) ; } private void cleanup ( ) { if ( encoder ! = null ) { if ( encoder . finish ( ) ) { for ( ; ; ) { ByteBuf buf = encoder . readOutbound ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; } } encoder = null ; } } private void encode ( ByteBuf in , List < Object > out ) { encoder . writeOutbound ( in . retain ( ) ) ; fetchEncoderOutput ( out ) ; } private void finishEncode ( List < Object > out ) { if ( encoder . finish ( ) ) { fetchEncoderOutput ( out ) ; } encoder = null ; } private void fetchEncoderOutput ( List < Object > out ) { for ( ; ; ) { ByteBuf buf = encoder . readOutbound ( ) ; if ( buf = = null ) { break ; } if ( ! buf . isReadable ( ) ) { buf . release ( ) ; continue ; } out . add ( new DefaultHttpContent ( buf ) ) ; } } public static final class Result { private final String targetContentEncoding ; private final EmbeddedChannel contentEncoder ; public Result ( String targetContentEncoding , EmbeddedChannel contentEncoder ) { if ( targetContentEncoding = = null ) { throw new NullPointerException ( <str> ) ; } if ( contentEncoder = = null ) { throw new NullPointerException ( <str> ) ; } this . targetContentEncoding = targetContentEncoding ; this . contentEncoder = contentEncoder ; } public String targetContentEncoding ( ) { return targetContentEncoding ; } public EmbeddedChannel contentEncoder ( ) { return contentEncoder ; } } }