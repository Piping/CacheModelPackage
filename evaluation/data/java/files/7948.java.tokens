package org . apache . cassandra . stress . operations ; import java . util . * ; import org . apache . cassandra . stress . generate . * ; import org . apache . cassandra . stress . util . Timing ; import org . apache . commons . math3 . distribution . EnumeratedDistribution ; import org . apache . commons . math3 . util . Pair ; import org . apache . cassandra . stress . Operation ; import org . apache . cassandra . stress . generate . DistributionFactory ; import org . apache . cassandra . stress . generate . PartitionGenerator ; import org . apache . cassandra . stress . util . Timer ; public abstract class SampledOpDistributionFactory < T > implements OpDistributionFactory { final Map < T , Double > ratios ; final DistributionFactory clustering ; protected SampledOpDistributionFactory ( Map < T , Double > ratios , DistributionFactory clustering ) { this . ratios = ratios ; this . clustering = clustering ; } protected abstract List < ? extends Operation > get ( Timer timer , PartitionGenerator generator , T key ) ; protected abstract PartitionGenerator newGenerator ( ) ; public OpDistribution get ( Timing timing , int sampleCount ) { PartitionGenerator generator = newGenerator ( ) ; List < Pair < Operation , Double > > operations = new ArrayList < > ( ) ; for ( Map . Entry < T , Double > ratio : ratios . entrySet ( ) ) { List < ? extends Operation > ops = get ( timing . newTimer ( ratio . getKey ( ) . toString ( ) , sampleCount ) , generator , ratio . getKey ( ) ) ; for ( Operation op : ops ) operations . add ( new Pair < > ( op , ratio . getValue ( ) / ops . size ( ) ) ) ; } return new SampledOpDistribution ( new EnumeratedDistribution < > ( operations ) , clustering . get ( ) ) ; } public String desc ( ) { List < T > keys = new ArrayList < > ( ) ; for ( Map . Entry < T , Double > ratio : ratios . entrySet ( ) ) keys . add ( ratio . getKey ( ) ) ; return keys . toString ( ) ; } public Iterable < OpDistributionFactory > each ( ) { List < OpDistributionFactory > out = new ArrayList < > ( ) ; for ( final Map . Entry < T , Double > ratio : ratios . entrySet ( ) ) { out . add ( new OpDistributionFactory ( ) { public OpDistribution get ( Timing timing , int sampleCount ) { List < ? extends Operation > ops = SampledOpDistributionFactory . this . get ( timing . newTimer ( ratio . getKey ( ) . toString ( ) , sampleCount ) , newGenerator ( ) , ratio . getKey ( ) ) ; if ( ops . size ( ) = = <int> ) return new FixedOpDistribution ( ops . get ( <int> ) ) ; List < Pair < Operation , Double > > ratios = new ArrayList < > ( ) ; for ( Operation op : ops ) ratios . add ( new Pair < > ( op , <int> d / ops . size ( ) ) ) ; return new SampledOpDistribution ( new EnumeratedDistribution < Operation > ( ratios ) , new DistributionFixed ( <int> ) ) ; } public String desc ( ) { return ratio . getKey ( ) . toString ( ) ; } public Iterable < OpDistributionFactory > each ( ) { return Collections . < OpDistributionFactory > singleton ( this ) ; } } ) ; } return out ; } }