package org . apache . cassandra . db . compaction ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . UUID ; import junit . framework . Assert ; import org . junit . After ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . notifications . SSTableAddedNotification ; import org . apache . cassandra . notifications . SSTableRepairStatusChanged ; import org . apache . cassandra . repair . RepairJobDesc ; import org . apache . cassandra . repair . Validator ; import org . apache . cassandra . schema . CompactionParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class LeveledCompactionStrategyTest { private static final Logger logger = LoggerFactory . getLogger ( LeveledCompactionStrategyTest . class ) ; private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARDDLEVELED = <str> ; private Keyspace keyspace ; private ColumnFamilyStore cfs ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARDDLEVELED ) . compaction ( CompactionParams . lcs ( Collections . singletonMap ( <str> , <str> ) ) ) ) ; } @Before public void enableCompaction ( ) { keyspace = Keyspace . open ( KEYSPACE1 ) ; cfs = keyspace . getColumnFamilyStore ( CF_STANDARDDLEVELED ) ; cfs . enableAutoCompaction ( ) ; } @After public void truncateSTandardLeveled ( ) { cfs . truncateBlocking ( ) ; } @Test public void testGrouperLevels ( ) throws Exception { ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> * <int> ] ) ; new Random ( ) . nextBytes ( value . array ( ) ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { UpdateBuilder update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( r ) ) ; for ( int c = <int> ; c < columns ; c + + ) update . newRow ( <str> + c ) . add ( <str> , value ) ; update . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } waitForLeveling ( cfs ) ; CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; int l1Count = strategy . getSSTableCountPerLevel ( ) [ <int> ] ; int l2Count = strategy . getSSTableCountPerLevel ( ) [ <int> ] ; if ( l1Count = = <int> | | l2Count = = <int> ) { logger . error ( <str> ) ; logger . error ( <str> + l1Count ) ; logger . error ( <str> + l2Count ) ; Assert . fail ( ) ; } Collection < Collection < SSTableReader > > groupedSSTables = cfs . getCompactionStrategyManager ( ) . groupSSTablesForAntiCompaction ( cfs . getLiveSSTables ( ) ) ; for ( Collection < SSTableReader > sstableGroup : groupedSSTables ) { int groupLevel = - <int> ; Iterator < SSTableReader > it = sstableGroup . iterator ( ) ; while ( it . hasNext ( ) ) { SSTableReader sstable = it . next ( ) ; int tableLevel = sstable . getSSTableLevel ( ) ; if ( groupLevel = = - <int> ) groupLevel = tableLevel ; assert groupLevel = = tableLevel ; } } } @Test public void testValidationMultipleSSTablePerLevel ( ) throws Exception { byte [ ] b = new byte [ <int> * <int> ] ; new Random ( ) . nextBytes ( b ) ; ByteBuffer value = ByteBuffer . wrap ( b ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { UpdateBuilder update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( r ) ) ; for ( int c = <int> ; c < columns ; c + + ) update . newRow ( <str> + c ) . add ( <str> , value ) ; update . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } waitForLeveling ( cfs ) ; CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; assertTrue ( strategy . getSSTableCountPerLevel ( ) [ <int> ] > <int> ) ; assertTrue ( strategy . getSSTableCountPerLevel ( ) [ <int> ] > <int> ) ; Range < Token > range = new Range < > ( Util . token ( <str> ) , Util . token ( <str> ) ) ; int gcBefore = keyspace . getColumnFamilyStore ( CF_STANDARDDLEVELED ) . gcBefore ( FBUtilities . nowInSeconds ( ) ) ; UUID parentRepSession = UUID . randomUUID ( ) ; ActiveRepairService . instance . registerParentRepairSession ( parentRepSession , Arrays . asList ( cfs ) , Arrays . asList ( range ) , false , System . currentTimeMillis ( ) , true ) ; RepairJobDesc desc = new RepairJobDesc ( parentRepSession , UUID . randomUUID ( ) , KEYSPACE1 , CF_STANDARDDLEVELED , Arrays . asList ( range ) ) ; Validator validator = new Validator ( desc , FBUtilities . getBroadcastAddress ( ) , gcBefore ) ; CompactionManager . instance . submitValidation ( cfs , validator ) . get ( ) ; } private void waitForLeveling ( ColumnFamilyStore cfs ) throws InterruptedException { CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; while ( strategy . getSSTableCountPerLevel ( ) [ <int> ] > <int> ) Thread . sleep ( <int> ) ; Thread . sleep ( <int> ) ; } @Test public void testCompactionProgress ( ) throws Exception { byte [ ] b = new byte [ <int> * <int> ] ; new Random ( ) . nextBytes ( b ) ; ByteBuffer value = ByteBuffer . wrap ( b ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { UpdateBuilder update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( r ) ) ; for ( int c = <int> ; c < columns ; c + + ) update . newRow ( <str> + c ) . add ( <str> , value ) ; update . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } waitForLeveling ( cfs ) ; LeveledCompactionStrategy strategy = ( LeveledCompactionStrategy ) ( cfs . getCompactionStrategyManager ( ) ) . getStrategies ( ) . get ( <int> ) ; assert strategy . getLevelSize ( <int> ) > <int> ; Collection < SSTableReader > sstables = strategy . manifest . getLevel ( <int> ) ; List < ISSTableScanner > scanners = strategy . getScanners ( sstables ) . scanners ; assertEquals ( <int> , scanners . size ( ) ) ; ISSTableScanner scanner = scanners . get ( <int> ) ; while ( scanner . hasNext ( ) ) scanner . next ( ) ; assertEquals ( scanner . getCurrentPosition ( ) , SSTableReader . getTotalUncompressedBytes ( sstables ) ) ; } @Test public void testMutateLevel ( ) throws Exception { cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> * <int> ] ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { UpdateBuilder update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( r ) ) ; for ( int c = <int> ; c < columns ; c + + ) update . newRow ( <str> + c ) . add ( <str> , value ) ; update . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } cfs . forceBlockingFlush ( ) ; LeveledCompactionStrategy strategy = ( LeveledCompactionStrategy ) ( cfs . getCompactionStrategyManager ( ) ) . getStrategies ( ) . get ( <int> ) ; cfs . forceMajorCompaction ( ) ; for ( SSTableReader s : cfs . getLiveSSTables ( ) ) { assertTrue ( s . getSSTableLevel ( ) ! = <int> & & s . getSSTableLevel ( ) > <int> ) ; strategy . manifest . remove ( s ) ; s . descriptor . getMetadataSerializer ( ) . mutateLevel ( s . descriptor , <int> ) ; s . reloadSSTableMetadata ( ) ; strategy . manifest . add ( s ) ; } for ( SSTableReader s : cfs . getLiveSSTables ( ) ) assertEquals ( <int> , s . getSSTableLevel ( ) ) ; int [ ] levels = strategy . manifest . getAllLevelSize ( ) ; assertEquals ( cfs . getLiveSSTables ( ) . size ( ) , levels [ <int> ] ) ; } @Test public void testNewRepairedSSTable ( ) throws Exception { byte [ ] b = new byte [ <int> * <int> ] ; new Random ( ) . nextBytes ( b ) ; ByteBuffer value = ByteBuffer . wrap ( b ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { UpdateBuilder update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( r ) ) ; for ( int c = <int> ; c < columns ; c + + ) update . newRow ( <str> + c ) . add ( <str> , value ) ; update . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } waitForLeveling ( cfs ) ; cfs . disableAutoCompaction ( ) ; while ( CompactionManager . instance . isCompacting ( Arrays . asList ( cfs ) ) ) Thread . sleep ( <int> ) ; CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; List < AbstractCompactionStrategy > strategies = strategy . getStrategies ( ) ; LeveledCompactionStrategy repaired = ( LeveledCompactionStrategy ) strategies . get ( <int> ) ; LeveledCompactionStrategy unrepaired = ( LeveledCompactionStrategy ) strategies . get ( <int> ) ; assertEquals ( <int> , repaired . manifest . getLevelCount ( ) ) ; assertEquals ( <int> , unrepaired . manifest . getLevelCount ( ) ) ; assertTrue ( strategy . getSSTableCountPerLevel ( ) [ <int> ] > <int> ) ; assertTrue ( strategy . getSSTableCountPerLevel ( ) [ <int> ] > <int> ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) assertFalse ( sstable . isRepaired ( ) ) ; int sstableCount = <int> ; for ( List < SSTableReader > level : unrepaired . manifest . generations ) sstableCount + = level . size ( ) ; assertEquals ( sstableCount , cfs . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable1 = unrepaired . manifest . generations [ <int> ] . get ( <int> ) ; SSTableReader sstable2 = unrepaired . manifest . generations [ <int> ] . get ( <int> ) ; sstable1 . descriptor . getMetadataSerializer ( ) . mutateRepairedAt ( sstable1 . descriptor , System . currentTimeMillis ( ) ) ; sstable1 . reloadSSTableMetadata ( ) ; assertTrue ( sstable1 . isRepaired ( ) ) ; strategy . handleNotification ( new SSTableRepairStatusChanged ( Arrays . asList ( sstable1 ) ) , this ) ; int repairedSSTableCount = <int> ; for ( List < SSTableReader > level : repaired . manifest . generations ) repairedSSTableCount + = level . size ( ) ; assertEquals ( <int> , repairedSSTableCount ) ; assertTrue ( repaired . manifest . generations [ <int> ] . contains ( sstable1 ) ) ; assertFalse ( unrepaired . manifest . generations [ <int> ] . contains ( sstable1 ) ) ; unrepaired . removeSSTable ( sstable2 ) ; strategy . handleNotification ( new SSTableAddedNotification ( Collections . singleton ( sstable2 ) ) , this ) ; assertTrue ( unrepaired . manifest . getLevel ( <int> ) . contains ( sstable2 ) ) ; assertFalse ( repaired . manifest . getLevel ( <int> ) . contains ( sstable2 ) ) ; } }