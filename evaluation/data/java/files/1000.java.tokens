package org . apache . cassandra . db . compaction ; import java . io . IOException ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableSortedSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Sets ; import com . google . common . primitives . Ints ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . dht . Bounds ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . Pair ; public class LeveledManifest { private static final Logger logger = LoggerFactory . getLogger ( LeveledManifest . class ) ; private static final int MAX_COMPACTING_L0 = <int> ; private static final int NO_COMPACTION_LIMIT = <int> ; public static final int MAX_LEVEL_COUNT = ( int ) Math . log10 ( <int> * <int> * <int> ) ; private final ColumnFamilyStore cfs ; @VisibleForTesting protected final List < SSTableReader > [ ] generations ; private final PartitionPosition [ ] lastCompactedKeys ; private final long maxSSTableSizeInBytes ; private final SizeTieredCompactionStrategyOptions options ; private final int [ ] compactionCounter ; LeveledManifest ( ColumnFamilyStore cfs , int maxSSTableSizeInMB , SizeTieredCompactionStrategyOptions options ) { this . cfs = cfs ; this . maxSSTableSizeInBytes = maxSSTableSizeInMB * <int> * <int> ; this . options = options ; generations = new List [ MAX_LEVEL_COUNT ] ; lastCompactedKeys = new PartitionPosition [ MAX_LEVEL_COUNT ] ; for ( int i = <int> ; i < generations . length ; i + + ) { generations [ i ] = new ArrayList < > ( ) ; lastCompactedKeys [ i ] = cfs . getPartitioner ( ) . getMinimumToken ( ) . minKeyBound ( ) ; } compactionCounter = new int [ MAX_LEVEL_COUNT ] ; } public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , List < SSTableReader > sstables ) { return create ( cfs , maxSSTableSize , sstables , new SizeTieredCompactionStrategyOptions ( ) ) ; } public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , Iterable < SSTableReader > sstables , SizeTieredCompactionStrategyOptions options ) { LeveledManifest manifest = new LeveledManifest ( cfs , maxSSTableSize , options ) ; for ( SSTableReader ssTableReader : sstables ) { manifest . add ( ssTableReader ) ; } for ( int i = <int> ; i < manifest . getAllLevelSize ( ) . length ; i + + ) { manifest . repairOverlappingSSTables ( i ) ; } return manifest ; } public synchronized void add ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level < generations . length : <str> + level + <str> + ( generations . length - <int> ) ; logDistribution ( ) ; if ( canAddSSTable ( reader ) ) { logger . trace ( <str> , reader , level ) ; generations [ level ] . add ( reader ) ; } else { try { reader . descriptor . getMetadataSerializer ( ) . mutateLevel ( reader . descriptor , <int> ) ; reader . reloadSSTableMetadata ( ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; } generations [ <int> ] . add ( reader ) ; } } public synchronized void replace ( Collection < SSTableReader > removed , Collection < SSTableReader > added ) { assert ! removed . isEmpty ( ) ; logDistribution ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , toString ( removed ) ) ; int minLevel = Integer . MAX_VALUE ; for ( SSTableReader sstable : removed ) { int thisLevel = remove ( sstable ) ; minLevel = Math . min ( minLevel , thisLevel ) ; } if ( added . isEmpty ( ) ) return ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , toString ( added ) ) ; for ( SSTableReader ssTableReader : added ) add ( ssTableReader ) ; lastCompactedKeys [ minLevel ] = SSTableReader . sstableOrdering . max ( added ) . last ; } public synchronized void repairOverlappingSSTables ( int level ) { SSTableReader previous = null ; Collections . sort ( generations [ level ] , SSTableReader . sstableComparator ) ; List < SSTableReader > outOfOrderSSTables = new ArrayList < > ( ) ; for ( SSTableReader current : generations [ level ] ) { if ( previous ! = null & & current . first . compareTo ( previous . last ) < = <int> ) { logger . warn ( String . format ( <str> + <str> , level , previous , previous . first , previous . last , current , current . first , current . last ) ) ; outOfOrderSSTables . add ( current ) ; } else { previous = current ; } } if ( ! outOfOrderSSTables . isEmpty ( ) ) { for ( SSTableReader sstable : outOfOrderSSTables ) sendBackToL0 ( sstable ) ; } } private boolean canAddSSTable ( SSTableReader sstable ) { int level = sstable . getSSTableLevel ( ) ; if ( level = = <int> ) return true ; List < SSTableReader > copyLevel = new ArrayList < > ( generations [ level ] ) ; copyLevel . add ( sstable ) ; Collections . sort ( copyLevel , SSTableReader . sstableComparator ) ; SSTableReader previous = null ; for ( SSTableReader current : copyLevel ) { if ( previous ! = null & & current . first . compareTo ( previous . last ) < = <int> ) return false ; previous = current ; } return true ; } private synchronized void sendBackToL0 ( SSTableReader sstable ) { remove ( sstable ) ; try { sstable . descriptor . getMetadataSerializer ( ) . mutateLevel ( sstable . descriptor , <int> ) ; sstable . reloadSSTableMetadata ( ) ; add ( sstable ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } private String toString ( Collection < SSTableReader > sstables ) { StringBuilder builder = new StringBuilder ( ) ; for ( SSTableReader sstable : sstables ) { builder . append ( sstable . descriptor . cfname ) . append ( <str> ) . append ( sstable . descriptor . generation ) . append ( <str> ) . append ( sstable . getSSTableLevel ( ) ) . append ( <str> ) ; } return builder . toString ( ) ; } public static long maxBytesForLevel ( int level , long maxSSTableSizeInBytes ) { if ( level = = <int> ) return <int> * maxSSTableSizeInBytes ; double bytes = Math . pow ( <int> , level ) * maxSSTableSizeInBytes ; if ( bytes > Long . MAX_VALUE ) throw new RuntimeException ( <str> + Long . MAX_VALUE + <str> + bytes ) ; return ( long ) bytes ; } public synchronized CompactionCandidate getCompactionCandidates ( ) { if ( StorageService . instance . isBootstrapMode ( ) ) { List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( <int> ) ) ; if ( ! mostInteresting . isEmpty ( ) ) { logger . info ( <str> ) ; return new CompactionCandidate ( mostInteresting , <int> , Long . MAX_VALUE ) ; } return null ; } for ( int i = generations . length - <int> ; i > <int> ; i - - ) { List < SSTableReader > sstables = getLevel ( i ) ; if ( sstables . isEmpty ( ) ) continue ; Set < SSTableReader > sstablesInLevel = Sets . newHashSet ( sstables ) ; Set < SSTableReader > remaining = Sets . difference ( sstablesInLevel , cfs . getTracker ( ) . getCompacting ( ) ) ; double score = ( double ) SSTableReader . getTotalBytes ( remaining ) / ( double ) maxBytesForLevel ( i , maxSSTableSizeInBytes ) ; logger . trace ( <str> , i , score ) ; if ( score > <float> ) { if ( ! DatabaseDescriptor . getDisableSTCSInL0 ( ) & & getLevel ( <int> ) . size ( ) > MAX_COMPACTING_L0 ) { List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( <int> ) ) ; if ( ! mostInteresting . isEmpty ( ) ) { logger . trace ( <str> ) ; return new CompactionCandidate ( mostInteresting , <int> , Long . MAX_VALUE ) ; } } Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; if ( ! candidates . isEmpty ( ) ) { int nextLevel = getNextLevel ( candidates ) ; candidates = getOverlappingStarvedSSTables ( nextLevel , candidates ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , i , toString ( candidates ) ) ; return new CompactionCandidate ( candidates , nextLevel , cfs . getCompactionStrategyManager ( ) . getMaxSSTableBytes ( ) ) ; } else { logger . trace ( <str> , i ) ; } } } if ( getLevel ( <int> ) . isEmpty ( ) ) return null ; Collection < SSTableReader > candidates = getCandidatesFor ( <int> ) ; if ( candidates . isEmpty ( ) ) return null ; return new CompactionCandidate ( candidates , getNextLevel ( candidates ) , cfs . getCompactionStrategyManager ( ) . getMaxSSTableBytes ( ) ) ; } private List < SSTableReader > getSSTablesForSTCS ( Collection < SSTableReader > sstables ) { Iterable < SSTableReader > candidates = cfs . getTracker ( ) . getUncompacting ( sstables ) ; List < Pair < SSTableReader , Long > > pairs = SizeTieredCompactionStrategy . createSSTableAndLengthPairs ( AbstractCompactionStrategy . filterSuspectSSTables ( candidates ) ) ; List < List < SSTableReader > > buckets = SizeTieredCompactionStrategy . getBuckets ( pairs , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; return SizeTieredCompactionStrategy . mostInterestingBucket ( buckets , <int> , <int> ) ; } private Collection < SSTableReader > getOverlappingStarvedSSTables ( int targetLevel , Collection < SSTableReader > candidates ) { Set < SSTableReader > withStarvedCandidate = new HashSet < > ( candidates ) ; for ( int i = generations . length - <int> ; i > <int> ; i - - ) compactionCounter [ i ] + + ; compactionCounter [ targetLevel ] = <int> ; if ( logger . isTraceEnabled ( ) ) { for ( int j = <int> ; j < compactionCounter . length ; j + + ) logger . trace ( <str> , j , compactionCounter [ j ] ) ; } for ( int i = generations . length - <int> ; i > <int> ; i - - ) { if ( getLevelSize ( i ) > <int> ) { if ( compactionCounter [ i ] > NO_COMPACTION_LIMIT ) { PartitionPosition max = null ; PartitionPosition min = null ; for ( SSTableReader candidate : candidates ) { if ( min = = null | | candidate . first . compareTo ( min ) < <int> ) min = candidate . first ; if ( max = = null | | candidate . last . compareTo ( max ) > <int> ) max = candidate . last ; } if ( min = = null | | max = = null | | min . equals ( max ) ) return candidates ; Set < SSTableReader > compacting = cfs . getTracker ( ) . getCompacting ( ) ; Range < PartitionPosition > boundaries = new Range < > ( min , max ) ; for ( SSTableReader sstable : getLevel ( i ) ) { Range < PartitionPosition > r = new Range < PartitionPosition > ( sstable . first , sstable . last ) ; if ( boundaries . contains ( r ) & & ! compacting . contains ( sstable ) ) { logger . info ( <str> , sstable . getSSTableLevel ( ) , sstable ) ; withStarvedCandidate . add ( sstable ) ; return withStarvedCandidate ; } } } return candidates ; } } return candidates ; } public synchronized int getLevelSize ( int i ) { if ( i > = generations . length ) throw new ArrayIndexOutOfBoundsException ( <str> + ( generations . length - <int> ) ) ; return getLevel ( i ) . size ( ) ; } public synchronized int [ ] getAllLevelSize ( ) { int [ ] counts = new int [ generations . length ] ; for ( int i = <int> ; i < counts . length ; i + + ) counts [ i ] = getLevel ( i ) . size ( ) ; return counts ; } private void logDistribution ( ) { if ( logger . isTraceEnabled ( ) ) { for ( int i = <int> ; i < generations . length ; i + + ) { if ( ! getLevel ( i ) . isEmpty ( ) ) { logger . trace ( <str> , i , getLevel ( i ) . size ( ) , SSTableReader . getTotalBytes ( getLevel ( i ) ) , this ) ; } } } } @VisibleForTesting public int remove ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level > = <int> : reader + <str> + level ; generations [ level ] . remove ( reader ) ; return level ; } private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) { assert ! candidates . isEmpty ( ) ; Iterator < SSTableReader > iter = candidates . iterator ( ) ; SSTableReader sstable = iter . next ( ) ; Token first = sstable . first . getToken ( ) ; Token last = sstable . last . getToken ( ) ; while ( iter . hasNext ( ) ) { sstable = iter . next ( ) ; first = first . compareTo ( sstable . first . getToken ( ) ) < = <int> ? first : sstable . first . getToken ( ) ; last = last . compareTo ( sstable . last . getToken ( ) ) > = <int> ? last : sstable . last . getToken ( ) ; } return overlapping ( first , last , others ) ; } @VisibleForTesting static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) { return overlapping ( sstable . first . getToken ( ) , sstable . last . getToken ( ) , others ) ; } private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) { assert start . compareTo ( end ) < = <int> ; Set < SSTableReader > overlapped = new HashSet < > ( ) ; Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; for ( SSTableReader candidate : sstables ) { Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . getToken ( ) , candidate . last . getToken ( ) ) ; if ( candidateBounds . intersects ( promotedBounds ) ) overlapped . add ( candidate ) ; } return overlapped ; } private static final Predicate < SSTableReader > suspectP = new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader candidate ) { return candidate . isMarkedSuspect ( ) ; } } ; private Collection < SSTableReader > getCandidatesFor ( int level ) { assert ! getLevel ( level ) . isEmpty ( ) ; logger . trace ( <str> , level ) ; final Set < SSTableReader > compacting = cfs . getTracker ( ) . getCompacting ( ) ; if ( level = = <int> ) { Set < SSTableReader > compactingL0 = getCompacting ( <int> ) ; PartitionPosition lastCompactingKey = null ; PartitionPosition firstCompactingKey = null ; for ( SSTableReader candidate : compactingL0 ) { if ( firstCompactingKey = = null | | candidate . first . compareTo ( firstCompactingKey ) < <int> ) firstCompactingKey = candidate . first ; if ( lastCompactingKey = = null | | candidate . last . compareTo ( lastCompactingKey ) > <int> ) lastCompactingKey = candidate . last ; } Set < SSTableReader > candidates = new HashSet < > ( ) ; Set < SSTableReader > remaining = new HashSet < > ( ) ; Iterables . addAll ( remaining , Iterables . filter ( getLevel ( <int> ) , Predicates . not ( suspectP ) ) ) ; for ( SSTableReader sstable : ageSortedSSTables ( remaining ) ) { if ( candidates . contains ( sstable ) ) continue ; Sets . SetView < SSTableReader > overlappedL0 = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ; if ( ! Sets . intersection ( overlappedL0 , compactingL0 ) . isEmpty ( ) ) continue ; for ( SSTableReader newCandidate : overlappedL0 ) { if ( firstCompactingKey = = null | | lastCompactingKey = = null | | overlapping ( firstCompactingKey . getToken ( ) , lastCompactingKey . getToken ( ) , Arrays . asList ( newCandidate ) ) . size ( ) = = <int> ) candidates . add ( newCandidate ) ; remaining . remove ( newCandidate ) ; } if ( candidates . size ( ) > MAX_COMPACTING_L0 ) { candidates = new HashSet < > ( ageSortedSSTables ( candidates ) . subList ( <int> , MAX_COMPACTING_L0 ) ) ; break ; } } if ( SSTableReader . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) { Set < SSTableReader > l1overlapping = overlapping ( candidates , getLevel ( <int> ) ) ; if ( Sets . intersection ( l1overlapping , compacting ) . size ( ) > <int> ) return Collections . emptyList ( ) ; if ( ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) return Collections . emptyList ( ) ; candidates = Sets . union ( candidates , l1overlapping ) ; } if ( candidates . size ( ) < <int> ) return Collections . emptyList ( ) ; else return candidates ; } Collections . sort ( getLevel ( level ) , SSTableReader . sstableComparator ) ; int start = <int> ; for ( int i = <int> ; i < getLevel ( level ) . size ( ) ; i + + ) { SSTableReader sstable = getLevel ( level ) . get ( i ) ; if ( sstable . first . compareTo ( lastCompactedKeys [ level ] ) > <int> ) { start = i ; break ; } } for ( int i = <int> ; i < getLevel ( level ) . size ( ) ; i + + ) { SSTableReader sstable = getLevel ( level ) . get ( ( start + i ) % getLevel ( level ) . size ( ) ) ; Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , getLevel ( level + <int> ) ) ) ; if ( Iterables . any ( candidates , suspectP ) ) continue ; if ( Sets . intersection ( candidates , compacting ) . isEmpty ( ) ) return candidates ; } return Collections . emptyList ( ) ; } private Set < SSTableReader > getCompacting ( int level ) { Set < SSTableReader > sstables = new HashSet < > ( ) ; Set < SSTableReader > levelSSTables = new HashSet < > ( getLevel ( level ) ) ; for ( SSTableReader sstable : cfs . getTracker ( ) . getCompacting ( ) ) { if ( levelSSTables . contains ( sstable ) ) sstables . add ( sstable ) ; } return sstables ; } private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) { List < SSTableReader > ageSortedCandidates = new ArrayList < > ( candidates ) ; Collections . sort ( ageSortedCandidates , SSTableReader . maxTimestampComparator ) ; return ageSortedCandidates ; } @Override public String toString ( ) { return <str> + hashCode ( ) ; } public int getLevelCount ( ) { for ( int i = generations . length - <int> ; i > = <int> ; i - - ) { if ( getLevel ( i ) . size ( ) > <int> ) return i ; } return <int> ; } public synchronized SortedSet < SSTableReader > getLevelSorted ( int level , Comparator < SSTableReader > comparator ) { return ImmutableSortedSet . copyOf ( comparator , getLevel ( level ) ) ; } public List < SSTableReader > getLevel ( int i ) { return generations [ i ] ; } public synchronized int getEstimatedTasks ( ) { long tasks = <int> ; long [ ] estimated = new long [ generations . length ] ; for ( int i = generations . length - <int> ; i > = <int> ; i - - ) { List < SSTableReader > sstables = getLevel ( i ) ; estimated [ i ] = ( long ) Math . ceil ( ( double ) Math . max ( <int> , SSTableReader . getTotalBytes ( sstables ) - ( long ) ( maxBytesForLevel ( i , maxSSTableSizeInBytes ) * <float> ) ) / ( double ) maxSSTableSizeInBytes ) ; tasks + = estimated [ i ] ; } logger . trace ( <str> , Arrays . toString ( estimated ) , cfs . keyspace . getName ( ) , cfs . name ) ; return Ints . checkedCast ( tasks ) ; } public int getNextLevel ( Collection < SSTableReader > sstables ) { int maximumLevel = Integer . MIN_VALUE ; int minimumLevel = Integer . MAX_VALUE ; for ( SSTableReader sstable : sstables ) { maximumLevel = Math . max ( sstable . getSSTableLevel ( ) , maximumLevel ) ; minimumLevel = Math . min ( sstable . getSSTableLevel ( ) , minimumLevel ) ; } int newLevel ; if ( minimumLevel = = <int> & & minimumLevel = = maximumLevel & & SSTableReader . getTotalBytes ( sstables ) < maxSSTableSizeInBytes ) { newLevel = <int> ; } else { newLevel = minimumLevel = = maximumLevel ? maximumLevel + <int> : maximumLevel ; assert newLevel > <int> ; } return newLevel ; } public Iterable < SSTableReader > getAllSSTables ( ) { Set < SSTableReader > sstables = new HashSet < > ( ) ; for ( List < SSTableReader > generation : generations ) { sstables . addAll ( generation ) ; } return sstables ; } public static class CompactionCandidate { public final Collection < SSTableReader > sstables ; public final int level ; public final long maxSSTableBytes ; public CompactionCandidate ( Collection < SSTableReader > sstables , int level , long maxSSTableBytes ) { this . sstables = sstables ; this . level = level ; this . maxSSTableBytes = maxSSTableBytes ; } } } 
