package io . netty . handler . codec . stomp ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . handler . codec . stomp . StompSubframeDecoder . State ; import io . netty . util . internal . AppendableCharSequence ; import io . netty . util . internal . StringUtil ; import java . util . List ; import java . util . Locale ; import static io . netty . buffer . ByteBufUtil . indexOf ; import static io . netty . buffer . ByteBufUtil . readBytes ; public class StompSubframeDecoder extends ReplayingDecoder < State > { private static final int DEFAULT_CHUNK_SIZE = <int> ; private static final int DEFAULT_MAX_LINE_LENGTH = <int> ; enum State { SKIP_CONTROL_CHARACTERS , READ_HEADERS , READ_CONTENT , FINALIZE_FRAME_READ , BAD_FRAME , INVALID_CHUNK } private final int maxLineLength ; private final int maxChunkSize ; private int alreadyReadChunkSize ; private LastStompContentSubframe lastContent ; private long contentLength = - <int> ; public StompSubframeDecoder ( ) { this ( DEFAULT_MAX_LINE_LENGTH , DEFAULT_CHUNK_SIZE ) ; } public StompSubframeDecoder ( int maxLineLength , int maxChunkSize ) { super ( State . SKIP_CONTROL_CHARACTERS ) ; if ( maxLineLength < = <int> ) { throw new IllegalArgumentException ( <str> + maxLineLength ) ; } if ( maxChunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxChunkSize ) ; } this . maxChunkSize = maxChunkSize ; this . maxLineLength = maxLineLength ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { switch ( state ( ) ) { case SKIP_CONTROL_CHARACTERS : skipControlCharacters ( in ) ; checkpoint ( State . READ_HEADERS ) ; case READ_HEADERS : StompCommand command = StompCommand . UNKNOWN ; StompHeadersSubframe frame = null ; try { command = readCommand ( in ) ; frame = new DefaultStompHeadersSubframe ( command ) ; checkpoint ( readHeaders ( in , frame . headers ( ) ) ) ; out . add ( frame ) ; } catch ( Exception e ) { if ( frame = = null ) { frame = new DefaultStompHeadersSubframe ( command ) ; } frame . setDecoderResult ( DecoderResult . failure ( e ) ) ; out . add ( frame ) ; checkpoint ( State . BAD_FRAME ) ; return ; } break ; case BAD_FRAME : in . skipBytes ( actualReadableBytes ( ) ) ; return ; } try { switch ( state ( ) ) { case READ_CONTENT : int toRead = in . readableBytes ( ) ; if ( toRead = = <int> ) { return ; } if ( toRead > maxChunkSize ) { toRead = maxChunkSize ; } if ( this . contentLength > = <int> ) { int remainingLength = ( int ) ( contentLength - alreadyReadChunkSize ) ; if ( toRead > remainingLength ) { toRead = remainingLength ; } ByteBuf chunkBuffer = readBytes ( ctx . alloc ( ) , in , toRead ) ; if ( ( alreadyReadChunkSize + = toRead ) > = contentLength ) { lastContent = new DefaultLastStompContentSubframe ( chunkBuffer ) ; checkpoint ( State . FINALIZE_FRAME_READ ) ; } else { out . add ( new DefaultStompContentSubframe ( chunkBuffer ) ) ; return ; } } else { int nulIndex = indexOf ( in , in . readerIndex ( ) , in . writerIndex ( ) , StompConstants . NUL ) ; if ( nulIndex = = in . readerIndex ( ) ) { checkpoint ( State . FINALIZE_FRAME_READ ) ; } else { if ( nulIndex > <int> ) { toRead = nulIndex - in . readerIndex ( ) ; } else { toRead = in . writerIndex ( ) - in . readerIndex ( ) ; } ByteBuf chunkBuffer = readBytes ( ctx . alloc ( ) , in , toRead ) ; alreadyReadChunkSize + = toRead ; if ( nulIndex > <int> ) { lastContent = new DefaultLastStompContentSubframe ( chunkBuffer ) ; checkpoint ( State . FINALIZE_FRAME_READ ) ; } else { out . add ( new DefaultStompContentSubframe ( chunkBuffer ) ) ; return ; } } } case FINALIZE_FRAME_READ : skipNullCharacter ( in ) ; if ( lastContent = = null ) { lastContent = LastStompContentSubframe . EMPTY_LAST_CONTENT ; } out . add ( lastContent ) ; resetDecoder ( ) ; } } catch ( Exception e ) { StompContentSubframe errorContent = new DefaultLastStompContentSubframe ( Unpooled . EMPTY_BUFFER ) ; errorContent . setDecoderResult ( DecoderResult . failure ( e ) ) ; out . add ( errorContent ) ; checkpoint ( State . BAD_FRAME ) ; } } private StompCommand readCommand ( ByteBuf in ) { String commandStr = readLine ( in , maxLineLength ) ; StompCommand command = null ; try { command = StompCommand . valueOf ( commandStr ) ; } catch ( IllegalArgumentException iae ) { } if ( command = = null ) { commandStr = commandStr . toUpperCase ( Locale . US ) ; try { command = StompCommand . valueOf ( commandStr ) ; } catch ( IllegalArgumentException iae ) { } } if ( command = = null ) { throw new DecoderException ( <str> ) ; } return command ; } private State readHeaders ( ByteBuf buffer , StompHeaders headers ) { for ( ; ; ) { String line = readLine ( buffer , maxLineLength ) ; if ( ! line . isEmpty ( ) ) { String [ ] split = StringUtil . split ( line , <str> ) ; if ( split . length = = <int> ) { headers . add ( split [ <int> ] , split [ <int> ] ) ; } } else { if ( headers . contains ( StompHeaders . CONTENT_LENGTH ) ) { this . contentLength = getContentLength ( headers , <int> ) ; if ( this . contentLength = = <int> ) { return State . FINALIZE_FRAME_READ ; } } return State . READ_CONTENT ; } } } private static long getContentLength ( StompHeaders headers , long defaultValue ) { long contentLength = headers . getLong ( StompHeaders . CONTENT_LENGTH , defaultValue ) ; if ( contentLength < <int> ) { throw new DecoderException ( StompHeaders . CONTENT_LENGTH + <str> ) ; } return contentLength ; } private static void skipNullCharacter ( ByteBuf buffer ) { byte b = buffer . readByte ( ) ; if ( b ! = StompConstants . NUL ) { throw new IllegalStateException ( <str> + b + <str> ) ; } } private static void skipControlCharacters ( ByteBuf buffer ) { byte b ; for ( ; ; ) { b = buffer . readByte ( ) ; if ( b ! = StompConstants . CR & & b ! = StompConstants . LF ) { buffer . readerIndex ( buffer . readerIndex ( ) - <int> ) ; break ; } } } private static String readLine ( ByteBuf buffer , int maxLineLength ) { AppendableCharSequence buf = new AppendableCharSequence ( <int> ) ; int lineLength = <int> ; for ( ; ; ) { byte nextByte = buffer . readByte ( ) ; if ( nextByte = = StompConstants . CR ) { nextByte = buffer . readByte ( ) ; if ( nextByte = = StompConstants . LF ) { return buf . toString ( ) ; } } else if ( nextByte = = StompConstants . LF ) { return buf . toString ( ) ; } else { if ( lineLength > = maxLineLength ) { throw new TooLongFrameException ( <str> + maxLineLength + <str> ) ; } lineLength + + ; buf . append ( ( char ) nextByte ) ; } } } private void resetDecoder ( ) { checkpoint ( State . SKIP_CONTROL_CHARACTERS ) ; contentLength = - <int> ; alreadyReadChunkSize = <int> ; lastContent = null ; } }