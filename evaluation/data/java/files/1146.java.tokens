package org . gradle ; import org . gradle . api . Action ; import org . gradle . api . logging . LogLevel ; import org . gradle . execution . MultipleBuildFailures ; import org . gradle . initialization . BuildClientMetaData ; import org . gradle . internal . exceptions . FailureResolutionAware ; import org . gradle . internal . exceptions . LocationAwareException ; import org . gradle . logging . LoggingConfiguration ; import org . gradle . logging . ShowStacktrace ; import org . gradle . logging . StyledTextOutput ; import org . gradle . logging . StyledTextOutputFactory ; import org . gradle . logging . internal . BufferingStyledTextOutput ; import org . gradle . logging . internal . LinePrefixingStyledTextOutput ; import org . gradle . logging . internal . LoggingCommandLineConverter ; import org . gradle . util . GUtil ; import org . gradle . util . TreeVisitor ; import java . util . List ; import static org . gradle . logging . StyledTextOutput . Style . * ; @Deprecated public class BuildExceptionReporter extends BuildAdapter implements Action < Throwable > { private enum ExceptionStyle { NONE , FULL } private final StyledTextOutputFactory textOutputFactory ; private final LoggingConfiguration loggingConfiguration ; private final BuildClientMetaData clientMetaData ; public BuildExceptionReporter ( StyledTextOutputFactory textOutputFactory , LoggingConfiguration loggingConfiguration , BuildClientMetaData clientMetaData ) { this . textOutputFactory = textOutputFactory ; this . loggingConfiguration = loggingConfiguration ; this . clientMetaData = clientMetaData ; } public void buildFinished ( BuildResult result ) { Throwable failure = result . getFailure ( ) ; if ( failure = = null ) { return ; } execute ( failure ) ; } public void execute ( Throwable failure ) { if ( failure instanceof MultipleBuildFailures ) { renderMultipleBuildExceptions ( ( MultipleBuildFailures ) failure ) ; return ; } renderSingleBuildException ( failure ) ; } private void renderMultipleBuildExceptions ( MultipleBuildFailures multipleFailures ) { List < ? extends Throwable > causes = multipleFailures . getCauses ( ) ; StyledTextOutput output = textOutputFactory . create ( BuildExceptionReporter . class , LogLevel . ERROR ) ; output . println ( ) ; output . withStyle ( Failure ) . format ( <str> , causes . size ( ) ) ; output . println ( ) ; for ( int i = <int> ; i < causes . size ( ) ; i + + ) { Throwable cause = causes . get ( i ) ; FailureDetails details = constructFailureDetails ( <str> , cause ) ; output . println ( ) ; output . withStyle ( Failure ) . format ( <str> , i + <int> ) ; details . summary . writeTo ( output . withStyle ( Failure ) ) ; output . println ( ) ; output . text ( <str> ) ; writeFailureDetails ( output , details ) ; output . println ( <str> ) ; } } private void renderSingleBuildException ( Throwable failure ) { StyledTextOutput output = textOutputFactory . create ( BuildExceptionReporter . class , LogLevel . ERROR ) ; FailureDetails details = constructFailureDetails ( <str> , failure ) ; output . println ( ) ; output . withStyle ( Failure ) . text ( <str> ) ; details . summary . writeTo ( output . withStyle ( Failure ) ) ; output . println ( ) ; writeFailureDetails ( output , details ) ; } private FailureDetails constructFailureDetails ( String granularity , Throwable failure ) { FailureDetails details = new FailureDetails ( failure ) ; reportBuildFailure ( granularity , failure , details ) ; return details ; } private void reportBuildFailure ( String granularity , Throwable failure , FailureDetails details ) { if ( loggingConfiguration . getShowStacktrace ( ) ! = ShowStacktrace . INTERNAL_EXCEPTIONS ) { details . exceptionStyle = ExceptionStyle . FULL ; } formatGenericFailure ( granularity , failure , details ) ; } private void formatGenericFailure ( String granularity , Throwable failure , final FailureDetails details ) { details . summary . format ( <str> , granularity ) ; fillInFailureResolution ( details ) ; if ( failure instanceof LocationAwareException ) { final LocationAwareException scriptException = ( LocationAwareException ) failure ; details . failure = scriptException . getCause ( ) ; if ( scriptException . getLocation ( ) ! = null ) { details . location . text ( scriptException . getLocation ( ) ) ; } scriptException . visitReportableCauses ( new TreeVisitor < Throwable > ( ) { int depth ; @Override public void node ( final Throwable node ) { if ( node = = scriptException ) { details . details . text ( getMessage ( scriptException . getCause ( ) ) ) ; } else { final LinePrefixingStyledTextOutput output = getLinePrefixingStyledTextOutput ( ) ; output . text ( getMessage ( node ) ) ; } } @Override public void startChildren ( ) { depth + + ; } @Override public void endChildren ( ) { depth - - ; } private LinePrefixingStyledTextOutput getLinePrefixingStyledTextOutput ( ) { details . details . format ( <str> ) ; StringBuilder prefix = new StringBuilder ( ) ; for ( int i = <int> ; i < depth ; i + + ) { prefix . append ( <str> ) ; } details . details . text ( prefix ) ; prefix . append ( <str> ) ; details . details . style ( Info ) . text ( <str> ) . style ( Normal ) ; return new LinePrefixingStyledTextOutput ( details . details , prefix , false ) ; } } ) ; } else { details . details . text ( getMessage ( failure ) ) ; } } private void fillInFailureResolution ( FailureDetails details ) { if ( details . failure instanceof FailureResolutionAware ) { ( ( FailureResolutionAware ) details . failure ) . appendResolution ( details . resolution , clientMetaData ) ; if ( details . resolution . getHasContent ( ) ) { details . resolution . append ( <str> ) ; } } if ( details . exceptionStyle = = ExceptionStyle . NONE ) { details . resolution . text ( <str> ) ; details . resolution . withStyle ( UserInput ) . format ( <str> , LoggingCommandLineConverter . STACKTRACE_LONG ) ; details . resolution . text ( <str> ) ; } if ( loggingConfiguration . getLogLevel ( ) ! = LogLevel . DEBUG ) { details . resolution . text ( <str> ) ; if ( loggingConfiguration . getLogLevel ( ) ! = LogLevel . INFO ) { details . resolution . withStyle ( UserInput ) . format ( <str> , LoggingCommandLineConverter . INFO_LONG ) ; details . resolution . text ( <str> ) ; } details . resolution . withStyle ( UserInput ) . format ( <str> , LoggingCommandLineConverter . DEBUG_LONG ) ; details . resolution . text ( <str> ) ; } } private String getMessage ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( GUtil . isTrue ( message ) ) { return message ; } return String . format ( <str> , throwable . getClass ( ) . getName ( ) ) ; } private void writeFailureDetails ( StyledTextOutput output , FailureDetails details ) { if ( details . location . getHasContent ( ) ) { output . println ( ) ; output . println ( <str> ) ; details . location . writeTo ( output ) ; output . println ( ) ; } if ( details . details . getHasContent ( ) ) { output . println ( ) ; output . println ( <str> ) ; details . details . writeTo ( output ) ; output . println ( ) ; } if ( details . resolution . getHasContent ( ) ) { output . println ( ) ; output . println ( <str> ) ; details . resolution . writeTo ( output ) ; output . println ( ) ; } Throwable exception = null ; switch ( details . exceptionStyle ) { case NONE : break ; case FULL : exception = details . failure ; break ; } if ( exception ! = null ) { output . println ( ) ; output . println ( <str> ) ; output . exception ( exception ) ; output . println ( ) ; } } private static class FailureDetails { Throwable failure ; final BufferingStyledTextOutput summary = new BufferingStyledTextOutput ( ) ; final BufferingStyledTextOutput details = new BufferingStyledTextOutput ( ) ; final BufferingStyledTextOutput location = new BufferingStyledTextOutput ( ) ; final BufferingStyledTextOutput resolution = new BufferingStyledTextOutput ( ) ; ExceptionStyle exceptionStyle = ExceptionStyle . NONE ; public FailureDetails ( Throwable failure ) { this . failure = failure ; } } } 
