package org . elasticsearch . bwcompat ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . apache . lucene . index . Fields ; import org . apache . lucene . util . English ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . admin . indices . analyze . AnalyzeResponse ; import org . elasticsearch . action . admin . indices . settings . get . GetSettingsResponse ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . explain . ExplainResponse ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . get . MultiGetItemResponse ; import org . elasticsearch . action . get . MultiGetRequest ; import org . elasticsearch . action . get . MultiGetRequestBuilder ; import org . elasticsearch . action . get . MultiGetResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . termvectors . TermVectorsResponse ; import org . elasticsearch . action . update . UpdateRequestBuilder ; import org . elasticsearch . action . update . UpdateResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . internal . FieldNamesFieldMapper ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESBackcompatTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . constantScoreQuery ; import static org . elasticsearch . index . query . QueryBuilders . existsQuery ; import static org . elasticsearch . index . query . QueryBuilders . queryStringQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchHits ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; public class BasicBackwardsCompatibilityIT extends ESBackcompatTestCase { public void testExternalVersion ( ) throws Exception { createIndex ( <str> ) ; final boolean routing = randomBoolean ( ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; String routingKey = routing ? randomRealisticUnicodeOfLength ( <int> ) : null ; final long version = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; client ( ) . prepareIndex ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( version ) . setVersionType ( VersionType . EXTERNAL ) . setSource ( <str> , English . intToEnglish ( i ) ) . get ( ) ; GetResponse get = client ( ) . prepareGet ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( version ) . get ( ) ; assertThat ( <str> + id + <str> , get . isExists ( ) , is ( true ) ) ; assertThat ( get . getVersion ( ) , equalTo ( version ) ) ; final long nextVersion = version + randomIntBetween ( <int> , Integer . MAX_VALUE ) ; client ( ) . prepareIndex ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( nextVersion ) . setVersionType ( VersionType . EXTERNAL ) . setSource ( <str> , English . intToEnglish ( i ) ) . get ( ) ; get = client ( ) . prepareGet ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( nextVersion ) . get ( ) ; assertThat ( <str> + id + <str> , get . isExists ( ) , is ( true ) ) ; assertThat ( get . getVersion ( ) , equalTo ( nextVersion ) ) ; } } public void testInternalVersion ( ) throws Exception { createIndex ( <str> ) ; final boolean routing = randomBoolean ( ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String routingKey = routing ? randomRealisticUnicodeOfLength ( <int> ) : null ; String id = Integer . toString ( i ) ; assertThat ( id , client ( ) . prepareIndex ( <str> , <str> , id ) . setRouting ( routingKey ) . setSource ( <str> , English . intToEnglish ( i ) ) . get ( ) . isCreated ( ) , is ( true ) ) ; GetResponse get = client ( ) . prepareGet ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( <int> ) . get ( ) ; assertThat ( <str> + id + <str> , get . isExists ( ) , is ( true ) ) ; assertThat ( get . getVersion ( ) , equalTo ( <int> l ) ) ; client ( ) . prepareIndex ( <str> , <str> , id ) . setRouting ( routingKey ) . setSource ( <str> , English . intToEnglish ( i ) ) . execute ( ) . actionGet ( ) ; get = client ( ) . prepareGet ( <str> , <str> , id ) . setRouting ( routingKey ) . setVersion ( <int> ) . get ( ) ; assertThat ( <str> + id + <str> , get . isExists ( ) , is ( true ) ) ; assertThat ( get . getVersion ( ) , equalTo ( <int> l ) ) ; } assertVersionCreated ( compatibilityVersion ( ) , <str> ) ; } public void testIndexAndSearch ( ) throws Exception { createIndex ( <str> ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > builder = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; builder . add ( client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , id ) ) ; } indexRandom ( true , builder ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . termQuery ( <str> , id ) ) . get ( ) , <int> ) ; } assertVersionCreated ( compatibilityVersion ( ) , <str> ) ; } public void testRecoverFromPreviousVersion ( ) throws ExecutionException , InterruptedException { if ( backwardsCluster ( ) . numNewDataNodes ( ) = = <int> ) { backwardsCluster ( ) . startNewNode ( ) ; } assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) . put ( indexSettings ( ) ) ) ) ; ensureYellow ( ) ; assertAllShardsOnNodes ( <str> , backwardsCluster ( ) . backwardsNodePattern ( ) ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; ArrayList < String > ids = new ArrayList < > ( ) ; logger . info ( <str> , numDocs ) ; IndexRequestBuilder [ ] docs = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = randomRealisticUnicodeOfLength ( <int> ) + String . valueOf ( i ) ; ids . add ( id ) ; docs [ i ] = client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , English . intToEnglish ( i ) ) ; } indexRandom ( true , docs ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; if ( randomBoolean ( ) ) { logger . info ( <str> ) ; backwardsCluster ( ) . allowOnlyNewNodes ( <str> ) ; } else { logger . info ( <str> ) ; backwardsCluster ( ) . allowOnAllNodes ( <str> ) ; } logger . info ( <str> , numDocs ) ; if ( randomBoolean ( ) ) { for ( int i = <int> ; i < numDocs ; i + + ) { String id = randomRealisticUnicodeOfLength ( <int> ) + String . valueOf ( numDocs + i ) ; ids . add ( id ) ; docs [ i ] = client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , English . intToEnglish ( numDocs + i ) ) ; } indexRandom ( true , docs ) ; if ( compatibilityVersion ( ) . before ( Version . V_1_3_0 ) ) { assertNoFailures ( backwardsCluster ( ) . internalCluster ( ) . dataNodeClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . setIndicesOptions ( IndicesOptions . lenientExpandOpen ( ) ) . execute ( ) . get ( ) ) ; } numDocs * = <int> ; } logger . info ( <str> , numDocs ) ; ensureYellow ( <str> ) ; final int numIters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { assertSearchHits ( client ( ) . prepareSearch ( ) . setSize ( ids . size ( ) ) . get ( ) , ids . toArray ( new String [ ids . size ( ) ] ) ) ; } assertVersionCreated ( compatibilityVersion ( ) , <str> ) ; } public void testNoRecoveryFromNewNodes ( ) throws ExecutionException , InterruptedException { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . backwardsNodePattern ( ) ) . put ( indexSettings ( ) ) ) ) ; if ( backwardsCluster ( ) . numNewDataNodes ( ) = = <int> ) { backwardsCluster ( ) . startNewNode ( ) ; } ensureYellow ( ) ; assertAllShardsOnNodes ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) ; if ( randomBoolean ( ) ) { backwardsCluster ( ) . allowOnAllNodes ( <str> ) ; } int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] docs = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( <str> , <str> , randomRealisticUnicodeOfLength ( <int> ) + String . valueOf ( i ) ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , randomInt ( ) , <str> , randomDouble ( ) ) ; } indexRandom ( true , docs ) ; backwardsCluster ( ) . allowOnAllNodes ( <str> ) ; while ( ensureYellow ( ) ! = ClusterHealthStatus . GREEN ) { backwardsCluster ( ) . startNewNode ( ) ; } assertAllShardsOnNodes ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; final int numIters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; assertSimpleSort ( <str> , <str> ) ; } assertVersionCreated ( compatibilityVersion ( ) , <str> ) ; } public void assertSimpleSort ( String . . . numericFields ) { for ( String field : numericFields ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . addSort ( field , SortOrder . ASC ) . get ( ) ; SearchHit [ ] hits = searchResponse . getHits ( ) . getHits ( ) ; assertThat ( hits . length , greaterThan ( <int> ) ) ; Number previous = null ; for ( SearchHit hit : hits ) { assertNotNull ( hit . getSource ( ) . get ( field ) ) ; if ( previous ! = null ) { assertThat ( previous . doubleValue ( ) , lessThanOrEqualTo ( ( ( Number ) hit . getSource ( ) . get ( field ) ) . doubleValue ( ) ) ) ; } previous = ( Number ) hit . getSource ( ) . get ( field ) ; } } } @Override public void assertAllShardsOnNodes ( String index , String pattern ) { ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { if ( shardRouting . currentNodeId ( ) ! = null & & index . equals ( shardRouting . getIndex ( ) ) ) { String name = clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) ; assertThat ( <str> + name , Regex . simpleMatch ( pattern , name ) , is ( true ) ) ; } } } } } public void testIndexUpgradeSingleNode ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) . put ( indexSettings ( ) ) ) ) ; ensureYellow ( ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] docs = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( <str> , <str> , String . valueOf ( i ) ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , randomInt ( ) , <str> , randomDouble ( ) ) ; } indexRandom ( true , docs ) ; assertAllShardsOnNodes ( <str> , backwardsCluster ( ) . backwardsNodePattern ( ) ) ; disableAllocation ( <str> ) ; backwardsCluster ( ) . allowOnAllNodes ( <str> ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; backwardsCluster ( ) . upgradeOneNode ( ) ; ensureYellow ( ) ; if ( randomBoolean ( ) ) { for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( <str> , <str> , String . valueOf ( i ) ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , randomInt ( ) , <str> , randomDouble ( ) ) ; } indexRandom ( true , docs ) ; } enableAllocation ( <str> ) ; ensureYellow ( ) ; final int numIters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , numDocs ) ; assertSimpleSort ( <str> , <str> ) ; } assertVersionCreated ( compatibilityVersion ( ) , <str> ) ; } public void testIndexRollingUpgrade ( ) throws Exception { String [ ] indices = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < indices . length ; i + + ) { indices [ i ] = <str> + i ; assertAcked ( prepareCreate ( indices [ i ] ) . setSettings ( Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) . put ( indexSettings ( ) ) ) ) ; } int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] docs = new IndexRequestBuilder [ numDocs ] ; String [ ] indexForDoc = new String [ docs . length ] ; for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( indexForDoc [ i ] = RandomPicks . randomFrom ( getRandom ( ) , indices ) , <str> , String . valueOf ( i ) ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , randomInt ( ) , <str> , randomDouble ( ) ) ; } indexRandom ( true , docs ) ; for ( String index : indices ) { assertAllShardsOnNodes ( index , backwardsCluster ( ) . backwardsNodePattern ( ) ) ; } disableAllocation ( indices ) ; backwardsCluster ( ) . allowOnAllNodes ( indices ) ; logClusterState ( ) ; boolean upgraded ; do { logClusterState ( ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; assertSimpleSort ( <str> , <str> ) ; upgraded = backwardsCluster ( ) . upgradeOneNode ( ) ; ensureYellow ( ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; for ( int i = <int> ; i < numDocs ; i + + ) { docs [ i ] = client ( ) . prepareIndex ( indexForDoc [ i ] , <str> , String . valueOf ( i ) ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , randomInt ( ) , <str> , randomDouble ( ) ) ; } indexRandom ( true , docs ) ; } while ( upgraded ) ; enableAllocation ( indices ) ; ensureYellow ( ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; assertSimpleSort ( <str> , <str> ) ; String [ ] newIndices = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < newIndices . length ; i + + ) { newIndices [ i ] = <str> + i ; createIndex ( newIndices [ i ] ) ; } assertVersionCreated ( Version . CURRENT , newIndices ) ; assertVersionCreated ( compatibilityVersion ( ) , indices ) ; } public void assertVersionCreated ( Version version , String . . . indices ) { GetSettingsResponse getSettingsResponse = client ( ) . admin ( ) . indices ( ) . prepareGetSettings ( indices ) . get ( ) ; ImmutableOpenMap < String , Settings > indexToSettings = getSettingsResponse . getIndexToSettings ( ) ; for ( String index : indices ) { Settings settings = indexToSettings . get ( index ) ; assertThat ( settings . getAsVersion ( IndexMetaData . SETTING_VERSION_CREATED , null ) , notNullValue ( ) ) ; assertThat ( settings . getAsVersion ( IndexMetaData . SETTING_VERSION_CREATED , null ) , equalTo ( version ) ) ; } } public void testUnsupportedFeatures ( ) throws IOException { XContentBuilder mapping = XContentBuilder . builder ( JsonXContent . jsonXContent ) . startObject ( ) . startObject ( <str> ) . startObject ( FieldNamesFieldMapper . NAME ) . field ( <str> , randomFrom ( <str> , <str> ) ) . field ( <str> , randomFrom ( <str> , <str> ) ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) . put ( indexSettings ( ) ) ) . addMapping ( <str> , mapping ) ) ; } catch ( MapperParsingException ex ) { assertThat ( ex . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( ExceptionsHelper . detailedMessage ( ex ) . contains ( <str> ) , equalTo ( true ) ) ; } } public void testExistsFilter ( ) throws IOException , ExecutionException , InterruptedException { int indexId = <int> ; String indexName ; for ( ; ; ) { indexName = <str> + indexId + + ; createIndex ( indexName ) ; ensureYellow ( ) ; indexRandom ( true , client ( ) . prepareIndex ( indexName , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) , client ( ) . prepareIndex ( indexName , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) , client ( ) . prepareIndex ( indexName , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) , client ( ) . prepareIndex ( indexName , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( existsQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( constantScoreQuery ( existsQuery ( <str> ) ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( queryStringQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( existsQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( existsQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( existsQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( existsQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( queryStringQuery ( <str> ) ) . get ( ) ; assertHitCount ( countResponse , <int> l ) ; if ( ! backwardsCluster ( ) . upgradeOneNode ( ) ) { break ; } ensureYellow ( ) ; assertVersionCreated ( compatibilityVersion ( ) , indexName ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( indexName ) ) ; } assertVersionCreated ( Version . CURRENT , indexName ) ; } public Version getMasterVersion ( ) { return client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . nodes ( ) . masterNode ( ) . getVersion ( ) ; } public void testDeleteRoutingRequired ( ) throws ExecutionException , InterruptedException , IOException { createIndexWithAlias ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( <str> ) ; int numDocs = iterations ( <int> , <int> ) ; IndexRequestBuilder [ ] indexRequestBuilders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs - <int> ; i + + ) { indexRequestBuilders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setRouting ( randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ) . setSource ( <str> , <str> ) ; } String firstDocId = Integer . toString ( numDocs - <int> ) ; indexRequestBuilders [ numDocs - <int> ] = client ( ) . prepareIndex ( <str> , <str> , firstDocId ) . setRouting ( <str> ) . setSource ( <str> , <str> ) ; String secondDocId = Integer . toString ( numDocs - <int> ) ; String secondRouting = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; indexRequestBuilders [ numDocs - <int> ] = client ( ) . prepareIndex ( <str> , <str> , secondDocId ) . setRouting ( secondRouting ) . setSource ( <str> , <str> ) ; indexRandom ( true , indexRequestBuilders ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( ( long ) numDocs ) ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , firstDocId ) . setRouting ( <str> ) . get ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , firstDocId ) . setRouting ( <str> ) . get ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( false ) ) ; refresh ( ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( ( long ) numDocs - <int> ) ) ; } public void testIndexGetAndDelete ( ) throws ExecutionException , InterruptedException { createIndexWithAlias ( ) ; ensureYellow ( <str> ) ; int numDocs = iterations ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { IndexResponse indexResponse = client ( ) . prepareIndex ( indexOrAlias ( ) , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + i ) . get ( ) ; assertThat ( indexResponse . isCreated ( ) , equalTo ( true ) ) ; assertThat ( indexResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( indexResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( indexResponse . getId ( ) , equalTo ( Integer . toString ( i ) ) ) ; } refresh ( ) ; String docId = Integer . toString ( randomIntBetween ( <int> , numDocs - <int> ) ) ; GetResponse getResponse = client ( ) . prepareGet ( indexOrAlias ( ) , <str> , docId ) . get ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( true ) ) ; assertThat ( getResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( getResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( getResponse . getId ( ) , equalTo ( docId ) ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( indexOrAlias ( ) , <str> , docId ) . get ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( deleteResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( deleteResponse . getId ( ) , equalTo ( docId ) ) ; getResponse = client ( ) . prepareGet ( indexOrAlias ( ) , <str> , docId ) . get ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( false ) ) ; refresh ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( indexOrAlias ( ) ) . get ( ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( ( long ) numDocs - <int> ) ) ; } public void testUpdate ( ) { createIndexWithAlias ( ) ; ensureYellow ( <str> ) ; UpdateRequestBuilder updateRequestBuilder = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( <str> , <str> ) . setDoc ( <str> , <str> ) ; UpdateResponse updateResponse = updateRequestBuilder . get ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getId ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . isCreated ( ) , equalTo ( true ) ) ; GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( true ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . containsKey ( <str> ) , equalTo ( false ) ) ; updateResponse = updateRequestBuilder . get ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getId ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . isCreated ( ) , equalTo ( false ) ) ; getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( true ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; } public void testAnalyze ( ) { createIndexWithAlias ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( <str> , <str> ) ) ; ensureYellow ( <str> ) ; AnalyzeResponse analyzeResponse = client ( ) . admin ( ) . indices ( ) . prepareAnalyze ( <str> ) . setIndex ( indexOrAlias ( ) ) . setField ( <str> ) . get ( ) ; assertThat ( analyzeResponse . getTokens ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( analyzeResponse . getTokens ( ) . get ( <int> ) . getTerm ( ) , equalTo ( <str> ) ) ; } public void testExplain ( ) { createIndexWithAlias ( ) ; ensureYellow ( <str> ) ; client ( ) . prepareIndex ( indexOrAlias ( ) , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; refresh ( ) ; ExplainResponse response = client ( ) . prepareExplain ( indexOrAlias ( ) , <str> , <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <str> ) ) . get ( ) ; assertThat ( response . isExists ( ) , equalTo ( true ) ) ; assertThat ( response . isMatch ( ) , equalTo ( true ) ) ; assertThat ( response . getExplanation ( ) , notNullValue ( ) ) ; assertThat ( response . getExplanation ( ) . isMatch ( ) , equalTo ( true ) ) ; assertThat ( response . getExplanation ( ) . getDetails ( ) . length , equalTo ( <int> ) ) ; } public void testGetTermVector ( ) throws IOException { createIndexWithAlias ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( <str> , <str> ) . get ( ) ) ; ensureYellow ( <str> ) ; client ( ) . prepareIndex ( indexOrAlias ( ) , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; refresh ( ) ; TermVectorsResponse termVectorsResponse = client ( ) . prepareTermVectors ( indexOrAlias ( ) , <str> , <str> ) . get ( ) ; assertThat ( termVectorsResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( termVectorsResponse . isExists ( ) , equalTo ( true ) ) ; Fields fields = termVectorsResponse . getFields ( ) ; assertThat ( fields . size ( ) , equalTo ( <int> ) ) ; assertThat ( fields . terms ( <str> ) . size ( ) , equalTo ( <int> l ) ) ; } public void testIndicesStats ( ) { createIndex ( <str> ) ; ensureYellow ( <str> ) ; IndicesStatsResponse indicesStatsResponse = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . all ( ) . get ( ) ; assertThat ( indicesStatsResponse . getIndices ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( indicesStatsResponse . getIndices ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; } public void testMultiGet ( ) throws ExecutionException , InterruptedException { createIndexWithAlias ( ) ; ensureYellow ( <str> ) ; int numDocs = iterations ( <int> , <int> ) ; IndexRequestBuilder [ ] indexRequestBuilders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { indexRequestBuilders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + Integer . toString ( i ) ) ; } indexRandom ( false , indexRequestBuilders ) ; int iterations = iterations ( <int> , numDocs ) ; MultiGetRequestBuilder multiGetRequestBuilder = client ( ) . prepareMultiGet ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { multiGetRequestBuilder . add ( new MultiGetRequest . Item ( indexOrAlias ( ) , <str> , Integer . toString ( randomInt ( numDocs - <int> ) ) ) ) ; } MultiGetResponse multiGetResponse = multiGetRequestBuilder . get ( ) ; assertThat ( multiGetResponse . getResponses ( ) . length , equalTo ( iterations ) ) ; for ( int i = <int> ; i < multiGetResponse . getResponses ( ) . length ; i + + ) { MultiGetItemResponse multiGetItemResponse = multiGetResponse . getResponses ( ) [ i ] ; assertThat ( multiGetItemResponse . isFailed ( ) , equalTo ( false ) ) ; assertThat ( multiGetItemResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getId ( ) , equalTo ( multiGetRequestBuilder . request ( ) . getItems ( ) . get ( i ) . id ( ) ) ) ; assertThat ( multiGetItemResponse . getResponse ( ) . isExists ( ) , equalTo ( true ) ) ; assertThat ( multiGetItemResponse . getResponse ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getResponse ( ) . getType ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getResponse ( ) . getId ( ) , equalTo ( multiGetRequestBuilder . request ( ) . getItems ( ) . get ( i ) . id ( ) ) ) ; } } public void testScroll ( ) throws ExecutionException , InterruptedException { createIndex ( <str> ) ; ensureYellow ( <str> ) ; int numDocs = iterations ( <int> , <int> ) ; IndexRequestBuilder [ ] indexRequestBuilders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { indexRequestBuilders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + Integer . toString ( i ) ) ; } indexRandom ( true , indexRequestBuilders ) ; int size = randomIntBetween ( <int> , <int> ) ; SearchRequestBuilder searchRequestBuilder = client ( ) . prepareSearch ( <str> ) . setScroll ( <str> ) . setSize ( size ) ; SearchResponse searchResponse = searchRequestBuilder . get ( ) ; assertThat ( searchResponse . getScrollId ( ) , notNullValue ( ) ) ; assertHitCount ( searchResponse , numDocs ) ; int hits = <int> ; assertThat ( searchResponse . getHits ( ) . getHits ( ) . length , greaterThan ( <int> ) ) ; hits + = searchResponse . getHits ( ) . getHits ( ) . length ; try { do { searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( <str> ) . get ( ) ; assertThat ( searchResponse . getScrollId ( ) , notNullValue ( ) ) ; assertHitCount ( searchResponse , numDocs ) ; hits + = searchResponse . getHits ( ) . getHits ( ) . length ; } while ( searchResponse . getHits ( ) . getHits ( ) . length > <int> ) ; assertThat ( hits , equalTo ( numDocs ) ) ; } finally { clearScroll ( searchResponse . getScrollId ( ) ) ; } } private static String indexOrAlias ( ) { return randomBoolean ( ) ? <str> : <str> ; } private void createIndexWithAlias ( ) { assertAcked ( prepareCreate ( <str> ) . addAlias ( new Alias ( <str> ) ) ) ; } } 
