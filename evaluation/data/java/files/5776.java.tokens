package rx . schedulers ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import org . junit . Test ; import org . mockito . InOrder ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import rx . Observable ; import rx . Observable . OnSubscribe ; import rx . Scheduler ; import rx . Subscriber ; import rx . functions . Action0 ; import rx . functions . Action1 ; import rx . functions . Func1 ; public abstract class AbstractSchedulerTests { protected abstract Scheduler getScheduler ( ) ; @Test public void testNestedActions ( ) throws InterruptedException { Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Action0 firstStepStart = mock ( Action0 . class ) ; final Action0 firstStepEnd = mock ( Action0 . class ) ; final Action0 secondStepStart = mock ( Action0 . class ) ; final Action0 secondStepEnd = mock ( Action0 . class ) ; final Action0 thirdStepStart = mock ( Action0 . class ) ; final Action0 thirdStepEnd = mock ( Action0 . class ) ; final Action0 firstAction = new Action0 ( ) { @Override public void call ( ) { firstStepStart . call ( ) ; firstStepEnd . call ( ) ; latch . countDown ( ) ; } } ; final Action0 secondAction = new Action0 ( ) { @Override public void call ( ) { secondStepStart . call ( ) ; inner . schedule ( firstAction ) ; secondStepEnd . call ( ) ; } } ; final Action0 thirdAction = new Action0 ( ) { @Override public void call ( ) { thirdStepStart . call ( ) ; inner . schedule ( secondAction ) ; thirdStepEnd . call ( ) ; } } ; InOrder inOrder = inOrder ( firstStepStart , firstStepEnd , secondStepStart , secondStepEnd , thirdStepStart , thirdStepEnd ) ; inner . schedule ( thirdAction ) ; latch . await ( ) ; inOrder . verify ( thirdStepStart , times ( <int> ) ) . call ( ) ; inOrder . verify ( thirdStepEnd , times ( <int> ) ) . call ( ) ; inOrder . verify ( secondStepStart , times ( <int> ) ) . call ( ) ; inOrder . verify ( secondStepEnd , times ( <int> ) ) . call ( ) ; inOrder . verify ( firstStepStart , times ( <int> ) ) . call ( ) ; inOrder . verify ( firstStepEnd , times ( <int> ) ) . call ( ) ; } finally { inner . unsubscribe ( ) ; } } @Test public final void testNestedScheduling ( ) { Observable < Integer > ids = Observable . from ( Arrays . asList ( <int> , <int> ) ) . subscribeOn ( getScheduler ( ) ) ; Observable < String > m = ids . flatMap ( new Func1 < Integer , Observable < String > > ( ) { @Override public Observable < String > call ( Integer id ) { return Observable . from ( Arrays . asList ( <str> + id , <str> + id ) ) . subscribeOn ( getScheduler ( ) ) . map ( new Func1 < String , String > ( ) { @Override public String call ( String s ) { return <str> + s ; } } ) ; } } ) ; List < String > strings = m . toList ( ) . toBlocking ( ) . last ( ) ; assertEquals ( <int> , strings . size ( ) ) ; assertTrue ( strings . contains ( <str> ) ) ; assertTrue ( strings . contains ( <str> ) ) ; assertTrue ( strings . contains ( <str> ) ) ; assertTrue ( strings . contains ( <str> ) ) ; } @SuppressWarnings ( <str> ) @Test public final void testSequenceOfActions ( ) throws InterruptedException { final Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Action0 first = mock ( Action0 . class ) ; final Action0 second = mock ( Action0 . class ) ; doAnswer ( new Answer ( ) { @Override public Object answer ( InvocationOnMock invocation ) throws Throwable { try { return invocation . getMock ( ) ; } finally { latch . countDown ( ) ; } } } ) . when ( first ) . call ( ) ; doAnswer ( new Answer ( ) { @Override public Object answer ( InvocationOnMock invocation ) throws Throwable { try { return invocation . getMock ( ) ; } finally { latch . countDown ( ) ; } } } ) . when ( second ) . call ( ) ; inner . schedule ( first ) ; inner . schedule ( second ) ; latch . await ( ) ; verify ( first , times ( <int> ) ) . call ( ) ; verify ( second , times ( <int> ) ) . call ( ) ; } finally { inner . unsubscribe ( ) ; } } @Test public void testSequenceOfDelayedActions ( ) throws InterruptedException { Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Action0 first = mock ( Action0 . class ) ; final Action0 second = mock ( Action0 . class ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { inner . schedule ( first , <int> , TimeUnit . MILLISECONDS ) ; inner . schedule ( second , <int> , TimeUnit . MILLISECONDS ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { latch . countDown ( ) ; } } , <int> , TimeUnit . MILLISECONDS ) ; } } ) ; latch . await ( ) ; InOrder inOrder = inOrder ( first , second ) ; inOrder . verify ( second , times ( <int> ) ) . call ( ) ; inOrder . verify ( first , times ( <int> ) ) . call ( ) ; } finally { inner . unsubscribe ( ) ; } } @Test public void testMixOfDelayedAndNonDelayedActions ( ) throws InterruptedException { Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Action0 first = mock ( Action0 . class ) ; final Action0 second = mock ( Action0 . class ) ; final Action0 third = mock ( Action0 . class ) ; final Action0 fourth = mock ( Action0 . class ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { inner . schedule ( first ) ; inner . schedule ( second , <int> , TimeUnit . MILLISECONDS ) ; inner . schedule ( third , <int> , TimeUnit . MILLISECONDS ) ; inner . schedule ( fourth ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { latch . countDown ( ) ; } } , <int> , TimeUnit . MILLISECONDS ) ; } } ) ; latch . await ( ) ; InOrder inOrder = inOrder ( first , second , third , fourth ) ; inOrder . verify ( first , times ( <int> ) ) . call ( ) ; inOrder . verify ( fourth , times ( <int> ) ) . call ( ) ; inOrder . verify ( third , times ( <int> ) ) . call ( ) ; inOrder . verify ( second , times ( <int> ) ) . call ( ) ; } finally { inner . unsubscribe ( ) ; } } @Test public final void testRecursiveExecution ( ) throws InterruptedException { final Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final AtomicInteger i = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { if ( i . incrementAndGet ( ) < <int> ) { inner . schedule ( this ) ; } else { latch . countDown ( ) ; } } } ) ; latch . await ( ) ; assertEquals ( <int> , i . get ( ) ) ; } finally { inner . unsubscribe ( ) ; } } @Test public final void testRecursiveExecutionWithDelayTime ( ) throws InterruptedException { Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try { final AtomicInteger i = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; inner . schedule ( new Action0 ( ) { int state = <int> ; @Override public void call ( ) { i . set ( state ) ; if ( state + + < <int> ) { inner . schedule ( this , <int> , TimeUnit . MILLISECONDS ) ; } else { latch . countDown ( ) ; } } } ) ; latch . await ( ) ; assertEquals ( <int> , i . get ( ) ) ; } finally { inner . unsubscribe ( ) ; } } @Test public final void testRecursiveSchedulerInObservable ( ) { Observable < Integer > obs = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( final Subscriber < ? super Integer > observer ) { final Scheduler . Worker inner = getScheduler ( ) . createWorker ( ) ; observer . add ( inner ) ; inner . schedule ( new Action0 ( ) { int i = <int> ; @Override public void call ( ) { if ( i > <int> ) { observer . onCompleted ( ) ; return ; } observer . onNext ( i + + ) ; inner . schedule ( this ) ; } } ) ; } } ) ; final AtomicInteger lastValue = new AtomicInteger ( ) ; obs . toBlocking ( ) . forEach ( new Action1 < Integer > ( ) { @Override public void call ( Integer v ) { System . out . println ( <str> + v ) ; lastValue . set ( v ) ; } } ) ; assertEquals ( <int> , lastValue . get ( ) ) ; } @Test public final void testConcurrentOnNextFailsValidation ( ) throws InterruptedException { final int count = <int> ; final CountDownLatch latch = new CountDownLatch ( count ) ; Observable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { for ( int i = <int> ; i < count ; i + + ) { final int v = i ; new Thread ( new Runnable ( ) { @Override public void run ( ) { observer . onNext ( <str> + v ) ; latch . countDown ( ) ; } } ) . start ( ) ; } } } ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < String > ( ) ; o . subscribe ( observer ) ; if ( ! observer . completed . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } if ( observer . error . get ( ) = = null ) { fail ( <str> ) ; } } @Test public final void testObserveOn ( ) throws InterruptedException { final Scheduler scheduler = getScheduler ( ) ; Observable < String > o = Observable . just ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < String > ( ) ; o . observeOn ( scheduler ) . subscribe ( observer ) ; if ( ! observer . completed . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } if ( observer . error . get ( ) ! = null ) { observer . error . get ( ) . printStackTrace ( ) ; fail ( <str> + observer . error . get ( ) . getMessage ( ) ) ; } } @Test public final void testSubscribeOnNestedConcurrency ( ) throws InterruptedException { final Scheduler scheduler = getScheduler ( ) ; Observable < String > o = Observable . just ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) . flatMap ( new Func1 < String , Observable < String > > ( ) { @Override public Observable < String > call ( final String v ) { return Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { observer . onNext ( <str> + v ) ; observer . onCompleted ( ) ; } } ) . subscribeOn ( scheduler ) ; } } ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < String > ( ) ; o . subscribe ( observer ) ; if ( ! observer . completed . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } if ( observer . error . get ( ) ! = null ) { observer . error . get ( ) . printStackTrace ( ) ; fail ( <str> + observer . error . get ( ) . getMessage ( ) ) ; } } private static class ConcurrentObserverValidator < T > extends Subscriber < T > { final AtomicInteger concurrentCounter = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; final CountDownLatch completed = new CountDownLatch ( <int> ) ; @Override public void onCompleted ( ) { completed . countDown ( ) ; } @Override public void onError ( Throwable e ) { error . set ( e ) ; completed . countDown ( ) ; } @Override public void onNext ( T args ) { int count = concurrentCounter . incrementAndGet ( ) ; System . out . println ( <str> + args ) ; if ( count > <int> ) { onError ( new RuntimeException ( <str> ) ) ; } try { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } finally { concurrentCounter . decrementAndGet ( ) ; } } } }