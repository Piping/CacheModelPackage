package com . google . common . collect . testing ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . fail ; import com . google . common . annotations . GwtCompatible ; import junit . framework . AssertionFailedError ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . Stack ; @GwtCompatible abstract class AbstractIteratorTester < E , I extends Iterator < E > > { private boolean whenNextThrowsExceptionStopTestingCallsToRemove ; private boolean whenAddThrowsExceptionStopTesting ; public void ignoreSunJavaBug6529795 ( ) { whenNextThrowsExceptionStopTestingCallsToRemove = true ; } public void stopTestingWhenAddThrowsException ( ) { whenAddThrowsExceptionStopTesting = true ; } private Stimulus < E , ? super I > [ ] stimuli ; private final Iterator < E > elementsToInsert ; private final Set < IteratorFeature > features ; private final List < E > expectedElements ; private final int startIndex ; private final KnownOrder knownOrder ; private static final class PermittedMetaException extends RuntimeException { final Set < ? extends Class < ? extends RuntimeException > > exceptionClasses ; PermittedMetaException ( Set < ? extends Class < ? extends RuntimeException > > exceptionClasses ) { super ( <str> + exceptionClasses ) ; this . exceptionClasses = exceptionClasses ; } PermittedMetaException ( Class < ? extends RuntimeException > exceptionClass ) { this ( Collections . singleton ( exceptionClass ) ) ; } boolean isPermitted ( RuntimeException exception ) { for ( Class < ? extends RuntimeException > clazz : exceptionClasses ) { if ( Platform . checkIsInstance ( clazz , exception ) ) { return true ; } } return false ; } void assertPermitted ( RuntimeException exception ) { if ( ! isPermitted ( exception ) ) { String message = <str> + exception . getClass ( ) + <str> + this ; Helpers . fail ( exception , message ) ; } } @Override public String toString ( ) { return getMessage ( ) ; } private static final long serialVersionUID = <int> ; } private static final class UnknownElementException extends RuntimeException { private UnknownElementException ( Collection < ? > expected , Object actual ) { super ( <str> + actual + <str> + expected ) ; } private static final long serialVersionUID = <int> ; } protected final class MultiExceptionListIterator implements ListIterator < E > { final Stack < E > nextElements = new Stack < E > ( ) ; final Stack < E > previousElements = new Stack < E > ( ) ; Stack < E > stackWithLastReturnedElementAtTop = null ; MultiExceptionListIterator ( List < E > expectedElements ) { Helpers . addAll ( nextElements , Helpers . reverse ( expectedElements ) ) ; for ( int i = <int> ; i < startIndex ; i + + ) { previousElements . push ( nextElements . pop ( ) ) ; } } @Override public void add ( E e ) { if ( ! features . contains ( IteratorFeature . SUPPORTS_ADD ) ) { throw new PermittedMetaException ( UnsupportedOperationException . class ) ; } previousElements . push ( e ) ; stackWithLastReturnedElementAtTop = null ; } @Override public boolean hasNext ( ) { return ! nextElements . isEmpty ( ) ; } @Override public boolean hasPrevious ( ) { return ! previousElements . isEmpty ( ) ; } @Override public E next ( ) { return transferElement ( nextElements , previousElements ) ; } @Override public int nextIndex ( ) { return previousElements . size ( ) ; } @Override public E previous ( ) { return transferElement ( previousElements , nextElements ) ; } @Override public int previousIndex ( ) { return nextIndex ( ) - <int> ; } @Override public void remove ( ) { throwIfInvalid ( IteratorFeature . SUPPORTS_REMOVE ) ; stackWithLastReturnedElementAtTop . pop ( ) ; stackWithLastReturnedElementAtTop = null ; } @Override public void set ( E e ) { throwIfInvalid ( IteratorFeature . SUPPORTS_SET ) ; stackWithLastReturnedElementAtTop . pop ( ) ; stackWithLastReturnedElementAtTop . push ( e ) ; } void promoteToNext ( E e ) { if ( nextElements . remove ( e ) ) { nextElements . push ( e ) ; } else { throw new UnknownElementException ( nextElements , e ) ; } } private E transferElement ( Stack < E > source , Stack < E > destination ) { if ( source . isEmpty ( ) ) { throw new PermittedMetaException ( NoSuchElementException . class ) ; } destination . push ( source . pop ( ) ) ; stackWithLastReturnedElementAtTop = destination ; return destination . peek ( ) ; } private void throwIfInvalid ( IteratorFeature methodFeature ) { Set < Class < ? extends RuntimeException > > exceptions = new HashSet < Class < ? extends RuntimeException > > ( ) ; if ( ! features . contains ( methodFeature ) ) { exceptions . add ( UnsupportedOperationException . class ) ; } if ( stackWithLastReturnedElementAtTop = = null ) { exceptions . add ( IllegalStateException . class ) ; } if ( ! exceptions . isEmpty ( ) ) { throw new PermittedMetaException ( exceptions ) ; } } private List < E > getElements ( ) { List < E > elements = new ArrayList < E > ( ) ; Helpers . addAll ( elements , previousElements ) ; Helpers . addAll ( elements , Helpers . reverse ( nextElements ) ) ; return elements ; } } public enum KnownOrder { KNOWN_ORDER , UNKNOWN_ORDER } @SuppressWarnings ( <str> ) AbstractIteratorTester ( int steps , Iterable < E > elementsToInsertIterable , Iterable < ? extends IteratorFeature > features , Iterable < E > expectedElements , KnownOrder knownOrder , int startIndex ) { stimuli = new Stimulus [ steps ] ; if ( ! elementsToInsertIterable . iterator ( ) . hasNext ( ) ) { throw new IllegalArgumentException ( ) ; } elementsToInsert = Helpers . cycle ( elementsToInsertIterable ) ; this . features = Helpers . copyToSet ( features ) ; this . expectedElements = Helpers . copyToList ( expectedElements ) ; this . knownOrder = knownOrder ; this . startIndex = startIndex ; } protected abstract Iterable < ? extends Stimulus < E , ? super I > > getStimulusValues ( ) ; protected abstract I newTargetIterator ( ) ; protected void verify ( List < E > elements ) { } public final void test ( ) { try { recurse ( <int> ) ; } catch ( RuntimeException e ) { throw new RuntimeException ( Arrays . toString ( stimuli ) , e ) ; } } private void recurse ( int level ) { if ( level = = stimuli . length ) { compareResultsForThisListOfStimuli ( ) ; } else { for ( Stimulus < E , ? super I > stimulus : getStimulusValues ( ) ) { stimuli [ level ] = stimulus ; recurse ( level + <int> ) ; } } } private void compareResultsForThisListOfStimuli ( ) { MultiExceptionListIterator reference = new MultiExceptionListIterator ( expectedElements ) ; I target = newTargetIterator ( ) ; boolean shouldStopTestingCallsToRemove = false ; for ( int i = <int> ; i < stimuli . length ; i + + ) { Stimulus < E , ? super I > stimulus = stimuli [ i ] ; if ( stimulus . equals ( remove ) & & shouldStopTestingCallsToRemove ) { break ; } try { boolean threwException = stimulus . executeAndCompare ( reference , target ) ; if ( threwException & & stimulus . equals ( next ) & & whenNextThrowsExceptionStopTestingCallsToRemove ) { shouldStopTestingCallsToRemove = true ; } if ( threwException & & stimulus . equals ( add ) & & whenAddThrowsExceptionStopTesting ) { break ; } List < E > elements = reference . getElements ( ) ; verify ( elements ) ; } catch ( AssertionFailedError cause ) { Helpers . fail ( cause , <str> + subListCopy ( stimuli , i + <int> ) ) ; } } } private static List < Object > subListCopy ( Object [ ] source , int size ) { final Object [ ] copy = new Object [ size ] ; System . arraycopy ( source , <int> , copy , <int> , size ) ; return Arrays . asList ( copy ) ; } private interface IteratorOperation { Object execute ( Iterator < ? > iterator ) ; } private < T extends Iterator < E > > boolean internalExecuteAndCompare ( T reference , T target , IteratorOperation method ) throws AssertionFailedError { Object referenceReturnValue = null ; PermittedMetaException referenceException = null ; Object targetReturnValue = null ; RuntimeException targetException = null ; try { targetReturnValue = method . execute ( target ) ; } catch ( RuntimeException e ) { targetException = e ; } try { if ( method = = NEXT_METHOD & & targetException = = null & & knownOrder = = KnownOrder . UNKNOWN_ORDER ) { @SuppressWarnings ( <str> ) E targetReturnValueFromNext = ( E ) targetReturnValue ; MultiExceptionListIterator multiExceptionListIterator = ( MultiExceptionListIterator ) reference ; multiExceptionListIterator . promoteToNext ( targetReturnValueFromNext ) ; } referenceReturnValue = method . execute ( reference ) ; } catch ( PermittedMetaException e ) { referenceException = e ; } catch ( UnknownElementException e ) { Helpers . fail ( e , e . getMessage ( ) ) ; } if ( referenceException = = null ) { if ( targetException ! = null ) { Helpers . fail ( targetException , <str> ) ; } assertEquals ( referenceReturnValue , targetReturnValue ) ; return false ; } if ( targetException = = null ) { fail ( <str> + referenceException ) ; } referenceException . assertPermitted ( targetException ) ; return true ; } private static final IteratorOperation REMOVE_METHOD = new IteratorOperation ( ) { @Override public Object execute ( Iterator < ? > iterator ) { iterator . remove ( ) ; return null ; } } ; private static final IteratorOperation NEXT_METHOD = new IteratorOperation ( ) { @Override public Object execute ( Iterator < ? > iterator ) { return iterator . next ( ) ; } } ; private static final IteratorOperation PREVIOUS_METHOD = new IteratorOperation ( ) { @Override public Object execute ( Iterator < ? > iterator ) { return ( ( ListIterator < ? > ) iterator ) . previous ( ) ; } } ; private final IteratorOperation newAddMethod ( ) { final Object toInsert = elementsToInsert . next ( ) ; return new IteratorOperation ( ) { @Override public Object execute ( Iterator < ? > iterator ) { @SuppressWarnings ( <str> ) ListIterator < Object > rawIterator = ( ListIterator < Object > ) iterator ; rawIterator . add ( toInsert ) ; return null ; } } ; } private final IteratorOperation newSetMethod ( ) { final E toInsert = elementsToInsert . next ( ) ; return new IteratorOperation ( ) { @Override public Object execute ( Iterator < ? > iterator ) { @SuppressWarnings ( <str> ) ListIterator < E > li = ( ListIterator < E > ) iterator ; li . set ( toInsert ) ; return null ; } } ; } abstract static class Stimulus < E , T extends Iterator < E > > { private final String toString ; protected Stimulus ( String toString ) { this . toString = toString ; } abstract boolean executeAndCompare ( ListIterator < E > reference , T target ) ; @Override public String toString ( ) { return toString ; } } Stimulus < E , Iterator < E > > hasNext = new Stimulus < E , Iterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , Iterator < E > target ) { assertEquals ( reference . hasNext ( ) , target . hasNext ( ) ) ; return false ; } } ; Stimulus < E , Iterator < E > > next = new Stimulus < E , Iterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , Iterator < E > target ) { return internalExecuteAndCompare ( reference , target , NEXT_METHOD ) ; } } ; Stimulus < E , Iterator < E > > remove = new Stimulus < E , Iterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , Iterator < E > target ) { return internalExecuteAndCompare ( reference , target , REMOVE_METHOD ) ; } } ; @SuppressWarnings ( <str> ) List < Stimulus < E , Iterator < E > > > iteratorStimuli ( ) { return Arrays . asList ( hasNext , next , remove ) ; } Stimulus < E , ListIterator < E > > hasPrevious = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { assertEquals ( reference . hasPrevious ( ) , target . hasPrevious ( ) ) ; return false ; } } ; Stimulus < E , ListIterator < E > > nextIndex = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { assertEquals ( reference . nextIndex ( ) , target . nextIndex ( ) ) ; return false ; } } ; Stimulus < E , ListIterator < E > > previousIndex = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { assertEquals ( reference . previousIndex ( ) , target . previousIndex ( ) ) ; return false ; } } ; Stimulus < E , ListIterator < E > > previous = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { return internalExecuteAndCompare ( reference , target , PREVIOUS_METHOD ) ; } } ; Stimulus < E , ListIterator < E > > add = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { return internalExecuteAndCompare ( reference , target , newAddMethod ( ) ) ; } } ; Stimulus < E , ListIterator < E > > set = new Stimulus < E , ListIterator < E > > ( <str> ) { @Override boolean executeAndCompare ( ListIterator < E > reference , ListIterator < E > target ) { return internalExecuteAndCompare ( reference , target , newSetMethod ( ) ) ; } } ; @SuppressWarnings ( <str> ) List < Stimulus < E , ListIterator < E > > > listIteratorStimuli ( ) { return Arrays . asList ( hasPrevious , nextIndex , previousIndex , previous , add , set ) ; } } 
