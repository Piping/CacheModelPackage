package com . google . common . util . concurrent ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Queues ; import junit . framework . TestCase ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public class SerializingExecutorTest extends TestCase { private static class FakeExecutor implements Executor { Queue < Runnable > tasks = Queues . newArrayDeque ( ) ; @Override public void execute ( Runnable command ) { tasks . add ( command ) ; } boolean hasNext ( ) { return ! tasks . isEmpty ( ) ; } void runNext ( ) { assertTrue ( <str> , hasNext ( ) ) ; tasks . remove ( ) . run ( ) ; } void runAll ( ) { while ( hasNext ( ) ) { runNext ( ) ; } } } private FakeExecutor fakePool ; private SerializingExecutor e ; @Override public void setUp ( ) { fakePool = new FakeExecutor ( ) ; e = new SerializingExecutor ( fakePool ) ; } public void testSerializingNullExecutor_fails ( ) { try { new SerializingExecutor ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBasics ( ) { final AtomicInteger totalCalls = new AtomicInteger ( ) ; Runnable intCounter = new Runnable ( ) { @Override public void run ( ) { totalCalls . incrementAndGet ( ) ; assertFalse ( fakePool . hasNext ( ) ) ; } } ; assertFalse ( fakePool . hasNext ( ) ) ; e . execute ( intCounter ) ; assertTrue ( fakePool . hasNext ( ) ) ; e . execute ( intCounter ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; fakePool . runAll ( ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; assertFalse ( fakePool . hasNext ( ) ) ; e . execute ( intCounter ) ; e . execute ( intCounter ) ; e . execute ( intCounter ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; fakePool . runAll ( ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; assertFalse ( fakePool . hasNext ( ) ) ; } public void testSuspend ( ) { final AtomicInteger totalCalls = new AtomicInteger ( ) ; Runnable suspender = new Runnable ( ) { @Override public void run ( ) { totalCalls . incrementAndGet ( ) ; e . suspend ( ) ; } } ; assertFalse ( fakePool . hasNext ( ) ) ; e . execute ( suspender ) ; assertTrue ( fakePool . hasNext ( ) ) ; e . execute ( suspender ) ; fakePool . runAll ( ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; assertFalse ( fakePool . hasNext ( ) ) ; e . execute ( suspender ) ; assertFalse ( fakePool . hasNext ( ) ) ; e . resume ( ) ; assertTrue ( fakePool . hasNext ( ) ) ; fakePool . runAll ( ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; assertFalse ( fakePool . hasNext ( ) ) ; e . suspend ( ) ; e . resume ( ) ; assertFalse ( fakePool . hasNext ( ) ) ; e . resume ( ) ; assertTrue ( fakePool . hasNext ( ) ) ; fakePool . runAll ( ) ; assertEquals ( <int> , totalCalls . get ( ) ) ; } public void testOrdering ( ) { final List < Integer > callOrder = Lists . newArrayList ( ) ; class FakeOp implements Runnable { final int op ; FakeOp ( int op ) { this . op = op ; } @Override public void run ( ) { callOrder . add ( op ) ; } } e . execute ( new FakeOp ( <int> ) ) ; e . execute ( new FakeOp ( <int> ) ) ; e . execute ( new FakeOp ( <int> ) ) ; fakePool . runAll ( ) ; assertEquals ( ImmutableList . of ( <int> , <int> , <int> ) , callOrder ) ; } public void testPrependContinuation ( ) { final List < Integer > callOrder = Lists . newArrayList ( ) ; class FakeOp implements Runnable { final int op ; FakeOp ( int op ) { this . op = op ; } @Override public void run ( ) { callOrder . add ( op ) ; } } e . execute ( new FakeOp ( <int> ) ) ; e . execute ( new FakeOp ( <int> ) ) ; e . executeFirst ( new FakeOp ( <int> ) ) ; fakePool . runAll ( ) ; assertEquals ( ImmutableList . of ( <int> , <int> , <int> ) , callOrder ) ; } public void testRuntimeException_doesNotStopExecution ( ) { final AtomicInteger numCalls = new AtomicInteger ( ) ; Runnable runMe = new Runnable ( ) { @Override public void run ( ) { numCalls . incrementAndGet ( ) ; throw new RuntimeException ( <str> ) ; } } ; e . execute ( runMe ) ; e . execute ( runMe ) ; fakePool . runAll ( ) ; assertEquals ( <int> , numCalls . get ( ) ) ; } public void testInterrupt_doesNotStopExecution ( ) { final AtomicInteger numCalls = new AtomicInteger ( ) ; Runnable runMe = new Runnable ( ) { @Override public void run ( ) { numCalls . incrementAndGet ( ) ; } } ; Thread . currentThread ( ) . interrupt ( ) ; e . execute ( runMe ) ; e . execute ( runMe ) ; fakePool . runAll ( ) ; assertEquals ( <int> , numCalls . get ( ) ) ; assertTrue ( Thread . interrupted ( ) ) ; } public void testDelegateRejection ( ) { final AtomicInteger numCalls = new AtomicInteger ( ) ; final AtomicBoolean reject = new AtomicBoolean ( true ) ; final SerializingExecutor executor = new SerializingExecutor ( new Executor ( ) { @Override public void execute ( Runnable r ) { if ( reject . get ( ) ) { throw new RejectedExecutionException ( ) ; } r . run ( ) ; } } ) ; Runnable task = new Runnable ( ) { @Override public void run ( ) { numCalls . incrementAndGet ( ) ; } } ; try { executor . execute ( task ) ; fail ( ) ; } catch ( RejectedExecutionException expected ) { } assertEquals ( <int> , numCalls . get ( ) ) ; reject . set ( false ) ; executor . execute ( task ) ; assertEquals ( <int> , numCalls . get ( ) ) ; } public void testTaskThrowsError ( ) throws Exception { class MyError extends Error { } final CyclicBarrier barrier = new CyclicBarrier ( <int> ) ; ExecutorService service = Executors . newSingleThreadExecutor ( ) ; try { final SerializingExecutor executor = new SerializingExecutor ( service ) ; Runnable errorTask = new Runnable ( ) { @Override public void run ( ) { throw new MyError ( ) ; } } ; Runnable barrierTask = new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; executor . execute ( errorTask ) ; service . execute ( barrierTask ) ; barrier . await ( <int> , TimeUnit . SECONDS ) ; executor . execute ( barrierTask ) ; barrier . await ( <int> , TimeUnit . SECONDS ) ; } finally { service . shutdown ( ) ; } } }