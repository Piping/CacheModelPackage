package org . apache . cassandra . utils . memory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicReference ; import com . google . common . util . concurrent . Uninterruptibles ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . utils . concurrent . OpOrder ; public class NativeAllocatorTest { @Test public void testBookKeeping ( ) throws ExecutionException , InterruptedException { { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( <int> ) ; final OpOrder order = new OpOrder ( ) ; final OpOrder . Group group = order . start ( ) ; final CountDownLatch canClean = new CountDownLatch ( <int> ) ; final CountDownLatch isClean = new CountDownLatch ( <int> ) ; final AtomicReference < NativeAllocator > allocatorRef = new AtomicReference < > ( ) ; final AtomicReference < OpOrder . Barrier > barrier = new AtomicReference < > ( ) ; final NativeAllocator allocator = new NativeAllocator ( new NativePool ( <int> , <int> , <float> , new Runnable ( ) { public void run ( ) { try { canClean . await ( ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } if ( isClean . getCount ( ) > <int> ) { allocatorRef . get ( ) . offHeap ( ) . released ( <int> ) ; isClean . countDown ( ) ; } } } ) ) ; allocatorRef . set ( allocator ) ; final Runnable markBlocking = new Runnable ( ) { public void run ( ) { barrier . set ( order . newBarrier ( ) ) ; barrier . get ( ) . issue ( ) ; barrier . get ( ) . markBlocking ( ) ; } } ; final Runnable run = new Runnable ( ) { public void run ( ) { allocator . allocate ( <int> , group ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; allocator . offHeap ( ) . adjust ( - <int> , group ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; allocator . offHeap ( ) . adjust ( <int> , group ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; boolean success = false ; try { allocator . offHeap ( ) . allocate ( - <int> , group ) ; } catch ( AssertionError e ) { success = true ; } Assert . assertTrue ( success ) ; Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; Assert . assertEquals ( <int> , isClean . getCount ( ) ) ; allocator . allocate ( <int> , group ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; canClean . countDown ( ) ; try { isClean . await ( <int> , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } Assert . assertEquals ( <int> , isClean . getCount ( ) ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; exec . schedule ( markBlocking , <int> , TimeUnit . MILLISECONDS ) ; allocator . allocate ( <int> , group ) ; Assert . assertNotNull ( barrier . get ( ) ) ; Assert . assertEquals ( <int> , allocator . offHeap ( ) . owns ( ) ) ; } } ; exec . submit ( run ) . get ( ) ; } } }