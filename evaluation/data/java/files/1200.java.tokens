package com . badlogic . gdx . backends . iosrobovm ; import org . robovm . apple . audiotoolbox . AudioServices ; import org . robovm . apple . coregraphics . CGPoint ; import org . robovm . apple . coregraphics . CGRect ; import org . robovm . apple . foundation . NSExtensions ; import org . robovm . apple . foundation . NSObject ; import org . robovm . apple . foundation . NSRange ; import org . robovm . apple . uikit . UIAlertView ; import org . robovm . apple . uikit . UIAlertViewDelegate ; import org . robovm . apple . uikit . UIAlertViewDelegateAdapter ; import org . robovm . apple . uikit . UIAlertViewStyle ; import org . robovm . apple . uikit . UIApplication ; import org . robovm . apple . uikit . UIDevice ; import org . robovm . apple . uikit . UIEvent ; import org . robovm . apple . uikit . UIInterfaceOrientation ; import org . robovm . apple . uikit . UIKeyboardType ; import org . robovm . apple . uikit . UIReturnKeyType ; import org . robovm . apple . uikit . UITextAutocapitalizationType ; import org . robovm . apple . uikit . UITextAutocorrectionType ; import org . robovm . apple . uikit . UITextField ; import org . robovm . apple . uikit . UITextFieldDelegate ; import org . robovm . apple . uikit . UITextFieldDelegateAdapter ; import org . robovm . apple . uikit . UITextSpellCheckingType ; import org . robovm . apple . uikit . UITouch ; import org . robovm . apple . uikit . UITouchPhase ; import org . robovm . objc . annotation . Method ; import org . robovm . rt . VM ; import org . robovm . rt . bro . NativeObject ; import org . robovm . rt . bro . annotation . MachineSizedUInt ; import org . robovm . rt . bro . annotation . Pointer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . backends . iosrobovm . custom . UIAcceleration ; import com . badlogic . gdx . backends . iosrobovm . custom . UIAccelerometer ; import com . badlogic . gdx . backends . iosrobovm . custom . UIAccelerometerDelegate ; import com . badlogic . gdx . backends . iosrobovm . custom . UIAccelerometerDelegateAdapter ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . Pool ; public class IOSInput implements Input { static final int MAX_TOUCHES = <int> ; private static class NSObjectWrapper < T extends NSObject > { private static final long HANDLE_OFFSET ; static { try { HANDLE_OFFSET = VM . getInstanceFieldOffset ( VM . getFieldAddress ( NativeObject . class . getDeclaredField ( <str> ) ) ) ; } catch ( Throwable t ) { throw new Error ( t ) ; } } private final T instance ; public NSObjectWrapper ( Class < T > cls ) { instance = VM . allocateObject ( cls ) ; } public T wrap ( long handle ) { VM . setLong ( VM . getObjectAddress ( instance ) + HANDLE_OFFSET , handle ) ; return instance ; } } private static final NSObjectWrapper < UITouch > UI_TOUCH_WRAPPER = new NSObjectWrapper < UITouch > ( UITouch . class ) ; static final NSObjectWrapper < UIAcceleration > UI_ACCELERATION_WRAPPER = new NSObjectWrapper < UIAcceleration > ( UIAcceleration . class ) ; IOSApplication app ; IOSApplicationConfiguration config ; int [ ] deltaX = new int [ MAX_TOUCHES ] ; int [ ] deltaY = new int [ MAX_TOUCHES ] ; int [ ] touchX = new int [ MAX_TOUCHES ] ; int [ ] touchY = new int [ MAX_TOUCHES ] ; long [ ] touchDown = new long [ MAX_TOUCHES ] ; int numTouched = <int> ; boolean justTouched = false ; Pool < TouchEvent > touchEventPool = new Pool < TouchEvent > ( ) { @Override protected TouchEvent newObject ( ) { return new TouchEvent ( ) ; } } ; Array < TouchEvent > touchEvents = new Array < TouchEvent > ( ) ; TouchEvent currentEvent = null ; float [ ] acceleration = new float [ <int> ] ; float [ ] rotation = new float [ <int> ] ; float [ ] R = new float [ <int> ] ; InputProcessor inputProcessor = null ; boolean hasVibrator ; UIAccelerometerDelegate accelerometerDelegate ; boolean compassSupported ; boolean keyboardCloseOnReturn ; public IOSInput ( IOSApplication app ) { this . app = app ; this . config = app . config ; this . keyboardCloseOnReturn = app . config . keyboardCloseOnReturn ; } void setupPeripherals ( ) { setupAccelerometer ( ) ; setupCompass ( ) ; UIDevice device = UIDevice . getCurrentDevice ( ) ; if ( device . getModel ( ) . equalsIgnoreCase ( <str> ) ) hasVibrator = true ; } private void setupCompass ( ) { if ( config . useCompass ) { } } private void setupAccelerometer ( ) { if ( config . useAccelerometer ) { accelerometerDelegate = new UIAccelerometerDelegateAdapter ( ) { @Method ( selector = <str> ) public void didAccelerate ( UIAccelerometer accelerometer , @Pointer long valuesPtr ) { UIAcceleration values = UI_ACCELERATION_WRAPPER . wrap ( valuesPtr ) ; float x = ( float ) values . getX ( ) * <int> ; float y = ( float ) values . getY ( ) * <int> ; float z = ( float ) values . getZ ( ) * <int> ; acceleration [ <int> ] = - x ; acceleration [ <int> ] = - y ; acceleration [ <int> ] = - z ; } } ; UIAccelerometer . getSharedAccelerometer ( ) . setDelegate ( accelerometerDelegate ) ; UIAccelerometer . getSharedAccelerometer ( ) . setUpdateInterval ( config . accelerometerUpdate ) ; } } @Override public float getAccelerometerX ( ) { return acceleration [ <int> ] ; } @Override public float getAccelerometerY ( ) { return acceleration [ <int> ] ; } @Override public float getAccelerometerZ ( ) { return acceleration [ <int> ] ; } @Override public float getAzimuth ( ) { if ( ! compassSupported ) return <int> ; return rotation [ <int> ] ; } @Override public float getPitch ( ) { if ( ! compassSupported ) return <int> ; return rotation [ <int> ] ; } @Override public float getRoll ( ) { if ( ! compassSupported ) return <int> ; return rotation [ <int> ] ; } @Override public void getRotationMatrix ( float [ ] matrix ) { if ( matrix . length ! = <int> ) return ; } @Override public int getX ( ) { return touchX [ <int> ] ; } @Override public int getX ( int pointer ) { return touchX [ pointer ] ; } @Override public int getDeltaX ( ) { return deltaX [ <int> ] ; } @Override public int getDeltaX ( int pointer ) { return deltaX [ pointer ] ; } @Override public int getY ( ) { return touchY [ <int> ] ; } @Override public int getY ( int pointer ) { return touchY [ pointer ] ; } @Override public int getDeltaY ( ) { return deltaY [ <int> ] ; } @Override public int getDeltaY ( int pointer ) { return deltaY [ pointer ] ; } @Override public boolean isTouched ( ) { for ( int pointer = <int> ; pointer < MAX_TOUCHES ; pointer + + ) { if ( touchDown [ pointer ] ! = <int> ) { return true ; } } return false ; } @Override public boolean justTouched ( ) { return justTouched ; } @Override public boolean isTouched ( int pointer ) { return touchDown [ pointer ] ! = <int> ; } @Override public boolean isButtonPressed ( int button ) { return button = = Buttons . LEFT & & numTouched > <int> ; } @Override public boolean isKeyPressed ( int key ) { return false ; } @Override public boolean isKeyJustPressed ( int key ) { return false ; } @Override public void getTextInput ( TextInputListener listener , String title , String text , String hint ) { buildUIAlertView ( listener , title , text , hint ) . show ( ) ; } private class HiddenTextField extends UITextField { public HiddenTextField ( CGRect frame ) { super ( frame ) ; setKeyboardType ( UIKeyboardType . Default ) ; setReturnKeyType ( UIReturnKeyType . Done ) ; setAutocapitalizationType ( UITextAutocapitalizationType . None ) ; setAutocorrectionType ( UITextAutocorrectionType . No ) ; setSpellCheckingType ( UITextSpellCheckingType . No ) ; setHidden ( true ) ; } @Override public void deleteBackward ( ) { app . input . inputProcessor . keyTyped ( ( char ) <int> ) ; super . deleteBackward ( ) ; Gdx . graphics . requestRendering ( ) ; } } private UITextField textfield = null ; private final UITextFieldDelegate textDelegate = new UITextFieldDelegateAdapter ( ) { @Override public boolean shouldChangeCharacters ( UITextField textField , NSRange range , String string ) { for ( int i = <int> ; i < range . getLength ( ) ; i + + ) { app . input . inputProcessor . keyTyped ( ( char ) <int> ) ; } if ( string . isEmpty ( ) ) { if ( range . getLength ( ) > <int> ) Gdx . graphics . requestRendering ( ) ; return false ; } char [ ] chars = new char [ string . length ( ) ] ; string . getChars ( <int> , string . length ( ) , chars , <int> ) ; for ( int i = <int> ; i < chars . length ; i + + ) { app . input . inputProcessor . keyTyped ( chars [ i ] ) ; } Gdx . graphics . requestRendering ( ) ; return true ; } @Override public boolean shouldEndEditing ( UITextField textField ) { textField . setText ( <str> ) ; Gdx . graphics . requestRendering ( ) ; return true ; } @Override public boolean shouldReturn ( UITextField textField ) { if ( keyboardCloseOnReturn ) setOnscreenKeyboardVisible ( false ) ; app . input . inputProcessor . keyDown ( Keys . ENTER ) ; app . input . inputProcessor . keyTyped ( ( char ) <int> ) ; Gdx . graphics . requestRendering ( ) ; return false ; } } ; @Override public void setOnscreenKeyboardVisible ( boolean visible ) { if ( textfield = = null ) createDefaultTextField ( ) ; if ( visible ) { textfield . becomeFirstResponder ( ) ; textfield . setDelegate ( textDelegate ) ; } else { textfield . resignFirstResponder ( ) ; } } public void setKeyboardCloseOnReturnKey ( boolean shouldClose ) { keyboardCloseOnReturn = shouldClose ; } public UITextField getKeyboardTextField ( ) { if ( textfield = = null ) createDefaultTextField ( ) ; return textfield ; } private void createDefaultTextField ( ) { textfield = new UITextField ( new CGRect ( <int> , <int> , <int> , <int> ) ) ; textfield . setKeyboardType ( UIKeyboardType . Default ) ; textfield . setReturnKeyType ( UIReturnKeyType . Done ) ; textfield . setAutocapitalizationType ( UITextAutocapitalizationType . None ) ; textfield . setAutocorrectionType ( UITextAutocorrectionType . No ) ; textfield . setSpellCheckingType ( UITextSpellCheckingType . No ) ; textfield . setHidden ( true ) ; textfield . setText ( <str> ) ; app . getUIViewController ( ) . getView ( ) . addSubview ( textfield ) ; } UIAlertViewDelegate delegate ; private UIAlertView buildUIAlertView ( final TextInputListener listener , String title , String text , String placeholder ) { delegate = new UIAlertViewDelegateAdapter ( ) { @Override public void clicked ( UIAlertView view , long clicked ) { if ( clicked = = <int> ) { listener . canceled ( ) ; } else if ( clicked = = <int> ) { UITextField textField = view . getTextField ( <int> ) ; listener . input ( textField . getText ( ) ) ; } delegate = null ; } @Override public void cancel ( UIAlertView view ) { listener . canceled ( ) ; delegate = null ; } } ; final UIAlertView uiAlertView = new UIAlertView ( ) ; uiAlertView . setTitle ( title ) ; uiAlertView . addButton ( <str> ) ; uiAlertView . addButton ( <str> ) ; uiAlertView . setAlertViewStyle ( UIAlertViewStyle . PlainTextInput ) ; uiAlertView . setDelegate ( delegate ) ; UITextField textField = uiAlertView . getTextField ( <int> ) ; textField . setPlaceholder ( placeholder ) ; textField . setText ( text ) ; return uiAlertView ; } @Override public void vibrate ( int milliseconds ) { AudioServices . playSystemSound ( <int> ) ; } @Override public void vibrate ( long [ ] pattern , int repeat ) { } @Override public void cancelVibrate ( ) { } @Override public long getCurrentEventTime ( ) { return currentEvent . timestamp ; } @Override public void setCatchBackKey ( boolean catchBack ) { } @Override public boolean isCatchBackKey ( ) { return false ; } @Override public void setCatchMenuKey ( boolean catchMenu ) { } @Override public boolean isCatchMenuKey ( ) { return false ; } @Override public void setInputProcessor ( InputProcessor processor ) { this . inputProcessor = processor ; } @Override public InputProcessor getInputProcessor ( ) { return inputProcessor ; } @Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { if ( peripheral = = Peripheral . Accelerometer & & config . useAccelerometer ) return true ; if ( peripheral = = Peripheral . MultitouchScreen ) return true ; if ( peripheral = = Peripheral . Vibrator ) return hasVibrator ; if ( peripheral = = Peripheral . Compass ) return compassSupported ; return false ; } @Override public int getRotation ( ) { UIInterfaceOrientation orientation = app . graphics . viewController ! = null ? app . graphics . viewController . getInterfaceOrientation ( ) : UIApplication . getSharedApplication ( ) . getStatusBarOrientation ( ) ; if ( orientation = = UIInterfaceOrientation . Portrait ) return <int> ; if ( orientation = = UIInterfaceOrientation . LandscapeLeft ) return <int> ; if ( orientation = = UIInterfaceOrientation . PortraitUpsideDown ) return <int> ; if ( orientation = = UIInterfaceOrientation . LandscapeRight ) return <int> ; return <int> ; } @Override public Orientation getNativeOrientation ( ) { return Orientation . Portrait ; } @Override public void setCursorCatched ( boolean catched ) { } @Override public boolean isCursorCatched ( ) { return false ; } @Override public void setCursorPosition ( int x , int y ) { } public void touchDown ( long touches , UIEvent event ) { toTouchEvents ( touches , event ) ; Gdx . graphics . requestRendering ( ) ; } public void touchUp ( long touches , UIEvent event ) { toTouchEvents ( touches , event ) ; Gdx . graphics . requestRendering ( ) ; } public void touchMoved ( long touches , UIEvent event ) { toTouchEvents ( touches , event ) ; Gdx . graphics . requestRendering ( ) ; } void processEvents ( ) { synchronized ( touchEvents ) { justTouched = false ; for ( TouchEvent event : touchEvents ) { currentEvent = event ; switch ( event . phase ) { case Began : if ( inputProcessor ! = null ) inputProcessor . touchDown ( event . x , event . y , event . pointer , Buttons . LEFT ) ; if ( numTouched = = <int> ) justTouched = true ; break ; case Cancelled : case Ended : if ( inputProcessor ! = null ) inputProcessor . touchUp ( event . x , event . y , event . pointer , Buttons . LEFT ) ; break ; case Moved : case Stationary : if ( inputProcessor ! = null ) inputProcessor . touchDragged ( event . x , event . y , event . pointer ) ; break ; } } touchEventPool . freeAll ( touchEvents ) ; touchEvents . clear ( ) ; } } private int getFreePointer ( ) { for ( int i = <int> ; i < touchDown . length ; i + + ) { if ( touchDown [ i ] = = <int> ) return i ; } throw new GdxRuntimeException ( <str> ) ; } private int findPointer ( UITouch touch ) { long ptr = touch . getHandle ( ) ; for ( int i = <int> ; i < touchDown . length ; i + + ) { if ( touchDown [ i ] = = ptr ) return i ; } throw new GdxRuntimeException ( <str> ) ; } private static class NSSetExtensions extends NSExtensions { @Method ( selector = <str> ) public static native @Pointer long allObjects ( @Pointer long thiz ) ; } private static class NSArrayExtensions extends NSExtensions { @Method ( selector = <str> ) public static native @Pointer long objectAtIndex$ ( @Pointer long thiz , @MachineSizedUInt long index ) ; @Method ( selector = <str> ) public static native @MachineSizedUInt long count ( @Pointer long thiz ) ; } private void toTouchEvents ( long touches , UIEvent uiEvent ) { long array = NSSetExtensions . allObjects ( touches ) ; int length = ( int ) NSArrayExtensions . count ( array ) ; for ( int i = <int> ; i < length ; i + + ) { long touchHandle = NSArrayExtensions . objectAtIndex$ ( array , i ) ; UITouch touch = UI_TOUCH_WRAPPER . wrap ( touchHandle ) ; CGPoint loc = touch . getLocationInView ( touch . getView ( ) ) ; synchronized ( touchEvents ) { UITouchPhase phase = touch . getPhase ( ) ; TouchEvent event = touchEventPool . obtain ( ) ; event . x = ( int ) ( loc . getX ( ) * app . displayScaleFactor ) ; event . y = ( int ) ( loc . getY ( ) * app . displayScaleFactor ) ; event . phase = phase ; event . timestamp = ( long ) ( touch . getTimestamp ( ) * <int> ) ; touchEvents . add ( event ) ; if ( phase = = UITouchPhase . Began ) { event . pointer = getFreePointer ( ) ; touchDown [ event . pointer ] = touch . getHandle ( ) ; touchX [ event . pointer ] = event . x ; touchY [ event . pointer ] = event . y ; deltaX [ event . pointer ] = <int> ; deltaY [ event . pointer ] = <int> ; numTouched + + ; } if ( phase = = UITouchPhase . Moved | | phase = = UITouchPhase . Stationary ) { event . pointer = findPointer ( touch ) ; deltaX [ event . pointer ] = event . x - touchX [ event . pointer ] ; deltaY [ event . pointer ] = event . y - touchY [ event . pointer ] ; touchX [ event . pointer ] = event . x ; touchY [ event . pointer ] = event . y ; } if ( phase = = UITouchPhase . Cancelled | | phase = = UITouchPhase . Ended ) { event . pointer = findPointer ( touch ) ; touchDown [ event . pointer ] = <int> ; touchX [ event . pointer ] = event . x ; touchY [ event . pointer ] = event . y ; deltaX [ event . pointer ] = <int> ; deltaY [ event . pointer ] = <int> ; numTouched - - ; } } } } static class TouchEvent { UITouchPhase phase ; long timestamp ; int x , y ; int pointer ; } } 
