package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Group ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . Touchable ; import com . badlogic . gdx . scenes . scene2d . ui . Image ; import com . badlogic . gdx . scenes . scene2d . ui . Label ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Scaling ; import com . badlogic . gdx . utils . viewport . ScreenViewport ; public class StageTest extends GdxTest implements InputProcessor { private static final int NUM_GROUPS = <int> ; private static final int NUM_SPRITES = ( int ) Math . sqrt ( <int> / NUM_GROUPS ) ; private static final float SPACING = <int> ; ShapeRenderer renderer ; Stage stage ; Stage ui ; Texture texture ; Texture uiTexture ; BitmapFont font ; boolean rotateSprites = false ; boolean scaleSprites = false ; float angle ; Array < Actor > sprites = new Array ( ) ; float scale = <int> ; float vScale = <int> ; Label fps ; @Override public void create ( ) { texture = new Texture ( Gdx . files . internal ( <str> ) ) ; texture . setFilter ( TextureFilter . Linear , TextureFilter . Linear ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , false ) ; stage = new Stage ( new ScreenViewport ( ) ) ; float loc = ( NUM_SPRITES * ( <int> + SPACING ) - SPACING ) / <int> ; for ( int i = <int> ; i < NUM_GROUPS ; i + + ) { Group group = new Group ( ) ; group . setX ( ( float ) Math . random ( ) * ( stage . getWidth ( ) - NUM_SPRITES * ( <int> + SPACING ) ) ) ; group . setY ( ( float ) Math . random ( ) * ( stage . getHeight ( ) - NUM_SPRITES * ( <int> + SPACING ) ) ) ; group . setOrigin ( loc , loc ) ; fillGroup ( group , texture ) ; stage . addActor ( group ) ; } uiTexture = new Texture ( Gdx . files . internal ( <str> ) ) ; uiTexture . setFilter ( TextureFilter . Linear , TextureFilter . Linear ) ; ui = new Stage ( new ScreenViewport ( ) ) ; Image blend = new Image ( new TextureRegion ( uiTexture , <int> , <int> , <int> , <int> ) ) ; blend . setAlign ( Align . center ) ; blend . setScaling ( Scaling . none ) ; blend . addListener ( new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { if ( stage . getBatch ( ) . isBlendingEnabled ( ) ) stage . getBatch ( ) . disableBlending ( ) ; else stage . getBatch ( ) . enableBlending ( ) ; return true ; } } ) ; blend . setY ( ui . getHeight ( ) - <int> ) ; Image rotate = new Image ( new TextureRegion ( uiTexture , <int> , <int> , <int> , <int> ) ) ; rotate . setAlign ( Align . center ) ; rotate . setScaling ( Scaling . none ) ; rotate . addListener ( new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { rotateSprites = ! rotateSprites ; return true ; } } ) ; rotate . setPosition ( <int> , blend . getY ( ) ) ; Image scale = new Image ( new TextureRegion ( uiTexture , <int> , <int> , <int> , <int> ) ) ; scale . setAlign ( Align . center ) ; scale . setScaling ( Scaling . none ) ; scale . addListener ( new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { scaleSprites = ! scaleSprites ; return true ; } } ) ; scale . setPosition ( <int> , blend . getY ( ) ) ; { Actor shapeActor = new Actor ( ) { public void drawDebug ( ShapeRenderer shapes ) { shapes . set ( ShapeType . Filled ) ; shapes . setColor ( getColor ( ) ) ; shapes . rect ( getX ( ) , getY ( ) , getOriginX ( ) , getOriginY ( ) , getWidth ( ) , getHeight ( ) , getScaleX ( ) , getScaleY ( ) , getRotation ( ) ) ; } } ; shapeActor . setBounds ( <int> , <int> , <int> , <int> ) ; shapeActor . setOrigin ( <int> , <int> ) ; shapeActor . debug ( ) ; sprites . add ( shapeActor ) ; Group shapeGroup = new Group ( ) ; shapeGroup . setBounds ( <int> , <int> , <int> , <int> ) ; shapeGroup . setOrigin ( <int> , <int> ) ; shapeGroup . setTouchable ( Touchable . childrenOnly ) ; shapeGroup . addActor ( shapeActor ) ; stage . addActor ( shapeGroup ) ; } ui . addActor ( blend ) ; ui . addActor ( rotate ) ; ui . addActor ( scale ) ; fps = new Label ( <str> , new Label . LabelStyle ( font , Color . WHITE ) ) ; fps . setPosition ( <int> , <int> ) ; fps . setColor ( <int> , <int> , <int> , <int> ) ; ui . addActor ( fps ) ; renderer = new ShapeRenderer ( ) ; Gdx . input . setInputProcessor ( this ) ; } private void fillGroup ( Group group , Texture texture ) { float advance = <int> + SPACING ; for ( int y = <int> ; y < NUM_SPRITES * advance ; y + = advance ) for ( int x = <int> ; x < NUM_SPRITES * advance ; x + = advance ) { Image img = new Image ( new TextureRegion ( texture ) ) ; img . setAlign ( Align . center ) ; img . setScaling ( Scaling . none ) ; img . setBounds ( x , y , <int> , <int> ) ; img . setOrigin ( <int> , <int> ) ; group . addActor ( img ) ; sprites . add ( img ) ; } } private final Vector2 stageCoords = new Vector2 ( ) ; @Override public void render ( ) { Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; if ( Gdx . input . isTouched ( ) ) { stage . screenToStageCoordinates ( stageCoords . set ( Gdx . input . getX ( ) , Gdx . input . getY ( ) ) ) ; Actor actor = stage . hit ( stageCoords . x , stageCoords . y , true ) ; if ( actor ! = null ) actor . setColor ( ( float ) Math . random ( ) , ( float ) Math . random ( ) , ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) ) ; } Array < Actor > actors = stage . getActors ( ) ; int len = actors . size ; if ( rotateSprites ) { for ( int i = <int> ; i < len ; i + + ) actors . get ( i ) . rotateBy ( Gdx . graphics . getDeltaTime ( ) * <int> ) ; } scale + = vScale * Gdx . graphics . getDeltaTime ( ) ; if ( scale > <int> ) { scale = <int> ; vScale = - vScale ; } if ( scale < <float> ) { scale = <float> ; vScale = - vScale ; } len = sprites . size ; for ( int i = <int> ; i < len ; i + + ) { Actor sprite = sprites . get ( i ) ; if ( rotateSprites ) sprite . rotateBy ( - <int> * Gdx . graphics . getDeltaTime ( ) ) ; else sprite . setRotation ( <int> ) ; if ( scaleSprites ) { sprite . setScale ( scale ) ; } else { sprite . setScale ( <int> ) ; } } stage . draw ( ) ; renderer . begin ( ShapeType . Point ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; len = actors . size ; for ( int i = <int> ; i < len ; i + + ) { Group group = ( Group ) actors . get ( i ) ; renderer . point ( group . getX ( ) + group . getOriginX ( ) , group . getY ( ) + group . getOriginY ( ) , <int> ) ; } renderer . end ( ) ; fps . setText ( <str> + Gdx . graphics . getFramesPerSecond ( ) + <str> + sprites . size + <str> + sprites . size ) ; ui . draw ( ) ; } @Override public boolean touchDown ( int x , int y , int pointer , int button ) { return ui . touchDown ( x , y , pointer , button ) ; } public void resize ( int width , int height ) { ui . getViewport ( ) . update ( width , height , true ) ; stage . getViewport ( ) . update ( width , height , true ) ; } @Override public void dispose ( ) { ui . dispose ( ) ; renderer . dispose ( ) ; texture . dispose ( ) ; uiTexture . dispose ( ) ; font . dispose ( ) ; } } 
