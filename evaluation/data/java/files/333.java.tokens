package org . apache . cassandra . auth ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . TimeUnit ; import com . google . common . base . * ; import com . google . common . base . Objects ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . mindrot . jbcrypt . BCrypt ; public class CassandraRoleManager implements IRoleManager { private static final Logger logger = LoggerFactory . getLogger ( CassandraRoleManager . class ) ; static final String DEFAULT_SUPERUSER_NAME = <str> ; static final String DEFAULT_SUPERUSER_PASSWORD = <str> ; private static final Function < UntypedResultSet . Row , Role > ROW_TO_ROLE = new Function < UntypedResultSet . Row , Role > ( ) { public Role apply ( UntypedResultSet . Row row ) { return new Role ( row . getString ( <str> ) , row . getBoolean ( <str> ) , row . getBoolean ( <str> ) , row . has ( <str> ) ? row . getSet ( <str> , UTF8Type . instance ) : Collections . < String > emptySet ( ) ) ; } } ; public static final String LEGACY_USERS_TABLE = <str> ; private static final Function < UntypedResultSet . Row , Role > LEGACY_ROW_TO_ROLE = new Function < UntypedResultSet . Row , Role > ( ) { public Role apply ( UntypedResultSet . Row row ) { return new Role ( row . getString ( <str> ) , row . getBoolean ( <str> ) , true , Collections . < String > emptySet ( ) ) ; } } ; private static final String GENSALT_LOG2_ROUNDS_PROPERTY = Config . PROPERTY_PREFIX + <str> ; private static final int GENSALT_LOG2_ROUNDS = getGensaltLogRounds ( ) ; static int getGensaltLogRounds ( ) { int rounds = Integer . getInteger ( GENSALT_LOG2_ROUNDS_PROPERTY , <int> ) ; if ( rounds < <int> | | rounds > <int> ) throw new ConfigurationException ( String . format ( <str> + <str> , GENSALT_LOG2_ROUNDS_PROPERTY ) ) ; return rounds ; } private static final Role NULL_ROLE = new Role ( null , false , false , Collections . < String > emptySet ( ) ) ; private SelectStatement loadRoleStatement ; private SelectStatement legacySelectUserStatement ; private final Set < Option > supportedOptions ; private final Set < Option > alterableOptions ; private volatile boolean isClusterReady = false ; public CassandraRoleManager ( ) { supportedOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) = = PasswordAuthenticator . class ? ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER , Option . PASSWORD ) : ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER ) ; alterableOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) . equals ( PasswordAuthenticator . class ) ? ImmutableSet . of ( Option . PASSWORD ) : ImmutableSet . < Option > of ( ) ; } public void setup ( ) { loadRoleStatement = ( SelectStatement ) prepare ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES ) ; if ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , <str> ) ! = null ) { legacySelectUserStatement = ( SelectStatement ) prepare ( <str> , AuthKeyspace . NAME , LEGACY_USERS_TABLE ) ; scheduleSetupTask ( ( ) - > { convertLegacyData ( ) ; return null ; } ) ; } else { scheduleSetupTask ( ( ) - > { setupDefaultRole ( ) ; return null ; } ) ; } } public Set < Option > supportedOptions ( ) { return supportedOptions ; } public Set < Option > alterableOptions ( ) { return alterableOptions ; } public void createRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) throws RequestValidationException , RequestExecutionException { String insertCql = options . getPassword ( ) . isPresent ( ) ? String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , escape ( role . getRoleName ( ) ) , options . getSuperuser ( ) . or ( false ) , options . getLogin ( ) . or ( false ) , escape ( hashpw ( options . getPassword ( ) . get ( ) ) ) ) : String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , escape ( role . getRoleName ( ) ) , options . getSuperuser ( ) . or ( false ) , options . getLogin ( ) . or ( false ) ) ; process ( insertCql , consistencyForRole ( role . getRoleName ( ) ) ) ; } public void dropRole ( AuthenticatedUser performer , RoleResource role ) throws RequestValidationException , RequestExecutionException { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , escape ( role . getRoleName ( ) ) ) , consistencyForRole ( role . getRoleName ( ) ) ) ; removeAllMembers ( role . getRoleName ( ) ) ; } public void alterRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) { String assignments = Joiner . on ( <str> ) . join ( Iterables . filter ( optionsToAssignments ( options . getOptions ( ) ) , Predicates . notNull ( ) ) ) ; if ( ! Strings . isNullOrEmpty ( assignments ) ) { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , assignments , escape ( role . getRoleName ( ) ) ) , consistencyForRole ( role . getRoleName ( ) ) ) ; } } public void grantRole ( AuthenticatedUser performer , RoleResource role , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { if ( getRoles ( grantee , true ) . contains ( role ) ) throw new InvalidRequestException ( String . format ( <str> , grantee . getRoleName ( ) , role . getRoleName ( ) ) ) ; if ( getRoles ( role , true ) . contains ( grantee ) ) throw new InvalidRequestException ( String . format ( <str> , role . getRoleName ( ) , grantee . getRoleName ( ) ) ) ; modifyRoleMembership ( grantee . getRoleName ( ) , role . getRoleName ( ) , <str> ) ; process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_MEMBERS , escape ( role . getRoleName ( ) ) , escape ( grantee . getRoleName ( ) ) ) , consistencyForRole ( role . getRoleName ( ) ) ) ; } public void revokeRole ( AuthenticatedUser performer , RoleResource role , RoleResource revokee ) throws RequestValidationException , RequestExecutionException { if ( ! getRoles ( revokee , false ) . contains ( role ) ) throw new InvalidRequestException ( String . format ( <str> , revokee . getRoleName ( ) , role . getRoleName ( ) ) ) ; modifyRoleMembership ( revokee . getRoleName ( ) , role . getRoleName ( ) , <str> ) ; process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_MEMBERS , escape ( role . getRoleName ( ) ) , escape ( revokee . getRoleName ( ) ) ) , consistencyForRole ( role . getRoleName ( ) ) ) ; } public Set < RoleResource > getRoles ( RoleResource grantee , boolean includeInherited ) throws RequestValidationException , RequestExecutionException { Set < RoleResource > roles = new HashSet < > ( ) ; Role role = getRole ( grantee . getRoleName ( ) ) ; if ( ! role . equals ( NULL_ROLE ) ) { roles . add ( RoleResource . role ( role . name ) ) ; collectRoles ( role , roles , includeInherited ) ; } return roles ; } public Set < RoleResource > getAllRoles ( ) throws RequestValidationException , RequestExecutionException { UntypedResultSet rows = process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES ) , ConsistencyLevel . QUORUM ) ; Iterable < RoleResource > roles = Iterables . transform ( rows , new Function < UntypedResultSet . Row , RoleResource > ( ) { public RoleResource apply ( UntypedResultSet . Row row ) { return RoleResource . role ( row . getString ( <str> ) ) ; } } ) ; return ImmutableSet . < RoleResource > builder ( ) . addAll ( roles ) . build ( ) ; } public boolean isSuper ( RoleResource role ) { return getRole ( role . getRoleName ( ) ) . isSuper ; } public boolean canLogin ( RoleResource role ) { return getRole ( role . getRoleName ( ) ) . canLogin ; } public Map < String , String > getCustomOptions ( RoleResource role ) { return Collections . emptyMap ( ) ; } public boolean isExistingRole ( RoleResource role ) { return getRole ( role . getRoleName ( ) ) ! = NULL_ROLE ; } public Set < ? extends IResource > protectedResources ( ) { return ImmutableSet . of ( DataResource . table ( AuthKeyspace . NAME , AuthKeyspace . ROLES ) , DataResource . table ( AuthKeyspace . NAME , AuthKeyspace . ROLE_MEMBERS ) ) ; } public void validateConfiguration ( ) throws ConfigurationException { } private static void setupDefaultRole ( ) { try { if ( ! hasExistingRoles ( ) ) { QueryProcessor . process ( String . format ( <str> + <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , DEFAULT_SUPERUSER_NAME , escape ( hashpw ( DEFAULT_SUPERUSER_PASSWORD ) ) ) , consistencyForRole ( DEFAULT_SUPERUSER_NAME ) ) ; logger . info ( <str> , DEFAULT_SUPERUSER_NAME ) ; } } catch ( RequestExecutionException e ) { logger . warn ( <str> ) ; throw e ; } } private static boolean hasExistingRoles ( ) throws RequestExecutionException { String defaultSUQuery = String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , DEFAULT_SUPERUSER_NAME ) ; String allUsersQuery = String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES ) ; return ! QueryProcessor . process ( defaultSUQuery , ConsistencyLevel . ONE ) . isEmpty ( ) | | ! QueryProcessor . process ( defaultSUQuery , ConsistencyLevel . QUORUM ) . isEmpty ( ) | | ! QueryProcessor . process ( allUsersQuery , ConsistencyLevel . QUORUM ) . isEmpty ( ) ; } private void scheduleSetupTask ( final Callable < Void > setupTask ) { ScheduledExecutors . optionalTasks . schedule ( new Runnable ( ) { public void run ( ) { if ( ! MessagingService . instance ( ) . areAllNodesAtLeast22 ( ) ) { logger . trace ( <str> ) ; scheduleSetupTask ( setupTask ) ; return ; } isClusterReady = true ; try { setupTask . call ( ) ; } catch ( Exception e ) { logger . info ( <str> ) ; scheduleSetupTask ( setupTask ) ; } } } , AuthKeyspace . SUPERUSER_SETUP_DELAY , TimeUnit . MILLISECONDS ) ; } private void convertLegacyData ( ) throws Exception { try { if ( Schema . instance . getCFMetaData ( <str> , <str> ) ! = null ) { logger . info ( <str> ) ; UntypedResultSet users = QueryProcessor . process ( <str> , ConsistencyLevel . QUORUM ) ; for ( UntypedResultSet . Row row : users ) { RoleOptions options = new RoleOptions ( ) ; options . setOption ( Option . SUPERUSER , row . getBoolean ( <str> ) ) ; options . setOption ( Option . LOGIN , true ) ; createRole ( null , RoleResource . role ( row . getString ( <str> ) ) , options ) ; } logger . info ( <str> ) ; } if ( Schema . instance . getCFMetaData ( <str> , <str> ) ! = null ) { logger . info ( <str> ) ; UntypedResultSet credentials = QueryProcessor . process ( <str> , ConsistencyLevel . QUORUM ) ; for ( UntypedResultSet . Row row : credentials ) { QueryProcessor . process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , row . getString ( <str> ) , row . getString ( <str> ) ) , consistencyForRole ( row . getString ( <str> ) ) ) ; } logger . info ( <str> ) ; } } catch ( Exception e ) { logger . info ( <str> + <str> ) ; logger . trace ( <str> , e ) ; throw e ; } } private CQLStatement prepare ( String template , String keyspace , String table ) { try { return QueryProcessor . parseStatement ( String . format ( template , keyspace , table ) ) . prepare ( ) . statement ; } catch ( RequestValidationException e ) { throw new AssertionError ( e ) ; } } private void collectRoles ( Role role , Set < RoleResource > collected , boolean includeInherited ) throws RequestValidationException , RequestExecutionException { for ( String memberOf : role . memberOf ) { Role granted = getRole ( memberOf ) ; if ( granted . equals ( NULL_ROLE ) ) continue ; collected . add ( RoleResource . role ( granted . name ) ) ; if ( includeInherited ) collectRoles ( granted , collected , true ) ; } } private Role getRole ( String name ) { try { return ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , <str> ) ! = null ) ? getRoleFromTable ( name , legacySelectUserStatement , LEGACY_ROW_TO_ROLE ) : getRoleFromTable ( name , loadRoleStatement , ROW_TO_ROLE ) ; } catch ( RequestExecutionException | RequestValidationException e ) { throw new RuntimeException ( e ) ; } } private Role getRoleFromTable ( String name , SelectStatement statement , Function < UntypedResultSet . Row , Role > function ) throws RequestExecutionException , RequestValidationException { ResultMessage . Rows rows = statement . execute ( QueryState . forInternalCalls ( ) , QueryOptions . forInternalCalls ( consistencyForRole ( name ) , Collections . singletonList ( ByteBufferUtil . bytes ( name ) ) ) ) ; if ( rows . result . isEmpty ( ) ) return NULL_ROLE ; return function . apply ( UntypedResultSet . create ( rows . result ) . one ( ) ) ; } private void modifyRoleMembership ( String grantee , String role , String op ) throws RequestExecutionException { process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLES , op , escape ( role ) , escape ( grantee ) ) , consistencyForRole ( grantee ) ) ; } private void removeAllMembers ( String role ) throws RequestValidationException , RequestExecutionException { UntypedResultSet rows = process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_MEMBERS , escape ( role ) ) , consistencyForRole ( role ) ) ; if ( rows . isEmpty ( ) ) return ; for ( UntypedResultSet . Row row : rows ) modifyRoleMembership ( row . getString ( <str> ) , role , <str> ) ; process ( String . format ( <str> , AuthKeyspace . NAME , AuthKeyspace . ROLE_MEMBERS , escape ( role ) ) , consistencyForRole ( role ) ) ; } private Iterable < String > optionsToAssignments ( Map < Option , Object > options ) { return Iterables . transform ( options . entrySet ( ) , new Function < Map . Entry < Option , Object > , String > ( ) { public String apply ( Map . Entry < Option , Object > entry ) { switch ( entry . getKey ( ) ) { case LOGIN : return String . format ( <str> , entry . getValue ( ) ) ; case SUPERUSER : return String . format ( <str> , entry . getValue ( ) ) ; case PASSWORD : return String . format ( <str> , escape ( hashpw ( ( String ) entry . getValue ( ) ) ) ) ; default : return null ; } } } ) ; } protected static ConsistencyLevel consistencyForRole ( String role ) { if ( role . equals ( DEFAULT_SUPERUSER_NAME ) ) return ConsistencyLevel . QUORUM ; else return ConsistencyLevel . LOCAL_ONE ; } private static String hashpw ( String password ) { return BCrypt . hashpw ( password , BCrypt . gensalt ( GENSALT_LOG2_ROUNDS ) ) ; } private static String escape ( String name ) { return StringUtils . replace ( name , <str> , <str> ) ; } private UntypedResultSet process ( String query , ConsistencyLevel consistencyLevel ) throws RequestValidationException , RequestExecutionException { if ( ! isClusterReady ) throw new InvalidRequestException ( <str> + <str> + <str> ) ; return QueryProcessor . process ( query , consistencyLevel ) ; } private static final class Role { private String name ; private final boolean isSuper ; private final boolean canLogin ; private Set < String > memberOf ; private Role ( String name , boolean isSuper , boolean canLogin , Set < String > memberOf ) { this . name = name ; this . isSuper = isSuper ; this . canLogin = canLogin ; this . memberOf = memberOf ; } public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Role ) ) return false ; Role r = ( Role ) o ; return Objects . equal ( name , r . name ) ; } public int hashCode ( ) { return Objects . hashCode ( name ) ; } } } 
