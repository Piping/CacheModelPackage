package org . gradle . api . internal . tasks . options ; import org . gradle . internal . typeconversion . ValueAwareNotationParser ; import java . lang . reflect . Method ; import java . util . List ; public class MethodOptionElement extends AbstractOptionElement { private final Method method ; MethodOptionElement ( Option option , Method method , Class < ? > optionType , ValueAwareNotationParser < ? > notationParser ) { super ( option . option ( ) , option , optionType , method . getDeclaringClass ( ) , notationParser ) ; this . method = method ; assertMethodTypeSupported ( getOptionName ( ) , method ) ; assertValidOptionName ( ) ; } private void assertValidOptionName ( ) { if ( getOptionName ( ) = = null | | getOptionName ( ) . length ( ) = = <int> ) { throw new OptionValidationException ( String . format ( <str> , getElementName ( ) , getDeclaredClass ( ) . getName ( ) ) ) ; } } public Class < ? > getDeclaredClass ( ) { return method . getDeclaringClass ( ) ; } public String getElementName ( ) { return method . getName ( ) ; } public void apply ( Object object , List < String > parameterValues ) { if ( parameterValues . size ( ) = = <int> ) { invokeMethod ( object , method , true ) ; } else if ( parameterValues . size ( ) > <int> ) { throw new IllegalArgumentException ( String . format ( <str> ) ) ; } else { invokeMethod ( object , method , getNotationParser ( ) . parseNotation ( parameterValues . get ( <int> ) ) ) ; } } public static MethodOptionElement create ( Option option , Method method , OptionNotationParserFactory optionNotationParserFactory ) { Class < ? > optionType = calculateOptionType ( method ) ; ValueAwareNotationParser < ? > notationParser = createNotationParserOrFail ( optionNotationParserFactory , option . option ( ) , optionType , method . getDeclaringClass ( ) ) ; return new MethodOptionElement ( option , method , optionType , notationParser ) ; } private static Class < ? > calculateOptionType ( Method optionMethod ) { if ( optionMethod . getParameterTypes ( ) . length = = <int> ) { return Void . TYPE ; } else { return calculateOptionType ( optionMethod . getParameterTypes ( ) [ <int> ] ) ; } } private static void assertMethodTypeSupported ( String optionName , Method method ) { final Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length > <int> ) { throw new OptionValidationException ( String . format ( <str> , optionName , method . getDeclaringClass ( ) . getName ( ) , method . getName ( ) ) ) ; } } } 
