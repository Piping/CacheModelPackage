package io . netty . handler . codec . socksx . v5 ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socksx . SocksVersion ; import io . netty . handler . codec . socksx . v5 . Socks5CommandRequestDecoder . State ; import java . util . List ; public class Socks5CommandRequestDecoder extends ReplayingDecoder < State > { enum State { INIT , SUCCESS , FAILURE } private final Socks5AddressDecoder addressDecoder ; public Socks5CommandRequestDecoder ( ) { this ( Socks5AddressDecoder . DEFAULT ) ; } public Socks5CommandRequestDecoder ( Socks5AddressDecoder addressDecoder ) { super ( State . INIT ) ; if ( addressDecoder = = null ) { throw new NullPointerException ( <str> ) ; } this . addressDecoder = addressDecoder ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( state ( ) ) { case INIT : { final byte version = in . readByte ( ) ; if ( version ! = SocksVersion . SOCKS5 . byteValue ( ) ) { throw new DecoderException ( <str> + version + <str> + SocksVersion . SOCKS5 . byteValue ( ) + <str> ) ; } final Socks5CommandType type = Socks5CommandType . valueOf ( in . readByte ( ) ) ; in . skipBytes ( <int> ) ; final Socks5AddressType dstAddrType = Socks5AddressType . valueOf ( in . readByte ( ) ) ; final String dstAddr = addressDecoder . decodeAddress ( dstAddrType , in ) ; final int dstPort = in . readUnsignedShort ( ) ; out . add ( new DefaultSocks5CommandRequest ( type , dstAddrType , dstAddr , dstPort ) ) ; checkpoint ( State . SUCCESS ) ; } case SUCCESS : { int readableBytes = actualReadableBytes ( ) ; if ( readableBytes > <int> ) { out . add ( in . readSlice ( readableBytes ) . retain ( ) ) ; } break ; } case FAILURE : { in . skipBytes ( actualReadableBytes ( ) ) ; break ; } } } catch ( Exception e ) { fail ( out , e ) ; } } private void fail ( List < Object > out , Throwable cause ) { if ( ! ( cause instanceof DecoderException ) ) { cause = new DecoderException ( cause ) ; } checkpoint ( State . FAILURE ) ; Socks5Message m = new DefaultSocks5CommandRequest ( Socks5CommandType . CONNECT , Socks5AddressType . IPv4 , <str> , <int> ) ; m . setDecoderResult ( DecoderResult . failure ( cause ) ) ; out . add ( m ) ; } } 
