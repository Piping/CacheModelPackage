package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . base . Objects ; import com . google . common . base . Predicate ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; import org . apache . cassandra . cql3 . selection . RawSelector ; import org . apache . cassandra . cql3 . selection . Selection ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . db . marshal . CompositeType ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . db . rows . ComplexColumnData ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . RowIterator ; import org . apache . cassandra . db . view . View ; import org . apache . cassandra . dht . AbstractBounds ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . ClientWarn ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . service . pager . PagingState ; import org . apache . cassandra . service . pager . QueryPager ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkNotNull ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; import static org . apache . cassandra . utils . ByteBufferUtil . UNSET_BYTE_BUFFER ; public class SelectStatement implements CQLStatement { private static final Logger logger = LoggerFactory . getLogger ( SelectStatement . class ) ; private static final int DEFAULT_COUNT_PAGE_SIZE = <int> ; public static final String REQUIRES_ALLOW_FILTERING_MESSAGE = <str> + <str> + <str> ; private final int boundTerms ; public final CFMetaData cfm ; public final Parameters parameters ; private final Selection selection ; private final Term limit ; private final StatementRestrictions restrictions ; private final boolean isReversed ; private final Comparator < List < ByteBuffer > > orderingComparator ; private final ColumnFilter queriedColumns ; private static final Parameters defaultParameters = new Parameters ( Collections . < ColumnIdentifier . Raw , Boolean > emptyMap ( ) , false , false , false ) ; public SelectStatement ( CFMetaData cfm , int boundTerms , Parameters parameters , Selection selection , StatementRestrictions restrictions , boolean isReversed , Comparator < List < ByteBuffer > > orderingComparator , Term limit ) { this . cfm = cfm ; this . boundTerms = boundTerms ; this . selection = selection ; this . restrictions = restrictions ; this . isReversed = isReversed ; this . orderingComparator = orderingComparator ; this . parameters = parameters ; this . limit = limit ; this . queriedColumns = gatherQueriedColumns ( ) ; } public Iterable < Function > getFunctions ( ) { return Iterables . concat ( selection . getFunctions ( ) , restrictions . getFunctions ( ) , limit ! = null ? limit . getFunctions ( ) : Collections . < Function > emptySet ( ) ) ; } private ColumnFilter gatherQueriedColumns ( ) { if ( selection . isWildcard ( ) ) return ColumnFilter . all ( cfm ) ; ColumnFilter . Builder builder = ColumnFilter . allColumnsBuilder ( cfm ) ; for ( ColumnDefinition def : selection . getColumns ( ) ) if ( ! def . isPrimaryKeyColumn ( ) ) builder . add ( def ) ; builder . addAll ( restrictions . nonPKRestrictedColumns ( true ) ) ; return builder . build ( ) ; } static SelectStatement forSelection ( CFMetaData cfm , Selection selection ) { return new SelectStatement ( cfm , <int> , defaultParameters , selection , StatementRestrictions . empty ( StatementType . SELECT , cfm ) , false , null , null ) ; } public ResultSet . ResultMetadata getResultMetadata ( ) { return selection . getResultMetadata ( parameters . isJson ) ; } public int getBoundTerms ( ) { return boundTerms ; } public void checkAccess ( ClientState state ) throws InvalidRequestException , UnauthorizedException { if ( cfm . isView ( ) ) { CFMetaData baseTable = View . findBaseTable ( keyspace ( ) , columnFamily ( ) ) ; if ( baseTable ! = null ) state . hasColumnFamilyAccess ( baseTable , Permission . SELECT ) ; } else { state . hasColumnFamilyAccess ( cfm , Permission . SELECT ) ; } for ( Function function : getFunctions ( ) ) state . ensureHasPermission ( Permission . EXECUTE , function ) ; } public void validate ( ClientState state ) throws InvalidRequestException { } public ResultMessage . Rows execute ( QueryState state , QueryOptions options ) throws RequestExecutionException , RequestValidationException { ConsistencyLevel cl = options . getConsistency ( ) ; checkNotNull ( cl , <str> ) ; cl . validateForRead ( keyspace ( ) ) ; int nowInSec = FBUtilities . nowInSeconds ( ) ; int userLimit = getLimit ( options ) ; ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; int pageSize = getPageSize ( options ) ; if ( pageSize < = <int> | | query . limits ( ) . count ( ) < = pageSize ) return execute ( query , options , state , nowInSec , userLimit ) ; QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; return execute ( Pager . forDistributedQuery ( pager , cl , state . getClientState ( ) ) , options , pageSize , nowInSec , userLimit ) ; } private int getPageSize ( QueryOptions options ) { int pageSize = options . getPageSize ( ) ; if ( selection . isAggregate ( ) & & pageSize < = <int> ) pageSize = DEFAULT_COUNT_PAGE_SIZE ; return pageSize ; } public ReadQuery getQuery ( QueryOptions options , int nowInSec ) throws RequestValidationException { return getQuery ( options , nowInSec , getLimit ( options ) ) ; } public ReadQuery getQuery ( QueryOptions options , int nowInSec , int userLimit ) throws RequestValidationException { DataLimits limit = getDataLimits ( userLimit ) ; if ( restrictions . isKeyRange ( ) | | restrictions . usesSecondaryIndexing ( ) ) return getRangeCommand ( options , limit , nowInSec ) ; return getSliceCommands ( options , limit , nowInSec ) ; } private ResultMessage . Rows execute ( ReadQuery query , QueryOptions options , QueryState state , int nowInSec , int userLimit ) throws RequestValidationException , RequestExecutionException { try ( PartitionIterator data = query . execute ( options . getConsistency ( ) , state . getClientState ( ) ) ) { return processResults ( data , options , nowInSec , userLimit ) ; } } private static abstract class Pager { protected QueryPager pager ; protected Pager ( QueryPager pager ) { this . pager = pager ; } public static Pager forInternalQuery ( QueryPager pager , ReadExecutionController executionController ) { return new InternalPager ( pager , executionController ) ; } public static Pager forDistributedQuery ( QueryPager pager , ConsistencyLevel consistency , ClientState clientState ) { return new NormalPager ( pager , consistency , clientState ) ; } public boolean isExhausted ( ) { return pager . isExhausted ( ) ; } public PagingState state ( ) { return pager . state ( ) ; } public abstract PartitionIterator fetchPage ( int pageSize ) ; public static class NormalPager extends Pager { private final ConsistencyLevel consistency ; private final ClientState clientState ; private NormalPager ( QueryPager pager , ConsistencyLevel consistency , ClientState clientState ) { super ( pager ) ; this . consistency = consistency ; this . clientState = clientState ; } public PartitionIterator fetchPage ( int pageSize ) { return pager . fetchPage ( pageSize , consistency , clientState ) ; } } public static class InternalPager extends Pager { private final ReadExecutionController executionController ; private InternalPager ( QueryPager pager , ReadExecutionController executionController ) { super ( pager ) ; this . executionController = executionController ; } public PartitionIterator fetchPage ( int pageSize ) { return pager . fetchPageInternal ( pageSize , executionController ) ; } } } private ResultMessage . Rows execute ( Pager pager , QueryOptions options , int pageSize , int nowInSec , int userLimit ) throws RequestValidationException , RequestExecutionException { if ( selection . isAggregate ( ) ) return pageAggregateQuery ( pager , options , pageSize , nowInSec ) ; checkFalse ( needsPostQueryOrdering ( ) , <str> + <str> ) ; ResultMessage . Rows msg ; try ( PartitionIterator page = pager . fetchPage ( pageSize ) ) { msg = processResults ( page , options , nowInSec , userLimit ) ; } if ( ! pager . isExhausted ( ) ) msg . result . metadata . setHasMorePages ( pager . state ( ) ) ; return msg ; } private ResultMessage . Rows pageAggregateQuery ( Pager pager , QueryOptions options , int pageSize , int nowInSec ) throws RequestValidationException , RequestExecutionException { if ( ! restrictions . hasPartitionKeyRestrictions ( ) ) { logger . warn ( <str> ) ; ClientWarn . warn ( <str> ) ; } else if ( restrictions . keyIsInRelation ( ) ) { logger . warn ( <str> ) ; ClientWarn . warn ( <str> ) ; } Selection . ResultSetBuilder result = selection . resultSetBuilder ( parameters . isJson ) ; while ( ! pager . isExhausted ( ) ) { try ( PartitionIterator iter = pager . fetchPage ( pageSize ) ) { while ( iter . hasNext ( ) ) { try ( RowIterator partition = iter . next ( ) ) { processPartition ( partition , options , result , nowInSec ) ; } } } } return new ResultMessage . Rows ( result . build ( options . getProtocolVersion ( ) ) ) ; } private ResultMessage . Rows processResults ( PartitionIterator partitions , QueryOptions options , int nowInSec , int userLimit ) throws RequestValidationException { ResultSet rset = process ( partitions , options , nowInSec , userLimit ) ; return new ResultMessage . Rows ( rset ) ; } public ResultMessage . Rows executeInternal ( QueryState state , QueryOptions options ) throws RequestExecutionException , RequestValidationException { int nowInSec = FBUtilities . nowInSeconds ( ) ; int userLimit = getLimit ( options ) ; ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; int pageSize = getPageSize ( options ) ; try ( ReadExecutionController executionController = query . executionController ( ) ) { if ( pageSize < = <int> | | query . limits ( ) . count ( ) < = pageSize ) { try ( PartitionIterator data = query . executeInternal ( executionController ) ) { return processResults ( data , options , nowInSec , userLimit ) ; } } else { QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; return execute ( Pager . forInternalQuery ( pager , executionController ) , options , pageSize , nowInSec , userLimit ) ; } } } public ResultSet process ( PartitionIterator partitions , int nowInSec ) throws InvalidRequestException { return process ( partitions , QueryOptions . DEFAULT , nowInSec , getLimit ( QueryOptions . DEFAULT ) ) ; } public String keyspace ( ) { return cfm . ksName ; } public String columnFamily ( ) { return cfm . cfName ; } public Selection getSelection ( ) { return selection ; } public StatementRestrictions getRestrictions ( ) { return restrictions ; } private ReadQuery getSliceCommands ( QueryOptions options , DataLimits limit , int nowInSec ) throws RequestValidationException { Collection < ByteBuffer > keys = restrictions . getPartitionKeys ( options ) ; if ( keys . isEmpty ( ) ) return ReadQuery . EMPTY ; ClusteringIndexFilter filter = makeClusteringIndexFilter ( options ) ; if ( filter = = null ) return ReadQuery . EMPTY ; RowFilter rowFilter = getRowFilter ( options ) ; List < SinglePartitionReadCommand > commands = new ArrayList < > ( keys . size ( ) ) ; for ( ByteBuffer key : keys ) { QueryProcessor . validateKey ( key ) ; DecoratedKey dk = cfm . decorateKey ( ByteBufferUtil . clone ( key ) ) ; commands . add ( SinglePartitionReadCommand . create ( cfm , nowInSec , queriedColumns , rowFilter , limit , dk , filter ) ) ; } return new SinglePartitionReadCommand . Group ( commands , limit ) ; } public SinglePartitionReadCommand internalReadForView ( DecoratedKey key , int nowInSec ) { QueryOptions options = QueryOptions . forInternalCalls ( Collections . emptyList ( ) ) ; ClusteringIndexFilter filter = makeClusteringIndexFilter ( options ) ; RowFilter rowFilter = getRowFilter ( options ) ; return SinglePartitionReadCommand . create ( cfm , nowInSec , queriedColumns , rowFilter , DataLimits . NONE , key , filter ) ; } private ReadQuery getRangeCommand ( QueryOptions options , DataLimits limit , int nowInSec ) throws RequestValidationException { ClusteringIndexFilter clusteringIndexFilter = makeClusteringIndexFilter ( options ) ; if ( clusteringIndexFilter = = null ) return ReadQuery . EMPTY ; RowFilter rowFilter = getRowFilter ( options ) ; AbstractBounds < PartitionPosition > keyBounds = restrictions . getPartitionKeyBounds ( options ) ; return keyBounds = = null ? ReadQuery . EMPTY : new PartitionRangeReadCommand ( cfm , nowInSec , queriedColumns , rowFilter , limit , new DataRange ( keyBounds , clusteringIndexFilter ) , Optional . empty ( ) ) ; } private ClusteringIndexFilter makeClusteringIndexFilter ( QueryOptions options ) throws InvalidRequestException { if ( parameters . isDistinct ) { return new ClusteringIndexSliceFilter ( Slices . ALL , false ) ; } if ( restrictions . isColumnRange ( ) ) { Slices slices = makeSlices ( options ) ; if ( slices = = Slices . NONE & & ! selection . containsStaticColumns ( ) ) return null ; return new ClusteringIndexSliceFilter ( slices , isReversed ) ; } else { NavigableSet < Clustering > clusterings = getRequestedRows ( options ) ; if ( clusterings . isEmpty ( ) & & queriedColumns . fetchedColumns ( ) . statics . isEmpty ( ) ) return null ; return new ClusteringIndexNamesFilter ( clusterings , isReversed ) ; } } private Slices makeSlices ( QueryOptions options ) throws InvalidRequestException { SortedSet < Slice . Bound > startBounds = restrictions . getClusteringColumnsBounds ( Bound . START , options ) ; SortedSet < Slice . Bound > endBounds = restrictions . getClusteringColumnsBounds ( Bound . END , options ) ; assert startBounds . size ( ) = = endBounds . size ( ) ; if ( startBounds . size ( ) = = <int> ) { Slice . Bound start = startBounds . first ( ) ; Slice . Bound end = endBounds . first ( ) ; return cfm . comparator . compare ( start , end ) > <int> ? Slices . NONE : Slices . with ( cfm . comparator , Slice . make ( start , end ) ) ; } Slices . Builder builder = new Slices . Builder ( cfm . comparator , startBounds . size ( ) ) ; Iterator < Slice . Bound > startIter = startBounds . iterator ( ) ; Iterator < Slice . Bound > endIter = endBounds . iterator ( ) ; while ( startIter . hasNext ( ) & & endIter . hasNext ( ) ) { Slice . Bound start = startIter . next ( ) ; Slice . Bound end = endIter . next ( ) ; if ( cfm . comparator . compare ( start , end ) > <int> ) continue ; builder . add ( start , end ) ; } return builder . build ( ) ; } private DataLimits getDataLimits ( int userLimit ) { int cqlRowLimit = DataLimits . NO_LIMIT ; if ( ! selection . isAggregate ( ) & & ! needsPostQueryOrdering ( ) ) cqlRowLimit = userLimit ; if ( parameters . isDistinct ) return cqlRowLimit = = DataLimits . NO_LIMIT ? DataLimits . DISTINCT_NONE : DataLimits . distinctLimits ( cqlRowLimit ) ; return cqlRowLimit = = DataLimits . NO_LIMIT ? DataLimits . NONE : DataLimits . cqlLimits ( cqlRowLimit ) ; } public int getLimit ( QueryOptions options ) { int userLimit = DataLimits . NO_LIMIT ; if ( limit ! = null ) { ByteBuffer b = checkNotNull ( limit . bindAndGet ( options ) , <str> ) ; if ( b ! = UNSET_BYTE_BUFFER ) { try { Int32Type . instance . validate ( b ) ; userLimit = Int32Type . instance . compose ( b ) ; checkTrue ( userLimit > <int> , <str> ) ; } catch ( MarshalException e ) { throw new InvalidRequestException ( <str> ) ; } } } return userLimit ; } private NavigableSet < Clustering > getRequestedRows ( QueryOptions options ) throws InvalidRequestException { assert ! restrictions . isColumnRange ( ) ; return restrictions . getClusteringColumns ( options ) ; } public RowFilter getRowFilter ( QueryOptions options ) throws InvalidRequestException { ColumnFamilyStore cfs = Keyspace . open ( keyspace ( ) ) . getColumnFamilyStore ( columnFamily ( ) ) ; SecondaryIndexManager secondaryIndexManager = cfs . indexManager ; RowFilter filter = restrictions . getRowFilter ( secondaryIndexManager , options ) ; return filter ; } private ResultSet process ( PartitionIterator partitions , QueryOptions options , int nowInSec , int userLimit ) throws InvalidRequestException { Selection . ResultSetBuilder result = selection . resultSetBuilder ( parameters . isJson ) ; while ( partitions . hasNext ( ) ) { try ( RowIterator partition = partitions . next ( ) ) { processPartition ( partition , options , result , nowInSec ) ; } } ResultSet cqlRows = result . build ( options . getProtocolVersion ( ) ) ; orderResults ( cqlRows ) ; cqlRows . trim ( userLimit ) ; return cqlRows ; } public static ByteBuffer [ ] getComponents ( CFMetaData cfm , DecoratedKey dk ) { ByteBuffer key = dk . getKey ( ) ; if ( cfm . getKeyValidator ( ) instanceof CompositeType ) { return ( ( CompositeType ) cfm . getKeyValidator ( ) ) . split ( key ) ; } else { return new ByteBuffer [ ] { key } ; } } void processPartition ( RowIterator partition , QueryOptions options , Selection . ResultSetBuilder result , int nowInSec ) throws InvalidRequestException { int protocolVersion = options . getProtocolVersion ( ) ; ByteBuffer [ ] keyComponents = getComponents ( cfm , partition . partitionKey ( ) ) ; Row staticRow = partition . staticRow ( ) ; if ( ! partition . hasNext ( ) ) { if ( ! staticRow . isEmpty ( ) & & ( ! restrictions . usesSecondaryIndexing ( ) | | cfm . isStaticCompactTable ( ) ) & & ! restrictions . hasClusteringColumnsRestriction ( ) ) { result . newRow ( protocolVersion ) ; for ( ColumnDefinition def : selection . getColumns ( ) ) { switch ( def . kind ) { case PARTITION_KEY : result . add ( keyComponents [ def . position ( ) ] ) ; break ; case STATIC : addValue ( result , def , staticRow , nowInSec , protocolVersion ) ; break ; default : result . add ( ( ByteBuffer ) null ) ; } } } return ; } while ( partition . hasNext ( ) ) { Row row = partition . next ( ) ; result . newRow ( protocolVersion ) ; for ( ColumnDefinition def : selection . getColumns ( ) ) { switch ( def . kind ) { case PARTITION_KEY : result . add ( keyComponents [ def . position ( ) ] ) ; break ; case CLUSTERING : result . add ( row . clustering ( ) . get ( def . position ( ) ) ) ; break ; case REGULAR : addValue ( result , def , row , nowInSec , protocolVersion ) ; break ; case STATIC : addValue ( result , def , staticRow , nowInSec , protocolVersion ) ; break ; } } } } private static void addValue ( Selection . ResultSetBuilder result , ColumnDefinition def , Row row , int nowInSec , int protocolVersion ) { if ( def . isComplex ( ) ) { assert def . type . isCollection ( ) & & def . type . isMultiCell ( ) ; ComplexColumnData complexData = row . getComplexColumnData ( def ) ; if ( complexData = = null ) result . add ( ( ByteBuffer ) null ) ; else result . add ( ( ( CollectionType ) def . type ) . serializeForNativeProtocol ( def , complexData . iterator ( ) , protocolVersion ) ) ; } else { result . add ( row . getCell ( def ) , nowInSec ) ; } } private boolean needsPostQueryOrdering ( ) { return restrictions . keyIsInRelation ( ) & & ! parameters . orderings . isEmpty ( ) ; } private void orderResults ( ResultSet cqlRows ) { if ( cqlRows . size ( ) = = <int> | | ! needsPostQueryOrdering ( ) ) return ; Collections . sort ( cqlRows . rows , orderingComparator ) ; } public static class RawStatement extends CFStatement { public final Parameters parameters ; public final List < RawSelector > selectClause ; public final WhereClause whereClause ; public final Term . Raw limit ; public RawStatement ( CFName cfName , Parameters parameters , List < RawSelector > selectClause , WhereClause whereClause , Term . Raw limit ) { super ( cfName ) ; this . parameters = parameters ; this . selectClause = selectClause ; this . whereClause = whereClause ; this . limit = limit ; } public ParsedStatement . Prepared prepare ( ) throws InvalidRequestException { return prepare ( false ) ; } public ParsedStatement . Prepared prepare ( boolean forView ) throws InvalidRequestException { CFMetaData cfm = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; VariableSpecifications boundNames = getBoundVariables ( ) ; Selection selection = selectClause . isEmpty ( ) ? Selection . wildcard ( cfm ) : Selection . fromSelectors ( cfm , selectClause ) ; StatementRestrictions restrictions = prepareRestrictions ( cfm , boundNames , selection , forView ) ; if ( parameters . isDistinct ) validateDistinctSelection ( cfm , selection , restrictions ) ; Comparator < List < ByteBuffer > > orderingComparator = null ; boolean isReversed = false ; if ( ! parameters . orderings . isEmpty ( ) ) { assert ! forView ; verifyOrderingIsAllowed ( restrictions ) ; orderingComparator = getOrderingComparator ( cfm , selection , restrictions ) ; isReversed = isReversed ( cfm ) ; if ( isReversed ) orderingComparator = Collections . reverseOrder ( orderingComparator ) ; } checkNeedsFiltering ( restrictions ) ; SelectStatement stmt = new SelectStatement ( cfm , boundNames . size ( ) , parameters , selection , restrictions , isReversed , orderingComparator , prepareLimit ( boundNames ) ) ; return new ParsedStatement . Prepared ( stmt , boundNames , boundNames . getPartitionKeyBindIndexes ( cfm ) ) ; } private StatementRestrictions prepareRestrictions ( CFMetaData cfm , VariableSpecifications boundNames , Selection selection , boolean forView ) throws InvalidRequestException { try { return new StatementRestrictions ( StatementType . SELECT , cfm , whereClause , boundNames , selection . containsOnlyStaticColumns ( ) , selection . containsACollection ( ) , parameters . allowFiltering , forView ) ; } catch ( UnrecognizedEntityException e ) { if ( containsAlias ( e . entity ) ) throw invalidRequest ( <str> , e . relation ) ; throw e ; } } private Term prepareLimit ( VariableSpecifications boundNames ) throws InvalidRequestException { if ( limit = = null ) return null ; Term prepLimit = limit . prepare ( keyspace ( ) , limitReceiver ( ) ) ; prepLimit . collectMarkerSpecification ( boundNames ) ; return prepLimit ; } private static void verifyOrderingIsAllowed ( StatementRestrictions restrictions ) throws InvalidRequestException { checkFalse ( restrictions . usesSecondaryIndexing ( ) , <str> ) ; checkFalse ( restrictions . isKeyRange ( ) , <str> ) ; } private static void validateDistinctSelection ( CFMetaData cfm , Selection selection , StatementRestrictions restrictions ) throws InvalidRequestException { Collection < ColumnDefinition > requestedColumns = selection . getColumns ( ) ; for ( ColumnDefinition def : requestedColumns ) checkFalse ( ! def . isPartitionKey ( ) & & ! def . isStatic ( ) , <str> , def . name ) ; if ( ! restrictions . isKeyRange ( ) ) return ; for ( ColumnDefinition def : cfm . partitionKeyColumns ( ) ) checkTrue ( requestedColumns . contains ( def ) , <str> , def . name ) ; } private void handleUnrecognizedOrderingColumn ( ColumnIdentifier column ) throws InvalidRequestException { checkFalse ( containsAlias ( column ) , <str> , column ) ; checkFalse ( true , <str> , column ) ; } private Comparator < List < ByteBuffer > > getOrderingComparator ( CFMetaData cfm , Selection selection , StatementRestrictions restrictions ) throws InvalidRequestException { if ( ! restrictions . keyIsInRelation ( ) ) return null ; Map < ColumnIdentifier , Integer > orderingIndexes = getOrderingIndex ( cfm , selection ) ; List < Integer > idToSort = new ArrayList < Integer > ( ) ; List < Comparator < ByteBuffer > > sorters = new ArrayList < Comparator < ByteBuffer > > ( ) ; for ( ColumnIdentifier . Raw raw : parameters . orderings . keySet ( ) ) { ColumnIdentifier identifier = raw . prepare ( cfm ) ; ColumnDefinition orderingColumn = cfm . getColumnDefinition ( identifier ) ; idToSort . add ( orderingIndexes . get ( orderingColumn . name ) ) ; sorters . add ( orderingColumn . type ) ; } return idToSort . size ( ) = = <int> ? new SingleColumnComparator ( idToSort . get ( <int> ) , sorters . get ( <int> ) ) : new CompositeComparator ( sorters , idToSort ) ; } private Map < ColumnIdentifier , Integer > getOrderingIndex ( CFMetaData cfm , Selection selection ) throws InvalidRequestException { Map < ColumnIdentifier , Integer > orderingIndexes = new HashMap < > ( ) ; for ( ColumnIdentifier . Raw raw : parameters . orderings . keySet ( ) ) { ColumnIdentifier column = raw . prepare ( cfm ) ; final ColumnDefinition def = cfm . getColumnDefinition ( column ) ; if ( def = = null ) handleUnrecognizedOrderingColumn ( column ) ; int index = selection . getResultSetIndex ( def ) ; if ( index < <int> ) index = selection . addColumnForOrdering ( def ) ; orderingIndexes . put ( def . name , index ) ; } return orderingIndexes ; } private boolean isReversed ( CFMetaData cfm ) throws InvalidRequestException { Boolean [ ] reversedMap = new Boolean [ cfm . clusteringColumns ( ) . size ( ) ] ; int i = <int> ; for ( Map . Entry < ColumnIdentifier . Raw , Boolean > entry : parameters . orderings . entrySet ( ) ) { ColumnIdentifier column = entry . getKey ( ) . prepare ( cfm ) ; boolean reversed = entry . getValue ( ) ; ColumnDefinition def = cfm . getColumnDefinition ( column ) ; if ( def = = null ) handleUnrecognizedOrderingColumn ( column ) ; checkTrue ( def . isClusteringColumn ( ) , <str> , column ) ; checkTrue ( i + + = = def . position ( ) , <str> ) ; reversedMap [ def . position ( ) ] = ( reversed ! = def . isReversedType ( ) ) ; } Boolean isReversed = null ; for ( Boolean b : reversedMap ) { if ( b = = null ) continue ; if ( isReversed = = null ) { isReversed = b ; continue ; } checkTrue ( isReversed . equals ( b ) , <str> ) ; } assert isReversed ! = null ; return isReversed ; } private void checkNeedsFiltering ( StatementRestrictions restrictions ) throws InvalidRequestException { if ( ! parameters . allowFiltering & & ( restrictions . isKeyRange ( ) | | restrictions . usesSecondaryIndexing ( ) ) ) { checkFalse ( restrictions . needFiltering ( ) , REQUIRES_ALLOW_FILTERING_MESSAGE ) ; } } private boolean containsAlias ( final ColumnIdentifier name ) { return Iterables . any ( selectClause , new Predicate < RawSelector > ( ) { public boolean apply ( RawSelector raw ) { return name . equals ( raw . alias ) ; } } ) ; } private ColumnSpecification limitReceiver ( ) { return new ColumnSpecification ( keyspace ( ) , columnFamily ( ) , new ColumnIdentifier ( <str> , true ) , Int32Type . instance ) ; } @Override public String toString ( ) { return Objects . toStringHelper ( this ) . add ( <str> , cfName ) . add ( <str> , selectClause ) . add ( <str> , whereClause ) . add ( <str> , parameters . isDistinct ) . toString ( ) ; } } public static class Parameters { public final Map < ColumnIdentifier . Raw , Boolean > orderings ; public final boolean isDistinct ; public final boolean allowFiltering ; public final boolean isJson ; public Parameters ( Map < ColumnIdentifier . Raw , Boolean > orderings , boolean isDistinct , boolean allowFiltering , boolean isJson ) { this . orderings = orderings ; this . isDistinct = isDistinct ; this . allowFiltering = allowFiltering ; this . isJson = isJson ; } } private static class SingleColumnComparator implements Comparator < List < ByteBuffer > > { private final int index ; private final Comparator < ByteBuffer > comparator ; public SingleColumnComparator ( int columnIndex , Comparator < ByteBuffer > orderer ) { index = columnIndex ; comparator = orderer ; } public int compare ( List < ByteBuffer > a , List < ByteBuffer > b ) { return comparator . compare ( a . get ( index ) , b . get ( index ) ) ; } } private static class CompositeComparator implements Comparator < List < ByteBuffer > > { private final List < Comparator < ByteBuffer > > orderTypes ; private final List < Integer > positions ; private CompositeComparator ( List < Comparator < ByteBuffer > > orderTypes , List < Integer > positions ) { this . orderTypes = orderTypes ; this . positions = positions ; } public int compare ( List < ByteBuffer > a , List < ByteBuffer > b ) { for ( int i = <int> ; i < positions . size ( ) ; i + + ) { Comparator < ByteBuffer > type = orderTypes . get ( i ) ; int columnPos = positions . get ( i ) ; ByteBuffer aValue = a . get ( columnPos ) ; ByteBuffer bValue = b . get ( columnPos ) ; int comparison = type . compare ( aValue , bValue ) ; if ( comparison ! = <int> ) return comparison ; } return <int> ; } } }