package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . http . HttpClientCodec ; import io . netty . handler . codec . http . HttpObjectAggregator ; import io . netty . handler . codec . http . HttpServerCodec ; import io . netty . handler . codec . http . websocketx . WebSocketClientProtocolHandler . ClientHandshakeStateEvent ; import io . netty . handler . codec . http . websocketx . WebSocketServerProtocolHandler . ServerHandshakeStateEvent ; import org . junit . Before ; import org . junit . Test ; import java . net . URI ; import static org . junit . Assert . * ; public class WebSocketHandshakeHandOverTest { private boolean serverReceivedHandshake ; private boolean clientReceivedHandshake ; private boolean clientReceivedMessage ; @Before public void setUp ( ) { serverReceivedHandshake = false ; clientReceivedHandshake = false ; clientReceivedMessage = false ; } @Test public void testHandover ( ) throws Exception { EmbeddedChannel serverChannel = createServerChannel ( new SimpleChannelInboundHandler < Object > ( ) { @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) { if ( evt = = ServerHandshakeStateEvent . HANDSHAKE_COMPLETE ) { serverReceivedHandshake = true ; ctx . writeAndFlush ( new TextWebSocketFrame ( <str> ) ) ; } } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { } } ) ; EmbeddedChannel clientChannel = createClientChannel ( new SimpleChannelInboundHandler < Object > ( ) { @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) { if ( evt = = ClientHandshakeStateEvent . HANDSHAKE_COMPLETE ) { clientReceivedHandshake = true ; } } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( msg instanceof TextWebSocketFrame ) { clientReceivedMessage = true ; } } } ) ; transferAllDataWithMerge ( clientChannel , serverChannel ) ; assertTrue ( serverReceivedHandshake ) ; transferAllDataWithMerge ( serverChannel , clientChannel ) ; assertTrue ( clientReceivedHandshake ) ; assertTrue ( clientReceivedMessage ) ; } private static void transferAllDataWithMerge ( EmbeddedChannel srcChannel , EmbeddedChannel dstChannel ) { ByteBuf mergedBuffer = null ; for ( ; ; ) { Object srcData = srcChannel . readOutbound ( ) ; if ( srcData ! = null ) { assertTrue ( srcData instanceof ByteBuf ) ; ByteBuf srcBuf = ( ByteBuf ) srcData ; try { if ( mergedBuffer = = null ) { mergedBuffer = Unpooled . buffer ( ) ; } mergedBuffer . writeBytes ( srcBuf ) ; } finally { srcBuf . release ( ) ; } } else { break ; } } if ( mergedBuffer ! = null ) { dstChannel . writeInbound ( mergedBuffer ) ; } } private static EmbeddedChannel createClientChannel ( ChannelHandler handler ) throws Exception { return new EmbeddedChannel ( new HttpClientCodec ( ) , new HttpObjectAggregator ( <int> ) , new WebSocketClientProtocolHandler ( new URI ( <str> ) , WebSocketVersion . V13 , null , false , null , <int> ) , handler ) ; } private static EmbeddedChannel createServerChannel ( ChannelHandler handler ) { return new EmbeddedChannel ( new HttpServerCodec ( ) , new HttpObjectAggregator ( <int> ) , new WebSocketServerProtocolHandler ( <str> , null , false ) , handler ) ; } }