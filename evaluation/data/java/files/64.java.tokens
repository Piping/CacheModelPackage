package com . netflix . hystrix ; import java . util . ArrayList ; import java . util . BitSet ; import java . util . List ; public class ExecutionResult { private final EventCounts eventCounts ; private final Exception failedExecutionException ; private final Exception executionException ; private final long startTimestamp ; private final int executionLatency ; private final int userThreadLatency ; private final boolean executionOccurred ; private final boolean isExecutedInThread ; private final HystrixCollapserKey collapserKey ; private static final HystrixEventType [ ] ALL_EVENT_TYPES = HystrixEventType . values ( ) ; private static final int NUM_EVENT_TYPES = ALL_EVENT_TYPES . length ; private static final BitSet EXCEPTION_PRODUCING_EVENTS = new BitSet ( NUM_EVENT_TYPES ) ; static { for ( HystrixEventType eventType : HystrixEventType . EXCEPTION_PRODUCING_EVENT_TYPES ) { EXCEPTION_PRODUCING_EVENTS . set ( eventType . ordinal ( ) ) ; } } public static class EventCounts { private final BitSet events ; private final int numEmissions ; private final int numFallbackEmissions ; private final int numCollapsed ; EventCounts ( ) { this . events = new BitSet ( NUM_EVENT_TYPES ) ; this . numEmissions = <int> ; this . numFallbackEmissions = <int> ; this . numCollapsed = <int> ; } EventCounts ( BitSet events , int numEmissions , int numFallbackEmissions , int numCollapsed ) { this . events = events ; this . numEmissions = numEmissions ; this . numFallbackEmissions = numFallbackEmissions ; this . numCollapsed = numCollapsed ; } EventCounts ( HystrixEventType . . . eventTypes ) { BitSet newBitSet = new BitSet ( NUM_EVENT_TYPES ) ; int localNumEmits = <int> ; int localNumFallbackEmits = <int> ; int localNumCollapsed = <int> ; for ( HystrixEventType eventType : eventTypes ) { switch ( eventType ) { case EMIT : newBitSet . set ( HystrixEventType . EMIT . ordinal ( ) ) ; localNumEmits + + ; break ; case FALLBACK_EMIT : newBitSet . set ( HystrixEventType . FALLBACK_EMIT . ordinal ( ) ) ; localNumFallbackEmits + + ; break ; case COLLAPSED : newBitSet . set ( HystrixEventType . COLLAPSED . ordinal ( ) ) ; localNumCollapsed + + ; break ; default : newBitSet . set ( eventType . ordinal ( ) ) ; break ; } } this . events = newBitSet ; this . numEmissions = localNumEmits ; this . numFallbackEmissions = localNumFallbackEmits ; this . numCollapsed = localNumCollapsed ; } EventCounts plus ( HystrixEventType eventType ) { return plus ( eventType , <int> ) ; } EventCounts plus ( HystrixEventType eventType , int count ) { BitSet newBitSet = ( BitSet ) events . clone ( ) ; int localNumEmits = numEmissions ; int localNumFallbackEmits = numFallbackEmissions ; int localNumCollapsed = numCollapsed ; switch ( eventType ) { case EMIT : newBitSet . set ( HystrixEventType . EMIT . ordinal ( ) ) ; localNumEmits + = count ; break ; case FALLBACK_EMIT : newBitSet . set ( HystrixEventType . FALLBACK_EMIT . ordinal ( ) ) ; localNumFallbackEmits + = count ; break ; case COLLAPSED : newBitSet . set ( HystrixEventType . COLLAPSED . ordinal ( ) ) ; localNumCollapsed + = count ; break ; default : newBitSet . set ( eventType . ordinal ( ) ) ; break ; } return new EventCounts ( newBitSet , localNumEmits , localNumFallbackEmits , localNumCollapsed ) ; } public boolean contains ( HystrixEventType eventType ) { return events . get ( eventType . ordinal ( ) ) ; } public boolean containsAnyOf ( BitSet other ) { return events . intersects ( other ) ; } public int getCount ( HystrixEventType eventType ) { switch ( eventType ) { case EMIT : return numEmissions ; case FALLBACK_EMIT : return numFallbackEmissions ; case EXCEPTION_THROWN : return containsAnyOf ( EXCEPTION_PRODUCING_EVENTS ) ? <int> : <int> ; case COLLAPSED : return numCollapsed ; default : return contains ( eventType ) ? <int> : <int> ; } } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; EventCounts that = ( EventCounts ) o ; if ( numEmissions ! = that . numEmissions ) return false ; if ( numFallbackEmissions ! = that . numFallbackEmissions ) return false ; if ( numCollapsed ! = that . numCollapsed ) return false ; return events . equals ( that . events ) ; } @Override public int hashCode ( ) { int result = events . hashCode ( ) ; result = <int> * result + numEmissions ; result = <int> * result + numFallbackEmissions ; result = <int> * result + numCollapsed ; return result ; } @Override public String toString ( ) { return <str> + <str> + events + <str> + numEmissions + <str> + numFallbackEmissions + <str> + numCollapsed + <str> ; } } private ExecutionResult ( EventCounts eventCounts , long startTimestamp , int executionLatency , int userThreadLatency , Exception failedExecutionException , Exception executionException , boolean executionOccurred , boolean isExecutedInThread , HystrixCollapserKey collapserKey ) { this . eventCounts = eventCounts ; this . startTimestamp = startTimestamp ; this . executionLatency = executionLatency ; this . userThreadLatency = userThreadLatency ; this . failedExecutionException = failedExecutionException ; this . executionException = executionException ; this . executionOccurred = executionOccurred ; this . isExecutedInThread = isExecutedInThread ; this . collapserKey = collapserKey ; } static ExecutionResult EMPTY = ExecutionResult . from ( ) ; public static ExecutionResult from ( HystrixEventType . . . eventTypes ) { boolean didExecutionOccur = false ; for ( HystrixEventType eventType : eventTypes ) { if ( didExecutionOccur ( eventType ) ) { didExecutionOccur = true ; } } return new ExecutionResult ( new EventCounts ( eventTypes ) , - <int> , - <int> , - <int> , null , null , didExecutionOccur , false , null ) ; } private static boolean didExecutionOccur ( HystrixEventType eventType ) { switch ( eventType ) { case SUCCESS : return true ; case FAILURE : return true ; case BAD_REQUEST : return true ; case TIMEOUT : return true ; default : return false ; } } public ExecutionResult setExecutionLatency ( int executionLatency ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } public ExecutionResult setException ( Exception e ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , userThreadLatency , e , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } public ExecutionResult setExecutionException ( Exception executionException ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } public ExecutionResult setInvocationStartTime ( long startTimestamp ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } public ExecutionResult setExecutedInThread ( ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred , true , collapserKey ) ; } public ExecutionResult markCollapsed ( HystrixCollapserKey collapserKey , int sizeOfBatch ) { return new ExecutionResult ( eventCounts . plus ( HystrixEventType . COLLAPSED , sizeOfBatch ) , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } @Deprecated public ExecutionResult markUserThreadCompletion ( long userThreadLatency ) { if ( startTimestamp > <int> & & ! isResponseRejected ( ) ) { return new ExecutionResult ( eventCounts , startTimestamp , executionLatency , ( int ) userThreadLatency , failedExecutionException , executionException , executionOccurred , isExecutedInThread , collapserKey ) ; } else { return this ; } } public ExecutionResult addEvent ( HystrixEventType eventType ) { return new ExecutionResult ( eventCounts . plus ( eventType ) , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred ? executionOccurred : didExecutionOccur ( eventType ) , isExecutedInThread , collapserKey ) ; } public ExecutionResult addEvent ( int executionLatency , HystrixEventType eventType ) { if ( startTimestamp > = <int> & & ! isResponseRejected ( ) ) { return new ExecutionResult ( eventCounts . plus ( eventType ) , startTimestamp , executionLatency , userThreadLatency , failedExecutionException , executionException , executionOccurred ? executionOccurred : didExecutionOccur ( eventType ) , isExecutedInThread , collapserKey ) ; } else { return addEvent ( eventType ) ; } } public EventCounts getEventCounts ( ) { return eventCounts ; } public long getStartTimestamp ( ) { return startTimestamp ; } public int getExecutionLatency ( ) { return executionLatency ; } public int getUserThreadLatency ( ) { return userThreadLatency ; } public long getCommandRunStartTimeInNanos ( ) { return startTimestamp * <int> * <int> ; } public Exception getException ( ) { return failedExecutionException ; } public Exception getExecutionException ( ) { return executionException ; } public HystrixCollapserKey getCollapserKey ( ) { return collapserKey ; } public boolean isResponseSemaphoreRejected ( ) { return eventCounts . contains ( HystrixEventType . SEMAPHORE_REJECTED ) ; } public boolean isResponseThreadPoolRejected ( ) { return eventCounts . contains ( HystrixEventType . THREAD_POOL_REJECTED ) ; } public boolean isResponseRejected ( ) { return isResponseThreadPoolRejected ( ) | | isResponseSemaphoreRejected ( ) ; } public List < HystrixEventType > getOrderedList ( ) { List < HystrixEventType > eventList = new ArrayList < HystrixEventType > ( ) ; for ( HystrixEventType eventType : ALL_EVENT_TYPES ) { if ( eventCounts . contains ( eventType ) ) { eventList . add ( eventType ) ; } } return eventList ; } public boolean isExecutedInThread ( ) { return isExecutedInThread ; } public boolean executionOccurred ( ) { return executionOccurred ; } @Override public String toString ( ) { return <str> + <str> + eventCounts + <str> + failedExecutionException + <str> + executionException + <str> + startTimestamp + <str> + executionLatency + <str> + userThreadLatency + <str> + executionOccurred + <str> + isExecutedInThread + <str> + collapserKey + <str> ; } }