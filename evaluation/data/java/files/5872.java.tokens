package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import rx . Observable ; import rx . Observer ; import rx . exceptions . TestException ; import rx . functions . Func1 ; import rx . functions . Func2 ; import rx . internal . util . UtilityFunctions ; public class OperatorReduceTest { @Mock Observer < Object > observer ; @Before public void before ( ) { MockitoAnnotations . initMocks ( this ) ; } Func2 < Integer , Integer , Integer > sum = new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ; @Test public void testAggregateAsIntSum ( ) { Observable < Integer > result = Observable . just ( <int> , <int> , <int> , <int> , <int> ) . reduce ( <int> , sum ) . map ( UtilityFunctions . < Integer > identity ( ) ) ; result . subscribe ( observer ) ; verify ( observer ) . onNext ( <int> + <int> + <int> + <int> + <int> ) ; verify ( observer ) . onCompleted ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testAggregateAsIntSumSourceThrows ( ) { Observable < Integer > result = Observable . concat ( Observable . just ( <int> , <int> , <int> , <int> , <int> ) , Observable . < Integer > error ( new TestException ( ) ) ) . reduce ( <int> , sum ) . map ( UtilityFunctions . < Integer > identity ( ) ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onCompleted ( ) ; verify ( observer , times ( <int> ) ) . onError ( any ( TestException . class ) ) ; } @Test public void testAggregateAsIntSumAccumulatorThrows ( ) { Func2 < Integer , Integer , Integer > sumErr = new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { throw new TestException ( ) ; } } ; Observable < Integer > result = Observable . just ( <int> , <int> , <int> , <int> , <int> ) . reduce ( <int> , sumErr ) . map ( UtilityFunctions . < Integer > identity ( ) ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onCompleted ( ) ; verify ( observer , times ( <int> ) ) . onError ( any ( TestException . class ) ) ; } @Test public void testAggregateAsIntSumResultSelectorThrows ( ) { Func1 < Integer , Integer > error = new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer t1 ) { throw new TestException ( ) ; } } ; Observable < Integer > result = Observable . just ( <int> , <int> , <int> , <int> , <int> ) . reduce ( <int> , sum ) . map ( error ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onCompleted ( ) ; verify ( observer , times ( <int> ) ) . onError ( any ( TestException . class ) ) ; } @Test public void testBackpressureWithNoInitialValue ( ) throws InterruptedException { Observable < Integer > source = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> ) ; Observable < Integer > reduced = source . reduce ( sum ) ; Integer r = reduced . toBlocking ( ) . first ( ) ; assertEquals ( <int> , r . intValue ( ) ) ; } @Test public void testBackpressureWithInitialValue ( ) throws InterruptedException { Observable < Integer > source = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> ) ; Observable < Integer > reduced = source . reduce ( <int> , sum ) ; Integer r = reduced . toBlocking ( ) . first ( ) ; assertEquals ( <int> , r . intValue ( ) ) ; } }