package org . apache . cassandra . io . sstable ; import java . io . ByteArrayInputStream ; import java . io . DataInputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . Lists ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . db . * ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . io . sstable . IndexSummaryBuilder . downsample ; import static org . apache . cassandra . io . sstable . IndexSummaryBuilder . entriesAtSamplingLevel ; import static org . apache . cassandra . io . sstable . Downsampling . BASE_SAMPLING_LEVEL ; import static org . junit . Assert . * ; public class IndexSummaryTest { IPartitioner partitioner = Util . testPartitioner ( ) ; @Test public void testGetKey ( ) { Pair < List < DecoratedKey > , IndexSummary > random = generateRandomIndex ( <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( random . left . get ( i ) . getKey ( ) , ByteBuffer . wrap ( random . right . getKey ( i ) ) ) ; random . right . close ( ) ; } @Test public void testBinarySearch ( ) { Pair < List < DecoratedKey > , IndexSummary > random = generateRandomIndex ( <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( i , random . right . binarySearch ( random . left . get ( i ) ) ) ; random . right . close ( ) ; } @Test public void testGetPosition ( ) { Pair < List < DecoratedKey > , IndexSummary > random = generateRandomIndex ( <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( i * <int> , random . right . getPosition ( i ) ) ; random . right . close ( ) ; } @Test public void testSerialization ( ) throws IOException { Pair < List < DecoratedKey > , IndexSummary > random = generateRandomIndex ( <int> , <int> ) ; DataOutputBuffer dos = new DataOutputBuffer ( ) ; IndexSummary . serializer . serialize ( random . right , dos , false ) ; dos . writeUTF ( <str> ) ; dos . writeUTF ( <str> ) ; FileUtils . closeQuietly ( dos ) ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( dos . toByteArray ( ) ) ) ; IndexSummary is = IndexSummary . serializer . deserialize ( dis , partitioner , false , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( i , is . binarySearch ( random . left . get ( i ) ) ) ; assertEquals ( dis . readUTF ( ) , <str> ) ; assertEquals ( dis . readUTF ( ) , <str> ) ; is . close ( ) ; FileUtils . closeQuietly ( dis ) ; random . right . close ( ) ; } @Test public void testAddEmptyKey ( ) throws Exception { IPartitioner p = new RandomPartitioner ( ) ; try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( <int> , <int> , BASE_SAMPLING_LEVEL ) ) { builder . maybeAddEntry ( p . decorateKey ( ByteBufferUtil . EMPTY_BYTE_BUFFER ) , <int> ) ; IndexSummary summary = builder . build ( p ) ; assertEquals ( <int> , summary . size ( ) ) ; assertEquals ( <int> , summary . getPosition ( <int> ) ) ; assertArrayEquals ( new byte [ <int> ] , summary . getKey ( <int> ) ) ; DataOutputBuffer dos = new DataOutputBuffer ( ) ; IndexSummary . serializer . serialize ( summary , dos , false ) ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( dos . toByteArray ( ) ) ) ; IndexSummary loaded = IndexSummary . serializer . deserialize ( dis , p , false , <int> , <int> ) ; assertEquals ( <int> , loaded . size ( ) ) ; assertEquals ( summary . getPosition ( <int> ) , loaded . getPosition ( <int> ) ) ; assertArrayEquals ( summary . getKey ( <int> ) , summary . getKey ( <int> ) ) ; summary . close ( ) ; loaded . close ( ) ; } } private Pair < List < DecoratedKey > , IndexSummary > generateRandomIndex ( int size , int interval ) { List < DecoratedKey > list = Lists . newArrayList ( ) ; try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( list . size ( ) , interval , BASE_SAMPLING_LEVEL ) ) { for ( int i = <int> ; i < size ; i + + ) { UUID uuid = UUID . randomUUID ( ) ; DecoratedKey key = partitioner . decorateKey ( ByteBufferUtil . bytes ( uuid ) ) ; list . add ( key ) ; } Collections . sort ( list ) ; for ( int i = <int> ; i < size ; i + + ) builder . maybeAddEntry ( list . get ( i ) , i ) ; IndexSummary summary = builder . build ( partitioner ) ; return Pair . create ( list , summary ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } @Test public void testDownsamplePatterns ( ) { assertEquals ( Arrays . asList ( <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> , <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , Downsampling . getSamplingPattern ( <int> ) ) ; } private static boolean shouldSkip ( int index , List < Integer > startPoints ) { for ( int start : startPoints ) { if ( ( index - start ) % BASE_SAMPLING_LEVEL = = <int> ) return true ; } return false ; } @Test public void testDownsample ( ) { final int NUM_KEYS = <int> ; final int INDEX_INTERVAL = <int> ; final int ORIGINAL_NUM_ENTRIES = NUM_KEYS / INDEX_INTERVAL ; Pair < List < DecoratedKey > , IndexSummary > random = generateRandomIndex ( NUM_KEYS , INDEX_INTERVAL ) ; List < DecoratedKey > keys = random . left ; IndexSummary original = random . right ; for ( int i = <int> ; i < ORIGINAL_NUM_ENTRIES ; i + + ) assertEquals ( keys . get ( i * INDEX_INTERVAL ) . getKey ( ) , ByteBuffer . wrap ( original . getKey ( i ) ) ) ; List < Integer > samplePattern = Downsampling . getSamplingPattern ( BASE_SAMPLING_LEVEL ) ; int downsamplingRound = <int> ; for ( int samplingLevel = BASE_SAMPLING_LEVEL - <int> ; samplingLevel > = <int> ; samplingLevel - - ) { try ( IndexSummary downsampled = downsample ( original , samplingLevel , <int> , partitioner ) ; ) { assertEquals ( entriesAtSamplingLevel ( samplingLevel , original . getMaxNumberOfEntries ( ) ) , downsampled . size ( ) ) ; int sampledCount = <int> ; List < Integer > skipStartPoints = samplePattern . subList ( <int> , downsamplingRound ) ; for ( int i = <int> ; i < ORIGINAL_NUM_ENTRIES ; i + + ) { if ( ! shouldSkip ( i , skipStartPoints ) ) { assertEquals ( keys . get ( i * INDEX_INTERVAL ) . getKey ( ) , ByteBuffer . wrap ( downsampled . getKey ( sampledCount ) ) ) ; sampledCount + + ; } } testPosition ( original , downsampled , keys ) ; downsamplingRound + + ; } } IndexSummary previous = original ; downsamplingRound = <int> ; for ( int downsampleLevel = BASE_SAMPLING_LEVEL - <int> ; downsampleLevel > = <int> ; downsampleLevel - - ) { IndexSummary downsampled = downsample ( previous , downsampleLevel , <int> , partitioner ) ; if ( previous ! = original ) previous . close ( ) ; assertEquals ( entriesAtSamplingLevel ( downsampleLevel , original . getMaxNumberOfEntries ( ) ) , downsampled . size ( ) ) ; int sampledCount = <int> ; List < Integer > skipStartPoints = samplePattern . subList ( <int> , downsamplingRound ) ; for ( int i = <int> ; i < ORIGINAL_NUM_ENTRIES ; i + + ) { if ( ! shouldSkip ( i , skipStartPoints ) ) { assertEquals ( keys . get ( i * INDEX_INTERVAL ) . getKey ( ) , ByteBuffer . wrap ( downsampled . getKey ( sampledCount ) ) ) ; sampledCount + + ; } } testPosition ( original , downsampled , keys ) ; previous = downsampled ; downsamplingRound + + ; } previous . close ( ) ; original . close ( ) ; } private void testPosition ( IndexSummary original , IndexSummary downsampled , List < DecoratedKey > keys ) { for ( DecoratedKey key : keys ) { long orig = SSTableReader . getIndexScanPositionFromBinarySearchResult ( original . binarySearch ( key ) , original ) ; int binarySearch = downsampled . binarySearch ( key ) ; int index = SSTableReader . getIndexSummaryIndexFromBinarySearchResult ( binarySearch ) ; int scanFrom = ( int ) SSTableReader . getIndexScanPositionFromBinarySearchResult ( index , downsampled ) ; assert scanFrom < = orig ; int effectiveInterval = downsampled . getEffectiveIndexIntervalAfterIndex ( index ) ; DecoratedKey k = null ; for ( int i = <int> ; k ! = key & & i < effectiveInterval & & scanFrom < keys . size ( ) ; i + + , scanFrom + + ) k = keys . get ( scanFrom ) ; assert k = = key ; } } @Test public void testOriginalIndexLookup ( ) { for ( int i = BASE_SAMPLING_LEVEL ; i > = <int> ; i - - ) assertEquals ( i , Downsampling . getOriginalIndexes ( i ) . size ( ) ) ; ArrayList < Integer > full = new ArrayList < > ( ) ; for ( int i = <int> ; i < BASE_SAMPLING_LEVEL ; i + + ) full . add ( i ) ; assertEquals ( full , Downsampling . getOriginalIndexes ( BASE_SAMPLING_LEVEL ) ) ; assertEquals ( full . subList ( <int> , full . size ( ) - <int> ) , Downsampling . getOriginalIndexes ( BASE_SAMPLING_LEVEL - <int> ) ) ; assertEquals ( <int> , BASE_SAMPLING_LEVEL ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> ) , Downsampling . getOriginalIndexes ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> , <int> ) , Downsampling . getOriginalIndexes ( <int> ) ) ; assertEquals ( Arrays . asList ( <int> ) , Downsampling . getOriginalIndexes ( <int> ) ) ; } @Test public void testGetNumberOfSkippedEntriesAfterIndex ( ) { int indexInterval = <int> ; for ( int i = <int> ; i < BASE_SAMPLING_LEVEL ; i + + ) assertEquals ( indexInterval , Downsampling . getEffectiveIndexIntervalAfterIndex ( i , BASE_SAMPLING_LEVEL , indexInterval ) ) ; for ( int i = <int> ; i < BASE_SAMPLING_LEVEL - <int> ; i + + ) assertEquals ( indexInterval , Downsampling . getEffectiveIndexIntervalAfterIndex ( i , BASE_SAMPLING_LEVEL - <int> , indexInterval ) ) ; assertEquals ( indexInterval * <int> , Downsampling . getEffectiveIndexIntervalAfterIndex ( BASE_SAMPLING_LEVEL - <int> , BASE_SAMPLING_LEVEL - <int> , indexInterval ) ) ; assertEquals ( <int> , BASE_SAMPLING_LEVEL ) ; assertEquals ( <int> * indexInterval , Downsampling . getEffectiveIndexIntervalAfterIndex ( <int> , <int> , indexInterval ) ) ; assertEquals ( <int> * indexInterval , Downsampling . getEffectiveIndexIntervalAfterIndex ( <int> , <int> , indexInterval ) ) ; } } 
