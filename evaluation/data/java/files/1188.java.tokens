package org . elasticsearch . mapper . attachments ; import org . apache . commons . cli . CommandLine ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . cli . CliTool ; import org . elasticsearch . common . cli . CliToolConfig ; import org . elasticsearch . common . cli . Terminal ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . MapperTestUtils ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . ParseContext ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Locale ; import static org . elasticsearch . common . cli . CliToolConfig . Builder . cmd ; import static org . elasticsearch . common . cli . CliToolConfig . Builder . option ; import static org . elasticsearch . common . io . Streams . copy ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . mapper . attachments . AttachmentUnitTestCase . getIndicesModuleWithRegisteredAttachmentMapper ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; @SuppressForbidden ( reason = <str> ) public class StandaloneRunner extends CliTool { private static final CliToolConfig CONFIG = CliToolConfig . config ( <str> , StandaloneRunner . class ) . cmds ( TikaRunner . CMD ) . build ( ) ; static { System . setProperty ( <str> , <str> ) ; } static class TikaRunner extends Command { private static final String NAME = <str> ; private final String url ; private final Integer size ; private final String base64text ; private final DocumentMapper docMapper ; private static final CliToolConfig . Cmd CMD = cmd ( NAME , TikaRunner . class ) . options ( option ( <str> , <str> ) . required ( false ) . hasArg ( false ) ) . options ( option ( <str> , <str> ) . required ( false ) . hasArg ( false ) ) . build ( ) ; protected TikaRunner ( Terminal terminal , String url , Integer size , String base64text ) throws IOException { super ( terminal ) ; this . size = size ; this . url = url ; this . base64text = base64text ; DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( PathUtils . get ( <str> ) , Settings . EMPTY , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; docMapper = mapperParser . parse ( mapping ) ; } @Override public ExitStatus execute ( Settings settings , Environment env ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . field ( <str> ) . startObject ( ) ; if ( base64text ! = null ) { builder . field ( <str> , base64text ) ; } else { byte [ ] bytes = copyToBytes ( PathUtils . get ( url ) ) ; builder . field ( <str> , bytes ) ; } if ( size > = <int> ) { builder . field ( <str> , size ) ; } BytesReference json = builder . endObject ( ) . endObject ( ) . bytes ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , json ) . rootDoc ( ) ; terminal . println ( <str> ) ; terminal . println ( <str> ) ; terminal . println ( <str> , doc . get ( <str> ) ) ; terminal . println ( <str> ) ; terminal . println ( <str> ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . AUTHOR ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . CONTENT_LENGTH ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . CONTENT_TYPE ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . DATE ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . KEYWORDS ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . LANGUAGE ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . NAME ) ; printMetadataContent ( doc , AttachmentMapper . FieldNames . TITLE ) ; return ExitStatus . OK ; } private void printMetadataContent ( ParseContext . Document doc , String field ) { terminal . println ( <str> , field , doc . get ( docMapper . mappers ( ) . getMapper ( <str> + field ) . fieldType ( ) . names ( ) . indexName ( ) ) ) ; } public static byte [ ] copyToBytes ( Path path ) throws IOException { try ( InputStream is = Files . newInputStream ( path ) ) { if ( is = = null ) { throw new FileNotFoundException ( <str> + path + <str> ) ; } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { copy ( is , out ) ; return out . bytes ( ) . toBytes ( ) ; } } } public static Command parse ( Terminal terminal , CommandLine cli ) throws IOException { String url = cli . getOptionValue ( <str> ) ; String base64text = null ; String sSize = cli . getOptionValue ( <str> ) ; Integer size = sSize ! = null ? Integer . parseInt ( sSize ) : - <int> ; if ( url = = null & & cli . getArgs ( ) . length = = <int> ) { return exitCmd ( ExitStatus . USAGE , terminal , <str> ) ; } if ( url = = null ) { if ( cli . getArgs ( ) . length = = <int> ) { return exitCmd ( ExitStatus . USAGE , terminal , <str> ) ; } base64text = cli . getArgs ( ) [ <int> ] ; } else { if ( cli . getArgs ( ) . length = = <int> ) { return exitCmd ( ExitStatus . USAGE , terminal , <str> ) ; } } return new TikaRunner ( terminal , url , size , base64text ) ; } } public StandaloneRunner ( ) { super ( CONFIG ) ; } public static void main ( String [ ] args ) { StandaloneRunner pluginManager = new StandaloneRunner ( ) ; pluginManager . execute ( args ) ; } @Override protected Command parse ( String cmdName , CommandLine cli ) throws Exception { switch ( cmdName . toLowerCase ( Locale . ROOT ) ) { case TikaRunner . NAME : return TikaRunner . parse ( terminal , cli ) ; default : assert false : <str> ; return exitCmd ( ExitStatus . CODE_ERROR ) ; } } } 
