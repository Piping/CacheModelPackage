package com . google . common . util . concurrent ; import com . google . common . collect . ObjectArrays ; import java . util . AbstractQueue ; import java . util . Collection ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; import javax . annotation . Nullable ; public class MonitorBasedArrayBlockingQueue < E > extends AbstractQueue < E > implements BlockingQueue < E > { final E [ ] items ; int takeIndex ; int putIndex ; private int count ; final Monitor monitor ; private final Monitor . Guard notEmpty ; private final Monitor . Guard notFull ; final int inc ( int i ) { return ( + + i = = items . length ) ? <int> : i ; } private void insert ( E x ) { items [ putIndex ] = x ; putIndex = inc ( putIndex ) ; + + count ; } private E extract ( ) { final E [ ] items = this . items ; E x = items [ takeIndex ] ; items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; - - count ; return x ; } void removeAt ( int i ) { final E [ ] items = this . items ; if ( i = = takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; } else { for ( ; ; ) { int nexti = inc ( i ) ; if ( nexti ! = putIndex ) { items [ i ] = items [ nexti ] ; i = nexti ; } else { items [ i ] = null ; putIndex = i ; break ; } } } - - count ; } public MonitorBasedArrayBlockingQueue ( int capacity ) { this ( capacity , false ) ; } public MonitorBasedArrayBlockingQueue ( int capacity , boolean fair ) { if ( capacity < = <int> ) throw new IllegalArgumentException ( ) ; this . items = newEArray ( capacity ) ; monitor = new Monitor ( fair ) ; notEmpty = new Monitor . Guard ( monitor ) { @Override public boolean isSatisfied ( ) { return count > <int> ; } } ; notFull = new Monitor . Guard ( monitor ) { @Override public boolean isSatisfied ( ) { return count < items . length ; } } ; } @SuppressWarnings ( <str> ) private static < E > E [ ] newEArray ( int capacity ) { return ( E [ ] ) new Object [ capacity ] ; } public MonitorBasedArrayBlockingQueue ( int capacity , boolean fair , Collection < ? extends E > c ) { this ( capacity , fair ) ; if ( capacity < c . size ( ) ) throw new IllegalArgumentException ( ) ; for ( E e : c ) add ( e ) ; } @Override public boolean add ( E e ) { return super . add ( e ) ; } @Override public boolean offer ( E e ) { if ( e = = null ) throw new NullPointerException ( ) ; final Monitor monitor = this . monitor ; if ( monitor . enterIf ( notFull ) ) { try { insert ( e ) ; return true ; } finally { monitor . leave ( ) ; } } else { return false ; } } @Override public void put ( E e ) throws InterruptedException { if ( e = = null ) throw new NullPointerException ( ) ; final Monitor monitor = this . monitor ; monitor . enterWhen ( notFull ) ; try { insert ( e ) ; } finally { monitor . leave ( ) ; } } @Override public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e = = null ) throw new NullPointerException ( ) ; final Monitor monitor = this . monitor ; if ( monitor . enterWhen ( notFull , timeout , unit ) ) { try { insert ( e ) ; return true ; } finally { monitor . leave ( ) ; } } else { return false ; } } @Override public E poll ( ) { final Monitor monitor = this . monitor ; if ( monitor . enterIf ( notEmpty ) ) { try { return extract ( ) ; } finally { monitor . leave ( ) ; } } else { return null ; } } @Override public E take ( ) throws InterruptedException { final Monitor monitor = this . monitor ; monitor . enterWhen ( notEmpty ) ; try { return extract ( ) ; } finally { monitor . leave ( ) ; } } @Override public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { final Monitor monitor = this . monitor ; if ( monitor . enterWhen ( notEmpty , timeout , unit ) ) { try { return extract ( ) ; } finally { monitor . leave ( ) ; } } else { return null ; } } @Override public E peek ( ) { final Monitor monitor = this . monitor ; if ( monitor . enterIf ( notEmpty ) ) { try { return items [ takeIndex ] ; } finally { monitor . leave ( ) ; } } else { return null ; } } @Override public int size ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return count ; } finally { monitor . leave ( ) ; } } @Override public int remainingCapacity ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return items . length - count ; } finally { monitor . leave ( ) ; } } @Override public boolean remove ( @Nullable Object o ) { if ( o = = null ) return false ; final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int k = <int> ; for ( ; ; ) { if ( k + + > = count ) return false ; if ( o . equals ( items [ i ] ) ) { removeAt ( i ) ; return true ; } i = inc ( i ) ; } } finally { monitor . leave ( ) ; } } @Override public boolean contains ( @Nullable Object o ) { if ( o = = null ) return false ; final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int k = <int> ; while ( k + + < count ) { if ( o . equals ( items [ i ] ) ) return true ; i = inc ( i ) ; } return false ; } finally { monitor . leave ( ) ; } } @Override public Object [ ] toArray ( ) { final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { Object [ ] a = new Object [ count ] ; int k = <int> ; int i = takeIndex ; while ( k < count ) { a [ k + + ] = items [ i ] ; i = inc ( i ) ; } return a ; } finally { monitor . leave ( ) ; } } @Override public < T > T [ ] toArray ( T [ ] a ) { final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { if ( a . length < count ) a = ObjectArrays . newArray ( a , count ) ; int k = <int> ; int i = takeIndex ; while ( k < count ) { @SuppressWarnings ( <str> ) T t = ( T ) items [ i ] ; a [ k + + ] = t ; i = inc ( i ) ; } if ( a . length > count ) a [ count ] = null ; return a ; } finally { monitor . leave ( ) ; } } @Override public String toString ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return super . toString ( ) ; } finally { monitor . leave ( ) ; } } @Override public void clear ( ) { final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int k = count ; while ( k - - > <int> ) { items [ i ] = null ; i = inc ( i ) ; } count = <int> ; putIndex = <int> ; takeIndex = <int> ; } finally { monitor . leave ( ) ; } } @Override public int drainTo ( Collection < ? super E > c ) { if ( c = = null ) throw new NullPointerException ( ) ; if ( c = = this ) throw new IllegalArgumentException ( ) ; final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int n = <int> ; int max = count ; while ( n < max ) { c . add ( items [ i ] ) ; items [ i ] = null ; i = inc ( i ) ; + + n ; } if ( n > <int> ) { count = <int> ; putIndex = <int> ; takeIndex = <int> ; } return n ; } finally { monitor . leave ( ) ; } } @Override public int drainTo ( Collection < ? super E > c , int maxElements ) { if ( c = = null ) throw new NullPointerException ( ) ; if ( c = = this ) throw new IllegalArgumentException ( ) ; if ( maxElements < = <int> ) return <int> ; final E [ ] items = this . items ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int i = takeIndex ; int n = <int> ; int max = ( maxElements < count ) ? maxElements : count ; while ( n < max ) { c . add ( items [ i ] ) ; items [ i ] = null ; i = inc ( i ) ; + + n ; } if ( n > <int> ) { count - = n ; takeIndex = i ; } return n ; } finally { monitor . leave ( ) ; } } @Override public Iterator < E > iterator ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return new Itr ( ) ; } finally { monitor . leave ( ) ; } } private class Itr implements Iterator < E > { private int nextIndex ; private E nextItem ; private int lastRet ; Itr ( ) { lastRet = - <int> ; if ( count = = <int> ) nextIndex = - <int> ; else { nextIndex = takeIndex ; nextItem = items [ takeIndex ] ; } } @Override public boolean hasNext ( ) { return nextIndex > = <int> ; } private void checkNext ( ) { if ( nextIndex = = putIndex ) { nextIndex = - <int> ; nextItem = null ; } else { nextItem = items [ nextIndex ] ; if ( nextItem = = null ) nextIndex = - <int> ; } } @Override public E next ( ) { final Monitor monitor = MonitorBasedArrayBlockingQueue . this . monitor ; monitor . enter ( ) ; try { if ( nextIndex < <int> ) throw new NoSuchElementException ( ) ; lastRet = nextIndex ; E x = nextItem ; nextIndex = inc ( nextIndex ) ; checkNext ( ) ; return x ; } finally { monitor . leave ( ) ; } } @Override public void remove ( ) { final Monitor monitor = MonitorBasedArrayBlockingQueue . this . monitor ; monitor . enter ( ) ; try { int i = lastRet ; if ( i = = - <int> ) throw new IllegalStateException ( ) ; lastRet = - <int> ; int ti = takeIndex ; removeAt ( i ) ; nextIndex = ( i = = ti ) ? takeIndex : i ; checkNext ( ) ; } finally { monitor . leave ( ) ; } } } }