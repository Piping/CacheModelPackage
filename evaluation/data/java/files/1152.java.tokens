package com . google . common . io ; import static com . google . common . io . SourceSinkFactory . ByteSourceFactory ; import static com . google . common . io . SourceSinkFactory . CharSourceFactory ; import static org . junit . Assert . assertArrayEquals ; import com . google . common . base . Charsets ; import com . google . common . base . Optional ; import com . google . common . collect . ImmutableList ; import com . google . common . hash . HashCode ; import com . google . common . hash . Hashing ; import junit . framework . TestSuite ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Random ; @AndroidIncompatible public class ByteSourceTester extends SourceSinkTester < ByteSource , byte [ ] , ByteSourceFactory > { private static final ImmutableList < Method > testMethods = getTestMethods ( ByteSourceTester . class ) ; static TestSuite tests ( String name , ByteSourceFactory factory , boolean testAsCharSource ) { TestSuite suite = new TestSuite ( name ) ; for ( Map . Entry < String , String > entry : TEST_STRINGS . entrySet ( ) ) { if ( testAsCharSource ) { suite . addTest ( suiteForString ( factory , entry . getValue ( ) , name , entry . getKey ( ) ) ) ; } else { suite . addTest ( suiteForBytes ( factory , entry . getValue ( ) . getBytes ( Charsets . UTF_8 ) , name , entry . getKey ( ) , true ) ) ; } } return suite ; } static TestSuite suiteForString ( ByteSourceFactory factory , String string , String name , String desc ) { TestSuite suite = suiteForBytes ( factory , string . getBytes ( Charsets . UTF_8 ) , name , desc , true ) ; CharSourceFactory charSourceFactory = SourceSinkFactories . asCharSourceFactory ( factory ) ; suite . addTest ( CharSourceTester . suiteForString ( charSourceFactory , string , name + <str> , desc ) ) ; return suite ; } static TestSuite suiteForBytes ( ByteSourceFactory factory , byte [ ] bytes , String name , String desc , boolean slice ) { TestSuite suite = new TestSuite ( name + <str> + desc + <str> ) ; for ( Method method : testMethods ) { suite . addTest ( new ByteSourceTester ( factory , bytes , name , desc , method ) ) ; } if ( slice & & bytes . length > <int> ) { Random random = new Random ( ) ; byte [ ] expected = factory . getExpected ( bytes ) ; int off = expected . length = = <int> ? <int> : random . nextInt ( expected . length ) ; int len = expected . length = = <int> ? <int> : random . nextInt ( expected . length - off ) ; ByteSourceFactory sliced = SourceSinkFactories . asSlicedByteSourceFactory ( factory , off , len ) ; suite . addTest ( suiteForBytes ( sliced , bytes , name + <str> , desc , false ) ) ; ByteSourceFactory slicedLongMaxValue = SourceSinkFactories . asSlicedByteSourceFactory ( factory , off , Long . MAX_VALUE ) ; suite . addTest ( suiteForBytes ( slicedLongMaxValue , bytes , name + <str> , desc , false ) ) ; ByteSourceFactory slicedOffsetPastEnd = SourceSinkFactories . asSlicedByteSourceFactory ( factory , expected . length + <int> , expected . length + <int> ) ; suite . addTest ( suiteForBytes ( slicedOffsetPastEnd , bytes , name + <str> , desc , false ) ) ; } return suite ; } private ByteSource source ; public ByteSourceTester ( ByteSourceFactory factory , byte [ ] bytes , String suiteName , String caseDesc , Method method ) { super ( factory , bytes , suiteName , caseDesc , method ) ; } @Override public void setUp ( ) throws IOException { source = factory . createSource ( data ) ; } public void testOpenStream ( ) throws IOException { InputStream in = source . openStream ( ) ; try { byte [ ] readBytes = ByteStreams . toByteArray ( in ) ; assertExpectedBytes ( readBytes ) ; } finally { in . close ( ) ; } } public void testOpenBufferedStream ( ) throws IOException { InputStream in = source . openBufferedStream ( ) ; try { byte [ ] readBytes = ByteStreams . toByteArray ( in ) ; assertExpectedBytes ( readBytes ) ; } finally { in . close ( ) ; } } public void testRead ( ) throws IOException { byte [ ] readBytes = source . read ( ) ; assertExpectedBytes ( readBytes ) ; } public void testCopyTo_outputStream ( ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; source . copyTo ( out ) ; assertExpectedBytes ( out . toByteArray ( ) ) ; } public void testCopyTo_byteSink ( ) throws IOException { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; source . copyTo ( new ByteSink ( ) { @Override public OutputStream openStream ( ) throws IOException { return out ; } } ) ; assertExpectedBytes ( out . toByteArray ( ) ) ; } public void testIsEmpty ( ) throws IOException { assertEquals ( expected . length = = <int> , source . isEmpty ( ) ) ; } public void testSize ( ) throws IOException { assertEquals ( expected . length , source . size ( ) ) ; } public void testSizeIfKnown ( ) throws IOException { Optional < Long > sizeIfKnown = source . sizeIfKnown ( ) ; if ( sizeIfKnown . isPresent ( ) ) { assertEquals ( expected . length , ( long ) sizeIfKnown . get ( ) ) ; } } public void testContentEquals ( ) throws IOException { assertTrue ( source . contentEquals ( new ByteSource ( ) { @Override public InputStream openStream ( ) throws IOException { return new RandomAmountInputStream ( new ByteArrayInputStream ( expected ) , new Random ( ) ) ; } } ) ) ; } public void testRead_usingByteProcessor ( ) throws IOException { byte [ ] readBytes = source . read ( new ByteProcessor < byte [ ] > ( ) { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; @Override public boolean processBytes ( byte [ ] buf , int off , int len ) throws IOException { out . write ( buf , off , len ) ; return true ; } @Override public byte [ ] getResult ( ) { return out . toByteArray ( ) ; } } ) ; assertExpectedBytes ( readBytes ) ; } public void testHash ( ) throws IOException { HashCode expectedHash = Hashing . md5 ( ) . hashBytes ( expected ) ; assertEquals ( expectedHash , source . hash ( Hashing . md5 ( ) ) ) ; } public void testSlice_illegalArguments ( ) { try { source . slice ( - <int> , <int> ) ; fail ( <str> + source ) ; } catch ( IllegalArgumentException expected ) { } try { source . slice ( <int> , - <int> ) ; fail ( <str> + source ) ; } catch ( IllegalArgumentException expected ) { } } public void testSlice_constrainedRange ( ) throws IOException { long size = source . read ( ) . length ; if ( size > = <int> ) { ByteSource sliced = source . slice ( <int> , size - <int> ) ; assertEquals ( size - <int> , sliced . read ( ) . length ) ; ByteSource resliced = sliced . slice ( <int> , size - <int> ) ; assertTrue ( sliced . contentEquals ( resliced ) ) ; } } private void assertExpectedBytes ( byte [ ] readBytes ) { assertArrayEquals ( expected , readBytes ) ; } }