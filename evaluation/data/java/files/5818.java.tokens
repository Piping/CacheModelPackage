package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . util . Arrays ; import java . util . List ; import java . util . Vector ; import java . util . concurrent . ExecutionException ; import org . junit . Test ; import rx . Notification ; import rx . Observable ; import rx . Subscriber ; import rx . functions . Action1 ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; public class OperatorMaterializeTest { @Test public void testMaterialize1 ( ) { final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( <str> , <str> , null , <str> ) ; TestObserver Observer = new TestObserver ( ) ; Observable < Notification < String > > m = Observable . create ( o1 ) . materialize ( ) ; m . subscribe ( Observer ) ; try { o1 . t . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertFalse ( Observer . onError ) ; assertTrue ( Observer . onCompleted ) ; assertEquals ( <int> , Observer . notifications . size ( ) ) ; assertEquals ( <str> , Observer . notifications . get ( <int> ) . getValue ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnNext ( ) ) ; assertEquals ( <str> , Observer . notifications . get ( <int> ) . getValue ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnNext ( ) ) ; assertEquals ( NullPointerException . class , Observer . notifications . get ( <int> ) . getThrowable ( ) . getClass ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnError ( ) ) ; } @Test public void testMaterialize2 ( ) { final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( <str> , <str> , <str> ) ; TestObserver Observer = new TestObserver ( ) ; Observable < Notification < String > > m = Observable . create ( o1 ) . materialize ( ) ; m . subscribe ( Observer ) ; try { o1 . t . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertFalse ( Observer . onError ) ; assertTrue ( Observer . onCompleted ) ; assertEquals ( <int> , Observer . notifications . size ( ) ) ; assertEquals ( <str> , Observer . notifications . get ( <int> ) . getValue ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnNext ( ) ) ; assertEquals ( <str> , Observer . notifications . get ( <int> ) . getValue ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnNext ( ) ) ; assertEquals ( <str> , Observer . notifications . get ( <int> ) . getValue ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnNext ( ) ) ; assertTrue ( Observer . notifications . get ( <int> ) . isOnCompleted ( ) ) ; } @Test public void testMultipleSubscribes ( ) throws InterruptedException , ExecutionException { final TestAsyncErrorObservable o = new TestAsyncErrorObservable ( <str> , <str> , null , <str> ) ; Observable < Notification < String > > m = Observable . create ( o ) . materialize ( ) ; assertEquals ( <int> , m . toList ( ) . toBlocking ( ) . toFuture ( ) . get ( ) . size ( ) ) ; assertEquals ( <int> , m . toList ( ) . toBlocking ( ) . toFuture ( ) . get ( ) . size ( ) ) ; } @Test public void testBackpressureOnEmptyStream ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; Observable . < Integer > empty ( ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; assertTrue ( ts . getOnNextEvents ( ) . get ( <int> ) . isOnCompleted ( ) ) ; ts . assertCompleted ( ) ; } @Test public void testBackpressureNoError ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; Observable . just ( <int> , <int> , <int> ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . assertCompleted ( ) ; } @Test public void testBackpressureNoErrorAsync ( ) throws InterruptedException { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; Observable . just ( <int> , <int> , <int> ) . materialize ( ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; Thread . sleep ( <int> ) ; ts . assertNoValues ( ) ; ts . requestMore ( <int> ) ; Thread . sleep ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . requestMore ( <int> ) ; Thread . sleep ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . requestMore ( <int> ) ; Thread . sleep ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . assertCompleted ( ) ; } @Test public void testBackpressureWithError ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; Observable . < Integer > error ( new IllegalArgumentException ( ) ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; ts . assertCompleted ( ) ; } @Test public void testBackpressureWithEmissionThenError ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . from ( Arrays . asList ( <int> ) ) . concatWith ( Observable . < Integer > error ( ex ) ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; assertTrue ( ts . getOnNextEvents ( ) . get ( <int> ) . hasValue ( ) ) ; ts . requestMore ( <int> ) ; ts . assertValueCount ( <int> ) ; assertTrue ( ts . getOnNextEvents ( ) . get ( <int> ) . isOnError ( ) ) ; assertTrue ( ex = = ts . getOnNextEvents ( ) . get ( <int> ) . getThrowable ( ) ) ; ts . assertCompleted ( ) ; } @Test public void testWithCompletionCausingError ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( ) ; final RuntimeException ex = new RuntimeException ( <str> ) ; Observable . < Integer > empty ( ) . materialize ( ) . doOnNext ( new Action1 < Object > ( ) { @Override public void call ( Object t ) { throw ex ; } } ) . subscribe ( ts ) ; ts . assertError ( ex ) ; ts . assertNoValues ( ) ; ts . assertTerminalEvent ( ) ; } @Test public void testUnsubscribeJustBeforeCompletionNotificationShouldPreventThatNotificationArriving ( ) { TestSubscriber < Notification < Integer > > ts = TestSubscriber . create ( <int> ) ; IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . < Integer > empty ( ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . unsubscribe ( ) ; ts . requestMore ( <int> ) ; ts . assertNoValues ( ) ; ts . assertUnsubscribed ( ) ; } private static class TestObserver extends Subscriber < Notification < String > > { boolean onCompleted = false ; boolean onError = false ; List < Notification < String > > notifications = new Vector < Notification < String > > ( ) ; @Override public void onCompleted ( ) { this . onCompleted = true ; } @Override public void onError ( Throwable e ) { this . onError = true ; } @Override public void onNext ( Notification < String > value ) { this . notifications . add ( value ) ; } } private static class TestAsyncErrorObservable implements Observable . OnSubscribe < String > { String [ ] valuesToReturn ; TestAsyncErrorObservable ( String . . . values ) { valuesToReturn = values ; } volatile Thread t ; @Override public void call ( final Subscriber < ? super String > observer ) { t = new Thread ( new Runnable ( ) { @Override public void run ( ) { for ( String s : valuesToReturn ) { if ( s = = null ) { System . out . println ( <str> ) ; try { Thread . sleep ( <int> ) ; } catch ( Throwable e ) { } observer . onError ( new NullPointerException ( ) ) ; return ; } else { observer . onNext ( s ) ; } } System . out . println ( <str> ) ; observer . onCompleted ( ) ; } } ) ; t . start ( ) ; } } }