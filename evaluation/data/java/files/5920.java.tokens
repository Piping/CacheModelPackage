package rx . subjects ; import static org . junit . Assert . assertEquals ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicReference ; import org . junit . * ; import rx . * ; import rx . Observable . OnSubscribe ; import rx . Observable ; import rx . Observer ; import rx . functions . * ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; public class ReplaySubjectConcurrencyTest { public static void main ( String args [ ] ) { try { for ( int i = <int> ; i < <int> ; i + + ) { new ReplaySubjectConcurrencyTest ( ) . testSubscribeCompletionRaceCondition ( ) ; new ReplaySubjectConcurrencyTest ( ) . testReplaySubjectConcurrentSubscriptions ( ) ; new ReplaySubjectConcurrencyTest ( ) . testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } @Test ( timeout = <int> ) public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther ( ) throws InterruptedException { final ReplaySubject < Long > replay = ReplaySubject . create ( ) ; Thread source = new Thread ( new Runnable ( ) { @Override public void run ( ) { Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > o ) { System . out . println ( <str> ) ; for ( long l = <int> ; l < = <int> ; l + + ) { o . onNext ( l ) ; } System . out . println ( <str> ) ; o . onCompleted ( ) ; } } ) . subscribe ( replay ) ; } } ) ; source . start ( ) ; long v = replay . toBlocking ( ) . last ( ) ; assertEquals ( <int> , v ) ; final CountDownLatch slowLatch = new CountDownLatch ( <int> ) ; Thread slowThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { Subscriber < Long > slow = new Subscriber < Long > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; slowLatch . countDown ( ) ; } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Long args ) { if ( args = = <int> ) { System . out . println ( <str> ) ; } try { if ( args % <int> = = <int> ) { Thread . sleep ( <int> ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; replay . subscribe ( slow ) ; try { slowLatch . await ( ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } } ) ; slowThread . start ( ) ; Thread fastThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { final CountDownLatch fastLatch = new CountDownLatch ( <int> ) ; Subscriber < Long > fast = new Subscriber < Long > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; fastLatch . countDown ( ) ; } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Long args ) { if ( args = = <int> ) { System . out . println ( <str> ) ; } } } ; replay . subscribe ( fast ) ; try { fastLatch . await ( ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } } ) ; fastThread . start ( ) ; fastThread . join ( ) ; assertEquals ( <int> , slowLatch . getCount ( ) ) ; slowThread . join ( ) ; } @Test public void testReplaySubjectConcurrentSubscriptions ( ) throws InterruptedException { final ReplaySubject < Long > replay = ReplaySubject . create ( ) ; Thread source = new Thread ( new Runnable ( ) { @Override public void run ( ) { Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > o ) { System . out . println ( <str> ) ; for ( long l = <int> ; l < = <int> ; l + + ) { o . onNext ( l ) ; } System . out . println ( <str> ) ; o . onCompleted ( ) ; } } ) . subscribe ( replay ) ; } } ) ; final List < List < Long > > listOfListsOfValues = Collections . synchronizedList ( new ArrayList < List < Long > > ( ) ) ; final List < Thread > threads = Collections . synchronizedList ( new ArrayList < Thread > ( ) ) ; for ( int i = <int> ; i < = <int> ; i + + ) { final int count = i ; if ( count = = <int> ) { source . start ( ) ; } if ( count = = <int> ) { source . join ( ) ; } Thread t = new Thread ( new Runnable ( ) { @Override public void run ( ) { List < Long > values = replay . toList ( ) . toBlocking ( ) . last ( ) ; listOfListsOfValues . add ( values ) ; System . out . println ( <str> + count ) ; } } ) ; t . start ( ) ; System . out . println ( <str> + i ) ; threads . add ( t ) ; } for ( Thread t : threads ) { t . join ( ) ; } List < Long > sums = new ArrayList < Long > ( ) ; for ( List < Long > values : listOfListsOfValues ) { long v = <int> ; for ( long l : values ) { v + = l ; } sums . add ( v ) ; } long expected = sums . get ( <int> ) ; boolean success = true ; for ( long l : sums ) { if ( l ! = expected ) { success = false ; System . out . println ( <str> + expected + <str> + l ) ; } } if ( success ) { System . out . println ( <str> + sums . size ( ) + <str> + expected ) ; } else { throw new RuntimeException ( <str> ) ; } } @Test ( timeout = <int> ) public void testSubscribeCompletionRaceCondition ( ) { for ( int i = <int> ; i < <int> ; i + + ) { final ReplaySubject < String > subject = ReplaySubject . create ( ) ; final AtomicReference < String > value1 = new AtomicReference < String > ( ) ; subject . subscribe ( new Action1 < String > ( ) { @Override public void call ( String t1 ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } value1 . set ( t1 ) ; } } ) ; Thread t1 = new Thread ( new Runnable ( ) { @Override public void run ( ) { subject . onNext ( <str> ) ; subject . onCompleted ( ) ; } } ) ; SubjectObserverThread t2 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t3 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t4 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t5 = new SubjectObserverThread ( subject ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try { t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertEquals ( <str> , value1 . get ( ) ) ; assertEquals ( <str> , t2 . value . get ( ) ) ; assertEquals ( <str> , t3 . value . get ( ) ) ; assertEquals ( <str> , t4 . value . get ( ) ) ; assertEquals ( <str> , t5 . value . get ( ) ) ; } } @Test public void testRaceForTerminalState ( ) { final List < Integer > expected = Arrays . asList ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . just ( <int> ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertReceivedOnNext ( expected ) ; ts . assertTerminalEvent ( ) ; } } private static class SubjectObserverThread extends Thread { private final ReplaySubject < String > subject ; private final AtomicReference < String > value = new AtomicReference < String > ( ) ; public SubjectObserverThread ( ReplaySubject < String > subject ) { this . subject = subject ; } @Override public void run ( ) { try { String v = subject . timeout ( <int> , TimeUnit . MILLISECONDS ) . toBlocking ( ) . single ( ) ; value . set ( v ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @Test public void testReplaySubjectEmissionSubscriptionRace ( ) throws Exception { Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { if ( i % <int> = = <int> ) { System . out . println ( i ) ; } final ReplaySubject < Object > rs = ReplaySubject . create ( ) ; final CountDownLatch finish = new CountDownLatch ( <int> ) ; final CountDownLatch start = new CountDownLatch ( <int> ) ; worker . schedule ( new Action0 ( ) { @Override public void call ( ) { try { start . await ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } rs . onNext ( <int> ) ; } } ) ; final AtomicReference < Object > o = new AtomicReference < Object > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new Observer < Object > ( ) { @Override public void onCompleted ( ) { o . set ( - <int> ) ; finish . countDown ( ) ; } @Override public void onError ( Throwable e ) { o . set ( e ) ; finish . countDown ( ) ; } @Override public void onNext ( Object t ) { o . set ( t ) ; finish . countDown ( ) ; } } ) ; start . countDown ( ) ; if ( ! finish . await ( <int> , TimeUnit . SECONDS ) ) { System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasObservers ( ) ) ; rs . onCompleted ( ) ; Assert . fail ( <str> + i ) ; break ; } else { Assert . assertEquals ( <int> , o . get ( ) ) ; worker . schedule ( new Action0 ( ) { @Override public void call ( ) { rs . onCompleted ( ) ; } } ) ; } } } finally { worker . unsubscribe ( ) ; } } @Test ( timeout = <int> ) public void testConcurrentSizeAndHasAnyValue ( ) throws InterruptedException { final ReplaySubject < Object > rs = ReplaySubject . create ( ) ; final CyclicBarrier cb = new CyclicBarrier ( <int> ) ; Thread t = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { cb . await ( ) ; } catch ( InterruptedException e ) { return ; } catch ( BrokenBarrierException e ) { return ; } for ( int i = <int> ; i < <int> ; i + + ) { rs . onNext ( i ) ; } rs . onCompleted ( ) ; System . out . println ( <str> ) ; } } ) ; t . start ( ) ; try { cb . await ( ) ; } catch ( InterruptedException e ) { return ; } catch ( BrokenBarrierException e ) { return ; } int lastSize = <int> ; for ( ; ! rs . hasThrowable ( ) & & ! rs . hasCompleted ( ) ; ) { int size = rs . size ( ) ; boolean hasAny = rs . hasAnyValue ( ) ; Object [ ] values = rs . getValues ( ) ; if ( size < lastSize ) { Assert . fail ( <str> + lastSize + <str> + size ) ; } if ( ( size > <int> ) & & ! hasAny ) { Assert . fail ( <str> ) ; } if ( size > values . length ) { Assert . fail ( <str> + size + <str> + values . length ) ; } lastSize = size ; } t . join ( ) ; } }