package io . netty . handler . codec . http ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . util . List ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; public class HttpRequestDecoderTest { private static final byte [ ] CONTENT_CRLF_DELIMITERS = createContent ( <str> ) ; private static final byte [ ] CONTENT_LF_DELIMITERS = createContent ( <str> ) ; private static final byte [ ] CONTENT_MIXED_DELIMITERS = createContent ( <str> , <str> ) ; private static final int CONTENT_LENGTH = <int> ; private static byte [ ] createContent ( String . . . lineDelimiters ) { String lineDelimiter ; String lineDelimiter2 ; if ( lineDelimiters . length = = <int> ) { lineDelimiter = lineDelimiters [ <int> ] ; lineDelimiter2 = lineDelimiters [ <int> ] ; } else { lineDelimiter = lineDelimiters [ <int> ] ; lineDelimiter2 = lineDelimiters [ <int> ] ; } return ( <str> + <str> + <str> + lineDelimiter2 + <str> + lineDelimiter + <str> + lineDelimiter2 + <str> + lineDelimiter + <str> + lineDelimiter2 + <str> + lineDelimiter + <str> + CONTENT_LENGTH + lineDelimiter2 + <str> + <str> ) . getBytes ( CharsetUtil . US_ASCII ) ; } @Test public void testDecodeWholeRequestAtOnceCRLFDelimiters ( ) { testDecodeWholeRequestAtOnce ( CONTENT_CRLF_DELIMITERS ) ; } @Test public void testDecodeWholeRequestAtOnceLFDelimiters ( ) { testDecodeWholeRequestAtOnce ( CONTENT_LF_DELIMITERS ) ; } @Test public void testDecodeWholeRequestAtOnceMixedDelimiters ( ) { testDecodeWholeRequestAtOnce ( CONTENT_MIXED_DELIMITERS ) ; } private static void testDecodeWholeRequestAtOnce ( byte [ ] content ) { EmbeddedChannel channel = new EmbeddedChannel ( new HttpRequestDecoder ( ) ) ; assertTrue ( channel . writeInbound ( Unpooled . wrappedBuffer ( content ) ) ) ; HttpRequest req = channel . readInbound ( ) ; assertNotNull ( req ) ; checkHeaders ( req . headers ( ) ) ; LastHttpContent c = channel . readInbound ( ) ; assertEquals ( CONTENT_LENGTH , c . content ( ) . readableBytes ( ) ) ; assertEquals ( Unpooled . wrappedBuffer ( content , content . length - CONTENT_LENGTH , CONTENT_LENGTH ) , c . content ( ) . readBytes ( CONTENT_LENGTH ) ) ; c . release ( ) ; assertFalse ( channel . finish ( ) ) ; assertNull ( channel . readInbound ( ) ) ; } private static void checkHeaders ( HttpHeaders headers ) { assertEquals ( <int> , headers . names ( ) . size ( ) ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , <str> ) ; checkHeader ( headers , <str> , String . valueOf ( CONTENT_LENGTH ) ) ; } private static void checkHeader ( HttpHeaders headers , String name , String value ) { List < String > header1 = headers . getAll ( of ( name ) ) ; assertEquals ( <int> , header1 . size ( ) ) ; assertEquals ( value , header1 . get ( <int> ) ) ; } @Test public void testDecodeWholeRequestInMultipleStepsCRLFDelimiters ( ) { testDecodeWholeRequestInMultipleSteps ( CONTENT_CRLF_DELIMITERS ) ; } @Test public void testDecodeWholeRequestInMultipleStepsLFDelimiters ( ) { testDecodeWholeRequestInMultipleSteps ( CONTENT_LF_DELIMITERS ) ; } @Test public void testDecodeWholeRequestInMultipleStepsMixedDelimiters ( ) { testDecodeWholeRequestInMultipleSteps ( CONTENT_MIXED_DELIMITERS ) ; } private static void testDecodeWholeRequestInMultipleSteps ( byte [ ] content ) { for ( int i = <int> ; i < content . length ; i + + ) { testDecodeWholeRequestInMultipleSteps ( content , i ) ; } } private static void testDecodeWholeRequestInMultipleSteps ( byte [ ] content , int fragmentSize ) { EmbeddedChannel channel = new EmbeddedChannel ( new HttpRequestDecoder ( ) ) ; int headerLength = content . length - CONTENT_LENGTH ; for ( int a = <int> ; a < headerLength ; ) { int amount = fragmentSize ; if ( a + amount > headerLength ) { amount = headerLength - a ; } channel . writeInbound ( Unpooled . wrappedBuffer ( content , a , amount ) ) ; a + = amount ; } for ( int i = CONTENT_LENGTH ; i > <int> ; i - - ) { channel . writeInbound ( Unpooled . wrappedBuffer ( content , content . length - i , <int> ) ) ; } HttpRequest req = channel . readInbound ( ) ; assertNotNull ( req ) ; checkHeaders ( req . headers ( ) ) ; for ( int i = CONTENT_LENGTH ; i > <int> ; i - - ) { HttpContent c = channel . readInbound ( ) ; assertEquals ( <int> , c . content ( ) . readableBytes ( ) ) ; assertEquals ( content [ content . length - i ] , c . content ( ) . readByte ( ) ) ; c . release ( ) ; } LastHttpContent c = channel . readInbound ( ) ; assertEquals ( <int> , c . content ( ) . readableBytes ( ) ) ; assertEquals ( content [ content . length - <int> ] , c . content ( ) . readByte ( ) ) ; c . release ( ) ; assertFalse ( channel . finish ( ) ) ; assertNull ( channel . readInbound ( ) ) ; } @Test public void testEmptyHeaderValue ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new HttpRequestDecoder ( ) ) ; String crlf = <str> ; String request = <str> + crlf + <str> + crlf + <str> + crlf + crlf ; channel . writeInbound ( Unpooled . wrappedBuffer ( request . getBytes ( CharsetUtil . US_ASCII ) ) ) ; HttpRequest req = channel . readInbound ( ) ; assertEquals ( <str> , req . headers ( ) . get ( of ( <str> ) ) ) ; } @Test public void test100Continue ( ) { HttpRequestDecoder decoder = new HttpRequestDecoder ( ) ; EmbeddedChannel channel = new EmbeddedChannel ( decoder ) ; String oversized = <str> + <str> + <str> ; channel . writeInbound ( Unpooled . copiedBuffer ( oversized , CharsetUtil . US_ASCII ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( HttpRequest . class ) ) ) ; decoder . reset ( ) ; String query = <str> ; channel . writeInbound ( Unpooled . copiedBuffer ( query , CharsetUtil . US_ASCII ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( HttpRequest . class ) ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( LastHttpContent . class ) ) ) ; assertThat ( channel . finish ( ) , is ( false ) ) ; } @Test public void test100ContinueWithBadClient ( ) { HttpRequestDecoder decoder = new HttpRequestDecoder ( ) ; EmbeddedChannel channel = new EmbeddedChannel ( decoder ) ; String oversized = <str> + <str> + <str> + <str> ; channel . writeInbound ( Unpooled . copiedBuffer ( oversized , CharsetUtil . US_ASCII ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( HttpRequest . class ) ) ) ; HttpContent prematureData = channel . readInbound ( ) ; prematureData . release ( ) ; assertThat ( channel . readInbound ( ) , is ( nullValue ( ) ) ) ; decoder . reset ( ) ; String query = <str> ; channel . writeInbound ( Unpooled . copiedBuffer ( query , CharsetUtil . US_ASCII ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( HttpRequest . class ) ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( LastHttpContent . class ) ) ) ; assertThat ( channel . finish ( ) , is ( false ) ) ; } } 
