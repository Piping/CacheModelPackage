package com . badlogic . gdx . backends . lwjgl . audio ; import java . nio . ByteBuffer ; import java . nio . IntBuffer ; import org . lwjgl . BufferUtils ; import org . lwjgl . openal . AL11 ; import com . badlogic . gdx . audio . Music ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import static org . lwjgl . openal . AL10 . * ; public abstract class OpenALMusic implements Music { static private final int bufferSize = <int> * <int> ; static private final int bufferCount = <int> ; static private final int bytesPerSample = <int> ; static private final byte [ ] tempBytes = new byte [ bufferSize ] ; static private final ByteBuffer tempBuffer = BufferUtils . createByteBuffer ( bufferSize ) ; private final OpenALAudio audio ; private IntBuffer buffers ; private int sourceID = - <int> ; private int format , sampleRate ; private boolean isLooping , isPlaying ; private float volume = <int> ; private float pan = <int> ; private float renderedSeconds , secondsPerBuffer ; protected final FileHandle file ; protected int bufferOverhead = <int> ; private OnCompletionListener onCompletionListener ; public OpenALMusic ( OpenALAudio audio , FileHandle file ) { this . audio = audio ; this . file = file ; this . onCompletionListener = null ; } protected void setup ( int channels , int sampleRate ) { this . format = channels > <int> ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16 ; this . sampleRate = sampleRate ; secondsPerBuffer = ( float ) ( bufferSize - bufferOverhead ) / ( bytesPerSample * channels * sampleRate ) ; } public void play ( ) { if ( audio . noDevice ) return ; if ( sourceID = = - <int> ) { sourceID = audio . obtainSource ( true ) ; if ( sourceID = = - <int> ) return ; audio . music . add ( this ) ; if ( buffers = = null ) { buffers = BufferUtils . createIntBuffer ( bufferCount ) ; alGenBuffers ( buffers ) ; if ( alGetError ( ) ! = AL_NO_ERROR ) throw new GdxRuntimeException ( <str> ) ; } alSourcei ( sourceID , AL_LOOPING , AL_FALSE ) ; setPan ( pan , volume ) ; boolean filled = false ; for ( int i = <int> ; i < bufferCount ; i + + ) { int bufferID = buffers . get ( i ) ; if ( ! fill ( bufferID ) ) break ; filled = true ; alSourceQueueBuffers ( sourceID , bufferID ) ; } if ( ! filled & & onCompletionListener ! = null ) onCompletionListener . onCompletion ( this ) ; if ( alGetError ( ) ! = AL_NO_ERROR ) { stop ( ) ; return ; } } if ( ! isPlaying ) { alSourcePlay ( sourceID ) ; isPlaying = true ; } } public void stop ( ) { if ( audio . noDevice ) return ; if ( sourceID = = - <int> ) return ; audio . music . removeValue ( this , true ) ; reset ( ) ; audio . freeSource ( sourceID ) ; sourceID = - <int> ; renderedSeconds = <int> ; isPlaying = false ; } public void pause ( ) { if ( audio . noDevice ) return ; if ( sourceID ! = - <int> ) alSourcePause ( sourceID ) ; isPlaying = false ; } public boolean isPlaying ( ) { if ( audio . noDevice ) return false ; if ( sourceID = = - <int> ) return false ; return isPlaying ; } public void setLooping ( boolean isLooping ) { this . isLooping = isLooping ; } public boolean isLooping ( ) { return isLooping ; } public void setVolume ( float volume ) { this . volume = volume ; if ( audio . noDevice ) return ; if ( sourceID ! = - <int> ) alSourcef ( sourceID , AL_GAIN , volume ) ; } public float getVolume ( ) { return this . volume ; } public void setPan ( float pan , float volume ) { this . volume = volume ; this . pan = pan ; if ( audio . noDevice ) return ; if ( sourceID = = - <int> ) return ; alSource3f ( sourceID , AL_POSITION , MathUtils . cos ( ( pan - <int> ) * MathUtils . PI / <int> ) , <int> , MathUtils . sin ( ( pan + <int> ) * MathUtils . PI / <int> ) ) ; alSourcef ( sourceID , AL_GAIN , volume ) ; } public void setPosition ( float position ) { if ( audio . noDevice ) return ; if ( sourceID = = - <int> ) return ; boolean wasPlaying = isPlaying ; isPlaying = false ; alSourceStop ( sourceID ) ; alSourceUnqueueBuffers ( sourceID , buffers ) ; renderedSeconds + = ( secondsPerBuffer * bufferCount ) ; if ( position < = renderedSeconds ) { reset ( ) ; renderedSeconds = <int> ; } while ( renderedSeconds < ( position - secondsPerBuffer ) ) { if ( read ( tempBytes ) < = <int> ) break ; renderedSeconds + = secondsPerBuffer ; } boolean filled = false ; for ( int i = <int> ; i < bufferCount ; i + + ) { int bufferID = buffers . get ( i ) ; if ( ! fill ( bufferID ) ) break ; filled = true ; alSourceQueueBuffers ( sourceID , bufferID ) ; } if ( ! filled ) { stop ( ) ; if ( onCompletionListener ! = null ) onCompletionListener . onCompletion ( this ) ; } alSourcef ( sourceID , AL11 . AL_SEC_OFFSET , position - renderedSeconds ) ; if ( wasPlaying ) { alSourcePlay ( sourceID ) ; isPlaying = true ; } } public float getPosition ( ) { if ( audio . noDevice ) return <int> ; if ( sourceID = = - <int> ) return <int> ; return renderedSeconds + alGetSourcef ( sourceID , AL11 . AL_SEC_OFFSET ) ; } abstract public int read ( byte [ ] buffer ) ; abstract public void reset ( ) ; protected void loop ( ) { reset ( ) ; } public int getChannels ( ) { return format = = AL_FORMAT_STEREO16 ? <int> : <int> ; } public int getRate ( ) { return sampleRate ; } public void update ( ) { if ( audio . noDevice ) return ; if ( sourceID = = - <int> ) return ; boolean end = false ; int buffers = alGetSourcei ( sourceID , AL_BUFFERS_PROCESSED ) ; while ( buffers - - > <int> ) { int bufferID = alSourceUnqueueBuffers ( sourceID ) ; if ( bufferID = = AL_INVALID_VALUE ) break ; renderedSeconds + = secondsPerBuffer ; if ( end ) continue ; if ( fill ( bufferID ) ) alSourceQueueBuffers ( sourceID , bufferID ) ; else end = true ; } if ( end & & alGetSourcei ( sourceID , AL_BUFFERS_QUEUED ) = = <int> ) { stop ( ) ; if ( onCompletionListener ! = null ) onCompletionListener . onCompletion ( this ) ; } if ( isPlaying & & alGetSourcei ( sourceID , AL_SOURCE_STATE ) ! = AL_PLAYING ) alSourcePlay ( sourceID ) ; } private boolean fill ( int bufferID ) { tempBuffer . clear ( ) ; int length = read ( tempBytes ) ; if ( length < = <int> ) { if ( isLooping ) { loop ( ) ; renderedSeconds = <int> ; length = read ( tempBytes ) ; if ( length < = <int> ) return false ; } else return false ; } tempBuffer . put ( tempBytes , <int> , length ) . flip ( ) ; alBufferData ( bufferID , format , tempBuffer , sampleRate ) ; return true ; } public void dispose ( ) { stop ( ) ; if ( audio . noDevice ) return ; if ( buffers = = null ) return ; alDeleteBuffers ( buffers ) ; buffers = null ; onCompletionListener = null ; } public void setOnCompletionListener ( OnCompletionListener listener ) { onCompletionListener = listener ; } public int getSourceId ( ) { return sourceID ; } } 
