package org . apache . cassandra . service ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicInteger ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . net . IAsyncCallback ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . utils . concurrent . SimpleCondition ; public class TruncateResponseHandler implements IAsyncCallback { protected static final Logger logger = LoggerFactory . getLogger ( TruncateResponseHandler . class ) ; protected final SimpleCondition condition = new SimpleCondition ( ) ; private final int responseCount ; protected final AtomicInteger responses = new AtomicInteger ( <int> ) ; private final long start ; public TruncateResponseHandler ( int responseCount ) { assert <int> < = responseCount : <str> + responseCount ; this . responseCount = responseCount ; start = System . nanoTime ( ) ; } public void get ( ) throws TimeoutException { long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getTruncateRpcTimeout ( ) ) - ( System . nanoTime ( ) - start ) ; boolean success ; try { success = condition . await ( timeout , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException ex ) { throw new AssertionError ( ex ) ; } if ( ! success ) { throw new TimeoutException ( <str> + responses . get ( ) + <str> ) ; } } public void response ( MessageIn message ) { responses . incrementAndGet ( ) ; if ( responses . get ( ) > = responseCount ) condition . signalAll ( ) ; } public boolean isLatencyForSnitch ( ) { return false ; } } 
