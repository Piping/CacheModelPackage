package rx . internal . util . unsafe ; import static rx . internal . util . unsafe . UnsafeAccess . UNSAFE ; import java . util . AbstractQueue ; import java . util . Iterator ; abstract class ConcurrentCircularArrayQueueL0Pad < E > extends AbstractQueue < E > implements MessagePassingQueue < E > { long p00 , p01 , p02 , p03 , p04 , p05 , p06 , p07 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; } public abstract class ConcurrentCircularArrayQueue < E > extends ConcurrentCircularArrayQueueL0Pad < E > { protected static final int SPARSE_SHIFT = Integer . getInteger ( <str> , <int> ) ; protected static final int BUFFER_PAD = <int> ; private static final long REF_ARRAY_BASE ; private static final int REF_ELEMENT_SHIFT ; static { final int scale = UnsafeAccess . UNSAFE . arrayIndexScale ( Object [ ] . class ) ; if ( <int> = = scale ) { REF_ELEMENT_SHIFT = <int> + SPARSE_SHIFT ; } else if ( <int> = = scale ) { REF_ELEMENT_SHIFT = <int> + SPARSE_SHIFT ; } else { throw new IllegalStateException ( <str> ) ; } REF_ARRAY_BASE = UnsafeAccess . UNSAFE . arrayBaseOffset ( Object [ ] . class ) + ( BUFFER_PAD < < ( REF_ELEMENT_SHIFT - SPARSE_SHIFT ) ) ; } protected final long mask ; protected final E [ ] buffer ; @SuppressWarnings ( <str> ) public ConcurrentCircularArrayQueue ( int capacity ) { int actualCapacity = Pow2 . roundToPowerOfTwo ( capacity ) ; mask = actualCapacity - <int> ; buffer = ( E [ ] ) new Object [ ( actualCapacity < < SPARSE_SHIFT ) + BUFFER_PAD * <int> ] ; } protected final long calcElementOffset ( long index ) { return calcElementOffset ( index , mask ) ; } protected final long calcElementOffset ( long index , long mask ) { return REF_ARRAY_BASE + ( ( index & mask ) < < REF_ELEMENT_SHIFT ) ; } protected final void spElement ( long offset , E e ) { spElement ( buffer , offset , e ) ; } protected final void spElement ( E [ ] buffer , long offset , E e ) { UNSAFE . putObject ( buffer , offset , e ) ; } protected final void soElement ( long offset , E e ) { soElement ( buffer , offset , e ) ; } protected final void soElement ( E [ ] buffer , long offset , E e ) { UNSAFE . putOrderedObject ( buffer , offset , e ) ; } protected final E lpElement ( long offset ) { return lpElement ( buffer , offset ) ; } @SuppressWarnings ( <str> ) protected final E lpElement ( E [ ] buffer , long offset ) { return ( E ) UNSAFE . getObject ( buffer , offset ) ; } protected final E lvElement ( long offset ) { return lvElement ( buffer , offset ) ; } @SuppressWarnings ( <str> ) protected final E lvElement ( E [ ] buffer , long offset ) { return ( E ) UNSAFE . getObjectVolatile ( buffer , offset ) ; } @Override public Iterator < E > iterator ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { while ( poll ( ) ! = null | | ! isEmpty ( ) ) ; } }