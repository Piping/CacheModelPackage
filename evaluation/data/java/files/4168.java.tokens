package io . netty . handler . codec . compression ; import com . ning . compress . BufferRecycler ; import com . ning . compress . lzf . ChunkEncoder ; import com . ning . compress . lzf . LZFEncoder ; import com . ning . compress . lzf . util . ChunkEncoderFactory ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import static com . ning . compress . lzf . LZFChunk . * ; public class LzfEncoder extends MessageToByteEncoder < ByteBuf > { private static final int MIN_BLOCK_TO_COMPRESS = <int> ; private final ChunkEncoder encoder ; private final BufferRecycler recycler ; public LzfEncoder ( ) { this ( false , MAX_CHUNK_LEN ) ; } public LzfEncoder ( boolean safeInstance ) { this ( safeInstance , MAX_CHUNK_LEN ) ; } public LzfEncoder ( int totalLength ) { this ( false , totalLength ) ; } public LzfEncoder ( boolean safeInstance , int totalLength ) { super ( false ) ; if ( totalLength < MIN_BLOCK_TO_COMPRESS | | totalLength > MAX_CHUNK_LEN ) { throw new IllegalArgumentException ( <str> + totalLength + <str> + MIN_BLOCK_TO_COMPRESS + <str> + MAX_CHUNK_LEN + <str> ) ; } encoder = safeInstance ? ChunkEncoderFactory . safeNonAllocatingInstance ( totalLength ) : ChunkEncoderFactory . optimalNonAllocatingInstance ( totalLength ) ; recycler = BufferRecycler . instance ( ) ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { final int length = in . readableBytes ( ) ; final int idx = in . readerIndex ( ) ; final byte [ ] input ; final int inputPtr ; if ( in . hasArray ( ) ) { input = in . array ( ) ; inputPtr = in . arrayOffset ( ) + idx ; } else { input = recycler . allocInputBuffer ( length ) ; in . getBytes ( idx , input , <int> , length ) ; inputPtr = <int> ; } final int maxOutputLength = LZFEncoder . estimateMaxWorkspaceSize ( length ) ; out . ensureWritable ( maxOutputLength ) ; final byte [ ] output = out . array ( ) ; final int outputPtr = out . arrayOffset ( ) + out . writerIndex ( ) ; final int outputLength = LZFEncoder . appendEncoded ( encoder , input , inputPtr , length , output , outputPtr ) - outputPtr ; out . writerIndex ( out . writerIndex ( ) + outputLength ) ; in . skipBytes ( length ) ; if ( ! in . hasArray ( ) ) { recycler . releaseInputBuffer ( input ) ; } } }