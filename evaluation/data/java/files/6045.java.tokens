package rx . internal . operators ; import java . util . concurrent . atomic . AtomicLong ; import rx . * ; import rx . Observable . OnSubscribe ; public final class OnSubscribeRange implements OnSubscribe < Integer > { private final int start ; private final int end ; public OnSubscribeRange ( int start , int end ) { this . start = start ; this . end = end ; } @Override public void call ( final Subscriber < ? super Integer > o ) { o . setProducer ( new RangeProducer ( o , start , end ) ) ; } private static final class RangeProducer extends AtomicLong implements Producer { private static final long serialVersionUID = <int> ; private final Subscriber < ? super Integer > o ; private final int end ; private long index ; private RangeProducer ( Subscriber < ? super Integer > o , int start , int end ) { this . o = o ; this . index = start ; this . end = end ; } @Override public void request ( long n ) { if ( get ( ) = = Long . MAX_VALUE ) { return ; } if ( n = = Long . MAX_VALUE & & compareAndSet ( <int> , Long . MAX_VALUE ) ) { fastpath ( ) ; } else if ( n > <int> ) { long c = BackpressureUtils . getAndAddRequest ( this , n ) ; if ( c = = <int> ) { slowpath ( n ) ; } } } void slowpath ( long r ) { long idx = index ; while ( true ) { long fs = end - idx + <int> ; long e = Math . min ( fs , r ) ; final boolean complete = fs < = r ; fs = e + idx ; final Subscriber < ? super Integer > o = this . o ; for ( long i = idx ; i ! = fs ; i + + ) { if ( o . isUnsubscribed ( ) ) { return ; } o . onNext ( ( int ) i ) ; } if ( complete ) { if ( o . isUnsubscribed ( ) ) { return ; } o . onCompleted ( ) ; return ; } idx = fs ; index = fs ; r = addAndGet ( - e ) ; if ( r = = <int> ) { return ; } } } void fastpath ( ) { final long end = this . end + <int> ; final Subscriber < ? super Integer > o = this . o ; for ( long i = index ; i ! = end ; i + + ) { if ( o . isUnsubscribed ( ) ) { return ; } o . onNext ( ( int ) i ) ; } if ( ! o . isUnsubscribed ( ) ) { o . onCompleted ( ) ; } } } }