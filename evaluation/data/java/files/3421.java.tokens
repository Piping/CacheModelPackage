package org . nd4j . bytebuddy . shape ; import net . bytebuddy . ByteBuddy ; import net . bytebuddy . dynamic . DynamicType ; import net . bytebuddy . dynamic . loading . ClassLoadingStrategy ; import net . bytebuddy . implementation . Implementation ; import net . bytebuddy . matcher . ElementMatchers ; import org . junit . Test ; import static org . junit . Assert . * ; public class ShapeMapperTest { @Test public void testShapeMapper ( ) throws Exception { Implementation cImpl = ShapeMapper . getInd2Sub ( <str> , <int> ) ; Implementation fImpl = ShapeMapper . getInd2Sub ( <str> , <int> ) ; DynamicType . Unloaded < IndexMapper > c = new ByteBuddy ( ) . subclass ( IndexMapper . class ) . method ( ElementMatchers . isDeclaredBy ( IndexMapper . class ) ) . intercept ( cImpl ) . make ( ) ; DynamicType . Unloaded < IndexMapper > f = new ByteBuddy ( ) . subclass ( IndexMapper . class ) . method ( ElementMatchers . isDeclaredBy ( IndexMapper . class ) ) . intercept ( fImpl ) . make ( ) ; Class < ? > dynamicType = c . load ( IndexMapper . class . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) ; Class < ? > dynamicTypeF = f . load ( IndexMapper . class . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) ; IndexMapper testC = ( IndexMapper ) dynamicType . newInstance ( ) ; IndexMapper testF = ( IndexMapper ) dynamicTypeF . newInstance ( ) ; int n = <int> ; long byteBuddyTotal = <int> ; for ( int i = <int> ; i < n ; i + + ) { long start = System . nanoTime ( ) ; int [ ] cTest = testC . ind2sub ( new int [ ] { <int> , <int> } , <int> , <int> , <str> ) ; long end = System . nanoTime ( ) ; byteBuddyTotal + = Math . abs ( ( end - start ) ) ; } byteBuddyTotal / = n ; System . out . println ( <str> + byteBuddyTotal ) ; int [ ] cTest = testC . ind2sub ( new int [ ] { <int> , <int> } , <int> , <int> , <str> ) ; int [ ] fTest = testF . ind2sub ( new int [ ] { <int> , <int> } , <int> , <int> , <str> ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , fTest ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , cTest ) ; } @Test public void testOffsetMapper ( ) throws Exception { OffsetMapper mapper = ShapeMapper . getOffsetMapperInstance ( <int> ) ; assertEquals ( verifyImpl ( <int> , new int [ ] { <int> , <int> } , new int [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) , mapper . getOffset ( <int> , new int [ ] { <int> , <int> } , new int [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; long oldImplTotal = <int> ; long newImplTotal = <int> ; int [ ] timingShape = { <int> , <int> , <int> , <int> } ; int [ ] timingStride = { <int> , <int> , <int> , <int> } ; int [ ] timingIndex = { <int> , <int> , <int> , <int> } ; for ( int i = <int> ; i < <int> ; i + + ) { long old = System . nanoTime ( ) ; verifyImpl ( <int> , timingShape , timingStride , timingIndex ) ; long newTime = System . nanoTime ( ) ; long delta = Math . abs ( newTime - old ) ; long oldDelta = delta ; oldImplTotal + = delta ; old = System . nanoTime ( ) ; mapper . getOffset ( <int> , timingShape , timingStride , timingIndex ) ; newTime = System . nanoTime ( ) ; delta = Math . abs ( newTime - old ) ; newImplTotal + = delta ; System . out . println ( <str> + oldDelta + <str> + delta + <str> + i ) ; } oldImplTotal / = <int> ; newImplTotal / = <int> ; System . out . println ( <str> + oldImplTotal + <str> + newImplTotal + <str> ) ; } private int verifyImpl ( int baseOffset , int [ ] shape , int [ ] stride , int [ ] indices ) { int offset = <int> ; for ( int i = <int> ; i < indices . length ; i + + ) { if ( shape [ i ] = = <int> ) continue ; offset + = indices [ i ] * stride [ i ] ; } return offset + baseOffset ; } }