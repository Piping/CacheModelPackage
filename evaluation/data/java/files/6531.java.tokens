package org . apache . cassandra . db . compaction ; import java . util . Collection ; import java . util . concurrent . ExecutionException ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . CachingParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . * ; import static org . apache . cassandra . Util . dk ; public class CompactionsPurgeTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private static final String CF_STANDARD2 = <str> ; private static final String KEYSPACE2 = <str> ; private static final String KEYSPACE_CACHED = <str> ; private static final String CF_CACHED = <str> ; private static final String KEYSPACE_CQL = <str> ; private static final String CF_CQL = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE2 , CF_STANDARD1 ) ) ; SchemaLoader . createKeyspace ( KEYSPACE_CACHED , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHED , CF_CACHED ) . caching ( CachingParams . CACHE_EVERYTHING ) ) ; SchemaLoader . createKeyspace ( KEYSPACE_CQL , KeyspaceParams . simple ( <int> ) , CFMetaData . compile ( <str> + CF_CQL + <str> + <str> + <str> + <str> + <str> , KEYSPACE_CQL ) ) ; } @Test public void testMajorCompactionPurge ( ) { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; String cfName = <str> ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; String key = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , key , String . valueOf ( i ) ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , key ) ; builder . clustering ( String . valueOf ( <int> ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; FBUtilities . waitOnFutures ( CompactionManager . instance . submitMaximal ( cfs , Integer . MAX_VALUE , false ) ) ; cfs . invalidateCachedPartition ( dk ( key ) ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; assertEquals ( <int> , partition . rowCount ( ) ) ; } @Test public void testMinorCompactionPurge ( ) { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE2 ) ; String cfName = <str> ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; for ( int k = <int> ; k < = <int> ; + + k ) { String key = <str> + k ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , key , String . valueOf ( i ) ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } DecoratedKey key1 = Util . dk ( <str> ) ; DecoratedKey key2 = Util . dk ( <str> ) ; cfs . forceBlockingFlush ( ) ; Collection < SSTableReader > sstablesIncomplete = cfs . getLiveSSTables ( ) ; RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) ; builder . clustering ( String . valueOf ( <int> ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; cfs . getCompactionStrategyManager ( ) . getUserDefinedTask ( sstablesIncomplete , Integer . MAX_VALUE ) . execute ( null ) ; Util . assertEmpty ( Util . cmd ( cfs , key2 ) . build ( ) ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key1 ) . build ( ) ) ; assertEquals ( <int> , partition . rowCount ( ) ) ; } @Test public void testMinTimestampPurge ( ) { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE2 ) ; String cfName = <str> ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; String key3 = <str> ; new RowUpdateBuilder ( cfs . metadata , <int> , key3 ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key3 ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , key3 , <str> ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Collection < SSTableReader > sstablesIncomplete = cfs . getLiveSSTables ( ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , key3 , <str> ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; cfs . getCompactionStrategyManager ( ) . getUserDefinedTask ( sstablesIncomplete , Integer . MAX_VALUE ) . execute ( null ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key3 ) . build ( ) ) ; assertEquals ( <int> , partition . rowCount ( ) ) ; for ( Row row : partition ) assertFalse ( row . hasLiveData ( FBUtilities . nowInSeconds ( ) ) ) ; } @Test public void testCompactionPurgeOneFile ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; String cfName = <str> ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; String key = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , key , String . valueOf ( i ) ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; assertEquals ( String . valueOf ( cfs . getLiveSSTables ( ) ) , <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; Util . compactAll ( cfs , Integer . MAX_VALUE ) . get ( ) ; assertTrue ( cfs . getLiveSSTables ( ) . isEmpty ( ) ) ; Util . assertEmpty ( Util . cmd ( cfs , key ) . build ( ) ) ; } @Test public void testCompactionPurgeCachedRow ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; String keyspaceName = KEYSPACE_CACHED ; String cfName = CF_CACHED ; Keyspace keyspace = Keyspace . open ( keyspaceName ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; String key = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } Mutation rm = new Mutation ( KEYSPACE_CACHED , dk ( key ) ) ; rm . add ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , dk ( key ) , <int> , FBUtilities . nowInSeconds ( ) ) ) ; rm . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; assertFalse ( Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) . isEmpty ( ) ) ; cfs . forceBlockingFlush ( ) ; Util . compactAll ( cfs , Integer . MAX_VALUE ) . get ( ) ; Util . assertEmpty ( Util . cmd ( cfs , key ) . build ( ) ) ; } @Test public void testCompactionPurgeTombstonedRow ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; String keyspaceName = KEYSPACE1 ; String cfName = <str> ; Keyspace keyspace = Keyspace . open ( keyspaceName ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; String key = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , i , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } Mutation rm = new Mutation ( KEYSPACE1 , dk ( key ) ) ; rm . add ( PartitionUpdate . fullPartitionDelete ( cfs . metadata , dk ( key ) , <int> , FBUtilities . nowInSeconds ( ) ) ) ; rm . applyUnsafe ( ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; assertFalse ( partition . partitionLevelDeletion ( ) . isLive ( ) ) ; cfs . forceBlockingFlush ( ) ; Util . compactAll ( cfs , Integer . MAX_VALUE ) . get ( ) ; assertFalse ( Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) . isEmpty ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , i , key ) ; builder . clustering ( String . valueOf ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; assertEquals ( <int> , partition . rowCount ( ) ) ; } @Test public void testRowTombstoneObservedBeforePurging ( ) { String keyspace = <str> ; String table = <str> ; ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( table ) ; cfs . disableAutoCompaction ( ) ; QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> , <str> , <int> ) ) ; cfs . forceBlockingFlush ( ) ; UntypedResultSet result = QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; assertEquals ( <int> , result . size ( ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; result = QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; assertEquals ( <int> , result . size ( ) ) ; FBUtilities . waitOnFutures ( CompactionManager . instance . submitMaximal ( cfs , ( int ) ( System . currentTimeMillis ( ) / <int> ) - <int> , false ) ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; result = QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; assertEquals ( <int> , result . size ( ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> , <str> , <int> ) ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; result = QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; assertEquals ( <int> , result . size ( ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; cfs . forceBlockingFlush ( ) ; FBUtilities . waitOnFutures ( CompactionManager . instance . submitMaximal ( cfs , ( int ) ( System . currentTimeMillis ( ) / <int> ) + <int> , false ) ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; result = QueryProcessor . executeInternal ( String . format ( <str> , keyspace , table , <int> ) ) ; assertEquals ( <int> , result . size ( ) ) ; } }