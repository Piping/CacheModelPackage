package org . eclipse . debug . core . sourcelookup . containers ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . sourcelookup . ISourceContainerType ; import org . eclipse . debug . internal . core . sourcelookup . SourceLookupMessages ; import org . eclipse . debug . internal . core . sourcelookup . SourceLookupUtils ; import com . ibm . icu . text . MessageFormat ; public class ExternalArchiveSourceContainer extends AbstractSourceContainer { private boolean fDetectRoots = false ; private Set < String > fPotentialRoots = null ; private List < String > fRoots = new ArrayList < String > ( ) ; private String fArchivePath = null ; public static final String TYPE_ID = DebugPlugin . getUniqueIdentifier ( ) + <str> ; public ExternalArchiveSourceContainer ( String archivePath , boolean detectRootPaths ) { fArchivePath = archivePath ; fDetectRoots = detectRootPaths ; } @Override public Object [ ] findSourceElements ( String name ) throws CoreException { String newname = name . replace ( <str> , <str> ) ; ZipFile file = getArchive ( ) ; synchronized ( file ) { boolean isQualfied = newname . indexOf ( <str> ) > <int> ; if ( fDetectRoots & & isQualfied ) { ZipEntry entry = searchRoots ( file , newname ) ; if ( entry ! = null ) { return new Object [ ] { new ZipEntryStorage ( file , entry ) } ; } } else { ZipEntry entry = null ; try { entry = file . getEntry ( newname ) ; } catch ( IllegalStateException e ) { throw new CoreException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , e . getMessage ( ) , e ) ) ; } if ( entry ! = null ) { return new Object [ ] { new ZipEntryStorage ( file , entry ) } ; } Enumeration < ? extends ZipEntry > entries = file . entries ( ) ; List < ZipEntryStorage > matches = null ; while ( entries . hasMoreElements ( ) ) { entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . endsWith ( newname ) ) { if ( isQualfied | | entryName . length ( ) = = newname . length ( ) | | entryName . charAt ( entryName . length ( ) - newname . length ( ) - <int> ) = = <str> ) { if ( isFindDuplicates ( ) ) { if ( matches = = null ) { matches = new ArrayList < ZipEntryStorage > ( ) ; } matches . add ( new ZipEntryStorage ( file , entry ) ) ; } else { return new Object [ ] { new ZipEntryStorage ( file , entry ) } ; } } } } if ( matches ! = null ) { return matches . toArray ( ) ; } } } return EMPTY ; } private ZipEntry searchRoots ( ZipFile file , String name ) throws CoreException { if ( fPotentialRoots = = null ) { fPotentialRoots = new HashSet < String > ( ) ; fPotentialRoots . add ( <str> ) ; try { Enumeration < ? extends ZipEntry > entries = file . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; if ( entry . isDirectory ( ) ) { fPotentialRoots . add ( entry . getName ( ) ) ; } else { String entryName = entry . getName ( ) ; int index = entryName . lastIndexOf ( <str> ) ; while ( index > <int> ) { if ( fPotentialRoots . add ( entryName . substring ( <int> , index + <int> ) ) ) { entryName = entryName . substring ( <int> , index ) ; index = entryName . lastIndexOf ( <str> ) ; } else { break ; } } } } } catch ( IllegalStateException e ) { throw new CoreException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , e . getMessage ( ) , e ) ) ; } } int i = <int> ; while ( i < fRoots . size ( ) ) { String root = fRoots . get ( i ) ; ZipEntry entry = file . getEntry ( root + name ) ; if ( entry ! = null ) { return entry ; } i + + ; } if ( ! fPotentialRoots . isEmpty ( ) ) { for ( String root : fPotentialRoots ) { ZipEntry entry = file . getEntry ( root + name ) ; if ( entry ! = null ) { if ( root ! = null ) { fRoots . add ( root ) ; fPotentialRoots . remove ( root ) ; Iterator < String > rs = fPotentialRoots . iterator ( ) ; while ( rs . hasNext ( ) ) { String r = rs . next ( ) ; if ( r . startsWith ( root ) ) { rs . remove ( ) ; } } } return entry ; } } } return null ; } private ZipFile getArchive ( ) throws CoreException { try { return SourceLookupUtils . getZipFile ( fArchivePath ) ; } catch ( IOException e ) { File file = new File ( fArchivePath ) ; if ( file . exists ( ) ) { abort ( MessageFormat . format ( SourceLookupMessages . ExternalArchiveSourceContainer_2 , new Object [ ] { fArchivePath } ) , e ) ; } else { warn ( MessageFormat . format ( SourceLookupMessages . ExternalArchiveSourceContainer_1 , new Object [ ] { fArchivePath } ) , e ) ; } } return null ; } @Override public String getName ( ) { return fArchivePath ; } @Override public ISourceContainerType getType ( ) { return getSourceContainerType ( TYPE_ID ) ; } public boolean isDetectRoot ( ) { return fDetectRoots ; } @Override public boolean equals ( Object obj ) { return obj instanceof ExternalArchiveSourceContainer & & ( ( ExternalArchiveSourceContainer ) obj ) . getName ( ) . equals ( getName ( ) ) ; } @Override public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } @Override public void dispose ( ) { super . dispose ( ) ; if ( fPotentialRoots ! = null ) { fPotentialRoots . clear ( ) ; } fRoots . clear ( ) ; } } 
