package org . apache . cassandra . streaming ; import java . io . IOException ; import java . net . InetAddress ; import java . net . Socket ; import java . util . * ; import java . util . concurrent . ConcurrentLinkedQueue ; import com . google . common . util . concurrent . AbstractFuture ; import com . google . common . util . concurrent . Futures ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public final class StreamResultFuture extends AbstractFuture < StreamState > { private static final Logger logger = LoggerFactory . getLogger ( StreamResultFuture . class ) ; public final UUID planId ; public final String description ; private final StreamCoordinator coordinator ; private final Collection < StreamEventHandler > eventListeners = new ConcurrentLinkedQueue < > ( ) ; private StreamResultFuture ( UUID planId , String description , StreamCoordinator coordinator ) { this . planId = planId ; this . description = description ; this . coordinator = coordinator ; if ( ! coordinator . isReceiving ( ) & & ! coordinator . hasActiveSessions ( ) ) set ( getCurrentState ( ) ) ; } private StreamResultFuture ( UUID planId , String description , boolean keepSSTableLevels , boolean isIncremental ) { this ( planId , description , new StreamCoordinator ( <int> , keepSSTableLevels , isIncremental , new DefaultConnectionFactory ( ) ) ) ; } static StreamResultFuture init ( UUID planId , String description , Collection < StreamEventHandler > listeners , StreamCoordinator coordinator ) { StreamResultFuture future = createAndRegister ( planId , description , coordinator ) ; if ( listeners ! = null ) { for ( StreamEventHandler listener : listeners ) future . addEventListener ( listener ) ; } logger . info ( <str> , planId , description ) ; for ( final StreamSession session : coordinator . getAllStreamSessions ( ) ) { session . init ( future ) ; } coordinator . connectAllStreamSessions ( ) ; return future ; } public static synchronized StreamResultFuture initReceivingSide ( int sessionIndex , UUID planId , String description , InetAddress from , Socket socket , boolean isForOutgoing , int version , boolean keepSSTableLevel , boolean isIncremental ) throws IOException { StreamResultFuture future = StreamManager . instance . getReceivingStream ( planId ) ; if ( future = = null ) { logger . info ( <str> , planId , sessionIndex , description ) ; future = new StreamResultFuture ( planId , description , keepSSTableLevel , isIncremental ) ; StreamManager . instance . registerReceiving ( future ) ; } future . attachSocket ( from , sessionIndex , socket , isForOutgoing , version ) ; logger . info ( <str> , planId , sessionIndex , description ) ; return future ; } private static StreamResultFuture createAndRegister ( UUID planId , String description , StreamCoordinator coordinator ) { StreamResultFuture future = new StreamResultFuture ( planId , description , coordinator ) ; StreamManager . instance . register ( future ) ; return future ; } private void attachSocket ( InetAddress from , int sessionIndex , Socket socket , boolean isForOutgoing , int version ) throws IOException { StreamSession session = coordinator . getOrCreateSessionById ( from , sessionIndex , socket . getInetAddress ( ) ) ; session . init ( this ) ; session . handler . initiateOnReceivingSide ( socket , isForOutgoing , version ) ; } public void addEventListener ( StreamEventHandler listener ) { Futures . addCallback ( this , listener ) ; eventListeners . add ( listener ) ; } public StreamState getCurrentState ( ) { return new StreamState ( planId , description , coordinator . getAllSessionInfo ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; StreamResultFuture that = ( StreamResultFuture ) o ; return planId . equals ( that . planId ) ; } @Override public int hashCode ( ) { return planId . hashCode ( ) ; } void handleSessionPrepared ( StreamSession session ) { SessionInfo sessionInfo = session . getSessionInfo ( ) ; logger . info ( <str> , session . planId ( ) , session . sessionIndex ( ) , sessionInfo . getTotalFilesToReceive ( ) , sessionInfo . getTotalSizeToReceive ( ) , sessionInfo . getTotalFilesToSend ( ) , sessionInfo . getTotalSizeToSend ( ) ) ; StreamEvent . SessionPreparedEvent event = new StreamEvent . SessionPreparedEvent ( planId , sessionInfo ) ; coordinator . addSessionInfo ( sessionInfo ) ; fireStreamEvent ( event ) ; } void handleSessionComplete ( StreamSession session ) { logger . info ( <str> , session . planId ( ) , session . peer ) ; fireStreamEvent ( new StreamEvent . SessionCompleteEvent ( session ) ) ; SessionInfo sessionInfo = session . getSessionInfo ( ) ; coordinator . addSessionInfo ( sessionInfo ) ; maybeComplete ( ) ; } public void handleProgress ( ProgressInfo progress ) { coordinator . updateProgress ( progress ) ; fireStreamEvent ( new StreamEvent . ProgressEvent ( planId , progress ) ) ; } synchronized void fireStreamEvent ( StreamEvent event ) { for ( StreamEventHandler listener : eventListeners ) listener . handleStreamEvent ( event ) ; } private synchronized void maybeComplete ( ) { if ( ! coordinator . hasActiveSessions ( ) ) { StreamState finalState = getCurrentState ( ) ; if ( finalState . hasFailedSession ( ) ) { logger . warn ( <str> , planId ) ; setException ( new StreamException ( finalState , <str> ) ) ; } else { logger . info ( <str> , planId ) ; set ( finalState ) ; } } } }