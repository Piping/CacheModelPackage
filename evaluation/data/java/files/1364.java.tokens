package io . netty . channel . udt . nio ; import com . barchart . udt . TypeUDT ; import com . barchart . udt . nio . SocketChannelUDT ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . nio . AbstractNioMessageChannel ; import io . netty . channel . udt . DefaultUdtChannelConfig ; import io . netty . channel . udt . UdtChannel ; import io . netty . channel . udt . UdtChannelConfig ; import io . netty . channel . udt . UdtMessage ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . List ; import static java . nio . channels . SelectionKey . * ; public class NioUdtMessageConnectorChannel extends AbstractNioMessageChannel implements UdtChannel { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( NioUdtMessageConnectorChannel . class ) ; private static final ChannelMetadata METADATA = new ChannelMetadata ( false ) ; private final UdtChannelConfig config ; public NioUdtMessageConnectorChannel ( ) { this ( TypeUDT . DATAGRAM ) ; } public NioUdtMessageConnectorChannel ( final Channel parent , final SocketChannelUDT channelUDT ) { super ( parent , channelUDT , OP_READ ) ; try { channelUDT . configureBlocking ( false ) ; switch ( channelUDT . socketUDT ( ) . status ( ) ) { case INIT : case OPENED : config = new DefaultUdtChannelConfig ( this , channelUDT , true ) ; break ; default : config = new DefaultUdtChannelConfig ( this , channelUDT , false ) ; break ; } } catch ( final Exception e ) { try { channelUDT . close ( ) ; } catch ( final Exception e2 ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , e2 ) ; } } throw new ChannelException ( <str> , e ) ; } } public NioUdtMessageConnectorChannel ( final SocketChannelUDT channelUDT ) { this ( null , channelUDT ) ; } public NioUdtMessageConnectorChannel ( final TypeUDT type ) { this ( NioUdtProvider . newConnectorChannelUDT ( type ) ) ; } @Override public UdtChannelConfig config ( ) { return config ; } @Override protected void doBind ( final SocketAddress localAddress ) throws Exception { javaChannel ( ) . bind ( localAddress ) ; } @Override protected void doClose ( ) throws Exception { javaChannel ( ) . close ( ) ; } @Override protected boolean doConnect ( final SocketAddress remoteAddress , final SocketAddress localAddress ) throws Exception { doBind ( localAddress ! = null ? localAddress : new InetSocketAddress ( <int> ) ) ; boolean success = false ; try { final boolean connected = javaChannel ( ) . connect ( remoteAddress ) ; if ( ! connected ) { selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) | OP_CONNECT ) ; } success = true ; return connected ; } finally { if ( ! success ) { doClose ( ) ; } } } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected void doFinishConnect ( ) throws Exception { if ( javaChannel ( ) . finishConnect ( ) ) { selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) & ~ OP_CONNECT ) ; } else { throw new Error ( <str> ) ; } } @Override protected int doReadMessages ( List < Object > buf ) throws Exception { final int maximumMessageSize = config . getReceiveBufferSize ( ) ; final ByteBuf byteBuf = config . getAllocator ( ) . directBuffer ( maximumMessageSize ) ; final int receivedMessageSize = byteBuf . writeBytes ( javaChannel ( ) , maximumMessageSize ) ; if ( receivedMessageSize < = <int> ) { byteBuf . release ( ) ; return <int> ; } if ( receivedMessageSize > = maximumMessageSize ) { javaChannel ( ) . close ( ) ; throw new ChannelException ( <str> ) ; } buf . add ( new UdtMessage ( byteBuf ) ) ; return <int> ; } @Override protected boolean doWriteMessage ( Object msg , ChannelOutboundBuffer in ) throws Exception { final UdtMessage message = ( UdtMessage ) msg ; final ByteBuf byteBuf = message . content ( ) ; final int messageSize = byteBuf . readableBytes ( ) ; if ( messageSize = = <int> ) { return true ; } final long writtenBytes ; if ( byteBuf . nioBufferCount ( ) = = <int> ) { writtenBytes = javaChannel ( ) . write ( byteBuf . nioBuffer ( ) ) ; } else { writtenBytes = javaChannel ( ) . write ( byteBuf . nioBuffers ( ) ) ; } if ( writtenBytes > <int> & & writtenBytes ! = messageSize ) { throw new Error ( <str> ) ; } return writtenBytes > <int> ; } @Override public boolean isActive ( ) { final SocketChannelUDT channelUDT = javaChannel ( ) ; return channelUDT . isOpen ( ) & & channelUDT . isConnectFinished ( ) ; } @Override protected SocketChannelUDT javaChannel ( ) { return ( SocketChannelUDT ) super . javaChannel ( ) ; } @Override protected SocketAddress localAddress0 ( ) { return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override protected SocketAddress remoteAddress0 ( ) { return javaChannel ( ) . socket ( ) . getRemoteSocketAddress ( ) ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } } 
