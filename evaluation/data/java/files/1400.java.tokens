package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . MockTokenizer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . ngram . * ; import org . apache . lucene . analysis . reverse . ReverseStringFilter ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . Settings . Builder ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . test . ESTokenStreamTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import java . io . IOException ; import java . io . StringReader ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Random ; import static com . carrotsearch . randomizedtesting . RandomizedTest . scaledRandomIntBetween ; import static org . hamcrest . Matchers . instanceOf ; public class NGramTokenizerFactoryTests extends ESTokenStreamTestCase { public void testParseTokenChars ( ) { final Index index = new Index ( <str> ) ; final String name = <str> ; final Settings indexSettings = newAnalysisSettingsBuilder ( ) . build ( ) ; IndexSettings indexProperties = IndexSettingsModule . newIndexSettings ( index , indexSettings ) ; for ( String tokenChars : Arrays . asList ( <str> , <str> , <str> ) ) { final Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , tokenChars ) . build ( ) ; try { new NGramTokenizerFactory ( indexProperties , null , name , settings ) . create ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } for ( String tokenChars : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { final Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , tokenChars ) . build ( ) ; indexProperties = IndexSettingsModule . newIndexSettings ( index , indexSettings ) ; new NGramTokenizerFactory ( indexProperties , null , name , settings ) . create ( ) ; } } public void testNoTokenChars ( ) throws IOException { final Index index = new Index ( <str> ) ; final String name = <str> ; final Settings indexSettings = newAnalysisSettingsBuilder ( ) . build ( ) ; final Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . putArray ( <str> , new String [ <int> ] ) . build ( ) ; Tokenizer tokenizer = new NGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; assertTokenStreamContents ( tokenizer , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ) ; } public void testPreTokenization ( ) throws IOException { final Index index = new Index ( <str> ) ; final String name = <str> ; final Settings indexSettings = newAnalysisSettingsBuilder ( ) . build ( ) ; Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; Tokenizer tokenizer = new NGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; assertTokenStreamContents ( tokenizer , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; tokenizer = new NGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; assertTokenStreamContents ( tokenizer , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; } public void testPreTokenizationEdge ( ) throws IOException { final Index index = new Index ( <str> ) ; final String name = <str> ; final Settings indexSettings = newAnalysisSettingsBuilder ( ) . build ( ) ; Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; Tokenizer tokenizer = new EdgeNGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; assertTokenStreamContents ( tokenizer , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ) ; settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; tokenizer = new EdgeNGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; assertTokenStreamContents ( tokenizer , new String [ ] { <str> , <str> } ) ; } public void testBackwardsCompatibilityEdgeNgramTokenizer ( ) throws Exception { int iters = scaledRandomIntBetween ( <int> , <int> ) ; final Index index = new Index ( <str> ) ; final String name = <str> ; for ( int i = <int> ; i < iters ; i + + ) { Version v = randomVersion ( random ( ) ) ; if ( v . onOrAfter ( Version . V_0_90_2 ) ) { Builder builder = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) ; boolean compatVersion = false ; if ( ( compatVersion = random ( ) . nextBoolean ( ) ) ) { builder . put ( <str> , <str> + random ( ) . nextInt ( <int> ) ) ; builder . put ( <str> , <str> ) ; } Settings settings = builder . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer edgeNGramTokenizer = new EdgeNGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; edgeNGramTokenizer . setReader ( new StringReader ( <str> ) ) ; if ( compatVersion ) { assertThat ( edgeNGramTokenizer , instanceOf ( Lucene43EdgeNGramTokenizer . class ) ) ; } else { assertThat ( edgeNGramTokenizer , instanceOf ( EdgeNGramTokenizer . class ) ) ; } } else { Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer edgeNGramTokenizer = new EdgeNGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; edgeNGramTokenizer . setReader ( new StringReader ( <str> ) ) ; assertThat ( edgeNGramTokenizer , instanceOf ( Lucene43EdgeNGramTokenizer . class ) ) ; } } Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; try { new EdgeNGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } public void testBackwardsCompatibilityNgramTokenizer ( ) throws Exception { int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { final Index index = new Index ( <str> ) ; final String name = <str> ; Version v = randomVersion ( random ( ) ) ; if ( v . onOrAfter ( Version . V_0_90_2 ) ) { Builder builder = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) ; boolean compatVersion = false ; if ( ( compatVersion = random ( ) . nextBoolean ( ) ) ) { builder . put ( <str> , <str> + random ( ) . nextInt ( <int> ) ) ; } Settings settings = builder . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer nGramTokenizer = new NGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; nGramTokenizer . setReader ( new StringReader ( <str> ) ) ; if ( compatVersion ) { assertThat ( nGramTokenizer , instanceOf ( Lucene43NGramTokenizer . class ) ) ; } else { assertThat ( nGramTokenizer , instanceOf ( NGramTokenizer . class ) ) ; } } else { Settings settings = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer nGramTokenizer = new NGramTokenizerFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( ) ; nGramTokenizer . setReader ( new StringReader ( <str> ) ) ; assertThat ( nGramTokenizer , instanceOf ( Lucene43NGramTokenizer . class ) ) ; } } } public void testBackwardsCompatibilityEdgeNgramTokenFilter ( ) throws Exception { int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { final Index index = new Index ( <str> ) ; final String name = <str> ; Version v = randomVersion ( random ( ) ) ; if ( v . onOrAfter ( Version . V_0_90_2 ) ) { Builder builder = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; boolean compatVersion = false ; if ( ( compatVersion = random ( ) . nextBoolean ( ) ) ) { builder . put ( <str> , <str> + random ( ) . nextInt ( <int> ) ) ; } boolean reverse = random ( ) . nextBoolean ( ) ; if ( reverse ) { builder . put ( <str> , <str> ) ; } Settings settings = builder . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer tokenizer = new MockTokenizer ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; TokenStream edgeNGramTokenFilter = new EdgeNGramTokenFilterFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( tokenizer ) ; if ( reverse ) { assertThat ( edgeNGramTokenFilter , instanceOf ( ReverseStringFilter . class ) ) ; } else if ( compatVersion ) { assertThat ( edgeNGramTokenFilter , instanceOf ( Lucene43EdgeNGramTokenFilter . class ) ) ; } else { assertThat ( edgeNGramTokenFilter , instanceOf ( EdgeNGramTokenFilter . class ) ) ; } } else { Builder builder = newAnalysisSettingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; boolean reverse = random ( ) . nextBoolean ( ) ; if ( reverse ) { builder . put ( <str> , <str> ) ; } Settings settings = builder . build ( ) ; Settings indexSettings = newAnalysisSettingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , v . id ) . build ( ) ; Tokenizer tokenizer = new MockTokenizer ( ) ; tokenizer . setReader ( new StringReader ( <str> ) ) ; TokenStream edgeNGramTokenFilter = new EdgeNGramTokenFilterFactory ( IndexSettingsModule . newIndexSettings ( index , indexSettings ) , null , name , settings ) . create ( tokenizer ) ; if ( reverse ) { assertThat ( edgeNGramTokenFilter , instanceOf ( ReverseStringFilter . class ) ) ; } else { assertThat ( edgeNGramTokenFilter , instanceOf ( Lucene43EdgeNGramTokenFilter . class ) ) ; } } } } private Version randomVersion ( Random random ) throws IllegalArgumentException , IllegalAccessException { Field [ ] declaredFields = Version . class . getFields ( ) ; List < Field > versionFields = new ArrayList < > ( ) ; for ( Field field : declaredFields ) { if ( ( field . getModifiers ( ) & Modifier . STATIC ) ! = <int> & & field . getName ( ) . startsWith ( <str> ) & & field . getType ( ) = = Version . class ) { versionFields . add ( field ) ; } } return ( Version ) versionFields . get ( random . nextInt ( versionFields . size ( ) ) ) . get ( Version . class ) ; } } 
