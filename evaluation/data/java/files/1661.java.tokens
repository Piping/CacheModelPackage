package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import com . google . caliper . AfterExperiment ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . api . Footprint ; import com . google . caliper . api . VmOptions ; import com . google . common . base . Preconditions ; import com . google . common . collect . Lists ; import com . google . common . util . concurrent . AbstractFutureBenchmarks . OldAbstractFuture ; import java . util . Queue ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . Nullable ; import javax . annotation . concurrent . GuardedBy ; @VmOptions ( { <str> , <str> } ) public class ExecutionListBenchmark { private static final int NUM_THREADS = <int> ; interface ExecutionListWrapper { void add ( Runnable runnable , Executor executor ) ; void execute ( ) ; Object getImpl ( ) ; } enum Impl { NEW { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final ExecutionList list = new ExecutionList ( ) ; @Override public void add ( Runnable runnable , Executor executor ) { list . add ( runnable , executor ) ; } @Override public void execute ( ) { list . execute ( ) ; } @Override public Object getImpl ( ) { return list ; } } ; } } , NEW_WITH_CAS { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final ExecutionListCAS list = new ExecutionListCAS ( ) ; @Override public void add ( Runnable runnable , Executor executor ) { list . add ( runnable , executor ) ; } @Override public void execute ( ) { list . execute ( ) ; } @Override public Object getImpl ( ) { return list ; } } ; } } , NEW_WITH_QUEUE { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final NewExecutionListQueue list = new NewExecutionListQueue ( ) ; @Override public void add ( Runnable runnable , Executor executor ) { list . add ( runnable , executor ) ; } @Override public void execute ( ) { list . execute ( ) ; } @Override public Object getImpl ( ) { return list ; } } ; } } , NEW_WITHOUT_REVERSE { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final NewExecutionListWithoutReverse list = new NewExecutionListWithoutReverse ( ) ; @Override public void add ( Runnable runnable , Executor executor ) { list . add ( runnable , executor ) ; } @Override public void execute ( ) { list . execute ( ) ; } @Override public Object getImpl ( ) { return list ; } } ; } } , OLD { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final OldExecutionList list = new OldExecutionList ( ) ; @Override public void add ( Runnable runnable , Executor executor ) { list . add ( runnable , executor ) ; } @Override public void execute ( ) { list . execute ( ) ; } @Override public Object getImpl ( ) { return list ; } } ; } } , ABSTRACT_FUTURE { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final AbstractFuture < ? > future = new AbstractFuture < Object > ( ) { } ; @Override public void add ( Runnable runnable , Executor executor ) { future . addListener ( runnable , executor ) ; } @Override public void execute ( ) { future . set ( null ) ; } @Override public Object getImpl ( ) { return future ; } } ; } } , OLD_ABSTRACT_FUTURE { @Override ExecutionListWrapper newExecutionList ( ) { return new ExecutionListWrapper ( ) { final OldAbstractFuture < Object > future = new OldAbstractFuture < Object > ( ) { } ; @Override public void add ( Runnable runnable , Executor executor ) { future . addListener ( runnable , executor ) ; } @Override public void execute ( ) { future . set ( null ) ; } @Override public Object getImpl ( ) { return future ; } } ; } } ; abstract ExecutionListWrapper newExecutionList ( ) ; } private ThreadPoolExecutor executorService ; private CountDownLatch listenerLatch ; private ExecutionListWrapper list ; @Param Impl impl ; @Param ( { <str> , <str> , <str> } ) int numListeners ; private final Runnable listener = new Runnable ( ) { @Override public void run ( ) { listenerLatch . countDown ( ) ; } } ; @BeforeExperiment void setUp ( ) throws Exception { executorService = new ThreadPoolExecutor ( NUM_THREADS , NUM_THREADS , Long . MAX_VALUE , TimeUnit . SECONDS , new ArrayBlockingQueue < Runnable > ( <int> ) ) ; executorService . prestartAllCoreThreads ( ) ; final AtomicInteger integer = new AtomicInteger ( ) ; for ( int i = <int> ; i < NUM_THREADS * <int> ; i + + ) { executorService . submit ( new Runnable ( ) { @Override public void run ( ) { integer . getAndIncrement ( ) ; } } ) ; } } @AfterExperiment void tearDown ( ) throws Exception { executorService . shutdown ( ) ; } @Footprint ( exclude = { Runnable . class , Executor . class } ) public Object measureSize ( ) { list = impl . newExecutionList ( ) ; for ( int i = <int> ; i < numListeners ; i + + ) { list . add ( listener , directExecutor ( ) ) ; } return list . getImpl ( ) ; } @Benchmark int addThenExecute_singleThreaded ( int reps ) { int returnValue = <int> ; for ( int i = <int> ; i < reps ; i + + ) { list = impl . newExecutionList ( ) ; listenerLatch = new CountDownLatch ( numListeners ) ; for ( int j = <int> ; j < numListeners ; j + + ) { list . add ( listener , directExecutor ( ) ) ; returnValue + = listenerLatch . getCount ( ) ; } list . execute ( ) ; returnValue + = listenerLatch . getCount ( ) ; } return returnValue ; } @Benchmark int executeThenAdd_singleThreaded ( int reps ) { int returnValue = <int> ; for ( int i = <int> ; i < reps ; i + + ) { list = impl . newExecutionList ( ) ; list . execute ( ) ; listenerLatch = new CountDownLatch ( numListeners ) ; for ( int j = <int> ; j < numListeners ; j + + ) { list . add ( listener , directExecutor ( ) ) ; returnValue + = listenerLatch . getCount ( ) ; } returnValue + = listenerLatch . getCount ( ) ; } return returnValue ; } private final Runnable executeTask = new Runnable ( ) { @Override public void run ( ) { list . execute ( ) ; } } ; @Benchmark int addThenExecute_multiThreaded ( final int reps ) throws InterruptedException { Runnable addTask = new Runnable ( ) { @Override public void run ( ) { for ( int i = <int> ; i < numListeners ; i + + ) { list . add ( listener , directExecutor ( ) ) ; } } } ; int returnValue = <int> ; for ( int i = <int> ; i < reps ; i + + ) { list = impl . newExecutionList ( ) ; listenerLatch = new CountDownLatch ( numListeners * NUM_THREADS ) ; for ( int j = <int> ; j < NUM_THREADS ; j + + ) { executorService . submit ( addTask ) ; } executorService . submit ( executeTask ) ; returnValue + = ( int ) listenerLatch . getCount ( ) ; listenerLatch . await ( ) ; } return returnValue ; } @Benchmark int executeThenAdd_multiThreaded ( final int reps ) throws InterruptedException { Runnable addTask = new Runnable ( ) { @Override public void run ( ) { for ( int i = <int> ; i < numListeners ; i + + ) { list . add ( listener , directExecutor ( ) ) ; } } } ; int returnValue = <int> ; for ( int i = <int> ; i < reps ; i + + ) { list = impl . newExecutionList ( ) ; listenerLatch = new CountDownLatch ( numListeners * NUM_THREADS ) ; executorService . submit ( executeTask ) ; for ( int j = <int> ; j < NUM_THREADS ; j + + ) { executorService . submit ( addTask ) ; } returnValue + = ( int ) listenerLatch . getCount ( ) ; listenerLatch . await ( ) ; } return returnValue ; } private static final class OldExecutionList { static final Logger log = Logger . getLogger ( OldExecutionList . class . getName ( ) ) ; final Queue < OldExecutionList . RunnableExecutorPair > runnables = Lists . newLinkedList ( ) ; boolean executed = false ; public void add ( Runnable runnable , Executor executor ) { Preconditions . checkNotNull ( runnable , <str> ) ; Preconditions . checkNotNull ( executor , <str> ) ; boolean executeImmediate = false ; synchronized ( runnables ) { if ( ! executed ) { runnables . add ( new RunnableExecutorPair ( runnable , executor ) ) ; } else { executeImmediate = true ; } } if ( executeImmediate ) { new RunnableExecutorPair ( runnable , executor ) . execute ( ) ; } } public void execute ( ) { synchronized ( runnables ) { if ( executed ) { return ; } executed = true ; } while ( ! runnables . isEmpty ( ) ) { runnables . poll ( ) . execute ( ) ; } } private static class RunnableExecutorPair { final Runnable runnable ; final Executor executor ; RunnableExecutorPair ( Runnable runnable , Executor executor ) { this . runnable = runnable ; this . executor = executor ; } void execute ( ) { try { executor . execute ( runnable ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + runnable + <str> + executor , e ) ; } } } } private static final class NewExecutionListWithoutReverse { static final Logger log = Logger . getLogger ( NewExecutionListWithoutReverse . class . getName ( ) ) ; @GuardedBy ( <str> ) private RunnableExecutorPair runnables ; @GuardedBy ( <str> ) private boolean executed ; public void add ( Runnable runnable , Executor executor ) { Preconditions . checkNotNull ( runnable , <str> ) ; Preconditions . checkNotNull ( executor , <str> ) ; synchronized ( this ) { if ( ! executed ) { runnables = new RunnableExecutorPair ( runnable , executor , runnables ) ; return ; } } executeListener ( runnable , executor ) ; } public void execute ( ) { RunnableExecutorPair list ; synchronized ( this ) { if ( executed ) { return ; } executed = true ; list = runnables ; runnables = null ; } while ( list ! = null ) { executeListener ( list . runnable , list . executor ) ; list = list . next ; } } private static void executeListener ( Runnable runnable , Executor executor ) { try { executor . execute ( runnable ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + runnable + <str> + executor , e ) ; } } private static final class RunnableExecutorPair { final Runnable runnable ; final Executor executor ; @Nullable RunnableExecutorPair next ; RunnableExecutorPair ( Runnable runnable , Executor executor , RunnableExecutorPair next ) { this . runnable = runnable ; this . executor = executor ; this . next = next ; } } } private static final class NewExecutionListQueue { static final Logger log = Logger . getLogger ( NewExecutionListQueue . class . getName ( ) ) ; @GuardedBy ( <str> ) private RunnableExecutorPair head ; @GuardedBy ( <str> ) private RunnableExecutorPair tail ; @GuardedBy ( <str> ) private boolean executed ; public void add ( Runnable runnable , Executor executor ) { Preconditions . checkNotNull ( runnable , <str> ) ; Preconditions . checkNotNull ( executor , <str> ) ; synchronized ( this ) { if ( ! executed ) { RunnableExecutorPair newTail = new RunnableExecutorPair ( runnable , executor ) ; if ( head = = null ) { head = newTail ; tail = newTail ; } else { tail . next = newTail ; tail = newTail ; } return ; } } executeListener ( runnable , executor ) ; } public void execute ( ) { RunnableExecutorPair list ; synchronized ( this ) { if ( executed ) { return ; } executed = true ; list = head ; head = null ; tail = null ; } while ( list ! = null ) { executeListener ( list . runnable , list . executor ) ; list = list . next ; } } private static void executeListener ( Runnable runnable , Executor executor ) { try { executor . execute ( runnable ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + runnable + <str> + executor , e ) ; } } private static final class RunnableExecutorPair { Runnable runnable ; Executor executor ; @Nullable RunnableExecutorPair next ; RunnableExecutorPair ( Runnable runnable , Executor executor ) { this . runnable = runnable ; this . executor = executor ; } } } private static final class ExecutionListCAS { static final Logger log = Logger . getLogger ( ExecutionListCAS . class . getName ( ) ) ; private static final sun . misc . Unsafe UNSAFE ; private static final long HEAD_OFFSET ; private static final RunnableExecutorPair NULL_PAIR = new RunnableExecutorPair ( null , null ) ; static { try { UNSAFE = getUnsafe ( ) ; HEAD_OFFSET = UNSAFE . objectFieldOffset ( ExecutionListCAS . class . getDeclaredField ( <str> ) ) ; } catch ( Exception ex ) { throw new Error ( ex ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { @Override public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } private volatile RunnableExecutorPair head = NULL_PAIR ; public void add ( Runnable runnable , Executor executor ) { Preconditions . checkNotNull ( runnable , <str> ) ; Preconditions . checkNotNull ( executor , <str> ) ; RunnableExecutorPair newHead = new RunnableExecutorPair ( runnable , executor ) ; RunnableExecutorPair oldHead ; do { oldHead = head ; if ( oldHead = = null ) { newHead . execute ( ) ; return ; } newHead . next = oldHead ; } while ( ! UNSAFE . compareAndSwapObject ( this , HEAD_OFFSET , oldHead , newHead ) ) ; } public void execute ( ) { RunnableExecutorPair stack ; do { stack = head ; if ( stack = = null ) { return ; } } while ( ! UNSAFE . compareAndSwapObject ( this , HEAD_OFFSET , stack , null ) ) ; RunnableExecutorPair reversedStack = null ; while ( stack ! = NULL_PAIR ) { RunnableExecutorPair head = stack ; stack = stack . next ; head . next = reversedStack ; reversedStack = head ; } stack = reversedStack ; while ( stack ! = null ) { stack . execute ( ) ; stack = stack . next ; } } private static class RunnableExecutorPair { final Runnable runnable ; final Executor executor ; @Nullable volatile RunnableExecutorPair next ; RunnableExecutorPair ( Runnable runnable , Executor executor ) { this . runnable = runnable ; this . executor = executor ; } void execute ( ) { try { executor . execute ( runnable ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + runnable + <str> + executor , e ) ; } } } } }