package org . nd4j . linalg . dimensionalityreduction ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . eigen . Eigen ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; public class PCA { public static INDArray pca ( INDArray X , int nDims , boolean normalize ) { if ( normalize ) { INDArray mean = X . mean ( <int> ) ; X = X . subiRowVector ( mean ) ; } INDArray C ; if ( X . size ( <int> ) < X . size ( <int> ) ) C = X . transpose ( ) . mmul ( X ) ; else C = X . mmul ( X . transpose ( ) ) . muli ( <int> / X . size ( <int> ) ) ; IComplexNDArray [ ] eigen = Eigen . eigenvectors ( C ) ; IComplexNDArray M = eigen [ <int> ] ; IComplexNDArray lambda = eigen [ <int> ] ; IComplexNDArray diagLambda = Nd4j . diag ( lambda ) ; INDArray [ ] sorted = Nd4j . sortWithIndices ( diagLambda , <int> , false ) ; INDArray indices = sorted [ <int> ] ; INDArrayIndex [ ] indices2 = NDArrayIndex . create ( indices . get ( NDArrayIndex . interval ( <int> , nDims ) ) ) ; INDArrayIndex [ ] rowsAndColumnIndices = new INDArrayIndex [ ] { NDArrayIndex . interval ( <int> , M . rows ( ) ) , indices2 [ <int> ] } ; M = M . get ( rowsAndColumnIndices ) ; X = Nd4j . createComplex ( X . subRowVector ( X . mean ( <int> ) ) ) . mmul ( M ) ; return X ; } } 
