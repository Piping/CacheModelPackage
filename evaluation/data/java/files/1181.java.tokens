package org . elasticsearch . index . mapper . completion ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . suggest . document . * ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . apache . lucene . util . automaton . Operations ; import org . apache . lucene . util . automaton . RegExp ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . index . mapper . core . CompletionFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . Matchers . * ; public class CompletionFieldMapperTests extends ESSingleNodeTestCase { public void testDefaultConfiguration ( ) throws IOException { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( CompletionFieldMapper . class ) ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; NamedAnalyzer indexAnalyzer = completionFieldType . indexAnalyzer ( ) ; assertThat ( indexAnalyzer . name ( ) , equalTo ( <str> ) ) ; assertThat ( indexAnalyzer . analyzer ( ) , instanceOf ( CompletionAnalyzer . class ) ) ; CompletionAnalyzer analyzer = ( CompletionAnalyzer ) indexAnalyzer . analyzer ( ) ; assertThat ( analyzer . preservePositionIncrements ( ) , equalTo ( true ) ) ; assertThat ( analyzer . preserveSep ( ) , equalTo ( true ) ) ; NamedAnalyzer searchAnalyzer = completionFieldType . searchAnalyzer ( ) ; assertThat ( searchAnalyzer . name ( ) , equalTo ( <str> ) ) ; assertThat ( searchAnalyzer . analyzer ( ) , instanceOf ( CompletionAnalyzer . class ) ) ; analyzer = ( CompletionAnalyzer ) searchAnalyzer . analyzer ( ) ; assertThat ( analyzer . preservePositionIncrements ( ) , equalTo ( true ) ) ; assertThat ( analyzer . preserveSep ( ) , equalTo ( true ) ) ; } public void testCompletionAnalyzerSettings ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( CompletionFieldMapper . class ) ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; NamedAnalyzer indexAnalyzer = completionFieldType . indexAnalyzer ( ) ; assertThat ( indexAnalyzer . name ( ) , equalTo ( <str> ) ) ; assertThat ( indexAnalyzer . analyzer ( ) , instanceOf ( CompletionAnalyzer . class ) ) ; CompletionAnalyzer analyzer = ( CompletionAnalyzer ) indexAnalyzer . analyzer ( ) ; assertThat ( analyzer . preservePositionIncrements ( ) , equalTo ( true ) ) ; assertThat ( analyzer . preserveSep ( ) , equalTo ( false ) ) ; NamedAnalyzer searchAnalyzer = completionFieldType . searchAnalyzer ( ) ; assertThat ( searchAnalyzer . name ( ) , equalTo ( <str> ) ) ; assertThat ( searchAnalyzer . analyzer ( ) , instanceOf ( CompletionAnalyzer . class ) ) ; analyzer = ( CompletionAnalyzer ) searchAnalyzer . analyzer ( ) ; assertThat ( analyzer . preservePositionIncrements ( ) , equalTo ( true ) ) ; assertThat ( analyzer . preserveSep ( ) , equalTo ( false ) ) ; } public void testTypeParsing ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . field ( <str> , true ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( CompletionFieldMapper . class ) ) ; CompletionFieldMapper completionFieldMapper = ( CompletionFieldMapper ) fieldMapper ; XContentBuilder builder = jsonBuilder ( ) . startObject ( ) ; completionFieldMapper . toXContent ( builder , ToXContent . EMPTY_PARAMS ) . endObject ( ) ; builder . close ( ) ; Map < String , Object > serializedMap = JsonXContent . jsonXContent . createParser ( builder . bytes ( ) ) . map ( ) ; Map < String , Object > configMap = ( Map < String , Object > ) serializedMap . get ( <str> ) ; assertThat ( configMap . get ( <str> ) . toString ( ) , is ( <str> ) ) ; assertThat ( configMap . get ( <str> ) . toString ( ) , is ( <str> ) ) ; assertThat ( Boolean . valueOf ( configMap . get ( <str> ) . toString ( ) ) , is ( false ) ) ; assertThat ( Boolean . valueOf ( configMap . get ( <str> ) . toString ( ) ) , is ( true ) ) ; assertThat ( Integer . valueOf ( configMap . get ( <str> ) . toString ( ) ) , is ( <int> ) ) ; } public void testParsingMinimal ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testParsingMultiValued ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . array ( <str> , <str> , <str> ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testParsingWithWeight ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testParsingMultiValueWithWeight ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . array ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testParsingFull ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testParsingMixed ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . array ( <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertSuggestFields ( fields , <int> ) ; } public void testNonContextEnabledParsingWithContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getRootCause ( ) . getMessage ( ) , containsString ( <str> ) ) ; } } public void testFieldValueValidation ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; CharsRefBuilder charsRefBuilder = new CharsRefBuilder ( ) ; charsRefBuilder . append ( <str> ) ; charsRefBuilder . setCharAt ( <int> , <str> ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , charsRefBuilder . get ( ) . toString ( ) ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { Throwable cause = e . unwrapCause ( ) . getCause ( ) ; assertThat ( cause , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( cause . getMessage ( ) , containsString ( <str> ) ) ; } charsRefBuilder . setCharAt ( <int> , <str> ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , charsRefBuilder . get ( ) . toString ( ) ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { Throwable cause = e . unwrapCause ( ) . getCause ( ) ; assertThat ( cause , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( cause . getMessage ( ) , containsString ( <str> ) ) ; } charsRefBuilder . setCharAt ( <int> , <str> ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , charsRefBuilder . get ( ) . toString ( ) ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { Throwable cause = e . unwrapCause ( ) . getCause ( ) ; assertThat ( cause , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( cause . getMessage ( ) , containsString ( <str> ) ) ; } } public void testPrefixQueryType ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; CompletionFieldMapper completionFieldMapper = ( CompletionFieldMapper ) fieldMapper ; Query prefixQuery = completionFieldMapper . fieldType ( ) . prefixQuery ( new BytesRef ( <str> ) ) ; assertThat ( prefixQuery , instanceOf ( PrefixCompletionQuery . class ) ) ; } public void testFuzzyQueryType ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; CompletionFieldMapper completionFieldMapper = ( CompletionFieldMapper ) fieldMapper ; Query prefixQuery = completionFieldMapper . fieldType ( ) . fuzzyQuery ( <str> , Fuzziness . fromEdits ( FuzzyCompletionQuery . DEFAULT_MAX_EDITS ) , FuzzyCompletionQuery . DEFAULT_NON_FUZZY_PREFIX , FuzzyCompletionQuery . DEFAULT_MIN_FUZZY_LENGTH , Operations . DEFAULT_MAX_DETERMINIZED_STATES , FuzzyCompletionQuery . DEFAULT_TRANSPOSITIONS , FuzzyCompletionQuery . DEFAULT_UNICODE_AWARE ) ; assertThat ( prefixQuery , instanceOf ( FuzzyCompletionQuery . class ) ) ; } public void testRegexQueryType ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; CompletionFieldMapper completionFieldMapper = ( CompletionFieldMapper ) fieldMapper ; Query prefixQuery = completionFieldMapper . fieldType ( ) . regexpQuery ( new BytesRef ( <str> ) , RegExp . ALL , Operations . DEFAULT_MAX_DETERMINIZED_STATES ) ; assertThat ( prefixQuery , instanceOf ( RegexCompletionQuery . class ) ) ; } private static void assertSuggestFields ( IndexableField [ ] fields , int expected ) { int actualFieldCount = <int> ; for ( IndexableField field : fields ) { if ( field instanceof SuggestField ) { actualFieldCount + + ; } } assertThat ( actualFieldCount , equalTo ( expected ) ) ; } } 
