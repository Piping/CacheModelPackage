package rx . internal . operators ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicReference ; import rx . Observer ; import rx . Subscriber ; import rx . functions . Action0 ; import rx . subjects . Subject ; import rx . subscriptions . Subscriptions ; public final class BufferUntilSubscriber < T > extends Subject < T , T > { public static < T > BufferUntilSubscriber < T > create ( ) { State < T > state = new State < T > ( ) ; return new BufferUntilSubscriber < T > ( state ) ; } static final class State < T > extends AtomicReference < Observer < ? super T > > { boolean casObserverRef ( Observer < ? super T > expected , Observer < ? super T > next ) { return compareAndSet ( expected , next ) ; } final Object guard = new Object ( ) ; boolean emitting = false ; final ConcurrentLinkedQueue < Object > buffer = new ConcurrentLinkedQueue < Object > ( ) ; final NotificationLite < T > nl = NotificationLite . instance ( ) ; } static final class OnSubscribeAction < T > implements OnSubscribe < T > { final State < T > state ; public OnSubscribeAction ( State < T > state ) { this . state = state ; } @Override public void call ( final Subscriber < ? super T > s ) { if ( state . casObserverRef ( null , s ) ) { s . add ( Subscriptions . create ( new Action0 ( ) { @SuppressWarnings ( <str> ) @Override public void call ( ) { state . set ( EMPTY_OBSERVER ) ; } } ) ) ; boolean win = false ; synchronized ( state . guard ) { if ( ! state . emitting ) { state . emitting = true ; win = true ; } } if ( win ) { final NotificationLite < T > nl = NotificationLite . instance ( ) ; while ( true ) { Object o ; while ( ( o = state . buffer . poll ( ) ) ! = null ) { nl . accept ( state . get ( ) , o ) ; } synchronized ( state . guard ) { if ( state . buffer . isEmpty ( ) ) { state . emitting = false ; break ; } } } } } else { s . onError ( new IllegalStateException ( <str> ) ) ; } } } final State < T > state ; private boolean forward = false ; private BufferUntilSubscriber ( State < T > state ) { super ( new OnSubscribeAction < T > ( state ) ) ; this . state = state ; } private void emit ( Object v ) { synchronized ( state . guard ) { state . buffer . add ( v ) ; if ( state . get ( ) ! = null & & ! state . emitting ) { forward = true ; state . emitting = true ; } } if ( forward ) { Object o ; while ( ( o = state . buffer . poll ( ) ) ! = null ) { state . nl . accept ( state . get ( ) , o ) ; } } } @Override public void onCompleted ( ) { if ( forward ) { state . get ( ) . onCompleted ( ) ; } else { emit ( state . nl . completed ( ) ) ; } } @Override public void onError ( Throwable e ) { if ( forward ) { state . get ( ) . onError ( e ) ; } else { emit ( state . nl . error ( e ) ) ; } } @Override public void onNext ( T t ) { if ( forward ) { state . get ( ) . onNext ( t ) ; } else { emit ( state . nl . next ( t ) ) ; } } @Override public boolean hasObservers ( ) { synchronized ( state . guard ) { return state . get ( ) ! = null ; } } @SuppressWarnings ( <str> ) private final static Observer EMPTY_OBSERVER = new Observer ( ) { @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Object t ) { } } ; }