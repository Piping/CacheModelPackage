package rx . internal . operators ; import static org . junit . Assert . * ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . * ; import java . util . * ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . Test ; import rx . Observable ; import rx . Observer ; import rx . exceptions . TestException ; import rx . functions . Func0 ; import rx . observers . TestSubscriber ; import rx . subjects . PublishSubject ; public class OperatorWindowWithObservableTest { @Test public void testWindowViaObservableNormal1 ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) final Observer < Object > o = mock ( Observer . class ) ; final List < Observer < Object > > values = new ArrayList < Observer < Object > > ( ) ; Observer < Observable < Integer > > wo = new Observer < Observable < Integer > > ( ) { @Override public void onNext ( Observable < Integer > args ) { @SuppressWarnings ( <str> ) final Observer < Object > mo = mock ( Observer . class ) ; values . add ( mo ) ; args . subscribe ( mo ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ; source . window ( boundary ) . subscribe ( wo ) ; int n = <int> ; for ( int i = <int> ; i < n ; i + + ) { source . onNext ( i ) ; if ( i % <int> = = <int> & & i < n - <int> ) { boundary . onNext ( i / <int> ) ; } } source . onCompleted ( ) ; assertEquals ( n / <int> , values . size ( ) ) ; int j = <int> ; for ( Observer < Object > mo : values ) { for ( int i = <int> ; i < <int> ; i + + ) { verify ( mo ) . onNext ( j + i ) ; } verify ( mo ) . onCompleted ( ) ; verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; j + = <int> ; } verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testWindowViaObservableBoundaryCompletes ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) final Observer < Object > o = mock ( Observer . class ) ; final List < Observer < Object > > values = new ArrayList < Observer < Object > > ( ) ; Observer < Observable < Integer > > wo = new Observer < Observable < Integer > > ( ) { @Override public void onNext ( Observable < Integer > args ) { @SuppressWarnings ( <str> ) final Observer < Object > mo = mock ( Observer . class ) ; values . add ( mo ) ; args . subscribe ( mo ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ; source . window ( boundary ) . subscribe ( wo ) ; int n = <int> ; for ( int i = <int> ; i < n ; i + + ) { source . onNext ( i ) ; if ( i % <int> = = <int> & & i < n - <int> ) { boundary . onNext ( i / <int> ) ; } } boundary . onCompleted ( ) ; assertEquals ( n / <int> , values . size ( ) ) ; int j = <int> ; for ( Observer < Object > mo : values ) { for ( int i = <int> ; i < <int> ; i + + ) { verify ( mo ) . onNext ( j + i ) ; } verify ( mo ) . onCompleted ( ) ; verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; j + = <int> ; } verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testWindowViaObservableBoundaryThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) final Observer < Object > o = mock ( Observer . class ) ; final List < Observer < Object > > values = new ArrayList < Observer < Object > > ( ) ; Observer < Observable < Integer > > wo = new Observer < Observable < Integer > > ( ) { @Override public void onNext ( Observable < Integer > args ) { @SuppressWarnings ( <str> ) final Observer < Object > mo = mock ( Observer . class ) ; values . add ( mo ) ; args . subscribe ( mo ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; boundary . onError ( new TestException ( ) ) ; assertEquals ( <int> , values . size ( ) ) ; Observer < Object > mo = values . get ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; } @Test public void testWindowViaObservableSourceThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) final Observer < Object > o = mock ( Observer . class ) ; final List < Observer < Object > > values = new ArrayList < Observer < Object > > ( ) ; Observer < Observable < Integer > > wo = new Observer < Observable < Integer > > ( ) { @Override public void onNext ( Observable < Integer > args ) { @SuppressWarnings ( <str> ) final Observer < Object > mo = mock ( Observer . class ) ; values . add ( mo ) ; args . subscribe ( mo ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onError ( new TestException ( ) ) ; assertEquals ( <int> , values . size ( ) ) ; Observer < Object > mo = values . get ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onNext ( <int> ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; } @Test public void testWindowNoDuplication ( ) { final PublishSubject < Integer > source = PublishSubject . create ( ) ; final TestSubscriber < Integer > tsw = new TestSubscriber < Integer > ( ) { boolean once ; @Override public void onNext ( Integer t ) { if ( ! once ) { once = true ; source . onNext ( <int> ) ; } super . onNext ( t ) ; } } ; TestSubscriber < Observable < Integer > > ts = new TestSubscriber < Observable < Integer > > ( ) { @Override public void onNext ( Observable < Integer > t ) { t . subscribe ( tsw ) ; super . onNext ( t ) ; } } ; source . window ( new Func0 < Observable < Object > > ( ) { @Override public Observable < Object > call ( ) { return Observable . never ( ) ; } } ) . subscribe ( ts ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; assertEquals ( Arrays . asList ( <int> , <int> ) , tsw . getOnNextEvents ( ) ) ; } @Test public void testWindowViaObservableNoUnsubscribe ( ) { Observable < Integer > source = Observable . range ( <int> , <int> ) ; Func0 < Observable < String > > boundary = new Func0 < Observable < String > > ( ) { @Override public Observable < String > call ( ) { return Observable . empty ( ) ; } } ; TestSubscriber < Observable < Integer > > ts = TestSubscriber . create ( ) ; source . window ( boundary ) . unsafeSubscribe ( ts ) ; assertFalse ( ts . isUnsubscribed ( ) ) ; } @Test public void testBoundaryUnsubscribedOnMainCompletion ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Func0 < Observable < Integer > > boundaryFunc = new Func0 < Observable < Integer > > ( ) { @Override public Observable < Integer > call ( ) { return boundary ; } } ; TestSubscriber < Observable < Integer > > ts = TestSubscriber . create ( ) ; source . window ( boundaryFunc ) . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( boundary . hasObservers ( ) ) ; source . onCompleted ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( boundary . hasObservers ( ) ) ; ts . assertCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( <int> ) ; } @Test public void testMainUnsubscribedOnBoundaryCompletion ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Func0 < Observable < Integer > > boundaryFunc = new Func0 < Observable < Integer > > ( ) { @Override public Observable < Integer > call ( ) { return boundary ; } } ; TestSubscriber < Observable < Integer > > ts = TestSubscriber . create ( ) ; source . window ( boundaryFunc ) . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( boundary . hasObservers ( ) ) ; boundary . onCompleted ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( boundary . hasObservers ( ) ) ; ts . assertCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( <int> ) ; } @Test public void testChildUnsubscribed ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Func0 < Observable < Integer > > boundaryFunc = new Func0 < Observable < Integer > > ( ) { @Override public Observable < Integer > call ( ) { return boundary ; } } ; TestSubscriber < Observable < Integer > > ts = TestSubscriber . create ( ) ; source . window ( boundaryFunc ) . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( boundary . hasObservers ( ) ) ; ts . unsubscribe ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( boundary . hasObservers ( ) ) ; ts . assertNotCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( <int> ) ; } @Test public void testInnerBackpressure ( ) { Observable < Integer > source = Observable . range ( <int> , <int> ) ; final PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Func0 < Observable < Integer > > boundaryFunc = new Func0 < Observable < Integer > > ( ) { @Override public Observable < Integer > call ( ) { return boundary ; } } ; final TestSubscriber < Integer > ts = TestSubscriber . create ( <int> ) ; final TestSubscriber < Observable < Integer > > ts1 = new TestSubscriber < Observable < Integer > > ( <int> ) { @Override public void onNext ( Observable < Integer > t ) { super . onNext ( t ) ; t . subscribe ( ts ) ; } } ; source . window ( boundaryFunc ) . subscribe ( ts1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertCompleted ( ) ; ts1 . assertValueCount ( <int> ) ; ts . assertNoErrors ( ) ; ts . assertNotCompleted ( ) ; ts . assertValues ( <int> ) ; ts . requestMore ( <int> ) ; ts . assertValues ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ts . assertNoErrors ( ) ; ts . assertCompleted ( ) ; } @Test public void newBoundaryCalledAfterWindowClosed ( ) { final AtomicInteger calls = new AtomicInteger ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Func0 < Observable < Integer > > boundaryFunc = new Func0 < Observable < Integer > > ( ) { @Override public Observable < Integer > call ( ) { calls . getAndIncrement ( ) ; return boundary ; } } ; TestSubscriber < Observable < Integer > > ts = TestSubscriber . create ( ) ; source . window ( boundaryFunc ) . subscribe ( ts ) ; source . onNext ( <int> ) ; boundary . onNext ( <int> ) ; assertTrue ( boundary . hasObservers ( ) ) ; source . onNext ( <int> ) ; boundary . onNext ( <int> ) ; assertTrue ( boundary . hasObservers ( ) ) ; source . onNext ( <int> ) ; boundary . onNext ( <int> ) ; assertTrue ( boundary . hasObservers ( ) ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( <int> ) ; ts . assertCompleted ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( boundary . hasObservers ( ) ) ; } } 
