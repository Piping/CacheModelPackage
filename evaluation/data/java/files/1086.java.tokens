package org . gradle . cache . internal . btree ; import org . gradle . internal . serialize . DefaultSerializer ; import org . gradle . internal . serialize . Serializer ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . * ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; public class BTreePersistentIndexedCacheTest { @Rule public TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private final Serializer < String > stringSerializer = new DefaultSerializer < String > ( ) ; private final Serializer < Integer > integerSerializer = new DefaultSerializer < Integer > ( ) ; private BTreePersistentIndexedCache < String , Integer > cache ; private TestFile cacheFile ; @Before public void setup ( ) { cacheFile = tmpDir . file ( <str> ) ; } private void createCache ( ) { cache = new BTreePersistentIndexedCache < String , Integer > ( cacheFile , stringSerializer , integerSerializer , ( short ) <int> , <int> ) ; } private void verifyAndCloseCache ( ) { cache . verify ( ) ; cache . close ( ) ; } @Test public void getReturnsNullWhenEntryDoesNotExist ( ) { createCache ( ) ; assertNull ( cache . get ( <str> ) ) ; verifyAndCloseCache ( ) ; } @Test public void persistsAddedEntries ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsAddedEntriesInReverseOrder ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsAddedEntriesOverMultipleIndexBlocks ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsAddedEntriesAfterReopen ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> ) ; cache . reset ( ) ; checkAdds ( <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsReplacedEntries ( ) { createCache ( ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; cache . put ( <str> , <int> ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; cache . reset ( ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( <str> ) , equalTo ( <int> ) ) ; verifyAndCloseCache ( ) ; } @Test public void reusesEmptySpaceWhenPuttingEntries ( ) { BTreePersistentIndexedCache < String , String > cache = new BTreePersistentIndexedCache < String , String > ( cacheFile , stringSerializer , stringSerializer , ( short ) <int> , <int> ) ; cache . put ( <str> , <str> ) ; cache . put ( <str> , <str> ) ; cache . put ( <str> , <str> ) ; cache . put ( <str> , <str> ) ; cache . put ( <str> , <str> ) ; long len = cacheFile . length ( ) ; assertThat ( len , greaterThan ( <int> ) ) ; cache . put ( <str> , <str> ) ; assertThat ( cacheFile . length ( ) , equalTo ( len ) ) ; cache . remove ( <str> ) ; cache . put ( <str> , <str> ) ; assertThat ( cacheFile . length ( ) , equalTo ( len ) ) ; cache . put ( <str> , <str> ) ; assertThat ( cacheFile . length ( ) , greaterThan ( len ) ) ; len = cacheFile . length ( ) ; cache . put ( <str> , <str> ) ; assertThat ( cacheFile . length ( ) , equalTo ( len ) ) ; cache . close ( ) ; } @Test public void canHandleLargeNumberOfEntries ( ) { createCache ( ) ; int count = <int> ; List < Integer > values = new ArrayList < Integer > ( ) ; for ( int i = <int> ; i < count ; i + + ) { values . add ( i ) ; } checkAddsAndRemoves ( null , values ) ; long len = cacheFile . length ( ) ; checkAddsAndRemoves ( Collections . < Integer > reverseOrder ( ) , values ) ; assertThat ( cacheFile . length ( ) , lessThan ( ( long ) ( <float> * len ) ) ) ; checkAdds ( values ) ; assertThat ( cacheFile . length ( ) , lessThan ( ( long ) ( <float> * <float> * len ) ) ) ; cache . close ( ) ; } @Test public void persistsRemovalOfEntries ( ) { createCache ( ) ; checkAddsAndRemoves ( <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsRemovalOfEntriesInReverse ( ) { createCache ( ) ; checkAddsAndRemoves ( Collections . < Integer > reverseOrder ( ) , <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void persistsRemovalOfEntriesOverMultipleIndexBlocks ( ) { createCache ( ) ; checkAddsAndRemoves ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; verifyAndCloseCache ( ) ; } @Test public void removalRedistributesRemainingEntriesWithLeftSibling ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> , <int> ) ; cache . verify ( ) ; cache . remove ( <str> ) ; verifyAndCloseCache ( ) ; } @Test public void removalMergesRemainingEntriesIntoLeftSibling ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> ) ; cache . verify ( ) ; cache . remove ( <str> ) ; verifyAndCloseCache ( ) ; } @Test public void removalRedistributesRemainingEntriesWithRightSibling ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> , <int> ) ; cache . verify ( ) ; cache . remove ( <str> ) ; verifyAndCloseCache ( ) ; } @Test public void removalMergesRemainingEntriesIntoRightSibling ( ) { createCache ( ) ; checkAdds ( <int> , <int> , <int> , <int> , <int> ) ; cache . verify ( ) ; cache . remove ( <str> ) ; verifyAndCloseCache ( ) ; } @Test public void handlesBadlyFormedCacheFile ( ) throws IOException { cacheFile . createNewFile ( ) ; cacheFile . write ( <str> ) ; BTreePersistentIndexedCache < String , Integer > cache = new BTreePersistentIndexedCache < String , Integer > ( cacheFile , stringSerializer , integerSerializer ) ; assertNull ( cache . get ( <str> ) ) ; cache . put ( <str> , <int> ) ; RandomAccessFile file = new RandomAccessFile ( cacheFile , <str> ) ; file . setLength ( file . length ( ) - <int> ) ; file . close ( ) ; cache . reset ( ) ; assertNull ( cache . get ( <str> ) ) ; cache . verify ( ) ; cache . close ( ) ; } @Test public void canUseFileAsKey ( ) { BTreePersistentIndexedCache < File , Integer > cache = new BTreePersistentIndexedCache < File , Integer > ( cacheFile , new DefaultSerializer < File > ( ) , integerSerializer ) ; cache . put ( new File ( <str> ) , <int> ) ; cache . put ( new File ( <str> ) , <int> ) ; cache . put ( new File ( <str> ) , <int> ) ; assertThat ( cache . get ( new File ( <str> ) ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( new File ( <str> ) ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( new File ( <str> ) ) , equalTo ( <int> ) ) ; cache . close ( ) ; } @Test public void handlesKeysWithSameHashCode ( ) { createCache ( ) ; String key1 = new String ( new byte [ ] { <int> , <int> } ) ; String key2 = new String ( new byte [ ] { <int> , <int> } ) ; cache . put ( key1 , <int> ) ; cache . put ( key2 , <int> ) ; assertThat ( cache . get ( key1 ) , equalTo ( <int> ) ) ; assertThat ( cache . get ( key2 ) , equalTo ( <int> ) ) ; cache . close ( ) ; } private void checkAdds ( Integer . . . values ) { checkAdds ( Arrays . asList ( values ) ) ; } private Map < String , Integer > checkAdds ( Iterable < Integer > values ) { Map < String , Integer > added = new LinkedHashMap < String , Integer > ( ) ; for ( Integer value : values ) { String key = String . format ( <str> , value ) ; cache . put ( key , value ) ; added . put ( String . format ( <str> , value ) , value ) ; } for ( Map . Entry < String , Integer > entry : added . entrySet ( ) ) { assertThat ( cache . get ( entry . getKey ( ) ) , equalTo ( entry . getValue ( ) ) ) ; } cache . reset ( ) ; for ( Map . Entry < String , Integer > entry : added . entrySet ( ) ) { assertThat ( cache . get ( entry . getKey ( ) ) , equalTo ( entry . getValue ( ) ) ) ; } return added ; } private void checkAddsAndRemoves ( Integer . . . values ) { checkAddsAndRemoves ( null , values ) ; } private void checkAddsAndRemoves ( Comparator < Integer > comparator , Integer . . . values ) { checkAddsAndRemoves ( comparator , Arrays . asList ( values ) ) ; } private void checkAddsAndRemoves ( Comparator < Integer > comparator , Collection < Integer > values ) { checkAdds ( values ) ; List < Integer > deleteValues = new ArrayList < Integer > ( values ) ; Collections . sort ( deleteValues , comparator ) ; for ( Integer value : deleteValues ) { String key = String . format ( <str> , value ) ; assertThat ( cache . get ( key ) , notNullValue ( ) ) ; cache . remove ( key ) ; assertThat ( cache . get ( key ) , nullValue ( ) ) ; } cache . reset ( ) ; cache . verify ( ) ; for ( Integer value : deleteValues ) { String key = String . format ( <str> , value ) ; assertThat ( cache . get ( key ) , nullValue ( ) ) ; } } } 
