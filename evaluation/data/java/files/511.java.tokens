package org . apache . cassandra . utils . obs ; final class BitUtil { public static int pop ( long x ) { x = x - ( ( x > > > <int> ) & <hex> L ) ; x = ( x & <hex> L ) + ( ( x > > > <int> ) & <hex> L ) ; x = ( x + ( x > > > <int> ) ) & <hex> L ; x = x + ( x > > > <int> ) ; x = x + ( x > > > <int> ) ; x = x + ( x > > > <int> ) ; return ( ( int ) x ) & <hex> ; } public static long pop_array ( long A [ ] , int wordOffset , int numWords ) { int n = wordOffset + numWords ; long tot = <int> , tot8 = <int> ; long ones = <int> , twos = <int> , fours = <int> ; int i ; for ( i = wordOffset ; i < = n - <int> ; i + = <int> ) { long twosA , twosB , foursA , foursB , eights ; { long b = A [ i ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = A [ i + <int> ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long b = A [ i + <int> ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = A [ i + <int> ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursB = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long u = fours ^ foursA ; eights = ( fours & foursA ) | ( u & foursB ) ; fours = u ^ foursB ; } tot8 + = pop ( eights ) ; } if ( i < = n - <int> ) { long twosA , twosB , foursA , eights ; { long b = A [ i ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = A [ i + <int> ] , c = A [ i + <int> ] ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < = n - <int> ) { long b = A [ i ] , c = A [ i + <int> ] ; long u = ones ^ b ; long twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; long foursA = twos & twosA ; twos = twos ^ twosA ; long eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < n ) { tot + = pop ( A [ i ] ) ; } tot + = ( pop ( fours ) < < <int> ) + ( pop ( twos ) < < <int> ) + pop ( ones ) + ( tot8 < < <int> ) ; return tot ; } public static long pop_intersect ( long A [ ] , long B [ ] , int wordOffset , int numWords ) { int n = wordOffset + numWords ; long tot = <int> , tot8 = <int> ; long ones = <int> , twos = <int> , fours = <int> ; int i ; for ( i = wordOffset ; i < = n - <int> ; i + = <int> ) { long twosA , twosB , foursA , foursB , eights ; { long b = ( A [ i ] & B [ i ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & B [ i + <int> ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long b = ( A [ i + <int> ] & B [ i + <int> ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & B [ i + <int> ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursB = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long u = fours ^ foursA ; eights = ( fours & foursA ) | ( u & foursB ) ; fours = u ^ foursB ; } tot8 + = pop ( eights ) ; } if ( i < = n - <int> ) { long twosA , twosB , foursA , eights ; { long b = ( A [ i ] & B [ i ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & B [ i + <int> ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < = n - <int> ) { long b = ( A [ i ] & B [ i ] ) , c = ( A [ i + <int> ] & B [ i + <int> ] ) ; long u = ones ^ b ; long twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; long foursA = twos & twosA ; twos = twos ^ twosA ; long eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < n ) { tot + = pop ( ( A [ i ] & B [ i ] ) ) ; } tot + = ( pop ( fours ) < < <int> ) + ( pop ( twos ) < < <int> ) + pop ( ones ) + ( tot8 < < <int> ) ; return tot ; } public static long pop_union ( long A [ ] , long B [ ] , int wordOffset , int numWords ) { int n = wordOffset + numWords ; long tot = <int> , tot8 = <int> ; long ones = <int> , twos = <int> , fours = <int> ; int i ; for ( i = wordOffset ; i < = n - <int> ; i + = <int> ) { long twosA , twosB , foursA , foursB , eights ; { long b = ( A [ i ] | B [ i ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] | B [ i + <int> ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long b = ( A [ i + <int> ] | B [ i + <int> ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] | B [ i + <int> ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursB = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long u = fours ^ foursA ; eights = ( fours & foursA ) | ( u & foursB ) ; fours = u ^ foursB ; } tot8 + = pop ( eights ) ; } if ( i < = n - <int> ) { long twosA , twosB , foursA , eights ; { long b = ( A [ i ] | B [ i ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] | B [ i + <int> ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < = n - <int> ) { long b = ( A [ i ] | B [ i ] ) , c = ( A [ i + <int> ] | B [ i + <int> ] ) ; long u = ones ^ b ; long twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; long foursA = twos & twosA ; twos = twos ^ twosA ; long eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < n ) { tot + = pop ( ( A [ i ] | B [ i ] ) ) ; } tot + = ( pop ( fours ) < < <int> ) + ( pop ( twos ) < < <int> ) + pop ( ones ) + ( tot8 < < <int> ) ; return tot ; } public static long pop_andnot ( long A [ ] , long B [ ] , int wordOffset , int numWords ) { int n = wordOffset + numWords ; long tot = <int> , tot8 = <int> ; long ones = <int> , twos = <int> , fours = <int> ; int i ; for ( i = wordOffset ; i < = n - <int> ; i + = <int> ) { long twosA , twosB , foursA , foursB , eights ; { long b = ( A [ i ] & ~ B [ i ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & ~ B [ i + <int> ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long b = ( A [ i + <int> ] & ~ B [ i + <int> ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & ~ B [ i + <int> ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursB = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long u = fours ^ foursA ; eights = ( fours & foursA ) | ( u & foursB ) ; fours = u ^ foursB ; } tot8 + = pop ( eights ) ; } if ( i < = n - <int> ) { long twosA , twosB , foursA , eights ; { long b = ( A [ i ] & ~ B [ i ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] & ~ B [ i + <int> ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < = n - <int> ) { long b = ( A [ i ] & ~ B [ i ] ) , c = ( A [ i + <int> ] & ~ B [ i + <int> ] ) ; long u = ones ^ b ; long twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; long foursA = twos & twosA ; twos = twos ^ twosA ; long eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < n ) { tot + = pop ( ( A [ i ] & ~ B [ i ] ) ) ; } tot + = ( pop ( fours ) < < <int> ) + ( pop ( twos ) < < <int> ) + pop ( ones ) + ( tot8 < < <int> ) ; return tot ; } public static long pop_xor ( long A [ ] , long B [ ] , int wordOffset , int numWords ) { int n = wordOffset + numWords ; long tot = <int> , tot8 = <int> ; long ones = <int> , twos = <int> , fours = <int> ; int i ; for ( i = wordOffset ; i < = n - <int> ; i + = <int> ) { long twosA , twosB , foursA , foursB , eights ; { long b = ( A [ i ] ^ B [ i ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] ^ B [ i + <int> ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long b = ( A [ i + <int> ] ^ B [ i + <int> ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] ^ B [ i + <int> ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursB = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } { long u = fours ^ foursA ; eights = ( fours & foursA ) | ( u & foursB ) ; fours = u ^ foursB ; } tot8 + = pop ( eights ) ; } if ( i < = n - <int> ) { long twosA , twosB , foursA , eights ; { long b = ( A [ i ] ^ B [ i ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long b = ( A [ i + <int> ] ^ B [ i + <int> ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; twosB = ( ones & b ) | ( u & c ) ; ones = u ^ c ; } { long u = twos ^ twosA ; foursA = ( twos & twosA ) | ( u & twosB ) ; twos = u ^ twosB ; } eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < = n - <int> ) { long b = ( A [ i ] ^ B [ i ] ) , c = ( A [ i + <int> ] ^ B [ i + <int> ] ) ; long u = ones ^ b ; long twosA = ( ones & b ) | ( u & c ) ; ones = u ^ c ; long foursA = twos & twosA ; twos = twos ^ twosA ; long eights = fours & foursA ; fours = fours ^ foursA ; tot8 + = pop ( eights ) ; i + = <int> ; } if ( i < n ) { tot + = pop ( ( A [ i ] ^ B [ i ] ) ) ; } tot + = ( pop ( fours ) < < <int> ) + ( pop ( twos ) < < <int> ) + pop ( ones ) + ( tot8 < < <int> ) ; return tot ; } public static final byte [ ] ntzTable = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; public static int ntz ( long val ) { int lower = ( int ) val ; int lowByte = lower & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] ; if ( lower ! = <int> ) { lowByte = ( lower > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; lowByte = ( lower > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; return ntzTable [ lower > > > <int> ] + <int> ; } else { int upper = ( int ) ( val > > <int> ) ; lowByte = upper & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; lowByte = ( upper > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; lowByte = ( upper > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; return ntzTable [ upper > > > <int> ] + <int> ; } } public static int ntz ( int val ) { int lowByte = val & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] ; lowByte = ( val > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; lowByte = ( val > > > <int> ) & <hex> ; if ( lowByte ! = <int> ) return ntzTable [ lowByte ] + <int> ; return ntzTable [ val > > > <int> ] + <int> ; } public static int ntz2 ( long x ) { int n = <int> ; int y = ( int ) x ; if ( y = = <int> ) { n + = <int> ; y = ( int ) ( x > > > <int> ) ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } return ( ntzTable [ y & <hex> ] ) + n ; } public static int ntz3 ( long x ) { int n = <int> ; int y = ( int ) x ; if ( y = = <int> ) { n + = <int> ; y = ( int ) ( x > > > <int> ) ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } if ( ( y & <hex> ) = = <int> ) { n + = <int> ; y > > > = <int> ; } return n - ( y & <int> ) ; } public static boolean isPowerOfTwo ( int v ) { return ( ( v & ( v - <int> ) ) = = <int> ) ; } public static boolean isPowerOfTwo ( long v ) { return ( ( v & ( v - <int> ) ) = = <int> ) ; } public static int nextHighestPowerOfTwo ( int v ) { v - - ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v + + ; return v ; } public static long nextHighestPowerOfTwo ( long v ) { v - - ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v + + ; return v ; } } 
