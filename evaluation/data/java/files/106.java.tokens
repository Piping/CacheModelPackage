package org . elasticsearch . index . query ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . ConstantScoreQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . spatial . prefix . PrefixTreeStrategy ; import org . apache . lucene . spatial . prefix . RecursivePrefixTreeStrategy ; import org . apache . lucene . spatial . query . SpatialArgs ; import org . apache . lucene . spatial . query . SpatialOperation ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . geo . ShapeRelation ; import org . elasticsearch . common . geo . ShapesAvailability ; import org . elasticsearch . common . geo . SpatialStrategy ; import org . elasticsearch . common . geo . builders . ShapeBuilder ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . geo . GeoShapeFieldMapper ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Objects ; public class GeoShapeQueryBuilder extends AbstractQueryBuilder < GeoShapeQueryBuilder > { public static final String NAME = <str> ; public static final String DEFAULT_SHAPE_INDEX_NAME = <str> ; public static final String DEFAULT_SHAPE_FIELD_NAME = <str> ; public static final ShapeRelation DEFAULT_SHAPE_RELATION = ShapeRelation . INTERSECTS ; static final GeoShapeQueryBuilder PROTOTYPE = new GeoShapeQueryBuilder ( <str> , new BytesArray ( new byte [ <int> ] ) ) ; private final String fieldName ; private BytesReference shapeBytes ; private SpatialStrategy strategy ; private final String indexedShapeId ; private final String indexedShapeType ; private String indexedShapeIndex = DEFAULT_SHAPE_INDEX_NAME ; private String indexedShapePath = DEFAULT_SHAPE_FIELD_NAME ; private ShapeRelation relation = DEFAULT_SHAPE_RELATION ; public GeoShapeQueryBuilder ( String fieldName , ShapeBuilder shape ) throws IOException { this ( fieldName , shape , null , null ) ; } public GeoShapeQueryBuilder ( String fieldName , String indexedShapeId , String indexedShapeType ) { this ( fieldName , ( BytesReference ) null , indexedShapeId , indexedShapeType ) ; } GeoShapeQueryBuilder ( String fieldName , BytesReference shapeBytes ) { this ( fieldName , shapeBytes , null , null ) ; } private GeoShapeQueryBuilder ( String fieldName , ShapeBuilder shape , String indexedShapeId , String indexedShapeType ) throws IOException { this ( fieldName , new BytesArray ( new byte [ <int> ] ) , indexedShapeId , indexedShapeType ) ; if ( shape ! = null ) { this . shapeBytes = shape . buildAsBytes ( XContentType . JSON ) ; if ( this . shapeBytes . length ( ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } } else { throw new IllegalArgumentException ( <str> ) ; } } private GeoShapeQueryBuilder ( String fieldName , BytesReference shapeBytes , String indexedShapeId , String indexedShapeType ) { if ( fieldName = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( ( shapeBytes = = null | | shapeBytes . length ( ) = = <int> ) & & indexedShapeId = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( indexedShapeId ! = null & & indexedShapeType = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldName = fieldName ; this . shapeBytes = shapeBytes ; this . indexedShapeId = indexedShapeId ; this . indexedShapeType = indexedShapeType ; } public String fieldName ( ) { return fieldName ; } public BytesReference shapeBytes ( ) { return shapeBytes ; } public String indexedShapeId ( ) { return indexedShapeId ; } public String indexedShapeType ( ) { return indexedShapeType ; } public GeoShapeQueryBuilder strategy ( SpatialStrategy strategy ) { if ( strategy ! = null & & strategy = = SpatialStrategy . TERM & & relation ! = ShapeRelation . INTERSECTS ) { throw new IllegalArgumentException ( <str> + strategy . getStrategyName ( ) + <str> + ShapeRelation . INTERSECTS . getRelationName ( ) + <str> + relation . getRelationName ( ) + <str> ) ; } this . strategy = strategy ; return this ; } public SpatialStrategy strategy ( ) { return strategy ; } public GeoShapeQueryBuilder indexedShapeIndex ( String indexedShapeIndex ) { this . indexedShapeIndex = indexedShapeIndex ; return this ; } public String indexedShapeIndex ( ) { return indexedShapeIndex ; } public GeoShapeQueryBuilder indexedShapePath ( String indexedShapePath ) { this . indexedShapePath = indexedShapePath ; return this ; } public String indexedShapePath ( ) { return indexedShapePath ; } public GeoShapeQueryBuilder relation ( ShapeRelation relation ) { if ( relation = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( strategy ! = null & & strategy = = SpatialStrategy . TERM & & relation ! = ShapeRelation . INTERSECTS ) { throw new IllegalArgumentException ( <str> + strategy . getStrategyName ( ) + <str> + ShapeRelation . INTERSECTS . getRelationName ( ) + <str> + relation . getRelationName ( ) + <str> ) ; } this . relation = relation ; return this ; } public ShapeRelation relation ( ) { return relation ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { ShapeBuilder shape ; if ( shapeBytes = = null ) { GetRequest getRequest = new GetRequest ( indexedShapeIndex , indexedShapeType , indexedShapeId ) ; getRequest . copyContextAndHeadersFrom ( SearchContext . current ( ) ) ; shape = fetch ( context . getClient ( ) , getRequest , indexedShapePath ) ; } else { XContentParser shapeParser = XContentHelper . createParser ( shapeBytes ) ; shapeParser . nextToken ( ) ; shape = ShapeBuilder . parse ( shapeParser ) ; } MappedFieldType fieldType = context . fieldMapper ( fieldName ) ; if ( fieldType = = null ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } if ( ! ( fieldType instanceof GeoShapeFieldMapper . GeoShapeFieldType ) ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } GeoShapeFieldMapper . GeoShapeFieldType shapeFieldType = ( GeoShapeFieldMapper . GeoShapeFieldType ) fieldType ; PrefixTreeStrategy strategy = shapeFieldType . defaultStrategy ( ) ; if ( this . strategy ! = null ) { strategy = shapeFieldType . resolveStrategy ( this . strategy ) ; } Query query ; if ( strategy instanceof RecursivePrefixTreeStrategy & & relation = = ShapeRelation . DISJOINT ) { BooleanQuery . Builder bool = new BooleanQuery . Builder ( ) ; Query exists = ExistsQueryBuilder . newFilter ( context , fieldName ) ; Query intersects = strategy . makeQuery ( getArgs ( shape , ShapeRelation . INTERSECTS ) ) ; bool . add ( exists , BooleanClause . Occur . MUST ) ; bool . add ( intersects , BooleanClause . Occur . MUST_NOT ) ; query = new ConstantScoreQuery ( bool . build ( ) ) ; } else { query = new ConstantScoreQuery ( strategy . makeQuery ( getArgs ( shape , relation ) ) ) ; } return query ; } private ShapeBuilder fetch ( Client client , GetRequest getRequest , String path ) throws IOException { if ( ShapesAvailability . JTS_AVAILABLE = = false ) { throw new IllegalStateException ( <str> ) ; } getRequest . preference ( <str> ) ; getRequest . operationThreaded ( false ) ; GetResponse response = client . get ( getRequest ) . actionGet ( ) ; if ( ! response . isExists ( ) ) { throw new IllegalArgumentException ( <str> + getRequest . id ( ) + <str> + getRequest . type ( ) + <str> ) ; } String [ ] pathElements = Strings . splitStringToArray ( path , <str> ) ; int currentPathSlot = <int> ; XContentParser parser = null ; try { parser = XContentHelper . createParser ( response . getSourceAsBytesRef ( ) ) ; XContentParser . Token currentToken ; while ( ( currentToken = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( currentToken = = XContentParser . Token . FIELD_NAME ) { if ( pathElements [ currentPathSlot ] . equals ( parser . currentName ( ) ) ) { parser . nextToken ( ) ; if ( + + currentPathSlot = = pathElements . length ) { return ShapeBuilder . parse ( parser ) ; } } else { parser . nextToken ( ) ; parser . skipChildren ( ) ; } } } throw new IllegalStateException ( <str> + getRequest . id ( ) + <str> + path + <str> ) ; } finally { if ( parser ! = null ) { parser . close ( ) ; } } } public static SpatialArgs getArgs ( ShapeBuilder shape , ShapeRelation relation ) { switch ( relation ) { case DISJOINT : return new SpatialArgs ( SpatialOperation . IsDisjointTo , shape . build ( ) ) ; case INTERSECTS : return new SpatialArgs ( SpatialOperation . Intersects , shape . build ( ) ) ; case WITHIN : return new SpatialArgs ( SpatialOperation . IsWithin , shape . build ( ) ) ; case CONTAINS : return new SpatialArgs ( SpatialOperation . Contains , shape . build ( ) ) ; default : throw new IllegalArgumentException ( <str> + relation + <str> ) ; } } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; if ( strategy ! = null ) { builder . field ( GeoShapeQueryParser . STRATEGY_FIELD . getPreferredName ( ) , strategy . getStrategyName ( ) ) ; } if ( shapeBytes ! = null ) { builder . field ( GeoShapeQueryParser . SHAPE_FIELD . getPreferredName ( ) ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( shapeBytes ) ; parser . nextToken ( ) ; builder . copyCurrentStructure ( parser ) ; } else { builder . startObject ( GeoShapeQueryParser . INDEXED_SHAPE_FIELD . getPreferredName ( ) ) . field ( GeoShapeQueryParser . SHAPE_ID_FIELD . getPreferredName ( ) , indexedShapeId ) . field ( GeoShapeQueryParser . SHAPE_TYPE_FIELD . getPreferredName ( ) , indexedShapeType ) ; if ( indexedShapeIndex ! = null ) { builder . field ( GeoShapeQueryParser . SHAPE_INDEX_FIELD . getPreferredName ( ) , indexedShapeIndex ) ; } if ( indexedShapePath ! = null ) { builder . field ( GeoShapeQueryParser . SHAPE_PATH_FIELD . getPreferredName ( ) , indexedShapePath ) ; } builder . endObject ( ) ; } if ( relation ! = null ) { builder . field ( GeoShapeQueryParser . RELATION_FIELD . getPreferredName ( ) , relation . getRelationName ( ) ) ; } builder . endObject ( ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected GeoShapeQueryBuilder doReadFrom ( StreamInput in ) throws IOException { String fieldName = in . readString ( ) ; GeoShapeQueryBuilder builder ; if ( in . readBoolean ( ) ) { BytesReference shapeBytes = in . readBytesReference ( ) ; builder = new GeoShapeQueryBuilder ( fieldName , shapeBytes ) ; } else { String indexedShapeId = in . readOptionalString ( ) ; String indexedShapeType = in . readOptionalString ( ) ; String indexedShapeIndex = in . readOptionalString ( ) ; String indexedShapePath = in . readOptionalString ( ) ; builder = new GeoShapeQueryBuilder ( fieldName , indexedShapeId , indexedShapeType ) ; if ( indexedShapeIndex ! = null ) { builder . indexedShapeIndex = indexedShapeIndex ; } if ( indexedShapePath ! = null ) { builder . indexedShapePath = indexedShapePath ; } } builder . relation = ShapeRelation . DISJOINT . readFrom ( in ) ; if ( in . readBoolean ( ) ) { builder . strategy = SpatialStrategy . RECURSIVE . readFrom ( in ) ; } return builder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; boolean hasShapeBytes = shapeBytes ! = null ; out . writeBoolean ( hasShapeBytes ) ; if ( hasShapeBytes ) { out . writeBytesReference ( shapeBytes ) ; } else { out . writeOptionalString ( indexedShapeId ) ; out . writeOptionalString ( indexedShapeType ) ; out . writeOptionalString ( indexedShapeIndex ) ; out . writeOptionalString ( indexedShapePath ) ; } relation . writeTo ( out ) ; if ( strategy = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; strategy . writeTo ( out ) ; } } @Override protected boolean doEquals ( GeoShapeQueryBuilder other ) { return Objects . equals ( fieldName , other . fieldName ) & & Objects . equals ( indexedShapeId , other . indexedShapeId ) & & Objects . equals ( indexedShapeIndex , other . indexedShapeIndex ) & & Objects . equals ( indexedShapePath , other . indexedShapePath ) & & Objects . equals ( indexedShapeType , other . indexedShapeType ) & & Objects . equals ( relation , other . relation ) & & Objects . equals ( shapeBytes , other . shapeBytes ) & & Objects . equals ( strategy , other . strategy ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( fieldName , indexedShapeId , indexedShapeIndex , indexedShapePath , indexedShapeType , relation , shapeBytes , strategy ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
