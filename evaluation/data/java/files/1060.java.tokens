package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static rx . internal . operators . OnSubscribeAmb . amb ; import java . io . IOException ; import java . util . Arrays ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import rx . Observable ; import rx . Observable . OnSubscribe ; import rx . Observer ; import rx . Producer ; import rx . Scheduler ; import rx . Subscriber ; import rx . functions . Action0 ; import rx . functions . Action1 ; import rx . internal . util . RxRingBuffer ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; import rx . schedulers . TestScheduler ; import rx . subscriptions . CompositeSubscription ; public class OnSubscribeAmbTest { private TestScheduler scheduler ; private Scheduler . Worker innerScheduler ; @Before public void setUp ( ) { scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; } private Observable < String > createObservable ( final String [ ] values , final long interval , final Throwable e ) { return Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > subscriber ) { CompositeSubscription parentSubscription = new CompositeSubscription ( ) ; subscriber . add ( parentSubscription ) ; long delay = interval ; for ( final String value : values ) { parentSubscription . add ( innerScheduler . schedule ( new Action0 ( ) { @Override public void call ( ) { subscriber . onNext ( value ) ; } } , delay , TimeUnit . MILLISECONDS ) ) ; delay + = interval ; } parentSubscription . add ( innerScheduler . schedule ( new Action0 ( ) { @Override public void call ( ) { if ( e = = null ) { subscriber . onCompleted ( ) ; } else { subscriber . onError ( e ) ; } } } , delay , TimeUnit . MILLISECONDS ) ) ; } } ) ; } @Test public void testAmb ( ) { Observable < String > observable1 = createObservable ( new String [ ] { <str> , <str> , <str> , <str> } , <int> , null ) ; Observable < String > observable2 = createObservable ( new String [ ] { <str> , <str> , <str> , <str> } , <int> , null ) ; Observable < String > observable3 = createObservable ( new String [ ] { <str> , <str> , <str> , <str> } , <int> , null ) ; Observable < String > o = Observable . create ( amb ( observable1 , observable2 , observable3 ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testAmb2 ( ) { IOException expectedException = new IOException ( <str> ) ; Observable < String > observable1 = createObservable ( new String [ ] { } , <int> , new IOException ( <str> ) ) ; Observable < String > observable2 = createObservable ( new String [ ] { <str> , <str> , <str> , <str> } , <int> , expectedException ) ; Observable < String > observable3 = createObservable ( new String [ ] { } , <int> , new IOException ( <str> ) ) ; Observable < String > o = Observable . create ( amb ( observable1 , observable2 , observable3 ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( expectedException ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testAmb3 ( ) { Observable < String > observable1 = createObservable ( new String [ ] { <str> } , <int> , null ) ; Observable < String > observable2 = createObservable ( new String [ ] { } , <int> , null ) ; Observable < String > observable3 = createObservable ( new String [ ] { <str> } , <int> , null ) ; Observable < String > o = Observable . create ( amb ( observable1 , observable2 , observable3 ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testProducerRequestThroughAmb ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; ts . requestMore ( <int> ) ; final AtomicLong requested1 = new AtomicLong ( ) ; final AtomicLong requested2 = new AtomicLong ( ) ; Observable < Integer > o1 = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( Subscriber < ? super Integer > s ) { s . setProducer ( new Producer ( ) { @Override public void request ( long n ) { System . out . println ( <str> + n ) ; requested1 . set ( n ) ; } } ) ; } } ) ; Observable < Integer > o2 = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( Subscriber < ? super Integer > s ) { s . setProducer ( new Producer ( ) { @Override public void request ( long n ) { System . out . println ( <str> + n ) ; requested2 . set ( n ) ; } } ) ; } } ) ; Observable . amb ( o1 , o2 ) . subscribe ( ts ) ; assertEquals ( <int> , requested1 . get ( ) ) ; assertEquals ( <int> , requested2 . get ( ) ) ; } @Test public void testBackpressure ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . range ( <int> , RxRingBuffer . SIZE * <int> ) . ambWith ( Observable . range ( <int> , RxRingBuffer . SIZE * <int> ) ) . observeOn ( Schedulers . computation ( ) ) . delay ( <int> , TimeUnit . MICROSECONDS ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( RxRingBuffer . SIZE * <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void testSubscriptionOnlyHappensOnce ( ) throws InterruptedException { final AtomicLong count = new AtomicLong ( ) ; Action0 incrementer = new Action0 ( ) { @Override public void call ( ) { count . incrementAndGet ( ) ; } } ; Observable < Integer > o1 = Observable . just ( <int> ) . doOnSubscribe ( incrementer ) . delay ( <int> , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable < Integer > o2 = Observable . just ( <int> ) . doOnSubscribe ( incrementer ) . delay ( <int> , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . amb ( o1 , o2 ) . subscribe ( ts ) ; ts . requestMore ( <int> ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , count . get ( ) ) ; } @Test public void testSecondaryRequestsPropagatedToChildren ( ) throws InterruptedException { Observable < Integer > o1 = Observable . from ( Arrays . asList ( <int> , <int> , <int> ) ) . delay ( <int> , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable < Integer > o2 = Observable . from ( Arrays . asList ( <int> , <int> , <int> ) ) . delay ( <int> , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } } ; Observable . amb ( o1 , o2 ) . subscribe ( ts ) ; ts . requestMore ( <int> ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; } @Test public void testSynchronousSources ( ) { int result = Observable . just ( <int> ) . doOnNext ( new Action1 < Object > ( ) { @Override public void call ( Object t ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } ) . ambWith ( Observable . just ( <int> ) ) . toBlocking ( ) . single ( ) ; assertEquals ( <int> , result ) ; } } 
