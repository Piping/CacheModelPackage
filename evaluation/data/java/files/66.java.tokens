package org . elasticsearch . index . mapper . geo ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . Version ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . util . ByteUtils ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . support . XContentMapValues ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . DoubleFieldMapper ; import org . elasticsearch . index . mapper . core . NumberFieldMapper . CustomNumericDocValuesField ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . object . ArrayValueMapperParser ; import java . io . IOException ; import java . util . Iterator ; import java . util . Map ; public class GeoPointFieldMapperLegacy extends BaseGeoPointFieldMapper implements ArrayValueMapperParser { public static final String CONTENT_TYPE = <str> ; public static class Names extends BaseGeoPointFieldMapper . Names { public static final String COERCE = <str> ; } public static class Defaults extends BaseGeoPointFieldMapper . Defaults { public static final Explicit < Boolean > COERCE = new Explicit ( false , false ) ; public static final GeoPointFieldType FIELD_TYPE = new GeoPointFieldType ( ) ; static { FIELD_TYPE . setIndexOptions ( IndexOptions . DOCS ) ; FIELD_TYPE . setTokenized ( false ) ; FIELD_TYPE . setOmitNorms ( true ) ; FIELD_TYPE . freeze ( ) ; } } public static class Builder extends BaseGeoPointFieldMapper . Builder < Builder , GeoPointFieldMapperLegacy > { private Boolean coerce ; public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE ) ; this . builder = this ; } public Builder coerce ( boolean coerce ) { this . coerce = coerce ; return builder ; } protected Explicit < Boolean > coerce ( BuilderContext context ) { if ( coerce ! = null ) { return new Explicit < > ( coerce , true ) ; } if ( context . indexSettings ( ) ! = null ) { return new Explicit < > ( context . indexSettings ( ) . getAsBoolean ( <str> , Defaults . COERCE . value ( ) ) , false ) ; } return Defaults . COERCE ; } @Override public GeoPointFieldMapperLegacy build ( BuilderContext context , String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , CopyTo copyTo ) { fieldType . setTokenized ( false ) ; setupFieldType ( context ) ; fieldType . setHasDocValues ( false ) ; defaultFieldType . setHasDocValues ( false ) ; return new GeoPointFieldMapperLegacy ( simpleName , fieldType , defaultFieldType , indexSettings , pathType , latMapper , lonMapper , geoHashMapper , multiFields , ignoreMalformed , coerce ( context ) , copyTo ) ; } @Override public GeoPointFieldMapperLegacy build ( BuilderContext context ) { return super . build ( context ) ; } } public static Builder parse ( Builder builder , Map < String , Object > node , Mapper . TypeParser . ParserContext parserContext ) throws MapperParsingException { final boolean indexCreatedBeforeV2_0 = parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0 ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . ignoreMalformed = ! XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . ignoreMalformed = ! XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . ignoreMalformed = ! XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( propName . equals ( Names . COERCE ) ) { builder . coerce = XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . coerce = XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . coerce = XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } else if ( indexCreatedBeforeV2_0 & & propName . equals ( <str> ) ) { builder . coerce = XContentMapValues . nodeBooleanValue ( propNode ) ; iterator . remove ( ) ; } } return builder ; } public static final class Encoding { private static final int MAX_NUM_BYTES = <int> ; private static final Encoding [ ] INSTANCES ; static { INSTANCES = new Encoding [ MAX_NUM_BYTES + <int> ] ; for ( int numBytes = <int> ; numBytes < = MAX_NUM_BYTES ; numBytes + = <int> ) { INSTANCES [ numBytes ] = new Encoding ( numBytes ) ; } } public static final Encoding of ( int numBytesPerValue ) { final Encoding instance = INSTANCES [ numBytesPerValue ] ; if ( instance = = null ) { throw new IllegalStateException ( <str> + numBytesPerValue + <str> ) ; } return instance ; } public static final Encoding of ( DistanceUnit . Distance precision ) { for ( Encoding encoding : INSTANCES ) { if ( encoding ! = null & & encoding . precision ( ) . compareTo ( precision ) < = <int> ) { return encoding ; } } return INSTANCES [ MAX_NUM_BYTES ] ; } private final DistanceUnit . Distance precision ; private final int numBytes ; private final int numBytesPerCoordinate ; private final double factor ; private Encoding ( int numBytes ) { assert numBytes > = <int> & & numBytes < = MAX_NUM_BYTES ; assert ( numBytes & <int> ) = = <int> ; this . numBytes = numBytes ; this . numBytesPerCoordinate = numBytes / <int> ; this . factor = Math . pow ( <int> , - numBytesPerCoordinate * <int> + <int> ) ; assert ( <int> < < ( numBytesPerCoordinate * <int> - <int> ) ) * factor > <int> & & ( <int> < < ( numBytesPerCoordinate * <int> - <int> ) ) * factor < <int> : numBytesPerCoordinate + <str> + factor ; if ( numBytes = = MAX_NUM_BYTES ) { precision = new DistanceUnit . Distance ( <int> , DistanceUnit . DEFAULT ) ; } else { precision = new DistanceUnit . Distance ( GeoDistance . PLANE . calculate ( <int> , <int> , factor / <int> , factor / <int> , DistanceUnit . DEFAULT ) , DistanceUnit . DEFAULT ) ; } } public DistanceUnit . Distance precision ( ) { return precision ; } public final int numBytes ( ) { return numBytes ; } public int numBitsPerCoordinate ( ) { return numBytesPerCoordinate < < <int> ; } public long encodeCoordinate ( double lat ) { return Math . round ( ( lat + <int> ) / factor ) ; } public double decodeCoordinate ( long bits ) { return bits * factor - <int> ; } private void encodeBits ( long bits , byte [ ] out , int offset ) { for ( int i = <int> ; i < numBytesPerCoordinate ; + + i ) { out [ offset + + ] = ( byte ) bits ; bits > > > = <int> ; } assert bits = = <int> ; } private long decodeBits ( byte [ ] in , int offset ) { long r = in [ offset + + ] & <hex> L ; for ( int i = <int> ; i < numBytesPerCoordinate ; + + i ) { r = ( in [ offset + + ] & <hex> L ) < < ( i * <int> ) ; } return r ; } public void encode ( double lat , double lon , byte [ ] out , int offset ) { encodeBits ( encodeCoordinate ( lat ) , out , offset ) ; encodeBits ( encodeCoordinate ( lon ) , out , offset + numBytesPerCoordinate ) ; } public GeoPoint decode ( byte [ ] in , int offset , GeoPoint out ) { final long latBits = decodeBits ( in , offset ) ; final long lonBits = decodeBits ( in , offset + numBytesPerCoordinate ) ; return decode ( latBits , lonBits , out ) ; } public GeoPoint decode ( long latBits , long lonBits , GeoPoint out ) { final double lat = decodeCoordinate ( latBits ) ; final double lon = decodeCoordinate ( lonBits ) ; return out . reset ( lat , lon ) ; } } protected Explicit < Boolean > coerce ; public GeoPointFieldMapperLegacy ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , Explicit < Boolean > coerce , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , indexSettings , pathType , latMapper , lonMapper , geoHashMapper , multiFields , ignoreMalformed , copyTo ) ; this . coerce = coerce ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { super . merge ( mergeWith , mergeResult ) ; if ( ! this . getClass ( ) . equals ( mergeWith . getClass ( ) ) ) { return ; } GeoPointFieldMapperLegacy gpfmMergeWith = ( GeoPointFieldMapperLegacy ) mergeWith ; if ( gpfmMergeWith . coerce . explicit ( ) ) { if ( coerce . explicit ( ) & & coerce . value ( ) ! = gpfmMergeWith . coerce . value ( ) ) { mergeResult . addConflict ( <str> + fieldType ( ) . names ( ) . fullName ( ) + <str> ) ; } } if ( mergeResult . simulate ( ) = = false & & mergeResult . hasConflicts ( ) = = false ) { if ( gpfmMergeWith . coerce . explicit ( ) ) { this . coerce = gpfmMergeWith . coerce ; } } } @Override protected void parse ( ParseContext context , GeoPoint point , String geoHash ) throws IOException { boolean validPoint = false ; if ( coerce . value ( ) = = false & & ignoreMalformed . value ( ) = = false ) { if ( point . lat ( ) > <float> | | point . lat ( ) < - <float> ) { throw new IllegalArgumentException ( <str> + point . lat ( ) + <str> + name ( ) ) ; } if ( point . lon ( ) > <float> | | point . lon ( ) < - <int> ) { throw new IllegalArgumentException ( <str> + point . lon ( ) + <str> + name ( ) ) ; } validPoint = true ; } if ( coerce . value ( ) = = true & & validPoint = = false ) { GeoUtils . normalizePoint ( point , true , true ) ; } if ( fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE | | fieldType ( ) . stored ( ) ) { Field field = new Field ( fieldType ( ) . names ( ) . indexName ( ) , Double . toString ( point . lat ( ) ) + <str> + Double . toString ( point . lon ( ) ) , fieldType ( ) ) ; context . doc ( ) . add ( field ) ; } super . parse ( context , point , geoHash ) ; if ( fieldType ( ) . hasDocValues ( ) ) { CustomGeoPointDocValuesField field = ( CustomGeoPointDocValuesField ) context . doc ( ) . getByKey ( fieldType ( ) . names ( ) . indexName ( ) ) ; if ( field = = null ) { field = new CustomGeoPointDocValuesField ( fieldType ( ) . names ( ) . indexName ( ) , point . lat ( ) , point . lon ( ) ) ; context . doc ( ) . addWithKey ( fieldType ( ) . names ( ) . indexName ( ) , field ) ; } else { field . add ( point . lat ( ) , point . lon ( ) ) ; } } } @Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { super . doXContentBody ( builder , includeDefaults , params ) ; if ( includeDefaults | | coerce . explicit ( ) ) { builder . field ( Names . COERCE , coerce . value ( ) ) ; } } public static class CustomGeoPointDocValuesField extends CustomNumericDocValuesField { private final ObjectHashSet < GeoPoint > points ; public CustomGeoPointDocValuesField ( String name , double lat , double lon ) { super ( name ) ; points = new ObjectHashSet < > ( <int> ) ; points . add ( new GeoPoint ( lat , lon ) ) ; } public void add ( double lat , double lon ) { points . add ( new GeoPoint ( lat , lon ) ) ; } @Override public BytesRef binaryValue ( ) { final byte [ ] bytes = new byte [ points . size ( ) * <int> ] ; int off = <int> ; for ( Iterator < ObjectCursor < GeoPoint > > it = points . iterator ( ) ; it . hasNext ( ) ; ) { final GeoPoint point = it . next ( ) . value ; ByteUtils . writeDoubleLE ( point . getLat ( ) , bytes , off ) ; ByteUtils . writeDoubleLE ( point . getLon ( ) , bytes , off + <int> ) ; off + = <int> ; } return new BytesRef ( bytes ) ; } } } 
