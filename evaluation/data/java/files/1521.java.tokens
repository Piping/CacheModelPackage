package com . google . common . collect ; import static com . google . common . collect . BoundType . CLOSED ; import static com . google . common . collect . BoundType . OPEN ; import static com . google . common . collect . DiscreteDomain . integers ; import static com . google . common . collect . testing . features . CollectionFeature . ALLOWS_NULL_QUERIES ; import static com . google . common . collect . testing . features . CollectionFeature . KNOWN_ORDER ; import static com . google . common . collect . testing . features . CollectionFeature . NON_STANDARD_TOSTRING ; import static com . google . common . collect . testing . features . CollectionFeature . RESTRICTS_ELEMENTS ; import static com . google . common . collect . testing . testers . NavigableSetNavigationTester . getHoleMethods ; import static com . google . common . testing . SerializableTester . reserialize ; import static com . google . common . testing . SerializableTester . reserializeAndAssert ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . NavigableSetTestSuiteBuilder ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . google . SetGenerators . ContiguousSetDescendingGenerator ; import com . google . common . collect . testing . google . SetGenerators . ContiguousSetGenerator ; import com . google . common . collect . testing . google . SetGenerators . ContiguousSetHeadsetGenerator ; import com . google . common . collect . testing . google . SetGenerators . ContiguousSetSubsetGenerator ; import com . google . common . collect . testing . google . SetGenerators . ContiguousSetTailsetGenerator ; import com . google . common . testing . EqualsTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Collection ; import java . util . Set ; @GwtCompatible ( emulated = true ) public class ContiguousSetTest extends TestCase { private static final DiscreteDomain < Integer > NOT_EQUAL_TO_INTEGERS = new DiscreteDomain < Integer > ( ) { @Override public Integer next ( Integer value ) { return integers ( ) . next ( value ) ; } @Override public Integer previous ( Integer value ) { return integers ( ) . previous ( value ) ; } @Override public long distance ( Integer start , Integer end ) { return integers ( ) . distance ( start , end ) ; } @Override public Integer minValue ( ) { return integers ( ) . minValue ( ) ; } @Override public Integer maxValue ( ) { return integers ( ) . maxValue ( ) ; } } ; public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) , ContiguousSet . create ( Range . closed ( <int> , <int> ) , NOT_EQUAL_TO_INTEGERS ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , NOT_EQUAL_TO_INTEGERS ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , NOT_EQUAL_TO_INTEGERS ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , NOT_EQUAL_TO_INTEGERS ) , ImmutableSortedSet . of ( <int> , <int> , <int> ) ) . addEqualityGroup ( ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) , ImmutableSortedSet . of ( ) , ImmutableSet . of ( ) ) . testEquals ( ) ; assertEquals ( ContiguousSet . create ( Range . closed ( Integer . MIN_VALUE , Integer . MAX_VALUE ) , integers ( ) ) , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) ) ; assertEquals ( ContiguousSet . create ( Range . closed ( Integer . MIN_VALUE , Integer . MAX_VALUE ) , integers ( ) ) , ContiguousSet . create ( Range . atLeast ( Integer . MIN_VALUE ) , integers ( ) ) ) ; assertEquals ( ContiguousSet . create ( Range . closed ( Integer . MIN_VALUE , Integer . MAX_VALUE ) , integers ( ) ) , ContiguousSet . create ( Range . atMost ( Integer . MAX_VALUE ) , integers ( ) ) ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { ContiguousSet < Integer > empty = ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) ; assertTrue ( empty instanceof EmptyContiguousSet ) ; reserializeAndAssert ( empty ) ; ContiguousSet < Integer > regular = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertTrue ( regular instanceof RegularContiguousSet ) ; reserializeAndAssert ( regular ) ; ContiguousSet < Integer > enormous = ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) ; assertTrue ( enormous instanceof RegularContiguousSet ) ; ContiguousSet < Integer > enormousReserialized = reserialize ( enormous ) ; assertEquals ( enormous , enormousReserialized ) ; } public void testCreate_noMin ( ) { Range < Integer > range = Range . lessThan ( <int> ) ; try { ContiguousSet . create ( range , RangeTest . UNBOUNDED_DOMAIN ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCreate_noMax ( ) { Range < Integer > range = Range . greaterThan ( <int> ) ; try { ContiguousSet . create ( range , RangeTest . UNBOUNDED_DOMAIN ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCreate_empty ( ) { assertEquals ( ImmutableSet . of ( ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) ) ; assertEquals ( ImmutableSet . of ( ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) ) ; assertEquals ( ImmutableSet . of ( ) , ContiguousSet . create ( Range . lessThan ( Integer . MIN_VALUE ) , integers ( ) ) ) ; assertEquals ( ImmutableSet . of ( ) , ContiguousSet . create ( Range . greaterThan ( Integer . MAX_VALUE ) , integers ( ) ) ) ; } public void testHeadSet ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertThat ( set . headSet ( <int> ) ) . isEmpty ( ) ; assertThat ( set . headSet ( <int> ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( Integer . MAX_VALUE ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> , true ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> , true ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> , true ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( <int> , true ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . headSet ( Integer . MAX_VALUE , true ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; } public void testHeadSet_tooSmall ( ) { assertThat ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . headSet ( <int> ) ) . isEmpty ( ) ; } public void testTailSet ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertThat ( set . tailSet ( Integer . MIN_VALUE ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( Integer . MIN_VALUE , false ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> , false ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> , false ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . tailSet ( <int> , false ) ) . isEmpty ( ) ; } public void testTailSet_tooLarge ( ) { assertThat ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . tailSet ( <int> ) ) . isEmpty ( ) ; } public void testSubSet ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . isEmpty ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . containsExactly ( <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , <int> ) ) . isEmpty ( ) ; assertThat ( set . subSet ( Integer . MIN_VALUE , Integer . MAX_VALUE ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , true , <int> , true ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , false , <int> , true ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , true , <int> , false ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( set . subSet ( <int> , false , <int> , false ) ) . containsExactly ( <int> ) . inOrder ( ) ; } public void testSubSet_outOfOrder ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; try { set . subSet ( <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testSubSet_tooLarge ( ) { assertThat ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . subSet ( <int> , <int> ) ) . isEmpty ( ) ; } public void testSubSet_tooSmall ( ) { assertThat ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . subSet ( - <int> , <int> ) ) . isEmpty ( ) ; } public void testFirst ( ) { assertEquals ( <int> , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . first ( ) . intValue ( ) ) ; assertEquals ( <int> , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . first ( ) . intValue ( ) ) ; assertEquals ( Integer . MIN_VALUE , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . first ( ) . intValue ( ) ) ; } public void testLast ( ) { assertEquals ( <int> , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . last ( ) . intValue ( ) ) ; assertEquals ( <int> , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . last ( ) . intValue ( ) ) ; assertEquals ( Integer . MAX_VALUE , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . last ( ) . intValue ( ) ) ; } public void testContains ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertFalse ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertFalse ( set . contains ( <int> ) ) ; set = ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) ; assertFalse ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertTrue ( set . contains ( <int> ) ) ; assertFalse ( set . contains ( <int> ) ) ; assertFalse ( set . contains ( ( Object ) <str> ) ) ; } public void testContainsAll ( ) { ImmutableSortedSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; for ( Set < Integer > subset : Sets . powerSet ( ImmutableSet . of ( <int> , <int> , <int> ) ) ) { assertTrue ( set . containsAll ( subset ) ) ; } for ( Set < Integer > subset : Sets . powerSet ( ImmutableSet . of ( <int> , <int> , <int> ) ) ) { assertFalse ( set . containsAll ( Sets . union ( subset , ImmutableSet . of ( <int> ) ) ) ) ; } assertFalse ( set . containsAll ( ( Collection < ? > ) ImmutableSet . of ( <str> ) ) ) ; } public void testRange ( ) { assertEquals ( Range . closed ( <int> , <int> ) , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . range ( ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) . range ( ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . range ( ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) . range ( ) ) ; assertEquals ( Range . openClosed ( <int> , <int> ) , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . range ( OPEN , CLOSED ) ) ; assertEquals ( Range . openClosed ( <int> , <int> ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) . range ( OPEN , CLOSED ) ) ; assertEquals ( Range . openClosed ( <int> , <int> ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . range ( OPEN , CLOSED ) ) ; assertEquals ( Range . openClosed ( <int> , <int> ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) . range ( OPEN , CLOSED ) ) ; assertEquals ( Range . open ( <int> , <int> ) , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . range ( OPEN , OPEN ) ) ; assertEquals ( Range . open ( <int> , <int> ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) . range ( OPEN , OPEN ) ) ; assertEquals ( Range . open ( <int> , <int> ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . range ( OPEN , OPEN ) ) ; assertEquals ( Range . open ( <int> , <int> ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) . range ( OPEN , OPEN ) ) ; assertEquals ( Range . closedOpen ( <int> , <int> ) , ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) . range ( CLOSED , OPEN ) ) ; assertEquals ( Range . closedOpen ( <int> , <int> ) , ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) . range ( CLOSED , OPEN ) ) ; assertEquals ( Range . closedOpen ( <int> , <int> ) , ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) . range ( CLOSED , OPEN ) ) ; assertEquals ( Range . closedOpen ( <int> , <int> ) , ContiguousSet . create ( Range . openClosed ( <int> , <int> ) , integers ( ) ) . range ( CLOSED , OPEN ) ) ; } public void testRange_unboundedRange ( ) { assertEquals ( Range . closed ( Integer . MIN_VALUE , Integer . MAX_VALUE ) , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . range ( ) ) ; assertEquals ( Range . atLeast ( Integer . MIN_VALUE ) , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . range ( CLOSED , OPEN ) ) ; assertEquals ( Range . all ( ) , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . range ( OPEN , OPEN ) ) ; assertEquals ( Range . atMost ( Integer . MAX_VALUE ) , ContiguousSet . create ( Range . < Integer > all ( ) , integers ( ) ) . range ( OPEN , CLOSED ) ) ; } public void testIntersection_empty ( ) { ContiguousSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; ContiguousSet < Integer > emptySet = ContiguousSet . create ( Range . closedOpen ( <int> , <int> ) , integers ( ) ) ; assertEquals ( ImmutableSet . of ( ) , set . intersection ( emptySet ) ) ; assertEquals ( ImmutableSet . of ( ) , emptySet . intersection ( set ) ) ; assertEquals ( ImmutableSet . of ( ) , ContiguousSet . create ( Range . closed ( - <int> , - <int> ) , integers ( ) ) . intersection ( ContiguousSet . create ( Range . open ( <int> , <int> ) , integers ( ) ) ) ) ; } public void testIntersection ( ) { ContiguousSet < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> , <int> ) , ContiguousSet . create ( Range . open ( - <int> , <int> ) , integers ( ) ) . intersection ( set ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> , <int> ) , set . intersection ( ContiguousSet . create ( Range . open ( - <int> , <int> ) , integers ( ) ) ) ) ; assertEquals ( ImmutableSet . of ( <int> ) , set . intersection ( ContiguousSet . create ( Range . closed ( <int> , <int> ) , integers ( ) ) ) ) ; } @GwtIncompatible ( <str> ) public static class BuiltTests extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ContiguousSetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , KNOWN_ORDER , ALLOWS_NULL_QUERIES , NON_STANDARD_TOSTRING , RESTRICTS_ELEMENTS ) . suppressing ( getHoleMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ContiguousSetHeadsetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , KNOWN_ORDER , ALLOWS_NULL_QUERIES , NON_STANDARD_TOSTRING , RESTRICTS_ELEMENTS ) . suppressing ( getHoleMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ContiguousSetTailsetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , KNOWN_ORDER , ALLOWS_NULL_QUERIES , NON_STANDARD_TOSTRING , RESTRICTS_ELEMENTS ) . suppressing ( getHoleMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ContiguousSetSubsetGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , KNOWN_ORDER , ALLOWS_NULL_QUERIES , NON_STANDARD_TOSTRING , RESTRICTS_ELEMENTS ) . suppressing ( getHoleMethods ( ) ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ContiguousSetDescendingGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , KNOWN_ORDER , ALLOWS_NULL_QUERIES , NON_STANDARD_TOSTRING , RESTRICTS_ELEMENTS ) . suppressing ( getHoleMethods ( ) ) . createTestSuite ( ) ) ; return suite ; } } }