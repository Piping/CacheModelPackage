package rx . internal . util ; import java . util . * ; import rx . Subscription ; import rx . exceptions . Exceptions ; public final class SubscriptionList implements Subscription { private LinkedList < Subscription > subscriptions ; private volatile boolean unsubscribed ; public SubscriptionList ( ) { } public SubscriptionList ( final Subscription . . . subscriptions ) { this . subscriptions = new LinkedList < Subscription > ( Arrays . asList ( subscriptions ) ) ; } public SubscriptionList ( Subscription s ) { this . subscriptions = new LinkedList < Subscription > ( ) ; this . subscriptions . add ( s ) ; } @Override public boolean isUnsubscribed ( ) { return unsubscribed ; } public void add ( final Subscription s ) { if ( s . isUnsubscribed ( ) ) { return ; } if ( ! unsubscribed ) { synchronized ( this ) { if ( ! unsubscribed ) { LinkedList < Subscription > subs = subscriptions ; if ( subs = = null ) { subs = new LinkedList < Subscription > ( ) ; subscriptions = subs ; } subs . add ( s ) ; return ; } } } s . unsubscribe ( ) ; } public void remove ( final Subscription s ) { if ( ! unsubscribed ) { boolean unsubscribe = false ; synchronized ( this ) { LinkedList < Subscription > subs = subscriptions ; if ( unsubscribed | | subs = = null ) { return ; } unsubscribe = subs . remove ( s ) ; } if ( unsubscribe ) { s . unsubscribe ( ) ; } } } @Override public void unsubscribe ( ) { if ( ! unsubscribed ) { List < Subscription > list ; synchronized ( this ) { if ( unsubscribed ) { return ; } unsubscribed = true ; list = subscriptions ; subscriptions = null ; } unsubscribeFromAll ( list ) ; } } private static void unsubscribeFromAll ( Collection < Subscription > subscriptions ) { if ( subscriptions = = null ) { return ; } List < Throwable > es = null ; for ( Subscription s : subscriptions ) { try { s . unsubscribe ( ) ; } catch ( Throwable e ) { if ( es = = null ) { es = new ArrayList < Throwable > ( ) ; } es . add ( e ) ; } } Exceptions . throwIfAny ( es ) ; } public void clear ( ) { if ( ! unsubscribed ) { List < Subscription > list ; synchronized ( this ) { list = subscriptions ; subscriptions = null ; } unsubscribeFromAll ( list ) ; } } public boolean hasSubscriptions ( ) { if ( ! unsubscribed ) { synchronized ( this ) { return ! unsubscribed & & subscriptions ! = null & & ! subscriptions . isEmpty ( ) ; } } return false ; } } 
