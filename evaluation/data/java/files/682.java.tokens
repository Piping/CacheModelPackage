package org . elasticsearch . search . geo ; import com . spatial4j . core . context . SpatialContext ; import com . spatial4j . core . distance . DistanceUtils ; import com . spatial4j . core . exception . InvalidShapeException ; import com . spatial4j . core . shape . Shape ; import org . apache . lucene . spatial . prefix . RecursivePrefixTreeStrategy ; import org . apache . lucene . spatial . prefix . tree . GeohashPrefixTree ; import org . apache . lucene . spatial . query . SpatialArgs ; import org . apache . lucene . spatial . query . SpatialOperation ; import org . apache . lucene . spatial . query . UnsupportedSpatialOperation ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . GeoProjectionUtils ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . action . bulk . BulkItemResponse ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . builders . LineStringBuilder ; import org . elasticsearch . common . geo . builders . MultiPolygonBuilder ; import org . elasticsearch . common . geo . builders . PolygonBuilder ; import org . elasticsearch . common . geo . builders . ShapeBuilders ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . query . GeohashCellQuery ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . VersionUtils ; import org . junit . BeforeClass ; import java . io . ByteArrayOutputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Random ; import java . util . zip . GZIPInputStream ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . geoBoundingBoxQuery ; import static org . elasticsearch . index . query . QueryBuilders . geoDistanceQuery ; import static org . elasticsearch . index . query . QueryBuilders . geoHashCellQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertFirstHit ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchHits ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . hasId ; import static org . hamcrest . Matchers . * ; public class GeoFilterIT extends ESIntegTestCase { private static boolean intersectSupport ; private static boolean disjointSupport ; private static boolean withinSupport ; @BeforeClass public static void createNodes ( ) throws Exception { intersectSupport = testRelationSupport ( SpatialOperation . Intersects ) ; disjointSupport = testRelationSupport ( SpatialOperation . IsDisjointTo ) ; withinSupport = testRelationSupport ( SpatialOperation . IsWithin ) ; } private static byte [ ] unZipData ( String path ) throws IOException { InputStream is = Streams . class . getResourceAsStream ( path ) ; if ( is = = null ) { throw new FileNotFoundException ( <str> + path + <str> ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; GZIPInputStream in = new GZIPInputStream ( is ) ; Streams . copy ( in , out ) ; is . close ( ) ; out . close ( ) ; return out . toByteArray ( ) ; } public void testShapeBuilders ( ) { try { ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( <int> , <int> ) . point ( - <int> , <int> ) . point ( <int> , - <int> ) . close ( ) . build ( ) ; fail ( <str> ) ; } catch ( InvalidShapeException e ) { } ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) . build ( ) ; try { ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) . build ( ) ; fail ( <str> ) ; } catch ( InvalidShapeException e ) { } try { ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( <int> , - <int> ) . point ( <int> , - <int> ) . point ( - <int> , - <int> ) . close ( ) ) . close ( ) . build ( ) ; fail ( <str> ) ; } catch ( InvalidShapeException e ) { } try { ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( - <int> , <int> ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) . build ( ) ; fail ( <str> ) ; } catch ( InvalidShapeException e ) { } ShapeBuilders . newMultiPolygon ( ) . polygon ( new PolygonBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) ) . polygon ( new PolygonBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . build ( ) ; } public void testShapeRelations ( ) throws Exception { assertTrue ( <str> , intersectSupport ) ; assertTrue ( <str> , disjointSupport ) ; assertTrue ( <str> , withinSupport ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; CreateIndexRequestBuilder mappingRequest = client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , mapping ) ; mappingRequest . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; MultiPolygonBuilder polygon = ShapeBuilders . newMultiPolygon ( ) . polygon ( new PolygonBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) ) . polygon ( new PolygonBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) ; BytesReference data = jsonBuilder ( ) . startObject ( ) . field ( <str> , polygon ) . endObject ( ) . bytes ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( data ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; SearchResponse result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <int> , <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; assertFirstHit ( result , hasId ( <str> ) ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <float> , <float> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <float> , <float> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; assertFirstHit ( result , hasId ( <str> ) ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <float> , <float> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; assertFirstHit ( result , hasId ( <str> ) ) ; if ( disjointSupport ) { result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoDisjointQuery ( <str> , ShapeBuilders . newPoint ( <int> , <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoDisjointQuery ( <str> , ShapeBuilders . newPoint ( <float> , <float> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; assertFirstHit ( result , hasId ( <str> ) ) ; } PolygonBuilder inverse = ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) ; data = jsonBuilder ( ) . startObject ( ) . field ( <str> , inverse ) . endObject ( ) . bytes ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( data ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <float> , <float> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; assertFirstHit ( result , hasId ( <str> ) ) ; PolygonBuilder builder = ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . hole ( new LineStringBuilder ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ) . close ( ) ; if ( withinSupport ) { builder = ShapeBuilders . newPolygon ( ) . point ( - <int> , - <int> ) . point ( - <int> , <int> ) . point ( <int> , <int> ) . point ( <int> , - <int> ) . close ( ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoWithinQuery ( <str> , builder ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; } builder = ShapeBuilders . newPolygon ( ) . point ( <int> , - <int> ) . point ( <int> , - <int> ) . point ( <int> , <int> ) . point ( <int> , <int> ) . close ( ) ; data = jsonBuilder ( ) . startObject ( ) . field ( <str> , builder ) . endObject ( ) . bytes ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( data ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; builder = ShapeBuilders . newPolygon ( ) . point ( <int> , - <int> ) . point ( <int> , - <int> ) . point ( <int> , <int> ) . point ( <int> , <int> ) . hole ( new LineStringBuilder ( ) . point ( <int> , - <int> ) . point ( <int> , - <int> ) . point ( <int> , <int> ) . point ( <int> , <int> ) . close ( ) ) . close ( ) ; data = jsonBuilder ( ) . startObject ( ) . field ( <str> , builder ) . endObject ( ) . bytes ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( data ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <int> , - <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( - <int> , - <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <int> , - <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; result = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( QueryBuilders . geoIntersectionQuery ( <str> , ShapeBuilders . newPoint ( <int> , - <int> ) ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( result , <int> ) ; } public void testBulk ( ) throws Exception { byte [ ] bulkAction = unZipData ( <str> ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_2_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; XContentBuilder xContentBuilder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) ; if ( version . before ( Version . V_2_2_0 ) ) { xContentBuilder . field ( <str> , true ) ; } xContentBuilder . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , xContentBuilder . string ( ) ) . execute ( ) . actionGet ( ) ; BulkResponse bulk = client ( ) . prepareBulk ( ) . add ( bulkAction , <int> , bulkAction . length , null , null ) . execute ( ) . actionGet ( ) ; for ( BulkItemResponse item : bulk . getItems ( ) ) { assertFalse ( <str> , item . isFailed ( ) ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; String key = <str> ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchQuery ( <str> , key ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( searchResponse , <int> ) ; for ( SearchHit hit : searchResponse . getHits ( ) ) { assertThat ( hit . getId ( ) , equalTo ( key ) ) ; } SearchResponse world = client ( ) . prepareSearch ( ) . addField ( <str> ) . setQuery ( geoBoundingBoxQuery ( <str> ) . setCorners ( <int> , - <float> , - <int> , <float> ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( world , <int> ) ; SearchResponse distance = client ( ) . prepareSearch ( ) . addField ( <str> ) . setQuery ( geoDistanceQuery ( <str> ) . distance ( <str> ) . point ( <float> , <float> ) ) . execute ( ) . actionGet ( ) ; assertHitCount ( distance , <int> ) ; GeoPoint point = new GeoPoint ( ) ; for ( SearchHit hit : distance . getHits ( ) ) { String name = hit . getId ( ) ; if ( version . before ( Version . V_2_2_0 ) ) { point . resetFromString ( hit . fields ( ) . get ( <str> ) . getValue ( ) . toString ( ) ) ; } else { point . resetFromIndexHash ( hit . fields ( ) . get ( <str> ) . getValue ( ) ) ; } double dist = distance ( point . getLat ( ) , point . getLon ( ) , <float> , <float> ) ; assertThat ( <str> + name + <str> , dist , lessThanOrEqualTo ( <int> d ) ) ; assertThat ( name , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) , equalTo ( <str> ) , equalTo ( <str> ) , equalTo ( <str> ) ) ) ; if ( key . equals ( name ) ) { assertThat ( dist , closeTo ( <int> d , <float> ) ) ; } } } public void testGeohashCellFilter ( ) throws IOException { String geohash = randomhash ( <int> ) ; logger . info ( <str> , geohash ) ; Collection < ? extends CharSequence > neighbors = GeoHashUtils . neighbors ( geohash ) ; Collection < ? extends CharSequence > parentNeighbors = GeoHashUtils . neighbors ( geohash . substring ( <int> , geohash . length ( ) - <int> ) ) ; logger . info ( <str> , neighbors ) ; logger . info ( <str> , parentNeighbors ) ; ensureYellow ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setCreate ( true ) . setSource ( <str> , geohash ) . execute ( ) . actionGet ( ) ; Iterator < ? extends CharSequence > iterator = neighbors . iterator ( ) ; for ( int i = <int> ; iterator . hasNext ( ) ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setCreate ( true ) . setSource ( <str> , iterator . next ( ) ) . execute ( ) . actionGet ( ) ; } client ( ) . prepareIndex ( <str> , <str> , <str> ) . setCreate ( true ) . setSource ( <str> , geohash . substring ( <int> , geohash . length ( ) - <int> ) ) . execute ( ) . actionGet ( ) ; iterator = parentNeighbors . iterator ( ) ; for ( int i = <int> ; iterator . hasNext ( ) ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setCreate ( true ) . setSource ( <str> , iterator . next ( ) ) . execute ( ) . actionGet ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . actionGet ( ) ; Map < GeohashCellQuery . Builder , Long > expectedCounts = new HashMap < > ( ) ; Map < GeohashCellQuery . Builder , String [ ] > expectedResults = new HashMap < > ( ) ; expectedCounts . put ( geoHashCellQuery ( <str> , geohash , false ) , <int> ) ; expectedCounts . put ( geoHashCellQuery ( <str> , geohash . substring ( <int> , geohash . length ( ) - <int> ) , true ) , <int> + neighbors . size ( ) + parentNeighbors . size ( ) ) ; GeoPoint point = GeoPoint . fromGeohash ( geohash ) ; int precision = geohash . length ( ) ; expectedCounts . put ( geoHashCellQuery ( <str> , point ) . neighbors ( true ) . precision ( precision ) , <int> + neighbors . size ( ) ) ; List < GeohashCellQuery . Builder > filterBuilders = new ArrayList < > ( expectedCounts . keySet ( ) ) ; for ( GeohashCellQuery . Builder builder : filterBuilders ) { try { long expectedCount = expectedCounts . get ( builder ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . setPostFilter ( builder ) . setSize ( ( int ) expectedCount ) . get ( ) ; assertHitCount ( response , expectedCount ) ; String [ ] expectedIds = expectedResults . get ( builder ) ; if ( expectedIds = = null ) { ArrayList < String > ids = new ArrayList < > ( ) ; for ( SearchHit hit : response . getHits ( ) ) { ids . add ( hit . id ( ) ) ; } expectedResults . put ( builder , ids . toArray ( Strings . EMPTY_ARRAY ) ) ; continue ; } assertSearchHits ( response , expectedIds ) ; } catch ( AssertionError error ) { throw new AssertionError ( error . getMessage ( ) + <str> + builder , error ) ; } } } public void testNeighbors ( ) { assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( GeoHashUtils . addNeighbors ( <str> , new ArrayList < String > ( ) ) , containsInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; } public static double distance ( double lat1 , double lon1 , double lat2 , double lon2 ) { return GeoProjectionUtils . SEMIMAJOR_AXIS * DistanceUtils . distHaversineRAD ( DistanceUtils . toRadians ( lat1 ) , DistanceUtils . toRadians ( lon1 ) , DistanceUtils . toRadians ( lat2 ) , DistanceUtils . toRadians ( lon2 ) ) ; } protected static boolean testRelationSupport ( SpatialOperation relation ) { if ( relation = = SpatialOperation . IsDisjointTo ) { relation = SpatialOperation . Intersects ; } try { GeohashPrefixTree tree = new GeohashPrefixTree ( SpatialContext . GEO , <int> ) ; RecursivePrefixTreeStrategy strategy = new RecursivePrefixTreeStrategy ( tree , <str> ) ; Shape shape = SpatialContext . GEO . makePoint ( <int> , <int> ) ; SpatialArgs args = new SpatialArgs ( relation , shape ) ; strategy . makeQuery ( args ) ; return true ; } catch ( UnsupportedSpatialOperation e ) { e . printStackTrace ( ) ; return false ; } } protected static String randomhash ( int length ) { return randomhash ( getRandom ( ) , length ) ; } protected static String randomhash ( Random random ) { return randomhash ( random , <int> + random . nextInt ( <int> ) ) ; } protected static String randomhash ( ) { return randomhash ( getRandom ( ) ) ; } protected static String randomhash ( Random random , int length ) { final char [ ] BASE_32 = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < length ; i + + ) { sb . append ( BASE_32 [ random . nextInt ( BASE_32 . length ) ] ) ; } return sb . toString ( ) ; } } 
