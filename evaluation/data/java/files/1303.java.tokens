package com . google . common . math ; import static com . google . common . math . MathBenchmarking . ARRAY_MASK ; import static com . google . common . math . MathBenchmarking . ARRAY_SIZE ; import static com . google . common . math . MathBenchmarking . RANDOM_SOURCE ; import static com . google . common . math . MathBenchmarking . randomBigInteger ; import static com . google . common . math . MathBenchmarking . randomNonNegativeBigInteger ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . math . DoubleMath ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; public class ApacheBenchmark { private enum Impl { GUAVA { @Override public double factorialDouble ( int n ) { return DoubleMath . factorial ( n ) ; } @Override public int gcdInt ( int a , int b ) { return IntMath . gcd ( a , b ) ; } @Override public long gcdLong ( long a , long b ) { return LongMath . gcd ( a , b ) ; } @Override public long binomialCoefficient ( int n , int k ) { return LongMath . binomial ( n , k ) ; } @Override public boolean noAddOverflow ( int a , int b ) { try { IntMath . checkedAdd ( a , b ) ; return true ; } catch ( ArithmeticException e ) { return false ; } } @Override public boolean noAddOverflow ( long a , long b ) { try { LongMath . checkedAdd ( a , b ) ; return true ; } catch ( ArithmeticException e ) { return false ; } } @Override public boolean noMulOverflow ( int a , int b ) { try { IntMath . checkedMultiply ( a , b ) ; return true ; } catch ( ArithmeticException e ) { return false ; } } @Override public boolean noMulOverflow ( long a , long b ) { try { LongMath . checkedMultiply ( a , b ) ; return true ; } catch ( ArithmeticException e ) { return false ; } } } ; public abstract double factorialDouble ( int n ) ; public abstract long binomialCoefficient ( int n , int k ) ; public abstract int gcdInt ( int a , int b ) ; public abstract long gcdLong ( long a , long b ) ; public abstract boolean noAddOverflow ( int a , int b ) ; public abstract boolean noAddOverflow ( long a , long b ) ; public abstract boolean noMulOverflow ( int a , int b ) ; public abstract boolean noMulOverflow ( long a , long b ) ; } private final int [ ] factorials = new int [ ARRAY_SIZE ] ; private final int [ ] [ ] binomials = new int [ ARRAY_SIZE ] [ <int> ] ; private final int [ ] [ ] nonnegInt = new int [ ARRAY_SIZE ] [ <int> ] ; private final long [ ] [ ] nonnegLong = new long [ ARRAY_SIZE ] [ <int> ] ; private final int [ ] [ ] intsToAdd = new int [ ARRAY_SIZE ] [ <int> ] ; private final int [ ] [ ] intsToMul = new int [ ARRAY_SIZE ] [ <int> ] ; private final long [ ] [ ] longsToAdd = new long [ ARRAY_SIZE ] [ <int> ] ; private final long [ ] [ ] longsToMul = new long [ ARRAY_SIZE ] [ <int> ] ; @Param ( { <str> , <str> } ) Impl impl ; @BeforeExperiment void setUp ( ) { for ( int i = <int> ; i < ARRAY_SIZE ; i + + ) { factorials [ i ] = RANDOM_SOURCE . nextInt ( <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { nonnegInt [ i ] [ j ] = randomNonNegativeBigInteger ( Integer . SIZE - <int> ) . intValue ( ) ; nonnegLong [ i ] [ j ] = randomNonNegativeBigInteger ( Long . SIZE - <int> ) . longValue ( ) ; } do { for ( int j = <int> ; j < <int> ; j + + ) { intsToAdd [ i ] [ j ] = randomBigInteger ( Integer . SIZE - <int> ) . intValue ( ) ; } } while ( ! Impl . GUAVA . noAddOverflow ( intsToAdd [ i ] [ <int> ] , intsToAdd [ i ] [ <int> ] ) ) ; do { for ( int j = <int> ; j < <int> ; j + + ) { longsToAdd [ i ] [ j ] = randomBigInteger ( Long . SIZE - <int> ) . longValue ( ) ; } } while ( ! Impl . GUAVA . noAddOverflow ( longsToAdd [ i ] [ <int> ] , longsToAdd [ i ] [ <int> ] ) ) ; do { for ( int j = <int> ; j < <int> ; j + + ) { intsToMul [ i ] [ j ] = randomBigInteger ( Integer . SIZE - <int> ) . intValue ( ) ; } } while ( ! Impl . GUAVA . noMulOverflow ( intsToMul [ i ] [ <int> ] , intsToMul [ i ] [ <int> ] ) ) ; do { for ( int j = <int> ; j < <int> ; j + + ) { longsToMul [ i ] [ j ] = randomBigInteger ( Long . SIZE - <int> ) . longValue ( ) ; } } while ( ! Impl . GUAVA . noMulOverflow ( longsToMul [ i ] [ <int> ] , longsToMul [ i ] [ <int> ] ) ) ; int k = binomials [ i ] [ <int> ] = RANDOM_SOURCE . nextInt ( MathBenchmarking . biggestBinomials . length ) ; binomials [ i ] [ <int> ] = RANDOM_SOURCE . nextInt ( MathBenchmarking . biggestBinomials [ k ] - k ) + k ; } } @Benchmark long factorialDouble ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = Double . doubleToRawLongBits ( impl . factorialDouble ( factorials [ j ] ) ) ; } return tmp ; } @Benchmark int intGCD ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = impl . gcdInt ( nonnegInt [ j ] [ <int> ] , nonnegInt [ j ] [ <int> ] ) ; } return tmp ; } @Benchmark long longGCD ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = impl . gcdLong ( nonnegLong [ j ] [ <int> ] , nonnegLong [ j ] [ <int> ] ) ; } return tmp ; } @Benchmark long binomialCoefficient ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = impl . binomialCoefficient ( binomials [ j ] [ <int> ] , binomials [ j ] [ <int> ] ) ; } return tmp ; } @Benchmark int intAddOverflow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; if ( impl . noAddOverflow ( intsToAdd [ j ] [ <int> ] , intsToAdd [ j ] [ <int> ] ) ) { tmp + + ; } } return tmp ; } @Benchmark int longAddOverflow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; if ( impl . noAddOverflow ( longsToAdd [ j ] [ <int> ] , longsToAdd [ j ] [ <int> ] ) ) { tmp + + ; } } return tmp ; } @Benchmark int intMulOverflow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; if ( impl . noMulOverflow ( intsToMul [ j ] [ <int> ] , intsToMul [ j ] [ <int> ] ) ) { tmp + + ; } } return tmp ; } @Benchmark int longMulOverflow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; if ( impl . noMulOverflow ( longsToMul [ j ] [ <int> ] , longsToMul [ j ] [ <int> ] ) ) { tmp + + ; } } return tmp ; } } 
