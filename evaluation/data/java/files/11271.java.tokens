package com . badlogic . gdx . utils ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . CharBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . nio . LongBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Matrix4 ; import com . google . gwt . core . client . GWT ; public final class BufferUtils { public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { FloatBuffer floatBuffer = asFloatBuffer ( dst ) ; floatBuffer . clear ( ) ; dst . position ( <int> ) ; floatBuffer . put ( src , offset , numFloats ) ; dst . position ( <int> ) ; if ( dst instanceof ByteBuffer ) dst . limit ( numFloats < < <int> ) ; else dst . limit ( numFloats ) ; } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { if ( ! ( dst instanceof ByteBuffer ) ) throw new GdxRuntimeException ( <str> ) ; ByteBuffer byteBuffer = ( ByteBuffer ) dst ; int oldPosition = byteBuffer . position ( ) ; byteBuffer . put ( src , srcOffset , numElements ) ; byteBuffer . position ( oldPosition ) ; byteBuffer . limit ( oldPosition + numElements ) ; } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { ShortBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asShortBuffer ( ) ; else if ( dst instanceof ShortBuffer ) buffer = ( ShortBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { CharBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asCharBuffer ( ) ; else if ( dst instanceof CharBuffer ) buffer = ( CharBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { IntBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asIntBuffer ( ) ; else if ( dst instanceof IntBuffer ) buffer = ( IntBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { LongBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asLongBuffer ( ) ; else if ( dst instanceof LongBuffer ) buffer = ( LongBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { FloatBuffer buffer = asFloatBuffer ( dst ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { DoubleBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asDoubleBuffer ( ) ; else if ( dst instanceof DoubleBuffer ) buffer = ( DoubleBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldPosition + numElements ) ; } public static void copy ( char [ ] src , int srcOffset , int numElements , Buffer dst ) { CharBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asCharBuffer ( ) ; else if ( dst instanceof CharBuffer ) buffer = ( CharBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; } public static void copy ( int [ ] src , int srcOffset , int numElements , Buffer dst ) { IntBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asIntBuffer ( ) ; else if ( dst instanceof IntBuffer ) buffer = ( IntBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; } public static void copy ( long [ ] src , int srcOffset , int numElements , Buffer dst ) { LongBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asLongBuffer ( ) ; else if ( dst instanceof LongBuffer ) buffer = ( LongBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; } public static void copy ( float [ ] src , int srcOffset , int numElements , Buffer dst ) { FloatBuffer buffer = asFloatBuffer ( dst ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; } public static void copy ( double [ ] src , int srcOffset , int numElements , Buffer dst ) { DoubleBuffer buffer = null ; if ( dst instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) dst ) . asDoubleBuffer ( ) ; else if ( dst instanceof DoubleBuffer ) buffer = ( DoubleBuffer ) dst ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; int oldPosition = buffer . position ( ) ; buffer . put ( src , srcOffset , numElements ) ; buffer . position ( oldPosition ) ; } public static void copy ( Buffer src , Buffer dst , int numElements ) { int srcPos = src . position ( ) ; int dstPos = dst . position ( ) ; src . limit ( srcPos + numElements ) ; final boolean srcIsByte = src instanceof ByteBuffer ; final boolean dstIsByte = dst instanceof ByteBuffer ; dst . limit ( dst . capacity ( ) ) ; if ( srcIsByte & & dstIsByte ) ( ( ByteBuffer ) dst ) . put ( ( ByteBuffer ) src ) ; else if ( ( srcIsByte | | src instanceof CharBuffer ) & & ( dstIsByte | | dst instanceof CharBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asCharBuffer ( ) : ( CharBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asCharBuffer ( ) : ( CharBuffer ) src ) ) ; else if ( ( srcIsByte | | src instanceof ShortBuffer ) & & ( dstIsByte | | dst instanceof ShortBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asShortBuffer ( ) : ( ShortBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asShortBuffer ( ) : ( ShortBuffer ) src ) ) ; else if ( ( srcIsByte | | src instanceof IntBuffer ) & & ( dstIsByte | | dst instanceof IntBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asIntBuffer ( ) : ( IntBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asIntBuffer ( ) : ( IntBuffer ) src ) ) ; else if ( ( srcIsByte | | src instanceof LongBuffer ) & & ( dstIsByte | | dst instanceof LongBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asLongBuffer ( ) : ( LongBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asLongBuffer ( ) : ( LongBuffer ) src ) ) ; else if ( ( srcIsByte | | src instanceof FloatBuffer ) & & ( dstIsByte | | dst instanceof FloatBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asFloatBuffer ( ) : ( FloatBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asFloatBuffer ( ) : ( FloatBuffer ) src ) ) ; else if ( ( srcIsByte | | src instanceof DoubleBuffer ) & & ( dstIsByte | | dst instanceof DoubleBuffer ) ) ( dstIsByte ? ( ( ByteBuffer ) dst ) . asDoubleBuffer ( ) : ( DoubleBuffer ) dst ) . put ( ( srcIsByte ? ( ( ByteBuffer ) src ) . asDoubleBuffer ( ) : ( DoubleBuffer ) src ) ) ; else throw new GdxRuntimeException ( <str> ) ; src . position ( srcPos ) ; dst . flip ( ) ; dst . position ( dstPos ) ; } private final static FloatBuffer asFloatBuffer ( final Buffer data ) { FloatBuffer buffer = null ; if ( data instanceof ByteBuffer ) buffer = ( ( ByteBuffer ) data ) . asFloatBuffer ( ) ; else if ( data instanceof FloatBuffer ) buffer = ( FloatBuffer ) data ; if ( buffer = = null ) throw new GdxRuntimeException ( <str> ) ; return buffer ; } private final static float [ ] asFloatArray ( final FloatBuffer buffer ) { final int pos = buffer . position ( ) ; final float [ ] result = new float [ buffer . remaining ( ) ] ; buffer . get ( result ) ; buffer . position ( pos ) ; return result ; } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix4 matrix ) { FloatBuffer buffer = asFloatBuffer ( data ) ; final int pos = buffer . position ( ) ; int idx = pos ; float [ ] arr = asFloatArray ( buffer ) ; int stride = strideInBytes / <int> ; float [ ] m = matrix . val ; for ( int i = <int> ; i < count ; i + + ) { idx + = stride ; final float x = arr [ idx ] ; final float y = arr [ idx + <int> ] ; final float z = dimensions > = <int> ? arr [ idx + <int> ] : <int> f ; final float w = dimensions > = <int> ? arr [ idx + <int> ] : <int> f ; arr [ idx ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] + w * m [ <int> ] ; arr [ idx + <int> ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] + w * m [ <int> ] ; if ( dimensions > = <int> ) { arr [ idx + <int> ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] + w * m [ <int> ] ; if ( dimensions > = <int> ) arr [ idx + <int> ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] + w * m [ <int> ] ; } } buffer . put ( arr ) ; buffer . position ( pos ) ; } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix3 matrix ) { FloatBuffer buffer = asFloatBuffer ( data ) ; final int pos = buffer . position ( ) ; int idx = pos ; float [ ] arr = asFloatArray ( buffer ) ; int stride = strideInBytes / <int> ; float [ ] m = matrix . val ; for ( int i = <int> ; i < count ; i + + ) { idx + = stride ; final float x = arr [ idx ] ; final float y = arr [ idx + <int> ] ; final float z = dimensions > = <int> ? arr [ idx + <int> ] : <int> f ; arr [ idx ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] ; arr [ idx + <int> ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] ; if ( dimensions > = <int> ) arr [ idx + <int> ] = x * m [ <int> ] + y * m [ <int> ] + z * m [ <int> ] ; } buffer . put ( arr ) ; buffer . position ( pos ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , Buffer vertices , int numVertices ) { return findFloats ( asFloatArray ( asFloatBuffer ( vertex ) ) , strideInBytes , asFloatArray ( asFloatBuffer ( vertices ) ) , numVertices ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , Buffer vertices , int numVertices ) { return findFloats ( vertex , strideInBytes , asFloatArray ( asFloatBuffer ( vertices ) ) , numVertices ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , float [ ] vertices , int numVertices ) { return findFloats ( asFloatArray ( asFloatBuffer ( vertex ) ) , strideInBytes , vertices , numVertices ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , float [ ] vertices , int numVertices ) { final int size = strideInBytes / <int> ; for ( int i = <int> ; i < numVertices ; i + + ) { final int offset = i * size ; boolean found = true ; for ( int j = <int> ; ! found & & j < size ; j + + ) if ( vertices [ offset + j ] ! = vertex [ j ] ) found = false ; if ( found ) return ( long ) i ; } return - <int> ; } public static long findFloats ( Buffer vertex , int strideInBytes , Buffer vertices , int numVertices , float epsilon ) { return findFloats ( asFloatArray ( asFloatBuffer ( vertex ) ) , strideInBytes , asFloatArray ( asFloatBuffer ( vertices ) ) , numVertices , epsilon ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , Buffer vertices , int numVertices , float epsilon ) { return findFloats ( vertex , strideInBytes , asFloatArray ( asFloatBuffer ( vertices ) ) , numVertices , epsilon ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , float [ ] vertices , int numVertices , float epsilon ) { return findFloats ( asFloatArray ( asFloatBuffer ( vertex ) ) , strideInBytes , vertices , numVertices , epsilon ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , float [ ] vertices , int numVertices , float epsilon ) { final int size = strideInBytes / <int> ; for ( int i = <int> ; i < numVertices ; i + + ) { final int offset = i * size ; boolean found = true ; for ( int j = <int> ; ! found & & j < size ; j + + ) if ( ( vertices [ offset + j ] > vertex [ j ] ? vertices [ offset + j ] - vertex [ j ] : vertex [ j ] - vertices [ offset + j ] ) > epsilon ) found = false ; if ( found ) return ( long ) i ; } return - <int> ; } public static FloatBuffer newFloatBuffer ( int numFloats ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numFloats * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asFloatBuffer ( ) ; } else { return FloatBuffer . wrap ( new float [ numFloats ] ) ; } } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numDoubles * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asDoubleBuffer ( ) ; } else { return DoubleBuffer . wrap ( new double [ numDoubles ] ) ; } } public static ByteBuffer newByteBuffer ( int numBytes ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numBytes ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer ; } else { return ByteBuffer . wrap ( new byte [ numBytes ] ) ; } } public static ShortBuffer newShortBuffer ( int numShorts ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numShorts * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asShortBuffer ( ) ; } else { return ShortBuffer . wrap ( new short [ numShorts ] ) ; } } public static CharBuffer newCharBuffer ( int numChars ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numChars * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asCharBuffer ( ) ; } else { return CharBuffer . wrap ( new char [ numChars ] ) ; } } public static IntBuffer newIntBuffer ( int numInts ) { if ( GWT . isProdMode ( ) ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numInts * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asIntBuffer ( ) ; } else { return IntBuffer . wrap ( new int [ numInts ] ) ; } } public static LongBuffer newLongBuffer ( int numLongs ) { return LongBuffer . wrap ( new long [ numLongs ] ) ; } }