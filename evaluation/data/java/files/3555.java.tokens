package org . nd4j . linalg . fft ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . impl . transforms . VectorFFT ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . util . ComplexNDArrayUtil ; public abstract class BaseFFTInstance implements FFTInstance { @Override public IComplexNDArray fft ( INDArray transform , int numElements ) { IComplexNDArray inputC = Nd4j . createComplex ( transform ) ; if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( new VectorFFT ( inputC , inputC . length ( ) ) ) ; else { return rawfft ( inputC , numElements , inputC . shape ( ) . length - <int> ) ; } } @Override public IComplexNDArray fft ( IComplexNDArray inputC ) { if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( new VectorFFT ( inputC , inputC . length ( ) ) ) ; else { return rawfft ( inputC , inputC . size ( inputC . shape ( ) . length - <int> ) , inputC . shape ( ) . length - <int> ) ; } } @Override public IComplexNDArray fft ( INDArray input ) { IComplexNDArray inputC = Nd4j . createComplex ( input ) ; return fft ( inputC ) ; } @Override public IComplexNDArray fft ( IComplexNDArray inputC , int numElements ) { return fft ( inputC , numElements , inputC . shape ( ) . length - <int> ) ; } @Override public IComplexNDArray ifftn ( INDArray transform , int dimension , int numElements ) { return ifftn ( Nd4j . createComplex ( transform ) , dimension , numElements ) ; } @Override public IComplexNDArray irfftn ( IComplexNDArray arr ) { int [ ] shape = arr . shape ( ) ; IComplexNDArray ret = arr . dup ( ) ; for ( int i = <int> ; i < shape . length - <int> ; i + + ) { ret = ifftn ( ret , i , shape [ i ] ) ; } return irfft ( ret , <int> ) ; } @Override public IComplexNDArray irfft ( IComplexNDArray arr , int dimension ) { return fftn ( arr , arr . size ( dimension ) , dimension ) ; } @Override public IComplexNDArray irfft ( IComplexNDArray arr ) { return arr ; } @Override public IComplexNDArray ifftn ( IComplexNDArray transform , int dimension , int numElements ) { if ( numElements < <int> ) throw new IllegalArgumentException ( <str> ) ; int [ ] finalShape = ArrayUtil . replace ( transform . shape ( ) , dimension , numElements ) ; int [ ] axes = ArrayUtil . range ( <int> , finalShape . length ) ; IComplexNDArray result = transform . dup ( ) ; int desiredElementsAlongDimension = result . size ( dimension ) ; if ( numElements > desiredElementsAlongDimension ) { result = ComplexNDArrayUtil . padWithZeros ( result , finalShape ) ; } else if ( numElements < desiredElementsAlongDimension ) result = ComplexNDArrayUtil . truncate ( result , numElements , dimension ) ; return rawifftn ( result , finalShape , axes ) ; } @Override public IComplexNDArray fftn ( IComplexNDArray transform , int dimension , int numElements ) { if ( numElements < <int> ) throw new IllegalArgumentException ( <str> ) ; int [ ] finalShape = ArrayUtil . replace ( transform . shape ( ) , dimension , numElements ) ; int [ ] axes = ArrayUtil . range ( <int> , finalShape . length ) ; IComplexNDArray result = transform . dup ( ) ; int desiredElementsAlongDimension = result . size ( dimension ) ; if ( numElements > desiredElementsAlongDimension ) result = ComplexNDArrayUtil . padWithZeros ( result , finalShape ) ; else if ( numElements < desiredElementsAlongDimension ) result = ComplexNDArrayUtil . truncate ( result , numElements , dimension ) ; return rawfftn ( result , finalShape , axes ) ; } @Override public IComplexNDArray fftn ( INDArray transform , int dimension , int numElements ) { return fftn ( Nd4j . createComplex ( transform ) , dimension , numElements ) ; } @Override public IComplexNDArray fftn ( INDArray transform ) { return fftn ( transform , transform . shape ( ) . length - <int> , transform . shape ( ) [ transform . shape ( ) . length - <int> ] ) ; } @Override public IComplexNDArray fftn ( IComplexNDArray transform ) { return rawfftn ( transform , null , null ) ; } @Override public IComplexNDArray ifftn ( IComplexNDArray transform , int dimension ) { return ifftn ( transform , dimension , transform . shape ( ) [ dimension ] ) ; } @Override public IComplexNDArray ifftn ( IComplexNDArray transform ) { return rawifftn ( transform , null , null ) ; } @Override public IComplexNDArray ifftn ( INDArray transform ) { return ifftn ( transform , transform . shape ( ) . length - <int> , transform . size ( transform . shape ( ) . length - <int> ) ) ; } @Override public IComplexNDArray rawifftn ( IComplexNDArray transform , int [ ] shape , int [ ] axes ) { return doFFt ( transform , shape , axes , true ) ; } @Override public IComplexNDArray rawfftn ( IComplexNDArray transform , int [ ] shape , int [ ] axes ) { return doFFt ( transform , shape , axes , false ) ; } private IComplexNDArray fixShape ( IComplexNDArray x , int [ ] shape , int axis , int n ) { if ( shape [ axis ] > n ) { int [ ] newShape = ArrayUtil . copy ( shape ) ; newShape [ axis ] = n ; x = ComplexNDArrayUtil . truncate ( x , n , axis ) ; } else { int [ ] newShape = ArrayUtil . copy ( shape ) ; newShape [ axis ] = n ; x = ComplexNDArrayUtil . padWithZeros ( x , newShape ) ; return x ; } return x ; } @Override public IComplexNDArray rawifft ( IComplexNDArray transform , int dimension ) { return rawifft ( transform , transform . shape ( ) [ dimension ] , dimension ) ; } protected IComplexNDArray doFFt ( IComplexNDArray transform , int [ ] shape , int [ ] axes , boolean inverse ) { IComplexNDArray result = transform . dup ( ) ; if ( shape = = null ) shape = ArrayUtil . copy ( result . shape ( ) ) ; boolean noAxes = false ; if ( axes = = null | | axes . length < <int> ) { noAxes = true ; axes = ArrayUtil . range ( <int> , shape . length ) ; axes = ArrayUtil . reverseCopy ( axes ) ; } if ( noAxes ) { for ( int i : axes ) { if ( i < <int> ) i = shape . length + i ; transform = fixShape ( transform , shape , i , shape [ i ] ) ; } } if ( ArrayUtil . prod ( shape ) > ArrayUtil . prod ( result . shape ( ) ) ) result = ComplexNDArrayUtil . padWithZeros ( result , shape ) ; return doInnerFft ( result , shape , axes , inverse ) ; } protected IComplexNDArray doInnerFft ( IComplexNDArray result , int [ ] shape , int [ ] axes , boolean inverse ) { for ( int i = <int> ; i < axes . length ; i + + ) { result = inverse ? ifft ( result , shape [ axes [ i ] ] , axes [ i ] ) : fft ( result , shape [ axes [ i ] ] , axes [ i ] ) ; } return result ; } }