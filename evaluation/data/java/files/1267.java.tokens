package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpResponseStatus ; import java . util . regex . Pattern ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; public class WebSocketServerHandshaker00 extends WebSocketServerHandshaker { private static final Pattern BEGINNING_DIGIT = Pattern . compile ( <str> ) ; private static final Pattern BEGINNING_SPACE = Pattern . compile ( <str> ) ; public WebSocketServerHandshaker00 ( String webSocketURL , String subprotocols , int maxFramePayloadLength ) { super ( WebSocketVersion . V00 , webSocketURL , subprotocols , maxFramePayloadLength ) ; } @Override protected FullHttpResponse newHandshakeResponse ( FullHttpRequest req , HttpHeaders headers ) { if ( ! HttpHeaderValues . UPGRADE . contentEqualsIgnoreCase ( req . headers ( ) . get ( HttpHeaderNames . CONNECTION ) ) | | ! HttpHeaderValues . WEBSOCKET . contentEqualsIgnoreCase ( req . headers ( ) . get ( HttpHeaderNames . UPGRADE ) ) ) { throw new WebSocketHandshakeException ( <str> ) ; } boolean isHixie76 = req . headers ( ) . contains ( HttpHeaderNames . SEC_WEBSOCKET_KEY1 ) & & req . headers ( ) . contains ( HttpHeaderNames . SEC_WEBSOCKET_KEY2 ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HTTP_1_1 , new HttpResponseStatus ( <int> , isHixie76 ? <str> : <str> ) ) ; if ( headers ! = null ) { res . headers ( ) . add ( headers ) ; } res . headers ( ) . add ( HttpHeaderNames . UPGRADE , HttpHeaderValues . WEBSOCKET ) ; res . headers ( ) . add ( HttpHeaderNames . CONNECTION , HttpHeaderValues . UPGRADE ) ; if ( isHixie76 ) { res . headers ( ) . add ( HttpHeaderNames . SEC_WEBSOCKET_ORIGIN , req . headers ( ) . get ( HttpHeaderNames . ORIGIN ) ) ; res . headers ( ) . add ( HttpHeaderNames . SEC_WEBSOCKET_LOCATION , uri ( ) ) ; String subprotocols = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL ) ; if ( subprotocols ! = null ) { String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; if ( selectedSubprotocol = = null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , subprotocols ) ; } } else { res . headers ( ) . add ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL , selectedSubprotocol ) ; } } String key1 = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_KEY1 ) ; String key2 = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_KEY2 ) ; int a = ( int ) ( Long . parseLong ( BEGINNING_DIGIT . matcher ( key1 ) . replaceAll ( <str> ) ) / BEGINNING_SPACE . matcher ( key1 ) . replaceAll ( <str> ) . length ( ) ) ; int b = ( int ) ( Long . parseLong ( BEGINNING_DIGIT . matcher ( key2 ) . replaceAll ( <str> ) ) / BEGINNING_SPACE . matcher ( key2 ) . replaceAll ( <str> ) . length ( ) ) ; long c = req . content ( ) . readLong ( ) ; ByteBuf input = Unpooled . buffer ( <int> ) ; input . writeInt ( a ) ; input . writeInt ( b ) ; input . writeLong ( c ) ; res . content ( ) . writeBytes ( WebSocketUtil . md5 ( input . array ( ) ) ) ; } else { res . headers ( ) . add ( HttpHeaderNames . WEBSOCKET_ORIGIN , req . headers ( ) . get ( HttpHeaderNames . ORIGIN ) ) ; res . headers ( ) . add ( HttpHeaderNames . WEBSOCKET_LOCATION , uri ( ) ) ; String protocol = req . headers ( ) . get ( HttpHeaderNames . WEBSOCKET_PROTOCOL ) ; if ( protocol ! = null ) { res . headers ( ) . add ( HttpHeaderNames . WEBSOCKET_PROTOCOL , selectSubprotocol ( protocol ) ) ; } } return res ; } @Override public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame , ChannelPromise promise ) { return channel . writeAndFlush ( frame , promise ) ; } @Override protected WebSocketFrameDecoder newWebsocketDecoder ( ) { return new WebSocket00FrameDecoder ( maxFramePayloadLength ( ) ) ; } @Override protected WebSocketFrameEncoder newWebSocketEncoder ( ) { return new WebSocket00FrameEncoder ( ) ; } } 
