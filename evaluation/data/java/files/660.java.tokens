package com . netflix . hystrix . collapser ; import com . netflix . hystrix . HystrixCollapser . CollapsedRequest ; import rx . Observable . OnSubscribe ; import rx . Subscriber ; import rx . subjects . PublishSubject ; import java . util . concurrent . atomic . AtomicBoolean ; class CollapsedRequestObservableFunction < T , R > implements CollapsedRequest < T , R > , OnSubscribe < T > { private final R argument ; private AtomicBoolean valueSet = new AtomicBoolean ( false ) ; private final PublishSubject < T > responseSubject = PublishSubject . create ( ) ; public CollapsedRequestObservableFunction ( R arg ) { this . argument = arg ; } @Override public void call ( Subscriber < ? super T > observer ) { responseSubject . unsafeSubscribe ( observer ) ; } @Override public R getArgument ( ) { return argument ; } @Override public void setResponse ( T response ) { if ( ! isTerminated ( ) ) { responseSubject . onNext ( response ) ; valueSet . set ( true ) ; responseSubject . onCompleted ( ) ; } else { throw new IllegalStateException ( <str> + response ) ; } } @Override public void emitResponse ( T response ) { if ( ! isTerminated ( ) ) { responseSubject . onNext ( response ) ; valueSet . set ( true ) ; } else { throw new IllegalStateException ( <str> + response ) ; } } @Override public void setComplete ( ) { if ( ! isTerminated ( ) ) { responseSubject . onCompleted ( ) ; } } public void setExceptionIfResponseNotReceived ( Exception e ) { if ( ! valueSet . get ( ) & & ! isTerminated ( ) ) { responseSubject . onError ( e ) ; } } public Exception setExceptionIfResponseNotReceived ( Exception e , String exceptionMessage ) { Exception exception = e ; if ( ! valueSet . get ( ) & & ! isTerminated ( ) ) { if ( e = = null ) { exception = new IllegalStateException ( exceptionMessage ) ; } setExceptionIfResponseNotReceived ( exception ) ; } return exception ; } @Override public void setException ( Exception e ) { if ( ! isTerminated ( ) ) { responseSubject . onError ( e ) ; } else { throw new IllegalStateException ( <str> , e ) ; } } private boolean isTerminated ( ) { return ( responseSubject . hasCompleted ( ) | | responseSubject . hasThrowable ( ) ) ; } } 
