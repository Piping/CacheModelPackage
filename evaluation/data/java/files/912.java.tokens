package org . elasticsearch . plan . a ; import java . util . ArrayDeque ; import java . util . Arrays ; import java . util . Deque ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . antlr . v4 . runtime . ParserRuleContext ; import static org . elasticsearch . plan . a . Adapter . * ; import static org . elasticsearch . plan . a . Definition . * ; import static org . elasticsearch . plan . a . PlanAParser . * ; class Analyzer extends PlanAParserBaseVisitor < Void > { private static class Variable { final String name ; final Type type ; final int slot ; private Variable ( final String name , final Type type , final int slot ) { this . name = name ; this . type = type ; this . slot = slot ; } } static void analyze ( final Adapter adapter ) { new Analyzer ( adapter ) ; } private final Adapter adapter ; private final Definition definition ; private final CompilerSettings settings ; private final Deque < Integer > scopes ; private final Deque < Variable > variables ; private Analyzer ( final Adapter adapter ) { this . adapter = adapter ; definition = adapter . definition ; settings = adapter . settings ; scopes = new ArrayDeque < > ( ) ; variables = new ArrayDeque < > ( ) ; incrementScope ( ) ; addVariable ( null , <str> , definition . execType ) ; addVariable ( null , <str> , definition . smapType ) ; adapter . createStatementMetadata ( adapter . root ) ; visit ( adapter . root ) ; decrementScope ( ) ; } void incrementScope ( ) { scopes . push ( <int> ) ; } void decrementScope ( ) { int remove = scopes . pop ( ) ; while ( remove > <int> ) { variables . pop ( ) ; - - remove ; } } Variable getVariable ( final String name ) { final Iterator < Variable > itr = variables . iterator ( ) ; while ( itr . hasNext ( ) ) { final Variable variable = itr . next ( ) ; if ( variable . name . equals ( name ) ) { return variable ; } } return null ; } Variable addVariable ( final ParserRuleContext source , final String name , final Type type ) { if ( getVariable ( name ) ! = null ) { if ( source = = null ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } else { throw new IllegalArgumentException ( error ( source ) + <str> + name + <str> ) ; } } final Variable previous = variables . peekFirst ( ) ; int slot = <int> ; if ( previous ! = null ) { slot + = previous . slot + previous . type . type . getSize ( ) ; } final Variable variable = new Variable ( name , type , slot ) ; variables . push ( variable ) ; final int update = scopes . pop ( ) + <int> ; scopes . push ( update ) ; return variable ; } @Override public Void visitSource ( final SourceContext ctx ) { final StatementMetadata sourcesmd = adapter . getStatementMetadata ( ctx ) ; final List < StatementContext > statectxs = ctx . statement ( ) ; final StatementContext lastctx = statectxs . get ( statectxs . size ( ) - <int> ) ; incrementScope ( ) ; for ( final StatementContext statectx : statectxs ) { if ( sourcesmd . allExit ) { throw new IllegalArgumentException ( error ( statectx ) + <str> ) ; } final StatementMetadata statesmd = adapter . createStatementMetadata ( statectx ) ; statesmd . last = statectx = = lastctx ; visit ( statectx ) ; if ( statesmd . anyContinue ) { throw new IllegalArgumentException ( error ( statectx ) + <str> ) ; } if ( statesmd . anyBreak ) { throw new IllegalArgumentException ( error ( statectx ) + <str> ) ; } sourcesmd . allExit = statesmd . allExit ; sourcesmd . allReturn = statesmd . allReturn ; } decrementScope ( ) ; return null ; } @Override public Void visitIf ( final IfContext ctx ) { final StatementMetadata ifsmd = adapter . getStatementMetadata ( ctx ) ; incrementScope ( ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = definition . booleanType ; visit ( exprctx ) ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } final BlockContext blockctx0 = ctx . block ( <int> ) ; final StatementMetadata blocksmd0 = adapter . createStatementMetadata ( blockctx0 ) ; blocksmd0 . last = ifsmd . last ; visit ( blockctx0 ) ; ifsmd . anyReturn = blocksmd0 . anyReturn ; ifsmd . anyBreak = blocksmd0 . anyBreak ; ifsmd . anyContinue = blocksmd0 . anyContinue ; if ( ctx . ELSE ( ) ! = null ) { final BlockContext blockctx1 = ctx . block ( <int> ) ; final StatementMetadata blocksmd1 = adapter . createStatementMetadata ( blockctx1 ) ; blocksmd1 . last = ifsmd . last ; visit ( blockctx1 ) ; ifsmd . allExit = blocksmd0 . allExit & & blocksmd1 . allExit ; ifsmd . allReturn = blocksmd0 . allReturn & & blocksmd1 . allReturn ; ifsmd . anyReturn | = blocksmd1 . anyReturn ; ifsmd . allBreak = blocksmd0 . allBreak & & blocksmd1 . allBreak ; ifsmd . anyBreak | = blocksmd1 . anyBreak ; ifsmd . allContinue = blocksmd0 . allContinue & & blocksmd1 . allContinue ; ifsmd . anyContinue | = blocksmd1 . anyContinue ; } decrementScope ( ) ; return null ; } @Override public Void visitWhile ( final WhileContext ctx ) { final StatementMetadata whilesmd = adapter . getStatementMetadata ( ctx ) ; incrementScope ( ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = definition . booleanType ; visit ( exprctx ) ; markCast ( expremd ) ; boolean exitrequired = false ; if ( expremd . postConst ! = null ) { boolean constant = ( boolean ) expremd . postConst ; if ( ! constant ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } exitrequired = true ; } final BlockContext blockctx = ctx . block ( ) ; if ( blockctx ! = null ) { final StatementMetadata blocksmd = adapter . createStatementMetadata ( blockctx ) ; visit ( blockctx ) ; if ( blocksmd . allReturn ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( blocksmd . allBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( exitrequired & & ! blocksmd . anyReturn & & ! blocksmd . anyBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( exitrequired & & blocksmd . anyReturn & & ! blocksmd . anyBreak ) { whilesmd . allExit = true ; whilesmd . allReturn = true ; } } else if ( exitrequired ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } decrementScope ( ) ; return null ; } @Override public Void visitDo ( final DoContext ctx ) { final StatementMetadata dosmd = adapter . getStatementMetadata ( ctx ) ; incrementScope ( ) ; final BlockContext blockctx = ctx . block ( ) ; final StatementMetadata blocksmd = adapter . createStatementMetadata ( blockctx ) ; visit ( blockctx ) ; if ( blocksmd . allReturn ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( blocksmd . allBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( blocksmd . allContinue ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = definition . booleanType ; visit ( exprctx ) ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { final boolean exitrequired = ( boolean ) expremd . postConst ; if ( exitrequired & & ! blocksmd . anyReturn & & ! blocksmd . anyBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( exitrequired & & blocksmd . anyReturn & & ! blocksmd . anyBreak ) { dosmd . allExit = true ; dosmd . allReturn = true ; } if ( ! exitrequired & & ! blocksmd . anyContinue ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } } decrementScope ( ) ; return null ; } @Override public Void visitFor ( final ForContext ctx ) { final StatementMetadata forsmd = adapter . getStatementMetadata ( ctx ) ; boolean exitrequired = false ; incrementScope ( ) ; final InitializerContext initctx = ctx . initializer ( ) ; if ( initctx ! = null ) { adapter . createStatementMetadata ( initctx ) ; visit ( initctx ) ; } final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; if ( exprctx ! = null ) { final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = definition . booleanType ; visit ( exprctx ) ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { boolean constant = ( boolean ) expremd . postConst ; if ( ! constant ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } exitrequired = true ; } } else { exitrequired = true ; } final AfterthoughtContext atctx = ctx . afterthought ( ) ; if ( atctx ! = null ) { adapter . createStatementMetadata ( atctx ) ; visit ( atctx ) ; } final BlockContext blockctx = ctx . block ( ) ; if ( blockctx ! = null ) { final StatementMetadata blocksmd = adapter . createStatementMetadata ( blockctx ) ; visit ( blockctx ) ; if ( blocksmd . allReturn ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( blocksmd . allBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( exitrequired & & ! blocksmd . anyReturn & & ! blocksmd . anyBreak ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } if ( exitrequired & & blocksmd . anyReturn & & ! blocksmd . anyBreak ) { forsmd . allExit = true ; forsmd . allReturn = true ; } } else if ( exitrequired ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } decrementScope ( ) ; return null ; } @Override public Void visitDecl ( final DeclContext ctx ) { final DeclarationContext declctx = ctx . declaration ( ) ; adapter . createStatementMetadata ( declctx ) ; visit ( declctx ) ; return null ; } @Override public Void visitContinue ( final ContinueContext ctx ) { final StatementMetadata continuesmd = adapter . getStatementMetadata ( ctx ) ; continuesmd . allExit = true ; continuesmd . allContinue = true ; continuesmd . anyContinue = true ; return null ; } @Override public Void visitBreak ( final BreakContext ctx ) { final StatementMetadata breaksmd = adapter . getStatementMetadata ( ctx ) ; breaksmd . allExit = true ; breaksmd . allBreak = true ; breaksmd . anyBreak = true ; return null ; } @Override public Void visitReturn ( final ReturnContext ctx ) { final StatementMetadata returnsmd = adapter . getStatementMetadata ( ctx ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = definition . objectType ; visit ( exprctx ) ; markCast ( expremd ) ; returnsmd . allExit = true ; returnsmd . allReturn = true ; returnsmd . anyReturn = true ; return null ; } @Override public Void visitExpr ( final ExprContext ctx ) { final StatementMetadata exprsmd = adapter . getStatementMetadata ( ctx ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . read = exprsmd . last ; visit ( exprctx ) ; if ( ! expremd . statement & & ! exprsmd . last ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } final boolean rtn = exprsmd . last & & expremd . from . sort ! = Sort . VOID ; exprsmd . allExit = rtn ; exprsmd . allReturn = rtn ; exprsmd . anyReturn = rtn ; expremd . to = rtn ? definition . objectType : expremd . from ; markCast ( expremd ) ; return null ; } @Override public Void visitMultiple ( final MultipleContext ctx ) { final StatementMetadata multiplesmd = adapter . getStatementMetadata ( ctx ) ; final List < StatementContext > statectxs = ctx . statement ( ) ; final StatementContext lastctx = statectxs . get ( statectxs . size ( ) - <int> ) ; for ( StatementContext statectx : statectxs ) { if ( multiplesmd . allExit ) { throw new IllegalArgumentException ( error ( statectx ) + <str> ) ; } final StatementMetadata statesmd = adapter . createStatementMetadata ( statectx ) ; statesmd . last = multiplesmd . last & & statectx = = lastctx ; visit ( statectx ) ; multiplesmd . allExit = statesmd . allExit ; multiplesmd . allReturn = statesmd . allReturn & & ! statesmd . anyBreak & & ! statesmd . anyContinue ; multiplesmd . anyReturn | = statesmd . anyReturn ; multiplesmd . allBreak = ! statesmd . anyReturn & & statesmd . allBreak & & ! statesmd . anyContinue ; multiplesmd . anyBreak | = statesmd . anyBreak ; multiplesmd . allContinue = ! statesmd . anyReturn & & ! statesmd . anyBreak & & statesmd . allContinue ; multiplesmd . anyContinue | = statesmd . anyContinue ; } return null ; } @Override public Void visitSingle ( final SingleContext ctx ) { final StatementMetadata singlesmd = adapter . getStatementMetadata ( ctx ) ; final StatementContext statectx = ctx . statement ( ) ; final StatementMetadata statesmd = adapter . createStatementMetadata ( statectx ) ; statesmd . last = singlesmd . last ; visit ( statectx ) ; singlesmd . allExit = statesmd . allExit ; singlesmd . allReturn = statesmd . allReturn ; singlesmd . anyReturn = statesmd . anyReturn ; singlesmd . allBreak = statesmd . allBreak ; singlesmd . anyBreak = statesmd . anyBreak ; singlesmd . allContinue = statesmd . allContinue ; singlesmd . anyContinue = statesmd . anyContinue ; return null ; } @Override public Void visitEmpty ( final EmptyContext ctx ) { throw new UnsupportedOperationException ( error ( ctx ) + <str> ) ; } @Override public Void visitInitializer ( InitializerContext ctx ) { final DeclarationContext declctx = ctx . declaration ( ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; if ( declctx ! = null ) { adapter . createStatementMetadata ( declctx ) ; visit ( declctx ) ; } else if ( exprctx ! = null ) { final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . read = false ; visit ( exprctx ) ; expremd . to = expremd . from ; markCast ( expremd ) ; if ( ! expremd . statement ) { throw new IllegalArgumentException ( error ( exprctx ) + <str> ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } return null ; } @Override public Void visitAfterthought ( AfterthoughtContext ctx ) { ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; if ( exprctx ! = null ) { final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . read = false ; visit ( exprctx ) ; expremd . to = expremd . from ; markCast ( expremd ) ; if ( ! expremd . statement ) { throw new IllegalArgumentException ( error ( exprctx ) + <str> ) ; } } return null ; } @Override public Void visitDeclaration ( final DeclarationContext ctx ) { final DecltypeContext decltypectx = ctx . decltype ( ) ; final ExpressionMetadata decltypeemd = adapter . createExpressionMetadata ( decltypectx ) ; visit ( decltypectx ) ; for ( final DeclvarContext declvarctx : ctx . declvar ( ) ) { final ExpressionMetadata declvaremd = adapter . createExpressionMetadata ( declvarctx ) ; declvaremd . to = decltypeemd . from ; visit ( declvarctx ) ; } return null ; } @Override public Void visitDecltype ( final DecltypeContext ctx ) { final ExpressionMetadata decltypeemd = adapter . getExpressionMetadata ( ctx ) ; final String name = ctx . getText ( ) ; decltypeemd . from = definition . getType ( name ) ; return null ; } @Override public Void visitDeclvar ( final DeclvarContext ctx ) { final ExpressionMetadata declvaremd = adapter . getExpressionMetadata ( ctx ) ; final String name = ctx . ID ( ) . getText ( ) ; declvaremd . postConst = addVariable ( ctx , name , declvaremd . to ) . slot ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; if ( exprctx ! = null ) { final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = declvaremd . to ; visit ( exprctx ) ; markCast ( expremd ) ; } return null ; } @Override public Void visitPrecedence ( final PrecedenceContext ctx ) { throw new UnsupportedOperationException ( error ( ctx ) + <str> ) ; } @Override public Void visitNumeric ( final NumericContext ctx ) { final ExpressionMetadata numericemd = adapter . getExpressionMetadata ( ctx ) ; final boolean negate = ctx . parent instanceof UnaryContext & & ( ( UnaryContext ) ctx . parent ) . SUB ( ) ! = null ; if ( ctx . DECIMAL ( ) ! = null ) { final String svalue = ( negate ? <str> : <str> ) + ctx . DECIMAL ( ) . getText ( ) ; if ( svalue . endsWith ( <str> ) | | svalue . endsWith ( <str> ) ) { try { numericemd . from = definition . floatType ; numericemd . preConst = Float . parseFloat ( svalue . substring ( <int> , svalue . length ( ) - <int> ) ) ; } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } else { try { numericemd . from = definition . doubleType ; numericemd . preConst = Double . parseDouble ( svalue ) ; } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } } else { String svalue = negate ? <str> : <str> ; int radix ; if ( ctx . OCTAL ( ) ! = null ) { svalue + = ctx . OCTAL ( ) . getText ( ) ; radix = <int> ; } else if ( ctx . INTEGER ( ) ! = null ) { svalue + = ctx . INTEGER ( ) . getText ( ) ; radix = <int> ; } else if ( ctx . HEX ( ) ! = null ) { svalue + = ctx . HEX ( ) . getText ( ) ; radix = <int> ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } if ( svalue . endsWith ( <str> ) | | svalue . endsWith ( <str> ) ) { try { numericemd . from = definition . doubleType ; numericemd . preConst = Double . parseDouble ( svalue . substring ( <int> , svalue . length ( ) - <int> ) ) ; } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } else if ( svalue . endsWith ( <str> ) | | svalue . endsWith ( <str> ) ) { try { numericemd . from = definition . floatType ; numericemd . preConst = Float . parseFloat ( svalue . substring ( <int> , svalue . length ( ) - <int> ) ) ; } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } else if ( svalue . endsWith ( <str> ) | | svalue . endsWith ( <str> ) ) { try { numericemd . from = definition . longType ; numericemd . preConst = Long . parseLong ( svalue . substring ( <int> , svalue . length ( ) - <int> ) , radix ) ; } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } else { try { final Type type = numericemd . to ; final Sort sort = type = = null ? Sort . INT : type . sort ; final int value = Integer . parseInt ( svalue , radix ) ; if ( sort = = Sort . BYTE & & value > = Byte . MIN_VALUE & & value < = Byte . MAX_VALUE ) { numericemd . from = definition . byteType ; numericemd . preConst = ( byte ) value ; } else if ( sort = = Sort . CHAR & & value > = Character . MIN_VALUE & & value < = Character . MAX_VALUE ) { numericemd . from = definition . charType ; numericemd . preConst = ( char ) value ; } else if ( sort = = Sort . SHORT & & value > = Short . MIN_VALUE & & value < = Short . MAX_VALUE ) { numericemd . from = definition . shortType ; numericemd . preConst = ( short ) value ; } else { numericemd . from = definition . intType ; numericemd . preConst = value ; } } catch ( NumberFormatException exception ) { throw new IllegalArgumentException ( error ( ctx ) + <str> + svalue + <str> ) ; } } } return null ; } @Override public Void visitChar ( final CharContext ctx ) { final ExpressionMetadata charemd = adapter . getExpressionMetadata ( ctx ) ; if ( ctx . CHAR ( ) = = null ) { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } charemd . preConst = ctx . CHAR ( ) . getText ( ) . charAt ( <int> ) ; charemd . from = definition . charType ; return null ; } @Override public Void visitTrue ( final TrueContext ctx ) { final ExpressionMetadata trueemd = adapter . getExpressionMetadata ( ctx ) ; if ( ctx . TRUE ( ) = = null ) { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } trueemd . preConst = true ; trueemd . from = definition . booleanType ; return null ; } @Override public Void visitFalse ( final FalseContext ctx ) { final ExpressionMetadata falseemd = adapter . getExpressionMetadata ( ctx ) ; if ( ctx . FALSE ( ) = = null ) { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } falseemd . preConst = false ; falseemd . from = definition . booleanType ; return null ; } @Override public Void visitNull ( final NullContext ctx ) { final ExpressionMetadata nullemd = adapter . getExpressionMetadata ( ctx ) ; if ( ctx . NULL ( ) = = null ) { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } nullemd . isNull = true ; if ( nullemd . to ! = null ) { if ( nullemd . to . sort . primitive ) { throw new IllegalArgumentException ( <str> + nullemd . to . name + <str> ) ; } nullemd . from = nullemd . to ; } else { nullemd . from = definition . objectType ; } return null ; } @Override public Void visitExternal ( final ExternalContext ctx ) { final ExpressionMetadata extemd = adapter . getExpressionMetadata ( ctx ) ; final ExtstartContext extstartctx = ctx . extstart ( ) ; final ExternalMetadata extstartemd = adapter . createExternalMetadata ( extstartctx ) ; extstartemd . read = extemd . read ; visit ( extstartctx ) ; extemd . statement = extstartemd . statement ; extemd . preConst = extstartemd . constant ; extemd . from = extstartemd . current ; extemd . typesafe = extstartemd . current . sort ! = Sort . DEF ; return null ; } @Override public Void visitPostinc ( final PostincContext ctx ) { final ExpressionMetadata postincemd = adapter . getExpressionMetadata ( ctx ) ; final ExtstartContext extstartctx = ctx . extstart ( ) ; final ExternalMetadata extstartemd = adapter . createExternalMetadata ( extstartctx ) ; extstartemd . read = postincemd . read ; extstartemd . storeExpr = ctx . increment ( ) ; extstartemd . token = ADD ; extstartemd . post = true ; visit ( extstartctx ) ; postincemd . statement = true ; postincemd . from = extstartemd . read ? extstartemd . current : definition . voidType ; postincemd . typesafe = extstartemd . current . sort ! = Sort . DEF ; return null ; } @Override public Void visitPreinc ( final PreincContext ctx ) { final ExpressionMetadata preincemd = adapter . getExpressionMetadata ( ctx ) ; final ExtstartContext extstartctx = ctx . extstart ( ) ; final ExternalMetadata extstartemd = adapter . createExternalMetadata ( extstartctx ) ; extstartemd . read = preincemd . read ; extstartemd . storeExpr = ctx . increment ( ) ; extstartemd . token = ADD ; extstartemd . pre = true ; visit ( extstartctx ) ; preincemd . statement = true ; preincemd . from = extstartemd . read ? extstartemd . current : definition . voidType ; preincemd . typesafe = extstartemd . current . sort ! = Sort . DEF ; return null ; } @Override public Void visitUnary ( final UnaryContext ctx ) { final ExpressionMetadata unaryemd = adapter . getExpressionMetadata ( ctx ) ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; if ( ctx . BOOLNOT ( ) ! = null ) { expremd . to = definition . booleanType ; visit ( exprctx ) ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { unaryemd . preConst = ! ( boolean ) expremd . postConst ; } unaryemd . from = definition . booleanType ; } else if ( ctx . BWNOT ( ) ! = null | | ctx . ADD ( ) ! = null | | ctx . SUB ( ) ! = null ) { visit ( exprctx ) ; final Type promote = promoteNumeric ( expremd . from , ctx . BWNOT ( ) = = null , true ) ; if ( promote = = null ) { throw new ClassCastException ( <str> + ctx . getChild ( <int> ) . getText ( ) + <str> + <str> + expremd . from . name + <str> ) ; } expremd . to = promote ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { final Sort sort = promote . sort ; if ( ctx . BWNOT ( ) ! = null ) { if ( sort = = Sort . INT ) { unaryemd . preConst = ~ ( int ) expremd . postConst ; } else if ( sort = = Sort . LONG ) { unaryemd . preConst = ~ ( long ) expremd . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . SUB ( ) ! = null ) { if ( exprctx instanceof NumericContext ) { unaryemd . preConst = expremd . postConst ; } else { if ( sort = = Sort . INT ) { if ( settings . getNumericOverflow ( ) ) { unaryemd . preConst = - ( int ) expremd . postConst ; } else { unaryemd . preConst = Math . negateExact ( ( int ) expremd . postConst ) ; } } else if ( sort = = Sort . LONG ) { if ( settings . getNumericOverflow ( ) ) { unaryemd . preConst = - ( long ) expremd . postConst ; } else { unaryemd . preConst = Math . negateExact ( ( long ) expremd . postConst ) ; } } else if ( sort = = Sort . FLOAT ) { unaryemd . preConst = - ( float ) expremd . postConst ; } else if ( sort = = Sort . DOUBLE ) { unaryemd . preConst = - ( double ) expremd . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } } else if ( ctx . ADD ( ) ! = null ) { if ( sort = = Sort . INT ) { unaryemd . preConst = + ( int ) expremd . postConst ; } else if ( sort = = Sort . LONG ) { unaryemd . preConst = + ( long ) expremd . postConst ; } else if ( sort = = Sort . FLOAT ) { unaryemd . preConst = + ( float ) expremd . postConst ; } else if ( sort = = Sort . DOUBLE ) { unaryemd . preConst = + ( double ) expremd . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } unaryemd . from = promote ; unaryemd . typesafe = expremd . typesafe ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } return null ; } @Override public Void visitCast ( final CastContext ctx ) { final ExpressionMetadata castemd = adapter . getExpressionMetadata ( ctx ) ; final DecltypeContext decltypectx = ctx . decltype ( ) ; final ExpressionMetadata decltypemd = adapter . createExpressionMetadata ( decltypectx ) ; visit ( decltypectx ) ; final Type type = decltypemd . from ; castemd . from = type ; final ExpressionContext exprctx = adapter . updateExpressionTree ( ctx . expression ( ) ) ; final ExpressionMetadata expremd = adapter . createExpressionMetadata ( exprctx ) ; expremd . to = type ; expremd . explicit = true ; visit ( exprctx ) ; markCast ( expremd ) ; if ( expremd . postConst ! = null ) { castemd . preConst = expremd . postConst ; } castemd . typesafe = expremd . typesafe & & castemd . from . sort ! = Sort . DEF ; return null ; } @Override public Void visitBinary ( final BinaryContext ctx ) { final ExpressionMetadata binaryemd = adapter . getExpressionMetadata ( ctx ) ; final ExpressionContext exprctx0 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd0 = adapter . createExpressionMetadata ( exprctx0 ) ; visit ( exprctx0 ) ; final ExpressionContext exprctx1 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd1 = adapter . createExpressionMetadata ( exprctx1 ) ; visit ( exprctx1 ) ; final boolean decimal = ctx . MUL ( ) ! = null | | ctx . DIV ( ) ! = null | | ctx . REM ( ) ! = null | | ctx . SUB ( ) ! = null ; final boolean add = ctx . ADD ( ) ! = null ; final boolean xor = ctx . BWXOR ( ) ! = null ; final Type promote = add ? promoteAdd ( expremd0 . from , expremd1 . from ) : xor ? promoteXor ( expremd0 . from , expremd1 . from ) : promoteNumeric ( expremd0 . from , expremd1 . from , decimal , true ) ; if ( promote = = null ) { throw new ClassCastException ( <str> + ctx . getChild ( <int> ) . getText ( ) + <str> + <str> + expremd0 . from . name + <str> + expremd1 . from . name + <str> ) ; } final Sort sort = promote . sort ; expremd0 . to = add & & sort = = Sort . STRING ? expremd0 . from : promote ; expremd1 . to = add & & sort = = Sort . STRING ? expremd1 . from : promote ; markCast ( expremd0 ) ; markCast ( expremd1 ) ; if ( expremd0 . postConst ! = null & & expremd1 . postConst ! = null ) { if ( ctx . MUL ( ) ! = null ) { if ( sort = = Sort . INT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( int ) expremd0 . postConst * ( int ) expremd1 . postConst ; } else { binaryemd . preConst = Math . multiplyExact ( ( int ) expremd0 . postConst , ( int ) expremd1 . postConst ) ; } } else if ( sort = = Sort . LONG ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( long ) expremd0 . postConst * ( long ) expremd1 . postConst ; } else { binaryemd . preConst = Math . multiplyExact ( ( long ) expremd0 . postConst , ( long ) expremd1 . postConst ) ; } } else if ( sort = = Sort . FLOAT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( float ) expremd0 . postConst * ( float ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . multiplyWithoutOverflow ( ( float ) expremd0 . postConst , ( float ) expremd1 . postConst ) ; } } else if ( sort = = Sort . DOUBLE ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( double ) expremd0 . postConst * ( double ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . multiplyWithoutOverflow ( ( double ) expremd0 . postConst , ( double ) expremd1 . postConst ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . DIV ( ) ! = null ) { if ( sort = = Sort . INT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( int ) expremd0 . postConst / ( int ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . divideWithoutOverflow ( ( int ) expremd0 . postConst , ( int ) expremd1 . postConst ) ; } } else if ( sort = = Sort . LONG ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( long ) expremd0 . postConst / ( long ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . divideWithoutOverflow ( ( long ) expremd0 . postConst , ( long ) expremd1 . postConst ) ; } } else if ( sort = = Sort . FLOAT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( float ) expremd0 . postConst / ( float ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . divideWithoutOverflow ( ( float ) expremd0 . postConst , ( float ) expremd1 . postConst ) ; } } else if ( sort = = Sort . DOUBLE ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( double ) expremd0 . postConst / ( double ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . divideWithoutOverflow ( ( double ) expremd0 . postConst , ( double ) expremd1 . postConst ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . REM ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst % ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst % ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( float ) expremd0 . postConst % ( float ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . remainderWithoutOverflow ( ( float ) expremd0 . postConst , ( float ) expremd1 . postConst ) ; } } else if ( sort = = Sort . DOUBLE ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( double ) expremd0 . postConst % ( double ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . remainderWithoutOverflow ( ( double ) expremd0 . postConst , ( double ) expremd1 . postConst ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . ADD ( ) ! = null ) { if ( sort = = Sort . INT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( int ) expremd0 . postConst + ( int ) expremd1 . postConst ; } else { binaryemd . preConst = Math . addExact ( ( int ) expremd0 . postConst , ( int ) expremd1 . postConst ) ; } } else if ( sort = = Sort . LONG ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( long ) expremd0 . postConst + ( long ) expremd1 . postConst ; } else { binaryemd . preConst = Math . addExact ( ( long ) expremd0 . postConst , ( long ) expremd1 . postConst ) ; } } else if ( sort = = Sort . FLOAT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( float ) expremd0 . postConst + ( float ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . addWithoutOverflow ( ( float ) expremd0 . postConst , ( float ) expremd1 . postConst ) ; } } else if ( sort = = Sort . DOUBLE ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( double ) expremd0 . postConst + ( double ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . addWithoutOverflow ( ( double ) expremd0 . postConst , ( double ) expremd1 . postConst ) ; } } else if ( sort = = Sort . STRING ) { binaryemd . preConst = <str> + expremd0 . postConst + expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . SUB ( ) ! = null ) { if ( sort = = Sort . INT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( int ) expremd0 . postConst - ( int ) expremd1 . postConst ; } else { binaryemd . preConst = Math . subtractExact ( ( int ) expremd0 . postConst , ( int ) expremd1 . postConst ) ; } } else if ( sort = = Sort . LONG ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( long ) expremd0 . postConst - ( long ) expremd1 . postConst ; } else { binaryemd . preConst = Math . subtractExact ( ( long ) expremd0 . postConst , ( long ) expremd1 . postConst ) ; } } else if ( sort = = Sort . FLOAT ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( float ) expremd0 . postConst - ( float ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . subtractWithoutOverflow ( ( float ) expremd0 . postConst , ( float ) expremd1 . postConst ) ; } } else if ( sort = = Sort . DOUBLE ) { if ( settings . getNumericOverflow ( ) ) { binaryemd . preConst = ( double ) expremd0 . postConst - ( double ) expremd1 . postConst ; } else { binaryemd . preConst = Utility . subtractWithoutOverflow ( ( double ) expremd0 . postConst , ( double ) expremd1 . postConst ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . LSH ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst < < ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst < < ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . RSH ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst > > ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst > > ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . USH ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst > > > ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst > > > ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . BWAND ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst & ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst & ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . BWXOR ( ) ! = null ) { if ( sort = = Sort . BOOL ) { binaryemd . preConst = ( boolean ) expremd0 . postConst ^ ( boolean ) expremd1 . postConst ; } else if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst ^ ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst ^ ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else if ( ctx . BWOR ( ) ! = null ) { if ( sort = = Sort . INT ) { binaryemd . preConst = ( int ) expremd0 . postConst | ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { binaryemd . preConst = ( long ) expremd0 . postConst | ( long ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } binaryemd . from = promote ; binaryemd . typesafe = expremd0 . typesafe & & expremd1 . typesafe ; return null ; } @Override public Void visitComp ( final CompContext ctx ) { final ExpressionMetadata compemd = adapter . getExpressionMetadata ( ctx ) ; final boolean equality = ctx . EQ ( ) ! = null | | ctx . NE ( ) ! = null ; final boolean reference = ctx . EQR ( ) ! = null | | ctx . NER ( ) ! = null ; final ExpressionContext exprctx0 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd0 = adapter . createExpressionMetadata ( exprctx0 ) ; visit ( exprctx0 ) ; final ExpressionContext exprctx1 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd1 = adapter . createExpressionMetadata ( exprctx1 ) ; visit ( exprctx1 ) ; if ( expremd0 . isNull & & expremd1 . isNull ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } final Type promote = equality ? promoteEquality ( expremd0 . from , expremd1 . from ) : reference ? promoteReference ( expremd0 . from , expremd1 . from ) : promoteNumeric ( expremd0 . from , expremd1 . from , true , true ) ; if ( promote = = null ) { throw new ClassCastException ( <str> + ctx . getChild ( <int> ) . getText ( ) + <str> + <str> + expremd0 . from . name + <str> + expremd1 . from . name + <str> ) ; } expremd0 . to = promote ; expremd1 . to = promote ; markCast ( expremd0 ) ; markCast ( expremd1 ) ; if ( expremd0 . postConst ! = null & & expremd1 . postConst ! = null ) { final Sort sort = promote . sort ; if ( ctx . EQ ( ) ! = null | | ctx . EQR ( ) ! = null ) { if ( sort = = Sort . BOOL ) { compemd . preConst = ( boolean ) expremd0 . postConst = = ( boolean ) expremd1 . postConst ; } else if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst = = ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst = = ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst = = ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst = = ( double ) expremd1 . postConst ; } else { if ( ctx . EQ ( ) ! = null & & ! expremd0 . isNull & & ! expremd1 . isNull ) { compemd . preConst = expremd0 . postConst . equals ( expremd1 . postConst ) ; } else if ( ctx . EQR ( ) ! = null ) { compemd . preConst = expremd0 . postConst = = expremd1 . postConst ; } } } else if ( ctx . NE ( ) ! = null | | ctx . NER ( ) ! = null ) { if ( sort = = Sort . BOOL ) { compemd . preConst = ( boolean ) expremd0 . postConst ! = ( boolean ) expremd1 . postConst ; } else if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst ! = ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst ! = ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst ! = ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst ! = ( double ) expremd1 . postConst ; } else { if ( ctx . NE ( ) ! = null & & ! expremd0 . isNull & & ! expremd1 . isNull ) { compemd . preConst = expremd0 . postConst . equals ( expremd1 . postConst ) ; } else if ( ctx . NER ( ) ! = null ) { compemd . preConst = expremd0 . postConst = = expremd1 . postConst ; } } } else if ( ctx . GTE ( ) ! = null ) { if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst > = ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst > = ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst > = ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst > = ( double ) expremd1 . postConst ; } } else if ( ctx . GT ( ) ! = null ) { if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst > ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst > ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst > ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst > ( double ) expremd1 . postConst ; } } else if ( ctx . LTE ( ) ! = null ) { if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst < = ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst < = ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst < = ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst < = ( double ) expremd1 . postConst ; } } else if ( ctx . LT ( ) ! = null ) { if ( sort = = Sort . INT ) { compemd . preConst = ( int ) expremd0 . postConst < ( int ) expremd1 . postConst ; } else if ( sort = = Sort . LONG ) { compemd . preConst = ( long ) expremd0 . postConst < ( long ) expremd1 . postConst ; } else if ( sort = = Sort . FLOAT ) { compemd . preConst = ( float ) expremd0 . postConst < ( float ) expremd1 . postConst ; } else if ( sort = = Sort . DOUBLE ) { compemd . preConst = ( double ) expremd0 . postConst < ( double ) expremd1 . postConst ; } } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } compemd . from = definition . booleanType ; compemd . typesafe = expremd0 . typesafe & & expremd1 . typesafe ; return null ; } @Override public Void visitBool ( final BoolContext ctx ) { final ExpressionMetadata boolemd = adapter . getExpressionMetadata ( ctx ) ; final ExpressionContext exprctx0 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd0 = adapter . createExpressionMetadata ( exprctx0 ) ; expremd0 . to = definition . booleanType ; visit ( exprctx0 ) ; markCast ( expremd0 ) ; final ExpressionContext exprctx1 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd1 = adapter . createExpressionMetadata ( exprctx1 ) ; expremd1 . to = definition . booleanType ; visit ( exprctx1 ) ; markCast ( expremd1 ) ; if ( expremd0 . postConst ! = null & & expremd1 . postConst ! = null ) { if ( ctx . BOOLAND ( ) ! = null ) { boolemd . preConst = ( boolean ) expremd0 . postConst & & ( boolean ) expremd1 . postConst ; } else if ( ctx . BOOLOR ( ) ! = null ) { boolemd . preConst = ( boolean ) expremd0 . postConst | | ( boolean ) expremd1 . postConst ; } else { throw new IllegalStateException ( error ( ctx ) + <str> ) ; } } boolemd . from = definition . booleanType ; boolemd . typesafe = expremd0 . typesafe & & expremd1 . typesafe ; return null ; } @Override public Void visitConditional ( final ConditionalContext ctx ) { final ExpressionMetadata condemd = adapter . getExpressionMetadata ( ctx ) ; final ExpressionContext exprctx0 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd0 = adapter . createExpressionMetadata ( exprctx0 ) ; expremd0 . to = definition . booleanType ; visit ( exprctx0 ) ; markCast ( expremd0 ) ; if ( expremd0 . postConst ! = null ) { throw new IllegalArgumentException ( error ( ctx ) + <str> ) ; } final ExpressionContext exprctx1 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd1 = adapter . createExpressionMetadata ( exprctx1 ) ; expremd1 . to = condemd . to ; expremd1 . explicit = condemd . explicit ; visit ( exprctx1 ) ; final ExpressionContext exprctx2 = adapter . updateExpressionTree ( ctx . expression ( <int> ) ) ; final ExpressionMetadata expremd2 = adapter . createExpressionMetadata ( exprctx2 ) ; expremd2 . to = condemd . to ; expremd2 . explicit = condemd . explicit ; visit ( exprctx2 ) ; if ( condemd . to = = null ) { final Type promote = promoteConditional ( expremd1 . from , expremd2 . from , expremd1 . preConst , expremd2 . preConst ) ; expremd1 . to = promote ; expremd2 . to = promote ; condemd . from = promote ; } else { condemd . from = condemd . to ; } markCast ( expremd1 ) ; markCast ( expremd2 ) ; condemd . typesafe = expremd0 . typesafe & & expremd1 . typesafe ; return null ; } @Override public Void visitAssignment ( final AssignmentContext ctx ) { final ExpressionMetadata assignemd = adapter . getExpressionMetadata ( ctx ) ; final ExtstartContext extstartctx = ctx . extstart ( ) ; final ExternalMetadata extstartemd = adapter . createExternalMetadata ( extstartctx ) ; extstartemd . read = assignemd . read ; extstartemd . storeExpr = adapter . updateExpressionTree ( ctx . expression ( ) ) ; if ( ctx . AMUL ( ) ! = null ) { extstartemd . token = MUL ; } else if ( ctx . ADIV ( ) ! = null ) { extstartemd . token = DIV ; } else if ( ctx . AREM ( ) ! = null ) { extstartemd . token = REM ; } else if ( ctx . AADD ( ) ! = null ) { extstartemd . token = ADD ; } else if ( ctx . ASUB ( ) ! = null ) { extstartemd . token = SUB ; } else if ( ctx . ALSH ( ) ! = null ) { extstartemd . token = LSH ; } else if ( ctx . AUSH ( ) ! = null ) { extstartemd . token = USH ; } else if ( ctx . ARSH ( ) ! = null ) { extstartemd . token = RSH ; } else if ( ctx . AAND ( ) ! = null ) { extstartemd . token = BWAND ; } else if ( ctx . AXOR ( ) ! = null ) { extstartemd . token = BWXOR ; } else if ( ctx . AOR ( ) ! = null ) { extstartemd . token = BWOR ; } visit ( extstartctx ) ; assignemd . statement = true ; assignemd . from = extstartemd . read ? extstartemd . current : definition . voidType ; assignemd . typesafe = extstartemd . current . sort ! = Sort . DEF ; return null ; } @Override public Void visitExtstart ( final ExtstartContext ctx ) { final ExtprecContext precctx = ctx . extprec ( ) ; final ExtcastContext castctx = ctx . extcast ( ) ; final ExttypeContext typectx = ctx . exttype ( ) ; final ExtvarContext varctx = ctx . extvar ( ) ; 
