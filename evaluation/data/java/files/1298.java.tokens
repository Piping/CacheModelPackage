package com . google . common . cache ; import static com . google . common . cache . LocalCache . Strength . STRONG ; import static com . google . common . collect . Maps . immutableEntry ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Function ; import com . google . common . cache . LocalCache . Strength ; import com . google . common . cache . TestingRemovalListeners . CountingRemovalListener ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import junit . framework . TestCase ; import java . lang . ref . WeakReference ; public class CacheReferencesTest extends TestCase { private static final CacheLoader < Key , String > KEY_TO_STRING_LOADER = new CacheLoader < Key , String > ( ) { @Override public String load ( Key key ) { return key . toString ( ) ; } } ; private CacheBuilderFactory factoryWithAllKeyStrengths ( ) { return new CacheBuilderFactory ( ) . withKeyStrengths ( ImmutableSet . of ( STRONG , Strength . WEAK ) ) . withValueStrengths ( ImmutableSet . of ( STRONG , Strength . WEAK , Strength . SOFT ) ) ; } private Iterable < LoadingCache < Key , String > > caches ( ) { CacheBuilderFactory factory = factoryWithAllKeyStrengths ( ) ; return Iterables . transform ( factory . buildAllPermutations ( ) , new Function < CacheBuilder < Object , Object > , LoadingCache < Key , String > > ( ) { @Override public LoadingCache < Key , String > apply ( CacheBuilder < Object , Object > builder ) { return builder . build ( KEY_TO_STRING_LOADER ) ; } } ) ; } public void testContainsKeyAndValue ( ) { for ( LoadingCache < Key , String > cache : caches ( ) ) { Key key = new Key ( <int> ) ; String value = key . toString ( ) ; assertSame ( value , cache . getUnchecked ( key ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( key ) ) ; assertTrue ( cache . asMap ( ) . containsValue ( value ) ) ; assertEquals ( <int> , cache . size ( ) ) ; } } public void testClear ( ) { for ( LoadingCache < Key , String > cache : caches ( ) ) { Key key = new Key ( <int> ) ; String value = key . toString ( ) ; assertSame ( value , cache . getUnchecked ( key ) ) ; assertFalse ( cache . asMap ( ) . isEmpty ( ) ) ; cache . invalidateAll ( ) ; assertEquals ( <int> , cache . size ( ) ) ; assertTrue ( cache . asMap ( ) . isEmpty ( ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( key ) ) ; assertFalse ( cache . asMap ( ) . containsValue ( value ) ) ; } } public void testKeySetEntrySetValues ( ) { for ( LoadingCache < Key , String > cache : caches ( ) ) { Key key1 = new Key ( <int> ) ; String value1 = key1 . toString ( ) ; Key key2 = new Key ( <int> ) ; String value2 = key2 . toString ( ) ; assertSame ( value1 , cache . getUnchecked ( key1 ) ) ; assertSame ( value2 , cache . getUnchecked ( key2 ) ) ; assertEquals ( ImmutableSet . of ( key1 , key2 ) , cache . asMap ( ) . keySet ( ) ) ; assertThat ( cache . asMap ( ) . values ( ) ) . containsExactly ( value1 , value2 ) ; assertEquals ( ImmutableSet . of ( immutableEntry ( key1 , value1 ) , immutableEntry ( key2 , value2 ) ) , cache . asMap ( ) . entrySet ( ) ) ; } } public void testInvalidate ( ) { for ( LoadingCache < Key , String > cache : caches ( ) ) { Key key1 = new Key ( <int> ) ; String value1 = key1 . toString ( ) ; Key key2 = new Key ( <int> ) ; String value2 = key2 . toString ( ) ; assertSame ( value1 , cache . getUnchecked ( key1 ) ) ; assertSame ( value2 , cache . getUnchecked ( key2 ) ) ; cache . invalidate ( key1 ) ; assertFalse ( cache . asMap ( ) . containsKey ( key1 ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( key2 ) ) ; assertEquals ( <int> , cache . size ( ) ) ; assertEquals ( ImmutableSet . of ( key2 ) , cache . asMap ( ) . keySet ( ) ) ; assertThat ( cache . asMap ( ) . values ( ) ) . contains ( value2 ) ; assertEquals ( ImmutableSet . of ( immutableEntry ( key2 , value2 ) ) , cache . asMap ( ) . entrySet ( ) ) ; } } private void assertCleanup ( LoadingCache < Integer , String > cache , CountingRemovalListener < Integer , String > removalListener ) { long initialSize = cache . size ( ) ; assertTrue ( initialSize = = <int> | | initialSize = = <int> ) ; byte [ ] filler = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { System . gc ( ) ; CacheTesting . drainReferenceQueues ( cache ) ; if ( cache . size ( ) = = <int> ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } try { filler = new byte [ Math . max ( filler . length , filler . length * <int> ) ] ; } catch ( OutOfMemoryError e ) { } } CacheTesting . processPendingNotifications ( cache ) ; assertEquals ( <int> , cache . size ( ) ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; } static class Key { private final int value ; private WeakReference < String > toString ; Key ( int value ) { this . value = value ; } @Override public synchronized String toString ( ) { String s ; if ( toString ! = null ) { s = toString . get ( ) ; if ( s ! = null ) { return s ; } } s = Integer . toString ( value ) ; toString = new WeakReference < String > ( s ) ; return s ; } } }