package org . apache . cassandra . repair . messages ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . junit . Test ; import com . google . common . collect . ImmutableMap ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . repair . RepairParallelism ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class RepairOptionTest { @Test public void testParseOptions ( ) { IPartitioner partitioner = Murmur3Partitioner . instance ; Token . TokenFactory tokenFactory = partitioner . getTokenFactory ( ) ; RepairOption option = RepairOption . parse ( new HashMap < String , String > ( ) , partitioner ) ; if ( FBUtilities . isWindows ( ) & & ( DatabaseDescriptor . getDiskAccessMode ( ) ! = Config . DiskAccessMode . standard | | DatabaseDescriptor . getIndexAccessMode ( ) ! = Config . DiskAccessMode . standard ) ) assertTrue ( option . getParallelism ( ) = = RepairParallelism . PARALLEL ) ; else assertTrue ( option . getParallelism ( ) = = RepairParallelism . SEQUENTIAL ) ; assertFalse ( option . isPrimaryRange ( ) ) ; assertFalse ( option . isIncremental ( ) ) ; Map < String , String > options = new HashMap < > ( ) ; options . put ( RepairOption . PARALLELISM_KEY , <str> ) ; options . put ( RepairOption . PRIMARY_RANGE_KEY , <str> ) ; options . put ( RepairOption . INCREMENTAL_KEY , <str> ) ; options . put ( RepairOption . RANGES_KEY , <str> ) ; options . put ( RepairOption . COLUMNFAMILIES_KEY , <str> ) ; options . put ( RepairOption . DATACENTERS_KEY , <str> ) ; options . put ( RepairOption . HOSTS_KEY , <str> ) ; option = RepairOption . parse ( options , partitioner ) ; assertTrue ( option . getParallelism ( ) = = RepairParallelism . PARALLEL ) ; assertFalse ( option . isPrimaryRange ( ) ) ; assertFalse ( option . isIncremental ( ) ) ; Set < Range < Token > > expectedRanges = new HashSet < > ( <int> ) ; expectedRanges . add ( new Range < > ( tokenFactory . fromString ( <str> ) , tokenFactory . fromString ( <str> ) ) ) ; expectedRanges . add ( new Range < > ( tokenFactory . fromString ( <str> ) , tokenFactory . fromString ( <str> ) ) ) ; expectedRanges . add ( new Range < > ( tokenFactory . fromString ( <str> ) , tokenFactory . fromString ( <str> ) ) ) ; assertEquals ( expectedRanges , option . getRanges ( ) ) ; Set < String > expectedCFs = new HashSet < > ( <int> ) ; expectedCFs . add ( <str> ) ; expectedCFs . add ( <str> ) ; expectedCFs . add ( <str> ) ; assertEquals ( expectedCFs , option . getColumnFamilies ( ) ) ; Set < String > expectedDCs = new HashSet < > ( <int> ) ; expectedDCs . add ( <str> ) ; expectedDCs . add ( <str> ) ; expectedDCs . add ( <str> ) ; assertEquals ( expectedDCs , option . getDataCenters ( ) ) ; Set < String > expectedHosts = new HashSet < > ( <int> ) ; expectedHosts . add ( <str> ) ; expectedHosts . add ( <str> ) ; expectedHosts . add ( <str> ) ; assertEquals ( expectedHosts , option . getHosts ( ) ) ; } @Test public void testIncrementalRepairWithSubrangesIsNotGlobal ( ) throws Exception { RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL_KEY , <str> , RepairOption . RANGES_KEY , <str> ) , Murmur3Partitioner . instance ) ; assertFalse ( ro . isGlobal ( ) ) ; ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL_KEY , <str> , RepairOption . RANGES_KEY , <str> ) , Murmur3Partitioner . instance ) ; assertTrue ( ro . isGlobal ( ) ) ; } }