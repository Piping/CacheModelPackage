package org . elasticsearch . messy . tests ; import org . apache . lucene . util . ArrayUtil ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . index . query . functionscore . FunctionScoreQueryBuilder ; import org . elasticsearch . index . query . functionscore . random . RandomScoreFunctionBuilder ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . script . groovy . GroovyPlugin ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . CoreMatchers ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . * ; import static org . elasticsearch . index . query . functionscore . ScoreFunctionBuilders . * ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . * ; public class RandomScoreFunctionTests extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Collections . singleton ( GroovyPlugin . class ) ; } public void testConsistentHitsWithSameSeed ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; int docCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docCount ; i + + ) { index ( <str> , <str> , <str> + i , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; } flush ( ) ; refresh ( ) ; int outerIters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int o = <int> ; o < outerIters ; o + + ) { final int seed = randomInt ( ) ; String preference = randomRealisticUnicodeOfLengthBetween ( <int> , <int> ) ; while ( preference . startsWith ( <str> ) ) { preference = randomRealisticUnicodeOfLengthBetween ( <int> , <int> ) ; } int innerIters = scaledRandomIntBetween ( <int> , <int> ) ; SearchHit [ ] hits = null ; for ( int i = <int> ; i < innerIters ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setSize ( docCount ) . setPreference ( preference ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( seed ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( <str> + Arrays . toString ( searchResponse . getShardFailures ( ) ) , searchResponse . getShardFailures ( ) . length , CoreMatchers . equalTo ( <int> ) ) ; final int hitCount = searchResponse . getHits ( ) . getHits ( ) . length ; final SearchHit [ ] currentHits = searchResponse . getHits ( ) . getHits ( ) ; ArrayUtil . timSort ( currentHits , new Comparator < SearchHit > ( ) { @Override public int compare ( SearchHit o1 , SearchHit o2 ) { int cmp = Float . compare ( o1 . getScore ( ) , o2 . getScore ( ) ) ; return cmp = = <int> ? o1 . getId ( ) . compareTo ( o2 . getId ( ) ) : cmp ; } } ) ; if ( i = = <int> ) { assertThat ( hits , nullValue ( ) ) ; hits = currentHits ; } else { assertThat ( hits . length , equalTo ( searchResponse . getHits ( ) . getHits ( ) . length ) ) ; for ( int j = <int> ; j < hitCount ; j + + ) { assertThat ( <str> + j , currentHits [ j ] . score ( ) , equalTo ( hits [ j ] . score ( ) ) ) ; assertThat ( <str> + j , currentHits [ j ] . id ( ) , equalTo ( hits [ j ] . id ( ) ) ) ; } } int numDocsToChange = randomIntBetween ( <int> , <int> ) ; while ( numDocsToChange > <int> ) { int doc = randomInt ( docCount - <int> ) ; index ( <str> , <str> , <str> + doc , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; - - numDocsToChange ; } flush ( ) ; refresh ( ) ; } } } public void testScoreAccessWithinScript ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> + randomFrom ( <str> , <str> , <str> , <str> , <str> ) ) ) ; ensureYellow ( ) ; int docCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docCount ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , randomFrom ( Arrays . asList ( <str> , <str> , <str> ) ) , <str> , i + <int> ) . get ( ) ; } refresh ( ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( <str> , randomIntBetween ( <int> , <int> ) ) ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( fieldValueFactorFunction ( <str> ) . factor ( <int> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) } ) ) . get ( ) ; assertNoFailures ( resp ) ; SearchHit firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . getScore ( ) , greaterThan ( <int> f ) ) ; resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( fieldValueFactorFunction ( <str> ) . factor ( <int> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) } ) ) . get ( ) ; assertNoFailures ( resp ) ; firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . getScore ( ) , greaterThan ( <int> f ) ) ; resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( fieldValueFactorFunction ( <str> ) . factor ( <int> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) } ) ) . get ( ) ; assertNoFailures ( resp ) ; firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . getScore ( ) , greaterThan ( <int> f ) ) ; resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( fieldValueFactorFunction ( <str> ) . factor ( <int> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) } ) ) . get ( ) ; assertNoFailures ( resp ) ; firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . getScore ( ) , greaterThan ( <int> f ) ) ; resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( fieldValueFactorFunction ( <str> ) . factor ( <int> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) } ) ) . get ( ) ; assertNoFailures ( resp ) ; firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . getScore ( ) , greaterThan ( <int> f ) ) ; } public void testSeedReportedInExplain ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; index ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; flush ( ) ; refresh ( ) ; int seed = <int> ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( seed ) ) ) . setExplain ( true ) . get ( ) ; assertNoFailures ( resp ) ; assertEquals ( <int> , resp . getHits ( ) . totalHits ( ) ) ; SearchHit firstHit = resp . getHits ( ) . getAt ( <int> ) ; assertThat ( firstHit . explanation ( ) . toString ( ) , containsString ( <str> + seed ) ) ; } public void testNoDocs ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( <int> ) ) ) . get ( ) ; assertNoFailures ( resp ) ; assertEquals ( <int> , resp . getHits ( ) . totalHits ( ) ) ; } public void testScoreRange ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; int docCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docCount ; i + + ) { String id = randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) ; index ( <str> , <str> , id , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; } flush ( ) ; refresh ( ) ; int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; + + i ) { int seed = randomInt ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( seed ) ) ) . setSize ( docCount ) . execute ( ) . actionGet ( ) ; assertNoFailures ( searchResponse ) ; for ( SearchHit hit : searchResponse . getHits ( ) . getHits ( ) ) { assertThat ( hit . score ( ) , allOf ( greaterThanOrEqualTo ( <float> ) , lessThanOrEqualTo ( <float> ) ) ) ; } } } public void testSeeds ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; final int docCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docCount ; i + + ) { index ( <str> , <str> , <str> + i , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; } flushAndRefresh ( ) ; assertNoFailures ( client ( ) . prepareSearch ( ) . setSize ( docCount ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( randomInt ( ) ) ) ) . execute ( ) . actionGet ( ) ) ; assertNoFailures ( client ( ) . prepareSearch ( ) . setSize ( docCount ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( randomLong ( ) ) ) ) . execute ( ) . actionGet ( ) ) ; assertNoFailures ( client ( ) . prepareSearch ( ) . setSize ( docCount ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , randomFunction ( randomRealisticUnicodeOfLengthBetween ( <int> , <int> ) ) ) ) . execute ( ) . actionGet ( ) ) ; } public void checkDistribution ( ) throws Exception { int count = <int> ; assertAcked ( prepareCreate ( <str> ) ) ; ensureGreen ( ) ; for ( int i = <int> ; i < count ; i + + ) { index ( <str> , <str> , <str> + i , jsonBuilder ( ) . startObject ( ) . endObject ( ) ) ; } flush ( ) ; refresh ( ) ; int [ ] matrix = new int [ count ] ; for ( int i = <int> ; i < count ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( functionScoreQuery ( matchAllQuery ( ) , new RandomScoreFunctionBuilder ( ) ) ) . execute ( ) . actionGet ( ) ; matrix [ Integer . valueOf ( searchResponse . getHits ( ) . getAt ( <int> ) . id ( ) ) ] + + ; } int filled = <int> ; int maxRepeat = <int> ; int sumRepeat = <int> ; for ( int i = <int> ; i < matrix . length ; i + + ) { int value = matrix [ i ] ; sumRepeat + = value ; maxRepeat = Math . max ( maxRepeat , value ) ; if ( value > <int> ) { filled + + ; } } System . out . println ( ) ; System . out . println ( <str> + maxRepeat ) ; System . out . println ( <str> + sumRepeat / ( double ) filled ) ; System . out . println ( <str> + filled / ( double ) count ) ; int percentile50 = filled / <int> ; int percentile25 = ( filled / <int> ) ; int percentile75 = percentile50 + percentile25 ; int sum = <int> ; for ( int i = <int> ; i < matrix . length ; i + + ) { if ( matrix [ i ] = = <int> ) { continue ; } sum + = i * matrix [ i ] ; if ( percentile50 = = <int> ) { System . out . println ( <str> + i ) ; } else if ( percentile25 = = <int> ) { System . out . println ( <str> + i ) ; } else if ( percentile75 = = <int> ) { System . out . println ( <str> + i ) ; } percentile50 - - ; percentile25 - - ; percentile75 - - ; } System . out . println ( <str> + sum / ( double ) count ) ; } } 
