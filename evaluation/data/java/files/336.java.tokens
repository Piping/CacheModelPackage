package com . netflix . hystrix . contrib . requests . stream ; import com . netflix . config . DynamicIntProperty ; import com . netflix . config . DynamicPropertyFactory ; import com . netflix . hystrix . metric . HystrixRequestEvents ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import rx . Subscriber ; import rx . Subscription ; import rx . schedulers . Schedulers ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public class HystrixRequestEventsSseServlet extends HttpServlet { private static final Logger logger = LoggerFactory . getLogger ( HystrixRequestEventsSseServlet . class ) ; private static volatile boolean isDestroyed = false ; private static final String DELAY_REQ_PARAM_NAME = <str> ; private static final int DEFAULT_DELAY_IN_MILLISECONDS = <int> ; private static final int DEFAULT_QUEUE_DEPTH = <int> ; private static final String PING = <str> ; private static AtomicInteger concurrentConnections = new AtomicInteger ( <int> ) ; private static DynamicIntProperty maxConcurrentConnections = DynamicPropertyFactory . getInstance ( ) . getIntProperty ( <str> , <int> ) ; private final LinkedBlockingQueue < HystrixRequestEvents > requestQueue = new LinkedBlockingQueue < HystrixRequestEvents > ( DEFAULT_QUEUE_DEPTH ) ; private final HystrixRequestEventsJsonStream requestEventsJsonStream ; public HystrixRequestEventsSseServlet ( ) { requestEventsJsonStream = new HystrixRequestEventsJsonStream ( ) ; } @Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { if ( isDestroyed ) { response . sendError ( <int> , <str> ) ; } else { handleRequest ( request , response ) ; } } int getDelayFromHttpRequest ( HttpServletRequest req ) { try { String delay = req . getParameter ( DELAY_REQ_PARAM_NAME ) ; if ( delay ! = null ) { return Math . max ( Integer . parseInt ( delay ) , <int> ) ; } } catch ( Throwable ex ) { } return DEFAULT_DELAY_IN_MILLISECONDS ; } public static void shutdown ( ) { isDestroyed = true ; } @Override public void init ( ) throws ServletException { isDestroyed = false ; } @Override public void destroy ( ) { isDestroyed = true ; super . destroy ( ) ; } private void handleRequest ( HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final AtomicBoolean moreDataWillBeSent = new AtomicBoolean ( true ) ; Subscription requestsSubscription = null ; int numberConnections = concurrentConnections . incrementAndGet ( ) ; try { int maxNumberConnectionsAllowed = maxConcurrentConnections . get ( ) ; if ( numberConnections > maxNumberConnectionsAllowed ) { response . sendError ( <int> , <str> + maxNumberConnectionsAllowed ) ; } else { int delay = getDelayFromHttpRequest ( request ) ; response . setHeader ( <str> , <str> ) ; response . setHeader ( <str> , <str> ) ; response . setHeader ( <str> , <str> ) ; final PrintWriter writer = response . getWriter ( ) ; requestsSubscription = requestEventsJsonStream . getStream ( ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new Subscriber < HystrixRequestEvents > ( ) { @Override public void onCompleted ( ) { logger . error ( <str> ) ; moreDataWillBeSent . set ( false ) ; } @Override public void onError ( Throwable e ) { moreDataWillBeSent . set ( false ) ; } @Override public void onNext ( HystrixRequestEvents requestEvents ) { if ( requestEvents ! = null ) { requestQueue . offer ( requestEvents ) ; } } } ) ; while ( moreDataWillBeSent . get ( ) & & ! isDestroyed ) { try { if ( requestQueue . isEmpty ( ) ) { try { writer . print ( PING ) ; writer . flush ( ) ; } catch ( Throwable t ) { throw new IOException ( <str> ) ; } if ( writer . checkError ( ) ) { throw new IOException ( <str> ) ; } } else { List < HystrixRequestEvents > l = new ArrayList < HystrixRequestEvents > ( ) ; requestQueue . drainTo ( l ) ; String requestEventsAsStr = HystrixRequestEventsJsonStream . convertRequestsToJson ( l ) ; if ( requestEventsAsStr ! = null ) { try { writer . print ( <str> + requestEventsAsStr + <str> ) ; if ( writer . checkError ( ) ) { throw new IOException ( <str> ) ; } writer . flush ( ) ; } catch ( IOException ioe ) { moreDataWillBeSent . set ( false ) ; } } } Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { moreDataWillBeSent . set ( false ) ; } } } } finally { concurrentConnections . decrementAndGet ( ) ; if ( requestsSubscription ! = null & & ! requestsSubscription . isUnsubscribed ( ) ) { requestsSubscription . unsubscribe ( ) ; } } } }