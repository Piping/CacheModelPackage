package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . Test ; import org . mockito . InOrder ; import rx . Observable ; import rx . Observer ; import rx . Subscriber ; import rx . functions . Func1 ; import rx . internal . util . RxRingBuffer ; import rx . internal . util . UtilityFunctions ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; public class OperatorTakeLastTest { @Test public void testTakeLastEmpty ( ) { Observable < String > w = Observable . empty ( ) ; Observable < String > take = w . takeLast ( <int> ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; take . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testTakeLast1 ( ) { Observable < String > w = Observable . just ( <str> , <str> , <str> ) ; Observable < String > take = w . takeLast ( <int> ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; InOrder inOrder = inOrder ( observer ) ; take . subscribe ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testTakeLast2 ( ) { Observable < String > w = Observable . just ( <str> ) ; Observable < String > take = w . takeLast ( <int> ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; take . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testTakeLastWithZeroCount ( ) { Observable < String > w = Observable . just ( <str> ) ; Observable < String > take = w . takeLast ( <int> ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; take . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testTakeLastWithNull ( ) { Observable < String > w = Observable . just ( <str> , null , <str> ) ; Observable < String > take = w . takeLast ( <int> ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; take . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( null ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testTakeLastWithNegativeCount ( ) { Observable . just ( <str> ) . takeLast ( - <int> ) ; } @Test public void testBackpressure1 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . range ( <int> , <int> ) . takeLast ( <int> ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; } @Test public void testBackpressure2 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . range ( <int> , <int> ) . takeLast ( RxRingBuffer . SIZE * <int> ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( RxRingBuffer . SIZE * <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } private Func1 < Integer , Integer > newSlowProcessor ( ) { return new Func1 < Integer , Integer > ( ) { int c = <int> ; @Override public Integer call ( Integer i ) { if ( c + + < <int> ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } return i ; } } ; } @Test public void testIssue1522 ( ) { assertEquals ( <int> , Observable . empty ( ) . count ( ) . filter ( UtilityFunctions . alwaysFalse ( ) ) . toList ( ) . toBlocking ( ) . single ( ) . size ( ) ) ; } @Test public void testIgnoreRequest1 ( ) { Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( Long . MAX_VALUE ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { request ( Long . MAX_VALUE ) ; } } ) ; } @Test public void testIgnoreRequest2 ( ) { Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { request ( <int> ) ; } } ) ; } @Test ( timeout = <int> ) public void testIgnoreRequest3 ( ) { Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { request ( Long . MAX_VALUE ) ; } } ) ; } @Test public void testIgnoreRequest4 ( ) { Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( Long . MAX_VALUE ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { request ( <int> ) ; } } ) ; } @Test public void testUnsubscribeTakesEffectEarlyOnFastPath ( ) { final AtomicInteger count = new AtomicInteger ( ) ; Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( Long . MAX_VALUE ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { count . incrementAndGet ( ) ; unsubscribe ( ) ; } } ) ; assertEquals ( <int> , count . get ( ) ) ; } @Test ( timeout = <int> ) public void testRequestOverflow ( ) { final List < Integer > list = new ArrayList < Integer > ( ) ; Observable . range ( <int> , <int> ) . takeLast ( <int> ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer t ) { list . add ( t ) ; request ( Long . MAX_VALUE - <int> ) ; } } ) ; assertEquals ( <int> , list . size ( ) ) ; } }