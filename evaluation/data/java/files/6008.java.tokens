package rx . internal . operators ; import java . util . concurrent . atomic . AtomicLong ; import rx . Notification ; import rx . Observable . Operator ; import rx . Producer ; import rx . Subscriber ; import rx . plugins . RxJavaPlugins ; public final class OperatorMaterialize < T > implements Operator < Notification < T > , T > { private static final class Holder { static final OperatorMaterialize < Object > INSTANCE = new OperatorMaterialize < Object > ( ) ; } @SuppressWarnings ( <str> ) public static < T > OperatorMaterialize < T > instance ( ) { return ( OperatorMaterialize < T > ) Holder . INSTANCE ; } private OperatorMaterialize ( ) { } @Override public Subscriber < ? super T > call ( final Subscriber < ? super Notification < T > > child ) { final ParentSubscriber < T > parent = new ParentSubscriber < T > ( child ) ; child . add ( parent ) ; child . setProducer ( new Producer ( ) { @Override public void request ( long n ) { if ( n > <int> ) { parent . requestMore ( n ) ; } } } ) ; return parent ; } private static class ParentSubscriber < T > extends Subscriber < T > { private final Subscriber < ? super Notification < T > > child ; private volatile Notification < T > terminalNotification ; private boolean busy = false ; private boolean missed = false ; private final AtomicLong requested = new AtomicLong ( ) ; ParentSubscriber ( Subscriber < ? super Notification < T > > child ) { this . child = child ; } @Override public void onStart ( ) { request ( <int> ) ; } void requestMore ( long n ) { BackpressureUtils . getAndAddRequest ( requested , n ) ; request ( n ) ; drain ( ) ; } @Override public void onCompleted ( ) { terminalNotification = Notification . createOnCompleted ( ) ; drain ( ) ; } @Override public void onError ( Throwable e ) { terminalNotification = Notification . createOnError ( e ) ; RxJavaPlugins . getInstance ( ) . getErrorHandler ( ) . handleError ( e ) ; drain ( ) ; } @Override public void onNext ( T t ) { child . onNext ( Notification . createOnNext ( t ) ) ; decrementRequested ( ) ; } private void decrementRequested ( ) { AtomicLong localRequested = this . requested ; while ( true ) { long r = localRequested . get ( ) ; if ( r = = Long . MAX_VALUE ) { return ; } else if ( localRequested . compareAndSet ( r , r - <int> ) ) { return ; } } } private void drain ( ) { synchronized ( this ) { if ( busy ) { missed = true ; return ; } } final AtomicLong localRequested = this . requested ; while ( ! child . isUnsubscribed ( ) ) { Notification < T > tn ; tn = terminalNotification ; if ( tn ! = null ) { if ( localRequested . get ( ) > <int> ) { terminalNotification = null ; child . onNext ( tn ) ; if ( ! child . isUnsubscribed ( ) ) { child . onCompleted ( ) ; } return ; } } synchronized ( this ) { if ( ! missed ) { busy = false ; return ; } } } } } }