package org . elasticsearch . search . fetch ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . termvectors . TermVectorsRequest ; import org . elasticsearch . action . termvectors . TermVectorsResponse ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . search . SearchHitField ; import org . elasticsearch . search . SearchModule ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import org . elasticsearch . search . internal . InternalSearchHit ; import org . elasticsearch . search . internal . InternalSearchHitField ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . singletonMap ; import static org . elasticsearch . client . Requests . indexRequest ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . CoreMatchers . equalTo ; @ClusterScope ( scope = Scope . SUITE , numDataNodes = <int> ) public class FetchSubPhasePluginIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( FetchTermVectorsPlugin . class ) ; } public void testPlugin ( ) throws Exception { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; XContentBuilder extSource = jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; SearchResponse response = client ( ) . prepareSearch ( ) . setSource ( new SearchSourceBuilder ( ) . ext ( extSource ) ) . get ( ) ; assertSearchResponse ( response ) ; assertThat ( ( ( Map < String , Integer > ) response . getHits ( ) . getAt ( <int> ) . field ( <str> ) . getValues ( ) . get ( <int> ) ) . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Integer > ) response . getHits ( ) . getAt ( <int> ) . field ( <str> ) . getValues ( ) . get ( <int> ) ) . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( ( ( Map < String , Integer > ) response . getHits ( ) . getAt ( <int> ) . field ( <str> ) . getValues ( ) . get ( <int> ) ) . get ( <str> ) , equalTo ( <int> ) ) ; } public static class FetchTermVectorsPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( SearchModule searchModule ) { searchModule . registerFetchSubPhase ( TermVectorsFetchSubPhase . class ) ; } } public static class TermVectorsFetchSubPhase implements FetchSubPhase { public static final ContextFactory < TermVectorsFetchContext > CONTEXT_FACTORY = new ContextFactory < TermVectorsFetchContext > ( ) { @Override public String getName ( ) { return NAMES [ <int> ] ; } @Override public TermVectorsFetchContext newContextInstance ( ) { return new TermVectorsFetchContext ( ) ; } } ; public TermVectorsFetchSubPhase ( ) { } public static final String [ ] NAMES = { <str> } ; @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { return singletonMap ( <str> , new TermVectorsFetchParseElement ( ) ) ; } @Override public boolean hitsExecutionNeeded ( SearchContext context ) { return false ; } @Override public void hitsExecute ( SearchContext context , InternalSearchHit [ ] hits ) { } @Override public boolean hitExecutionNeeded ( SearchContext context ) { return context . getFetchSubPhaseContext ( CONTEXT_FACTORY ) . hitExecutionNeeded ( ) ; } @Override public void hitExecute ( SearchContext context , HitContext hitContext ) { String field = context . getFetchSubPhaseContext ( CONTEXT_FACTORY ) . getField ( ) ; if ( hitContext . hit ( ) . fieldsOrNull ( ) = = null ) { hitContext . hit ( ) . fields ( new HashMap < String , SearchHitField > ( ) ) ; } SearchHitField hitField = hitContext . hit ( ) . fields ( ) . get ( NAMES [ <int> ] ) ; if ( hitField = = null ) { hitField = new InternalSearchHitField ( NAMES [ <int> ] , new ArrayList < > ( <int> ) ) ; hitContext . hit ( ) . fields ( ) . put ( NAMES [ <int> ] , hitField ) ; } TermVectorsResponse termVector = context . indexShard ( ) . getTermVectors ( new TermVectorsRequest ( context . indexShard ( ) . shardId ( ) . index ( ) . getName ( ) , hitContext . hit ( ) . type ( ) , hitContext . hit ( ) . id ( ) ) ) ; try { Map < String , Integer > tv = new HashMap < > ( ) ; TermsEnum terms = termVector . getFields ( ) . terms ( field ) . iterator ( ) ; BytesRef term ; while ( ( term = terms . next ( ) ) ! = null ) { tv . put ( term . utf8ToString ( ) , terms . postings ( null , PostingsEnum . ALL ) . freq ( ) ) ; } hitField . values ( ) . add ( tv ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } public static class TermVectorsFetchParseElement extends FetchSubPhaseParseElement < TermVectorsFetchContext > { @Override protected void innerParse ( XContentParser parser , TermVectorsFetchContext termVectorsFetchContext , SearchContext searchContext ) throws Exception { XContentParser . Token token = parser . currentToken ( ) ; if ( token = = XContentParser . Token . VALUE_STRING ) { String fieldName = parser . text ( ) ; termVectorsFetchContext . setField ( fieldName ) ; } else { throw new IllegalStateException ( <str> + token ) ; } } @Override protected FetchSubPhase . ContextFactory getContextFactory ( ) { return TermVectorsFetchSubPhase . CONTEXT_FACTORY ; } } public static class TermVectorsFetchContext extends FetchSubPhaseContext { private String field = null ; public TermVectorsFetchContext ( ) { } public void setField ( String field ) { this . field = field ; } public String getField ( ) { return field ; } } } 
