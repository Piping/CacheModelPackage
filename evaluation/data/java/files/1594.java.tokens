package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . Uninterruptibles . awaitUninterruptibly ; import com . google . common . util . concurrent . ForwardingListenableFuture . SimpleForwardingListenableFuture ; import java . lang . reflect . UndeclaredThrowableException ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; public class FuturesTransformAsyncTest extends AbstractChainedListenableFutureTest < String > { protected static final int SLOW_OUTPUT_VALID_INPUT_DATA = <int> ; protected static final int SLOW_FUNC_VALID_INPUT_DATA = <int> ; private static final String RESULT_DATA = <str> ; private SettableFuture < String > outputFuture ; private CountDownLatch funcIsWaitingLatch ; private CountDownLatch funcCompletionLatch ; @Override protected ListenableFuture < String > buildChainingFuture ( ListenableFuture < Integer > inputFuture ) { outputFuture = SettableFuture . create ( ) ; funcIsWaitingLatch = new CountDownLatch ( <int> ) ; funcCompletionLatch = new CountDownLatch ( <int> ) ; return Futures . transformAsync ( inputFuture , new ChainingFunction ( ) ) ; } @Override protected String getSuccessfulResult ( ) { return RESULT_DATA ; } private class ChainingFunction implements AsyncFunction < Integer , String > { @Override public ListenableFuture < String > apply ( Integer input ) { switch ( input ) { case VALID_INPUT_DATA : outputFuture . set ( RESULT_DATA ) ; break ; case SLOW_OUTPUT_VALID_INPUT_DATA : break ; case SLOW_FUNC_VALID_INPUT_DATA : funcIsWaitingLatch . countDown ( ) ; awaitUninterruptibly ( funcCompletionLatch ) ; break ; default : throw new UndeclaredThrowableException ( EXCEPTION ) ; } return outputFuture ; } } public void testFutureGetThrowsFunctionException ( ) throws Exception { inputFuture . set ( EXCEPTION_DATA ) ; listener . assertException ( EXCEPTION ) ; } public void testFutureGetThrowsCancellationIfInputCancelled ( ) throws Exception { inputFuture . cancel ( true ) ; try { resultFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } } public void testFutureGetThrowsCancellationIfOutputCancelled ( ) throws Exception { inputFuture . set ( SLOW_OUTPUT_VALID_INPUT_DATA ) ; outputFuture . cancel ( true ) ; try { resultFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } } public void testFutureCancelBeforeInputCompletion ( ) throws Exception { assertTrue ( resultFuture . cancel ( true ) ) ; assertTrue ( resultFuture . isCancelled ( ) ) ; assertTrue ( inputFuture . isCancelled ( ) ) ; assertFalse ( outputFuture . isCancelled ( ) ) ; try { resultFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } } public void testFutureCancellableBeforeOutputCompletion ( ) throws Exception { inputFuture . set ( SLOW_OUTPUT_VALID_INPUT_DATA ) ; assertTrue ( resultFuture . cancel ( true ) ) ; assertTrue ( resultFuture . isCancelled ( ) ) ; assertFalse ( inputFuture . isCancelled ( ) ) ; assertTrue ( outputFuture . isCancelled ( ) ) ; try { resultFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } } public void testFutureCancellableBeforeFunctionCompletion ( ) throws Exception { new Thread ( ) { @Override public void run ( ) { inputFuture . set ( SLOW_FUNC_VALID_INPUT_DATA ) ; } } . start ( ) ; funcIsWaitingLatch . await ( ) ; assertTrue ( resultFuture . cancel ( true ) ) ; assertTrue ( resultFuture . isCancelled ( ) ) ; assertFalse ( inputFuture . isCancelled ( ) ) ; assertFalse ( outputFuture . isCancelled ( ) ) ; try { resultFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } funcCompletionLatch . countDown ( ) ; try { outputFuture . get ( ) ; fail ( <str> + <str> ) ; } catch ( CancellationException expected ) { } } public void testFutureCancelAfterCompletion ( ) throws Exception { inputFuture . set ( VALID_INPUT_DATA ) ; assertFalse ( resultFuture . cancel ( true ) ) ; assertFalse ( resultFuture . isCancelled ( ) ) ; assertFalse ( inputFuture . isCancelled ( ) ) ; assertFalse ( outputFuture . isCancelled ( ) ) ; assertEquals ( RESULT_DATA , resultFuture . get ( ) ) ; } public void testFutureGetThrowsRuntimeException ( ) throws Exception { BadFuture badInput = new BadFuture ( Futures . immediateFuture ( <int> ) ) ; ListenableFuture < String > chain = buildChainingFuture ( badInput ) ; try { chain . get ( ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertSame ( RuntimeException . class , e . getCause ( ) . getClass ( ) ) ; } } public static class BadFuture extends SimpleForwardingListenableFuture < Integer > { protected BadFuture ( ListenableFuture < Integer > delegate ) { super ( delegate ) ; } @Override public Integer get ( ) { throw new RuntimeException ( <str> ) ; } } }