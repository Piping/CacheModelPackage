package rx . internal . operators ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . HashMap ; import java . util . Map ; import java . util . NoSuchElementException ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import rx . Observable ; import rx . Observer ; import rx . Subscriber ; import rx . exceptions . OnErrorNotImplementedException ; import rx . functions . Action1 ; import rx . functions . Func1 ; import rx . functions . Func2 ; import rx . internal . operators . OperatorMap ; import rx . schedulers . Schedulers ; public class OperatorMapTest { @Mock Observer < String > stringObserver ; @Mock Observer < String > stringObserver2 ; final static Func2 < String , Integer , String > APPEND_INDEX = new Func2 < String , Integer , String > ( ) { @Override public String call ( String value , Integer index ) { return value + index ; } } ; @Before public void before ( ) { MockitoAnnotations . initMocks ( this ) ; } @Test public void testMap ( ) { Map < String , String > m1 = getMap ( <str> ) ; Map < String , String > m2 = getMap ( <str> ) ; Observable < Map < String , String > > observable = Observable . just ( m1 , m2 ) ; Observable < String > m = observable . lift ( new OperatorMap < Map < String , String > , String > ( new Func1 < Map < String , String > , String > ( ) { @Override public String call ( Map < String , String > map ) { return map . get ( <str> ) ; } } ) ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testMapMany ( ) { Observable < Integer > ids = Observable . just ( <int> , <int> ) ; Observable < String > m = ids . flatMap ( new Func1 < Integer , Observable < String > > ( ) { @Override public Observable < String > call ( Integer id ) { Observable < Map < String , String > > subObservable ; if ( id = = <int> ) { Map < String , String > m1 = getMap ( <str> ) ; Map < String , String > m2 = getMap ( <str> ) ; subObservable = Observable . just ( m1 , m2 ) ; } else { Map < String , String > m3 = getMap ( <str> ) ; Map < String , String > m4 = getMap ( <str> ) ; subObservable = Observable . just ( m3 , m4 ) ; } return subObservable . map ( new Func1 < Map < String , String > , String > ( ) { @Override public String call ( Map < String , String > map ) { return map . get ( <str> ) ; } } ) ; } } ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testMapMany2 ( ) { Map < String , String > m1 = getMap ( <str> ) ; Map < String , String > m2 = getMap ( <str> ) ; Observable < Map < String , String > > observable1 = Observable . just ( m1 , m2 ) ; Map < String , String > m3 = getMap ( <str> ) ; Map < String , String > m4 = getMap ( <str> ) ; Observable < Map < String , String > > observable2 = Observable . just ( m3 , m4 ) ; Observable < Observable < Map < String , String > > > observable = Observable . just ( observable1 , observable2 ) ; Observable < String > m = observable . flatMap ( new Func1 < Observable < Map < String , String > > , Observable < String > > ( ) { @Override public Observable < String > call ( Observable < Map < String , String > > o ) { return o . map ( new Func1 < Map < String , String > , String > ( ) { @Override public String call ( Map < String , String > map ) { return map . get ( <str> ) ; } } ) ; } } ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testMapWithError ( ) { Observable < String > w = Observable . just ( <str> , <str> , <str> , <str> , <str> ) ; Observable < String > m = w . lift ( new OperatorMap < String , String > ( new Func1 < String , String > ( ) { @Override public String call ( String s ) { if ( <str> . equals ( s ) ) { throw new RuntimeException ( <str> ) ; } return s ; } } ) ) . doOnError ( new Action1 < Throwable > ( ) { @Override public void call ( Throwable t1 ) { t1 . printStackTrace ( ) ; } } ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , never ( ) ) . onNext ( <str> ) ; verify ( stringObserver , never ( ) ) . onNext ( <str> ) ; verify ( stringObserver , never ( ) ) . onCompleted ( ) ; verify ( stringObserver , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; } @Test ( expected = IllegalArgumentException . class ) public void testMapWithIssue417 ( ) { Observable . just ( <int> ) . observeOn ( Schedulers . computation ( ) ) . map ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer arg0 ) { throw new IllegalArgumentException ( <str> ) ; } } ) . toBlocking ( ) . single ( ) ; } @Test ( expected = IllegalArgumentException . class ) public void testMapWithErrorInFuncAndThreadPoolScheduler ( ) throws InterruptedException { Observable < String > m = Observable . just ( <str> ) . observeOn ( Schedulers . computation ( ) ) . map ( new Func1 < String , String > ( ) { @Override public String call ( String arg0 ) { throw new IllegalArgumentException ( <str> ) ; } } ) ; m . toBlocking ( ) . last ( ) ; } @Test ( expected = NoSuchElementException . class ) public void testErrorPassesThruMap ( ) { Observable . range ( <int> , <int> ) . last ( ) . map ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer i ) { return i ; } } ) . toBlocking ( ) . single ( ) ; } @Test ( expected = IllegalStateException . class ) public void testErrorPassesThruMap2 ( ) { Observable . error ( new IllegalStateException ( ) ) . map ( new Func1 < Object , Object > ( ) { @Override public Object call ( Object i ) { return i ; } } ) . toBlocking ( ) . single ( ) ; } @Test ( expected = ArithmeticException . class ) public void testMapWithErrorInFunc ( ) { Observable . range ( <int> , <int> ) . last ( ) . map ( new Func1 < Integer , Integer > ( ) { @Override public Integer call ( Integer i ) { return i / <int> ; } } ) . toBlocking ( ) . single ( ) ; } @Test ( expected = OnErrorNotImplementedException . class ) public void verifyExceptionIsThrownIfThereIsNoExceptionHandler ( ) { Observable . OnSubscribe < Object > creator = new Observable . OnSubscribe < Object > ( ) { @Override public void call ( Subscriber < ? super Object > observer ) { observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ; Func1 < Object , Observable < Object > > manyMapper = new Func1 < Object , Observable < Object > > ( ) { @Override public Observable < Object > call ( Object object ) { return Observable . just ( object ) ; } } ; Func1 < Object , Object > mapper = new Func1 < Object , Object > ( ) { private int count = <int> ; @Override public Object call ( Object object ) { + + count ; if ( count > <int> ) { throw new RuntimeException ( ) ; } return object ; } } ; Action1 < Object > onNext = new Action1 < Object > ( ) { @Override public void call ( Object object ) { System . out . println ( object . toString ( ) ) ; } } ; try { Observable . create ( creator ) . flatMap ( manyMapper ) . map ( mapper ) . subscribe ( onNext ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; throw e ; } } private static Map < String , String > getMap ( String prefix ) { Map < String , String > m = new HashMap < String , String > ( ) ; m . put ( <str> , prefix + <str> ) ; m . put ( <str> , prefix + <str> ) ; return m ; } @Test ( expected = OnErrorNotImplementedException . class ) public void testShouldNotSwallowOnErrorNotImplementedException ( ) { Observable . just ( <str> , <str> ) . flatMap ( new Func1 < String , Observable < String > > ( ) { @Override public Observable < String > call ( String s ) { return Observable . just ( s + <str> , s + <str> ) ; } } ) . flatMap ( new Func1 < String , Observable < String > > ( ) { @Override public Observable < String > call ( String s ) { return Observable . error ( new Exception ( <str> ) ) ; } } ) . forEach ( new Action1 < String > ( ) { @Override public void call ( String s ) { System . out . println ( s ) ; } } ) ; } }