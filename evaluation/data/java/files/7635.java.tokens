package org . apache . cassandra . db . context ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . ArrayList ; import java . util . List ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ClockAndCount ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . * ; public class CounterContext { private static final int HEADER_SIZE_LENGTH = TypeSizes . sizeof ( Short . MAX_VALUE ) ; private static final int HEADER_ELT_LENGTH = TypeSizes . sizeof ( Short . MAX_VALUE ) ; private static final int CLOCK_LENGTH = TypeSizes . sizeof ( Long . MAX_VALUE ) ; private static final int COUNT_LENGTH = TypeSizes . sizeof ( Long . MAX_VALUE ) ; private static final int STEP_LENGTH = CounterId . LENGTH + CLOCK_LENGTH + COUNT_LENGTH ; private static final Logger logger = LoggerFactory . getLogger ( CounterContext . class ) ; public static enum Relationship { EQUAL , GREATER_THAN , LESS_THAN , DISJOINT } private static class LazyHolder { private static final CounterContext counterContext = new CounterContext ( ) ; } public static CounterContext instance ( ) { return LazyHolder . counterContext ; } public ByteBuffer createGlobal ( CounterId id , long clock , long count ) { ContextState state = ContextState . allocate ( <int> , <int> , <int> ) ; state . writeGlobal ( id , clock , count ) ; return state . context ; } public ByteBuffer createLocal ( long count ) { ContextState state = ContextState . allocate ( <int> , <int> , <int> ) ; state . writeLocal ( CounterId . getLocalId ( ) , <int> , count ) ; return state . context ; } public ByteBuffer createRemote ( CounterId id , long clock , long count ) { ContextState state = ContextState . allocate ( <int> , <int> , <int> ) ; state . writeRemote ( id , clock , count ) ; return state . context ; } private static int headerLength ( ByteBuffer context ) { return HEADER_SIZE_LENGTH + Math . abs ( context . getShort ( context . position ( ) ) ) * HEADER_ELT_LENGTH ; } private static int compareId ( ByteBuffer bb1 , int pos1 , ByteBuffer bb2 , int pos2 ) { return ByteBufferUtil . compareSubArrays ( bb1 , pos1 , bb2 , pos2 , CounterId . LENGTH ) ; } public Relationship diff ( ByteBuffer left , ByteBuffer right ) { Relationship relationship = Relationship . EQUAL ; ContextState leftState = ContextState . wrap ( left ) ; ContextState rightState = ContextState . wrap ( right ) ; while ( leftState . hasRemaining ( ) & & rightState . hasRemaining ( ) ) { int compareId = leftState . compareIdTo ( rightState ) ; if ( compareId = = <int> ) { long leftClock = leftState . getClock ( ) ; long rightClock = rightState . getClock ( ) ; long leftCount = leftState . getCount ( ) ; long rightCount = rightState . getCount ( ) ; leftState . moveToNext ( ) ; rightState . moveToNext ( ) ; if ( leftClock = = rightClock ) { if ( leftCount ! = rightCount ) { return Relationship . DISJOINT ; } } else if ( ( leftClock > = <int> & & rightClock > <int> & & leftClock > rightClock ) | | ( leftClock < <int> & & ( rightClock > <int> | | leftClock < rightClock ) ) ) { if ( relationship = = Relationship . EQUAL ) relationship = Relationship . GREATER_THAN ; else if ( relationship = = Relationship . LESS_THAN ) return Relationship . DISJOINT ; } else { if ( relationship = = Relationship . EQUAL ) relationship = Relationship . LESS_THAN ; else if ( relationship = = Relationship . GREATER_THAN ) return Relationship . DISJOINT ; } } else if ( compareId > <int> ) { rightState . moveToNext ( ) ; if ( relationship = = Relationship . EQUAL ) relationship = Relationship . LESS_THAN ; else if ( relationship = = Relationship . GREATER_THAN ) return Relationship . DISJOINT ; } else { leftState . moveToNext ( ) ; if ( relationship = = Relationship . EQUAL ) relationship = Relationship . GREATER_THAN ; else if ( relationship = = Relationship . LESS_THAN ) return Relationship . DISJOINT ; } } if ( leftState . hasRemaining ( ) ) { if ( relationship = = Relationship . EQUAL ) return Relationship . GREATER_THAN ; else if ( relationship = = Relationship . LESS_THAN ) return Relationship . DISJOINT ; } if ( rightState . hasRemaining ( ) ) { if ( relationship = = Relationship . EQUAL ) return Relationship . LESS_THAN ; else if ( relationship = = Relationship . GREATER_THAN ) return Relationship . DISJOINT ; } return relationship ; } public ByteBuffer merge ( ByteBuffer left , ByteBuffer right ) { boolean leftIsSuperSet = true ; boolean rightIsSuperSet = true ; int globalCount = <int> ; int localCount = <int> ; int remoteCount = <int> ; ContextState leftState = ContextState . wrap ( left ) ; ContextState rightState = ContextState . wrap ( right ) ; while ( leftState . hasRemaining ( ) & & rightState . hasRemaining ( ) ) { int cmp = leftState . compareIdTo ( rightState ) ; if ( cmp = = <int> ) { Relationship rel = compare ( leftState , rightState ) ; if ( rel = = Relationship . GREATER_THAN ) rightIsSuperSet = false ; else if ( rel = = Relationship . LESS_THAN ) leftIsSuperSet = false ; else if ( rel = = Relationship . DISJOINT ) leftIsSuperSet = rightIsSuperSet = false ; if ( leftState . isGlobal ( ) | | rightState . isGlobal ( ) ) globalCount + = <int> ; else if ( leftState . isLocal ( ) | | rightState . isLocal ( ) ) localCount + = <int> ; else remoteCount + = <int> ; leftState . moveToNext ( ) ; rightState . moveToNext ( ) ; } else if ( cmp > <int> ) { leftIsSuperSet = false ; if ( rightState . isGlobal ( ) ) globalCount + = <int> ; else if ( rightState . isLocal ( ) ) localCount + = <int> ; else remoteCount + = <int> ; rightState . moveToNext ( ) ; } else { rightIsSuperSet = false ; if ( leftState . isGlobal ( ) ) globalCount + = <int> ; else if ( leftState . isLocal ( ) ) localCount + = <int> ; else remoteCount + = <int> ; leftState . moveToNext ( ) ; } } if ( leftState . hasRemaining ( ) ) rightIsSuperSet = false ; else if ( rightState . hasRemaining ( ) ) leftIsSuperSet = false ; if ( leftIsSuperSet ) return left ; else if ( rightIsSuperSet ) return right ; while ( leftState . hasRemaining ( ) ) { if ( leftState . isGlobal ( ) ) globalCount + = <int> ; else if ( leftState . isLocal ( ) ) localCount + = <int> ; else remoteCount + = <int> ; leftState . moveToNext ( ) ; } while ( rightState . hasRemaining ( ) ) { if ( rightState . isGlobal ( ) ) globalCount + = <int> ; else if ( rightState . isLocal ( ) ) localCount + = <int> ; else remoteCount + = <int> ; rightState . moveToNext ( ) ; } leftState . reset ( ) ; rightState . reset ( ) ; return merge ( ContextState . allocate ( globalCount , localCount , remoteCount ) , leftState , rightState ) ; } private ByteBuffer merge ( ContextState mergedState , ContextState leftState , ContextState rightState ) { while ( leftState . hasRemaining ( ) & & rightState . hasRemaining ( ) ) { int cmp = leftState . compareIdTo ( rightState ) ; if ( cmp = = <int> ) { Relationship rel = compare ( leftState , rightState ) ; if ( rel = = Relationship . DISJOINT ) mergedState . writeLocal ( leftState . getCounterId ( ) , leftState . getClock ( ) + rightState . getClock ( ) , leftState . getCount ( ) + rightState . getCount ( ) ) ; else if ( rel = = Relationship . GREATER_THAN ) leftState . copyTo ( mergedState ) ; else rightState . copyTo ( mergedState ) ; rightState . moveToNext ( ) ; leftState . moveToNext ( ) ; } else if ( cmp > <int> ) { rightState . copyTo ( mergedState ) ; rightState . moveToNext ( ) ; } else { leftState . copyTo ( mergedState ) ; leftState . moveToNext ( ) ; } } while ( leftState . hasRemaining ( ) ) { leftState . copyTo ( mergedState ) ; leftState . moveToNext ( ) ; } while ( rightState . hasRemaining ( ) ) { rightState . copyTo ( mergedState ) ; rightState . moveToNext ( ) ; } return mergedState . context ; } private Relationship compare ( ContextState leftState , ContextState rightState ) { long leftClock = leftState . getClock ( ) ; long leftCount = leftState . getCount ( ) ; long rightClock = rightState . getClock ( ) ; long rightCount = rightState . getCount ( ) ; if ( leftState . isGlobal ( ) | | rightState . isGlobal ( ) ) { if ( leftState . isGlobal ( ) & & rightState . isGlobal ( ) ) { if ( leftClock = = rightClock ) { if ( leftCount ! = rightCount & & CompactionManager . isCompactionManager . get ( ) ) { logger . warn ( <str> + <str> , leftState . getCounterId ( ) , leftClock , leftCount , rightState . getCounterId ( ) , rightClock , rightCount ) ; } if ( leftCount > rightCount ) return Relationship . GREATER_THAN ; else if ( leftCount = = rightCount ) return Relationship . EQUAL ; else return Relationship . LESS_THAN ; } else { return leftClock > rightClock ? Relationship . GREATER_THAN : Relationship . LESS_THAN ; } } else { return leftState . isGlobal ( ) ? Relationship . GREATER_THAN : Relationship . LESS_THAN ; } } if ( leftState . isLocal ( ) | | rightState . isLocal ( ) ) { if ( leftState . isLocal ( ) & & rightState . isLocal ( ) ) return Relationship . DISJOINT ; else return leftState . isLocal ( ) ? Relationship . GREATER_THAN : Relationship . LESS_THAN ; } if ( leftClock = = rightClock ) { if ( leftCount ! = rightCount & & CompactionManager . isCompactionManager . get ( ) ) { logger . warn ( <str> + <str> , leftState . getCounterId ( ) , leftClock , leftCount , rightState . getCounterId ( ) , rightClock , rightCount ) ; } if ( leftCount > rightCount ) return Relationship . GREATER_THAN ; else if ( leftCount = = rightCount ) return Relationship . EQUAL ; else return Relationship . LESS_THAN ; } else { if ( ( leftClock > = <int> & & rightClock > <int> & & leftClock > = rightClock ) | | ( leftClock < <int> & & ( rightClock > <int> | | leftClock < rightClock ) ) ) return Relationship . GREATER_THAN ; else return Relationship . LESS_THAN ; } } public String toString ( ByteBuffer context ) { ContextState state = ContextState . wrap ( context ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; while ( state . hasRemaining ( ) ) { if ( state . getElementIndex ( ) > <int> ) sb . append ( <str> ) ; sb . append ( <str> ) ; sb . append ( state . getCounterId ( ) ) . append ( <str> ) ; sb . append ( state . getClock ( ) ) . append ( <str> ) ; sb . append ( state . getCount ( ) ) ; sb . append ( <str> ) ; if ( state . isGlobal ( ) ) sb . append ( <str> ) ; else if ( state . isLocal ( ) ) sb . append ( <str> ) ; state . moveToNext ( ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public long total ( ByteBuffer context ) { long total = <int> ; for ( int offset = context . position ( ) + headerLength ( context ) ; offset < context . limit ( ) ; offset + = STEP_LENGTH ) total + = context . getLong ( offset + CounterId . LENGTH + CLOCK_LENGTH ) ; return total ; } public boolean shouldClearLocal ( ByteBuffer context ) { return context . getShort ( context . position ( ) ) < <int> ; } public boolean hasLegacyShards ( ByteBuffer context ) { int totalCount = ( context . remaining ( ) - headerLength ( context ) ) / STEP_LENGTH ; int localAndGlobalCount = Math . abs ( context . getShort ( context . position ( ) ) ) ; if ( localAndGlobalCount < totalCount ) return true ; for ( int i = <int> ; i < localAndGlobalCount ; i + + ) if ( context . getShort ( context . position ( ) + HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH ) > = <int> ) return true ; return false ; } public ByteBuffer markLocalToBeCleared ( ByteBuffer context ) { short count = context . getShort ( context . position ( ) ) ; if ( count < = <int> ) return context ; boolean hasLocalShards = false ; for ( int i = <int> ; i < count ; i + + ) { if ( context . getShort ( context . position ( ) + HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH ) > = <int> ) { hasLocalShards = true ; break ; } } if ( ! hasLocalShards ) return context ; ByteBuffer marked = ByteBuffer . allocate ( context . remaining ( ) ) ; marked . putShort ( marked . position ( ) , ( short ) ( count * - <int> ) ) ; ByteBufferUtil . arrayCopy ( context , context . position ( ) + HEADER_SIZE_LENGTH , marked , marked . position ( ) + HEADER_SIZE_LENGTH , context . remaining ( ) - HEADER_SIZE_LENGTH ) ; return marked ; } public ByteBuffer clearAllLocal ( ByteBuffer context ) { int count = Math . abs ( context . getShort ( context . position ( ) ) ) ; if ( count = = <int> ) return context ; List < Short > globalShardIndexes = new ArrayList < > ( count ) ; for ( int i = <int> ; i < count ; i + + ) { short elt = context . getShort ( context . position ( ) + HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH ) ; if ( elt < <int> ) globalShardIndexes . add ( elt ) ; } if ( count = = globalShardIndexes . size ( ) ) return context ; ByteBuffer cleared = ByteBuffer . allocate ( context . remaining ( ) - ( count - globalShardIndexes . size ( ) ) * HEADER_ELT_LENGTH ) ; cleared . putShort ( cleared . position ( ) , ( short ) globalShardIndexes . size ( ) ) ; for ( int i = <int> ; i < globalShardIndexes . size ( ) ; i + + ) cleared . putShort ( cleared . position ( ) + HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH , globalShardIndexes . get ( i ) ) ; int origHeaderLength = headerLength ( context ) ; ByteBufferUtil . arrayCopy ( context , context . position ( ) + origHeaderLength , cleared , cleared . position ( ) + headerLength ( cleared ) , context . remaining ( ) - origHeaderLength ) ; return cleared ; } public void validateContext ( ByteBuffer context ) throws MarshalException { if ( ( context . remaining ( ) - headerLength ( context ) ) % STEP_LENGTH ! = <int> ) throw new MarshalException ( <str> ) ; } public void updateDigest ( MessageDigest message , ByteBuffer context ) { ByteBuffer dup = context . duplicate ( ) ; dup . position ( context . position ( ) + headerLength ( context ) ) ; message . update ( dup ) ; } public ClockAndCount getLocalClockAndCount ( ByteBuffer context ) { return getClockAndCountOf ( context , CounterId . getLocalId ( ) ) ; } public long getLocalCount ( ByteBuffer context ) { return getLocalClockAndCount ( context ) . count ; } public boolean isLocal ( ByteBuffer context ) { return ContextState . wrap ( context ) . isLocal ( ) ; } @VisibleForTesting public ClockAndCount getClockAndCountOf ( ByteBuffer context , CounterId id ) { int position = findPositionOf ( context , id ) ; if ( position = = - <int> ) return ClockAndCount . BLANK ; long clock = context . getLong ( position + CounterId . LENGTH ) ; long count = context . getLong ( position + CounterId . LENGTH + CLOCK_LENGTH ) ; return ClockAndCount . create ( clock , count ) ; } @VisibleForTesting public int findPositionOf ( ByteBuffer context , CounterId id ) { int headerLength = headerLength ( context ) ; int offset = context . position ( ) + headerLength ; int left = <int> ; int right = ( context . remaining ( ) - headerLength ) / STEP_LENGTH - <int> ; while ( right > = left ) { int middle = ( left + right ) / <int> ; int cmp = compareId ( context , offset + middle * STEP_LENGTH , id . bytes ( ) , id . bytes ( ) . position ( ) ) ; if ( cmp = = - <int> ) left = middle + <int> ; else if ( cmp = = <int> ) return offset + middle * STEP_LENGTH ; else right = middle - <int> ; } return - <int> ; } public static class ContextState { public final ByteBuffer context ; public final int headerLength ; private int headerOffset ; private int bodyOffset ; private boolean currentIsGlobal ; private boolean currentIsLocal ; private ContextState ( ByteBuffer context ) { this . context = context ; this . headerLength = this . bodyOffset = headerLength ( context ) ; this . headerOffset = HEADER_SIZE_LENGTH ; updateIsGlobalOrLocal ( ) ; } public static ContextState wrap ( ByteBuffer context ) { return new ContextState ( context ) ; } public static ContextState allocate ( int globalCount , int localCount , int remoteCount ) { int headerLength = HEADER_SIZE_LENGTH + ( globalCount + localCount ) * HEADER_ELT_LENGTH ; int bodyLength = ( globalCount + localCount + remoteCount ) * STEP_LENGTH ; ByteBuffer buffer = ByteBuffer . allocate ( headerLength + bodyLength ) ; buffer . putShort ( buffer . position ( ) , ( short ) ( globalCount + localCount ) ) ; return ContextState . wrap ( buffer ) ; } public boolean isGlobal ( ) { return currentIsGlobal ; } public boolean isLocal ( ) { return currentIsLocal ; } public boolean isRemote ( ) { return ! ( currentIsGlobal | | currentIsLocal ) ; } private void updateIsGlobalOrLocal ( ) { if ( headerOffset > = headerLength ) { currentIsGlobal = currentIsLocal = false ; } else { short headerElt = context . getShort ( context . position ( ) + headerOffset ) ; currentIsGlobal = headerElt = = getElementIndex ( ) + Short . MIN_VALUE ; currentIsLocal = headerElt = = getElementIndex ( ) ; } } public boolean hasRemaining ( ) { return bodyOffset < context . remaining ( ) ; } public void moveToNext ( ) { bodyOffset + = STEP_LENGTH ; if ( currentIsGlobal | | currentIsLocal ) headerOffset + = HEADER_ELT_LENGTH ; updateIsGlobalOrLocal ( ) ; } public void copyTo ( ContextState other ) { other . writeElement ( getCounterId ( ) , getClock ( ) , getCount ( ) , currentIsGlobal , currentIsLocal ) ; } public int compareIdTo ( ContextState other ) { return compareId ( context , context . position ( ) + bodyOffset , other . context , other . context . position ( ) + other . bodyOffset ) ; } public void reset ( ) { this . headerOffset = HEADER_SIZE_LENGTH ; this . bodyOffset = headerLength ; updateIsGlobalOrLocal ( ) ; } public int getElementIndex ( ) { return ( bodyOffset - headerLength ) / STEP_LENGTH ; } public CounterId getCounterId ( ) { return CounterId . wrap ( context , context . position ( ) + bodyOffset ) ; } public long getClock ( ) { return context . getLong ( context . position ( ) + bodyOffset + CounterId . LENGTH ) ; } public long getCount ( ) { return context . getLong ( context . position ( ) + bodyOffset + CounterId . LENGTH + CLOCK_LENGTH ) ; } public void writeGlobal ( CounterId id , long clock , long count ) { writeElement ( id , clock , count , true , false ) ; } public void writeLocal ( CounterId id , long clock , long count ) { writeElement ( id , clock , count , false , true ) ; } public void writeRemote ( CounterId id , long clock , long count ) { writeElement ( id , clock , count , false , false ) ; } private void writeElement ( CounterId id , long clock , long count , boolean isGlobal , boolean isLocal ) { writeElementAtOffset ( context , context . position ( ) + bodyOffset , id , clock , count ) ; if ( isGlobal ) context . putShort ( context . position ( ) + headerOffset , ( short ) ( getElementIndex ( ) + Short . MIN_VALUE ) ) ; else if ( isLocal ) context . putShort ( context . position ( ) + headerOffset , ( short ) getElementIndex ( ) ) ; currentIsGlobal = isGlobal ; currentIsLocal = isLocal ; moveToNext ( ) ; } private void writeElementAtOffset ( ByteBuffer ctx , int offset , CounterId id , long clock , long count ) { ctx = ctx . duplicate ( ) ; ctx . position ( offset ) ; ctx . put ( id . bytes ( ) . duplicate ( ) ) ; ctx . putLong ( clock ) ; ctx . putLong ( count ) ; } } }