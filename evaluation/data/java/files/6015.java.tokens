package rx . internal . operators ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import rx . Observable . Operator ; import rx . Scheduler ; import rx . Scheduler . Worker ; import rx . exceptions . Exceptions ; import rx . Subscriber ; import rx . functions . Action0 ; import rx . observers . SerializedSubscriber ; public final class OperatorSampleWithTime < T > implements Operator < T , T > { final long time ; final TimeUnit unit ; final Scheduler scheduler ; public OperatorSampleWithTime ( long time , TimeUnit unit , Scheduler scheduler ) { this . time = time ; this . unit = unit ; this . scheduler = scheduler ; } @Override public Subscriber < ? super T > call ( Subscriber < ? super T > child ) { final SerializedSubscriber < T > s = new SerializedSubscriber < T > ( child ) ; final Worker worker = scheduler . createWorker ( ) ; child . add ( worker ) ; SamplerSubscriber < T > sampler = new SamplerSubscriber < T > ( s ) ; child . add ( sampler ) ; worker . schedulePeriodically ( sampler , time , time , unit ) ; return sampler ; } static final class SamplerSubscriber < T > extends Subscriber < T > implements Action0 { private final Subscriber < ? super T > subscriber ; private static final Object EMPTY_TOKEN = new Object ( ) ; final AtomicReference < Object > value = new AtomicReference < Object > ( EMPTY_TOKEN ) ; public SamplerSubscriber ( Subscriber < ? super T > subscriber ) { this . subscriber = subscriber ; } @Override public void onStart ( ) { request ( Long . MAX_VALUE ) ; } @Override public void onNext ( T t ) { value . set ( t ) ; } @Override public void onError ( Throwable e ) { subscriber . onError ( e ) ; unsubscribe ( ) ; } @Override public void onCompleted ( ) { subscriber . onCompleted ( ) ; unsubscribe ( ) ; } @Override public void call ( ) { Object localValue = value . getAndSet ( EMPTY_TOKEN ) ; if ( localValue ! = EMPTY_TOKEN ) { try { @SuppressWarnings ( <str> ) T v = ( T ) localValue ; subscriber . onNext ( v ) ; } catch ( Throwable e ) { Exceptions . throwOrReport ( e , this ) ; } } } } }