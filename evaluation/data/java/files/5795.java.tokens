package rx . internal . operators ; import org . junit . Test ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import rx . Observable ; import rx . Observer ; import rx . Subscription ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import static org . mockito . Mockito . * ; import static rx . schedulers . Schedulers . computation ; public class OnSubscribeFromCallableTest { @SuppressWarnings ( <str> ) @Test public void shouldNotInvokeFuncUntilSubscription ( ) throws Exception { Callable < Object > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( new Object ( ) ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( func ) ; verifyZeroInteractions ( func ) ; fromCallableObservable . subscribe ( ) ; verify ( func ) . call ( ) ; } @SuppressWarnings ( <str> ) @Test public void shouldCallOnNextAndOnCompleted ( ) throws Exception { Callable < String > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( <str> ) ; Observable < String > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < String > observer = mock ( Observer . class ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer ) . onNext ( <str> ) ; verify ( observer ) . onCompleted ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @SuppressWarnings ( <str> ) @Test public void shouldCallOnError ( ) throws Exception { Callable < Object > func = mock ( Callable . class ) ; Throwable throwable = new IllegalStateException ( <str> ) ; when ( func . call ( ) ) . thenThrow ( throwable ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < Object > observer = mock ( Observer . class ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( anyObject ( ) ) ; verify ( observer , never ( ) ) . onCompleted ( ) ; verify ( observer ) . onError ( throwable ) ; } @SuppressWarnings ( <str> ) @Test public void shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission ( ) throws Exception { Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( <int> ) ; final CountDownLatch observerLatch = new CountDownLatch ( <int> ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) { @Override public String answer ( InvocationOnMock invocation ) throws Throwable { observerLatch . countDown ( ) ; try { funcLatch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } return <str> ; } } ) ; Observable < String > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < String > observer = mock ( Observer . class ) ; Subscription subscription = fromCallableObservable . subscribeOn ( computation ( ) ) . subscribe ( observer ) ; observerLatch . await ( ) ; subscription . unsubscribe ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verifyZeroInteractions ( observer ) ; } @SuppressWarnings ( <str> ) @Test public void shouldAllowToThrowCheckedException ( ) { final Exception checkedException = new Exception ( <str> ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { throw checkedException ; } } ) ; Observer < Object > observer = mock ( Observer . class ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer ) . onError ( checkedException ) ; verifyNoMoreInteractions ( observer ) ; } }