package com . badlogic . gdx . graphics . g3d . particles ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . FloatChannel ; import com . badlogic . gdx . graphics . g3d . particles . emitters . Emitter ; import com . badlogic . gdx . graphics . g3d . particles . influencers . Influencer ; import com . badlogic . gdx . graphics . g3d . particles . renderers . ParticleControllerRenderer ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonValue ; import com . badlogic . gdx . utils . reflect . ClassReflection ; public class ParticleController implements Json . Serializable , ResourceData . Configurable { protected static final float DEFAULT_TIME_STEP = <int> f / <int> ; public String name ; public Emitter emitter ; public Array < Influencer > influencers ; public ParticleControllerRenderer < ? , ? > renderer ; public ParallelArray particles ; public ParticleChannels particleChannels ; public Matrix4 transform ; public Vector3 scale ; protected BoundingBox boundingBox ; public float deltaTime , deltaTimeSqr ; public ParticleController ( ) { transform = new Matrix4 ( ) ; scale = new Vector3 ( <int> , <int> , <int> ) ; influencers = new Array < Influencer > ( true , <int> , Influencer . class ) ; setTimeStep ( DEFAULT_TIME_STEP ) ; } public ParticleController ( String name , Emitter emitter , ParticleControllerRenderer < ? , ? > renderer , Influencer . . . influencers ) { this ( ) ; this . name = name ; this . emitter = emitter ; this . renderer = renderer ; this . particleChannels = new ParticleChannels ( ) ; this . influencers = new Array < Influencer > ( influencers ) ; } private void setTimeStep ( float timeStep ) { deltaTime = timeStep ; deltaTimeSqr = deltaTime * deltaTime ; } public void setTransform ( Matrix4 transform ) { this . transform . set ( transform ) ; transform . getScale ( scale ) ; } public void setTransform ( float x , float y , float z , float qx , float qy , float qz , float qw , float scale ) { transform . set ( x , y , z , qx , qy , qz , qw , scale , scale , scale ) ; this . scale . set ( scale , scale , scale ) ; } public void rotate ( Quaternion rotation ) { this . transform . rotate ( rotation ) ; } public void rotate ( Vector3 axis , float angle ) { this . transform . rotate ( axis , angle ) ; } public void translate ( Vector3 translation ) { this . transform . translate ( translation ) ; } public void setTranslation ( Vector3 translation ) { this . transform . setTranslation ( translation ) ; } public void scale ( float scaleX , float scaleY , float scaleZ ) { this . transform . scale ( scaleX , scaleY , scaleZ ) ; this . transform . getScale ( scale ) ; } public void scale ( Vector3 scale ) { scale ( scale . x , scale . y , scale . z ) ; } public void mul ( Matrix4 transform ) { this . transform . mul ( transform ) ; this . transform . getScale ( scale ) ; } public void getTransform ( Matrix4 transform ) { transform . set ( this . transform ) ; } public void init ( ) { bind ( ) ; if ( particles ! = null ) { end ( ) ; particleChannels . resetIds ( ) ; } allocateChannels ( emitter . maxParticleCount ) ; emitter . init ( ) ; for ( Influencer influencer : influencers ) influencer . init ( ) ; renderer . init ( ) ; } protected void allocateChannels ( int maxParticleCount ) { particles = new ParallelArray ( maxParticleCount ) ; emitter . allocateChannels ( ) ; for ( Influencer influencer : influencers ) influencer . allocateChannels ( ) ; renderer . allocateChannels ( ) ; } protected void bind ( ) { emitter . set ( this ) ; for ( Influencer influencer : influencers ) influencer . set ( this ) ; renderer . set ( this ) ; } public void start ( ) { emitter . start ( ) ; for ( Influencer influencer : influencers ) influencer . start ( ) ; } public void reset ( ) { end ( ) ; start ( ) ; } public void end ( ) { for ( Influencer influencer : influencers ) influencer . end ( ) ; emitter . end ( ) ; } public void activateParticles ( int startIndex , int count ) { emitter . activateParticles ( startIndex , count ) ; for ( Influencer influencer : influencers ) influencer . activateParticles ( startIndex , count ) ; } public void killParticles ( int startIndex , int count ) { emitter . killParticles ( startIndex , count ) ; for ( Influencer influencer : influencers ) influencer . killParticles ( startIndex , count ) ; } public void update ( ) { emitter . update ( ) ; for ( Influencer influencer : influencers ) influencer . update ( ) ; } public void draw ( ) { if ( particles . size > <int> ) { renderer . update ( ) ; } } public ParticleController copy ( ) { Emitter emitter = ( Emitter ) this . emitter . copy ( ) ; Influencer [ ] influencers = new Influencer [ this . influencers . size ] ; int i = <int> ; for ( Influencer influencer : this . influencers ) { influencers [ i + + ] = ( Influencer ) influencer . copy ( ) ; } return new ParticleController ( new String ( this . name ) , emitter , ( ParticleControllerRenderer < ? , ? > ) renderer . copy ( ) , influencers ) ; } public void dispose ( ) { emitter . dispose ( ) ; for ( Influencer influencer : influencers ) influencer . dispose ( ) ; } public BoundingBox getBoundingBox ( ) { if ( boundingBox = = null ) boundingBox = new BoundingBox ( ) ; calculateBoundingBox ( ) ; return boundingBox ; } protected void calculateBoundingBox ( ) { boundingBox . clr ( ) ; FloatChannel positionChannel = particles . getChannel ( ParticleChannels . Position ) ; for ( int pos = <int> , c = positionChannel . strideSize * particles . size ; pos < c ; pos + = positionChannel . strideSize ) { boundingBox . ext ( positionChannel . data [ pos + ParticleChannels . XOffset ] , positionChannel . data [ pos + ParticleChannels . YOffset ] , positionChannel . data [ pos + ParticleChannels . ZOffset ] ) ; } } private < K extends Influencer > int findIndex ( Class < K > type ) { for ( int i = <int> ; i < influencers . size ; + + i ) { Influencer influencer = influencers . get ( i ) ; if ( ClassReflection . isAssignableFrom ( type , influencer . getClass ( ) ) ) { return i ; } } return - <int> ; } public < K extends Influencer > K findInfluencer ( Class < K > influencerClass ) { int index = findIndex ( influencerClass ) ; return index > - <int> ? ( K ) influencers . get ( index ) : null ; } public < K extends Influencer > void removeInfluencer ( Class < K > type ) { int index = findIndex ( type ) ; if ( index > - <int> ) influencers . removeIndex ( index ) ; } public < K extends Influencer > boolean replaceInfluencer ( Class < K > type , K newInfluencer ) { int index = findIndex ( type ) ; if ( index > - <int> ) { influencers . insert ( index , newInfluencer ) ; influencers . removeIndex ( index + <int> ) ; return true ; } return false ; } @Override public void write ( Json json ) { json . writeValue ( <str> , name ) ; json . writeValue ( <str> , emitter , Emitter . class ) ; json . writeValue ( <str> , influencers , Array . class , Influencer . class ) ; json . writeValue ( <str> , renderer , ParticleControllerRenderer . class ) ; } @Override public void read ( Json json , JsonValue jsonMap ) { name = json . readValue ( <str> , String . class , jsonMap ) ; emitter = json . readValue ( <str> , Emitter . class , jsonMap ) ; influencers . addAll ( json . readValue ( <str> , Array . class , Influencer . class , jsonMap ) ) ; renderer = json . readValue ( <str> , ParticleControllerRenderer . class , jsonMap ) ; } @Override public void save ( AssetManager manager , ResourceData data ) { emitter . save ( manager , data ) ; for ( Influencer influencer : influencers ) influencer . save ( manager , data ) ; renderer . save ( manager , data ) ; } @Override public void load ( AssetManager manager , ResourceData data ) { emitter . load ( manager , data ) ; for ( Influencer influencer : influencers ) influencer . load ( manager , data ) ; renderer . load ( manager , data ) ; } } 
