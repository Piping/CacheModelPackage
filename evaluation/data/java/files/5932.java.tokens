package rx . observers ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import rx . Notification ; import rx . Observer ; public class TestObserver < T > implements Observer < T > { private final Observer < T > delegate ; private final ArrayList < T > onNextEvents = new ArrayList < T > ( ) ; private final ArrayList < Throwable > onErrorEvents = new ArrayList < Throwable > ( ) ; private final ArrayList < Notification < T > > onCompletedEvents = new ArrayList < Notification < T > > ( ) ; public TestObserver ( Observer < T > delegate ) { this . delegate = delegate ; } @SuppressWarnings ( <str> ) public TestObserver ( ) { this . delegate = ( Observer < T > ) INERT ; } @Override public void onCompleted ( ) { onCompletedEvents . add ( Notification . < T > createOnCompleted ( ) ) ; delegate . onCompleted ( ) ; } public List < Notification < T > > getOnCompletedEvents ( ) { return Collections . unmodifiableList ( onCompletedEvents ) ; } @Override public void onError ( Throwable e ) { onErrorEvents . add ( e ) ; delegate . onError ( e ) ; } public List < Throwable > getOnErrorEvents ( ) { return Collections . unmodifiableList ( onErrorEvents ) ; } @Override public void onNext ( T t ) { onNextEvents . add ( t ) ; delegate . onNext ( t ) ; } public List < T > getOnNextEvents ( ) { return Collections . unmodifiableList ( onNextEvents ) ; } public List < Object > getEvents ( ) { ArrayList < Object > events = new ArrayList < Object > ( ) ; events . add ( onNextEvents ) ; events . add ( onErrorEvents ) ; events . add ( onCompletedEvents ) ; return Collections . unmodifiableList ( events ) ; } public void assertReceivedOnNext ( List < T > items ) { if ( onNextEvents . size ( ) ! = items . size ( ) ) { throw new AssertionError ( <str> + items . size ( ) + <str> + onNextEvents . size ( ) ) ; } for ( int i = <int> ; i < items . size ( ) ; i + + ) { T expected = items . get ( i ) ; T actual = onNextEvents . get ( i ) ; if ( expected = = null ) { if ( actual ! = null ) { throw new AssertionError ( <str> + i + <str> + actual + <str> ) ; } } else if ( ! expected . equals ( actual ) ) { throw new AssertionError ( <str> + i + <str> + expected + <str> + expected . getClass ( ) . getSimpleName ( ) + <str> + actual + <str> + ( actual ! = null ? actual . getClass ( ) . getSimpleName ( ) : <str> ) + <str> ) ; } } } public void assertTerminalEvent ( ) { if ( onErrorEvents . size ( ) > <int> ) { throw new AssertionError ( <str> + onErrorEvents . size ( ) ) ; } if ( onCompletedEvents . size ( ) > <int> ) { throw new AssertionError ( <str> + onCompletedEvents . size ( ) ) ; } if ( onCompletedEvents . size ( ) = = <int> & & onErrorEvents . size ( ) = = <int> ) { throw new AssertionError ( <str> ) ; } if ( onCompletedEvents . size ( ) = = <int> & & onErrorEvents . size ( ) = = <int> ) { throw new AssertionError ( <str> ) ; } } private static Observer < Object > INERT = new Observer < Object > ( ) { @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Object t ) { } } ; }