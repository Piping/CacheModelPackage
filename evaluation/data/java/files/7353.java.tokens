package org . apache . cassandra . service ; import java . io . File ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . lang . management . MemoryPoolMXBean ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . registry . LocateRegistry ; import java . rmi . server . RMIServerSocketFactory ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import javax . management . StandardMBean ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXServiceURL ; import javax . management . remote . rmi . RMIConnectorServer ; import com . addthis . metrics3 . reporter . config . ReporterConfig ; import com . codahale . metrics . Meter ; import com . codahale . metrics . MetricRegistryListener ; import com . codahale . metrics . SharedMetricRegistries ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . util . concurrent . Futures ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . common . util . concurrent . Uninterruptibles ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . * ; import org . apache . cassandra . batchlog . LegacyBatchlogMigrator ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . StartupException ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . hints . LegacyHintsMigrator ; import org . apache . cassandra . io . FSError ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . metrics . CassandraMetricsRegistry ; import org . apache . cassandra . metrics . DefaultNameFactory ; import org . apache . cassandra . metrics . StorageMetrics ; import org . apache . cassandra . schema . LegacySchemaMigrator ; import org . apache . cassandra . cql3 . functions . ThreadAwareSecurityManager ; import org . apache . cassandra . thrift . ThriftServer ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . * ; public class CassandraDaemon { public static final String MBEAN_NAME = <str> ; private static JMXConnectorServer jmxServer = null ; private static final Logger logger ; static { SharedMetricRegistries . getOrCreate ( <str> ) . addListener ( new MetricRegistryListener . Base ( ) { @Override public void onMeterAdded ( String metricName , Meter meter ) { int separator = metricName . lastIndexOf ( <str> ) ; String appenderName = metricName . substring ( <int> , separator ) ; String metric = metricName . substring ( separator + <int> ) ; ObjectName name = DefaultNameFactory . createMetricName ( appenderName , metric , null ) . getMBeanName ( ) ; CassandraMetricsRegistry . Metrics . registerMBean ( meter , name ) ; } } ) ; logger = LoggerFactory . getLogger ( CassandraDaemon . class ) ; } private static void maybeInitJmx ( ) { if ( System . getProperty ( <str> ) ! = null ) return ; String jmxPort = System . getProperty ( <str> ) ; if ( jmxPort = = null ) return ; System . setProperty ( <str> , InetAddress . getLoopbackAddress ( ) . getHostAddress ( ) ) ; RMIServerSocketFactory serverFactory = new RMIServerSocketFactoryImpl ( ) ; Map < String , ? > env = Collections . singletonMap ( RMIConnectorServer . RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE , serverFactory ) ; try { LocateRegistry . createRegistry ( Integer . valueOf ( jmxPort ) , null , serverFactory ) ; JMXServiceURL url = new JMXServiceURL ( String . format ( <str> , jmxPort ) ) ; jmxServer = new RMIConnectorServer ( url , env , ManagementFactory . getPlatformMBeanServer ( ) ) ; jmxServer . start ( ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; } } private static final CassandraDaemon instance = new CassandraDaemon ( ) ; public Server thriftServer ; private NativeTransportService nativeTransportService ; private final boolean runManaged ; protected final StartupChecks startupChecks ; private boolean setupCompleted ; public CassandraDaemon ( ) { this ( false ) ; } public CassandraDaemon ( boolean runManaged ) { this . runManaged = runManaged ; this . startupChecks = new StartupChecks ( ) . withDefaultTests ( ) ; this . setupCompleted = false ; } protected void setup ( ) { if ( FBUtilities . isWindows ( ) ) WindowsFailedSnapshotTracker . deleteOldSnapshots ( ) ; ThreadAwareSecurityManager . install ( ) ; logSystemInfo ( ) ; CLibrary . tryMlockall ( ) ; try { startupChecks . verify ( ) ; } catch ( StartupException e ) { exitOrFail ( e . returnCode , e . getMessage ( ) , e . getCause ( ) ) ; } try { if ( SystemKeyspace . snapshotOnVersionChange ( ) ) { SystemKeyspace . migrateDataDirs ( ) ; } } catch ( IOException e ) { exitOrFail ( <int> , e . getMessage ( ) , e . getCause ( ) ) ; } maybeInitJmx ( ) ; Thread . setDefaultUncaughtExceptionHandler ( new Thread . UncaughtExceptionHandler ( ) { public void uncaughtException ( Thread t , Throwable e ) { StorageMetrics . exceptions . inc ( ) ; logger . error ( <str> , t , e ) ; Tracing . trace ( <str> , t , e ) ; for ( Throwable e2 = e ; e2 ! = null ; e2 = e2 . getCause ( ) ) { JVMStabilityInspector . inspectThrowable ( e2 ) ; if ( e2 instanceof FSError ) { if ( e2 ! = e ) logger . error ( <str> , t , e2 ) ; FileUtils . handleFSError ( ( FSError ) e2 ) ; } if ( e2 instanceof CorruptSSTableException ) { if ( e2 ! = e ) logger . error ( <str> + t , e2 ) ; FileUtils . handleCorruptSSTable ( ( CorruptSSTableException ) e2 ) ; } } } } ) ; LegacySchemaMigrator . migrate ( ) ; StorageService . instance . populateTokenMetadata ( ) ; Schema . instance . loadFromDisk ( ) ; for ( String keyspaceName : Schema . instance . getKeyspaces ( ) ) { if ( keyspaceName . equals ( SystemKeyspace . NAME ) ) continue ; for ( CFMetaData cfm : Schema . instance . getTablesAndViews ( keyspaceName ) ) ColumnFamilyStore . scrubDataDirectories ( cfm ) ; } Keyspace . setInitialized ( ) ; for ( String keyspaceName : Schema . instance . getKeyspaces ( ) ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , keyspaceName ) ; for ( ColumnFamilyStore cfs : Keyspace . open ( keyspaceName ) . getColumnFamilyStores ( ) ) { for ( ColumnFamilyStore store : cfs . concatWithIndexes ( ) ) { store . disableAutoCompaction ( ) ; } } } try { loadRowAndKeyCacheAsync ( ) . get ( ) ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; logger . warn ( <str> , t ) ; } try { GCInspector . register ( ) ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; logger . warn ( <str> ) ; } try { CommitLog . instance . recover ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } StorageService . instance . populateTokenMetadata ( ) ; new LegacyHintsMigrator ( DatabaseDescriptor . getHintsDirectory ( ) , DatabaseDescriptor . getMaxHintsFileSize ( ) ) . migrate ( ) ; LegacyBatchlogMigrator . migrate ( ) ; for ( Keyspace keyspace : Keyspace . all ( ) ) { for ( ColumnFamilyStore cfs : keyspace . getColumnFamilyStores ( ) ) { for ( final ColumnFamilyStore store : cfs . concatWithIndexes ( ) ) { if ( store . getCompactionStrategyManager ( ) . shouldBeEnabled ( ) ) store . enableAutoCompaction ( ) ; } } } Runnable viewRebuild = new Runnable ( ) { @Override public void run ( ) { for ( Keyspace keyspace : Keyspace . all ( ) ) { keyspace . viewManager . buildAllViews ( ) ; } } } ; ScheduledExecutors . optionalTasks . schedule ( viewRebuild , StorageService . RING_DELAY , TimeUnit . MILLISECONDS ) ; SystemKeyspace . finishStartup ( ) ; String metricsReporterConfigFile = System . getProperty ( <str> ) ; if ( metricsReporterConfigFile ! = null ) { logger . info ( <str> , metricsReporterConfigFile ) ; try { String reportFileLocation = CassandraDaemon . class . getClassLoader ( ) . getResource ( metricsReporterConfigFile ) . getFile ( ) ; ReporterConfig . loadFromFile ( reportFileLocation ) . enableAll ( CassandraMetricsRegistry . Metrics ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } StorageService . instance . registerDaemon ( this ) ; try { StorageService . instance . initServer ( ) ; } catch ( ConfigurationException e ) { System . err . println ( e . getMessage ( ) + <str> ) ; exitOrFail ( <int> , <str> , e ) ; } Mx4jTool . maybeLoad ( ) ; if ( ! FBUtilities . getBroadcastAddress ( ) . equals ( InetAddress . getLoopbackAddress ( ) ) ) waitForGossipToSettle ( ) ; ScheduledExecutors . optionalTasks . scheduleWithFixedDelay ( ColumnFamilyStore . getBackgroundCompactionTaskSubmitter ( ) , <int> , <int> , TimeUnit . MINUTES ) ; int sizeRecorderInterval = Integer . getInteger ( <str> , <int> * <int> ) ; if ( sizeRecorderInterval > <int> ) ScheduledExecutors . optionalTasks . scheduleWithFixedDelay ( SizeEstimatesRecorder . instance , <int> , sizeRecorderInterval , TimeUnit . SECONDS ) ; InetAddress rpcAddr = DatabaseDescriptor . getRpcAddress ( ) ; int rpcPort = DatabaseDescriptor . getRpcPort ( ) ; int listenBacklog = DatabaseDescriptor . getRpcListenBacklog ( ) ; thriftServer = new ThriftServer ( rpcAddr , rpcPort , listenBacklog ) ; nativeTransportService = new NativeTransportService ( ) ; completeSetup ( ) ; } private ListenableFuture < ? > loadRowAndKeyCacheAsync ( ) { final ListenableFuture < Integer > keyCacheLoad = CacheService . instance . keyCache . loadSavedAsync ( ) ; final ListenableFuture < Integer > rowCacheLoad = CacheService . instance . rowCache . loadSavedAsync ( ) ; @SuppressWarnings ( <str> ) ListenableFuture < List < Integer > > retval = Futures . successfulAsList ( keyCacheLoad , rowCacheLoad ) ; return retval ; } @VisibleForTesting public void completeSetup ( ) { setupCompleted = true ; } public boolean setupCompleted ( ) { return setupCompleted ; } private void logSystemInfo ( ) { if ( logger . isInfoEnabled ( ) ) { try { logger . info ( <str> , InetAddress . getLocalHost ( ) . getHostName ( ) ) ; } catch ( UnknownHostException e1 ) { logger . info ( <str> ) ; } logger . info ( <str> , System . getProperty ( <str> ) , System . getProperty ( <str> ) ) ; logger . info ( <str> , Runtime . getRuntime ( ) . totalMemory ( ) , Runtime . getRuntime ( ) . maxMemory ( ) ) ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) logger . info ( <str> , pool . getName ( ) , pool . getType ( ) , pool . getPeakUsage ( ) ) ; logger . info ( <str> , System . getProperty ( <str> ) ) ; logger . info ( <str> , ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ) ; } } public void init ( String [ ] arguments ) throws IOException { setup ( ) ; } public void start ( ) { String nativeFlag = System . getProperty ( <str> ) ; if ( ( nativeFlag ! = null & & Boolean . parseBoolean ( nativeFlag ) ) | | ( nativeFlag = = null & & DatabaseDescriptor . startNativeTransport ( ) ) ) { startNativeTransport ( ) ; StorageService . instance . setRpcReady ( true ) ; } else logger . info ( <str> ) ; String rpcFlag = System . getProperty ( <str> ) ; if ( ( rpcFlag ! = null & & Boolean . parseBoolean ( rpcFlag ) ) | | ( rpcFlag = = null & & DatabaseDescriptor . startRpc ( ) ) ) thriftServer . start ( ) ; else logger . info ( <str> ) ; } public void stop ( ) { logger . info ( <str> ) ; if ( thriftServer ! = null ) thriftServer . stop ( ) ; if ( nativeTransportService ! = null ) nativeTransportService . destroy ( ) ; StorageService . instance . setRpcReady ( false ) ; if ( FBUtilities . isWindows ( ) ) System . exit ( <int> ) ; if ( jmxServer ! = null ) { try { jmxServer . stop ( ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; } } } public void destroy ( ) { } public void activate ( ) { try { try { DatabaseDescriptor . forceStaticInitialization ( ) ; } catch ( ExceptionInInitializerError e ) { throw e . getCause ( ) ; } try { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; mbs . registerMBean ( new StandardMBean ( new NativeAccess ( ) , NativeAccessMBean . class ) , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { logger . error ( <str> , MBEAN_NAME , e ) ; } if ( FBUtilities . isWindows ( ) ) { WindowsTimer . startTimerPeriod ( DatabaseDescriptor . getWindowsTimerInterval ( ) ) ; } setup ( ) ; String pidFile = System . getProperty ( <str> ) ; if ( pidFile ! = null ) { new File ( pidFile ) . deleteOnExit ( ) ; } if ( System . getProperty ( <str> ) = = null ) { System . out . close ( ) ; System . err . close ( ) ; } start ( ) ; } catch ( Throwable e ) { boolean logStackTrace = e instanceof ConfigurationException ? ( ( ConfigurationException ) e ) . logStackTrace : true ; System . out . println ( <str> + e . getClass ( ) . getName ( ) + <str> + e . getMessage ( ) ) ; if ( logStackTrace ) { if ( runManaged ) logger . error ( <str> , e ) ; e . printStackTrace ( ) ; exitOrFail ( <int> , <str> , e ) ; } else { if ( runManaged ) logger . error ( <str> , e . getMessage ( ) ) ; System . err . println ( e . getMessage ( ) ) ; exitOrFail ( <int> , <str> + e . getMessage ( ) ) ; } } } public void startNativeTransport ( ) { if ( nativeTransportService = = null ) throw new IllegalStateException ( <str> ) ; else nativeTransportService . start ( ) ; } public void stopNativeTransport ( ) { if ( nativeTransportService ! = null ) nativeTransportService . stop ( ) ; } public boolean isNativeTransportRunning ( ) { return nativeTransportService ! = null ? nativeTransportService . isRunning ( ) : false ; } public void deactivate ( ) { stop ( ) ; destroy ( ) ; if ( ! runManaged ) { System . exit ( <int> ) ; } } private void waitForGossipToSettle ( ) { int forceAfter = Integer . getInteger ( <str> , - <int> ) ; if ( forceAfter = = <int> ) { return ; } final int GOSSIP_SETTLE_MIN_WAIT_MS = <int> ; final int GOSSIP_SETTLE_POLL_INTERVAL_MS = <int> ; final int GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED = <int> ; logger . info ( <str> ) ; Uninterruptibles . sleepUninterruptibly ( GOSSIP_SETTLE_MIN_WAIT_MS , TimeUnit . MILLISECONDS ) ; int totalPolls = <int> ; int numOkay = <int> ; int epSize = Gossiper . instance . getEndpointStates ( ) . size ( ) ; while ( numOkay < GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED ) { Uninterruptibles . sleepUninterruptibly ( GOSSIP_SETTLE_POLL_INTERVAL_MS , TimeUnit . MILLISECONDS ) ; int currentSize = Gossiper . instance . getEndpointStates ( ) . size ( ) ; totalPolls + + ; if ( currentSize = = epSize ) { logger . debug ( <str> ) ; numOkay + + ; } else { logger . info ( <str> , totalPolls ) ; numOkay = <int> ; } epSize = currentSize ; if ( forceAfter > <int> & & totalPolls > forceAfter ) { logger . warn ( <str> , totalPolls ) ; break ; } } if ( totalPolls > GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED ) logger . info ( <str> , totalPolls - GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED ) ; else logger . info ( <str> ) ; } public static void stop ( String [ ] args ) { instance . deactivate ( ) ; } public static void main ( String [ ] args ) { instance . activate ( ) ; } private void exitOrFail ( int code , String message ) { exitOrFail ( code , message , null ) ; } private void exitOrFail ( int code , String message , Throwable cause ) { if ( runManaged ) { RuntimeException t = cause ! = null ? new RuntimeException ( message , cause ) : new RuntimeException ( message ) ; throw t ; } else { logger . error ( message , cause ) ; System . exit ( code ) ; } } static class NativeAccess implements NativeAccessMBean { public boolean isAvailable ( ) { return CLibrary . jnaAvailable ( ) ; } public boolean isMemoryLockable ( ) { return CLibrary . jnaMemoryLockable ( ) ; } } public interface Server { public void start ( ) ; public void stop ( ) ; public boolean isRunning ( ) ; } }