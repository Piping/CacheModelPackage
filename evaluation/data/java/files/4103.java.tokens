package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . util . List ; public class LineBasedFrameDecoder extends ByteToMessageDecoder { private final int maxLength ; private final boolean failFast ; private final boolean stripDelimiter ; private boolean discarding ; private int discardedBytes ; public LineBasedFrameDecoder ( final int maxLength ) { this ( maxLength , true , false ) ; } public LineBasedFrameDecoder ( final int maxLength , final boolean stripDelimiter , final boolean failFast ) { this . maxLength = maxLength ; this . failFast = failFast ; this . stripDelimiter = stripDelimiter ; } @Override protected final void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { Object decoded = decode ( ctx , in ) ; if ( decoded ! = null ) { out . add ( decoded ) ; } } protected Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { final int eol = findEndOfLine ( buffer ) ; if ( ! discarding ) { if ( eol > = <int> ) { final ByteBuf frame ; final int length = eol - buffer . readerIndex ( ) ; final int delimLength = buffer . getByte ( eol ) = = <str> ? <int> : <int> ; if ( length > maxLength ) { buffer . readerIndex ( eol + delimLength ) ; fail ( ctx , length ) ; return null ; } if ( stripDelimiter ) { frame = buffer . readSlice ( length ) ; buffer . skipBytes ( delimLength ) ; } else { frame = buffer . readSlice ( length + delimLength ) ; } return frame . retain ( ) ; } else { final int length = buffer . readableBytes ( ) ; if ( length > maxLength ) { discardedBytes = length ; buffer . readerIndex ( buffer . writerIndex ( ) ) ; discarding = true ; if ( failFast ) { fail ( ctx , <str> + discardedBytes ) ; } } return null ; } } else { if ( eol > = <int> ) { final int length = discardedBytes + eol - buffer . readerIndex ( ) ; final int delimLength = buffer . getByte ( eol ) = = <str> ? <int> : <int> ; buffer . readerIndex ( eol + delimLength ) ; discardedBytes = <int> ; discarding = false ; if ( ! failFast ) { fail ( ctx , length ) ; } } else { discardedBytes + = buffer . readableBytes ( ) ; buffer . readerIndex ( buffer . writerIndex ( ) ) ; } return null ; } } private void fail ( final ChannelHandlerContext ctx , int length ) { fail ( ctx , String . valueOf ( length ) ) ; } private void fail ( final ChannelHandlerContext ctx , String length ) { ctx . fireExceptionCaught ( new TooLongFrameException ( <str> + length + <str> + maxLength + <str> ) ) ; } private static int findEndOfLine ( final ByteBuf buffer ) { final int n = buffer . writerIndex ( ) ; for ( int i = buffer . readerIndex ( ) ; i < n ; i + + ) { final byte b = buffer . getByte ( i ) ; if ( b = = <str> ) { return i ; } else if ( b = = <str> & & i < n - <int> & & buffer . getByte ( i + <int> ) = = <str> ) { return i ; } } return - <int> ; } }