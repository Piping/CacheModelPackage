package org . apache . cassandra . db . rows ; import java . util . * ; import java . security . MessageDigest ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . transform . FilteredRows ; import org . apache . cassandra . db . transform . MoreRows ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . IMergeIterator ; import org . apache . cassandra . utils . MergeIterator ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public abstract class UnfilteredRowIterators { private static final Logger logger = LoggerFactory . getLogger ( UnfilteredRowIterators . class ) ; private UnfilteredRowIterators ( ) { } public interface MergeListener { public void onMergedPartitionLevelDeletion ( DeletionTime mergedDeletion , DeletionTime [ ] versions ) ; public void onMergedRows ( Row merged , Row [ ] versions ) ; public void onMergedRangeTombstoneMarkers ( RangeTombstoneMarker merged , RangeTombstoneMarker [ ] versions ) ; public void close ( ) ; } public static RowIterator filter ( UnfilteredRowIterator iter , int nowInSec ) { return FilteredRows . filter ( iter , nowInSec ) ; } public static UnfilteredRowIterator merge ( List < UnfilteredRowIterator > iterators , int nowInSec ) { assert ! iterators . isEmpty ( ) ; if ( iterators . size ( ) = = <int> ) return iterators . get ( <int> ) ; return UnfilteredRowMergeIterator . create ( iterators , nowInSec , null ) ; } public static UnfilteredRowIterator merge ( List < UnfilteredRowIterator > iterators , int nowInSec , MergeListener mergeListener ) { return UnfilteredRowMergeIterator . create ( iterators , nowInSec , mergeListener ) ; } public static UnfilteredRowIterator noRowsIterator ( final CFMetaData cfm , final DecoratedKey partitionKey , final Row staticRow , final DeletionTime partitionDeletion , final boolean isReverseOrder ) { return EmptyIterators . unfilteredRow ( cfm , partitionKey , isReverseOrder , staticRow , partitionDeletion ) ; } public static void digest ( UnfilteredRowIterator iterator , MessageDigest digest , int version ) { if ( version < MessagingService . VERSION_30 ) { LegacyLayout . fromUnfilteredRowIterator ( iterator ) . digest ( iterator . metadata ( ) , digest ) ; return ; } digest . update ( iterator . partitionKey ( ) . getKey ( ) . duplicate ( ) ) ; iterator . partitionLevelDeletion ( ) . digest ( digest ) ; iterator . columns ( ) . digest ( digest ) ; FBUtilities . updateWithBoolean ( digest , iterator . isReverseOrder ( ) ) ; iterator . staticRow ( ) . digest ( digest ) ; while ( iterator . hasNext ( ) ) { Unfiltered unfiltered = iterator . next ( ) ; unfiltered . digest ( digest ) ; } } public static UnfilteredRowIterator concat ( final UnfilteredRowIterator iter1 , final UnfilteredRowIterator iter2 ) { assert iter1 . metadata ( ) . cfId . equals ( iter2 . metadata ( ) . cfId ) & & iter1 . partitionKey ( ) . equals ( iter2 . partitionKey ( ) ) & & iter1 . partitionLevelDeletion ( ) . equals ( iter2 . partitionLevelDeletion ( ) ) & & iter1 . isReverseOrder ( ) = = iter2 . isReverseOrder ( ) & & iter1 . columns ( ) . equals ( iter2 . columns ( ) ) & & iter1 . staticRow ( ) . equals ( iter2 . staticRow ( ) ) ; class Extend implements MoreRows < UnfilteredRowIterator > { boolean returned = false ; public UnfilteredRowIterator moreContents ( ) { if ( returned ) return null ; returned = true ; return iter2 ; } } return MoreRows . extend ( iter1 , new Extend ( ) ) ; } public static UnfilteredRowIterator cloningIterator ( UnfilteredRowIterator iterator , final AbstractAllocator allocator ) { class Cloner extends Transformation { private final Row . Builder builder = allocator . cloningBTreeRowBuilder ( ) ; public Row applyToStatic ( Row row ) { return Rows . copy ( row , builder ) . build ( ) ; } @Override public Row applyToRow ( Row row ) { return Rows . copy ( row , builder ) . build ( ) ; } @Override public RangeTombstoneMarker applyToMarker ( RangeTombstoneMarker marker ) { return marker . copy ( allocator ) ; } } return Transformation . apply ( iterator , new Cloner ( ) ) ; } public static UnfilteredRowIterator withValidation ( UnfilteredRowIterator iterator , final String filename ) { class Validator extends Transformation { @Override public Row applyToStatic ( Row row ) { validate ( row ) ; return row ; } @Override public Row applyToRow ( Row row ) { validate ( row ) ; return row ; } @Override public RangeTombstoneMarker applyToMarker ( RangeTombstoneMarker marker ) { validate ( marker ) ; return marker ; } private void validate ( Unfiltered unfiltered ) { try { unfiltered . validateData ( iterator . metadata ( ) ) ; } catch ( MarshalException me ) { throw new CorruptSSTableException ( me , filename ) ; } } } return Transformation . apply ( iterator , new Validator ( ) ) ; } public static UnfilteredRowIterator loggingIterator ( UnfilteredRowIterator iterator , final String id , final boolean fullDetails ) { CFMetaData metadata = iterator . metadata ( ) ; logger . info ( <str> , id , metadata . ksName , metadata . cfName , metadata . getKeyValidator ( ) . getString ( iterator . partitionKey ( ) . getKey ( ) ) , iterator . isReverseOrder ( ) , iterator . partitionLevelDeletion ( ) . markedForDeleteAt ( ) ) ; class Logger extends Transformation { @Override public Row applyToStatic ( Row row ) { if ( ! row . isEmpty ( ) ) logger . info ( <str> , id , row . toString ( metadata , fullDetails ) ) ; return row ; } @Override public Row applyToRow ( Row row ) { logger . info ( <str> , id , row . toString ( metadata , fullDetails ) ) ; return row ; } @Override public RangeTombstoneMarker applyToMarker ( RangeTombstoneMarker marker ) { logger . info ( <str> , id , marker . toString ( metadata ) ) ; return marker ; } } return Transformation . apply ( iterator , new Logger ( ) ) ; } private static class UnfilteredRowMergeIterator extends AbstractUnfilteredRowIterator { private final IMergeIterator < Unfiltered , Unfiltered > mergeIterator ; private final MergeListener listener ; private UnfilteredRowMergeIterator ( CFMetaData metadata , List < UnfilteredRowIterator > iterators , PartitionColumns columns , DeletionTime partitionDeletion , int nowInSec , boolean reversed , MergeListener listener ) { super ( metadata , iterators . get ( <int> ) . partitionKey ( ) , partitionDeletion , columns , mergeStaticRows ( iterators , columns . statics , nowInSec , listener , partitionDeletion ) , reversed , mergeStats ( iterators ) ) ; this . mergeIterator = MergeIterator . get ( iterators , reversed ? metadata . comparator . reversed ( ) : metadata . comparator , new MergeReducer ( iterators . size ( ) , reversed , nowInSec , listener ) ) ; this . listener = listener ; } private static UnfilteredRowMergeIterator create ( List < UnfilteredRowIterator > iterators , int nowInSec , MergeListener listener ) { try { checkForInvalidInput ( iterators ) ; return new UnfilteredRowMergeIterator ( iterators . get ( <int> ) . metadata ( ) , iterators , collectColumns ( iterators ) , collectPartitionLevelDeletion ( iterators , listener ) , nowInSec , iterators . get ( <int> ) . isReverseOrder ( ) , listener ) ; } catch ( RuntimeException | Error e ) { try { FBUtilities . closeAll ( iterators ) ; } catch ( Exception suppressed ) { e . addSuppressed ( suppressed ) ; } throw e ; } } @SuppressWarnings ( <str> ) private static void checkForInvalidInput ( List < UnfilteredRowIterator > iterators ) { if ( iterators . isEmpty ( ) ) return ; UnfilteredRowIterator first = iterators . get ( <int> ) ; for ( int i = <int> ; i < iterators . size ( ) ; i + + ) { UnfilteredRowIterator iter = iterators . get ( i ) ; assert first . metadata ( ) . cfId . equals ( iter . metadata ( ) . cfId ) ; assert first . partitionKey ( ) . equals ( iter . partitionKey ( ) ) ; assert first . isReverseOrder ( ) = = iter . isReverseOrder ( ) ; } } @SuppressWarnings ( <str> ) private static DeletionTime collectPartitionLevelDeletion ( List < UnfilteredRowIterator > iterators , MergeListener listener ) { DeletionTime [ ] versions = listener = = null ? null : new DeletionTime [ iterators . size ( ) ] ; DeletionTime delTime = DeletionTime . LIVE ; for ( int i = <int> ; i < iterators . size ( ) ; i + + ) { UnfilteredRowIterator iter = iterators . get ( i ) ; DeletionTime iterDeletion = iter . partitionLevelDeletion ( ) ; if ( listener ! = null ) versions [ i ] = iterDeletion ; if ( ! delTime . supersedes ( iterDeletion ) ) delTime = iterDeletion ; } if ( listener ! = null & & ! delTime . isLive ( ) ) listener . onMergedPartitionLevelDeletion ( delTime , versions ) ; return delTime ; } private static Row mergeStaticRows ( List < UnfilteredRowIterator > iterators , Columns columns , int nowInSec , MergeListener listener , DeletionTime partitionDeletion ) { if ( columns . isEmpty ( ) ) return Rows . EMPTY_STATIC_ROW ; if ( iterators . stream ( ) . allMatch ( iter - > iter . staticRow ( ) . isEmpty ( ) ) ) return Rows . EMPTY_STATIC_ROW ; Row . Merger merger = new Row . Merger ( iterators . size ( ) , nowInSec , columns . hasComplex ( ) ) ; for ( int i = <int> ; i < iterators . size ( ) ; i + + ) merger . add ( i , iterators . get ( i ) . staticRow ( ) ) ; Row merged = merger . merge ( partitionDeletion ) ; if ( merged = = null ) merged = Rows . EMPTY_STATIC_ROW ; if ( listener ! = null ) listener . onMergedRows ( merged , merger . mergedRows ( ) ) ; return merged ; } private static PartitionColumns collectColumns ( List < UnfilteredRowIterator > iterators ) { PartitionColumns first = iterators . get ( <int> ) . columns ( ) ; Columns statics = first . statics ; Columns regulars = first . regulars ; for ( int i = <int> ; i < iterators . size ( ) ; i + + ) { PartitionColumns cols = iterators . get ( i ) . columns ( ) ; statics = statics . mergeTo ( cols . statics ) ; regulars = regulars . mergeTo ( cols . regulars ) ; } return statics = = first . statics & & regulars = = first . regulars ? first : new PartitionColumns ( statics , regulars ) ; } private static EncodingStats mergeStats ( List < UnfilteredRowIterator > iterators ) { EncodingStats stats = EncodingStats . NO_STATS ; for ( UnfilteredRowIterator iter : iterators ) stats = stats . mergeWith ( iter . stats ( ) ) ; return stats ; } protected Unfiltered computeNext ( ) { while ( mergeIterator . hasNext ( ) ) { Unfiltered merged = mergeIterator . next ( ) ; if ( merged ! = null ) return merged ; } return endOfData ( ) ; } public void close ( ) { FileUtils . closeQuietly ( mergeIterator ) ; if ( listener ! = null ) listener . close ( ) ; } private class MergeReducer extends MergeIterator . Reducer < Unfiltered , Unfiltered > { private final MergeListener listener ; private Unfiltered . Kind nextKind ; private final Row . Merger rowMerger ; private final RangeTombstoneMarker . Merger markerMerger ; private MergeReducer ( int size , boolean reversed , int nowInSec , MergeListener listener ) { this . rowMerger = new Row . Merger ( size , nowInSec , columns ( ) . regulars . hasComplex ( ) ) ; this . markerMerger = new RangeTombstoneMarker . Merger ( size , partitionLevelDeletion ( ) , reversed ) ; this . listener = listener ; } @Override public boolean trivialReduceIsTrivial ( ) { return listener = = null ; } public void reduce ( int idx , Unfiltered current ) { nextKind = current . kind ( ) ; if ( nextKind = = Unfiltered . Kind . ROW ) rowMerger . add ( idx , ( Row ) current ) ; else markerMerger . add ( idx , ( RangeTombstoneMarker ) current ) ; } protected Unfiltered getReduced ( ) { if ( nextKind = = Unfiltered . Kind . ROW ) { Row merged = rowMerger . merge ( markerMerger . activeDeletion ( ) ) ; if ( listener ! = null ) listener . onMergedRows ( merged = = null ? BTreeRow . emptyRow ( rowMerger . mergedClustering ( ) ) : merged , rowMerger . mergedRows ( ) ) ; return merged ; } else { RangeTombstoneMarker merged = markerMerger . merge ( ) ; if ( merged ! = null & & listener ! = null ) listener . onMergedRangeTombstoneMarkers ( merged , markerMerger . mergedMarkers ( ) ) ; return merged ; } } protected void onKeyChange ( ) { if ( nextKind = = Unfiltered . Kind . ROW ) rowMerger . clear ( ) ; else markerMerger . clear ( ) ; } } } }