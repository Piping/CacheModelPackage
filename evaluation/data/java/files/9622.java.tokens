package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . Ray ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . ClosestRayResultCallback ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; public class RayCastTest extends BaseBulletTest { final int BOXCOUNT_X = <int> ; final int BOXCOUNT_Y = <int> ; final int BOXCOUNT_Z = <int> ; final float BOXOFFSET_X = <int> f ; final float BOXOFFSET_Y = <float> ; final float BOXOFFSET_Z = <float> ; ClosestRayResultCallback rayTestCB ; Vector3 rayFrom = new Vector3 ( ) ; Vector3 rayTo = new Vector3 ( ) ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; world . add ( <str> , - <int> f , <int> f , - <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; for ( int x = <int> ; x < BOXCOUNT_X ; x + + ) { for ( int y = <int> ; y < BOXCOUNT_Y ; y + + ) { for ( int z = <int> ; z < BOXCOUNT_Z ; z + + ) { world . add ( <str> , BOXOFFSET_X + x , BOXOFFSET_Y + y , BOXOFFSET_Z + z ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; } } } rayTestCB = new ClosestRayResultCallback ( Vector3 . Zero , Vector3 . Z ) ; } @Override public void dispose ( ) { if ( rayTestCB ! = null ) rayTestCB . dispose ( ) ; rayTestCB = null ; super . dispose ( ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { Ray ray = camera . getPickRay ( x , y ) ; rayFrom . set ( ray . origin ) ; rayTo . set ( ray . direction ) . scl ( <int> f ) . add ( rayFrom ) ; rayTestCB . setCollisionObject ( null ) ; rayTestCB . setClosestHitFraction ( <int> f ) ; rayTestCB . setRayFromWorld ( rayFrom ) ; rayTestCB . setRayToWorld ( rayTo ) ; world . collisionWorld . rayTest ( rayFrom , rayTo , rayTestCB ) ; if ( rayTestCB . hasHit ( ) ) { final btCollisionObject obj = rayTestCB . getCollisionObject ( ) ; if ( ! obj . isStaticOrKinematicObject ( ) ) { final btRigidBody body = ( btRigidBody ) ( obj ) ; body . activate ( ) ; body . applyCentralImpulse ( tmpV2 . set ( ray . direction ) . scl ( <int> f ) ) ; } } return true ; } }