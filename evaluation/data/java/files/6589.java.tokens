package org . apache . cassandra . utils ; import java . util . Random ; import java . util . concurrent . TimeUnit ; import org . junit . Assert ; import org . apache . cassandra . utils . obs . OffHeapBitSet ; import org . apache . cassandra . utils . obs . OpenBitSet ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class LongBitSetTest { private static final Logger logger = LoggerFactory . getLogger ( LongBitSetTest . class ) ; private static final Random random = new Random ( ) ; public void populateRandom ( OffHeapBitSet offbs , OpenBitSet obs , long index ) { if ( random . nextBoolean ( ) ) { offbs . set ( index ) ; obs . set ( index ) ; } } public void compare ( OffHeapBitSet offbs , OpenBitSet obs , long index ) { if ( offbs . get ( index ) ! = obs . get ( index ) ) throw new RuntimeException ( ) ; Assert . assertEquals ( offbs . get ( index ) , obs . get ( index ) ) ; } @Test public void testBitSetOperations ( ) { long size_to_test = Integer . MAX_VALUE / <int> ; long size_and_excess = size_to_test + <int> ; OffHeapBitSet offbs = new OffHeapBitSet ( size_and_excess ) ; OpenBitSet obs = new OpenBitSet ( size_and_excess ) ; for ( long i = <int> ; i < size_to_test ; i + + ) populateRandom ( offbs , obs , i ) ; for ( long i = <int> ; i < size_to_test ; i + + ) compare ( offbs , obs , i ) ; } @Test public void timeit ( ) { long size_to_test = Integer . MAX_VALUE / <int> ; long size_and_excess = size_to_test + <int> ; OpenBitSet obs = new OpenBitSet ( size_and_excess ) ; OffHeapBitSet offbs = new OffHeapBitSet ( size_and_excess ) ; logger . info ( <str> ) ; loopOnce ( obs , offbs , size_to_test ) ; } public void loopOnce ( OpenBitSet obs , OffHeapBitSet offbs , long size_to_test ) { StringBuffer buffer = new StringBuffer ( ) ; System . gc ( ) ; long start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) obs . set ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) obs . get ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) obs . clear ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; System . gc ( ) ; start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) offbs . set ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) offbs . get ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; start = System . nanoTime ( ) ; for ( long i = <int> ; i < size_to_test ; i + + ) offbs . clear ( i ) ; buffer . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) . append ( <str> ) ; logger . info ( buffer . toString ( ) ) ; } @Test public void loopIt ( ) { long size_to_test = Integer . MAX_VALUE / <int> ; long size_and_excess = size_to_test + <int> ; OpenBitSet obs = new OpenBitSet ( size_and_excess ) ; OffHeapBitSet offbs = new OffHeapBitSet ( size_and_excess ) ; for ( int i = <int> ; i < <int> ; i + + ) loopOnce ( obs , offbs , size_to_test ) ; } }