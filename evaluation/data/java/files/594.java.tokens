package com . google . common . hash ; import static com . google . common . primitives . UnsignedBytes . toInt ; import com . google . common . primitives . Chars ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import java . io . Serializable ; import java . nio . ByteBuffer ; import javax . annotation . Nullable ; final class Murmur3_32HashFunction extends AbstractStreamingHashFunction implements Serializable { private static final int C1 = <hex> ; private static final int C2 = <hex> ; private final int seed ; Murmur3_32HashFunction ( int seed ) { this . seed = seed ; } @Override public int bits ( ) { return <int> ; } @Override public Hasher newHasher ( ) { return new Murmur3_32Hasher ( seed ) ; } @Override public String toString ( ) { return <str> + seed + <str> ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof Murmur3_32HashFunction ) { Murmur3_32HashFunction other = ( Murmur3_32HashFunction ) object ; return seed = = other . seed ; } return false ; } @Override public int hashCode ( ) { return getClass ( ) . hashCode ( ) ^ seed ; } @Override public HashCode hashInt ( int input ) { int k1 = mixK1 ( input ) ; int h1 = mixH1 ( seed , k1 ) ; return fmix ( h1 , Ints . BYTES ) ; } @Override public HashCode hashLong ( long input ) { int low = ( int ) input ; int high = ( int ) ( input > > > <int> ) ; int k1 = mixK1 ( low ) ; int h1 = mixH1 ( seed , k1 ) ; k1 = mixK1 ( high ) ; h1 = mixH1 ( h1 , k1 ) ; return fmix ( h1 , Longs . BYTES ) ; } @Override public HashCode hashUnencodedChars ( CharSequence input ) { int h1 = seed ; for ( int i = <int> ; i < input . length ( ) ; i + = <int> ) { int k1 = input . charAt ( i - <int> ) | ( input . charAt ( i ) < < <int> ) ; k1 = mixK1 ( k1 ) ; h1 = mixH1 ( h1 , k1 ) ; } if ( ( input . length ( ) & <int> ) = = <int> ) { int k1 = input . charAt ( input . length ( ) - <int> ) ; k1 = mixK1 ( k1 ) ; h1 ^ = k1 ; } return fmix ( h1 , Chars . BYTES * input . length ( ) ) ; } private static int mixK1 ( int k1 ) { k1 * = C1 ; k1 = Integer . rotateLeft ( k1 , <int> ) ; k1 * = C2 ; return k1 ; } private static int mixH1 ( int h1 , int k1 ) { h1 ^ = k1 ; h1 = Integer . rotateLeft ( h1 , <int> ) ; h1 = h1 * <int> + <hex> ; return h1 ; } private static HashCode fmix ( int h1 , int length ) { h1 ^ = length ; h1 ^ = h1 > > > <int> ; h1 * = <hex> ; h1 ^ = h1 > > > <int> ; h1 * = <hex> ; h1 ^ = h1 > > > <int> ; return HashCode . fromInt ( h1 ) ; } private static final class Murmur3_32Hasher extends AbstractStreamingHasher { private static final int CHUNK_SIZE = <int> ; private int h1 ; private int length ; Murmur3_32Hasher ( int seed ) { super ( CHUNK_SIZE ) ; this . h1 = seed ; this . length = <int> ; } @Override protected void process ( ByteBuffer bb ) { int k1 = Murmur3_32HashFunction . mixK1 ( bb . getInt ( ) ) ; h1 = Murmur3_32HashFunction . mixH1 ( h1 , k1 ) ; length + = CHUNK_SIZE ; } @Override protected void processRemaining ( ByteBuffer bb ) { length + = bb . remaining ( ) ; int k1 = <int> ; for ( int i = <int> ; bb . hasRemaining ( ) ; i + = <int> ) { k1 ^ = toInt ( bb . get ( ) ) < < i ; } h1 ^ = Murmur3_32HashFunction . mixK1 ( k1 ) ; } @Override public HashCode makeHash ( ) { return Murmur3_32HashFunction . fmix ( h1 , length ) ; } } private static final long serialVersionUID = <int> ; } 
