package org . apache . cassandra . io . sstable ; import java . io . File ; import java . io . FilenameFilter ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Iterator ; import java . util . UUID ; import com . google . common . collect . ImmutableMap ; import com . google . common . io . Files ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . OutputHandler ; import static org . junit . Assert . assertEquals ; public class CQLSSTableWriterTest { @BeforeClass public static void setup ( ) throws Exception { SchemaLoader . cleanupAndLeaveDirs ( ) ; Keyspace . setInitialized ( ) ; StorageService . instance . initServer ( ) ; } @AfterClass public static void tearDown ( ) throws Exception { Config . setClientMode ( false ) ; } @Test public void testUnsortedWriter ( ) throws Exception { try ( AutoCloseable switcher = Util . switchPartitioner ( ByteOrderedPartitioner . instance ) ) { String KS = <str> ; String TABLE = <str> ; File tempdir = Files . createTempDir ( ) ; File dataDir = new File ( tempdir . getAbsolutePath ( ) + File . separator + KS + File . separator + TABLE ) ; assert dataDir . mkdirs ( ) ; String schema = <str> + <str> + <str> + <str> + <str> ; String insert = <str> ; CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( schema ) . using ( insert ) . build ( ) ; writer . addRow ( <int> , <str> , <int> ) ; writer . addRow ( <int> , <str> , <int> ) ; writer . addRow ( <int> , <str> , <int> ) ; writer . addRow ( ImmutableMap . < String , Object > of ( <str> , <int> , <str> , <int> ) ) ; writer . close ( ) ; SSTableLoader loader = new SSTableLoader ( dataDir , new SSTableLoader . Client ( ) { private String keyspace ; public void init ( String keyspace ) { this . keyspace = keyspace ; for ( Range < Token > range : StorageService . instance . getLocalRanges ( <str> ) ) addRangeForEndpoint ( range , FBUtilities . getBroadcastAddress ( ) ) ; } public CFMetaData getTableMetadata ( String cfName ) { return Schema . instance . getCFMetaData ( keyspace , cfName ) ; } } , new OutputHandler . SystemOutput ( false , false ) ) ; loader . stream ( ) . get ( ) ; UntypedResultSet rs = QueryProcessor . executeInternal ( <str> ) ; assertEquals ( <int> , rs . size ( ) ) ; Iterator < UntypedResultSet . Row > iter = rs . iterator ( ) ; UntypedResultSet . Row row ; row = iter . next ( ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; assertEquals ( <str> , row . getString ( <str> ) ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; row = iter . next ( ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; assertEquals ( <str> , row . getString ( <str> ) ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; row = iter . next ( ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; assertEquals ( <str> , row . getString ( <str> ) ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; row = iter . next ( ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; assertEquals ( null , row . getBytes ( <str> ) ) ; assertEquals ( <int> , row . getInt ( <str> ) ) ; } } @Test ( expected = IllegalArgumentException . class ) public void testForbidCounterUpdates ( ) throws Exception { String KS = <str> ; String TABLE = <str> ; File tempdir = Files . createTempDir ( ) ; File dataDir = new File ( tempdir . getAbsolutePath ( ) + File . separator + KS + File . separator + TABLE ) ; assert dataDir . mkdirs ( ) ; String schema = <str> + <str> + <str> + <str> + <str> ; String insert = String . format ( <str> ) ; CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( schema ) . withPartitioner ( Murmur3Partitioner . instance ) . using ( insert ) . build ( ) ; } @Test public void testSyncWithinPartition ( ) throws Exception { String KS = <str> ; String TABLE = <str> ; File tempdir = Files . createTempDir ( ) ; File dataDir = new File ( tempdir . getAbsolutePath ( ) + File . separator + KS + File . separator + TABLE ) ; assert dataDir . mkdirs ( ) ; String schema = <str> + <str> + <str> + <str> ; String insert = <str> ; CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( schema ) . using ( insert ) . withBufferSizeInMB ( <int> ) . build ( ) ; ByteBuffer val = ByteBuffer . allocate ( <int> * <int> ) ; writer . addRow ( <int> , val ) ; writer . addRow ( <int> , val ) ; writer . close ( ) ; FilenameFilter filterDataFiles = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( <str> ) ; } } ; assert dataDir . list ( filterDataFiles ) . length > <int> : Arrays . toString ( dataDir . list ( filterDataFiles ) ) ; } @Test public void testSyncNoEmptyRows ( ) throws Exception { File tempdir = Files . createTempDir ( ) ; String schema = <str> + <str> + <str> + <str> + <str> ; String insert = <str> ; CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( tempdir ) . forTable ( schema ) . using ( insert ) . withBufferSizeInMB ( <int> ) . build ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { writer . addRow ( UUID . randomUUID ( ) , <int> ) ; } writer . close ( ) ; } private static final int NUMBER_WRITES_IN_RUNNABLE = <int> ; private class WriterThread extends Thread { private final File dataDir ; private final int id ; public volatile Exception exception ; public WriterThread ( File dataDir , int id ) { this . dataDir = dataDir ; this . id = id ; } @Override public void run ( ) { String schema = <str> + <str> + <str> + <str> + <str> ; String insert = <str> ; CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( schema ) . using ( insert ) . build ( ) ; try { for ( int i = <int> ; i < NUMBER_WRITES_IN_RUNNABLE ; i + + ) { writer . addRow ( id , i ) ; } writer . close ( ) ; } catch ( Exception e ) { exception = e ; } } } @Test public void testConcurrentWriters ( ) throws Exception { final String KS = <str> ; final String TABLE = <str> ; File tempdir = Files . createTempDir ( ) ; File dataDir = new File ( tempdir . getAbsolutePath ( ) + File . separator + KS + File . separator + TABLE ) ; assert dataDir . mkdirs ( ) ; WriterThread [ ] threads = new WriterThread [ <int> ] ; for ( int i = <int> ; i < threads . length ; i + + ) { WriterThread thread = new WriterThread ( dataDir , i ) ; threads [ i ] = thread ; thread . start ( ) ; } for ( WriterThread thread : threads ) { thread . join ( ) ; assert ! thread . isAlive ( ) : <str> ; if ( thread . exception ! = null ) { throw thread . exception ; } } SSTableLoader loader = new SSTableLoader ( dataDir , new SSTableLoader . Client ( ) { private String keyspace ; public void init ( String keyspace ) { this . keyspace = keyspace ; for ( Range < Token > range : StorageService . instance . getLocalRanges ( KS ) ) addRangeForEndpoint ( range , FBUtilities . getBroadcastAddress ( ) ) ; } public CFMetaData getTableMetadata ( String cfName ) { return Schema . instance . getCFMetaData ( keyspace , cfName ) ; } } , new OutputHandler . SystemOutput ( false , false ) ) ; loader . stream ( ) . get ( ) ; UntypedResultSet rs = QueryProcessor . executeInternal ( <str> ) ; assertEquals ( threads . length * NUMBER_WRITES_IN_RUNNABLE , rs . size ( ) ) ; } }