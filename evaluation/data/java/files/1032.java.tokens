package org . elasticsearch . action . admin . indices . mapping . get ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReferenceArray ; import static java . util . Collections . unmodifiableMap ; public class TransportGetFieldMappingsAction extends HandledTransportAction < GetFieldMappingsRequest , GetFieldMappingsResponse > { private final ClusterService clusterService ; private final TransportGetFieldMappingsIndexAction shardAction ; @Inject public TransportGetFieldMappingsAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , TransportGetFieldMappingsIndexAction shardAction , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , GetFieldMappingsAction . NAME , threadPool , transportService , actionFilters , indexNameExpressionResolver , GetFieldMappingsRequest : : new ) ; this . clusterService = clusterService ; this . shardAction = shardAction ; } @Override protected void doExecute ( GetFieldMappingsRequest request , final ActionListener < GetFieldMappingsResponse > listener ) { ClusterState clusterState = clusterService . state ( ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request ) ; final AtomicInteger indexCounter = new AtomicInteger ( ) ; final AtomicInteger completionCounter = new AtomicInteger ( concreteIndices . length ) ; final AtomicReferenceArray < Object > indexResponses = new AtomicReferenceArray < > ( concreteIndices . length ) ; if ( concreteIndices . length = = <int> ) { listener . onResponse ( new GetFieldMappingsResponse ( ) ) ; } else { boolean probablySingleFieldRequest = concreteIndices . length = = <int> & & request . types ( ) . length = = <int> & & request . fields ( ) . length = = <int> ; for ( final String index : concreteIndices ) { GetFieldMappingsIndexRequest shardRequest = new GetFieldMappingsIndexRequest ( request , index , probablySingleFieldRequest ) ; shardAction . execute ( shardRequest , new ActionListener < GetFieldMappingsResponse > ( ) { @Override public void onResponse ( GetFieldMappingsResponse result ) { indexResponses . set ( indexCounter . getAndIncrement ( ) , result ) ; if ( completionCounter . decrementAndGet ( ) = = <int> ) { listener . onResponse ( merge ( indexResponses ) ) ; } } @Override public void onFailure ( Throwable e ) { int index = indexCounter . getAndIncrement ( ) ; indexResponses . set ( index , e ) ; if ( completionCounter . decrementAndGet ( ) = = <int> ) { listener . onResponse ( merge ( indexResponses ) ) ; } } } ) ; } } } private GetFieldMappingsResponse merge ( AtomicReferenceArray < Object > indexResponses ) { Map < String , Map < String , Map < String , GetFieldMappingsResponse . FieldMappingMetaData > > > mergedResponses = new HashMap < > ( ) ; for ( int i = <int> ; i < indexResponses . length ( ) ; i + + ) { Object element = indexResponses . get ( i ) ; if ( element instanceof GetFieldMappingsResponse ) { GetFieldMappingsResponse response = ( GetFieldMappingsResponse ) element ; mergedResponses . putAll ( response . mappings ( ) ) ; } } return new GetFieldMappingsResponse ( unmodifiableMap ( mergedResponses ) ) ; } } 
