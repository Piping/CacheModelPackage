package org . elasticsearch . indices . store ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . FilterAllocationDecider ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . DiscoveryService ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . recovery . RecoverySource ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . disruption . BlockClusterStateProcessing ; import org . elasticsearch . test . disruption . SingleNodeDisruption ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static java . lang . Thread . sleep ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class IndicesStoreIntegrationIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , <str> ) . put ( IndicesStore . INDICES_STORE_DELETE_SHARD_TIMEOUT , new TimeValue ( <int> , TimeUnit . SECONDS ) ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } @Override protected void ensureClusterStateConsistency ( ) throws IOException { } public void testIndexCleanup ( ) throws Exception { final String masterNode = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( <str> , false ) ) ; final String node_1 = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( <str> , false ) ) ; final String node_2 = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( <str> , false ) ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_1 , <str> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_2 , <str> ) ) , equalTo ( true ) ) ; logger . info ( <str> ) ; final String node_3 = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( <str> , false ) ) ; logger . info ( <str> ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_1 , <str> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_2 , <str> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_3 , <str> , <int> ) ) , equalTo ( false ) ) ; assertThat ( Files . exists ( indexDirectory ( node_3 , <str> ) ) , equalTo ( false ) ) ; logger . info ( <str> ) ; if ( randomBoolean ( ) ) { SingleNodeDisruption disruption = new BlockClusterStateProcessing ( node_3 , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; MockTransportService transportServiceNode3 = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , node_3 ) ; CountDownLatch beginRelocationLatch = new CountDownLatch ( <int> ) ; CountDownLatch endRelocationLatch = new CountDownLatch ( <int> ) ; transportServiceNode3 . addTracer ( new ReclocationStartEndTracer ( logger , beginRelocationLatch , endRelocationLatch ) ) ; internalCluster ( ) . client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_3 ) ) . get ( ) ; beginRelocationLatch . await ( ) ; disruption . startDisrupting ( ) ; endRelocationLatch . await ( ) ; sleep ( <int> ) ; disruption . stopDisrupting ( ) ; } else { internalCluster ( ) . client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_3 ) ) . get ( ) ; } clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( waitForShardDeletion ( node_1 , <str> , <int> ) , equalTo ( false ) ) ; assertThat ( waitForIndexDeletion ( node_1 , <str> ) , equalTo ( false ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_2 , <str> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_3 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_3 , <str> ) ) , equalTo ( true ) ) ; } public void testShardCleanupIfShardDeletionAfterRelocationFailedAndIndexDeleted ( ) throws Exception { final String node_1 = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( <str> ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_1 , <str> ) ) , equalTo ( true ) ) ; final String node_2 = internalCluster ( ) . startDataOnlyNode ( Settings . builder ( ) . build ( ) ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( indexDirectory ( node_1 , <str> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( false ) ) ; assertThat ( Files . exists ( indexDirectory ( node_2 , <str> ) ) , equalTo ( false ) ) ; MockTransportService transportServiceNode_1 = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , node_1 ) ; TransportService transportServiceNode_2 = internalCluster ( ) . getInstance ( TransportService . class , node_2 ) ; final CountDownLatch shardActiveRequestSent = new CountDownLatch ( <int> ) ; transportServiceNode_1 . addDelegate ( transportServiceNode_2 , new MockTransportService . DelegateTransport ( transportServiceNode_1 . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( action . equals ( <str> ) & & shardActiveRequestSent . getCount ( ) > <int> ) { shardActiveRequestSent . countDown ( ) ; logger . info ( <str> ) ; throw new ConnectTransportException ( node , <str> ) ; } super . sendRequest ( node , requestId , action , request , options ) ; } } ) ; logger . info ( <str> , node_1 , node_2 ) ; internalCluster ( ) . client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_2 ) ) . get ( ) ; shardActiveRequestSent . await ( ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; logClusterState ( ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; assertThat ( waitForShardDeletion ( node_1 , <str> , <int> ) , equalTo ( false ) ) ; assertThat ( waitForIndexDeletion ( node_1 , <str> ) , equalTo ( false ) ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( false ) ) ; assertThat ( Files . exists ( indexDirectory ( node_1 , <str> ) ) , equalTo ( false ) ) ; assertThat ( waitForShardDeletion ( node_2 , <str> , <int> ) , equalTo ( false ) ) ; assertThat ( waitForIndexDeletion ( node_2 , <str> ) , equalTo ( false ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( false ) ) ; assertThat ( Files . exists ( indexDirectory ( node_2 , <str> ) ) , equalTo ( false ) ) ; } public void testShardsCleanup ( ) throws Exception { final String node_1 = internalCluster ( ) . startNode ( ) ; final String node_2 = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_2 , <str> , <int> ) ) , equalTo ( true ) ) ; logger . info ( <str> ) ; String node_3 = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; assertThat ( waitForShardDeletion ( node_3 , <str> , <int> ) , equalTo ( false ) ) ; Path server2Shard = shardDirectory ( node_2 , <str> , <int> ) ; logger . info ( <str> + node_2 ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( node_2 ) ) ; logger . info ( <str> ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> + clusterHealth . getStatus ( ) ) ; assertThat ( Files . exists ( server2Shard ) , equalTo ( true ) ) ; logger . info ( <str> ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( server2Shard ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_3 , <str> , <int> ) ) , equalTo ( true ) ) ; logger . info ( <str> ) ; final String node_4 = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; ensureGreen ( ) ; logger . info ( <str> ) ; assertThat ( Files . exists ( shardDirectory ( node_1 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( Files . exists ( shardDirectory ( node_3 , <str> , <int> ) ) , equalTo ( true ) ) ; assertThat ( waitForShardDeletion ( node_4 , <str> , <int> ) , equalTo ( false ) ) ; } @TestLogging ( <str> ) public void testShardActiveElsewhereDoesNotDeleteAnother ( ) throws Exception { InternalTestCluster . Async < String > masterFuture = internalCluster ( ) . startNodeAsync ( Settings . builder ( ) . put ( <str> , true , <str> , false ) . build ( ) ) ; InternalTestCluster . Async < List < String > > nodesFutures = internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( <str> , false , <str> , true ) . build ( ) ) ; final String masterNode = masterFuture . get ( ) ; final String node1 = nodesFutures . get ( ) . get ( <int> ) ; final String node2 = nodesFutures . get ( ) . get ( <int> ) ; final String node3 = nodesFutures . get ( ) . get ( <int> ) ; final String node4 = nodesFutures . get ( ) . get ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( FilterAllocationDecider . INDEX_ROUTING_EXCLUDE_GROUP + <str> , node4 ) ) ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; logger . debug ( <str> ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( node1 , node2 , node3 ) ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( node1 , node2 , node3 ) ) ; logger . debug ( <str> ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; if ( health . getStatus ( ) ! = ClusterHealthStatus . RED ) { logClusterState ( ) ; fail ( <str> ) ; } logger . debug ( <str> , node4 ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( FilterAllocationDecider . INDEX_ROUTING_EXCLUDE_GROUP + <str> , <str> ) ) ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; logger . debug ( <str> , node4 ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertTrue ( internalCluster ( ) . getInstance ( IndicesService . class , node4 ) . hasIndex ( <str> ) ) ; } } ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForActiveShards ( <int> ) . get ( ) . isTimedOut ( ) ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; logger . debug ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( <str> , false , <str> , true ) . build ( ) ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; logger . debug ( <str> ) ; ensureGreen ( <str> ) ; } public void testShardActiveElseWhere ( ) throws Exception { List < String > nodes = internalCluster ( ) . startNodesAsync ( <int> ) . get ( ) ; final String masterNode = internalCluster ( ) . getMasterName ( ) ; final String nonMasterNode = nodes . get ( <int> ) . equals ( masterNode ) ? nodes . get ( <int> ) : nodes . get ( <int> ) ; final String masterId = internalCluster ( ) . clusterService ( masterNode ) . localNode ( ) . id ( ) ; final String nonMasterId = internalCluster ( ) . clusterService ( nonMasterNode ) . localNode ( ) . id ( ) ; final int numShards = scaledRandomIntBetween ( <int> , <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , numShards ) ) ) ; ensureGreen ( <str> ) ; waitNoPendingTasksOnAll ( ) ; ClusterStateResponse stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; RoutingNode routingNode = stateResponse . getState ( ) . getRoutingNodes ( ) . node ( nonMasterId ) ; final int [ ] node2Shards = new int [ routingNode . numberOfOwningShards ( ) ] ; int i = <int> ; for ( ShardRouting shardRouting : routingNode ) { node2Shards [ i ] = shardRouting . shardId ( ) . id ( ) ; i + + ; } logger . info ( <str> , nonMasterNode , Arrays . toString ( node2Shards ) ) ; final long shardVersions [ ] = new long [ numShards ] ; final int shardIds [ ] = new int [ numShards ] ; i = <int> ; for ( ShardRouting shardRouting : stateResponse . getState ( ) . getRoutingTable ( ) . allShards ( <str> ) ) { shardVersions [ i ] = shardRouting . version ( ) ; shardIds [ i ] = shardRouting . getId ( ) ; i + + ; } client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) ) . get ( ) ; internalCluster ( ) . getInstance ( ClusterService . class , nonMasterNode ) . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { IndexRoutingTable . Builder indexRoutingTableBuilder = IndexRoutingTable . builder ( <str> ) ; for ( int i = <int> ; i < numShards ; i + + ) { indexRoutingTableBuilder . addIndexShard ( new IndexShardRoutingTable . Builder ( new ShardId ( <str> , i ) ) . addShard ( TestShardRouting . newShardRouting ( <str> , i , masterId , true , ShardRoutingState . STARTED , shardVersions [ shardIds [ i ] ] ) ) . build ( ) ) ; } return ClusterState . builder ( currentState ) . routingTable ( RoutingTable . builder ( ) . add ( indexRoutingTableBuilder ) . build ( ) ) . build ( ) ; } @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public void onFailure ( String source , Throwable t ) { } } ) ; waitNoPendingTasksOnAll ( ) ; logger . info ( <str> ) ; for ( int shard : node2Shards ) { assertTrue ( waitForShardDeletion ( nonMasterNode , <str> , shard ) ) ; } } private Path indexDirectory ( String server , String index ) { NodeEnvironment env = internalCluster ( ) . getInstance ( NodeEnvironment . class , server ) ; final Path [ ] paths = env . indexPaths ( new Index ( index ) ) ; assert paths . length = = <int> ; return paths [ <int> ] ; } private Path shardDirectory ( String server , String index , int shard ) { NodeEnvironment env = internalCluster ( ) . getInstance ( NodeEnvironment . class , server ) ; final Path [ ] paths = env . availableShardPaths ( new ShardId ( index , shard ) ) ; assert paths . length = = <int> ; return paths [ <int> ] ; } private boolean waitForShardDeletion ( final String server , final String index , final int shard ) throws InterruptedException { awaitBusy ( ( ) - > ! Files . exists ( shardDirectory ( server , index , shard ) ) ) ; return Files . exists ( shardDirectory ( server , index , shard ) ) ; } private boolean waitForIndexDeletion ( final String server , final String index ) throws InterruptedException { awaitBusy ( ( ) - > ! Files . exists ( indexDirectory ( server , index ) ) ) ; return Files . exists ( indexDirectory ( server , index ) ) ; } public static class ReclocationStartEndTracer extends MockTransportService . Tracer { private final ESLogger logger ; private final CountDownLatch beginRelocationLatch ; private final CountDownLatch receivedShardExistsRequestLatch ; public ReclocationStartEndTracer ( ESLogger logger , CountDownLatch beginRelocationLatch , CountDownLatch receivedShardExistsRequestLatch ) { this . logger = logger ; this . beginRelocationLatch = beginRelocationLatch ; this . receivedShardExistsRequestLatch = receivedShardExistsRequestLatch ; } @Override public void receivedRequest ( long requestId , String action ) { if ( action . equals ( IndicesStore . ACTION_SHARD_EXISTS ) ) { receivedShardExistsRequestLatch . countDown ( ) ; logger . info ( <str> , action ) ; } } @Override public void requestSent ( DiscoveryNode node , long requestId , String action , TransportRequestOptions options ) { if ( action . equals ( RecoverySource . Actions . START_RECOVERY ) ) { logger . info ( <str> , action ) ; beginRelocationLatch . countDown ( ) ; } } } } 
