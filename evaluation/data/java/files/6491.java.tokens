package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . Util ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . RowIterator ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . metrics . ClearableHistogram ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . junit . Test ; import static org . junit . Assert . * ; public class KeyspaceTest extends CQLTester { @Test public void testGetRowNoColumns ( ) throws Throwable { String tableName = createTable ( <str> ) ; execute ( <str> , <str> , <int> , <int> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int round = <int> ; round < <int> ; round + + ) { Util . assertEmpty ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . withLimit ( <int> ) . build ( ) ) ; Util . assertEmpty ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . fromIncl ( <int> ) . toIncl ( <int> ) . build ( ) ) ; Util . assertEmpty ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . includeRow ( <int> ) . build ( ) ) ; if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testGetRowSingleColumn ( ) throws Throwable { String tableName = createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , i ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int round = <int> ; round < <int> ; round + + ) { Row row = Util . getOnlyRow ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( ByteBufferUtil . bytes ( <int> ) , row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) . value ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { row = Util . getOnlyRow ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . includeRow ( i ) . build ( ) ) ; assertEquals ( ByteBufferUtil . bytes ( i ) , row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) . value ( ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { row = Util . getOnlyRow ( Util . cmd ( cfs , <str> ) . columns ( <str> ) . fromIncl ( i ) . toIncl ( i ) . build ( ) ) ; assertEquals ( ByteBufferUtil . bytes ( i ) , row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) . value ( ) ) ; } if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testGetSliceBloomFilterFalsePositive ( ) throws Throwable { String tableName = createTable ( <str> ) ; execute ( <str> , <str> , <int> , <int> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( String key : new String [ ] { <str> , <str> } ) Util . assertEmpty ( Util . cmd ( cfs , key ) . build ( ) ) ; cfs . forceBlockingFlush ( ) ; for ( String key : new String [ ] { <str> , <str> } ) Util . assertEmpty ( Util . cmd ( cfs , key ) . build ( ) ) ; Collection < SSTableReader > sstables = cfs . getLiveSSTables ( ) ; assertEquals ( <int> , sstables . size ( ) ) ; sstables . iterator ( ) . next ( ) . forceFilterFailures ( ) ; for ( String key : new String [ ] { <str> , <str> } ) Util . assertEmpty ( Util . cmd ( cfs , key ) . build ( ) ) ; } private static void assertRowsInSlice ( ColumnFamilyStore cfs , String key , int sliceStart , int sliceEnd , int limit , boolean reversed , String columnValuePrefix ) { Clustering startClustering = new Clustering ( ByteBufferUtil . bytes ( sliceStart ) ) ; Clustering endClustering = new Clustering ( ByteBufferUtil . bytes ( sliceEnd ) ) ; Slices slices = Slices . with ( cfs . getComparator ( ) , Slice . make ( startClustering , endClustering ) ) ; ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter ( slices , reversed ) ; SinglePartitionReadCommand command = singlePartitionSlice ( cfs , key , filter , limit ) ; try ( ReadExecutionController executionController = command . executionController ( ) ; PartitionIterator iterator = command . executeInternal ( executionController ) ) { try ( RowIterator rowIterator = iterator . next ( ) ) { if ( reversed ) { for ( int i = sliceEnd ; i > = sliceStart ; i - - ) { Row row = rowIterator . next ( ) ; Cell cell = row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) ; assertEquals ( ByteBufferUtil . bytes ( columnValuePrefix + i ) , cell . value ( ) ) ; } } else { for ( int i = sliceStart ; i < = sliceEnd ; i + + ) { Row row = rowIterator . next ( ) ; Cell cell = row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) ; assertEquals ( ByteBufferUtil . bytes ( columnValuePrefix + i ) , cell . value ( ) ) ; } } assertFalse ( rowIterator . hasNext ( ) ) ; } } } @Test public void testGetSliceWithCutoff ( ) throws Throwable { String tableName = createTable ( <str> ) ; String prefix = <str> ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , prefix + i ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int round = <int> ; round < <int> ; round + + ) { assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , false , prefix ) ; assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , true , prefix ) ; assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , false , prefix ) ; assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , true , prefix ) ; assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , false , prefix ) ; assertRowsInSlice ( cfs , <str> , <int> , <int> , <int> , true , prefix ) ; if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testReversedWithFlushing ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , i ) ; cfs . forceBlockingFlush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <str> , i , i ) ; PartitionColumns columns = PartitionColumns . of ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) ; ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter ( Slices . ALL , false ) ; SinglePartitionReadCommand command = singlePartitionSlice ( cfs , <str> , filter , null ) ; try ( ReadExecutionController executionController = command . executionController ( ) ; PartitionIterator iterator = command . executeInternal ( executionController ) ) { try ( RowIterator rowIterator = iterator . next ( ) ) { Row row = rowIterator . next ( ) ; Cell cell = row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) ; assertEquals ( ByteBufferUtil . bytes ( i ) , cell . value ( ) ) ; } } } } private static void assertRowsInResult ( ColumnFamilyStore cfs , SinglePartitionReadCommand command , int . . . columnValues ) { try ( ReadExecutionController executionController = command . executionController ( ) ; PartitionIterator iterator = command . executeInternal ( executionController ) ) { if ( columnValues . length = = <int> ) { if ( iterator . hasNext ( ) ) fail ( <str> + iterator . next ( ) . next ( ) . toString ( cfs . metadata ) ) ; return ; } try ( RowIterator rowIterator = iterator . next ( ) ) { for ( int expected : columnValues ) { Row row = rowIterator . next ( ) ; Cell cell = row . getCell ( cfs . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ) ; assertEquals ( String . format ( <str> , ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( expected ) ) , ByteBufferUtil . bytesToHex ( cell . value ( ) ) ) , ByteBufferUtil . bytes ( expected ) , cell . value ( ) ) ; } assertFalse ( rowIterator . hasNext ( ) ) ; } } } private static ClusteringIndexSliceFilter slices ( ColumnFamilyStore cfs , Integer sliceStart , Integer sliceEnd , boolean reversed ) { Slice . Bound startBound = sliceStart = = null ? Slice . Bound . BOTTOM : Slice . Bound . create ( ClusteringPrefix . Kind . INCL_START_BOUND , new ByteBuffer [ ] { ByteBufferUtil . bytes ( sliceStart ) } ) ; Slice . Bound endBound = sliceEnd = = null ? Slice . Bound . TOP : Slice . Bound . create ( ClusteringPrefix . Kind . INCL_END_BOUND , new ByteBuffer [ ] { ByteBufferUtil . bytes ( sliceEnd ) } ) ; Slices slices = Slices . with ( cfs . getComparator ( ) , Slice . make ( startBound , endBound ) ) ; return new ClusteringIndexSliceFilter ( slices , reversed ) ; } private static SinglePartitionReadCommand singlePartitionSlice ( ColumnFamilyStore cfs , String key , ClusteringIndexSliceFilter filter , Integer rowLimit ) { DataLimits limit = rowLimit = = null ? DataLimits . NONE : DataLimits . cqlLimits ( rowLimit ) ; return SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , limit , Util . dk ( key ) , filter ) ; } @Test public void testGetSliceFromBasic ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int i = <int> ; i < <int> ; i + + ) { if ( i = = <int> | | i = = <int> ) continue ; execute ( <str> , <str> , i , i ) ; } execute ( <str> , <str> , <int> ) ; for ( int round = <int> ; round < <int> ; round + + ) { ClusteringIndexSliceFilter filter = slices ( cfs , <int> , null , false ) ; SinglePartitionReadCommand command = singlePartitionSlice ( cfs , <str> , filter , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , null , false ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , <int> , true ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , <int> , true ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , <int> , true ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , null , true ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , null , false ) , <int> ) ; assertRowsInResult ( cfs , command ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , <int> , true ) , <int> ) ; assertRowsInResult ( cfs , command ) ; if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testGetSliceWithExpiration ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; execute ( <str> , <str> , <int> , <int> ) ; execute ( <str> , <str> , <int> , <int> ) ; execute ( <str> , <str> , <int> , <int> ) ; for ( int round = <int> ; round < <int> ; round + + ) { SinglePartitionReadCommand command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , null , false ) , <int> ) ; assertRowsInResult ( cfs , command , <int> , <int> ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , null , false ) , <int> ) ; assertRowsInResult ( cfs , command , <int> ) ; if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testGetSliceFromAdvanced ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , i ) ; cfs . forceBlockingFlush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , - <int> ) ; for ( int round = <int> ; round < <int> ; round + + ) { SinglePartitionReadCommand command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , null , false ) , <int> ) ; assertRowsInResult ( cfs , command , - <int> , - <int> , <int> ) ; if ( round = = <int> ) cfs . forceBlockingFlush ( ) ; } } @Test public void testGetSliceFromLarge ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , i , i ) ; cfs . forceBlockingFlush ( ) ; validateSliceLarge ( cfs ) ; if ( cfs . getLiveSSTables ( ) . size ( ) > <int> ) CompactionManager . instance . performMaximal ( cfs , false ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; RowIndexEntry indexEntry = sstable . getPosition ( Util . dk ( <str> ) , SSTableReader . Operator . EQ ) ; assert indexEntry . columnsIndex ( ) . size ( ) > <int> ; validateSliceLarge ( cfs ) ; } @Test public void testLimitSSTables ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; cfs . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { for ( int i = <int> + ( j * <int> ) ; i < <int> + ( ( j + <int> ) * <int> ) ; i + + ) execute ( <str> , <str> , i , i , ( long ) i ) ; cfs . forceBlockingFlush ( ) ; } ( ( ClearableHistogram ) cfs . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; SinglePartitionReadCommand command = singlePartitionSlice ( cfs , <str> , slices ( cfs , null , <int> , false ) , <int> ) ; int [ ] expectedValues = new int [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) expectedValues [ i ] = i + <int> ; assertRowsInResult ( cfs , command , expectedValues ) ; assertEquals ( <int> , cfs . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMax ( ) , <float> ) ; ( ( ClearableHistogram ) cfs . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , <int> , false ) , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) expectedValues [ i ] = i + <int> ; assertRowsInResult ( cfs , command , expectedValues ) ; assertEquals ( <int> , cfs . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMax ( ) , <float> ) ; ( ( ClearableHistogram ) cfs . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; command = singlePartitionSlice ( cfs , <str> , slices ( cfs , <int> , <int> , true ) , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) expectedValues [ i ] = <int> - i ; assertRowsInResult ( cfs , command , expectedValues ) ; } @Test public void testLimitSSTablesComposites ( ) throws Throwable { String tableName = createTable ( <str> ) ; final ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; cfs . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , <str> , <str> + i , j * <int> + i , <int> ) ; cfs . forceBlockingFlush ( ) ; } ( ( ClearableHistogram ) cfs . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; assertRows ( execute ( <str> , <str> , <str> , <int> , <str> ) , row ( <str> , <str> , <int> , <int> ) , row ( <str> , <str> , <int> , <int> ) ) ; assertEquals ( <int> , cfs . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMax ( ) , <float> ) ; } private void validateSliceLarge ( ColumnFamilyStore cfs ) { ClusteringIndexSliceFilter filter = slices ( cfs , <int> , null , false ) ; SinglePartitionReadCommand command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command , <int> , <int> , <int> ) ; filter = slices ( cfs , <int> , null , false ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command , <int> , <int> , <int> ) ; filter = slices ( cfs , null , <int> , true ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; int [ ] expectedValues = new int [ <int> ] ; for ( int i = <int> , v = <int> ; v > = <int> ; i + + , v - - ) expectedValues [ i ] = v ; assertRowsInResult ( cfs , command , expectedValues ) ; filter = slices ( cfs , <int> , null , false ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command , <int> , <int> , <int> ) ; filter = slices ( cfs , null , null , true ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command , <int> , <int> , <int> ) ; filter = slices ( cfs , null , <int> , true ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command , <int> , <int> , <int> ) ; filter = slices ( cfs , <int> , null , false ) ; command = SinglePartitionReadCommand . create ( cfs . metadata , FBUtilities . nowInSeconds ( ) , ColumnFilter . all ( cfs . metadata ) , RowFilter . NONE , DataLimits . cqlLimits ( <int> ) , Util . dk ( <str> ) , filter ) ; assertRowsInResult ( cfs , command ) ; } }