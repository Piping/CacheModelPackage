package com . google . common . math ; import static com . google . common . math . StatsTesting . ALLOWED_ERROR ; import static com . google . common . math . StatsTesting . ALL_MANY_VALUES ; import static com . google . common . math . StatsTesting . EMPTY_STATS_ITERABLE ; import static com . google . common . math . StatsTesting . MANY_VALUES ; import static com . google . common . math . StatsTesting . MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . MANY_VALUES_STATS_ITERABLE ; import static com . google . common . math . StatsTesting . MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS ; import static com . google . common . math . StatsTesting . ONE_VALUE ; import static com . google . common . math . StatsTesting . ONE_VALUE_STATS ; import static com . google . common . math . StatsTesting . OTHER_MANY_VALUES ; import static com . google . common . math . StatsTesting . OTHER_MANY_VALUES_STATS ; import static com . google . common . math . StatsTesting . OTHER_ONE_VALUE ; import static com . google . common . math . StatsTesting . OTHER_ONE_VALUE_STATS ; import static com . google . common . math . StatsTesting . OTHER_TWO_VALUES ; import static com . google . common . math . StatsTesting . OTHER_TWO_VALUES_STATS ; import static com . google . common . math . StatsTesting . TWO_VALUES ; import static com . google . common . math . StatsTesting . TWO_VALUES_STATS ; import static com . google . common . math . StatsTesting . TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS ; import static com . google . common . math . StatsTesting . assertDiagonalLinearTransformation ; import static com . google . common . math . StatsTesting . assertHorizontalLinearTransformation ; import static com . google . common . math . StatsTesting . assertLinearTransformationNaN ; import static com . google . common . math . StatsTesting . assertStatsApproxEqual ; import static com . google . common . math . StatsTesting . assertVerticalLinearTransformation ; import static com . google . common . math . StatsTesting . createFilledPairedStatsAccumulator ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . math . StatsTesting . ManyValues ; import junit . framework . TestCase ; public class PairedStatsAccumulatorTest extends TestCase { private PairedStatsAccumulator emptyAccumulator ; private PairedStatsAccumulator oneValueAccumulator ; private PairedStatsAccumulator twoValuesAccumulator ; private PairedStatsAccumulator manyValuesAccumulator ; private PairedStatsAccumulator horizontalValuesAccumulator ; private PairedStatsAccumulator verticalValuesAccumulator ; private PairedStatsAccumulator constantValuesAccumulator ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; emptyAccumulator = new PairedStatsAccumulator ( ) ; oneValueAccumulator = new PairedStatsAccumulator ( ) ; oneValueAccumulator . add ( ONE_VALUE , OTHER_ONE_VALUE ) ; twoValuesAccumulator = createFilledPairedStatsAccumulator ( TWO_VALUES , OTHER_TWO_VALUES ) ; manyValuesAccumulator = createFilledPairedStatsAccumulator ( MANY_VALUES , OTHER_MANY_VALUES ) ; horizontalValuesAccumulator = new PairedStatsAccumulator ( ) ; for ( double x : MANY_VALUES ) { horizontalValuesAccumulator . add ( x , OTHER_ONE_VALUE ) ; } verticalValuesAccumulator = new PairedStatsAccumulator ( ) ; for ( double y : OTHER_MANY_VALUES ) { verticalValuesAccumulator . add ( ONE_VALUE , y ) ; } constantValuesAccumulator = new PairedStatsAccumulator ( ) ; for ( int i = <int> ; i < MANY_VALUES_COUNT ; + + i ) { constantValuesAccumulator . add ( ONE_VALUE , OTHER_ONE_VALUE ) ; } } public void testCount ( ) { assertThat ( emptyAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( oneValueAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( twoValuesAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( manyValuesAccumulator . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; } public void testXStats ( ) { assertStatsApproxEqual ( EMPTY_STATS_ITERABLE , emptyAccumulator . xStats ( ) ) ; assertStatsApproxEqual ( ONE_VALUE_STATS , oneValueAccumulator . xStats ( ) ) ; assertStatsApproxEqual ( TWO_VALUES_STATS , twoValuesAccumulator . xStats ( ) ) ; assertStatsApproxEqual ( MANY_VALUES_STATS_ITERABLE , manyValuesAccumulator . xStats ( ) ) ; } public void testYStats ( ) { assertStatsApproxEqual ( EMPTY_STATS_ITERABLE , emptyAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_ONE_VALUE_STATS , oneValueAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_TWO_VALUES_STATS , twoValuesAccumulator . yStats ( ) ) ; assertStatsApproxEqual ( OTHER_MANY_VALUES_STATS , manyValuesAccumulator . yStats ( ) ) ; } public void testPopulationCovariance ( ) { try { emptyAccumulator . populationCovariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . populationCovariance ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( twoValuesAccumulator . populationCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS / <int> ) ; for ( ManyValues values : ALL_MANY_VALUES ) { PairedStatsAccumulator accumulator = createFilledPairedStatsAccumulator ( values . asIterable ( ) , OTHER_MANY_VALUES ) ; double populationCovariance = accumulator . populationCovariance ( ) ; if ( values . hasAnyNonFinite ( ) ) { assertThat ( populationCovariance ) . named ( <str> + values ) . isNaN ( ) ; } else { assertThat ( populationCovariance ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS / MANY_VALUES_COUNT ) ; } } assertThat ( horizontalValuesAccumulator . populationCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; assertThat ( verticalValuesAccumulator . populationCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; assertThat ( constantValuesAccumulator . populationCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; } public void testSampleCovariance ( ) { try { emptyAccumulator . sampleCovariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { oneValueAccumulator . sampleCovariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( twoValuesAccumulator . sampleCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS ) ; assertThat ( manyValuesAccumulator . sampleCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( horizontalValuesAccumulator . sampleCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; assertThat ( verticalValuesAccumulator . sampleCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; assertThat ( constantValuesAccumulator . sampleCovariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; } public void testPearsonsCorrelationCoefficient ( ) { try { emptyAccumulator . pearsonsCorrelationCoefficient ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { oneValueAccumulator . pearsonsCorrelationCoefficient ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( twoValuesAccumulator . pearsonsCorrelationCoefficient ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( twoValuesAccumulator . populationCovariance ( ) / ( twoValuesAccumulator . xStats ( ) . populationStandardDeviation ( ) * twoValuesAccumulator . yStats ( ) . populationStandardDeviation ( ) ) ) ; for ( ManyValues values : ALL_MANY_VALUES ) { PairedStatsAccumulator accumulator = createFilledPairedStatsAccumulator ( MANY_VALUES , values . asIterable ( ) ) ; double pearsonsCorrelationCoefficient = accumulator . pearsonsCorrelationCoefficient ( ) ; if ( values . hasAnyNonFinite ( ) ) { assertThat ( pearsonsCorrelationCoefficient ) . named ( <str> + values ) . isNaN ( ) ; } else { assertThat ( pearsonsCorrelationCoefficient ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( accumulator . populationCovariance ( ) / ( accumulator . xStats ( ) . populationStandardDeviation ( ) * accumulator . yStats ( ) . populationStandardDeviation ( ) ) ) ; } } try { horizontalValuesAccumulator . pearsonsCorrelationCoefficient ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { verticalValuesAccumulator . pearsonsCorrelationCoefficient ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { constantValuesAccumulator . pearsonsCorrelationCoefficient ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testLeastSquaresFit ( ) { try { emptyAccumulator . leastSquaresFit ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { oneValueAccumulator . leastSquaresFit ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertDiagonalLinearTransformation ( twoValuesAccumulator . leastSquaresFit ( ) , twoValuesAccumulator . xStats ( ) . mean ( ) , twoValuesAccumulator . yStats ( ) . mean ( ) , twoValuesAccumulator . xStats ( ) . populationVariance ( ) , twoValuesAccumulator . populationCovariance ( ) ) ; for ( ManyValues values : ALL_MANY_VALUES ) { PairedStatsAccumulator accumulator = createFilledPairedStatsAccumulator ( values . asIterable ( ) , OTHER_MANY_VALUES ) ; LinearTransformation fit = accumulator . leastSquaresFit ( ) ; if ( values . hasAnyNonFinite ( ) ) { assertLinearTransformationNaN ( fit ) ; } else { assertDiagonalLinearTransformation ( fit , accumulator . xStats ( ) . mean ( ) , accumulator . yStats ( ) . mean ( ) , accumulator . xStats ( ) . populationVariance ( ) , accumulator . populationCovariance ( ) ) ; } } assertHorizontalLinearTransformation ( horizontalValuesAccumulator . leastSquaresFit ( ) , horizontalValuesAccumulator . yStats ( ) . mean ( ) ) ; assertVerticalLinearTransformation ( verticalValuesAccumulator . leastSquaresFit ( ) , verticalValuesAccumulator . xStats ( ) . mean ( ) ) ; try { constantValuesAccumulator . leastSquaresFit ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } } 
