package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . DebugUIMessages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . memory . provisional . AbstractAsyncTableRendering ; import org . eclipse . debug . internal . ui . viewers . AbstractUpdatePolicy ; import org . eclipse . debug . internal . ui . viewers . AsynchronousModel ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStatusMonitor ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ICellEditorListener ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TextCellEditor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . TableCursor ; import org . eclipse . swt . custom . TableEditor ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . KeyAdapter ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . TraverseEvent ; import org . eclipse . swt . events . TraverseListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . ui . progress . UIJob ; public class AsyncTableRenderingViewer extends AsyncVirtualContentTableViewer { private AbstractAsyncTableRendering fRendering ; private Object fPendingSelection ; private Object fSelectionKey ; private TableCursor fTableCursor ; private KeyAdapter fCursorKeyAdapter ; private TraverseListener fCursorTraverseListener ; private MouseAdapter fCursorMouseListener ; private SelectionAdapter fCursorSelectionListener ; private TableEditor fCursorEditor ; private KeyAdapter fEditorKeyListener ; private CellEditorListener fCellEditorListener ; private class CellEditorListener implements ICellEditorListener { private CellEditor fEditor ; private int fRow ; private int fCol ; public CellEditorListener ( int row , int col , CellEditor editor ) { fEditor = editor ; fRow = row ; fCol = col ; } @Override public void applyEditorValue ( ) { fEditor . removeListener ( this ) ; modifyValue ( fRow , fCol , fEditor . getValue ( ) ) ; } @Override public void cancelEditor ( ) { fEditor . removeListener ( this ) ; } @Override public void editorValueChanged ( boolean oldValidState , boolean newValidState ) { } public int getRow ( ) { return fRow ; } public int getCol ( ) { return fCol ; } } private boolean fPendingFormatViewer ; public AsyncTableRenderingViewer ( AbstractAsyncTableRendering rendering , Composite parent , int style ) { super ( parent , style ) ; fRendering = rendering ; getTable ( ) . addMouseListener ( new MouseAdapter ( ) { @Override public void mouseDown ( MouseEvent e ) { handleTableMouseEvent ( e ) ; } } ) ; createCursor ( getTable ( ) ) ; } @Override public AbstractUpdatePolicy createUpdatePolicy ( ) { return new AsyncTableRenderingUpdatePolicy ( ) ; } public AbstractAsyncTableRendering getRendering ( ) { return fRendering ; } private void createCursor ( Table table ) { fTableCursor = new TableCursor ( table , SWT . NONE ) ; Display display = fTableCursor . getDisplay ( ) ; fTableCursor . setBackground ( display . getSystemColor ( SWT . COLOR_LIST_SELECTION ) ) ; fTableCursor . setForeground ( display . getSystemColor ( SWT . COLOR_LIST_SELECTION_TEXT ) ) ; fTableCursor . setFont ( JFaceResources . getFont ( IInternalDebugUIConstants . FONT_NAME ) ) ; fCursorKeyAdapter = new KeyAdapter ( ) { @Override public void keyPressed ( KeyEvent e ) { handleCursorKeyPressed ( e ) ; } } ; fTableCursor . addKeyListener ( fCursorKeyAdapter ) ; fCursorTraverseListener = new TraverseListener ( ) { @Override public void keyTraversed ( TraverseEvent e ) { handleCursorTraverseEvt ( e ) ; } } ; fTableCursor . addTraverseListener ( fCursorTraverseListener ) ; fCursorMouseListener = new MouseAdapter ( ) { @Override public void mouseDown ( MouseEvent e ) { handleCursorMouseEvent ( e ) ; } } ; fTableCursor . addMouseListener ( fCursorMouseListener ) ; fTableCursor . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { if ( fTableCursor = = null ) return ; fTableCursor . removeTraverseListener ( fCursorTraverseListener ) ; fTableCursor . removeKeyListener ( fCursorKeyAdapter ) ; fTableCursor . removeMouseListener ( fCursorMouseListener ) ; fTableCursor . removeSelectionListener ( fCursorSelectionListener ) ; } } ) ; fCursorSelectionListener = new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { handleCursorMoved ( ) ; } } ; fTableCursor . addSelectionListener ( fCursorSelectionListener ) ; fCursorEditor = new TableEditor ( getTable ( ) ) ; } private void handleCursorKeyPressed ( KeyEvent event ) { if ( event . character = = <str> & & event . getSource ( ) instanceof TableCursor ) { activateCellEditor ( null ) ; return ; } if ( MemoryViewUtil . isValidEditEvent ( event . keyCode ) ) { if ( event . getSource ( ) instanceof TableCursor ) { int col = fTableCursor . getColumn ( ) ; if ( getCellEditors ( ) [ col ] instanceof TextCellEditor ) { String initialValue = String . valueOf ( event . character ) ; activateCellEditor ( initialValue ) ; } } } } private void handleCursorMouseEvent ( MouseEvent e ) { if ( e . button = = <int> ) { int col = fTableCursor . getColumn ( ) ; if ( col > <int> & & col < = ( getNumCol ( ) ) ) activateCellEditor ( null ) ; } } private void handleCursorTraverseEvt ( TraverseEvent e ) { if ( fTableCursor . getRow ( ) = = null ) return ; Table table = ( Table ) fTableCursor . getParent ( ) ; int row = table . indexOf ( fTableCursor . getRow ( ) ) ; int col = fTableCursor . getColumn ( ) ; if ( col = = getNumCol ( ) & & e . keyCode = = SWT . ARROW_RIGHT ) { if ( row + <int> > = table . getItemCount ( ) ) { return ; } row = row + <int> ; col = <int> ; fTableCursor . setSelection ( row , col ) ; } if ( col < = <int> & & e . keyCode = = SWT . ARROW_LEFT ) { if ( row - <int> < <int> ) { return ; } row = row - <int> ; col = getNumCol ( ) + <int> ; fTableCursor . setSelection ( row , col ) ; } handleCursorMoved ( ) ; } private void handleCursorMoved ( ) { fSelectionKey = getSelectionKeyFromCursor ( ) ; fPendingSelection = null ; if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( Thread . currentThread ( ) . getName ( ) + <str> + ( ( BigInteger ) fSelectionKey ) . toString ( <int> ) ) ; } handleScrollBarSelection ( ) ; fireSelectionChanged ( fSelectionKey ) ; } private int getNumCol ( ) { int bytesPerLine = fRendering . getBytesPerLine ( ) ; int columnSize = fRendering . getBytesPerColumn ( ) ; return bytesPerLine / columnSize ; } public void setSelection ( Object key ) { fPendingSelection = key ; attemptSetKeySelection ( ) ; } public Object getSelectionKey ( ) { return fSelectionKey ; } private synchronized void attemptSetKeySelection ( ) { if ( fPendingSelection ! = null ) { doAttemptSetKeySelection ( fPendingSelection ) ; } } synchronized private Object doAttemptSetKeySelection ( final Object key ) { if ( getBufferTopKey ( ) = = null | | getBufferEndKey ( ) = = null ) return key ; int [ ] location = getCoordinatesFromKey ( key ) ; if ( location . length = = <int> ) { return key ; } UIJob uiJob = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { try { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) key ) . toString ( <int> ) ) ; } if ( fPendingSelection ! = null & & fPendingSelection ! = key ) return Status . OK_STATUS ; if ( fTableCursor . isDisposed ( ) ) return Status . OK_STATUS ; int [ ] newLocation = getCoordinatesFromKey ( key ) ; if ( newLocation . length = = <int> ) { Object selectionKey = getSelectionKey ( ) ; fPendingSelection = selectionKey ; return Status . OK_STATUS ; } fSelectionKey = key ; fPendingSelection = null ; if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + getTable ( ) . getItem ( newLocation [ <int> ] ) . getData ( ) ) ; DebugUIPlugin . trace ( getRendering ( ) + <str> + getVirtualContentModel ( ) . getElement ( newLocation [ <int> ] ) ) ; } fTableCursor . setSelection ( newLocation [ <int> ] , newLocation [ <int> ] ) ; showTableCursor ( true ) ; getTable ( ) . showColumn ( getTable ( ) . getColumn ( newLocation [ <int> ] ) ) ; int topIndex = getTable ( ) . getTopIndex ( ) ; Object topKey = getVirtualContentModel ( ) . getKey ( topIndex ) ; setTopIndexKey ( topKey ) ; } catch ( RuntimeException e ) { Object selectionKey = getSelectionKey ( ) ; fPendingSelection = selectionKey ; doAttemptSetKeySelection ( selectionKey ) ; } return Status . OK_STATUS ; } } ; uiJob . setSystem ( true ) ; uiJob . schedule ( ) ; return null ; } private int [ ] getCoordinatesFromKey ( Object key ) { final int row = indexOf ( key ) ; if ( row = = - <int> ) { return new int [ <int> ] ; } Object element = getVirtualContentModel ( ) . getElement ( row ) ; final int col = columnOf ( element , key ) ; if ( col = = - <int> ) { return new int [ <int> ] ; } return new int [ ] { row , col } ; } private Object getSelectionKeyFromCursor ( ) { int idx = getTable ( ) . indexOf ( fTableCursor . getRow ( ) ) ; int col = fTableCursor . getColumn ( ) ; return getVirtualContentModel ( ) . getKey ( idx , col ) ; } private Object getBufferTopKey ( ) { return getKey ( <int> ) ; } private Object getBufferEndKey ( ) { AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) return getKey ( model . getElements ( ) . length - <int> ) ; return null ; } public int indexOf ( Object key ) { int idx = - <int> ; AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) idx = model . indexOfKey ( key ) ; return idx ; } private int columnOf ( Object element , Object key ) { int idx = - <int> ; AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) { idx = model . columnOf ( element , key ) ; } return idx ; } public Object getKey ( int index ) { AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) { Object key = model . getKey ( index ) ; return key ; } return null ; } public Object getKey ( int row , int col ) { AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) return model . getKey ( row , col ) ; return null ; } @Override protected synchronized void preservingSelection ( Runnable updateCode ) { Object oldTopIndexKey = null ; if ( getPendingSetTopIndexKey ( ) = = null ) { oldTopIndexKey = getTopIndexKey ( ) ; } else { oldTopIndexKey = getPendingSetTopIndexKey ( ) ; } Object oldSelectionKey = null ; try { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { if ( oldTopIndexKey ! = null ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) oldTopIndexKey ) . toString ( <int> ) ) ; } else { DebugUIPlugin . trace ( <str> ) ; } } if ( fPendingSelection ! = null ) oldSelectionKey = fPendingSelection ; else oldSelectionKey = getSelectionKey ( ) ; if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { if ( oldTopIndexKey ! = null ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) oldSelectionKey ) . toString ( <int> ) ) ; } else { DebugUIPlugin . trace ( <str> ) ; } } updateCode . run ( ) ; } finally { if ( oldSelectionKey ! = null ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) oldSelectionKey ) . toString ( <int> ) ) ; } setSelection ( oldSelectionKey ) ; } if ( getPendingSetTopIndexKey ( ) ! = null ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { if ( oldTopIndexKey ! = null ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) oldTopIndexKey ) . toString ( <int> ) ) ; } } setTopIndex ( getPendingSetTopIndexKey ( ) ) ; } else if ( oldTopIndexKey ! = null ) { setTopIndex ( oldTopIndexKey ) ; if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( getRendering ( ) + <str> + ( ( BigInteger ) oldTopIndexKey ) . toString ( <int> ) ) ; } } } } @Override public void dispose ( ) { super . dispose ( ) ; if ( fTableCursor ! = null & & ! fTableCursor . isDisposed ( ) ) { fCursorEditor . dispose ( ) ; fCursorEditor = null ; fTableCursor . removeTraverseListener ( fCursorTraverseListener ) ; fTableCursor . removeKeyListener ( fCursorKeyAdapter ) ; fTableCursor . removeMouseListener ( fCursorMouseListener ) ; fTableCursor . removeSelectionListener ( fCursorSelectionListener ) ; fTableCursor . dispose ( ) ; fTableCursor = null ; } } public void showTableCursor ( final boolean show ) { Display display = DebugUIPlugin . getDefault ( ) . getWorkbench ( ) . getDisplay ( ) ; if ( Thread . currentThread ( ) = = display . getThread ( ) ) { if ( ! fTableCursor . isDisposed ( ) ) { if ( fTableCursor . isVisible ( ) ! = show ) fTableCursor . setVisible ( show ) ; } } else { UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( ! fTableCursor . isDisposed ( ) ) { if ( fTableCursor . isVisible ( ) ! = show ) fTableCursor . setVisible ( show ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } private void handleTableMouseEvent ( MouseEvent e ) { TableItem [ ] tableItems = getTable ( ) . getItems ( ) ; TableItem selectedRow = null ; int colNum = - <int> ; int numCol = getColumnProperties ( ) . length ; for ( int j = <int> ; j < tableItems . length ; j + + ) { TableItem item = tableItems [ j ] ; if ( item . getData ( ) ! = null ) { for ( int i = <int> ; i < numCol ; i + + ) { Rectangle bound = item . getBounds ( i ) ; if ( bound . contains ( e . x , e . y ) ) { colNum = i ; selectedRow = item ; break ; } } } if ( colNum > = <int> ) break ; } if ( colNum < <int> ) return ; if ( selectedRow ! = null ) { int row = getTable ( ) . indexOf ( selectedRow ) ; showTableCursor ( true ) ; fTableCursor . setSelection ( row , colNum ) ; handleCursorMoved ( ) ; fTableCursor . setFocus ( ) ; } } private void activateCellEditor ( String initialValue ) { final int col = fTableCursor . getColumn ( ) ; final int row = indexOf ( fSelectionKey ) ; if ( row < <int> ) return ; if ( col = = <int> | | col > getNumCol ( ) ) { return ; } ICellModifier cellModifier = null ; cellModifier = getCellModifier ( ) ; TableItem tableItem = getTable ( ) . getItem ( row ) ; Object element = tableItem . getData ( ) ; if ( element ! = null ) { Object property = getColumnProperties ( ) [ col ] ; Object value = cellModifier . getValue ( element , ( String ) property ) ; boolean canEdit = cellModifier . canModify ( element , ( String ) property ) ; if ( ! canEdit ) return ; CellEditor editor = getCellEditors ( ) [ col ] ; if ( editor ! = null ) { Control control = editor . getControl ( ) ; Object cellValue = null ; if ( initialValue ! = null ) { cellValue = initialValue ; } else { cellValue = value ; } editor . setValue ( cellValue ) ; fCursorEditor . horizontalAlignment = SWT . LEFT ; fCursorEditor . grabHorizontal = true ; fCursorEditor . setEditor ( control , tableItem , col ) ; editor . setFocus ( ) ; if ( initialValue ! = null & & control instanceof Text ) { ( ( Text ) control ) . clearSelection ( ) ; } control . setFont ( JFaceResources . getFont ( IInternalDebugUIConstants . FONT_NAME ) ) ; addListeners ( control ) ; fCellEditorListener = new CellEditorListener ( row , col , editor ) ; editor . addListener ( fCellEditorListener ) ; fTableCursor . moveBelow ( control ) ; } } } private void deactivateEditor ( CellEditor editor ) { removeListeners ( editor . getControl ( ) ) ; fTableCursor . moveAbove ( editor . getControl ( ) ) ; fTableCursor . setFocus ( ) ; } private void addListeners ( Control control ) { fEditorKeyListener = new KeyAdapter ( ) { @Override public void keyPressed ( KeyEvent e ) { handleKeyEventInEditor ( e ) ; } } ; control . addKeyListener ( fEditorKeyListener ) ; } private void handleKeyEventInEditor ( KeyEvent event ) { final KeyEvent e = event ; Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { Object obj = e . getSource ( ) ; if ( obj instanceof Control ) { Control control = ( Control ) obj ; int row = fCellEditorListener . getRow ( ) ; int col = fCellEditorListener . getCol ( ) ; try { switch ( e . keyCode ) { case <int> : doHandleKeyEvent ( row , col ) ; break ; case SWT . ESC : cancelEditing ( row , col ) ; break ; default : doHandleKeyEvent ( row , col ) ; break ; } } catch ( NumberFormatException e1 ) { MemoryViewUtil . openError ( DebugUIMessages . MemoryViewCellModifier_failure_title , DebugUIMessages . MemoryViewCellModifier_data_is_invalid , null ) ; fTableCursor . setSelection ( row , col ) ; handleCursorMoved ( ) ; removeListeners ( control ) ; } } } } ) ; } private void doHandleKeyEvent ( int row , int col ) { int numCharsPerByte = fRendering . getNumCharsPerByte ( ) ; if ( numCharsPerByte > <int> ) { Object value = getCellEditors ( ) [ col ] . getValue ( ) ; if ( getCellEditors ( ) [ col ] instanceof TextCellEditor & & value instanceof String ) { String str = ( String ) value ; if ( str . length ( ) > fRendering . getBytesPerColumn ( ) * numCharsPerByte ) { String newValue = str ; CellEditor editor = getCellEditors ( ) [ col ] ; editor . setValue ( newValue . substring ( <int> , fRendering . getBytesPerColumn ( ) * numCharsPerByte ) ) ; fCellEditorListener . cancelEditor ( ) ; deactivateEditor ( editor ) ; modifyValue ( fCellEditorListener . getRow ( ) , fCellEditorListener . getCol ( ) , editor . getValue ( ) ) ; if ( col > = getNumCol ( ) ) { col = <int> ; row + + ; } else { col + + ; } fTableCursor . setSelection ( row , col ) ; handleCursorMoved ( ) ; activateCellEditor ( newValue . substring ( fRendering . getBytesPerColumn ( ) * numCharsPerByte ) ) ; } } } } private void cancelEditing ( int row , int col ) { fCellEditorListener . cancelEditor ( ) ; deactivateEditor ( getCellEditors ( ) [ col ] ) ; fTableCursor . setSelection ( row , col ) ; handleCursorMoved ( ) ; fTableCursor . setFocus ( ) ; } private void removeListeners ( Control control ) { control . removeKeyListener ( fEditorKeyListener ) ; } private void modifyValue ( int row , int col , Object newValue ) throws NumberFormatException { if ( newValue instanceof String & & ( ( String ) newValue ) . length ( ) = = <int> ) { return ; } if ( row > = <int> & & row < getTable ( ) . getItemCount ( ) ) { TableItem tableItem = getTable ( ) . getItem ( row ) ; Object property = getColumnProperties ( ) [ col ] ; getCellModifier ( ) . modify ( tableItem , ( String ) property , newValue ) ; } } public TableCursor getCursor ( ) { return fTableCursor ; } @Override public IBaseLabelProvider getLabelProvider ( ) { return new ITableLabelProvider ( ) { @Override public Image getColumnImage ( Object element , int columnIndex ) { return null ; } @Override public String getColumnText ( Object element , int columnIndex ) { int idx = getVirtualContentModel ( ) . indexOfElement ( element ) ; if ( idx > = <int> ) { TableItem item = getTable ( ) . getItem ( idx ) ; return item . getText ( columnIndex ) ; } return IInternalDebugCoreConstants . EMPTY_STRING ; } @Override public void addListener ( ILabelProviderListener listener ) { } @Override public void dispose ( ) { } @Override public boolean isLabelProperty ( Object element , String property ) { return false ; } @Override public void removeListener ( ILabelProviderListener listener ) { } } ; } public void formatViewer ( ) { if ( getModel ( ) = = null | | ! hasPendingUpdates ( ) ) doFormatViewer ( ) ; else fPendingFormatViewer = true ; } private void doFormatViewer ( ) { fPendingFormatViewer = false ; preservingSelection ( new Runnable ( ) { @Override public void run ( ) { AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) { model . handleViewerChanged ( ) ; } } } ) ; } private void fireSelectionChanged ( Object selectionKey ) { if ( selectionKey ! = null ) { SelectionChangedEvent evt = new SelectionChangedEvent ( this , new StructuredSelection ( selectionKey ) ) ; fireSelectionChanged ( evt ) ; } } @Override public void handlePresentationFailure ( IStatusMonitor monitor , IStatus status ) { super . handlePresentationFailure ( monitor , status ) ; } @Override public void refresh ( boolean getContent ) { if ( getContent ) refresh ( ) ; else { preservingSelection ( new Runnable ( ) { @Override public void run ( ) { AbstractVirtualContentTableModel model = getVirtualContentModel ( ) ; if ( model ! = null ) { Object [ ] elements = model . getElements ( ) ; model . remove ( elements ) ; model . add ( elements ) ; } } } ) ; } } @Override protected void tableTopIndexSetComplete ( ) { if ( ! fTableCursor . isDisposed ( ) ) { int [ ] coordinates = getCoordinatesFromKey ( getSelectionKey ( ) ) ; if ( coordinates . length > <int> ) fTableCursor . setVisible ( true ) ; else fTableCursor . setVisible ( false ) ; } } @Override public AsynchronousModel getModel ( ) { return super . getModel ( ) ; } @Override protected AbstractVirtualContentTableModel createVirtualContentTableModel ( ) { return new TableRenderingModel ( this ) ; } @Override protected void updateComplete ( IStatusMonitor monitor ) { super . updateComplete ( monitor ) ; if ( ! hasPendingUpdates ( ) & & ! fTableCursor . isDisposed ( ) ) { attemptSetKeySelection ( ) ; fTableCursor . redraw ( ) ; if ( ! hasPendingSetTopIndex ( ) ) { preservingSelection ( new Runnable ( ) { @Override public void run ( ) { int [ ] coordinates = getCoordinatesFromKey ( getSelectionKey ( ) ) ; if ( coordinates . length > <int> ) fTableCursor . setVisible ( true ) ; else fTableCursor . setVisible ( false ) ; } } ) ; } } if ( ! hasPendingUpdates ( ) & & fPendingFormatViewer ) { formatViewer ( ) ; resizeColumnsToPreferredSize ( ) ; } } @Override protected void clear ( Widget item ) { super . clear ( item ) ; if ( item instanceof TableItem ) { item . setData ( null ) ; } } }