package rx . internal . operators ; import java . util . * ; import rx . * ; import rx . Observable . Operator ; import rx . Observable ; import rx . Observer ; import rx . functions . Action0 ; import rx . subscriptions . Subscriptions ; public final class OperatorWindowWithSize < T > implements Operator < Observable < T > , T > { final int size ; final int skip ; public OperatorWindowWithSize ( int size , int skip ) { this . size = size ; this . skip = skip ; } @Override public Subscriber < ? super T > call ( Subscriber < ? super Observable < T > > child ) { if ( skip = = size ) { ExactSubscriber e = new ExactSubscriber ( child ) ; e . init ( ) ; return e ; } InexactSubscriber ie = new InexactSubscriber ( child ) ; ie . init ( ) ; return ie ; } final class ExactSubscriber extends Subscriber < T > { final Subscriber < ? super Observable < T > > child ; int count ; UnicastSubject < T > window ; volatile boolean noWindow = true ; public ExactSubscriber ( Subscriber < ? super Observable < T > > child ) { this . child = child ; } void init ( ) { child . add ( Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { if ( noWindow ) { unsubscribe ( ) ; } } } ) ) ; child . setProducer ( new Producer ( ) { @Override public void request ( long n ) { if ( n > <int> ) { long u = n * size ; if ( ( ( u > > > <int> ) ! = <int> ) & & ( u / n ! = size ) ) { u = Long . MAX_VALUE ; } requestMore ( u ) ; } } } ) ; } void requestMore ( long n ) { request ( n ) ; } @Override public void onNext ( T t ) { if ( window = = null ) { noWindow = false ; window = UnicastSubject . create ( ) ; child . onNext ( window ) ; } window . onNext ( t ) ; if ( + + count % size = = <int> ) { window . onCompleted ( ) ; window = null ; noWindow = true ; if ( child . isUnsubscribed ( ) ) { unsubscribe ( ) ; } } } @Override public void onError ( Throwable e ) { if ( window ! = null ) { window . onError ( e ) ; } child . onError ( e ) ; } @Override public void onCompleted ( ) { if ( window ! = null ) { window . onCompleted ( ) ; } child . onCompleted ( ) ; } } final class InexactSubscriber extends Subscriber < T > { final Subscriber < ? super Observable < T > > child ; int count ; final List < CountedSubject < T > > chunks = new LinkedList < CountedSubject < T > > ( ) ; volatile boolean noWindow = true ; public InexactSubscriber ( Subscriber < ? super Observable < T > > child ) { this . child = child ; } void init ( ) { child . add ( Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { if ( noWindow ) { unsubscribe ( ) ; } } } ) ) ; child . setProducer ( new Producer ( ) { @Override public void request ( long n ) { if ( n > <int> ) { long u = n * size ; if ( ( ( u > > > <int> ) ! = <int> ) & & ( u / n ! = size ) ) { u = Long . MAX_VALUE ; } requestMore ( u ) ; } } } ) ; } void requestMore ( long n ) { request ( n ) ; } @Override public void onNext ( T t ) { if ( count + + % skip = = <int> ) { if ( ! child . isUnsubscribed ( ) ) { if ( chunks . isEmpty ( ) ) { noWindow = false ; } CountedSubject < T > cs = createCountedSubject ( ) ; chunks . add ( cs ) ; child . onNext ( cs . producer ) ; } } Iterator < CountedSubject < T > > it = chunks . iterator ( ) ; while ( it . hasNext ( ) ) { CountedSubject < T > cs = it . next ( ) ; cs . consumer . onNext ( t ) ; if ( + + cs . count = = size ) { it . remove ( ) ; cs . consumer . onCompleted ( ) ; } } if ( chunks . isEmpty ( ) ) { noWindow = true ; if ( child . isUnsubscribed ( ) ) { unsubscribe ( ) ; } } } @Override public void onError ( Throwable e ) { List < CountedSubject < T > > list = new ArrayList < CountedSubject < T > > ( chunks ) ; chunks . clear ( ) ; noWindow = true ; for ( CountedSubject < T > cs : list ) { cs . consumer . onError ( e ) ; } child . onError ( e ) ; } @Override public void onCompleted ( ) { List < CountedSubject < T > > list = new ArrayList < CountedSubject < T > > ( chunks ) ; chunks . clear ( ) ; noWindow = true ; for ( CountedSubject < T > cs : list ) { cs . consumer . onCompleted ( ) ; } child . onCompleted ( ) ; } CountedSubject < T > createCountedSubject ( ) { final UnicastSubject < T > bus = UnicastSubject . create ( ) ; return new CountedSubject < T > ( bus , bus ) ; } } static final class CountedSubject < T > { final Observer < T > consumer ; final Observable < T > producer ; int count ; public CountedSubject ( Observer < T > consumer , Observable < T > producer ) { this . consumer = consumer ; this . producer = producer ; } } }