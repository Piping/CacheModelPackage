package org . nd4j . linalg . convolution ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import java . util . Arrays ; import static org . junit . Assert . assertEquals ; public class ConvolutionTests extends BaseNd4jTest { public ConvolutionTests ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public ConvolutionTests ( Nd4jBackend backend ) { super ( backend ) ; } public ConvolutionTests ( String name ) { super ( name ) ; } public ConvolutionTests ( ) { } @Test public void testConvOutWidthAndHeight ( ) { int outSize = Convolution . outSize ( <int> , <int> , <int> , <int> , false ) ; assertEquals ( <int> , outSize ) ; } @Test public void testIm2Col ( ) { INDArray linspaced = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; INDArray ret = Convolution . im2col ( linspaced , <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; System . out . println ( ret ) ; } @Test public void testCompareIm2ColImpl ( ) { int [ ] miniBatches = { <int> , <int> , <int> } ; int [ ] depths = { <int> , <int> , <int> } ; int [ ] inHeights = { <int> , <int> } ; int [ ] inWidths = { <int> , <int> } ; int [ ] strideH = { <int> , <int> } ; int [ ] strideW = { <int> , <int> } ; int [ ] sizeW = { <int> , <int> , <int> } ; int [ ] sizeH = { <int> , <int> , <int> } ; int [ ] padH = { <int> , <int> , <int> } ; int [ ] padW = { <int> , <int> , <int> } ; boolean [ ] coverall = { false , true } ; DataBuffer . Type [ ] types = new DataBuffer . Type [ ] { DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE , DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE } ; DataBuffer . AllocationMode [ ] modes = new DataBuffer . AllocationMode [ ] { DataBuffer . AllocationMode . HEAP , DataBuffer . AllocationMode . HEAP , DataBuffer . AllocationMode . DIRECT , DataBuffer . AllocationMode . DIRECT } ; String factoryClassName = Nd4j . factory ( ) . getClass ( ) . toString ( ) . toLowerCase ( ) ; if ( factoryClassName . contains ( <str> ) | | factoryClassName . contains ( <str> ) ) { types = new DataBuffer . Type [ ] { DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE } ; modes = new DataBuffer . AllocationMode [ ] { DataBuffer . AllocationMode . DIRECT , DataBuffer . AllocationMode . DIRECT } ; } for ( int i = <int> ; i < types . length ; i + + ) { DataBuffer . Type type = types [ i ] ; DataBuffer . AllocationMode mode = modes [ i ] ; Nd4j . factory ( ) . setDType ( type ) ; Nd4j . dtype = type ; Nd4j . alloc = mode ; for ( int m : miniBatches ) { for ( int d : depths ) { for ( int h : inHeights ) { for ( int w : inWidths ) { for ( int sh : strideH ) { for ( int sw : strideW ) { for ( int kh : sizeH ) { for ( int kw : sizeW ) { for ( int ph : padH ) { for ( int pw : padW ) { if ( ( w - kw + <int> * pw ) % sw ! = <int> | | ( h - kh + <int> * ph ) % sh ! = <int> ) continue ; for ( boolean cAll : coverall ) { INDArray in = Nd4j . rand ( new int [ ] { m , d , h , w } ) ; assertEquals ( in . data ( ) . allocationMode ( ) , mode ) ; assertEquals ( in . data ( ) . dataType ( ) , type ) ; INDArray outOrig = OldConvolution . im2col ( in , kh , kw , sh , sw , ph , pw , - <int> , cAll ) ; INDArray outNew = Convolution . im2col ( in , kh , kw , sh , sw , ph , pw , cAll ) ; assertEquals ( outOrig , outNew ) ; } } } } } } } } } } } } } @Test public void testCompareIm2Col ( ) throws Exception { int [ ] miniBatches = { <int> , <int> , <int> } ; int [ ] depths = { <int> , <int> , <int> } ; int [ ] inHeights = { <int> , <int> } ; int [ ] inWidths = { <int> , <int> } ; int [ ] strideH = { <int> , <int> } ; int [ ] strideW = { <int> , <int> } ; int [ ] sizeW = { <int> , <int> , <int> } ; int [ ] sizeH = { <int> , <int> , <int> } ; int [ ] padH = { <int> , <int> , <int> } ; int [ ] padW = { <int> , <int> , <int> } ; DataBuffer . Type [ ] types = new DataBuffer . Type [ ] { DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE , DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE } ; DataBuffer . AllocationMode [ ] modes = new DataBuffer . AllocationMode [ ] { DataBuffer . AllocationMode . HEAP , DataBuffer . AllocationMode . HEAP , DataBuffer . AllocationMode . DIRECT , DataBuffer . AllocationMode . DIRECT } ; String factoryClassName = Nd4j . factory ( ) . getClass ( ) . toString ( ) . toLowerCase ( ) ; if ( factoryClassName . contains ( <str> ) | | factoryClassName . contains ( <str> ) ) { types = new DataBuffer . Type [ ] { DataBuffer . Type . FLOAT , DataBuffer . Type . DOUBLE } ; modes = new DataBuffer . AllocationMode [ ] { DataBuffer . AllocationMode . DIRECT , DataBuffer . AllocationMode . DIRECT } ; } for ( int i = <int> ; i < types . length ; i + + ) { DataBuffer . Type type = types [ i ] ; DataBuffer . AllocationMode mode = modes [ i ] ; Nd4j . factory ( ) . setDType ( type ) ; Nd4j . dtype = type ; Nd4j . alloc = mode ; for ( int m : miniBatches ) { for ( int d : depths ) { for ( int h : inHeights ) { for ( int w : inWidths ) { for ( int sh : strideH ) { for ( int sw : strideW ) { for ( int kh : sizeH ) { for ( int kw : sizeW ) { for ( int ph : padH ) { for ( int pw : padW ) { if ( ( w - kw + <int> * pw ) % sw ! = <int> | | ( h - kh + <int> * ph ) % sh ! = <int> ) continue ; INDArray in = Nd4j . rand ( new int [ ] { m , d , h , w } ) ; assertEquals ( in . data ( ) . allocationMode ( ) , mode ) ; assertEquals ( in . data ( ) . dataType ( ) , type ) ; INDArray im2col = Convolution . im2col ( in , kh , kw , sh , sw , ph , pw , false ) ; INDArray imgOutOld = OldConvolution . col2im ( im2col , sh , sw , ph , pw , h , w ) ; INDArray imgOutNew = Convolution . col2im ( im2col , sh , sw , ph , pw , h , w ) ; assertEquals ( imgOutOld , imgOutNew ) ; } } } } } } } } } } } } @Override public char ordering ( ) { return <str> ; } }