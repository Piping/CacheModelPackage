package com . google . common . primitives ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Comparator ; import java . util . List ; import java . util . Random ; @GwtCompatible ( emulated = true ) public class UnsignedIntsTest extends TestCase { private static final long [ ] UNSIGNED_INTS = { <int> , <int> , <int> , <int> , <hex> L , <hex> L , <hex> L , <hex> L , <hex> L , <hex> L , <hex> L } ; private static final int LEAST = ( int ) <int> ; private static final int GREATEST = ( int ) <hex> L ; public void testToLong ( ) { for ( long a : UNSIGNED_INTS ) { assertEquals ( a , UnsignedInts . toLong ( ( int ) a ) ) ; } } public void testCompare ( ) { for ( long a : UNSIGNED_INTS ) { for ( long b : UNSIGNED_INTS ) { int cmpAsLongs = Longs . compare ( a , b ) ; int cmpAsUInt = UnsignedInts . compare ( ( int ) a , ( int ) b ) ; assertEquals ( Integer . signum ( cmpAsLongs ) , Integer . signum ( cmpAsUInt ) ) ; } } } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { UnsignedInts . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( LEAST , UnsignedInts . max ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedInts . max ( GREATEST ) ) ; assertEquals ( ( int ) <hex> L , UnsignedInts . max ( ( int ) <int> , ( int ) <int> , ( int ) <int> , ( int ) <hex> L , ( int ) <hex> L , ( int ) <hex> L , ( int ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { UnsignedInts . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( LEAST , UnsignedInts . min ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedInts . min ( GREATEST ) ) ; assertEquals ( ( int ) <int> , UnsignedInts . min ( ( int ) <int> , ( int ) <int> , ( int ) <int> , ( int ) <hex> L , ( int ) <hex> L , ( int ) <hex> L , ( int ) <int> ) ) ; } public void testLexicographicalComparator ( ) { List < int [ ] > ordered = Arrays . asList ( new int [ ] { } , new int [ ] { LEAST } , new int [ ] { LEAST , LEAST } , new int [ ] { LEAST , ( int ) <int> } , new int [ ] { ( int ) <int> } , new int [ ] { ( int ) <int> , LEAST } , new int [ ] { GREATEST , ( GREATEST - ( int ) <int> ) } , new int [ ] { GREATEST , GREATEST } , new int [ ] { GREATEST , GREATEST , GREATEST } ) ; Comparator < int [ ] > comparator = UnsignedInts . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; } public void testDivide ( ) { for ( long a : UNSIGNED_INTS ) { for ( long b : UNSIGNED_INTS ) { try { assertEquals ( ( int ) ( a / b ) , UnsignedInts . divide ( ( int ) a , ( int ) b ) ) ; assertFalse ( b = = <int> ) ; } catch ( ArithmeticException e ) { assertEquals ( <int> , b ) ; } } } } public void testRemainder ( ) { for ( long a : UNSIGNED_INTS ) { for ( long b : UNSIGNED_INTS ) { try { assertEquals ( ( int ) ( a % b ) , UnsignedInts . remainder ( ( int ) a , ( int ) b ) ) ; assertFalse ( b = = <int> ) ; } catch ( ArithmeticException e ) { assertEquals ( <int> , b ) ; } } } } @GwtIncompatible ( <str> ) public void testDivideRemainderEuclideanProperty ( ) { Random r = new Random ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { int dividend = r . nextInt ( ) ; int divisor = r . nextInt ( ) ; assertTrue ( dividend - ( divisor * UnsignedInts . divide ( dividend , divisor ) + UnsignedInts . remainder ( dividend , divisor ) ) = = <int> ) ; } } public void testParseInt ( ) { for ( long a : UNSIGNED_INTS ) { assertEquals ( ( int ) a , UnsignedInts . parseUnsignedInt ( Long . toString ( a ) ) ) ; } } @SuppressWarnings ( <str> ) public void testParseIntFail ( ) { try { UnsignedInts . parseUnsignedInt ( Long . toString ( <int> < < <int> ) ) ; fail ( <str> ) ; } catch ( NumberFormatException expected ) { } } public void testParseIntWithRadix ( ) { for ( long a : UNSIGNED_INTS ) { for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { assertEquals ( ( int ) a , UnsignedInts . parseUnsignedInt ( Long . toString ( a , radix ) , radix ) ) ; } } } @SuppressWarnings ( <str> ) public void testParseIntWithRadixLimits ( ) { for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { String maxAsString = Long . toString ( ( <int> < < <int> ) - <int> , radix ) ; assertEquals ( - <int> , UnsignedInts . parseUnsignedInt ( maxAsString , radix ) ) ; try { long overflow = <int> < < <int> ; String overflowAsString = Long . toString ( overflow , radix ) ; UnsignedInts . parseUnsignedInt ( overflowAsString , radix ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } } @SuppressWarnings ( <str> ) public void testParseIntThrowsExceptionForInvalidRadix ( ) { try { UnsignedInts . parseUnsignedInt ( <str> , Character . MIN_RADIX - <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedInts . parseUnsignedInt ( <str> , Character . MAX_RADIX + <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedInts . parseUnsignedInt ( <str> , - <int> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testDecodeInt ( ) { assertEquals ( <hex> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <int> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <int> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <hex> , UnsignedInts . decode ( <str> ) ) ; assertEquals ( <int> , UnsignedInts . decode ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testDecodeIntFails ( ) { try { UnsignedInts . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedInts . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedInts . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } try { UnsignedInts . decode ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testToString ( ) { int [ ] bases = { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( long a : UNSIGNED_INTS ) { for ( int base : bases ) { assertEquals ( UnsignedInts . toString ( ( int ) a , base ) , Long . toString ( a , base ) ) ; } } } public void testJoin ( ) { assertEquals ( <str> , join ( ) ) ; assertEquals ( <str> , join ( <int> ) ) ; assertEquals ( <str> , join ( <int> , <int> ) ) ; assertEquals ( <str> , join ( - <int> , Integer . MIN_VALUE ) ) ; assertEquals ( <str> , UnsignedInts . join ( <str> , <int> , <int> , <int> ) ) ; } private static String join ( int . . . values ) { return UnsignedInts . join ( <str> , values ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( UnsignedInts . class ) ; } } 
