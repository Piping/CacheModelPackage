package org . elasticsearch . transport . netty ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BaseTransportResponseHandler ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportResponseOptions ; import java . io . IOException ; import static java . util . Collections . emptyMap ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; public class NettyScheduledPingTests extends ESTestCase { public void testScheduledPing ( ) throws Exception { ThreadPool threadPool = new ThreadPool ( getClass ( ) . getName ( ) ) ; Settings settings = Settings . builder ( ) . put ( NettyTransport . PING_SCHEDULE , <str> ) . put ( <str> , <int> ) . build ( ) ; final NettyTransport nettyA = new NettyTransport ( settings , threadPool , new NetworkService ( settings ) , BigArrays . NON_RECYCLING_INSTANCE , Version . CURRENT , new NamedWriteableRegistry ( ) ) ; MockTransportService serviceA = new MockTransportService ( settings , nettyA , threadPool ) ; serviceA . start ( ) ; final NettyTransport nettyB = new NettyTransport ( settings , threadPool , new NetworkService ( settings ) , BigArrays . NON_RECYCLING_INSTANCE , Version . CURRENT , new NamedWriteableRegistry ( ) ) ; MockTransportService serviceB = new MockTransportService ( settings , nettyB , threadPool ) ; serviceB . start ( ) ; DiscoveryNode nodeA = new DiscoveryNode ( <str> , <str> , serviceA . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , Version . CURRENT ) ; DiscoveryNode nodeB = new DiscoveryNode ( <str> , <str> , serviceB . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , Version . CURRENT ) ; serviceA . connectToNode ( nodeB ) ; serviceB . connectToNode ( nodeA ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( nettyA . scheduledPing . successfulPings . count ( ) , greaterThan ( <int> l ) ) ; assertThat ( nettyB . scheduledPing . successfulPings . count ( ) , greaterThan ( <int> l ) ) ; } } ) ; assertThat ( nettyA . scheduledPing . failedPings . count ( ) , equalTo ( <int> l ) ) ; assertThat ( nettyB . scheduledPing . failedPings . count ( ) , equalTo ( <int> l ) ) ; serviceA . registerRequestHandler ( <str> , TransportRequest . Empty : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < TransportRequest . Empty > ( ) { @Override public void messageReceived ( TransportRequest . Empty request , TransportChannel channel ) { try { channel . sendResponse ( TransportResponse . Empty . INSTANCE , TransportResponseOptions . EMPTY ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; int rounds = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < rounds ; i + + ) { serviceB . submitRequest ( nodeA , <str> , TransportRequest . Empty . INSTANCE , TransportRequestOptions . builder ( ) . withCompress ( randomBoolean ( ) ) . build ( ) , new BaseTransportResponseHandler < TransportResponse . Empty > ( ) { @Override public TransportResponse . Empty newInstance ( ) { return TransportResponse . Empty . INSTANCE ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( TransportResponse . Empty response ) { } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( <str> + exp . getMessage ( ) , false , equalTo ( true ) ) ; } } ) . txGet ( ) ; } assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( nettyA . scheduledPing . successfulPings . count ( ) , greaterThan ( <int> l ) ) ; assertThat ( nettyB . scheduledPing . successfulPings . count ( ) , greaterThan ( <int> l ) ) ; } } ) ; assertThat ( nettyA . scheduledPing . failedPings . count ( ) , equalTo ( <int> l ) ) ; assertThat ( nettyB . scheduledPing . failedPings . count ( ) , equalTo ( <int> l ) ) ; Releasables . close ( serviceA , serviceB ) ; terminate ( threadPool ) ; } } 
