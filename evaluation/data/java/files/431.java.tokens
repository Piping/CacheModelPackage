package rx . internal . operators ; import java . util . concurrent . atomic . AtomicInteger ; import rx . Observable . Operator ; import rx . exceptions . Exceptions ; import rx . Producer ; import rx . Subscriber ; public class OperatorTakeLastOne < T > implements Operator < T , T > { private static class Holder { static final OperatorTakeLastOne < Object > INSTANCE = new OperatorTakeLastOne < Object > ( ) ; } @SuppressWarnings ( <str> ) public static < T > OperatorTakeLastOne < T > instance ( ) { return ( OperatorTakeLastOne < T > ) Holder . INSTANCE ; } private OperatorTakeLastOne ( ) { } @Override public Subscriber < ? super T > call ( Subscriber < ? super T > child ) { final ParentSubscriber < T > parent = new ParentSubscriber < T > ( child ) ; child . setProducer ( new Producer ( ) { @Override public void request ( long n ) { parent . requestMore ( n ) ; } } ) ; child . add ( parent ) ; return parent ; } private static class ParentSubscriber < T > extends Subscriber < T > { private final static int NOT_REQUESTED_NOT_COMPLETED = <int> ; private final static int NOT_REQUESTED_COMPLETED = <int> ; private final static int REQUESTED_NOT_COMPLETED = <int> ; private final static int REQUESTED_COMPLETED = <int> ; private static final Object ABSENT = new Object ( ) ; private final Subscriber < ? super T > child ; @SuppressWarnings ( <str> ) private T last = ( T ) ABSENT ; private final AtomicInteger state = new AtomicInteger ( NOT_REQUESTED_NOT_COMPLETED ) ; ParentSubscriber ( Subscriber < ? super T > child ) { this . child = child ; } void requestMore ( long n ) { if ( n > <int> ) { while ( true ) { final int s = state . get ( ) ; if ( s = = NOT_REQUESTED_NOT_COMPLETED ) { if ( state . compareAndSet ( NOT_REQUESTED_NOT_COMPLETED , REQUESTED_NOT_COMPLETED ) ) { return ; } } else if ( s = = NOT_REQUESTED_COMPLETED ) { if ( state . compareAndSet ( NOT_REQUESTED_COMPLETED , REQUESTED_COMPLETED ) ) { emit ( ) ; return ; } } else return ; } } } @Override public void onCompleted ( ) { if ( last = = ABSENT ) { child . onCompleted ( ) ; return ; } while ( true ) { final int s = state . get ( ) ; if ( s = = NOT_REQUESTED_NOT_COMPLETED ) { if ( state . compareAndSet ( NOT_REQUESTED_NOT_COMPLETED , NOT_REQUESTED_COMPLETED ) ) { return ; } } else if ( s = = REQUESTED_NOT_COMPLETED ) { if ( state . compareAndSet ( REQUESTED_NOT_COMPLETED , REQUESTED_COMPLETED ) ) { emit ( ) ; return ; } } else return ; } } private void emit ( ) { if ( isUnsubscribed ( ) ) { last = null ; return ; } T t = last ; last = null ; if ( t ! = ABSENT ) { try { child . onNext ( t ) ; } catch ( Throwable e ) { Exceptions . throwOrReport ( e , child ) ; return ; } } if ( ! isUnsubscribed ( ) ) child . onCompleted ( ) ; } @Override public void onError ( Throwable e ) { child . onError ( e ) ; } @Override public void onNext ( T t ) { last = t ; } } } 
