package org . apache . cassandra . serializers ; import org . apache . cassandra . utils . ByteBufferUtil ; import java . nio . ByteBuffer ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . TimeZone ; import java . util . regex . Pattern ; import org . apache . commons . lang3 . time . DateUtils ; public class TimestampSerializer implements TypeSerializer < Date > { private static final String [ ] dateStringPatterns = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static final String DEFAULT_FORMAT = dateStringPatterns [ <int> ] ; private static final Pattern timestampPattern = Pattern . compile ( <str> ) ; private static final ThreadLocal < SimpleDateFormat > FORMATTER = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( DEFAULT_FORMAT ) ; } } ; private static final String UTC_FORMAT = dateStringPatterns [ <int> ] ; private static final ThreadLocal < SimpleDateFormat > FORMATTER_UTC = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { SimpleDateFormat sdf = new SimpleDateFormat ( UTC_FORMAT ) ; sdf . setTimeZone ( TimeZone . getTimeZone ( <str> ) ) ; return sdf ; } } ; public static final SimpleDateFormat TO_JSON_FORMAT = new SimpleDateFormat ( dateStringPatterns [ <int> ] ) ; public static final TimestampSerializer instance = new TimestampSerializer ( ) ; public Date deserialize ( ByteBuffer bytes ) { return bytes . remaining ( ) = = <int> ? null : new Date ( ByteBufferUtil . toLong ( bytes ) ) ; } public ByteBuffer serialize ( Date value ) { return value = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : ByteBufferUtil . bytes ( value . getTime ( ) ) ; } public static long dateStringToTimestamp ( String source ) throws MarshalException { if ( source . equalsIgnoreCase ( <str> ) ) return System . currentTimeMillis ( ) ; if ( timestampPattern . matcher ( source ) . matches ( ) ) { try { return Long . parseLong ( source ) ; } catch ( NumberFormatException e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } } try { return DateUtils . parseDateStrictly ( source , dateStringPatterns ) . getTime ( ) ; } catch ( ParseException e1 ) { throw new MarshalException ( String . format ( <str> , source ) , e1 ) ; } } public void validate ( ByteBuffer bytes ) throws MarshalException { if ( bytes . remaining ( ) ! = <int> & & bytes . remaining ( ) ! = <int> ) throw new MarshalException ( String . format ( <str> , bytes . remaining ( ) ) ) ; } public String toString ( Date value ) { return value = = null ? <str> : FORMATTER . get ( ) . format ( value ) ; } public String toStringUTC ( Date value ) { return value = = null ? <str> : FORMATTER_UTC . get ( ) . format ( value ) ; } public Class < Date > getType ( ) { return Date . class ; } @Override public void toCQLLiteral ( ByteBuffer buffer , StringBuilder target ) { if ( buffer = = null | | ! buffer . hasRemaining ( ) ) target . append ( <str> ) ; else target . append ( FORMATTER_UTC . get ( ) . format ( deserialize ( buffer ) ) ) ; } } 
