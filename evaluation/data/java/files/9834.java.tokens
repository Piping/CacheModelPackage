package com . badlogic . gdx . graphics . g3d . decals ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . SortedIntList ; public class DecalBatch implements Disposable { private static final int DEFAULT_SIZE = <int> ; private float [ ] vertices ; private Mesh mesh ; private final SortedIntList < Array < Decal > > groupList = new SortedIntList < Array < Decal > > ( ) ; private GroupStrategy groupStrategy ; private final Pool < Array < Decal > > groupPool = new Pool < Array < Decal > > ( <int> ) { @Override protected Array < Decal > newObject ( ) { return new Array < Decal > ( false , <int> ) ; } } ; private final Array < Array < Decal > > usedGroups = new Array < Array < Decal > > ( <int> ) ; public DecalBatch ( GroupStrategy groupStrategy ) { this ( DEFAULT_SIZE , groupStrategy ) ; } public DecalBatch ( int size , GroupStrategy groupStrategy ) { initialize ( size ) ; setGroupStrategy ( groupStrategy ) ; } public void setGroupStrategy ( GroupStrategy groupStrategy ) { this . groupStrategy = groupStrategy ; } public void initialize ( int size ) { vertices = new float [ size * Decal . SIZE ] ; Mesh . VertexDataType vertexDataType = Mesh . VertexDataType . VertexArray ; if ( Gdx . gl30 ! = null ) { vertexDataType = Mesh . VertexDataType . VertexBufferObjectWithVAO ; } mesh = new Mesh ( vertexDataType , false , size * <int> , size * <int> , new VertexAttribute ( VertexAttributes . Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( VertexAttributes . Usage . ColorPacked , <int> , ShaderProgram . COLOR_ATTRIBUTE ) , new VertexAttribute ( VertexAttributes . Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) ) ; short [ ] indices = new short [ size * <int> ] ; int v = <int> ; for ( int i = <int> ; i < indices . length ; i + = <int> , v + = <int> ) { indices [ i ] = ( short ) ( v ) ; indices [ i + <int> ] = ( short ) ( v + <int> ) ; indices [ i + <int> ] = ( short ) ( v + <int> ) ; indices [ i + <int> ] = ( short ) ( v + <int> ) ; indices [ i + <int> ] = ( short ) ( v + <int> ) ; indices [ i + <int> ] = ( short ) ( v + <int> ) ; } mesh . setIndices ( indices ) ; } public int getSize ( ) { return vertices . length / Decal . SIZE ; } public void add ( Decal decal ) { int groupIndex = groupStrategy . decideGroup ( decal ) ; Array < Decal > targetGroup = groupList . get ( groupIndex ) ; if ( targetGroup = = null ) { targetGroup = groupPool . obtain ( ) ; targetGroup . clear ( ) ; usedGroups . add ( targetGroup ) ; groupList . insert ( groupIndex , targetGroup ) ; } targetGroup . add ( decal ) ; } public void flush ( ) { render ( ) ; clear ( ) ; } protected void render ( ) { groupStrategy . beforeGroups ( ) ; for ( SortedIntList . Node < Array < Decal > > group : groupList ) { groupStrategy . beforeGroup ( group . index , group . value ) ; ShaderProgram shader = groupStrategy . getGroupShader ( group . index ) ; render ( shader , group . value ) ; groupStrategy . afterGroup ( group . index ) ; } groupStrategy . afterGroups ( ) ; } private void render ( ShaderProgram shader , Array < Decal > decals ) { DecalMaterial lastMaterial = null ; int idx = <int> ; for ( Decal decal : decals ) { if ( lastMaterial = = null | | ! lastMaterial . equals ( decal . getMaterial ( ) ) ) { if ( idx > <int> ) { flush ( shader , idx ) ; idx = <int> ; } decal . material . set ( ) ; lastMaterial = decal . material ; } decal . update ( ) ; System . arraycopy ( decal . vertices , <int> , vertices , idx , decal . vertices . length ) ; idx + = decal . vertices . length ; if ( idx = = vertices . length ) { flush ( shader , idx ) ; idx = <int> ; } } if ( idx > <int> ) { flush ( shader , idx ) ; } } protected void flush ( ShaderProgram shader , int verticesPosition ) { mesh . setVertices ( vertices , <int> , verticesPosition ) ; mesh . render ( shader , GL20 . GL_TRIANGLES , <int> , verticesPosition / <int> ) ; } protected void clear ( ) { groupList . clear ( ) ; groupPool . freeAll ( usedGroups ) ; usedGroups . clear ( ) ; } public void dispose ( ) { clear ( ) ; vertices = null ; mesh . dispose ( ) ; } }