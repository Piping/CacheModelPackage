package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . ImmediateEventExecutor ; import org . junit . Before ; import org . junit . Test ; import org . mockito . MockitoAnnotations ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class CoalescingBufferQueueTest { private ByteBuf cat ; private ByteBuf mouse ; private ChannelPromise catPromise , emptyPromise ; private ChannelPromise voidPromise ; private ChannelFutureListener mouseListener ; private boolean mouseDone ; private boolean mouseSuccess ; private Channel channel = new EmbeddedChannel ( ) ; private CoalescingBufferQueue writeQueue = new CoalescingBufferQueue ( channel ) ; @Before public void setup ( ) { MockitoAnnotations . initMocks ( this ) ; catPromise = newPromise ( ) ; mouseListener = new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { mouseDone = true ; mouseSuccess = future . isSuccess ( ) ; } } ; emptyPromise = newPromise ( ) ; voidPromise = channel . voidPromise ( ) ; cat = Unpooled . wrappedBuffer ( <str> . getBytes ( CharsetUtil . US_ASCII ) ) ; mouse = Unpooled . wrappedBuffer ( <str> . getBytes ( CharsetUtil . US_ASCII ) ) ; } @Test public void testAggregateWithFullRead ( ) { writeQueue . add ( cat , catPromise ) ; assertQueueSize ( <int> , false ) ; writeQueue . add ( mouse , mouseListener ) ; assertQueueSize ( <int> , false ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( <int> , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; assertFalse ( catPromise . isSuccess ( ) ) ; assertFalse ( mouseDone ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( catPromise . isSuccess ( ) ) ; assertTrue ( mouseSuccess ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; } @Test public void testWithVoidPromise ( ) { writeQueue . add ( cat , voidPromise ) ; writeQueue . add ( mouse , voidPromise ) ; assertQueueSize ( <int> , false ) ; assertEquals ( <str> , dequeue ( <int> , newPromise ( ) ) ) ; assertQueueSize ( <int> , false ) ; assertEquals ( <str> , dequeue ( <int> , newPromise ( ) ) ) ; assertQueueSize ( <int> , true ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; } @Test public void testAggregateWithPartialRead ( ) { writeQueue . add ( cat , catPromise ) ; writeQueue . add ( mouse , mouseListener ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( <int> , aggregatePromise ) ) ; assertQueueSize ( <int> , false ) ; assertFalse ( catPromise . isSuccess ( ) ) ; assertFalse ( mouseDone ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( catPromise . isSuccess ( ) ) ; assertFalse ( mouseDone ) ; aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( Integer . MAX_VALUE , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; assertFalse ( mouseDone ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( mouseSuccess ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; } @Test public void testReadExactAddedBufferSizeReturnsOriginal ( ) { writeQueue . add ( cat , catPromise ) ; writeQueue . add ( mouse , mouseListener ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertSame ( cat , writeQueue . remove ( <int> , aggregatePromise ) ) ; assertFalse ( catPromise . isSuccess ( ) ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( catPromise . isSuccess ( ) ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; cat . release ( ) ; aggregatePromise = newPromise ( ) ; assertSame ( mouse , writeQueue . remove ( <int> , aggregatePromise ) ) ; assertFalse ( mouseDone ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( mouseSuccess ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; mouse . release ( ) ; } @Test public void testReadEmptyQueueReturnsEmptyBuffer ( ) { cat . release ( ) ; mouse . release ( ) ; assertQueueSize ( <int> , true ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( Integer . MAX_VALUE , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; } @Test public void testReleaseAndFailAll ( ) { writeQueue . add ( cat , catPromise ) ; writeQueue . add ( mouse , mouseListener ) ; RuntimeException cause = new RuntimeException ( <str> ) ; writeQueue . releaseAndFailAll ( cause ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertQueueSize ( <int> , true ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; assertSame ( cause , catPromise . cause ( ) ) ; assertEquals ( <str> , dequeue ( Integer . MAX_VALUE , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; } @Test public void testEmptyBuffersAreCoalesced ( ) { ByteBuf empty = Unpooled . buffer ( <int> , <int> ) ; assertQueueSize ( <int> , true ) ; writeQueue . add ( cat , catPromise ) ; writeQueue . add ( empty , emptyPromise ) ; assertQueueSize ( <int> , false ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( <int> , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; assertFalse ( catPromise . isSuccess ( ) ) ; assertFalse ( emptyPromise . isSuccess ( ) ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( catPromise . isSuccess ( ) ) ; assertTrue ( emptyPromise . isSuccess ( ) ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , empty . refCnt ( ) ) ; } @Test public void testMerge ( ) { writeQueue . add ( cat , catPromise ) ; CoalescingBufferQueue otherQueue = new CoalescingBufferQueue ( channel ) ; otherQueue . add ( mouse , mouseListener ) ; otherQueue . copyTo ( writeQueue ) ; assertQueueSize ( <int> , false ) ; DefaultChannelPromise aggregatePromise = newPromise ( ) ; assertEquals ( <str> , dequeue ( <int> , aggregatePromise ) ) ; assertQueueSize ( <int> , true ) ; assertFalse ( catPromise . isSuccess ( ) ) ; assertFalse ( mouseDone ) ; aggregatePromise . setSuccess ( ) ; assertTrue ( catPromise . isSuccess ( ) ) ; assertTrue ( mouseSuccess ) ; assertEquals ( <int> , cat . refCnt ( ) ) ; assertEquals ( <int> , mouse . refCnt ( ) ) ; } private DefaultChannelPromise newPromise ( ) { return new DefaultChannelPromise ( channel , ImmediateEventExecutor . INSTANCE ) ; } private void assertQueueSize ( int size , boolean isEmpty ) { assertEquals ( size , writeQueue . readableBytes ( ) ) ; if ( isEmpty ) { assertTrue ( writeQueue . isEmpty ( ) ) ; } else { assertFalse ( writeQueue . isEmpty ( ) ) ; } } private String dequeue ( int numBytes , ChannelPromise aggregatePromise ) { ByteBuf removed = writeQueue . remove ( numBytes , aggregatePromise ) ; String result = removed . toString ( CharsetUtil . US_ASCII ) ; ReferenceCountUtil . safeRelease ( removed ) ; return result ; } } 
