} catch ( UnsupportedOperationException expected ) { } Set < Map . Entry < Number , String > > entries = unmod . entrySet ( ) ; Map . Entry < Number , String > entry = entries . iterator ( ) . next ( ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } @SuppressWarnings ( <str> ) Map . Entry < Integer , String > entry2 = ( Map . Entry < Integer , String > ) entries . toArray ( ) [ <int> ] ; try { entry2 . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } public void testImmutableEntry ( ) { Map . Entry < String , Integer > e = Maps . immutableEntry ( <str> , <int> ) ; assertEquals ( <str> , e . getKey ( ) ) ; assertEquals ( <int> , ( int ) e . getValue ( ) ) ; try { e . setValue ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertEquals ( <str> , e . toString ( ) ) ; assertEquals ( <int> , e . hashCode ( ) ) ; } public void testImmutableEntryNull ( ) { Map . Entry < String , Integer > e = Maps . immutableEntry ( ( String ) null , ( Integer ) null ) ; assertNull ( e . getKey ( ) ) ; assertNull ( e . getValue ( ) ) ; try { e . setValue ( null ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertEquals ( <str> , e . toString ( ) ) ; assertEquals ( <int> , e . hashCode ( ) ) ; } public void testSynchronizedBiMap ( ) { BiMap < String , Integer > bimap = HashBiMap . create ( ) ; bimap . put ( <str> , <int> ) ; BiMap < String , Integer > sync = Maps . synchronizedBiMap ( bimap ) ; bimap . put ( <str> , <int> ) ; sync . put ( <str> , <int> ) ; assertEquals ( ImmutableSet . of ( <int> , <int> , <int> ) , bimap . inverse ( ) . keySet ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> , <int> ) , sync . inverse ( ) . keySet ( ) ) ; } private static final Predicate < String > NOT_LENGTH_3 = new Predicate < String > ( ) { @Override public boolean apply ( String input ) { return input = = null | | input . length ( ) ! = <int> ; } } ; private static final Predicate < Integer > EVEN = new Predicate < Integer > ( ) { @Override public boolean apply ( Integer input ) { return input = = null | | input % <int> = = <int> ; } } ; private static final Predicate < Entry < String , Integer > > CORRECT_LENGTH = new Predicate < Entry < String , Integer > > ( ) { @Override public boolean apply ( Entry < String , Integer > input ) { return input . getKey ( ) . length ( ) = = input . getValue ( ) ; } } ; private static final Function < Integer , Double > SQRT_FUNCTION = new Function < Integer , Double > ( ) { @Override public Double apply ( Integer in ) { return Math . sqrt ( in ) ; } } ; public static class FilteredMapTest extends TestCase { Map < String , Integer > createUnfiltered ( ) { return Maps . newHashMap ( ) ; } public void testFilteredKeysIllegalPut ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterKeys ( unfiltered , NOT_LENGTH_3 ) ; filtered . put ( <str> , <int> ) ; filtered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . put ( <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testFilteredKeysIllegalPutAll ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterKeys ( unfiltered , NOT_LENGTH_3 ) ; filtered . put ( <str> , <int> ) ; filtered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . putAll ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredKeysFilteredReflectsBackingChanges ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterKeys ( unfiltered , NOT_LENGTH_3 ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , unfiltered ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; unfiltered . remove ( <str> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , unfiltered ) ; assertEquals ( ImmutableMap . of ( <str> , <int> ) , filtered ) ; unfiltered . clear ( ) ; assertEquals ( ImmutableMap . of ( ) , unfiltered ) ; assertEquals ( ImmutableMap . of ( ) , filtered ) ; } public void testFilteredValuesIllegalPut ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterValues ( unfiltered , EVEN ) ; filtered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . put ( <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredValuesIllegalPutAll ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterValues ( unfiltered , EVEN ) ; filtered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . putAll ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredValuesIllegalSetValue ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; Map < String , Integer > filtered = Maps . filterValues ( unfiltered , EVEN ) ; filtered . put ( <str> , <int> ) ; filtered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; Entry < String , Integer > entry = filtered . entrySet ( ) . iterator ( ) . next ( ) ; try { entry . setValue ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredValuesClear ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; Map < String , Integer > filtered = Maps . filterValues ( unfiltered , EVEN ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , unfiltered ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; filtered . clear ( ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , unfiltered ) ; assertTrue ( filtered . isEmpty ( ) ) ; } public void testFilteredEntriesIllegalPut ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; Map < String , Integer > filtered = Maps . filterEntries ( unfiltered , CORRECT_LENGTH ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; filtered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . put ( <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredEntriesIllegalPutAll ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; Map < String , Integer > filtered = Maps . filterEntries ( unfiltered , CORRECT_LENGTH ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; filtered . put ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , filtered ) ; try { filtered . putAll ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , filtered ) ; } public void testFilteredEntriesObjectPredicate ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; Predicate < Object > predicate = Predicates . alwaysFalse ( ) ; Map < String , Integer > filtered = Maps . filterEntries ( unfiltered , predicate ) ; assertTrue ( filtered . isEmpty ( ) ) ; } public void testFilteredEntriesWildCardEntryPredicate ( ) { Map < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; Predicate < Entry < ? , ? > > predicate = new Predicate < Entry < ? , ? > > ( ) { @Override public boolean apply ( Entry < ? , ? > input ) { return <str> . equals ( input . getKey ( ) ) | | Integer . valueOf ( <int> ) = = input . getValue ( ) ; } } ; Map < String , Integer > filtered = Maps . filterEntries ( unfiltered , predicate ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered ) ; } } public static class FilteredSortedMapTest extends FilteredMapTest { @Override SortedMap < String , Integer > createUnfiltered ( ) { return Maps . newTreeMap ( ) ; } public void testFilterKeysIdentifiesSortedMap ( ) { SortedMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterKeys ( ( Map < String , Integer > ) map , NOT_LENGTH_3 ) instanceof SortedMap ) ; } public void testFilterValuesIdentifiesSortedMap ( ) { SortedMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterValues ( ( Map < String , Integer > ) map , EVEN ) instanceof SortedMap ) ; } public void testFilterEntriesIdentifiesSortedMap ( ) { SortedMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterEntries ( ( Map < String , Integer > ) map , CORRECT_LENGTH ) instanceof SortedMap ) ; } public void testFirstAndLastKeyFilteredMap ( ) { SortedMap < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; SortedMap < String , Integer > filtered = Maps . filterEntries ( unfiltered , CORRECT_LENGTH ) ; assertEquals ( <str> , filtered . firstKey ( ) ) ; assertEquals ( <str> , filtered . lastKey ( ) ) ; } public void testHeadSubTailMap_FilteredMap ( ) { SortedMap < String , Integer > unfiltered = createUnfiltered ( ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; unfiltered . put ( <str> , <int> ) ; SortedMap < String , Integer > filtered = Maps . filterEntries ( unfiltered , CORRECT_LENGTH ) ; assertEquals ( ImmutableMap . of ( <str> , <int> ) , filtered . headMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( ) , filtered . headMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered . headMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , <int> ) , filtered . subMap ( <str> , <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , <int> ) , filtered . subMap ( <str> , <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , <int> ) , filtered . tailMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , filtered . tailMap ( <str> ) ) ; } } public static class FilteredBiMapTest extends FilteredMapTest { @Override BiMap < String , Integer > createUnfiltered ( ) { return HashBiMap . create ( ) ; } public void testFilterKeysIdentifiesBiMap ( ) { BiMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterKeys ( ( Map < String , Integer > ) map , NOT_LENGTH_3 ) instanceof BiMap ) ; } public void testFilterValuesIdentifiesBiMap ( ) { BiMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterValues ( ( Map < String , Integer > ) map , EVEN ) instanceof BiMap ) ; } public void testFilterEntriesIdentifiesBiMap ( ) { BiMap < String , Integer > map = createUnfiltered ( ) ; assertTrue ( Maps . filterEntries ( ( Map < String , Integer > ) map , CORRECT_LENGTH ) instanceof BiMap ) ; } } public void testTransformValues ( ) { Map < String , Integer > map = ImmutableMap . of ( <str> , <int> , <str> , <int> ) ; Map < String , Double > transformed = transformValues ( map , SQRT_FUNCTION ) ; assertEquals ( ImmutableMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; } public void testTransformValuesSecretlySorted ( ) { Map < String , Integer > map = sortedNotNavigable ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ) ; Map < String , Double > transformed = transformValues ( map , SQRT_FUNCTION ) ; assertEquals ( ImmutableMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; assertTrue ( transformed instanceof SortedMap ) ; } @GwtIncompatible ( <str> ) public void testTransformValuesSecretlyNavigable ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ; Map < String , Double > transformed ; transformed = transformValues ( map , SQRT_FUNCTION ) ; assertEquals ( ImmutableMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; assertTrue ( transformed instanceof NavigableMap ) ; transformed = transformValues ( ( SortedMap < String , Integer > ) map , SQRT_FUNCTION ) ; assertEquals ( ImmutableMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; assertTrue ( transformed instanceof NavigableMap ) ; } public void testTransformEntries ( ) { Map < String , String > map = ImmutableMap . of ( <str> , <str> , <str> , <str> ) ; EntryTransformer < String , String , String > concat = new EntryTransformer < String , String , String > ( ) { @Override public String transformEntry ( String key , String value ) { return key + value ; } } ; Map < String , String > transformed = transformEntries ( map , concat ) ; assertEquals ( ImmutableMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; } public void testTransformEntriesSecretlySorted ( ) { Map < String , String > map = ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) ; EntryTransformer < String , String , String > concat = new EntryTransformer < String , String , String > ( ) { @Override public String transformEntry ( String key , String value ) { return key + value ; } } ; Map < String , String > transformed = transformEntries ( map , concat ) ; assertEquals ( ImmutableMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; assertTrue ( transformed instanceof SortedMap ) ; } @GwtIncompatible ( <str> ) public void testTransformEntriesSecretlyNavigable ( ) { Map < String , String > map = ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) ; EntryTransformer < String , String , String > concat = new EntryTransformer < String , String , String > ( ) { @Override public String transformEntry ( String key , String value ) { return key + value ; } } ; Map < String , String > transformed ; transformed = transformEntries ( map , concat ) ; assertEquals ( ImmutableMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; assertTrue ( transformed instanceof NavigableMap ) ; transformed = transformEntries ( ( SortedMap < String , String > ) map , concat ) ; assertEquals ( ImmutableMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; assertTrue ( transformed instanceof NavigableMap ) ; } @SuppressWarnings ( <str> ) public void testTransformEntriesGenerics ( ) { Map < Object , Object > map1 = ImmutableMap . < Object , Object > of ( <int> , <int> ) ; Map < Object , Number > map2 = ImmutableMap . < Object , Number > of ( <int> , <int> ) ; Map < Object , Integer > map3 = ImmutableMap . < Object , Integer > of ( <int> , <int> ) ; Map < Number , Object > map4 = ImmutableMap . < Number , Object > of ( <int> , <int> ) ; Map < Number , Number > map5 = ImmutableMap . < Number , Number > of ( <int> , <int> ) ; Map < Number , Integer > map6 = ImmutableMap . < Number , Integer > of ( <int> , <int> ) ; Map < Integer , Object > map7 = ImmutableMap . < Integer , Object > of ( <int> , <int> ) ; Map < Integer , Number > map8 = ImmutableMap . < Integer , Number > of ( <int> , <int> ) ; Map < Integer , Integer > map9 = ImmutableMap . < Integer , Integer > of ( <int> , <int> ) ; Map < ? extends Number , ? extends Number > map0 = ImmutableMap . of ( <int> , <int> ) ; EntryTransformer < Number , Number , Double > transformer = new EntryTransformer < Number , Number , Double > ( ) { @Override public Double transformEntry ( Number key , Number value ) { return key . doubleValue ( ) + value . doubleValue ( ) ; } } ; Map < Object , Double > objectKeyed ; Map < Number , Double > numberKeyed ; Map < Integer , Double > integerKeyed ; numberKeyed = transformEntries ( map5 , transformer ) ; numberKeyed = transformEntries ( map6 , transformer ) ; integerKeyed = transformEntries ( map8 , transformer ) ; integerKeyed = transformEntries ( map9 , transformer ) ; Map < ? extends Number , Double > wildcarded = transformEntries ( map0 , transformer ) ; } public void testTransformEntriesExample ( ) { Map < String , Boolean > options = ImmutableMap . of ( <str> , true , <str> , false ) ; EntryTransformer < String , Boolean , String > flagPrefixer = new EntryTransformer < String , Boolean , String > ( ) { @Override public String transformEntry ( String key , Boolean value ) { return value ? key : <str> + key ; } } ; Map < String , String > transformed = transformEntries ( options , flagPrefixer ) ; assertEquals ( <str> , transformed . toString ( ) ) ; } private static < K , V > SortedMap < K , V > sortedNotNavigable ( final SortedMap < K , V > map ) { return new ForwardingSortedMap < K , V > ( ) { @Override protected SortedMap < K , V > delegate ( ) { return map ; } } ; } public void testSortedMapTransformValues ( ) { SortedMap < String , Integer > map = sortedNotNavigable ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ) ; SortedMap < String , Double > transformed = transformValues ( map , SQRT_FUNCTION ) ; assertEquals ( ImmutableSortedMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; } @GwtIncompatible ( <str> ) public void testNavigableMapTransformValues ( ) { NavigableMap < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ; NavigableMap < String , Double > transformed = transformValues ( map , SQRT_FUNCTION ) ; assertEquals ( ImmutableSortedMap . of ( <str> , <float> , <str> , <float> ) , transformed ) ; } public void testSortedMapTransformEntries ( ) { SortedMap < String , String > map = sortedNotNavigable ( ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) ) ; EntryTransformer < String , String , String > concat = new EntryTransformer < String , String , String > ( ) { @Override public String transformEntry ( String key , String value ) { return key + value ; } } ; SortedMap < String , String > transformed = transformEntries ( map , concat ) ; assertEquals ( ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; } @GwtIncompatible ( <str> ) public void testNavigableMapTransformEntries ( ) { NavigableMap < String , String > map = ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) ; EntryTransformer < String , String , String > concat = new EntryTransformer < String , String , String > ( ) { @Override public String transformEntry ( String key , String value ) { return key + value ; } } ; NavigableMap < String , String > transformed = transformEntries ( map , concat ) ; assertEquals ( ImmutableSortedMap . of ( <str> , <str> , <str> , <str> ) , transformed ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableNavigableMap ( ) { TreeMap < Integer , String > mod = Maps . newTreeMap ( ) ; mod . put ( <int> , <str> ) ; mod . put ( <int> , <str> ) ; mod . put ( <int> , <str> ) ; NavigableMap < Integer , String > unmod = unmodifiableNavigableMap ( mod ) ; mod . put ( <int> , <str> ) ; assertEquals ( <str> , unmod . get ( <int> ) ) ; assertEquals ( <str> , unmod . descendingMap ( ) . get ( <int> ) ) ; ensureNotDirectlyModifiable ( unmod ) ; ensureNotDirectlyModifiable ( unmod . descendingMap ( ) ) ; ensureNotDirectlyModifiable ( unmod . headMap ( <int> , true ) ) ; ensureNotDirectlyModifiable ( unmod . subMap ( <int> , true , <int> , true ) ) ; ensureNotDirectlyModifiable ( unmod . tailMap ( <int> , true ) ) ; Collection < String > values = unmod . values ( ) ; try { values . add ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { values . remove ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { values . removeAll ( Collections . singleton ( <str> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { values . retainAll ( Collections . singleton ( <str> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { Iterator < String > iterator = values . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } Set < Map . Entry < Integer , String > > entries = unmod . entrySet ( ) ; try { Iterator < Map . Entry < Integer , String > > iterator = entries . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } Map . Entry < Integer , String > entry = entries . iterator ( ) . next ( ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . lowerEntry ( <int> ) ; assertNull ( entry ) ; entry = unmod . floorEntry ( <int> ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . ceilingEntry ( <int> ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . lowerEntry ( <int> ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . higherEntry ( <int> ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . firstEntry ( ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = unmod . lastEntry ( ) ; try { entry . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } @SuppressWarnings ( <str> ) Map . Entry < Integer , String > entry2 = ( Map . Entry < Integer , String > ) entries . toArray ( ) [ <int> ] ; try { entry2 . setValue ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) void ensureNotDirectlyModifiable ( NavigableMap < Integer , String > unmod ) { try { unmod . put ( <int> , <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . putAll ( Collections . singletonMap ( <int> , <str> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . remove ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . pollFirstEntry ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . pollLastEntry ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testSubMap_boundedRange ( ) { ImmutableSortedMap < Integer , Integer > map = ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedMap < Integer , Integer > empty = ImmutableSortedMap . of ( ) ; assertEquals ( map , Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> ) , Maps . subMap ( map , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> ) , Maps . subMap ( map , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . open ( <int> , <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . open ( <int> , <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> ) , Maps . subMap ( map , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . closedOpen ( <int> , <int> ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubMap_halfBoundedRange ( ) { ImmutableSortedMap < Integer , Integer > map = ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedMap < Integer , Integer > empty = ImmutableSortedMap . of ( ) ; assertEquals ( map , Maps . subMap ( map , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atLeast ( <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . atLeast ( <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . greaterThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . greaterThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . greaterThan ( <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . greaterThan ( <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . lessThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> ) , Maps . subMap ( map , Range . lessThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . lessThan ( <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . lessThan ( <int> ) ) ) ; assertEquals ( empty , Maps . subMap ( map , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atMost ( <int> ) ) ) ; assertEquals ( map , Maps . subMap ( map , Range . atMost ( <int> ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubMap_unboundedRange ( ) { ImmutableSortedMap < Integer , Integer > map = ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( map , Maps . subMap ( map , Range . < Integer > all ( ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubMap_unnaturalOrdering ( ) { ImmutableSortedMap < Integer , Integer > map = ImmutableSortedMap . < Integer , Integer > reverseOrder ( ) . put ( <int> , <int> ) . put ( <int> , <int> ) . put ( <int> , <int> ) . put ( <int> , <int> ) . put ( <int> , <int> ) . build ( ) ; try { Maps . subMap ( map , Range . closed ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , Maps . subMap ( map , Range . < Integer > all ( ) ) ) ; } } 
