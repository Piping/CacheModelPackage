package org . elasticsearch . test . rest . json ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . test . rest . Stash ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class JsonPath { final String json ; final Map < String , Object > jsonMap ; public JsonPath ( String json ) throws IOException { this . json = json ; this . jsonMap = convertToMap ( json ) ; } private static Map < String , Object > convertToMap ( String json ) throws IOException { try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( json ) ) { return parser . mapOrdered ( ) ; } } public Object evaluate ( String path ) { return evaluate ( path , Stash . EMPTY ) ; } public Object evaluate ( String path , Stash stash ) { String [ ] parts = parsePath ( path ) ; Object object = jsonMap ; for ( String part : parts ) { object = evaluate ( part , object , stash ) ; if ( object = = null ) { return null ; } } return object ; } @SuppressWarnings ( <str> ) private Object evaluate ( String key , Object object , Stash stash ) { if ( stash . isStashedValue ( key ) ) { key = stash . unstashValue ( key ) . toString ( ) ; } if ( object instanceof Map ) { return ( ( Map < String , Object > ) object ) . get ( key ) ; } if ( object instanceof List ) { List < Object > list = ( List < Object > ) object ; try { return list . get ( Integer . valueOf ( key ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + key + <str> , e ) ; } catch ( IndexOutOfBoundsException e ) { throw new IllegalArgumentException ( <str> + list . size ( ) + <str> + key + <str> , e ) ; } } throw new IllegalArgumentException ( <str> + key + <str> + object . getClass ( ) + <str> ) ; } private String [ ] parsePath ( String path ) { List < String > list = new ArrayList < > ( ) ; StringBuilder current = new StringBuilder ( ) ; boolean escape = false ; for ( int i = <int> ; i < path . length ( ) ; i + + ) { char c = path . charAt ( i ) ; if ( c = = <str> ) { escape = true ; continue ; } if ( c = = <str> ) { if ( escape ) { escape = false ; } else { if ( current . length ( ) > <int> ) { list . add ( current . toString ( ) ) ; current . setLength ( <int> ) ; } continue ; } } current . append ( c ) ; } if ( current . length ( ) > <int> ) { list . add ( current . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } } 
