package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . Iterators ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public abstract class Slices implements Iterable < Slice > { public static final Serializer serializer = new Serializer ( ) ; public static final Slices ALL = new SelectAllSlices ( ) ; public static final Slices NONE = new SelectNoSlices ( ) ; protected Slices ( ) { } public static Slices with ( ClusteringComparator comparator , Slice slice ) { if ( slice . start ( ) = = Slice . Bound . BOTTOM & & slice . end ( ) = = Slice . Bound . TOP ) return Slices . ALL ; assert comparator . compare ( slice . start ( ) , slice . end ( ) ) < = <int> ; return new ArrayBackedSlices ( comparator , new Slice [ ] { slice } ) ; } public abstract boolean hasLowerBound ( ) ; public abstract boolean hasUpperBound ( ) ; public abstract int size ( ) ; public abstract Slice get ( int i ) ; public abstract Slices forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive , boolean reversed ) ; public abstract InOrderTester inOrderTester ( boolean reversed ) ; public abstract boolean selects ( Clustering clustering ) ; public abstract boolean intersects ( List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) ; public abstract UnfilteredRowIterator makeSliceIterator ( SliceableUnfilteredRowIterator iter ) ; public abstract String toCQLString ( CFMetaData metadata ) ; public final boolean isEmpty ( ) { return size ( ) = = <int> ; } public interface InOrderTester { public boolean includes ( Clustering value ) ; public boolean isDone ( ) ; } public static class Builder { private final ClusteringComparator comparator ; private final List < Slice > slices ; private boolean needsNormalizing ; public Builder ( ClusteringComparator comparator ) { this . comparator = comparator ; this . slices = new ArrayList < > ( ) ; } public Builder ( ClusteringComparator comparator , int initialSize ) { this . comparator = comparator ; this . slices = new ArrayList < > ( initialSize ) ; } public Builder add ( Slice . Bound start , Slice . Bound end ) { return add ( Slice . make ( start , end ) ) ; } public Builder add ( Slice slice ) { assert comparator . compare ( slice . start ( ) , slice . end ( ) ) < = <int> ; if ( slices . size ( ) > <int> & & comparator . compare ( slices . get ( slices . size ( ) - <int> ) . end ( ) , slice . start ( ) ) > <int> ) needsNormalizing = true ; slices . add ( slice ) ; return this ; } public int size ( ) { return slices . size ( ) ; } public Slices build ( ) { if ( slices . isEmpty ( ) ) return NONE ; if ( slices . size ( ) = = <int> & & slices . get ( <int> ) = = Slice . ALL ) return ALL ; List < Slice > normalized = needsNormalizing ? normalize ( slices ) : slices ; return new ArrayBackedSlices ( comparator , normalized . toArray ( new Slice [ normalized . size ( ) ] ) ) ; } private List < Slice > normalize ( List < Slice > slices ) { if ( slices . size ( ) < = <int> ) return slices ; Collections . sort ( slices , new Comparator < Slice > ( ) { @Override public int compare ( Slice s1 , Slice s2 ) { int c = comparator . compare ( s1 . start ( ) , s2 . start ( ) ) ; if ( c ! = <int> ) return c ; return comparator . compare ( s1 . end ( ) , s2 . end ( ) ) ; } } ) ; List < Slice > slicesCopy = new ArrayList < > ( slices . size ( ) ) ; Slice last = slices . get ( <int> ) ; for ( int i = <int> ; i < slices . size ( ) ; i + + ) { Slice s2 = slices . get ( i ) ; boolean includesStart = last . includes ( comparator , s2 . start ( ) ) ; boolean includesFinish = last . includes ( comparator , s2 . end ( ) ) ; if ( includesStart & & includesFinish ) continue ; if ( ! includesStart & & ! includesFinish ) { slicesCopy . add ( last ) ; last = s2 ; continue ; } if ( includesStart ) { last = Slice . make ( last . start ( ) , s2 . end ( ) ) ; continue ; } assert ! includesFinish ; } slicesCopy . add ( last ) ; return slicesCopy ; } } public static class Serializer { public void serialize ( Slices slices , DataOutputPlus out , int version ) throws IOException { int size = slices . size ( ) ; out . writeUnsignedVInt ( size ) ; if ( size = = <int> ) return ; List < AbstractType < ? > > types = slices = = ALL ? Collections . < AbstractType < ? > > emptyList ( ) : ( ( ArrayBackedSlices ) slices ) . comparator . subtypes ( ) ; for ( Slice slice : slices ) Slice . serializer . serialize ( slice , out , version , types ) ; } public long serializedSize ( Slices slices , int version ) { long size = TypeSizes . sizeofUnsignedVInt ( slices . size ( ) ) ; if ( slices . size ( ) = = <int> ) return size ; List < AbstractType < ? > > types = slices instanceof SelectAllSlices ? Collections . < AbstractType < ? > > emptyList ( ) : ( ( ArrayBackedSlices ) slices ) . comparator . subtypes ( ) ; for ( Slice slice : slices ) size + = Slice . serializer . serializedSize ( slice , version , types ) ; return size ; } public Slices deserialize ( DataInputPlus in , int version , CFMetaData metadata ) throws IOException { int size = ( int ) in . readUnsignedVInt ( ) ; if ( size = = <int> ) return NONE ; Slice [ ] slices = new Slice [ size ] ; for ( int i = <int> ; i < size ; i + + ) slices [ i ] = Slice . serializer . deserialize ( in , version , metadata . comparator . subtypes ( ) ) ; if ( size = = <int> & & slices [ <int> ] . start ( ) = = Slice . Bound . BOTTOM & & slices [ <int> ] . end ( ) = = Slice . Bound . TOP ) return ALL ; return new ArrayBackedSlices ( metadata . comparator , slices ) ; } } private static class ArrayBackedSlices extends Slices { private final ClusteringComparator comparator ; private final Slice [ ] slices ; private ArrayBackedSlices ( ClusteringComparator comparator , Slice [ ] slices ) { this . comparator = comparator ; this . slices = slices ; } public int size ( ) { return slices . length ; } public boolean hasLowerBound ( ) { return slices [ <int> ] . start ( ) . size ( ) ! = <int> ; } public boolean hasUpperBound ( ) { return slices [ slices . length - <int> ] . end ( ) . size ( ) ! = <int> ; } public Slice get ( int i ) { return slices [ i ] ; } public boolean selects ( Clustering clustering ) { for ( int i = <int> ; i < slices . length ; i + + ) { Slice slice = slices [ i ] ; if ( comparator . compare ( clustering , slice . start ( ) ) < <int> ) return false ; if ( comparator . compare ( clustering , slice . end ( ) ) < = <int> ) return true ; } return false ; } public InOrderTester inOrderTester ( boolean reversed ) { return reversed ? new InReverseOrderTester ( ) : new InForwardOrderTester ( ) ; } public Slices forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive , boolean reversed ) { return reversed ? forReversePaging ( comparator , lastReturned , inclusive ) : forForwardPaging ( comparator , lastReturned , inclusive ) ; } private Slices forForwardPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive ) { for ( int i = <int> ; i < slices . length ; i + + ) { Slice slice = slices [ i ] ; Slice newSlice = slice . forPaging ( comparator , lastReturned , inclusive , false ) ; if ( newSlice = = null ) continue ; if ( slice = = newSlice & & i = = <int> ) return this ; ArrayBackedSlices newSlices = new ArrayBackedSlices ( comparator , Arrays . copyOfRange ( slices , i , slices . length ) ) ; newSlices . slices [ <int> ] = newSlice ; return newSlices ; } return Slices . NONE ; } private Slices forReversePaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive ) { for ( int i = slices . length - <int> ; i > = <int> ; i - - ) { Slice slice = slices [ i ] ; Slice newSlice = slice . forPaging ( comparator , lastReturned , inclusive , true ) ; if ( newSlice = = null ) continue ; if ( slice = = newSlice & & i = = slices . length - <int> ) return this ; ArrayBackedSlices newSlices = new ArrayBackedSlices ( comparator , Arrays . copyOfRange ( slices , <int> , i + <int> ) ) ; newSlices . slices [ i ] = newSlice ; return newSlices ; } return Slices . NONE ; } public boolean intersects ( List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) { for ( Slice slice : this ) { if ( slice . intersects ( comparator , minClusteringValues , maxClusteringValues ) ) return true ; } return false ; } public UnfilteredRowIterator makeSliceIterator ( final SliceableUnfilteredRowIterator iter ) { return new WrappingUnfilteredRowIterator ( iter ) { private int nextSlice = iter . isReverseOrder ( ) ? slices . length - <int> : <int> ; private Iterator < Unfiltered > currentSliceIterator = Collections . emptyIterator ( ) ; private Unfiltered next ; @Override public boolean hasNext ( ) { prepareNext ( ) ; return next ! = null ; } @Override public Unfiltered next ( ) { prepareNext ( ) ; Unfiltered toReturn = next ; next = null ; return toReturn ; } private boolean hasMoreSlice ( ) { return isReverseOrder ( ) ? nextSlice > = <int> : nextSlice < slices . length ; } private Slice popNextSlice ( ) { return slices [ isReverseOrder ( ) ? nextSlice - - : nextSlice + + ] ; } private void prepareNext ( ) { if ( next ! = null ) return ; while ( true ) { if ( currentSliceIterator . hasNext ( ) ) { next = currentSliceIterator . next ( ) ; return ; } if ( ! hasMoreSlice ( ) ) return ; currentSliceIterator = iter . slice ( popNextSlice ( ) ) ; } } } ; } public Iterator < Slice > iterator ( ) { return Iterators . forArray ( slices ) ; } private class InForwardOrderTester implements InOrderTester { private int idx ; private boolean inSlice ; public boolean includes ( Clustering value ) { while ( idx < slices . length ) { if ( ! inSlice ) { int cmp = comparator . compare ( value , slices [ idx ] . start ( ) ) ; if ( cmp < <int> ) return false ; inSlice = true ; if ( cmp = = <int> ) return true ; } if ( comparator . compare ( value , slices [ idx ] . end ( ) ) < = <int> ) return true ; + + idx ; inSlice = false ; } return false ; } public boolean isDone ( ) { return idx > = slices . length ; } } private class InReverseOrderTester implements InOrderTester { private int idx ; private boolean inSlice ; public InReverseOrderTester ( ) { this . idx = slices . length - <int> ; } public boolean includes ( Clustering value ) { while ( idx > = <int> ) { if ( ! inSlice ) { int cmp = comparator . compare ( slices [ idx ] . end ( ) , value ) ; if ( cmp > <int> ) return false ; inSlice = true ; if ( cmp = = <int> ) return true ; } if ( comparator . compare ( slices [ idx ] . start ( ) , value ) < = <int> ) return true ; - - idx ; inSlice = false ; } return false ; } public boolean isDone ( ) { return idx < <int> ; } } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; for ( int i = <int> ; i < slices . length ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( slices [ i ] . toString ( comparator ) ) ; } return sb . append ( <str> ) . toString ( ) ; } public String toCQLString ( CFMetaData metadata ) { StringBuilder sb = new StringBuilder ( ) ; int clusteringSize = metadata . clusteringColumns ( ) . size ( ) ; List < List < ComponentOfSlice > > columnComponents = new ArrayList < > ( clusteringSize ) ; for ( int i = <int> ; i < clusteringSize ; i + + ) { List < ComponentOfSlice > perSlice = new ArrayList < > ( ) ; columnComponents . add ( perSlice ) ; for ( int j = <int> ; j < slices . length ; j + + ) { ComponentOfSlice c = ComponentOfSlice . fromSlice ( i , slices [ j ] ) ; if ( c ! = null ) perSlice . add ( c ) ; } } boolean needAnd = false ; for ( int i = <int> ; i < clusteringSize ; i + + ) { ColumnDefinition column = metadata . clusteringColumns ( ) . get ( i ) ; List < ComponentOfSlice > componentInfo = columnComponents . get ( i ) ; if ( componentInfo . isEmpty ( ) ) break ; ComponentOfSlice first = componentInfo . get ( <int> ) ; if ( first . isEQ ( ) ) { if ( needAnd ) sb . append ( <str> ) ; needAnd = true ; sb . append ( column . name ) ; Set < ByteBuffer > values = new LinkedHashSet < > ( ) ; for ( int j = <int> ; j < componentInfo . size ( ) ; j + + ) values . add ( componentInfo . get ( j ) . startValue ) ; if ( values . size ( ) = = <int> ) { sb . append ( <str> ) . append ( column . type . getString ( first . startValue ) ) ; } else { sb . append ( <str> ) ; int j = <int> ; for ( ByteBuffer value : values ) sb . append ( j + + = = <int> ? <str> : <str> ) . append ( column . type . getString ( value ) ) ; sb . append ( <str> ) ; } } else { if ( first . startValue ! = null ) { if ( needAnd ) sb . append ( <str> ) ; needAnd = true ; sb . append ( column . name ) . append ( first . startInclusive ? <str> : <str> ) . append ( column . type . getString ( first . startValue ) ) ; } if ( first . endValue ! = null ) { if ( needAnd ) sb . append ( <str> ) ; needAnd = true ; sb . append ( column . name ) . append ( first . endInclusive ? <str> : <str> ) . append ( column . type . getString ( first . endValue ) ) ; } } } return sb . toString ( ) ; } private static class ComponentOfSlice { public final boolean startInclusive ; public final ByteBuffer startValue ; public final boolean endInclusive ; public final ByteBuffer endValue ; private ComponentOfSlice ( boolean startInclusive , ByteBuffer startValue , boolean endInclusive , ByteBuffer endValue ) { this . startInclusive = startInclusive ; this . startValue = startValue ; this . endInclusive = endInclusive ; this . endValue = endValue ; } public static ComponentOfSlice fromSlice ( int component , Slice slice ) { Slice . Bound start = slice . start ( ) ; Slice . Bound end = slice . end ( ) ; if ( component > = start . size ( ) & & component > = end . size ( ) ) return null ; boolean startInclusive = true , endInclusive = true ; ByteBuffer startValue = null , endValue = null ; if ( component < start . size ( ) ) { startInclusive = start . isInclusive ( ) ; startValue = start . get ( component ) ; } if ( component < end . size ( ) ) { endInclusive = end . isInclusive ( ) ; endValue = end . get ( component ) ; } return new ComponentOfSlice ( startInclusive , startValue , endInclusive , endValue ) ; } public boolean isEQ ( ) { return Objects . equals ( startValue , endValue ) ; } } } private static class SelectAllSlices extends Slices { private static final InOrderTester trivialTester = new InOrderTester ( ) { public boolean includes ( Clustering value ) { return true ; } public boolean isDone ( ) { return false ; } } ; public int size ( ) { return <int> ; } public Slice get ( int i ) { return Slice . ALL ; } public boolean hasLowerBound ( ) { return false ; } public boolean hasUpperBound ( ) { return false ; } public boolean selects ( Clustering clustering ) { return true ; } public Slices forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive , boolean reversed ) { return new ArrayBackedSlices ( comparator , new Slice [ ] { Slice . ALL . forPaging ( comparator , lastReturned , inclusive , reversed ) } ) ; } public InOrderTester inOrderTester ( boolean reversed ) { return trivialTester ; } public boolean intersects ( List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) { return true ; } public UnfilteredRowIterator makeSliceIterator ( SliceableUnfilteredRowIterator iter ) { return iter ; } public Iterator < Slice > iterator ( ) { return Iterators . singletonIterator ( Slice . ALL ) ; } @Override public String toString ( ) { return <str> ; } public String toCQLString ( CFMetaData metadata ) { return <str> ; } } private static class SelectNoSlices extends Slices { private static final InOrderTester trivialTester = new InOrderTester ( ) { public boolean includes ( Clustering value ) { return false ; } public boolean isDone ( ) { return true ; } } ; public int size ( ) { return <int> ; } public Slice get ( int i ) { throw new UnsupportedOperationException ( ) ; } public boolean hasLowerBound ( ) { return false ; } public boolean hasUpperBound ( ) { return false ; } public Slices forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive , boolean reversed ) { return this ; } public boolean selects ( Clustering clustering ) { return false ; } public InOrderTester inOrderTester ( boolean reversed ) { return trivialTester ; } public boolean intersects ( List < ByteBuffer > minClusteringValues , List < ByteBuffer > maxClusteringValues ) { return false ; } public UnfilteredRowIterator makeSliceIterator ( SliceableUnfilteredRowIterator iter ) { return UnfilteredRowIterators . noRowsIterator ( iter . metadata ( ) , iter . partitionKey ( ) , iter . staticRow ( ) , iter . partitionLevelDeletion ( ) , iter . isReverseOrder ( ) ) ; } public Iterator < Slice > iterator ( ) { return Iterators . emptyIterator ( ) ; } @Override public String toString ( ) { return <str> ; } public String toCQLString ( CFMetaData metadata ) { return <str> ; } } }