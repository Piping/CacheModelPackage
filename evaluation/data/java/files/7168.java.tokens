package org . apache . cassandra . thrift ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . SocketTimeoutException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . SynchronousQueue ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import javax . net . ssl . SSLServerSocket ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . security . SSLFactory ; import org . apache . thrift . TException ; import org . apache . thrift . TProcessor ; import org . apache . thrift . protocol . TProtocol ; import org . apache . thrift . server . TServer ; import org . apache . thrift . server . TThreadPoolServer ; import org . apache . thrift . transport . TSSLTransportFactory ; import org . apache . thrift . transport . TServerSocket ; import org . apache . thrift . transport . TServerTransport ; import org . apache . thrift . transport . TTransport ; import org . apache . thrift . transport . TTransportException ; import org . apache . thrift . transport . TSSLTransportFactory . TSSLTransportParameters ; import com . google . common . util . concurrent . Uninterruptibles ; public class CustomTThreadPoolServer extends TServer { private static final Logger logger = LoggerFactory . getLogger ( CustomTThreadPoolServer . class . getName ( ) ) ; private final ExecutorService executorService ; private volatile boolean stopped ; private final TThreadPoolServer . Args args ; private final AtomicInteger activeClients = new AtomicInteger ( <int> ) ; public CustomTThreadPoolServer ( TThreadPoolServer . Args args , ExecutorService executorService ) { super ( args ) ; this . executorService = executorService ; this . args = args ; } @SuppressWarnings ( <str> ) public void serve ( ) { try { serverTransport_ . listen ( ) ; } catch ( TTransportException ttx ) { logger . error ( <str> , ttx ) ; return ; } stopped = false ; while ( ! stopped ) { while ( activeClients . get ( ) > = args . maxWorkerThreads ) { Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; } try { TTransport client = serverTransport_ . accept ( ) ; activeClients . incrementAndGet ( ) ; WorkerProcess wp = new WorkerProcess ( client ) ; executorService . execute ( wp ) ; } catch ( TTransportException ttx ) { if ( ttx . getCause ( ) instanceof SocketTimeoutException ) continue ; if ( ! stopped ) { logger . warn ( <str> , ttx ) ; } } catch ( RejectedExecutionException e ) { logger . trace ( <str> , args . maxWorkerThreads ) ; continue ; } if ( activeClients . get ( ) > = args . maxWorkerThreads ) logger . warn ( <str> , args . maxWorkerThreads ) ; } executorService . shutdown ( ) ; } public void stop ( ) { stopped = true ; serverTransport_ . interrupt ( ) ; } private class WorkerProcess implements Runnable { private TTransport client_ ; private WorkerProcess ( TTransport client ) { client_ = client ; } public void run ( ) { TProcessor processor = null ; TProtocol inputProtocol = null ; TProtocol outputProtocol = null ; SocketAddress socket = null ; try ( TTransport inputTransport = inputTransportFactory_ . getTransport ( client_ ) ; TTransport outputTransport = outputTransportFactory_ . getTransport ( client_ ) ) { socket = ( ( TCustomSocket ) client_ ) . getSocket ( ) . getRemoteSocketAddress ( ) ; ThriftSessionManager . instance . setCurrentSocket ( socket ) ; processor = processorFactory_ . getProcessor ( client_ ) ; inputProtocol = inputProtocolFactory_ . getProtocol ( inputTransport ) ; outputProtocol = outputProtocolFactory_ . getProtocol ( outputTransport ) ; while ( ! stopped & & processor . process ( inputProtocol , outputProtocol ) ) { inputProtocol = inputProtocolFactory_ . getProtocol ( inputTransport ) ; outputProtocol = outputProtocolFactory_ . getProtocol ( outputTransport ) ; } } catch ( TTransportException ttx ) { logger . trace ( <str> , ttx ) ; } catch ( TException tx ) { logger . error ( <str> , tx ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; logger . error ( <str> , e ) ; } finally { if ( socket ! = null ) ThriftSessionManager . instance . connectionComplete ( socket ) ; activeClients . decrementAndGet ( ) ; } } } public static class Factory implements TServerFactory { @SuppressWarnings ( <str> ) public TServer buildTServer ( Args args ) { final InetSocketAddress addr = args . addr ; TServerTransport serverTransport ; try { final ClientEncryptionOptions clientEnc = DatabaseDescriptor . getClientEncryptionOptions ( ) ; if ( clientEnc . enabled ) { logger . info ( <str> ) ; TSSLTransportParameters params = new TSSLTransportParameters ( clientEnc . protocol , clientEnc . cipher_suites ) ; params . setKeyStore ( clientEnc . keystore , clientEnc . keystore_password ) ; if ( clientEnc . require_client_auth ) { params . setTrustStore ( clientEnc . truststore , clientEnc . truststore_password ) ; params . requireClientAuth ( true ) ; } TServerSocket sslServer = TSSLTransportFactory . getServerSocket ( addr . getPort ( ) , <int> , addr . getAddress ( ) , params ) ; SSLServerSocket sslServerSocket = ( SSLServerSocket ) sslServer . getServerSocket ( ) ; sslServerSocket . setEnabledProtocols ( SSLFactory . ACCEPTED_PROTOCOLS ) ; serverTransport = new TCustomServerSocket ( sslServer . getServerSocket ( ) , args . keepAlive , args . sendBufferSize , args . recvBufferSize ) ; } else { serverTransport = new TCustomServerSocket ( addr , args . keepAlive , args . sendBufferSize , args . recvBufferSize , args . listenBacklog ) ; } } catch ( TTransportException e ) { throw new RuntimeException ( String . format ( <str> , addr . getAddress ( ) , addr . getPort ( ) ) , e ) ; } TThreadPoolServer . Args serverArgs = new TThreadPoolServer . Args ( serverTransport ) . minWorkerThreads ( DatabaseDescriptor . getRpcMinThreads ( ) ) . maxWorkerThreads ( DatabaseDescriptor . getRpcMaxThreads ( ) ) . inputTransportFactory ( args . inTransportFactory ) . outputTransportFactory ( args . outTransportFactory ) . inputProtocolFactory ( args . tProtocolFactory ) . outputProtocolFactory ( args . tProtocolFactory ) . processor ( args . processor ) ; ExecutorService executorService = new ThreadPoolExecutor ( serverArgs . minWorkerThreads , serverArgs . maxWorkerThreads , <int> , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , new NamedThreadFactory ( <str> ) ) ; return new CustomTThreadPoolServer ( serverArgs , executorService ) ; } } }