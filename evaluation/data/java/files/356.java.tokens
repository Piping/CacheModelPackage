package org . gradle . internal . nativeintegration . services ; import net . rubygrapefruit . platform . * ; import net . rubygrapefruit . platform . Process ; import net . rubygrapefruit . platform . internal . DefaultProcessLauncher ; import org . gradle . internal . SystemProperties ; import org . gradle . internal . jvm . Jvm ; import org . gradle . internal . nativeintegration . ProcessEnvironment ; import org . gradle . internal . nativeintegration . console . ConsoleDetector ; import org . gradle . internal . nativeintegration . console . NativePlatformConsoleDetector ; import org . gradle . internal . nativeintegration . console . NoOpConsoleDetector ; import org . gradle . internal . nativeintegration . console . WindowsConsoleDetector ; import org . gradle . internal . nativeintegration . filesystem . services . FileSystemServices ; import org . gradle . internal . nativeintegration . filesystem . services . UnavailablePosixFiles ; import org . gradle . internal . nativeintegration . jna . JnaBootPathConfigurer ; import org . gradle . internal . nativeintegration . jna . UnsupportedEnvironment ; import org . gradle . internal . nativeintegration . processenvironment . NativePlatformBackedProcessEnvironment ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . service . DefaultServiceRegistry ; import org . gradle . internal . service . ServiceRegistry ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public class NativeServices extends DefaultServiceRegistry implements ServiceRegistry { private static final Logger LOGGER = LoggerFactory . getLogger ( NativeServices . class ) ; private static boolean useNativePlatform = <str> . equalsIgnoreCase ( System . getProperty ( <str> , <str> ) ) ; private static final NativeServices INSTANCE = new NativeServices ( ) ; private static boolean initialized ; public static final String NATIVE_DIR_OVERRIDE = <str> ; public static void initialize ( File userHomeDir ) { initialize ( userHomeDir , true ) ; } public static synchronized void initialize ( File userHomeDir , boolean initializeJNA ) { if ( ! initialized ) { String overrideProperty = System . getProperty ( NATIVE_DIR_OVERRIDE ) ; File nativeDir ; if ( overrideProperty = = null ) { nativeDir = new File ( userHomeDir , <str> ) ; } else { nativeDir = new File ( overrideProperty ) ; } if ( useNativePlatform ) { try { net . rubygrapefruit . platform . Native . init ( nativeDir ) ; } catch ( NativeIntegrationUnavailableException ex ) { LOGGER . debug ( <str> ) ; useNativePlatform = false ; } catch ( NativeException ex ) { if ( ex . getCause ( ) instanceof UnsatisfiedLinkError & & ex . getCause ( ) . getMessage ( ) . toLowerCase ( ) . contains ( <str> ) ) { LOGGER . debug ( <str> , format ( ex ) ) ; useNativePlatform = false ; } else { throw ex ; } } } if ( OperatingSystem . current ( ) . isWindows ( ) & & initializeJNA ) { new JnaBootPathConfigurer ( ) . configure ( nativeDir ) ; } initialized = true ; } } public static synchronized NativeServices getInstance ( ) { if ( ! initialized ) { throw new IllegalStateException ( <str> ) ; } return INSTANCE ; } private NativeServices ( ) { addProvider ( new FileSystemServices ( ) ) ; } @Override public void close ( ) { } protected OperatingSystem createOperatingSystem ( ) { return OperatingSystem . current ( ) ; } protected Jvm createJvm ( ) { return Jvm . current ( ) ; } protected ProcessEnvironment createProcessEnvironment ( OperatingSystem operatingSystem ) { if ( useNativePlatform ) { try { net . rubygrapefruit . platform . Process process = net . rubygrapefruit . platform . Native . get ( Process . class ) ; return new NativePlatformBackedProcessEnvironment ( process ) ; } catch ( NativeIntegrationUnavailableException ex ) { LOGGER . debug ( <str> ) ; } } return new UnsupportedEnvironment ( ) ; } protected ConsoleDetector createConsoleDetector ( OperatingSystem operatingSystem ) { if ( useNativePlatform ) { try { Terminals terminals = net . rubygrapefruit . platform . Native . get ( Terminals . class ) ; return new NativePlatformConsoleDetector ( terminals ) ; } catch ( NativeIntegrationUnavailableException ex ) { LOGGER . debug ( <str> ) ; } catch ( NativeException ex ) { LOGGER . debug ( <str> , format ( ex ) ) ; } } try { if ( operatingSystem . isWindows ( ) ) { return new WindowsConsoleDetector ( ) ; } } catch ( LinkageError e ) { LOGGER . debug ( <str> , format ( e ) ) ; } return new NoOpConsoleDetector ( ) ; } protected WindowsRegistry createWindowsRegistry ( OperatingSystem operatingSystem ) { if ( useNativePlatform & & operatingSystem . isWindows ( ) ) { return net . rubygrapefruit . platform . Native . get ( WindowsRegistry . class ) ; } return notAvailable ( WindowsRegistry . class ) ; } protected SystemInfo createSystemInfo ( ) { if ( useNativePlatform ) { try { return net . rubygrapefruit . platform . Native . get ( SystemInfo . class ) ; } catch ( NativeIntegrationUnavailableException e ) { LOGGER . debug ( <str> ) ; } } return notAvailable ( SystemInfo . class ) ; } protected ProcessLauncher createProcessLauncher ( ) { if ( useNativePlatform ) { try { return net . rubygrapefruit . platform . Native . get ( ProcessLauncher . class ) ; } catch ( NativeIntegrationUnavailableException e ) { LOGGER . debug ( <str> ) ; } } return new DefaultProcessLauncher ( ) ; } protected PosixFiles createPosixFiles ( ) { if ( useNativePlatform ) { try { return net . rubygrapefruit . platform . Native . get ( PosixFiles . class ) ; } catch ( NativeIntegrationUnavailableException e ) { LOGGER . debug ( <str> ) ; } } return notAvailable ( UnavailablePosixFiles . class ) ; } private < T > T notAvailable ( Class < T > type ) { return ( T ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , new BrokenService ( type . getSimpleName ( ) ) ) ; } private static String format ( Throwable throwable ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( throwable . toString ( ) ) ; for ( Throwable current = throwable . getCause ( ) ; current ! = null ; current = current . getCause ( ) ) { builder . append ( SystemProperties . getInstance ( ) . getLineSeparator ( ) ) ; builder . append ( <str> ) ; builder . append ( current . toString ( ) ) ; } return builder . toString ( ) ; } private static class BrokenService implements InvocationHandler { private final String type ; private BrokenService ( String type ) { this . type = type ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { throw new org . gradle . internal . nativeintegration . NativeIntegrationUnavailableException ( String . format ( <str> , type ) ) ; } } } 
