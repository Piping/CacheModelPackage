package rx . schedulers ; import static org . junit . Assert . * ; import java . lang . management . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . Test ; import rx . * ; import rx . Scheduler . Worker ; import rx . functions . * ; import rx . internal . schedulers . NewThreadWorker ; import rx . internal . util . RxThreadFactory ; import rx . schedulers . ExecutorScheduler . ExecutorSchedulerWorker ; public class ExecutorSchedulerTest extends AbstractSchedulerConcurrencyTests { final static Executor executor = Executors . newFixedThreadPool ( <int> , new RxThreadFactory ( <str> ) ) ; @Override protected Scheduler getScheduler ( ) { return Schedulers . from ( executor ) ; } @Test public final void testUnhandledErrorIsDeliveredToThreadHandler ( ) throws InterruptedException { SchedulerTests . testUnhandledErrorIsDeliveredToThreadHandler ( getScheduler ( ) ) ; } @Test public final void testHandledErrorIsNotDeliveredToThreadHandler ( ) throws InterruptedException { SchedulerTests . testHandledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; } public static void testCancelledRetention ( Scheduler . Worker w , boolean periodic ) throws InterruptedException { System . out . println ( <str> ) ; Thread . sleep ( <int> ) ; System . out . println ( <str> ) ; System . gc ( ) ; Thread . sleep ( <int> ) ; MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( <str> , initial / <float> / <float> ) ; int n = <int> * <int> ; if ( periodic ) { final CountDownLatch cdl = new CountDownLatch ( n ) ; final Action0 action = new Action0 ( ) { @Override public void call ( ) { cdl . countDown ( ) ; } } ; for ( int i = <int> ; i < n ; i + + ) { if ( i % <int> = = <int> ) { System . out . println ( <str> + i ) ; } w . schedulePeriodically ( action , <int> , <int> , TimeUnit . DAYS ) ; } System . out . println ( <str> ) ; cdl . await ( ) ; } else { for ( int i = <int> ; i < n ; i + + ) { if ( i % <int> = = <int> ) { System . out . println ( <str> + i ) ; } w . schedule ( Actions . empty ( ) , <int> , TimeUnit . DAYS ) ; } } memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long after = memHeap . getUsed ( ) ; System . out . printf ( <str> , after / <float> / <float> ) ; w . unsubscribe ( ) ; System . out . println ( <str> ) ; Thread . sleep ( NewThreadWorker . PURGE_FREQUENCY + <int> ) ; System . out . println ( <str> ) ; System . gc ( ) ; Thread . sleep ( <int> ) ; memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long finish = memHeap . getUsed ( ) ; System . out . printf ( <str> , finish / <float> / <float> ) ; if ( finish > initial * <int> ) { fail ( String . format ( <str> , initial / <int> / <float> , after / <int> / <float> , finish / <int> / <int> d ) ) ; } } @Test ( timeout = <int> ) public void testCancelledTaskRetention ( ) throws InterruptedException { ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; Scheduler s = Schedulers . from ( exec ) ; try { Scheduler . Worker w = s . createWorker ( ) ; try { testCancelledRetention ( w , false ) ; } finally { w . unsubscribe ( ) ; } w = s . createWorker ( ) ; try { testCancelledRetention ( w , true ) ; } finally { w . unsubscribe ( ) ; } } finally { exec . shutdownNow ( ) ; } } static final class TestExecutor implements Executor { final ConcurrentLinkedQueue < Runnable > queue = new ConcurrentLinkedQueue < Runnable > ( ) ; @Override public void execute ( Runnable command ) { queue . offer ( command ) ; } public void executeOne ( ) { Runnable r = queue . poll ( ) ; if ( r ! = null ) { r . run ( ) ; } } public void executeAll ( ) { Runnable r ; while ( ( r = queue . poll ( ) ) ! = null ) { r . run ( ) ; } } } @Test public void testCancelledTasksDontRun ( ) { final AtomicInteger calls = new AtomicInteger ( ) ; Action0 task = new Action0 ( ) { @Override public void call ( ) { calls . getAndIncrement ( ) ; } } ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec ) ; Worker w = custom . createWorker ( ) ; try { Subscription s1 = w . schedule ( task ) ; Subscription s2 = w . schedule ( task ) ; Subscription s3 = w . schedule ( task ) ; s1 . unsubscribe ( ) ; s2 . unsubscribe ( ) ; s3 . unsubscribe ( ) ; exec . executeAll ( ) ; assertEquals ( <int> , calls . get ( ) ) ; } finally { w . unsubscribe ( ) ; } } @Test public void testCancelledWorkerDoesntRunTasks ( ) { final AtomicInteger calls = new AtomicInteger ( ) ; Action0 task = new Action0 ( ) { @Override public void call ( ) { calls . getAndIncrement ( ) ; } } ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec ) ; Worker w = custom . createWorker ( ) ; try { w . schedule ( task ) ; w . schedule ( task ) ; w . schedule ( task ) ; } finally { w . unsubscribe ( ) ; } exec . executeAll ( ) ; assertEquals ( <int> , calls . get ( ) ) ; } @Test public void testNoTimedTaskAfterScheduleRetention ( ) throws InterruptedException { Executor e = new Executor ( ) { @Override public void execute ( Runnable command ) { command . run ( ) ; } } ; ExecutorSchedulerWorker w = ( ExecutorSchedulerWorker ) Schedulers . from ( e ) . createWorker ( ) ; w . schedule ( Actions . empty ( ) , <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( w . tasks . hasSubscriptions ( ) ) ; Thread . sleep ( <int> ) ; assertFalse ( w . tasks . hasSubscriptions ( ) ) ; } @Test public void testNoTimedTaskPartRetention ( ) { Executor e = new Executor ( ) { @Override public void execute ( Runnable command ) { } } ; ExecutorSchedulerWorker w = ( ExecutorSchedulerWorker ) Schedulers . from ( e ) . createWorker ( ) ; Subscription s = w . schedule ( Actions . empty ( ) , <int> , TimeUnit . DAYS ) ; assertTrue ( w . tasks . hasSubscriptions ( ) ) ; s . unsubscribe ( ) ; assertFalse ( w . tasks . hasSubscriptions ( ) ) ; } @Test public void testNoPeriodicTimedTaskPartRetention ( ) throws InterruptedException { Executor e = new Executor ( ) { @Override public void execute ( Runnable command ) { command . run ( ) ; } } ; ExecutorSchedulerWorker w = ( ExecutorSchedulerWorker ) Schedulers . from ( e ) . createWorker ( ) ; final CountDownLatch cdl = new CountDownLatch ( <int> ) ; final Action0 action = new Action0 ( ) { @Override public void call ( ) { cdl . countDown ( ) ; } } ; Subscription s = w . schedulePeriodically ( action , <int> , <int> , TimeUnit . DAYS ) ; assertTrue ( w . tasks . hasSubscriptions ( ) ) ; cdl . await ( ) ; s . unsubscribe ( ) ; assertFalse ( w . tasks . hasSubscriptions ( ) ) ; } }