package org . apache . cassandra . cql3 . functions ; import java . lang . management . ManagementFactory ; import java . lang . management . ThreadMXBean ; import java . net . InetAddress ; import java . net . URL ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . List ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import com . google . common . base . Objects ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . datastax . driver . core . DataType ; import com . datastax . driver . core . UserType ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . FunctionExecutionException ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . schema . Functions ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . service . ClientWarn ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . JVMStabilityInspector ; public abstract class UDFunction extends AbstractFunction implements ScalarFunction { protected static final Logger logger = LoggerFactory . getLogger ( UDFunction . class ) ; static final ThreadMXBean threadMXBean = ManagementFactory . getThreadMXBean ( ) ; protected final List < ColumnIdentifier > argNames ; protected final String language ; protected final String body ; protected final DataType [ ] argDataTypes ; protected final DataType returnDataType ; protected final boolean calledOnNullInput ; private static final String [ ] whitelistedPatterns = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , } ; private static final String [ ] blacklistedPatterns = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , } ; static boolean secureResource ( String resource ) { while ( resource . startsWith ( <str> ) ) resource = resource . substring ( <int> ) ; for ( String white : whitelistedPatterns ) if ( resource . startsWith ( white ) ) { for ( String black : blacklistedPatterns ) if ( resource . startsWith ( black ) ) { logger . trace ( <str> , resource ) ; return false ; } return true ; } logger . trace ( <str> , resource ) ; return false ; } static final ClassLoader udfClassLoader = new UDFClassLoader ( ) ; protected UDFunction ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , AbstractType < ? > returnType , boolean calledOnNullInput , String language , String body ) { this ( name , argNames , argTypes , UDHelper . driverTypes ( argTypes ) , returnType , UDHelper . driverType ( returnType ) , calledOnNullInput , language , body ) ; } protected UDFunction ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , DataType [ ] argDataTypes , AbstractType < ? > returnType , DataType returnDataType , boolean calledOnNullInput , String language , String body ) { super ( name , argTypes , returnType ) ; assert new HashSet < > ( argNames ) . size ( ) = = argNames . size ( ) : <str> ; this . argNames = argNames ; this . language = language ; this . body = body ; this . argDataTypes = argDataTypes ; this . returnDataType = returnDataType ; this . calledOnNullInput = calledOnNullInput ; } public static UDFunction create ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , AbstractType < ? > returnType , boolean calledOnNullInput , String language , String body ) { UDFunction . assertUdfsEnabled ( language ) ; switch ( language ) { case <str> : return new JavaBasedUDFunction ( name , argNames , argTypes , returnType , calledOnNullInput , body ) ; default : return new ScriptBasedUDFunction ( name , argNames , argTypes , returnType , calledOnNullInput , language , body ) ; } } public static UDFunction createBrokenFunction ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , AbstractType < ? > returnType , boolean calledOnNullInput , String language , String body , InvalidRequestException reason ) { return new UDFunction ( name , argNames , argTypes , returnType , calledOnNullInput , language , body ) { protected ExecutorService executor ( ) { return Executors . newSingleThreadExecutor ( ) ; } public ByteBuffer executeUserDefined ( int protocolVersion , List < ByteBuffer > parameters ) { throw new InvalidRequestException ( String . format ( <str> + <str> , this , reason . getMessage ( ) ) ) ; } } ; } public final ByteBuffer execute ( int protocolVersion , List < ByteBuffer > parameters ) { assertUdfsEnabled ( language ) ; if ( ! isCallableWrtNullable ( parameters ) ) return null ; long tStart = System . nanoTime ( ) ; parameters = makeEmptyParametersNull ( parameters ) ; try { ByteBuffer result = DatabaseDescriptor . enableUserDefinedFunctionsThreads ( ) ? executeAsync ( protocolVersion , parameters ) : executeUserDefined ( protocolVersion , parameters ) ; Tracing . trace ( <str> , name ( ) , ( System . nanoTime ( ) - tStart ) / <int> ) ; return result ; } catch ( InvalidRequestException e ) { throw e ; } catch ( Throwable t ) { logger . trace ( <str> , this , t ) ; if ( t instanceof VirtualMachineError ) throw ( VirtualMachineError ) t ; throw FunctionExecutionException . create ( this , t ) ; } } public static void assertUdfsEnabled ( String language ) { if ( ! DatabaseDescriptor . enableUserDefinedFunctions ( ) ) throw new InvalidRequestException ( <str> ) ; if ( ! <str> . equalsIgnoreCase ( language ) & & ! DatabaseDescriptor . enableScriptedUserDefinedFunctions ( ) ) throw new InvalidRequestException ( <str> ) ; } static void initializeThread ( ) { UDHelper . codecFor ( DataType . inet ( ) ) . format ( InetAddress . getLoopbackAddress ( ) ) ; UDHelper . codecFor ( DataType . ascii ( ) ) . format ( <str> ) ; } private static final class ThreadIdAndCpuTime extends CompletableFuture < Object > { long threadId ; long cpuTime ; ThreadIdAndCpuTime ( ) { threadMXBean . getCurrentThreadCpuTime ( ) ; } void setup ( ) { this . threadId = Thread . currentThread ( ) . getId ( ) ; this . cpuTime = threadMXBean . getCurrentThreadCpuTime ( ) ; complete ( null ) ; } } private ByteBuffer executeAsync ( int protocolVersion , List < ByteBuffer > parameters ) { ThreadIdAndCpuTime threadIdAndCpuTime = new ThreadIdAndCpuTime ( ) ; Future < ByteBuffer > future = executor ( ) . submit ( ( ) - > { threadIdAndCpuTime . setup ( ) ; return executeUserDefined ( protocolVersion , parameters ) ; } ) ; try { if ( DatabaseDescriptor . getUserDefinedFunctionWarnTimeout ( ) > <int> ) try { return future . get ( DatabaseDescriptor . getUserDefinedFunctionWarnTimeout ( ) , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { String warn = String . format ( <str> , this , DatabaseDescriptor . getUserDefinedFunctionWarnTimeout ( ) ) ; logger . warn ( warn ) ; ClientWarn . warn ( warn ) ; } return future . get ( DatabaseDescriptor . getUserDefinedFunctionFailTimeout ( ) - DatabaseDescriptor . getUserDefinedFunctionWarnTimeout ( ) , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { Throwable c = e . getCause ( ) ; if ( c instanceof RuntimeException ) throw ( RuntimeException ) c ; throw new RuntimeException ( c ) ; } catch ( TimeoutException e ) { try { threadIdAndCpuTime . get ( <int> , TimeUnit . SECONDS ) ; long cpuTimeMillis = threadMXBean . getThreadCpuTime ( threadIdAndCpuTime . threadId ) - threadIdAndCpuTime . cpuTime ; cpuTimeMillis / = <int> ; return future . get ( Math . max ( DatabaseDescriptor . getUserDefinedFunctionFailTimeout ( ) - cpuTimeMillis , <int> ) , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e1 ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e1 ) { Throwable c = e . getCause ( ) ; if ( c instanceof RuntimeException ) throw ( RuntimeException ) c ; throw new RuntimeException ( c ) ; } catch ( TimeoutException e1 ) { TimeoutException cause = new TimeoutException ( String . format ( <str> , this , DatabaseDescriptor . getUserDefinedFunctionFailTimeout ( ) , DatabaseDescriptor . getUserFunctionTimeoutPolicy ( ) = = Config . UserFunctionTimeoutPolicy . ignore ? <str> : <str> ) ) ; FunctionExecutionException fe = FunctionExecutionException . create ( this , cause ) ; JVMStabilityInspector . userFunctionTimeout ( cause ) ; throw fe ; } } } private List < ByteBuffer > makeEmptyParametersNull ( List < ByteBuffer > parameters ) { List < ByteBuffer > r = new ArrayList < > ( parameters . size ( ) ) ; for ( int i = <int> ; i < parameters . size ( ) ; i + + ) { ByteBuffer param = parameters . get ( i ) ; r . add ( UDHelper . isNullOrEmpty ( argTypes . get ( i ) , param ) ? null : param ) ; } return r ; } protected abstract ExecutorService executor ( ) ; public boolean isCallableWrtNullable ( List < ByteBuffer > parameters ) { if ( ! calledOnNullInput ) for ( int i = <int> ; i < parameters . size ( ) ; i + + ) if ( UDHelper . isNullOrEmpty ( argTypes . get ( i ) , parameters . get ( i ) ) ) return false ; return true ; } protected abstract ByteBuffer executeUserDefined ( int protocolVersion , List < ByteBuffer > parameters ) ; public boolean isAggregate ( ) { return false ; } public boolean isNative ( ) { return false ; } public boolean isCalledOnNullInput ( ) { return calledOnNullInput ; } public List < ColumnIdentifier > argNames ( ) { return argNames ; } public String body ( ) { return body ; } public String language ( ) { return language ; } protected Object compose ( int protocolVersion , int argIndex , ByteBuffer value ) { return compose ( argDataTypes , protocolVersion , argIndex , value ) ; } protected static Object compose ( DataType [ ] argDataTypes , int protocolVersion , int argIndex , ByteBuffer value ) { return value = = null ? null : UDHelper . deserialize ( argDataTypes [ argIndex ] , protocolVersion , value ) ; } protected ByteBuffer decompose ( int protocolVersion , Object value ) { return decompose ( returnDataType , protocolVersion , value ) ; } protected static ByteBuffer decompose ( DataType dataType , int protocolVersion , Object value ) { return value = = null ? null : UDHelper . serialize ( dataType , protocolVersion , value ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof UDFunction ) ) return false ; UDFunction that = ( UDFunction ) o ; return Objects . equal ( name , that . name ) & & Objects . equal ( argNames , that . argNames ) & & Functions . typesMatch ( argTypes , that . argTypes ) & & Functions . typesMatch ( returnType , that . returnType ) & & Objects . equal ( language , that . language ) & & Objects . equal ( body , that . body ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( name , Functions . typeHashCode ( argTypes ) , Functions . typeHashCode ( returnType ) , returnType , language , body ) ; } public void userTypeUpdated ( String ksName , String typeName ) { boolean updated = false ; for ( int i = <int> ; i < argDataTypes . length ; i + + ) { DataType dataType = argDataTypes [ i ] ; if ( dataType instanceof UserType ) { UserType userType = ( UserType ) dataType ; if ( userType . getKeyspace ( ) . equals ( ksName ) & & userType . getTypeName ( ) . equals ( typeName ) ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; assert ksm ! = null ; org . apache . cassandra . db . marshal . UserType ut = ksm . types . get ( ByteBufferUtil . bytes ( typeName ) ) . get ( ) ; DataType newUserType = UDHelper . driverType ( ut ) ; argDataTypes [ i ] = newUserType ; argTypes . set ( i , ut ) ; updated = true ; } } } if ( updated ) MigrationManager . announceNewFunction ( this , true ) ; } private static class UDFClassLoader extends ClassLoader { static final ClassLoader insecureClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; public URL getResource ( String name ) { if ( ! secureResource ( name ) ) return null ; return insecureClassLoader . getResource ( name ) ; } protected URL findResource ( String name ) { return getResource ( name ) ; } public Enumeration < URL > getResources ( String name ) { return Collections . emptyEnumeration ( ) ; } protected Class < ? > findClass ( String name ) throws ClassNotFoundException { if ( ! secureResource ( name . replace ( <str> , <str> ) + <str> ) ) throw new ClassNotFoundException ( name ) ; return insecureClassLoader . loadClass ( name ) ; } public Class < ? > loadClass ( String name ) throws ClassNotFoundException { if ( ! secureResource ( name . replace ( <str> , <str> ) + <str> ) ) throw new ClassNotFoundException ( name ) ; return super . loadClass ( name ) ; } } } 
