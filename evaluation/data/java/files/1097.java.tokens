package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import com . google . common . annotations . Beta ; import com . google . common . base . Supplier ; import com . google . j2objc . annotations . WeakOuter ; import java . util . concurrent . Callable ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . locks . ReentrantLock ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . concurrent . GuardedBy ; @Beta public abstract class AbstractScheduledService implements Service { private static final Logger logger = Logger . getLogger ( AbstractScheduledService . class . getName ( ) ) ; public abstract static class Scheduler { public static Scheduler newFixedDelaySchedule ( final long initialDelay , final long delay , final TimeUnit unit ) { checkNotNull ( unit ) ; checkArgument ( delay > <int> , <str> , delay ) ; return new Scheduler ( ) { @Override public Future < ? > schedule ( AbstractService service , ScheduledExecutorService executor , Runnable task ) { return executor . scheduleWithFixedDelay ( task , initialDelay , delay , unit ) ; } } ; } public static Scheduler newFixedRateSchedule ( final long initialDelay , final long period , final TimeUnit unit ) { checkNotNull ( unit ) ; checkArgument ( period > <int> , <str> , period ) ; return new Scheduler ( ) { @Override public Future < ? > schedule ( AbstractService service , ScheduledExecutorService executor , Runnable task ) { return executor . scheduleAtFixedRate ( task , initialDelay , period , unit ) ; } } ; } abstract Future < ? > schedule ( AbstractService service , ScheduledExecutorService executor , Runnable runnable ) ; private Scheduler ( ) { } } private final AbstractService delegate = new ServiceDelegate ( ) ; @WeakOuter private final class ServiceDelegate extends AbstractService { private volatile Future < ? > runningTask ; private volatile ScheduledExecutorService executorService ; private final ReentrantLock lock = new ReentrantLock ( ) ; @WeakOuter class Task implements Runnable { @Override public void run ( ) { lock . lock ( ) ; try { if ( runningTask . isCancelled ( ) ) { return ; } AbstractScheduledService . this . runOneIteration ( ) ; } catch ( Throwable t ) { try { shutDown ( ) ; } catch ( Exception ignored ) { logger . log ( Level . WARNING , <str> , ignored ) ; } notifyFailed ( t ) ; runningTask . cancel ( false ) ; } finally { lock . unlock ( ) ; } } } private final Runnable task = new Task ( ) ; @Override protected final void doStart ( ) { executorService = MoreExecutors . renamingDecorator ( executor ( ) , new Supplier < String > ( ) { @Override public String get ( ) { return serviceName ( ) + <str> + state ( ) ; } } ) ; executorService . execute ( new Runnable ( ) { @Override public void run ( ) { lock . lock ( ) ; try { startUp ( ) ; runningTask = scheduler ( ) . schedule ( delegate , executorService , task ) ; notifyStarted ( ) ; } catch ( Throwable t ) { notifyFailed ( t ) ; if ( runningTask ! = null ) { runningTask . cancel ( false ) ; } } finally { lock . unlock ( ) ; } } } ) ; } @Override protected final void doStop ( ) { runningTask . cancel ( false ) ; executorService . execute ( new Runnable ( ) { @Override public void run ( ) { try { lock . lock ( ) ; try { if ( state ( ) ! = State . STOPPING ) { return ; } shutDown ( ) ; } finally { lock . unlock ( ) ; } notifyStopped ( ) ; } catch ( Throwable t ) { notifyFailed ( t ) ; } } } ) ; } @Override public String toString ( ) { return AbstractScheduledService . this . toString ( ) ; } } protected AbstractScheduledService ( ) { } protected abstract void runOneIteration ( ) throws Exception ; protected void startUp ( ) throws Exception { } protected void shutDown ( ) throws Exception { } protected abstract Scheduler scheduler ( ) ; protected ScheduledExecutorService executor ( ) { @WeakOuter class ThreadFactoryImpl implements ThreadFactory { @Override public Thread newThread ( Runnable runnable ) { return MoreExecutors . newThread ( serviceName ( ) , runnable ) ; } } final ScheduledExecutorService executor = Executors . newSingleThreadScheduledExecutor ( new ThreadFactoryImpl ( ) ) ; addListener ( new Listener ( ) { @Override public void terminated ( State from ) { executor . shutdown ( ) ; } @Override public void failed ( State from , Throwable failure ) { executor . shutdown ( ) ; } } , directExecutor ( ) ) ; return executor ; } protected String serviceName ( ) { return getClass ( ) . getSimpleName ( ) ; } @Override public String toString ( ) { return serviceName ( ) + <str> + state ( ) + <str> ; } @Override public final boolean isRunning ( ) { return delegate . isRunning ( ) ; } @Override public final State state ( ) { return delegate . state ( ) ; } @Override public final void addListener ( Listener listener , Executor executor ) { delegate . addListener ( listener , executor ) ; } @Override public final Throwable failureCause ( ) { return delegate . failureCause ( ) ; } @Override public final Service startAsync ( ) { delegate . startAsync ( ) ; return this ; } @Override public final Service stopAsync ( ) { delegate . stopAsync ( ) ; return this ; } @Override public final void awaitRunning ( ) { delegate . awaitRunning ( ) ; } @Override public final void awaitRunning ( long timeout , TimeUnit unit ) throws TimeoutException { delegate . awaitRunning ( timeout , unit ) ; } @Override public final void awaitTerminated ( ) { delegate . awaitTerminated ( ) ; } @Override public final void awaitTerminated ( long timeout , TimeUnit unit ) throws TimeoutException { delegate . awaitTerminated ( timeout , unit ) ; } @Beta public abstract static class CustomScheduler extends Scheduler { private class ReschedulableCallable extends ForwardingFuture < Void > implements Callable < Void > { private final Runnable wrappedRunnable ; private final ScheduledExecutorService executor ; private final AbstractService service ; private final ReentrantLock lock = new ReentrantLock ( ) ; @GuardedBy ( <str> ) private Future < Void > currentFuture ; ReschedulableCallable ( AbstractService service , ScheduledExecutorService executor , Runnable runnable ) { this . wrappedRunnable = runnable ; this . executor = executor ; this . service = service ; } @Override public Void call ( ) throws Exception { wrappedRunnable . run ( ) ; reschedule ( ) ; return null ; } public void reschedule ( ) { Schedule schedule ; try { schedule = CustomScheduler . this . getNextSchedule ( ) ; } catch ( Throwable t ) { service . notifyFailed ( t ) ; return ; } Throwable scheduleFailure = null ; lock . lock ( ) ; try { if ( currentFuture = = null | | ! currentFuture . isCancelled ( ) ) { currentFuture = executor . schedule ( this , schedule . delay , schedule . unit ) ; } } catch ( Throwable e ) { scheduleFailure = e ; } finally { lock . unlock ( ) ; } if ( scheduleFailure ! = null ) { service . notifyFailed ( scheduleFailure ) ; } } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { lock . lock ( ) ; try { return currentFuture . cancel ( mayInterruptIfRunning ) ; } finally { lock . unlock ( ) ; } } @Override public boolean isCancelled ( ) { lock . lock ( ) ; try { return currentFuture . isCancelled ( ) ; } finally { lock . unlock ( ) ; } } @Override protected Future < Void > delegate ( ) { throw new UnsupportedOperationException ( <str> ) ; } } @Override final Future < ? > schedule ( AbstractService service , ScheduledExecutorService executor , Runnable runnable ) { ReschedulableCallable task = new ReschedulableCallable ( service , executor , runnable ) ; task . reschedule ( ) ; return task ; } @Beta protected static final class Schedule { private final long delay ; private final TimeUnit unit ; public Schedule ( long delay , TimeUnit unit ) { this . delay = delay ; this . unit = checkNotNull ( unit ) ; } } protected abstract Schedule getNextSchedule ( ) throws Exception ; } }