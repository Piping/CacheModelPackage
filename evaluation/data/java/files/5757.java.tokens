package rx . observers ; import static org . junit . Assert . * ; import static org . mockito . Mockito . * ; import java . util . * ; import org . junit . * ; import org . junit . rules . ExpectedException ; import org . mockito . InOrder ; import rx . Notification ; import rx . Observable ; import rx . Observer ; import rx . exceptions . TestException ; import rx . subjects . PublishSubject ; public class TestObserverTest { @Rule public ExpectedException thrown = ExpectedException . none ( ) ; @Test public void testAssert ( ) { Observable < Integer > oi = Observable . from ( Arrays . asList ( <int> , <int> ) ) ; TestObserver < Integer > o = new TestObserver < Integer > ( ) ; oi . subscribe ( o ) ; o . assertReceivedOnNext ( Arrays . asList ( <int> , <int> ) ) ; assertEquals ( <int> , o . getOnNextEvents ( ) . size ( ) ) ; o . assertTerminalEvent ( ) ; } @Test public void testAssertNotMatchCount ( ) { Observable < Integer > oi = Observable . from ( Arrays . asList ( <int> , <int> ) ) ; TestObserver < Integer > o = new TestObserver < Integer > ( ) ; oi . subscribe ( o ) ; thrown . expect ( AssertionError . class ) ; thrown . expectMessage ( <str> ) ; o . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; assertEquals ( <int> , o . getOnNextEvents ( ) . size ( ) ) ; o . assertTerminalEvent ( ) ; } @Test public void testAssertNotMatchValue ( ) { Observable < Integer > oi = Observable . from ( Arrays . asList ( <int> , <int> ) ) ; TestObserver < Integer > o = new TestObserver < Integer > ( ) ; oi . subscribe ( o ) ; thrown . expect ( AssertionError . class ) ; thrown . expectMessage ( <str> ) ; o . assertReceivedOnNext ( Arrays . asList ( <int> , <int> ) ) ; assertEquals ( <int> , o . getOnNextEvents ( ) . size ( ) ) ; o . assertTerminalEvent ( ) ; } @Test public void testAssertTerminalEventNotReceived ( ) { PublishSubject < Integer > p = PublishSubject . create ( ) ; TestObserver < Integer > o = new TestObserver < Integer > ( ) ; p . subscribe ( o ) ; p . onNext ( <int> ) ; p . onNext ( <int> ) ; thrown . expect ( AssertionError . class ) ; thrown . expectMessage ( <str> ) ; o . assertReceivedOnNext ( Arrays . asList ( <int> , <int> ) ) ; assertEquals ( <int> , o . getOnNextEvents ( ) . size ( ) ) ; o . assertTerminalEvent ( ) ; } @Test public void testWrappingMock ( ) { Observable < Integer > oi = Observable . from ( Arrays . asList ( <int> , <int> ) ) ; @SuppressWarnings ( <str> ) Observer < Integer > mockObserver = mock ( Observer . class ) ; oi . subscribe ( new TestObserver < Integer > ( mockObserver ) ) ; InOrder inOrder = inOrder ( mockObserver ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testWrappingMockWhenUnsubscribeInvolved ( ) { Observable < Integer > oi = Observable . from ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . take ( <int> ) ; @SuppressWarnings ( <str> ) Observer < Integer > mockObserver = mock ( Observer . class ) ; oi . subscribe ( new TestObserver < Integer > ( mockObserver ) ) ; InOrder inOrder = inOrder ( mockObserver ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( mockObserver , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testErrorSwallowed ( ) { Observable . error ( new RuntimeException ( ) ) . subscribe ( new TestObserver < Object > ( ) ) ; } @Test public void testGetEvents ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onNext ( <int> ) ; to . onNext ( <int> ) ; assertEquals ( Arrays . < Object > asList ( Arrays . asList ( <int> , <int> ) , Collections . emptyList ( ) , Collections . emptyList ( ) ) , to . getEvents ( ) ) ; to . onCompleted ( ) ; assertEquals ( Arrays . < Object > asList ( Arrays . asList ( <int> , <int> ) , Collections . emptyList ( ) , Collections . singletonList ( Notification . createOnCompleted ( ) ) ) , to . getEvents ( ) ) ; TestException ex = new TestException ( ) ; TestObserver < Integer > to2 = new TestObserver < Integer > ( ) ; to2 . onNext ( <int> ) ; to2 . onNext ( <int> ) ; assertEquals ( Arrays . < Object > asList ( Arrays . asList ( <int> , <int> ) , Collections . emptyList ( ) , Collections . emptyList ( ) ) , to2 . getEvents ( ) ) ; to2 . onError ( ex ) ; assertEquals ( Arrays . < Object > asList ( Arrays . asList ( <int> , <int> ) , Collections . singletonList ( ex ) , Collections . emptyList ( ) ) , to2 . getEvents ( ) ) ; } @Test public void testNullExpected ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onNext ( <int> ) ; try { to . assertReceivedOnNext ( Arrays . asList ( ( Integer ) null ) ) ; } catch ( AssertionError ex ) { return ; } fail ( <str> ) ; } @Test public void testNullActual ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onNext ( null ) ; try { to . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; } catch ( AssertionError ex ) { return ; } fail ( <str> ) ; } @Test public void testTerminalErrorOnce ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onError ( new TestException ( ) ) ; to . onError ( new TestException ( ) ) ; try { to . assertTerminalEvent ( ) ; } catch ( AssertionError ex ) { return ; } fail ( <str> ) ; } @Test public void testTerminalCompletedOnce ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onCompleted ( ) ; to . onCompleted ( ) ; try { to . assertTerminalEvent ( ) ; } catch ( AssertionError ex ) { return ; } fail ( <str> ) ; } @Test public void testTerminalOneKind ( ) { TestObserver < Integer > to = new TestObserver < Integer > ( ) ; to . onError ( new TestException ( ) ) ; to . onCompleted ( ) ; try { to . assertTerminalEvent ( ) ; } catch ( AssertionError ex ) { return ; } fail ( <str> ) ; } }