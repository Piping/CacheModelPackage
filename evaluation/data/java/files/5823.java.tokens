package rx . internal . operators ; import static org . junit . Assert . * ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . * ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . * ; import org . mockito . * ; import rx . * ; import rx . Observable . OnSubscribe ; import rx . Observable ; import rx . Observer ; import rx . functions . * ; import rx . observers . * ; import rx . schedulers . * ; import rx . subjects . ReplaySubject ; import rx . subscriptions . Subscriptions ; public class OnSubscribeRefCountTest { @Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; } @Test public void testRefCountAsync ( ) { final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Long > r = Observable . interval ( <int> , <int> , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { subscribeCount . incrementAndGet ( ) ; } } ) . doOnNext ( new Action1 < Long > ( ) { @Override public void call ( Long l ) { nextCount . incrementAndGet ( ) ; } } ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Subscription s1 = r . subscribe ( new Action1 < Long > ( ) { @Override public void call ( Long l ) { receivedCount . incrementAndGet ( ) ; } } ) ; Subscription s2 = r . subscribe ( ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } s2 . unsubscribe ( ) ; s1 . unsubscribe ( ) ; System . out . println ( <str> + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) ) ; assertEquals ( <int> , subscribeCount . get ( ) ) ; } @Test public void testRefCountSynchronous ( ) { final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Integer > r = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { subscribeCount . incrementAndGet ( ) ; } } ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer l ) { nextCount . incrementAndGet ( ) ; } } ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Subscription s1 = r . subscribe ( new Action1 < Integer > ( ) { @Override public void call ( Integer l ) { receivedCount . incrementAndGet ( ) ; } } ) ; Subscription s2 = r . subscribe ( ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } s2 . unsubscribe ( ) ; s1 . unsubscribe ( ) ; System . out . println ( <str> + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) * <int> ) ; assertEquals ( <int> , subscribeCount . get ( ) ) ; } @Test public void testRefCountSynchronousTake ( ) { final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Integer > r = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer l ) { System . out . println ( <str> + l ) ; nextCount . incrementAndGet ( ) ; } } ) . take ( <int> ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; r . subscribe ( new Action1 < Integer > ( ) { @Override public void call ( Integer l ) { receivedCount . incrementAndGet ( ) ; } } ) ; System . out . println ( <str> + nextCount . get ( ) ) ; assertEquals ( <int> , receivedCount . get ( ) ) ; assertEquals ( <int> , receivedCount . get ( ) ) ; } @Test public void testRepeat ( ) { final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger unsubscribeCount = new AtomicInteger ( ) ; Observable < Long > r = Observable . interval ( <int> , <int> , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; subscribeCount . incrementAndGet ( ) ; } } ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; unsubscribeCount . incrementAndGet ( ) ; } } ) . publish ( ) . refCount ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { TestSubscriber < Long > ts1 = new TestSubscriber < Long > ( ) ; TestSubscriber < Long > ts2 = new TestSubscriber < Long > ( ) ; r . subscribe ( ts1 ) ; r . subscribe ( ts2 ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } ts1 . unsubscribe ( ) ; ts2 . unsubscribe ( ) ; ts1 . assertNoErrors ( ) ; ts2 . assertNoErrors ( ) ; assertTrue ( ts1 . getOnNextEvents ( ) . size ( ) > <int> ) ; assertTrue ( ts2 . getOnNextEvents ( ) . size ( ) > <int> ) ; } assertEquals ( <int> , subscribeCount . get ( ) ) ; assertEquals ( <int> , unsubscribeCount . get ( ) ) ; } @Test public void testConnectUnsubscribe ( ) throws InterruptedException { final CountDownLatch unsubscribeLatch = new CountDownLatch ( <int> ) ; final CountDownLatch subscribeLatch = new CountDownLatch ( <int> ) ; Observable < Long > o = synchronousInterval ( ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; subscribeLatch . countDown ( ) ; } } ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; unsubscribeLatch . countDown ( ) ; } } ) ; TestSubscriber < Long > s = new TestSubscriber < Long > ( ) ; o . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( s ) ; System . out . println ( <str> ) ; subscribeLatch . await ( ) ; s . unsubscribe ( ) ; System . out . println ( <str> ) ; if ( ! unsubscribeLatch . await ( <int> , TimeUnit . MILLISECONDS ) ) { System . out . println ( <str> + s . getOnErrorEvents ( ) ) ; if ( s . getOnErrorEvents ( ) . size ( ) > <int> ) { s . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } fail ( <str> ) ; } s . assertNoErrors ( ) ; } @Test public void testConnectUnsubscribeRaceConditionLoop ( ) throws InterruptedException { for ( int i = <int> ; i < <int> ; i + + ) { testConnectUnsubscribeRaceCondition ( ) ; } } @Test public void testConnectUnsubscribeRaceCondition ( ) throws InterruptedException { final AtomicInteger subUnsubCount = new AtomicInteger ( ) ; Observable < Long > o = synchronousInterval ( ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; subUnsubCount . decrementAndGet ( ) ; } } ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; subUnsubCount . incrementAndGet ( ) ; } } ) ; TestSubscriber < Long > s = new TestSubscriber < Long > ( ) ; o . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( s ) ; System . out . println ( <str> ) ; s . unsubscribe ( ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , subUnsubCount . get ( ) ) ; System . out . println ( <str> ) ; System . out . println ( <str> + s . getOnErrorEvents ( ) ) ; if ( s . getOnErrorEvents ( ) . size ( ) > <int> ) { s . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } s . assertNoErrors ( ) ; } private Observable < Long > synchronousInterval ( ) { return Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > subscriber ) { while ( ! subscriber . isUnsubscribed ( ) ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } subscriber . onNext ( <int> ) ; } } } ) ; } @Test public void onlyFirstShouldSubscribeAndLastUnsubscribe ( ) { final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; final AtomicInteger unsubscriptionCount = new AtomicInteger ( ) ; Observable < Integer > observable = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( Subscriber < ? super Integer > observer ) { subscriptionCount . incrementAndGet ( ) ; observer . add ( Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { unsubscriptionCount . incrementAndGet ( ) ; } } ) ) ; } } ) ; Observable < Integer > refCounted = observable . publish ( ) . refCount ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; Subscription first = refCounted . subscribe ( observer ) ; assertEquals ( <int> , subscriptionCount . get ( ) ) ; Subscription second = refCounted . subscribe ( observer ) ; assertEquals ( <int> , subscriptionCount . get ( ) ) ; first . unsubscribe ( ) ; assertEquals ( <int> , unsubscriptionCount . get ( ) ) ; second . unsubscribe ( ) ; assertEquals ( <int> , unsubscriptionCount . get ( ) ) ; } @Test public void testRefCount ( ) { TestScheduler s = new TestScheduler ( ) ; Observable < Long > interval = Observable . interval ( <int> , TimeUnit . MILLISECONDS , s ) . publish ( ) . refCount ( ) ; final List < Long > list1 = new ArrayList < Long > ( ) ; Subscription s1 = interval . subscribe ( new Action1 < Long > ( ) { @Override public void call ( Long t1 ) { list1 . add ( t1 ) ; } } ) ; s . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , list1 . size ( ) ) ; assertEquals ( <int> , list1 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list1 . get ( <int> ) . longValue ( ) ) ; final List < Long > list2 = new ArrayList < Long > ( ) ; Subscription s2 = interval . subscribe ( new Action1 < Long > ( ) { @Override public void call ( Long t1 ) { list2 . add ( t1 ) ; } } ) ; s . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , list1 . size ( ) ) ; assertEquals ( <int> , list1 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list1 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list1 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list2 . size ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; s1 . unsubscribe ( ) ; s . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , list1 . size ( ) ) ; assertEquals ( <int> , list2 . size ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . longValue ( ) ) ; s2 . unsubscribe ( ) ; s . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; final List < Long > list3 = new ArrayList < Long > ( ) ; interval . subscribe ( new Action1 < Long > ( ) { @Override public void call ( Long t1 ) { list3 . add ( t1 ) ; } } ) ; s . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <int> , list3 . size ( ) ) ; assertEquals ( <int> , list3 . get ( <int> ) . longValue ( ) ) ; assertEquals ( <int> , list3 . get ( <int> ) . longValue ( ) ) ; } @Test public void testAlreadyUnsubscribedClient ( ) { Subscriber < Integer > done = Subscribers . empty ( ) ; done . unsubscribe ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > o = mock ( Observer . class ) ; Observable < Integer > result = Observable . just ( <int> ) . publish ( ) . refCount ( ) ; result . subscribe ( done ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( <int> ) ; verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testAlreadyUnsubscribedInterleavesWithClient ( ) { ReplaySubject < Integer > source = ReplaySubject . create ( ) ; Subscriber < Integer > done = Subscribers . empty ( ) ; done . unsubscribe ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; Observable < Integer > result = source . publish ( ) . refCount ( ) ; result . subscribe ( o ) ; source . onNext ( <int> ) ; result . subscribe ( done ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; inOrder . verify ( o ) . onNext ( <int> ) ; inOrder . verify ( o ) . onNext ( <int> ) ; inOrder . verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testConnectDisconnectConnectAndSubjectState ( ) { Observable < Integer > o1 = Observable . just ( <int> ) ; Observable < Integer > o2 = Observable . just ( <int> ) ; Observable < Integer > combined = Observable . combineLatest ( o1 , o2 , new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ) . publish ( ) . refCount ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) ; combined . subscribe ( ts1 ) ; combined . subscribe ( ts2 ) ; ts1 . assertTerminalEvent ( ) ; ts1 . assertNoErrors ( ) ; ts1 . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; ts2 . assertTerminalEvent ( ) ; ts2 . assertNoErrors ( ) ; ts2 . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; } @Test ( timeout = <int> ) public void testUpstreamErrorAllowsRetry ( ) throws InterruptedException { final AtomicInteger intervalSubscribed = new AtomicInteger ( ) ; Observable < String > interval = Observable . interval ( <int> , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> + intervalSubscribed . incrementAndGet ( ) ) ; } } ) . flatMap ( new Func1 < Long , Observable < String > > ( ) { @Override public Observable < String > call ( Long t1 ) { return Observable . defer ( new Func0 < Observable < String > > ( ) { @Override public Observable < String > call ( ) { return Observable . < String > error ( new Exception ( <str> ) ) ; } } ) ; } } ) . onErrorResumeNext ( new Func1 < Throwable , Observable < String > > ( ) { @Override public Observable < String > call ( Throwable t1 ) { return Observable . error ( t1 ) ; } } ) . publish ( ) . refCount ( ) ; interval . doOnError ( new Action1 < Throwable > ( ) { @Override public void call ( Throwable t1 ) { System . out . println ( <str> + t1 ) ; } } ) . retry ( <int> ) . subscribe ( new Action1 < String > ( ) { @Override public void call ( String t1 ) { System . out . println ( <str> + t1 ) ; } } ) ; Thread . sleep ( <int> ) ; interval . doOnError ( new Action1 < Throwable > ( ) { @Override public void call ( Throwable t1 ) { System . out . println ( <str> + t1 ) ; } } ) . retry ( <int> ) . subscribe ( new Action1 < String > ( ) { @Override public void call ( String t1 ) { System . out . println ( <str> + t1 ) ; } } ) ; Thread . sleep ( <int> ) ; System . out . println ( intervalSubscribed . get ( ) ) ; assertEquals ( <int> , intervalSubscribed . get ( ) ) ; } }