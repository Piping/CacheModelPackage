package org . apache . cassandra . io . util ; import java . lang . reflect . Field ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import net . nicoulaj . compilecommand . annotations . Inline ; import org . apache . cassandra . utils . FastByteOperations ; import org . apache . cassandra . utils . concurrent . Ref ; import org . apache . cassandra . utils . memory . MemoryUtil ; import sun . misc . Unsafe ; import sun . nio . ch . DirectBuffer ; public class Memory implements AutoCloseable { private static final Unsafe unsafe ; static { try { Field field = sun . misc . Unsafe . class . getDeclaredField ( <str> ) ; field . setAccessible ( true ) ; unsafe = ( sun . misc . Unsafe ) field . get ( null ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } private static final long BYTE_ARRAY_BASE_OFFSET = unsafe . arrayBaseOffset ( byte [ ] . class ) ; private static final boolean bigEndian = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG_ENDIAN ) ; private static final boolean unaligned ; public static final ByteBuffer [ ] NO_BYTE_BUFFERS = new ByteBuffer [ <int> ] ; static { String arch = System . getProperty ( <str> ) ; unaligned = arch . equals ( <str> ) | | arch . equals ( <str> ) | | arch . equals ( <str> ) | | arch . equals ( <str> ) ; } protected long peer ; protected final long size ; protected Memory ( long bytes ) { if ( bytes < = <int> ) throw new AssertionError ( ) ; size = bytes ; peer = MemoryUtil . allocate ( size ) ; if ( peer = = <int> ) throw new OutOfMemoryError ( ) ; } protected Memory ( Memory copyOf ) { size = copyOf . size ; peer = copyOf . peer ; } public static Memory allocate ( long bytes ) { if ( bytes < <int> ) throw new IllegalArgumentException ( ) ; if ( Ref . DEBUG_ENABLED ) return new SafeMemory ( bytes ) ; return new Memory ( bytes ) ; } public void setByte ( long offset , byte b ) { checkBounds ( offset , offset + <int> ) ; unsafe . putByte ( peer + offset , b ) ; } public void setMemory ( long offset , long bytes , byte b ) { checkBounds ( offset , offset + bytes ) ; unsafe . setMemory ( peer + offset , bytes , b ) ; } public void setLong ( long offset , long l ) { checkBounds ( offset , offset + <int> ) ; if ( unaligned ) { unsafe . putLong ( peer + offset , l ) ; } else { putLongByByte ( peer + offset , l ) ; } } private void putLongByByte ( long address , long value ) { if ( bigEndian ) { unsafe . putByte ( address , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value ) ) ; } else { unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address , ( byte ) ( value ) ) ; } } public void setInt ( long offset , int l ) { checkBounds ( offset , offset + <int> ) ; if ( unaligned ) { unsafe . putInt ( peer + offset , l ) ; } else { putIntByByte ( peer + offset , l ) ; } } private void putIntByByte ( long address , int value ) { if ( bigEndian ) { unsafe . putByte ( address , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value ) ) ; } else { unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address , ( byte ) ( value ) ) ; } } public void setShort ( long offset , short l ) { checkBounds ( offset , offset + <int> ) ; if ( unaligned ) { unsafe . putShort ( peer + offset , l ) ; } else { putShortByByte ( peer + offset , l ) ; } } private void putShortByByte ( long address , short value ) { if ( bigEndian ) { unsafe . putByte ( address , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address + <int> , ( byte ) ( value ) ) ; } else { unsafe . putByte ( address + <int> , ( byte ) ( value > > <int> ) ) ; unsafe . putByte ( address , ( byte ) ( value ) ) ; } } public void setBytes ( long memoryOffset , ByteBuffer buffer ) { if ( buffer = = null ) throw new NullPointerException ( ) ; else if ( buffer . remaining ( ) = = <int> ) return ; checkBounds ( memoryOffset , memoryOffset + buffer . remaining ( ) ) ; if ( buffer . hasArray ( ) ) { setBytes ( memoryOffset , buffer . array ( ) , buffer . arrayOffset ( ) + buffer . position ( ) , buffer . remaining ( ) ) ; } else if ( buffer instanceof DirectBuffer ) { unsafe . copyMemory ( ( ( DirectBuffer ) buffer ) . address ( ) + buffer . position ( ) , peer + memoryOffset , buffer . remaining ( ) ) ; } else throw new IllegalStateException ( ) ; } public void setBytes ( long memoryOffset , byte [ ] buffer , int bufferOffset , int count ) { if ( buffer = = null ) throw new NullPointerException ( ) ; else if ( bufferOffset < <int> | | count < <int> | | bufferOffset + count > buffer . length ) throw new IndexOutOfBoundsException ( ) ; else if ( count = = <int> ) return ; checkBounds ( memoryOffset , memoryOffset + count ) ; unsafe . copyMemory ( buffer , BYTE_ARRAY_BASE_OFFSET + bufferOffset , null , peer + memoryOffset , count ) ; } public byte getByte ( long offset ) { checkBounds ( offset , offset + <int> ) ; return unsafe . getByte ( peer + offset ) ; } public long getLong ( long offset ) { checkBounds ( offset , offset + <int> ) ; if ( unaligned ) { return unsafe . getLong ( peer + offset ) ; } else { return getLongByByte ( peer + offset ) ; } } private long getLongByByte ( long address ) { if ( bigEndian ) { return ( ( ( long ) unsafe . getByte ( address ) ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) ) ; } else { return ( ( ( long ) unsafe . getByte ( address + <int> ) ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( long ) unsafe . getByte ( address ) & <hex> ) ) ; } } public int getInt ( long offset ) { checkBounds ( offset , offset + <int> ) ; if ( unaligned ) { return unsafe . getInt ( peer + offset ) ; } else { return getIntByByte ( peer + offset ) ; } } private int getIntByByte ( long address ) { if ( bigEndian ) { return ( ( ( int ) unsafe . getByte ( address ) ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address + <int> ) & <hex> ) ) ; } else { return ( ( ( int ) unsafe . getByte ( address + <int> ) ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address + <int> ) & <hex> ) < < <int> ) | ( ( ( int ) unsafe . getByte ( address ) & <hex> ) ) ; } } public void getBytes ( long memoryOffset , byte [ ] buffer , int bufferOffset , int count ) { if ( buffer = = null ) throw new NullPointerException ( ) ; else if ( bufferOffset < <int> | | count < <int> | | count > buffer . length - bufferOffset ) throw new IndexOutOfBoundsException ( ) ; else if ( count = = <int> ) return ; checkBounds ( memoryOffset , memoryOffset + count ) ; FastByteOperations . UnsafeOperations . copy ( null , peer + memoryOffset , buffer , bufferOffset , count ) ; } @Inline protected void checkBounds ( long start , long end ) { assert peer ! = <int> : <str> ; assert start > = <int> & & end < = size & & start < = end : <str> + start + <str> + end + <str> + size ; } public void put ( long trgOffset , Memory memory , long srcOffset , long size ) { checkBounds ( trgOffset , trgOffset + size ) ; memory . checkBounds ( srcOffset , srcOffset + size ) ; unsafe . copyMemory ( memory . peer + srcOffset , peer + trgOffset , size ) ; } public Memory copy ( long newSize ) { Memory copy = Memory . allocate ( newSize ) ; copy . put ( <int> , this , <int> , Math . min ( size ( ) , newSize ) ) ; return copy ; } public void free ( ) { if ( peer ! = <int> ) MemoryUtil . free ( peer ) ; else assert size = = <int> ; peer = <int> ; } public void close ( ) { free ( ) ; } public long size ( ) { assert peer ! = <int> ; return size ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Memory ) ) return false ; Memory b = ( Memory ) o ; if ( peer = = b . peer & & size = = b . size ) return true ; return false ; } public ByteBuffer [ ] asByteBuffers ( long offset , long length ) { checkBounds ( offset , offset + length ) ; if ( size ( ) = = <int> ) return NO_BYTE_BUFFERS ; ByteBuffer [ ] result = new ByteBuffer [ ( int ) ( length / Integer . MAX_VALUE ) + <int> ] ; int size = ( int ) ( size ( ) / result . length ) ; for ( int i = <int> ; i < result . length - <int> ; i + + ) { result [ i ] = MemoryUtil . getByteBuffer ( peer + offset , size ) ; offset + = size ; length - = size ; } result [ result . length - <int> ] = MemoryUtil . getByteBuffer ( peer + offset , ( int ) length ) ; return result ; } public ByteBuffer asByteBuffer ( long offset , int length ) { checkBounds ( offset , offset + length ) ; return MemoryUtil . getByteBuffer ( peer + offset , length ) ; } public void setByteBuffer ( ByteBuffer buffer , long offset , int length ) { checkBounds ( offset , offset + length ) ; MemoryUtil . setByteBuffer ( buffer , peer + offset , length ) ; } public String toString ( ) { return toString ( peer , size ) ; } protected static String toString ( long peer , long size ) { return String . format ( <str> , peer , peer + size ) ; } }