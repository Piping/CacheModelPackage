package io . netty . example . http . websocketx . benchmarkserver ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . websocketx . BinaryWebSocketFrame ; import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; import io . netty . handler . codec . http . websocketx . PingWebSocketFrame ; import io . netty . handler . codec . http . websocketx . PongWebSocketFrame ; import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; import io . netty . handler . codec . http . websocketx . WebSocketFrame ; import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; import io . netty . handler . codec . http . websocketx . WebSocketServerHandshakerFactory ; import io . netty . util . CharsetUtil ; import static io . netty . handler . codec . http . HttpMethod . * ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . * ; public class WebSocketServerHandler extends SimpleChannelInboundHandler < Object > { private static final String WEBSOCKET_PATH = <str> ; private WebSocketServerHandshaker handshaker ; @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) { if ( msg instanceof FullHttpRequest ) { handleHttpRequest ( ctx , ( FullHttpRequest ) msg ) ; } else if ( msg instanceof WebSocketFrame ) { handleWebSocketFrame ( ctx , ( WebSocketFrame ) msg ) ; } } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) { ctx . flush ( ) ; } private void handleHttpRequest ( ChannelHandlerContext ctx , FullHttpRequest req ) { if ( ! req . decoderResult ( ) . isSuccess ( ) ) { sendHttpResponse ( ctx , req , new DefaultFullHttpResponse ( HTTP_1_1 , BAD_REQUEST ) ) ; return ; } if ( req . method ( ) ! = GET ) { sendHttpResponse ( ctx , req , new DefaultFullHttpResponse ( HTTP_1_1 , FORBIDDEN ) ) ; return ; } if ( <str> . equals ( req . uri ( ) ) ) { ByteBuf content = WebSocketServerBenchmarkPage . getContent ( getWebSocketLocation ( req ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HTTP_1_1 , OK , content ) ; res . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; HttpUtil . setContentLength ( res , content . readableBytes ( ) ) ; sendHttpResponse ( ctx , req , res ) ; return ; } if ( <str> . equals ( req . uri ( ) ) ) { FullHttpResponse res = new DefaultFullHttpResponse ( HTTP_1_1 , NOT_FOUND ) ; sendHttpResponse ( ctx , req , res ) ; return ; } WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( getWebSocketLocation ( req ) , null , true , <int> * <int> * <int> ) ; handshaker = wsFactory . newHandshaker ( req ) ; if ( handshaker = = null ) { WebSocketServerHandshakerFactory . sendUnsupportedVersionResponse ( ctx . channel ( ) ) ; } else { handshaker . handshake ( ctx . channel ( ) , req ) ; } } private void handleWebSocketFrame ( ChannelHandlerContext ctx , WebSocketFrame frame ) { if ( frame instanceof CloseWebSocketFrame ) { handshaker . close ( ctx . channel ( ) , ( CloseWebSocketFrame ) frame . retain ( ) ) ; return ; } if ( frame instanceof PingWebSocketFrame ) { ctx . write ( new PongWebSocketFrame ( frame . content ( ) . retain ( ) ) ) ; return ; } if ( frame instanceof TextWebSocketFrame ) { ctx . write ( frame . retain ( ) ) ; return ; } if ( frame instanceof BinaryWebSocketFrame ) { ctx . write ( frame . retain ( ) ) ; return ; } } private static void sendHttpResponse ( ChannelHandlerContext ctx , FullHttpRequest req , FullHttpResponse res ) { if ( res . status ( ) . code ( ) ! = <int> ) { ByteBuf buf = Unpooled . copiedBuffer ( res . status ( ) . toString ( ) , CharsetUtil . UTF_8 ) ; res . content ( ) . writeBytes ( buf ) ; buf . release ( ) ; HttpUtil . setContentLength ( res , res . content ( ) . readableBytes ( ) ) ; } ChannelFuture f = ctx . channel ( ) . writeAndFlush ( res ) ; if ( ! HttpUtil . isKeepAlive ( req ) | | res . status ( ) . code ( ) ! = <int> ) { f . addListener ( ChannelFutureListener . CLOSE ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } private static String getWebSocketLocation ( FullHttpRequest req ) { String location = req . headers ( ) . get ( HttpHeaderNames . HOST ) + WEBSOCKET_PATH ; if ( WebSocketServer . SSL ) { return <str> + location ; } else { return <str> + location ; } } }