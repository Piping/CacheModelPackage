package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . AbstractCollection ; import java . util . Objects ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . FBUtilities ; public abstract class AbstractRow extends AbstractCollection < ColumnData > implements Row { public Unfiltered . Kind kind ( ) { return Unfiltered . Kind . ROW ; } public boolean hasLiveData ( int nowInSec ) { if ( primaryKeyLivenessInfo ( ) . isLive ( nowInSec ) ) return true ; return Iterables . any ( cells ( ) , cell - > cell . isLive ( nowInSec ) ) ; } public boolean isStatic ( ) { return clustering ( ) = = Clustering . STATIC_CLUSTERING ; } public void digest ( MessageDigest digest ) { FBUtilities . updateWithByte ( digest , kind ( ) . ordinal ( ) ) ; clustering ( ) . digest ( digest ) ; deletion ( ) . digest ( digest ) ; primaryKeyLivenessInfo ( ) . digest ( digest ) ; for ( ColumnData cd : this ) cd . digest ( digest ) ; } public void validateData ( CFMetaData metadata ) { Clustering clustering = clustering ( ) ; for ( int i = <int> ; i < clustering . size ( ) ; i + + ) { ByteBuffer value = clustering . get ( i ) ; if ( value ! = null ) metadata . comparator . subtype ( i ) . validate ( value ) ; } primaryKeyLivenessInfo ( ) . validate ( ) ; if ( deletion ( ) . time ( ) . localDeletionTime ( ) < <int> ) throw new MarshalException ( <str> ) ; for ( ColumnData cd : this ) cd . validate ( ) ; } public String toString ( CFMetaData metadata ) { return toString ( metadata , false ) ; } public String toString ( CFMetaData metadata , boolean fullDetails ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; if ( fullDetails ) { sb . append ( <str> ) . append ( primaryKeyLivenessInfo ( ) ) ; if ( ! deletion ( ) . isLive ( ) ) sb . append ( <str> ) . append ( deletion ( ) ) ; sb . append ( <str> ) ; } sb . append ( <str> ) . append ( clustering ( ) . toString ( metadata ) ) . append ( <str> ) ; boolean isFirst = true ; for ( ColumnData cd : this ) { if ( isFirst ) isFirst = false ; else sb . append ( <str> ) ; if ( fullDetails ) { if ( cd . column ( ) . isSimple ( ) ) { sb . append ( cd ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; if ( ! complexData . complexDeletion ( ) . isLive ( ) ) sb . append ( <str> ) . append ( cd . column ( ) . name ) . append ( <str> ) . append ( complexData . complexDeletion ( ) ) ; for ( Cell cell : complexData ) sb . append ( <str> ) . append ( cell ) ; } } else { if ( cd . column ( ) . isSimple ( ) ) { Cell cell = ( Cell ) cd ; sb . append ( cell . column ( ) . name ) . append ( <str> ) ; if ( cell . isTombstone ( ) ) sb . append ( <str> ) ; else sb . append ( cell . column ( ) . type . getString ( cell . value ( ) ) ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; CollectionType ct = ( CollectionType ) cd . column ( ) . type ; sb . append ( cd . column ( ) . name ) . append ( <str> ) ; int i = <int> ; for ( Cell cell : complexData ) { sb . append ( i + + = = <int> ? <str> : <str> ) ; sb . append ( ct . nameComparator ( ) . getString ( cell . path ( ) . get ( <int> ) ) ) . append ( <str> ) . append ( ct . valueComparator ( ) . getString ( cell . value ( ) ) ) ; } sb . append ( <str> ) ; } } } return sb . toString ( ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof Row ) ) return false ; Row that = ( Row ) other ; if ( ! this . clustering ( ) . equals ( that . clustering ( ) ) | | ! this . primaryKeyLivenessInfo ( ) . equals ( that . primaryKeyLivenessInfo ( ) ) | | ! this . deletion ( ) . equals ( that . deletion ( ) ) ) return false ; return Iterables . elementsEqual ( this , that ) ; } @Override public int hashCode ( ) { int hash = Objects . hash ( clustering ( ) , columns ( ) , primaryKeyLivenessInfo ( ) , deletion ( ) ) ; for ( ColumnData cd : this ) hash + = <int> * cd . hashCode ( ) ; return hash ; } }