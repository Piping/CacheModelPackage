package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObjectWrapper ; import com . badlogic . gdx . physics . bullet . collision . btCollisionWorld ; import com . badlogic . gdx . physics . bullet . collision . ContactResultCallback ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btManifoldPoint ; public class CollisionWorldTest extends BaseBulletTest { BulletEntity movingBox ; boolean hit = false ; Color normalColor = new Color ( ) ; btCollisionObject other ; public class TestContactResultCallback extends ContactResultCallback { @Override public float addSingleResult ( btManifoldPoint cp , btCollisionObjectWrapper colObj0Wrap , int partId0 , int index0 , btCollisionObjectWrapper colObj1Wrap , int partId1 , int index1 ) { hit = true ; other = colObj0Wrap . getCollisionObject ( ) = = movingBox . body ? colObj1Wrap . getCollisionObject ( ) : colObj0Wrap . getCollisionObject ( ) ; return <int> f ; } } TestContactResultCallback contactCB ; @Override public BulletWorld createWorld ( ) { btDefaultCollisionConfiguration collisionConfig = new btDefaultCollisionConfiguration ( ) ; btCollisionDispatcher dispatcher = new btCollisionDispatcher ( collisionConfig ) ; btDbvtBroadphase broadphase = new btDbvtBroadphase ( ) ; btCollisionWorld collisionWorld = new btCollisionWorld ( dispatcher , broadphase , collisionConfig ) ; return new BulletWorld ( collisionConfig , dispatcher , broadphase , null , collisionWorld ) ; } @Override public void create ( ) { super . create ( ) ; instructions = <str> ; contactCB = new TestContactResultCallback ( ) ; Model groundModel = world . getConstructor ( <str> ) . model ; Model boxModel = world . getConstructor ( <str> ) . model ; world . addConstructor ( <str> , new BulletConstructor ( groundModel ) ) ; world . addConstructor ( <str> , new BulletConstructor ( boxModel ) ) ; world . add ( <str> , <int> f , <int> f , <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; world . add ( <str> , <int> f , <int> f , <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; world . add ( <str> , <int> f , <int> f , - <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; world . add ( <str> , <int> f , <int> f , <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; world . add ( <str> , - <int> f , <int> f , <int> f ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; movingBox = world . add ( <str> , - <int> f , <int> f , <int> f ) ; normalColor . set ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <int> f ) ; } Color tmpColor = new Color ( ) ; @Override public void render ( ) { movingBox . transform . val [ Matrix4 . M03 ] = movingBox . transform . val [ Matrix4 . M13 ] = movingBox . transform . val [ Matrix4 . M23 ] = <int> f ; movingBox . transform . rotate ( Vector3 . Y , Gdx . graphics . getDeltaTime ( ) * <int> f ) ; movingBox . transform . translate ( - <int> f , <int> f , <int> f ) ; movingBox . body . setWorldTransform ( movingBox . transform ) ; super . render ( ) ; } @Override public void update ( ) { super . update ( ) ; if ( world . performanceCounter ! = null ) world . performanceCounter . start ( ) ; world . collisionWorld . performDiscreteCollisionDetection ( ) ; if ( world . performanceCounter ! = null ) world . performanceCounter . stop ( ) ; } @Override protected void renderWorld ( ) { hit = false ; other = null ; world . collisionWorld . contactTest ( movingBox . body , contactCB ) ; movingBox . setColor ( hit ? Color . RED : normalColor ) ; BulletEntity e = null ; if ( other ! = null & & other . userData ! = null & & other . userData instanceof BulletEntity ) { e = ( BulletEntity ) ( other . userData ) ; tmpColor . set ( e . getColor ( ) ) ; e . setColor ( Color . RED ) ; } super . renderWorld ( ) ; if ( e ! = null ) e . setColor ( tmpColor ) ; } @Override public void dispose ( ) { super . dispose ( ) ; movingBox = null ; } }