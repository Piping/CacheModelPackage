package org . nd4j . linalg . api . ops . impl . scalar . comparison ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseScalarOp ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; public class ScalarEquals extends BaseScalarOp { public ScalarEquals ( ) { } public ScalarEquals ( INDArray x , INDArray y , INDArray z , int n , Number num ) { super ( x , y , z , n , num ) ; } public ScalarEquals ( INDArray x , Number num ) { super ( x , num ) ; } public ScalarEquals ( INDArray x , INDArray y , INDArray z , int n , IComplexNumber num ) { super ( x , y , z , n , num ) ; } public ScalarEquals ( INDArray x , IComplexNumber num ) { super ( x , num ) ; } public ScalarEquals ( INDArray x ) { this ( x , <int> ) ; } @Override public String name ( ) { return <str> ; } @Override public IComplexNumber op ( IComplexNumber origin , double other ) { return origin . absoluteValue ( ) . doubleValue ( ) = = num . doubleValue ( ) ? Nd4j . createComplexNumber ( <int> , <int> ) : Nd4j . createComplexNumber ( <int> , <int> ) ; } @Override public IComplexNumber op ( IComplexNumber origin , float other ) { return origin . absoluteValue ( ) . doubleValue ( ) = = num . doubleValue ( ) ? Nd4j . createComplexNumber ( <int> , <int> ) : Nd4j . createComplexNumber ( <int> , <int> ) ; } @Override public IComplexNumber op ( IComplexNumber origin , IComplexNumber other ) { return origin . absoluteValue ( ) . doubleValue ( ) = = num . doubleValue ( ) ? Nd4j . createComplexNumber ( <int> , <int> ) : Nd4j . createComplexNumber ( <int> , <int> ) ; } @Override public float op ( float origin , float other ) { return origin = = num . floatValue ( ) ? <int> : <int> ; } @Override public double op ( double origin , double other ) { return origin = = num . doubleValue ( ) ? <int> : <int> ; } @Override public double op ( double origin ) { return origin = = num . doubleValue ( ) ? <int> : <int> ; } @Override public float op ( float origin ) { return origin = = num . floatValue ( ) ? <int> : <int> ; } @Override public IComplexNumber op ( IComplexNumber origin ) { return origin . absoluteValue ( ) . doubleValue ( ) = = num . doubleValue ( ) ? Nd4j . createComplexNumber ( <int> , <int> ) : Nd4j . createComplexNumber ( <int> , <int> ) ; } @Override public Op opForDimension ( int index , int dimension ) { if ( num ! = null ) return new ScalarEquals ( x . vectorAlongDimension ( index , dimension ) , num ) ; else return new ScalarEquals ( x . vectorAlongDimension ( index , dimension ) , complexNumber ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { if ( num ! = null ) return new ScalarEquals ( x . tensorAlongDimension ( index , dimension ) , num ) ; else return new ScalarEquals ( x . tensorAlongDimension ( index , dimension ) , complexNumber ) ; } @Override public int [ ] getDimension ( ) { return new int [ <int> ] ; } @Override public void setDimension ( int . . . dimension ) { } }