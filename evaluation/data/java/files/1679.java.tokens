package com . google . common . testing ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableList ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . List ; public class AbstractPackageSanityTestsTest extends TestCase { private final AbstractPackageSanityTests sanityTests = new AbstractPackageSanityTests ( ) { } ; public void testFindClassesToTest_testClass ( ) { assertThat ( findClassesToTest ( ImmutableList . of ( EmptyTest . class ) ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( EmptyTests . class ) ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( EmptyTestCase . class ) ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( EmptyTestSuite . class ) ) ) . isEmpty ( ) ; } public void testFindClassesToTest_noCorrespondingTestClass ( ) { assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class ) ) ) . containsExactly ( Foo . class ) ; assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , Foo2Test . class ) ) ) . containsExactly ( Foo . class ) ; } public void testFindClassesToTest_publicApiOnly ( ) { sanityTests . publicApiOnly ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class ) ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( PublicFoo . class ) ) ) . contains ( PublicFoo . class ) ; } public void testFindClassesToTest_ignoreClasses ( ) { sanityTests . ignoreClasses ( Predicates . < Object > equalTo ( PublicFoo . class ) ) ; assertThat ( findClassesToTest ( ImmutableList . of ( PublicFoo . class ) ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class ) ) ) . contains ( Foo . class ) ; } public void testFindClassesToTeset_ignoreUnderscores ( ) { assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , Foo_Bar . class ) ) ) . containsExactly ( Foo . class , Foo_Bar . class ) ; sanityTests . ignoreClasses ( AbstractPackageSanityTests . UNDERSCORE_IN_NAME ) ; assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , Foo_Bar . class ) ) ) . containsExactly ( Foo . class ) ; } public void testFindClassesToTest_withCorrespondingTestClassButNotExplicitlyTested ( ) { assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , FooTest . class ) , <str> ) ) . containsExactly ( Foo . class ) ; assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , FooTest . class ) , <str> ) ) . containsExactly ( Foo . class ) ; } public void testFindClassesToTest_withCorrespondingTestClassAndExplicitlyTested ( ) { ImmutableList < Class < ? extends Object > > classes = ImmutableList . of ( Foo . class , FooTest . class ) ; assertThat ( findClassesToTest ( classes , <str> ) ) . isEmpty ( ) ; assertThat ( findClassesToTest ( classes , <str> , <str> ) ) . isEmpty ( ) ; } public void testFindClassesToTest_withCorrespondingTestClass_noTestName ( ) { assertThat ( findClassesToTest ( ImmutableList . of ( Foo . class , FooTest . class ) ) ) . containsExactly ( Foo . class ) ; } static class EmptyTestCase { } static class EmptyTest { } static class EmptyTests { } static class EmptyTestSuite { } static class Foo { } static class Foo_Bar { } public static class PublicFoo { } static class FooTest { @SuppressWarnings ( <str> ) public void testPublic ( ) { } @SuppressWarnings ( <str> ) void testNotPublic ( ) { } } static class Foo2Test { @SuppressWarnings ( <str> ) public void testPublic ( ) { } } private List < Class < ? > > findClassesToTest ( Iterable < ? extends Class < ? > > classes , String . . . explicitTestNames ) { return sanityTests . findClassesToTest ( classes , Arrays . asList ( explicitTestNames ) ) ; } }