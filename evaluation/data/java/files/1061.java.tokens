package org . elasticsearch . search . highlight ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . index . mapper . FieldMapper ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; public class CustomHighlighter implements Highlighter { @Override public HighlightField highlight ( HighlighterContext highlighterContext ) { SearchContextHighlight . Field field = highlighterContext . field ; CacheEntry cacheEntry = ( CacheEntry ) highlighterContext . hitContext . cache ( ) . get ( <str> ) ; final int docId = highlighterContext . hitContext . readerContext ( ) . docBase + highlighterContext . hitContext . docId ( ) ; if ( cacheEntry = = null ) { cacheEntry = new CacheEntry ( ) ; highlighterContext . hitContext . cache ( ) . put ( <str> , cacheEntry ) ; cacheEntry . docId = docId ; cacheEntry . position = <int> ; } else { if ( cacheEntry . docId = = docId ) { cacheEntry . position + + ; } else { cacheEntry . docId = docId ; cacheEntry . position = <int> ; } } List < Text > responses = new ArrayList < > ( ) ; responses . add ( new StringText ( String . format ( Locale . ENGLISH , <str> , field . field ( ) , cacheEntry . position ) ) ) ; if ( field . fieldOptions ( ) . options ( ) ! = null ) { for ( Map . Entry < String , Object > entry : field . fieldOptions ( ) . options ( ) . entrySet ( ) ) { responses . add ( new StringText ( <str> + entry . getKey ( ) + <str> + entry . getValue ( ) ) ) ; } } return new HighlightField ( highlighterContext . fieldName , responses . toArray ( new Text [ ] { } ) ) ; } @Override public boolean canHighlight ( FieldMapper fieldMapper ) { return true ; } private static class CacheEntry { private int position ; private int docId ; } } 
