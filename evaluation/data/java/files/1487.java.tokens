package io . netty . handler . codec . compression ; import com . jcraft . jzlib . Deflater ; import com . jcraft . jzlib . JZlib ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseNotifier ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . OneTimeTask ; import java . util . concurrent . TimeUnit ; public class JZlibEncoder extends ZlibEncoder { private final int wrapperOverhead ; private final Deflater z = new Deflater ( ) ; private volatile boolean finished ; private volatile ChannelHandlerContext ctx ; public JZlibEncoder ( ) { this ( <int> ) ; } public JZlibEncoder ( int compressionLevel ) { this ( ZlibWrapper . ZLIB , compressionLevel ) ; } public JZlibEncoder ( ZlibWrapper wrapper ) { this ( wrapper , <int> ) ; } public JZlibEncoder ( ZlibWrapper wrapper , int compressionLevel ) { this ( wrapper , compressionLevel , <int> , <int> ) ; } public JZlibEncoder ( ZlibWrapper wrapper , int compressionLevel , int windowBits , int memLevel ) { if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( windowBits < <int> | | windowBits > <int> ) { throw new IllegalArgumentException ( <str> + windowBits + <str> ) ; } if ( memLevel < <int> | | memLevel > <int> ) { throw new IllegalArgumentException ( <str> + memLevel + <str> ) ; } if ( wrapper = = null ) { throw new NullPointerException ( <str> ) ; } if ( wrapper = = ZlibWrapper . ZLIB_OR_NONE ) { throw new IllegalArgumentException ( <str> + ZlibWrapper . ZLIB_OR_NONE + <str> + <str> ) ; } int resultCode = z . init ( compressionLevel , windowBits , memLevel , ZlibUtil . convertWrapperType ( wrapper ) ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } wrapperOverhead = ZlibUtil . wrapperOverhead ( wrapper ) ; } public JZlibEncoder ( byte [ ] dictionary ) { this ( <int> , dictionary ) ; } public JZlibEncoder ( int compressionLevel , byte [ ] dictionary ) { this ( compressionLevel , <int> , <int> , dictionary ) ; } public JZlibEncoder ( int compressionLevel , int windowBits , int memLevel , byte [ ] dictionary ) { if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( windowBits < <int> | | windowBits > <int> ) { throw new IllegalArgumentException ( <str> + windowBits + <str> ) ; } if ( memLevel < <int> | | memLevel > <int> ) { throw new IllegalArgumentException ( <str> + memLevel + <str> ) ; } if ( dictionary = = null ) { throw new NullPointerException ( <str> ) ; } int resultCode ; resultCode = z . deflateInit ( compressionLevel , windowBits , memLevel , JZlib . W_ZLIB ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } else { resultCode = z . deflateSetDictionary ( dictionary , dictionary . length ) ; if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } } wrapperOverhead = ZlibUtil . wrapperOverhead ( ZlibWrapper . ZLIB ) ; } @Override public ChannelFuture close ( ) { return close ( ctx ( ) . channel ( ) . newPromise ( ) ) ; } @Override public ChannelFuture close ( final ChannelPromise promise ) { ChannelHandlerContext ctx = ctx ( ) ; EventExecutor executor = ctx . executor ( ) ; if ( executor . inEventLoop ( ) ) { return finishEncode ( ctx , promise ) ; } else { final ChannelPromise p = ctx . newPromise ( ) ; executor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelFuture f = finishEncode ( ctx ( ) , p ) ; f . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } ) ; return p ; } } private ChannelHandlerContext ctx ( ) { ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( <str> ) ; } return ctx ; } @Override public boolean isClosed ( ) { return finished ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { if ( finished ) { out . writeBytes ( in ) ; return ; } int inputLength = in . readableBytes ( ) ; if ( inputLength = = <int> ) { return ; } try { boolean inHasArray = in . hasArray ( ) ; z . avail_in = inputLength ; if ( inHasArray ) { z . next_in = in . array ( ) ; z . next_in_index = in . arrayOffset ( ) + in . readerIndex ( ) ; } else { byte [ ] array = new byte [ inputLength ] ; in . getBytes ( in . readerIndex ( ) , array ) ; z . next_in = array ; z . next_in_index = <int> ; } int oldNextInIndex = z . next_in_index ; int maxOutputLength = ( int ) Math . ceil ( inputLength * <float> ) + <int> + wrapperOverhead ; out . ensureWritable ( maxOutputLength ) ; z . avail_out = maxOutputLength ; z . next_out = out . array ( ) ; z . next_out_index = out . arrayOffset ( ) + out . writerIndex ( ) ; int oldNextOutIndex = z . next_out_index ; int resultCode ; try { resultCode = z . deflate ( JZlib . Z_SYNC_FLUSH ) ; } finally { in . skipBytes ( z . next_in_index - oldNextInIndex ) ; } if ( resultCode ! = JZlib . Z_OK ) { ZlibUtil . fail ( z , <str> , resultCode ) ; } int outputLength = z . next_out_index - oldNextOutIndex ; if ( outputLength > <int> ) { out . writerIndex ( out . writerIndex ( ) + outputLength ) ; } } finally { z . next_in = null ; z . next_out = null ; } } @Override public void close ( final ChannelHandlerContext ctx , final ChannelPromise promise ) { ChannelFuture f = finishEncode ( ctx , ctx . newPromise ( ) ) ; f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture f ) throws Exception { ctx . close ( promise ) ; } } ) ; if ( ! f . isDone ( ) ) { ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { ctx . close ( promise ) ; } } , <int> , TimeUnit . SECONDS ) ; } } private ChannelFuture finishEncode ( ChannelHandlerContext ctx , ChannelPromise promise ) { if ( finished ) { promise . setSuccess ( ) ; return promise ; } finished = true ; ByteBuf footer ; try { z . next_in = EmptyArrays . EMPTY_BYTES ; z . next_in_index = <int> ; z . avail_in = <int> ; byte [ ] out = new byte [ <int> ] ; z . next_out = out ; z . next_out_index = <int> ; z . avail_out = out . length ; int resultCode = z . deflate ( JZlib . Z_FINISH ) ; if ( resultCode ! = JZlib . Z_OK & & resultCode ! = JZlib . Z_STREAM_END ) { promise . setFailure ( ZlibUtil . deflaterException ( z , <str> , resultCode ) ) ; return promise ; } else if ( z . next_out_index ! = <int> ) { footer = Unpooled . wrappedBuffer ( out , <int> , z . next_out_index ) ; } else { footer = Unpooled . EMPTY_BUFFER ; } } finally { z . deflateEnd ( ) ; z . next_in = null ; z . next_out = null ; } return ctx . writeAndFlush ( footer , promise ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; } } 
