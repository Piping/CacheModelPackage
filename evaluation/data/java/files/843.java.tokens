package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . * ; import org . junit . BeforeClass ; import org . junit . Test ; import static org . junit . Assert . fail ; import static org . junit . Assert . assertEquals ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . * ; public class CompositeTypeTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARDCOMPOSITE = <str> ; private static final CompositeType comparator ; static { List < AbstractType < ? > > subComparators = new ArrayList < AbstractType < ? > > ( ) ; subComparators . add ( BytesType . instance ) ; subComparators . add ( TimeUUIDType . instance ) ; subComparators . add ( IntegerType . instance ) ; comparator = CompositeType . getInstance ( subComparators ) ; } private static final int UUID_COUNT = <int> ; private static final UUID [ ] uuids = new UUID [ UUID_COUNT ] ; static { for ( int i = <int> ; i < UUID_COUNT ; + + i ) uuids [ i ] = UUIDGen . getTimeUUID ( ) ; } @BeforeClass public static void defineSchema ( ) throws ConfigurationException { AbstractType < ? > composite = CompositeType . getInstance ( Arrays . asList ( new AbstractType < ? > [ ] { BytesType . instance , TimeUUIDType . instance , IntegerType . instance } ) ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . denseCFMD ( KEYSPACE1 , CF_STANDARDCOMPOSITE , composite ) ) ; } @Test public void testEndOfComponent ( ) { ByteBuffer [ ] cnames = { createCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) , createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) , createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , } ; ByteBuffer start = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) ; ByteBuffer stop = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; for ( int i = <int> ; i < <int> ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) > <int> ; assert comparator . compare ( stop , cnames [ i ] ) > <int> ; } for ( int i = <int> ; i < <int> ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) < <int> ; assert comparator . compare ( stop , cnames [ i ] ) > <int> ; } for ( int i = <int> ; i < cnames . length ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) < <int> ; assert comparator . compare ( stop , cnames [ i ] ) < <int> ; } } @Test public void testGetString ( ) { String test1Hex = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( <str> ) ) ; ByteBuffer key = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; assert comparator . getString ( key ) . equals ( test1Hex + <str> + uuids [ <int> ] + <str> ) ; key = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; assert comparator . getString ( key ) . equals ( test1Hex + <str> + uuids [ <int> ] + <str> ) ; } @Test public void testFromString ( ) { String test1Hex = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( <str> ) ) ; ByteBuffer key = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; assert key . equals ( comparator . fromString ( test1Hex + <str> + uuids [ <int> ] + <str> ) ) ; key = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; assert key . equals ( comparator . fromString ( test1Hex + <str> + uuids [ <int> ] + <str> ) ) ; } @Test public void testValidate ( ) { ByteBuffer key = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; comparator . validate ( key ) ; key = createCompositeKey ( <str> , null , - <int> , false ) ; comparator . validate ( key ) ; key = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; comparator . validate ( key ) ; key . get ( ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { } key = ByteBuffer . allocate ( <int> + <str> . length ( ) + <int> + <int> ) ; key . putShort ( ( short ) <str> . length ( ) ) ; key . put ( ByteBufferUtil . bytes ( <str> ) ) ; key . put ( ( byte ) <int> ) ; key . putShort ( ( short ) <int> ) ; key . rewind ( ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { assert e . toString ( ) . contains ( <str> ) ; } key = createCompositeKey ( <str> , UUID . randomUUID ( ) , <int> , false ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { assert e . toString ( ) . contains ( <str> ) ; } } @Test public void testFullRound ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARDCOMPOSITE ) ; ByteBuffer cname1 = createCompositeKey ( <str> , null , - <int> , false ) ; ByteBuffer cname2 = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer cname3 = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer cname4 = createCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) ; ByteBuffer cname5 = createCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; long ts = FBUtilities . timestampMicros ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname5 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname1 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname4 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname2 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname3 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; ColumnDefinition cdef = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; ImmutableBTreePartition readPartition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; Iterator < Row > iter = readPartition . iterator ( ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; } private void compareValues ( Cell c , String r ) throws CharacterCodingException { assert ByteBufferUtil . string ( c . value ( ) ) . equals ( r ) : <str> + ByteBufferUtil . string ( c . value ( ) ) + <str> + r + <str> ; } @Test public void testEmptyParametersNotallowed ( ) { try { TypeParser . parse ( <str> ) ; fail ( <str> ) ; } catch ( ConfigurationException e ) { } catch ( SyntaxException e ) { } try { TypeParser . parse ( <str> ) ; fail ( <str> ) ; } catch ( ConfigurationException e ) { } catch ( SyntaxException e ) { } } @Test public void testCompatibility ( ) throws Exception { assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert ! TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert ! TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; } @Test public void testEscapeUnescape ( ) { List < AbstractType < ? > > subComparators = new ArrayList < AbstractType < ? > > ( ) { { ; add ( UTF8Type . instance ) ; add ( UTF8Type . instance ) ; } } ; CompositeType comp = CompositeType . getInstance ( subComparators ) ; String [ ] [ ] inputs = new String [ ] [ ] { new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , } ; for ( String [ ] input : inputs ) { CompositeType . Builder builder = new CompositeType . Builder ( comp ) ; for ( String part : input ) builder . add ( UTF8Type . instance . fromString ( part ) ) ; ByteBuffer value = comp . fromString ( comp . getString ( builder . build ( ) ) ) ; ByteBuffer [ ] splitted = comp . split ( value ) ; for ( int i = <int> ; i < splitted . length ; i + + ) assertEquals ( input [ i ] , UTF8Type . instance . getString ( splitted [ i ] ) ) ; } } private ByteBuffer createCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne ) { ByteBuffer bytes = ByteBufferUtil . bytes ( s ) ; int totalSize = <int> ; if ( s ! = null ) { totalSize + = <int> + bytes . remaining ( ) + <int> ; if ( uuid ! = null ) { totalSize + = <int> + <int> + <int> ; if ( i ! = - <int> ) { totalSize + = <int> + <int> + <int> ; } } } ByteBuffer bb = ByteBuffer . allocate ( totalSize ) ; if ( s ! = null ) { bb . putShort ( ( short ) bytes . remaining ( ) ) ; bb . put ( bytes ) ; bb . put ( uuid = = null & & lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; if ( uuid ! = null ) { bb . putShort ( ( short ) <int> ) ; bb . put ( UUIDGen . decompose ( uuid ) ) ; bb . put ( i = = - <int> & & lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; if ( i ! = - <int> ) { bb . putShort ( ( short ) <int> ) ; bb . put ( ( byte ) i ) ; bb . put ( lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; } } } bb . rewind ( ) ; return bb ; } } 
