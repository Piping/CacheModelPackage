package org . elasticsearch . cluster . metadata ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . AbstractDiffable ; import org . elasticsearch . cluster . metadata . MetaData . Custom ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . loader . SettingsLoader ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . EnumSet ; import java . util . List ; public class RepositoriesMetaData extends AbstractDiffable < Custom > implements MetaData . Custom { public static final String TYPE = <str> ; public static final RepositoriesMetaData PROTO = new RepositoriesMetaData ( ) ; private final List < RepositoryMetaData > repositories ; public RepositoriesMetaData ( RepositoryMetaData . . . repositories ) { this . repositories = Arrays . asList ( repositories ) ; } public List < RepositoryMetaData > repositories ( ) { return this . repositories ; } public RepositoryMetaData repository ( String name ) { for ( RepositoryMetaData repository : repositories ) { if ( name . equals ( repository . name ( ) ) ) { return repository ; } } return null ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; RepositoriesMetaData that = ( RepositoriesMetaData ) o ; return repositories . equals ( that . repositories ) ; } @Override public int hashCode ( ) { return repositories . hashCode ( ) ; } @Override public String type ( ) { return TYPE ; } @Override public Custom readFrom ( StreamInput in ) throws IOException { RepositoryMetaData [ ] repository = new RepositoryMetaData [ in . readVInt ( ) ] ; for ( int i = <int> ; i < repository . length ; i + + ) { repository [ i ] = RepositoryMetaData . readFrom ( in ) ; } return new RepositoriesMetaData ( repository ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( repositories . size ( ) ) ; for ( RepositoryMetaData repository : repositories ) { repository . writeTo ( out ) ; } } @Override public RepositoriesMetaData fromXContent ( XContentParser parser ) throws IOException { XContentParser . Token token ; List < RepositoryMetaData > repository = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String name = parser . currentName ( ) ; if ( parser . nextToken ( ) ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> , name ) ; } String type = null ; Settings settings = Settings . EMPTY ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String currentFieldName = parser . currentName ( ) ; if ( <str> . equals ( currentFieldName ) ) { if ( parser . nextToken ( ) ! = XContentParser . Token . VALUE_STRING ) { throw new ElasticsearchParseException ( <str> , name ) ; } type = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { if ( parser . nextToken ( ) ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> , name ) ; } settings = Settings . settingsBuilder ( ) . put ( SettingsLoader . Helper . loadNestedFromMap ( parser . mapOrdered ( ) ) ) . build ( ) ; } else { throw new ElasticsearchParseException ( <str> , name , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , name ) ; } } if ( type = = null ) { throw new ElasticsearchParseException ( <str> , name ) ; } repository . add ( new RepositoryMetaData ( name , type , settings ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } return new RepositoriesMetaData ( repository . toArray ( new RepositoryMetaData [ repository . size ( ) ] ) ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { for ( RepositoryMetaData repository : repositories ) { toXContent ( repository , builder , params ) ; } return builder ; } @Override public EnumSet < MetaData . XContentContext > context ( ) { return MetaData . API_AND_GATEWAY ; } public static void toXContent ( RepositoryMetaData repository , XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( repository . name ( ) , XContentBuilder . FieldCaseConversion . NONE ) ; builder . field ( <str> , repository . type ( ) ) ; builder . startObject ( <str> ) ; repository . settings ( ) . toXContent ( builder , params ) ; builder . endObject ( ) ; builder . endObject ( ) ; } } 
