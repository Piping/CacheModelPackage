package org . apache . cassandra . dht ; import java . math . BigInteger ; import java . util . List ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public class KeyCollisionTest { static IPartitioner oldPartitioner ; private static final String KEYSPACE1 = <str> ; private static final String CF = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { oldPartitioner = StorageService . instance . setPartitionerUnsafe ( LengthPartitioner . instance ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF ) ) ; } @AfterClass public static void tearDown ( ) { DatabaseDescriptor . setPartitionerUnsafe ( oldPartitioner ) ; } @Test public void testGetSliceWithCollision ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . clearUnsafe ( ) ; insert ( <str> , <str> , <str> ) ; insert ( <str> , <str> , <str> ) ; insert ( <str> , <str> ) ; List < FilteredPartition > partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyIncl ( <str> ) . build ( ) ) ; assert partitions . get ( <int> ) . partitionKey ( ) . getKey ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ; assert partitions . get ( <int> ) . partitionKey ( ) . getKey ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ; assert partitions . get ( <int> ) . partitionKey ( ) . getKey ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ; assert partitions . get ( <int> ) . partitionKey ( ) . getKey ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ; } private void insert ( String . . . keys ) { for ( String key : keys ) insert ( key ) ; } private void insert ( String key ) { RowUpdateBuilder builder = new RowUpdateBuilder ( Schema . instance . getCFMetaData ( KEYSPACE1 , CF ) , FBUtilities . timestampMicros ( ) , key ) ; builder . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; } static class BigIntegerToken extends ComparableObjectToken < BigInteger > { private static final long serialVersionUID = <int> ; public BigIntegerToken ( BigInteger token ) { super ( token ) ; } public BigIntegerToken ( String token ) { this ( new BigInteger ( token ) ) ; } @Override public IPartitioner getPartitioner ( ) { return LengthPartitioner . instance ; } @Override public long getHeapSize ( ) { return <int> ; } } } 
