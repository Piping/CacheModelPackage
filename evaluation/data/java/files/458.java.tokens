package rx . observables ; import static org . junit . Assert . * ; import static org . mockito . Matchers . * ; import static org . mockito . Mockito . * ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . * ; import org . junit . Test ; import org . mockito . * ; import rx . * ; import rx . Observable ; import rx . Observable . * ; import rx . Observer ; import rx . exceptions . TestException ; import rx . functions . * ; import rx . observers . TestSubscriber ; import rx . schedulers . * ; public class SyncOnSubscribeTest { @Test public void testObservableJustEquivalent ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onNext ( <int> ) ; subscriber . onCompleted ( ) ; } } ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . create ( os ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; } @Test public void testStateAfterTerminal ( ) { final AtomicInteger finalStateValue = new AtomicInteger ( - <int> ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > subscriber ) { subscriber . onNext ( state ) ; subscriber . onCompleted ( ) ; return state + <int> ; } } , new Action1 < Integer > ( ) { @Override public void call ( Integer t ) { finalStateValue . set ( t ) ; } } ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . create ( os ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminalEvent ( ) ; ts . assertValue ( <int> ) ; assertEquals ( <int> , finalStateValue . get ( ) ) ; } @Test public void testMultipleOnNextValuesCallsOnError ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onNext ( <int> ) ; subscriber . onNext ( <int> ) ; subscriber . onCompleted ( ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , times ( <int> ) ) . onNext ( <int> ) ; verify ( o , never ( ) ) . onNext ( <int> ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o , times ( <int> ) ) . onError ( any ( IllegalStateException . class ) ) ; } @Test public void testMultipleOnCompleted ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onNext ( <int> ) ; subscriber . onCompleted ( ) ; subscriber . onCompleted ( ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , times ( <int> ) ) . onNext ( <int> ) ; verify ( o , times ( <int> ) ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testOnNextAfterOnComplete ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onNext ( <int> ) ; subscriber . onCompleted ( ) ; subscriber . onNext ( <int> ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , times ( <int> ) ) . onNext ( <int> ) ; verify ( o , times ( <int> ) ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @SuppressWarnings ( <str> ) private static class FooException extends RuntimeException { public FooException ( String string ) { super ( string ) ; } } @Test public void testMultipleOnErrors ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onNext ( <int> ) ; subscriber . onError ( new TestException ( <str> ) ) ; subscriber . onError ( new FooException ( <str> ) ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , times ( <int> ) ) . onNext ( <int> ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o , times ( <int> ) ) . onError ( isA ( TestException . class ) ) ; verify ( o , never ( ) ) . onError ( isA ( FooException . class ) ) ; } @Test public void testEmpty ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onCompleted ( ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o ) . onCompleted ( ) ; } @Test public void testNever ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { } } ) ; Observable < Integer > neverObservable = Observable . create ( os ) . subscribeOn ( Schedulers . newThread ( ) ) ; Observable < ? extends Number > merged = Observable . amb ( neverObservable , Observable . timer ( <int> , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; Iterator < ? extends Number > values = merged . toBlocking ( ) . toIterable ( ) . iterator ( ) ; assertTrue ( ( values . hasNext ( ) ) ) ; assertEquals ( <int> l , values . next ( ) ) ; } @Test public void testThrows ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { throw new TestException ( <str> ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; } @Test public void testThrowAfterCompleteFastPath ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onCompleted ( ) ; throw new TestException ( <str> ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o , times ( <int> ) ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testThrowsSlowPath ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { throw new TestException ( <str> ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; TestSubscriber < Object > ts = new TestSubscriber < Object > ( o ) { @Override public void onStart ( ) { requestMore ( <int> ) ; } } ; Observable . create ( os ) . subscribe ( ts ) ; ts . requestMore ( <int> ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o , times ( <int> ) ) . onError ( any ( TestException . class ) ) ; } @Test public void testError ( ) { OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > subscriber ) { subscriber . onError ( new TestException ( <str> ) ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; } @Test public void testRange ( ) { final int start = <int> ; final int count = <int> ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return start ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > subscriber ) { subscriber . onNext ( state ) ; if ( state = = count ) { subscriber . onCompleted ( ) ; } return state + <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onError ( any ( TestException . class ) ) ; inOrder . verify ( o , times ( count ) ) . onNext ( any ( Integer . class ) ) ; inOrder . verify ( o ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testFromIterable ( ) { int n = <int> ; final List < Integer > source = new ArrayList < Integer > ( ) ; for ( int i = <int> ; i < n ; i + + ) { source . add ( i ) ; } OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Iterator < Integer > > ( ) { @Override public Iterator < Integer > call ( ) { return source . iterator ( ) ; } } , new Func2 < Iterator < Integer > , Observer < ? super Integer > , Iterator < Integer > > ( ) { @Override public Iterator < Integer > call ( Iterator < Integer > it , Observer < ? super Integer > observer ) { if ( it . hasNext ( ) ) { observer . onNext ( it . next ( ) ) ; } if ( ! it . hasNext ( ) ) { observer . onCompleted ( ) ; } return it ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; Observable . create ( os ) . subscribe ( o ) ; verify ( o , never ( ) ) . onError ( any ( TestException . class ) ) ; inOrder . verify ( o , times ( n ) ) . onNext ( any ( ) ) ; inOrder . verify ( o ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testInfiniteTake ( ) { final int start = <int> ; final int finalCount = <int> ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return start ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > observer ) { observer . onNext ( state ) ; return state + <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; Observable . create ( os ) . take ( finalCount ) . subscribe ( o ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( o , times ( finalCount ) ) . onNext ( any ( ) ) ; inOrder . verify ( o ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testInfiniteRequestSome ( ) { final int finalCount = <int> ; final int start = <int> ; @SuppressWarnings ( <str> ) Action1 < ? super Integer > onUnSubscribe = mock ( Action1 . class ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return start ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > observer ) { observer . onNext ( state ) ; return state + <int> ; } } , onUnSubscribe ) ; TestSubscriber < Object > ts = new TestSubscriber < Object > ( <int> ) ; Observable . create ( os ) . subscribe ( ts ) ; ts . requestMore ( finalCount ) ; ts . assertNoErrors ( ) ; ts . assertNotCompleted ( ) ; ts . assertValueCount ( finalCount ) ; verify ( onUnSubscribe , never ( ) ) . call ( any ( Integer . class ) ) ; } @Test public void testUnsubscribeDownstream ( ) { @SuppressWarnings ( <str> ) Action1 < ? super Integer > onUnSubscribe = mock ( Action1 . class ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return null ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > observer ) { observer . onNext ( state ) ; return state ; } } , onUnSubscribe ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; TestSubscriber < Object > ts = new TestSubscriber < Object > ( o ) ; Observable . create ( os ) . take ( <int> ) . subscribe ( ts ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( onUnSubscribe , times ( <int> ) ) . call ( any ( Integer . class ) ) ; } @Test public void testConcurrentRequestsLoop ( ) throws InterruptedException { for ( int i = <int> ; i < <int> ; i + + ) { if ( i % <int> = = <int> ) { System . out . println ( <str> + i ) ; } testConcurrentRequests ( ) ; } } @Test public void testConcurrentRequests ( ) throws InterruptedException { final int count1 = <int> ; final int count2 = <int> ; final int finalCount = count1 + count2 ; final int start = <int> ; final CountDownLatch l1 = new CountDownLatch ( <int> ) ; final CountDownLatch l2 = new CountDownLatch ( <int> ) ; final CountDownLatch l3 = new CountDownLatch ( <int> ) ; final Action1 < Object > onUnSubscribe = new Action1 < Object > ( ) { @Override public void call ( Object t ) { l3 . countDown ( ) ; } } ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return start ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer state , Observer < ? super Integer > observer ) { l2 . countDown ( ) ; try { if ( ! l1 . await ( <int> , TimeUnit . SECONDS ) ) { observer . onError ( new TimeoutException ( ) ) ; return state + <int> ; } } catch ( InterruptedException e ) { observer . onError ( e ) ; return state + <int> ; } observer . onNext ( state ) ; if ( state = = finalCount ) { observer . onCompleted ( ) ; } return state + <int> ; } } , onUnSubscribe ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; final TestSubscriber < Object > ts = new TestSubscriber < Object > ( o ) ; Observable . create ( os ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( ts ) ; if ( ! l2 . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } ts . requestMore ( count2 ) ; l1 . countDown ( ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; inOrder . verify ( o , times ( finalCount ) ) . onNext ( any ( ) ) ; inOrder . verify ( o , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; if ( ! l3 . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } } @Test public void testUnsubscribeOutsideOfLoop ( ) throws InterruptedException { final AtomicInteger calledUnsubscribe = new AtomicInteger ( <int> ) ; final AtomicBoolean currentlyEvaluating = new AtomicBoolean ( false ) ; OnSubscribe < Void > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Void > > ( ) { @Override public void call ( Observer < ? super Void > observer ) { currentlyEvaluating . set ( true ) ; observer . onNext ( null ) ; currentlyEvaluating . set ( false ) ; } } , new Action0 ( ) { @Override public void call ( ) { calledUnsubscribe . incrementAndGet ( ) ; assertFalse ( currentlyEvaluating . get ( ) ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final TestSubscriber < Object > ts = new TestSubscriber < Object > ( o ) ; Observable . create ( os ) . lift ( new Operator < Void , Void > ( ) { @Override public Subscriber < ? super Void > call ( final Subscriber < ? super Void > subscriber ) { return new Subscriber < Void > ( subscriber ) { @Override public void setProducer ( Producer p ) { p . request ( <int> ) ; } @Override public void onCompleted ( ) { subscriber . onCompleted ( ) ; } @Override public void onError ( Throwable e ) { subscriber . onError ( e ) ; } @Override public void onNext ( final Void t ) { subscriber . onNext ( t ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { latch . await ( <int> , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } unsubscribe ( ) ; subscriber . onCompleted ( ) ; latch . countDown ( ) ; } } ) . start ( ) ; } } ; } } ) . subscribe ( ts ) ; latch . countDown ( ) ; ts . awaitTerminalEventAndUnsubscribeOnTimeout ( <int> , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertUnsubscribed ( ) ; assertEquals ( <int> , calledUnsubscribe . get ( ) ) ; } @Test public void testIndependentStates ( ) { int count = <int> ; final ConcurrentHashMap < Object , Object > subscribers = new ConcurrentHashMap < Object , Object > ( ) ; @SuppressWarnings ( <str> ) Action1 < ? super Map < Object , Object > > onUnSubscribe = mock ( Action1 . class ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( new Func0 < Map < Object , Object > > ( ) { @Override public Map < Object , Object > call ( ) { return subscribers ; } } , new Func2 < Map < Object , Object > , Observer < ? super Integer > , Map < Object , Object > > ( ) { @Override public Map < Object , Object > call ( Map < Object , Object > state , Observer < ? super Integer > observer ) { state . put ( observer , observer ) ; observer . onCompleted ( ) ; return state ; } } , onUnSubscribe ) ; Observable < Integer > source = Observable . create ( os ) ; for ( int i = <int> ; i < count ; i + + ) { source . subscribe ( ) ; } assertEquals ( count , subscribers . size ( ) ) ; verify ( onUnSubscribe , times ( count ) ) . call ( Matchers . < Map < Object , Object > > any ( ) ) ; } @Test ( timeout = <int> ) public void testSubscribeOn ( ) { final int start = <int> ; final int count = <int> ; final AtomicInteger countUnsubscribe = new AtomicInteger ( <int> ) ; final int numSubscribers = <int> ; OnSubscribe < Integer > os = SyncOnSubscribe . < Integer , Integer > createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return start ; } } , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer calls , Observer < ? super Integer > observer ) { if ( calls > count ) { observer . onCompleted ( ) ; } else { observer . onNext ( calls ) ; } return calls + <int> ; } } , new Action1 < Integer > ( ) { @Override public void call ( Integer t ) { countUnsubscribe . incrementAndGet ( ) ; } } ) ; List < TestSubscriber < Object > > subs = new ArrayList < TestSubscriber < Object > > ( numSubscribers ) ; for ( int i = <int> ; i < numSubscribers ; i + + ) { TestSubscriber < Object > ts = new TestSubscriber < Object > ( ) ; subs . add ( ts ) ; } TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > o2 = Observable . create ( os ) . subscribeOn ( scheduler ) ; for ( Subscriber < Object > ts : subs ) { o2 . subscribe ( ts ) ; } scheduler . triggerActions ( ) ; for ( TestSubscriber < Object > ts : subs ) { ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( count ) ; ts . assertCompleted ( ) ; } assertEquals ( numSubscribers , countUnsubscribe . get ( ) ) ; } @Test ( timeout = <int> ) public void testObserveOn ( ) { final int start = <int> ; final int count = <int> ; @SuppressWarnings ( <str> ) Action1 < ? super Integer > onUnSubscribe = mock ( Action1 . class ) ; @SuppressWarnings ( <str> ) Func0 < Integer > generator = mock ( Func0 . class ) ; Mockito . when ( generator . call ( ) ) . thenReturn ( start ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateful ( generator , new Func2 < Integer , Observer < ? super Integer > , Integer > ( ) { @Override public Integer call ( Integer calls , Observer < ? super Integer > observer ) { observer . onNext ( calls ) ; if ( calls = = count ) observer . onCompleted ( ) ; return calls + <int> ; } } , onUnSubscribe ) ; TestSubscriber < Object > ts = new TestSubscriber < Object > ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; Observable . create ( os ) . observeOn ( scheduler ) . subscribe ( ts ) ; scheduler . triggerActions ( ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; ts . assertCompleted ( ) ; ts . assertValueCount ( count ) ; verify ( generator , times ( <int> ) ) . call ( ) ; List < Object > events = ts . getOnNextEvents ( ) ; for ( int i = <int> ; i < events . size ( ) ; i + + ) { assertEquals ( i + <int> , events . get ( i ) ) ; } verify ( onUnSubscribe , times ( <int> ) ) . call ( any ( Integer . class ) ) ; } @Test public void testCanRequestInOnNext ( ) { Action0 onUnSubscribe = mock ( Action0 . class ) ; OnSubscribe < Integer > os = SyncOnSubscribe . createStateless ( new Action1 < Observer < ? super Integer > > ( ) { @Override public void call ( Observer < ? super Integer > observer ) { observer . onNext ( <int> ) ; observer . onCompleted ( ) ; } } , onUnSubscribe ) ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; Observable . create ( os ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { exception . set ( e ) ; } @Override public void onNext ( Integer t ) { request ( <int> ) ; } } ) ; if ( exception . get ( ) ! = null ) { exception . get ( ) . printStackTrace ( ) ; } assertNull ( exception . get ( ) ) ; verify ( onUnSubscribe , times ( <int> ) ) . call ( ) ; } @Test public void testExtendingBase ( ) { final AtomicReference < Object > lastState = new AtomicReference < Object > ( ) ; final AtomicInteger countUnsubs = new AtomicInteger ( <int> ) ; SyncOnSubscribe < Object , Object > sos = new SyncOnSubscribe < Object , Object > ( ) { @Override protected Object generateState ( ) { Object o = new Object ( ) ; lastState . set ( o ) ; return o ; } @Override protected Object next ( Object state , Observer < ? super Object > observer ) { observer . onNext ( lastState . get ( ) ) ; assertEquals ( lastState . get ( ) , state ) ; Object o = new Object ( ) ; lastState . set ( o ) ; return o ; } @Override protected void onUnsubscribe ( Object state ) { countUnsubs . incrementAndGet ( ) ; assertEquals ( lastState . get ( ) , state ) ; } } ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; TestSubscriber < Object > ts = new TestSubscriber < Object > ( o ) ; int count = <int> ; Observable . create ( sos ) . take ( count ) . subscribe ( ts ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , times ( count ) ) . onNext ( any ( Object . class ) ) ; verify ( o ) . onCompleted ( ) ; assertEquals ( <int> , countUnsubs . get ( ) ) ; } private interface FooQux { } private static class Foo implements FooQux { } private interface BarQux extends FooQux { } private static class Bar extends Foo implements BarQux { } @Test public void testGenericsCreateSingleState ( ) { Func0 < ? extends BarQux > generator = new Func0 < Bar > ( ) { @Override public Bar call ( ) { return new Bar ( ) ; } } ; Action2 < ? super BarQux , Observer < ? super FooQux > > next = new Action2 < BarQux , Observer < ? super FooQux > > ( ) { @Override public void call ( BarQux state , Observer < ? super FooQux > observer ) { observer . onNext ( state ) ; observer . onCompleted ( ) ; } } ; assertJustBehavior ( SyncOnSubscribe . createSingleState ( generator , next ) ) ; } @Test public void testGenericsCreateSingleStateWithUnsub ( ) { Func0 < ? extends BarQux > generator = new Func0 < Bar > ( ) { @Override public Bar call ( ) { return new Bar ( ) ; } } ; Action2 < ? super BarQux , Observer < ? super FooQux > > next = new Action2 < BarQux , Observer < ? super FooQux > > ( ) { @Override public void call ( BarQux state , Observer < ? super FooQux > observer ) { observer . onNext ( state ) ; observer . onCompleted ( ) ; } } ; Action1 < ? super BarQux > unsub = new Action1 < FooQux > ( ) { @Override public void call ( FooQux t ) { } } ; assertJustBehavior ( SyncOnSubscribe . createSingleState ( generator , next , unsub ) ) ; } @Test public void testGenericsCreateStateful ( ) { Func0 < ? extends BarQux > generator = new Func0 < Bar > ( ) { @Override public Bar call ( ) { return new Bar ( ) ; } } ; Func2 < ? super BarQux , Observer < ? super FooQux > , ? extends BarQux > next = new Func2 < BarQux , Observer < ? super FooQux > , BarQux > ( ) { @Override public BarQux call ( BarQux state , Observer < ? super FooQux > observer ) { observer . onNext ( state ) ; observer . onCompleted ( ) ; return state ; } } ; assertJustBehavior ( SyncOnSubscribe . createStateful ( generator , next ) ) ; } @Test public void testGenericsCreateStatefulWithUnsub ( ) { Func0 < ? extends BarQux > generator = new Func0 < Bar > ( ) { @Override public Bar call ( ) { return new Bar ( ) ; } } ; Func2 < ? super BarQux , Observer < ? super FooQux > , ? extends BarQux > next = new Func2 < BarQux , Observer < ? super FooQux > , BarQux > ( ) { @Override public BarQux call ( BarQux state , Observer < ? super FooQux > observer ) { observer . onNext ( state ) ; observer . onCompleted ( ) ; return state ; } } ; Action1 < ? super BarQux > unsub = new Action1 < FooQux > ( ) { @Override public void call ( FooQux t ) { } } ; OnSubscribe < FooQux > os = SyncOnSubscribe . createStateful ( generator , next , unsub ) ; assertJustBehavior ( os ) ; } @Test public void testGenericsCreateStateless ( ) { Action1 < Observer < ? super FooQux > > next = new Action1 < Observer < ? super FooQux > > ( ) { @Override public void call ( Observer < ? super FooQux > observer ) { observer . onNext ( new Foo ( ) ) ; observer . onCompleted ( ) ; } } ; OnSubscribe < FooQux > os = SyncOnSubscribe . createStateless ( next ) ; assertJustBehavior ( os ) ; } @Test public void testGenericsCreateStatelessWithUnsub ( ) { Action1 < Observer < ? super FooQux > > next = new Action1 < Observer < ? super FooQux > > ( ) { @Override public void call ( Observer < ? super FooQux > observer ) { observer . onNext ( new Foo ( ) ) ; observer . onCompleted ( ) ; } } ; Action0 unsub = new Action0 ( ) { @Override public void call ( ) { } } ; OnSubscribe < FooQux > os = SyncOnSubscribe . createStateless ( next , unsub ) ; assertJustBehavior ( os ) ; } private void assertJustBehavior ( OnSubscribe < FooQux > os ) { TestSubscriber < Object > ts = new TestSubscriber < Object > ( ) ; os . call ( ts ) ; ts . assertCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( <int> ) ; } @Test public void testConcurrentUnsubscribe3000Iterations ( ) throws InterruptedException , BrokenBarrierException , ExecutionException { ExecutorService exec = null ; try { exec = Executors . newSingleThreadExecutor ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { final AtomicInteger wip = new AtomicInteger ( ) ; Func0 < AtomicInteger > func0 = new Func0 < AtomicInteger > ( ) { @Override public AtomicInteger call ( ) { return wip ; } } ; Func2 < AtomicInteger , Observer < ? super Integer > , AtomicInteger > func2 = new Func2 < AtomicInteger , Observer < ? super Integer > , AtomicInteger > ( ) { @Override public AtomicInteger call ( AtomicInteger s , Observer < ? super Integer > o ) { o . onNext ( <int> ) ; return s ; } } ; Action1 < ? super AtomicInteger > action1 = new Action1 < AtomicInteger > ( ) { @Override public void call ( AtomicInteger s ) { s . getAndIncrement ( ) ; } } ; Observable < Integer > source = Observable . create ( SyncOnSubscribe . createStateful ( func0 , func2 , action1 ) ) ; final TestSubscriber < Integer > ts = TestSubscriber . create ( <int> ) ; source . subscribe ( ts ) ; final CyclicBarrier cb = new CyclicBarrier ( <int> ) ; Future < ? > f = exec . submit ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { cb . await ( ) ; ts . requestMore ( <int> ) ; return null ; } } ) ; cb . await ( ) ; ts . unsubscribe ( ) ; f . get ( ) ; assertEquals ( <str> , <int> , wip . get ( ) ) ; } } finally { if ( exec ! = null ) exec . shutdownNow ( ) ; } } } 
