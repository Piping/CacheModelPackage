package org . apache . cassandra . db . lifecycle ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import com . google . common . base . Function ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import org . junit . BeforeClass ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . MockSchema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Memtable ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . dht . AbstractBounds ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import static com . google . common . collect . ImmutableSet . copyOf ; import static com . google . common . collect . ImmutableSet . of ; import static com . google . common . collect . Iterables . concat ; import static org . apache . cassandra . db . lifecycle . Helpers . emptySet ; public class ViewTest { @BeforeClass public static void setUp ( ) { MockSchema . cleanup ( ) ; } @Test public void testSSTablesInBounds ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; View initialView = fakeView ( <int> , <int> , cfs ) ; for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = i ; j < <int> ; j + + ) { PartitionPosition min = MockSchema . readerBounds ( i ) ; PartitionPosition max = MockSchema . readerBounds ( j ) ; for ( boolean minInc : new boolean [ ] { true } ) { for ( boolean maxInc : new boolean [ ] { true } ) { if ( i = = j & & ! ( minInc & & maxInc ) ) continue ; AbstractBounds < PartitionPosition > bounds = AbstractBounds . bounds ( min , minInc , max , maxInc ) ; List < SSTableReader > r = ImmutableList . copyOf ( initialView . sstablesInBounds ( SSTableSet . LIVE , bounds . left , bounds . right ) ) ; Assert . assertEquals ( String . format ( <str> , i , minInc , j , maxInc ) , j - i + ( minInc ? <int> : - <int> ) + ( maxInc ? <int> : <int> ) , r . size ( ) ) ; } } } } } @Test public void testCompaction ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; View initialView = fakeView ( <int> , <int> , cfs ) ; View cur = initialView ; List < SSTableReader > readers = ImmutableList . copyOf ( initialView . sstables ) ; Assert . assertTrue ( View . permitCompacting ( readers ) . apply ( cur ) ) ; Assert . assertTrue ( View . permitCompacting ( ImmutableList . copyOf ( concat ( readers , readers ) ) ) . apply ( cur ) ) ; testFailure ( View . updateCompacting ( emptySet ( ) , concat ( readers . subList ( <int> , <int> ) , readers . subList ( <int> , <int> ) ) ) , cur ) ; cur = View . updateCompacting ( emptySet ( ) , readers . subList ( <int> , <int> ) ) . apply ( cur ) ; Assert . assertTrue ( View . permitCompacting ( readers . subList ( <int> , <int> ) ) . apply ( cur ) ) ; Assert . assertFalse ( View . permitCompacting ( readers . subList ( <int> , <int> ) ) . apply ( cur ) ) ; Assert . assertFalse ( View . permitCompacting ( readers . subList ( <int> , <int> ) ) . apply ( cur ) ) ; Assert . assertFalse ( View . permitCompacting ( readers . subList ( <int> , <int> ) ) . apply ( cur ) ) ; Assert . assertTrue ( readers . subList ( <int> , <int> ) . containsAll ( copyOf ( cur . getUncompacting ( readers ) ) ) ) ; Assert . assertEquals ( <int> , copyOf ( cur . getUncompacting ( readers ) ) . size ( ) ) ; Assert . assertTrue ( ImmutableSet . copyOf ( cur . sstables ( SSTableSet . NONCOMPACTING ) ) . containsAll ( readers . subList ( <int> , <int> ) ) ) ; Assert . assertEquals ( <int> , ImmutableSet . copyOf ( cur . sstables ( SSTableSet . NONCOMPACTING ) ) . size ( ) ) ; testFailure ( View . updateCompacting ( emptySet ( ) , readers . subList ( <int> , <int> ) ) , cur ) ; testFailure ( View . updateCompacting ( emptySet ( ) , readers . subList ( <int> , <int> ) ) , cur ) ; testFailure ( View . updateCompacting ( copyOf ( readers . subList ( <int> , <int> ) ) , readers . subList ( <int> , <int> ) ) , cur ) ; SSTableReader r0 = MockSchema . sstable ( <int> , cfs ) , r1 = MockSchema . sstable ( <int> , cfs ) , r2 = MockSchema . sstable ( <int> , cfs ) ; testFailure ( View . updateCompacting ( emptySet ( ) , of ( r2 ) ) , cur ) ; cur = View . updateLiveSet ( copyOf ( readers . subList ( <int> , <int> ) ) , of ( r1 , r2 ) ) . apply ( cur ) ; Assert . assertSame ( readers . get ( <int> ) , cur . sstablesMap . get ( r0 ) ) ; Assert . assertSame ( r1 , cur . sstablesMap . get ( r1 ) ) ; Assert . assertSame ( r2 , cur . sstablesMap . get ( r2 ) ) ; testFailure ( View . updateCompacting ( emptySet ( ) , readers . subList ( <int> , <int> ) ) , cur ) ; Assert . assertSame ( readers . get ( <int> ) , Iterables . getFirst ( Iterables . filter ( cur . compacting , Predicates . equalTo ( r1 ) ) , null ) ) ; cur = View . updateCompacting ( copyOf ( readers . subList ( <int> , <int> ) ) , emptySet ( ) ) . apply ( cur ) ; Assert . assertTrue ( View . permitCompacting ( concat ( readers . subList ( <int> , <int> ) , of ( r2 ) , readers . subList ( <int> , <int> ) ) ) . apply ( cur ) ) ; Assert . assertFalse ( View . permitCompacting ( readers . subList ( <int> , <int> ) ) . apply ( cur ) ) ; testFailure ( View . updateCompacting ( emptySet ( ) , readers . subList ( <int> , <int> ) ) , cur ) ; testFailure ( View . updateCompacting ( copyOf ( readers . subList ( <int> , <int> ) ) , emptySet ( ) ) , cur ) ; Assert . assertTrue ( copyOf ( concat ( readers . subList ( <int> , <int> ) , readers . subList ( <int> , <int> ) ) ) . containsAll ( copyOf ( cur . getUncompacting ( readers ) ) ) ) ; Assert . assertEquals ( <int> , copyOf ( cur . getUncompacting ( readers ) ) . size ( ) ) ; Set < SSTableReader > nonCompacting = ImmutableSet . copyOf ( cur . sstables ( SSTableSet . NONCOMPACTING ) ) ; Assert . assertTrue ( nonCompacting . containsAll ( readers . subList ( <int> , <int> ) ) ) ; Assert . assertTrue ( nonCompacting . containsAll ( readers . subList ( <int> , <int> ) ) ) ; Assert . assertEquals ( <int> , nonCompacting . size ( ) ) ; } private static void testFailure ( Function < View , ? > function , View view ) { boolean failed = true ; try { function . apply ( view ) ; failed = false ; } catch ( Throwable t ) { } Assert . assertTrue ( failed ) ; } @Test public void testFlushing ( ) { ColumnFamilyStore cfs = MockSchema . newCFS ( ) ; View initialView = fakeView ( <int> , <int> , cfs ) ; View cur = initialView ; Memtable memtable1 = initialView . getCurrentMemtable ( ) ; Memtable memtable2 = MockSchema . memtable ( cfs ) ; cur = View . switchMemtable ( memtable2 ) . apply ( cur ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( memtable1 , cur . liveMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable2 , cur . getCurrentMemtable ( ) ) ; Memtable memtable3 = MockSchema . memtable ( cfs ) ; cur = View . switchMemtable ( memtable3 ) . apply ( cur ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cur . flushingMemtables . size ( ) ) ; Assert . assertEquals ( memtable1 , cur . liveMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable2 , cur . liveMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable3 , cur . getCurrentMemtable ( ) ) ; testFailure ( View . replaceFlushed ( memtable2 , null ) , cur ) ; cur = View . markFlushing ( memtable2 ) . apply ( cur ) ; Assert . assertTrue ( cur . flushingMemtables . contains ( memtable2 ) ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cur . flushingMemtables . size ( ) ) ; Assert . assertEquals ( memtable2 , cur . flushingMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable1 , cur . liveMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable3 , cur . getCurrentMemtable ( ) ) ; cur = View . markFlushing ( memtable1 ) . apply ( cur ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cur . flushingMemtables . size ( ) ) ; Assert . assertEquals ( memtable1 , cur . flushingMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable2 , cur . flushingMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable3 , cur . getCurrentMemtable ( ) ) ; cur = View . replaceFlushed ( memtable2 , null ) . apply ( cur ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cur . flushingMemtables . size ( ) ) ; Assert . assertEquals ( memtable1 , cur . flushingMemtables . get ( <int> ) ) ; Assert . assertEquals ( memtable3 , cur . getCurrentMemtable ( ) ) ; SSTableReader sstable = MockSchema . sstable ( <int> , cfs ) ; cur = View . replaceFlushed ( memtable1 , Collections . singleton ( sstable ) ) . apply ( cur ) ; Assert . assertEquals ( <int> , cur . flushingMemtables . size ( ) ) ; Assert . assertEquals ( <int> , cur . liveMemtables . size ( ) ) ; Assert . assertEquals ( memtable3 , cur . getCurrentMemtable ( ) ) ; Assert . assertEquals ( <int> , cur . sstables . size ( ) ) ; Assert . assertEquals ( sstable , cur . sstablesMap . get ( sstable ) ) ; } static View fakeView ( int memtableCount , int sstableCount , ColumnFamilyStore cfs ) { List < Memtable > memtables = new ArrayList < > ( ) ; List < SSTableReader > sstables = new ArrayList < > ( ) ; for ( int i = <int> ; i < memtableCount ; i + + ) memtables . add ( MockSchema . memtable ( cfs ) ) ; for ( int i = <int> ; i < sstableCount ; i + + ) sstables . add ( MockSchema . sstable ( i , cfs ) ) ; return new View ( ImmutableList . copyOf ( memtables ) , Collections . < Memtable > emptyList ( ) , Helpers . identityMap ( sstables ) , Collections . < SSTableReader , SSTableReader > emptyMap ( ) , SSTableIntervalTree . build ( sstables ) ) ; } }