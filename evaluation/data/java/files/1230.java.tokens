package rx . internal . operators ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicReference ; import rx . Observable ; import rx . Observable . OnSubscribe ; import rx . Producer ; import rx . Subscriber ; import rx . functions . Action0 ; import rx . subscriptions . Subscriptions ; public final class OnSubscribeAmb < T > implements OnSubscribe < T > { public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 , Observable < ? extends T > o5 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; sources . add ( o5 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 , Observable < ? extends T > o5 , Observable < ? extends T > o6 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; sources . add ( o5 ) ; sources . add ( o6 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 , Observable < ? extends T > o5 , Observable < ? extends T > o6 , Observable < ? extends T > o7 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; sources . add ( o5 ) ; sources . add ( o6 ) ; sources . add ( o7 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 , Observable < ? extends T > o5 , Observable < ? extends T > o6 , Observable < ? extends T > o7 , Observable < ? extends T > o8 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; sources . add ( o5 ) ; sources . add ( o6 ) ; sources . add ( o7 ) ; sources . add ( o8 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( Observable < ? extends T > o1 , Observable < ? extends T > o2 , Observable < ? extends T > o3 , Observable < ? extends T > o4 , Observable < ? extends T > o5 , Observable < ? extends T > o6 , Observable < ? extends T > o7 , Observable < ? extends T > o8 , Observable < ? extends T > o9 ) { List < Observable < ? extends T > > sources = new ArrayList < Observable < ? extends T > > ( ) ; sources . add ( o1 ) ; sources . add ( o2 ) ; sources . add ( o3 ) ; sources . add ( o4 ) ; sources . add ( o5 ) ; sources . add ( o6 ) ; sources . add ( o7 ) ; sources . add ( o8 ) ; sources . add ( o9 ) ; return amb ( sources ) ; } public static < T > OnSubscribe < T > amb ( final Iterable < ? extends Observable < ? extends T > > sources ) { return new OnSubscribeAmb < T > ( sources ) ; } private static final class AmbSubscriber < T > extends Subscriber < T > { private final Subscriber < ? super T > subscriber ; private final Selection < T > selection ; private boolean chosen ; private AmbSubscriber ( long requested , Subscriber < ? super T > subscriber , Selection < T > selection ) { this . subscriber = subscriber ; this . selection = selection ; request ( requested ) ; } private final void requestMore ( long n ) { request ( n ) ; } @Override public void onNext ( T t ) { if ( ! isSelected ( ) ) { return ; } subscriber . onNext ( t ) ; } @Override public void onCompleted ( ) { if ( ! isSelected ( ) ) { return ; } subscriber . onCompleted ( ) ; } @Override public void onError ( Throwable e ) { if ( ! isSelected ( ) ) { return ; } subscriber . onError ( e ) ; } private boolean isSelected ( ) { if ( chosen ) { return true ; } if ( selection . choice . get ( ) = = this ) { chosen = true ; return true ; } else { if ( selection . choice . compareAndSet ( null , this ) ) { selection . unsubscribeOthers ( this ) ; chosen = true ; return true ; } else { selection . unsubscribeLosers ( ) ; return false ; } } } } private static class Selection < T > { final AtomicReference < AmbSubscriber < T > > choice = new AtomicReference < AmbSubscriber < T > > ( ) ; final Collection < AmbSubscriber < T > > ambSubscribers = new ConcurrentLinkedQueue < AmbSubscriber < T > > ( ) ; public void unsubscribeLosers ( ) { AmbSubscriber < T > winner = choice . get ( ) ; if ( winner ! = null ) { unsubscribeOthers ( winner ) ; } } public void unsubscribeOthers ( AmbSubscriber < T > notThis ) { for ( AmbSubscriber < T > other : ambSubscribers ) { if ( other ! = notThis ) { other . unsubscribe ( ) ; } } ambSubscribers . clear ( ) ; } } final Iterable < ? extends Observable < ? extends T > > sources ; final Selection < T > selection = new Selection < T > ( ) ; final AtomicReference < AmbSubscriber < T > > choice = selection . choice ; private OnSubscribeAmb ( Iterable < ? extends Observable < ? extends T > > sources ) { this . sources = sources ; } @Override public void call ( final Subscriber < ? super T > subscriber ) { subscriber . add ( Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { AmbSubscriber < T > c ; if ( ( c = choice . get ( ) ) ! = null ) { c . unsubscribe ( ) ; } unsubscribeAmbSubscribers ( selection . ambSubscribers ) ; } } ) ) ; for ( Observable < ? extends T > source : sources ) { if ( subscriber . isUnsubscribed ( ) ) { break ; } AmbSubscriber < T > ambSubscriber = new AmbSubscriber < T > ( <int> , subscriber , selection ) ; selection . ambSubscribers . add ( ambSubscriber ) ; AmbSubscriber < T > c ; if ( ( c = choice . get ( ) ) ! = null ) { selection . unsubscribeOthers ( c ) ; return ; } source . unsafeSubscribe ( ambSubscriber ) ; } if ( subscriber . isUnsubscribed ( ) ) { unsubscribeAmbSubscribers ( selection . ambSubscribers ) ; } subscriber . setProducer ( new Producer ( ) { @Override public void request ( long n ) { final AmbSubscriber < T > c ; if ( ( c = choice . get ( ) ) ! = null ) { c . requestMore ( n ) ; } else { for ( AmbSubscriber < T > ambSubscriber : selection . ambSubscribers ) { if ( ! ambSubscriber . isUnsubscribed ( ) ) { if ( choice . get ( ) = = ambSubscriber ) { ambSubscriber . requestMore ( n ) ; return ; } else { ambSubscriber . requestMore ( n ) ; } } } } } } ) ; } private static < T > void unsubscribeAmbSubscribers ( Collection < AmbSubscriber < T > > ambSubscribers ) { if ( ! ambSubscribers . isEmpty ( ) ) { for ( AmbSubscriber < T > other : ambSubscribers ) { other . unsubscribe ( ) ; } ambSubscribers . clear ( ) ; } } } 
