package org . nd4j . linalg . shape ; import org . apache . commons . math3 . util . Pair ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . tensor . TensorCalculator ; import org . nd4j . linalg . api . shape . tensor . TensorCalculator1d ; import org . nd4j . linalg . api . shape . tensor . TensorCalculatorFactory ; import org . nd4j . linalg . checkutil . NDArrayCreationUtil ; import org . nd4j . linalg . factory . Nd4jBackend ; import java . util . List ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; public class TestTensorCalculator extends BaseNd4jTest { public TestTensorCalculator ( ) { } public TestTensorCalculator ( Nd4jBackend backend ) { super ( backend ) ; } public TestTensorCalculator ( String name ) { super ( name ) ; } public TestTensorCalculator ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Test public void testTensorCalculator1d ( ) throws Exception { int [ ] [ ] shapes = new int [ <int> ] [ <int> ] ; shapes [ <int> ] = new int [ ] { <int> , <int> } ; shapes [ <int> ] = new int [ ] { <int> , <int> } ; shapes [ <int> ] = new int [ ] { <int> , <int> , <int> } ; shapes [ <int> ] = new int [ ] { <int> , <int> , <int> , <int> } ; shapes [ <int> ] = new int [ ] { <int> , <int> , <int> , <int> , <int> } ; shapes [ <int> ] = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; int seed = <int> ; for ( int z = <int> ; z < shapes . length ; z + + ) { List < Pair < INDArray , String > > list ; switch ( z ) { case <int> : case <int> : list = NDArrayCreationUtil . getAllTestMatricesWithShape ( shapes [ z ] [ <int> ] , shapes [ z ] [ <int> ] , seed ) ; break ; case <int> : list = NDArrayCreationUtil . getAll3dTestArraysWithShape ( seed , shapes [ z ] ) ; break ; case <int> : list = NDArrayCreationUtil . getAll4dTestArraysWithShape ( <int> , shapes [ z ] ) ; break ; case <int> : list = NDArrayCreationUtil . getAll5dTestArraysWithShape ( <int> , shapes [ z ] ) ; break ; case <int> : list = NDArrayCreationUtil . getAll6dTestArraysWithShape ( <int> , shapes [ z ] ) ; break ; default : throw new RuntimeException ( ) ; } for ( Pair < INDArray , String > pair : list ) { INDArray arr = pair . getFirst ( ) ; int [ ] shape = arr . shape ( ) ; if ( arr . ordering ( ) ! = <str> ) continue ; for ( int d = <int> ; d < arr . rank ( ) ; d + + ) { int nT = arr . tensorssAlongDimension ( d ) ; TensorCalculator tCalc = TensorCalculatorFactory . getTensorCalculator ( arr , d ) ; assertEquals ( nT , tCalc . getNumTensors ( ) ) ; for ( int i = <int> ; i < nT ; i + + ) { String msg = pair . getSecond ( ) + <str> + i + <str> + d ; INDArray tensor = arr . tensorAlongDimension ( i , d ) ; assertEquals ( msg , tensor . offset ( ) , tCalc . getOffsetForTensor ( i ) ) ; if ( shape [ d ] > <int> ) { assertEquals ( msg , tensor . elementWiseStride ( ) , tCalc . getElementWiseStrideForTensor ( ) ) ; } else { assertEquals ( msg , <int> , tCalc . getTensorLength ( ) ) ; } assertEquals ( msg , tensor . length ( ) , tCalc . getTensorLength ( ) ) ; assertArrayEquals ( msg , tensor . shape ( ) , tCalc . getShape ( ) ) ; assertEquals ( msg , <int> , tCalc . getStride ( ) . length ) ; if ( tensor . length ( ) > <int> ) assertEquals ( msg , tensor . stride ( <int> ) , tCalc . getStride ( ) [ <int> ] ) ; DataBuffer db = arr . data ( ) ; for ( int x = <int> ; x < tensor . length ( ) ; x + + ) { double dTensor = tensor . getDouble ( x ) ; double dCalc = db . getDouble ( tCalc . getOffsetForTensor ( i ) + x * tCalc . getElementWiseStrideForTensor ( ) ) ; assertEquals ( dTensor , dCalc , <int> e - <int> ) ; } } } } } } @Override public char ordering ( ) { return <str> ; } }