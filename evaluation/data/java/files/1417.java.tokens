package org . gradle . internal ; import com . google . common . base . Function ; public final class Pair < L , R > { public final L left ; public final R right ; private Pair ( L left , R right ) { this . left = left ; this . right = right ; } public L getLeft ( ) { return left ; } public R getRight ( ) { return right ; } public L left ( ) { return left ; } public R right ( ) { return right ; } public static < L , R > Pair < L , R > of ( L left , R right ) { return new Pair < L , R > ( left , right ) ; } public < T > Pair < T , Pair < L , R > > pushLeft ( T t ) { return of ( t , this ) ; } public < T > Pair < Pair < L , R > , T > pushRight ( T t ) { return of ( this , t ) ; } public < T > Pair < Pair < T , L > , R > nestLeft ( T t ) { return of ( of ( t , left ) , right ) ; } public < T > Pair < L , Pair < T , R > > nestRight ( T t ) { return of ( left , of ( t , right ) ) ; } public < T > Pair < T , R > mapLeft ( Function < ? super L , ? extends T > function ) throws Exception { return of ( function . apply ( left ) , right ) ; } public < T > Pair < L , T > mapRight ( Function < ? super R , ? extends T > function ) throws Exception { return of ( left , function . apply ( right ) ) ; } public < T > T map ( Function < ? super Pair < L , R > , ? extends T > function ) throws Exception { return function . apply ( this ) ; } public static < L , T extends Pair < L , ? > > Function < T , L > unpackLeft ( ) { return new Function < T , L > ( ) { @Override public L apply ( T tuple ) { return tuple . left ; } } ; } public static < R , T extends Pair < ? , R > > Function < T , R > unpackRight ( ) { return new Function < T , R > ( ) { @Override public R apply ( T tuple ) { return tuple . right ; } } ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } Pair < ? , ? > pair = ( Pair < ? , ? > ) o ; return ! ( left ! = null ? ! left . equals ( pair . left ) : pair . left ! = null ) & & ! ( right ! = null ? ! right . equals ( pair . right ) : pair . right ! = null ) ; } @Override public int hashCode ( ) { int result = left ! = null ? left . hashCode ( ) : <int> ; result = <int> * result + ( right ! = null ? right . hashCode ( ) : <int> ) ; return result ; } @Override public String toString ( ) { return <str> + left + <str> + right + <str> ; } } 
