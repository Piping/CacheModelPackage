package org . jbox2d . dynamics ; import org . jbox2d . callbacks . ContactImpulse ; import org . jbox2d . callbacks . ContactListener ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Sweep ; import org . jbox2d . common . Timer ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . contacts . Contact ; import org . jbox2d . dynamics . contacts . ContactSolver ; import org . jbox2d . dynamics . contacts . ContactSolver . ContactSolverDef ; import org . jbox2d . dynamics . contacts . ContactVelocityConstraint ; import org . jbox2d . dynamics . contacts . Position ; import org . jbox2d . dynamics . contacts . Velocity ; import org . jbox2d . dynamics . joints . Joint ; public class Island { public ContactListener m_listener ; public Body [ ] m_bodies ; public Contact [ ] m_contacts ; public Joint [ ] m_joints ; public Position [ ] m_positions ; public Velocity [ ] m_velocities ; public int m_bodyCount ; public int m_jointCount ; public int m_contactCount ; public int m_bodyCapacity ; public int m_contactCapacity ; public int m_jointCapacity ; public Island ( ) { } public void init ( int bodyCapacity , int contactCapacity , int jointCapacity , ContactListener listener ) { m_bodyCapacity = bodyCapacity ; m_contactCapacity = contactCapacity ; m_jointCapacity = jointCapacity ; m_bodyCount = <int> ; m_contactCount = <int> ; m_jointCount = <int> ; m_listener = listener ; if ( m_bodies = = null | | m_bodyCapacity > m_bodies . length ) { m_bodies = new Body [ m_bodyCapacity ] ; } if ( m_joints = = null | | m_jointCapacity > m_joints . length ) { m_joints = new Joint [ m_jointCapacity ] ; } if ( m_contacts = = null | | m_contactCapacity > m_contacts . length ) { m_contacts = new Contact [ m_contactCapacity ] ; } if ( m_velocities = = null | | m_bodyCapacity > m_velocities . length ) { final Velocity [ ] old = m_velocities = = null ? new Velocity [ <int> ] : m_velocities ; m_velocities = new Velocity [ m_bodyCapacity ] ; System . arraycopy ( old , <int> , m_velocities , <int> , old . length ) ; for ( int i = old . length ; i < m_velocities . length ; i + + ) { m_velocities [ i ] = new Velocity ( ) ; } } if ( m_positions = = null | | m_bodyCapacity > m_positions . length ) { final Position [ ] old = m_positions = = null ? new Position [ <int> ] : m_positions ; m_positions = new Position [ m_bodyCapacity ] ; System . arraycopy ( old , <int> , m_positions , <int> , old . length ) ; for ( int i = old . length ; i < m_positions . length ; i + + ) { m_positions [ i ] = new Position ( ) ; } } } public void clear ( ) { m_bodyCount = <int> ; m_contactCount = <int> ; m_jointCount = <int> ; } private final ContactSolver contactSolver = new ContactSolver ( ) ; private final Timer timer = new Timer ( ) ; private final SolverData solverData = new SolverData ( ) ; private final ContactSolverDef solverDef = new ContactSolverDef ( ) ; public void solve ( Profile profile , TimeStep step , Vec2 gravity , boolean allowSleep ) { float h = step . dt ; for ( int i = <int> ; i < m_bodyCount ; + + i ) { final Body b = m_bodies [ i ] ; final Sweep bm_sweep = b . m_sweep ; final Vec2 c = bm_sweep . c ; float a = bm_sweep . a ; final Vec2 v = b . m_linearVelocity ; float w = b . m_angularVelocity ; bm_sweep . c0 . set ( bm_sweep . c ) ; bm_sweep . a0 = bm_sweep . a ; if ( b . m_type = = BodyType . DYNAMIC ) { v . x + = h * ( b . m_gravityScale * gravity . x + b . m_invMass * b . m_force . x ) ; v . y + = h * ( b . m_gravityScale * gravity . y + b . m_invMass * b . m_force . y ) ; w + = h * b . m_invI * b . m_torque ; v . x * = <float> / ( <float> + h * b . m_linearDamping ) ; v . y * = <float> / ( <float> + h * b . m_linearDamping ) ; w * = <float> / ( <float> + h * b . m_angularDamping ) ; } m_positions [ i ] . c . x = c . x ; m_positions [ i ] . c . y = c . y ; m_positions [ i ] . a = a ; m_velocities [ i ] . v . x = v . x ; m_velocities [ i ] . v . y = v . y ; m_velocities [ i ] . w = w ; } timer . reset ( ) ; solverData . step = step ; solverData . positions = m_positions ; solverData . velocities = m_velocities ; solverDef . step = step ; solverDef . contacts = m_contacts ; solverDef . count = m_contactCount ; solverDef . positions = m_positions ; solverDef . velocities = m_velocities ; contactSolver . init ( solverDef ) ; contactSolver . initializeVelocityConstraints ( ) ; if ( step . warmStarting ) { contactSolver . warmStart ( ) ; } for ( int i = <int> ; i < m_jointCount ; + + i ) { m_joints [ i ] . initVelocityConstraints ( solverData ) ; } profile . solveInit . accum ( timer . getMilliseconds ( ) ) ; timer . reset ( ) ; for ( int i = <int> ; i < step . velocityIterations ; + + i ) { for ( int j = <int> ; j < m_jointCount ; + + j ) { m_joints [ j ] . solveVelocityConstraints ( solverData ) ; } contactSolver . solveVelocityConstraints ( ) ; } contactSolver . storeImpulses ( ) ; profile . solveVelocity . accum ( timer . getMilliseconds ( ) ) ; for ( int i = <int> ; i < m_bodyCount ; + + i ) { final Vec2 c = m_positions [ i ] . c ; float a = m_positions [ i ] . a ; final Vec2 v = m_velocities [ i ] . v ; float w = m_velocities [ i ] . w ; float translationx = v . x * h ; float translationy = v . y * h ; if ( translationx * translationx + translationy * translationy > Settings . maxTranslationSquared ) { float ratio = Settings . maxTranslation / MathUtils . sqrt ( translationx * translationx + translationy * translationy ) ; v . x * = ratio ; v . y * = ratio ; } float rotation = h * w ; if ( rotation * rotation > Settings . maxRotationSquared ) { float ratio = Settings . maxRotation / MathUtils . abs ( rotation ) ; w * = ratio ; } c . x + = h * v . x ; c . y + = h * v . y ; a + = h * w ; m_positions [ i ] . a = a ; m_velocities [ i ] . w = w ; } timer . reset ( ) ; boolean positionSolved = false ; for ( int i = <int> ; i < step . positionIterations ; + + i ) { boolean contactsOkay = contactSolver . solvePositionConstraints ( ) ; boolean jointsOkay = true ; for ( int j = <int> ; j < m_jointCount ; + + j ) { boolean jointOkay = m_joints [ j ] . solvePositionConstraints ( solverData ) ; jointsOkay = jointsOkay & & jointOkay ; } if ( contactsOkay & & jointsOkay ) { positionSolved = true ; break ; } } for ( int i = <int> ; i < m_bodyCount ; + + i ) { Body body = m_bodies [ i ] ; body . m_sweep . c . x = m_positions [ i ] . c . x ; body . m_sweep . c . y = m_positions [ i ] . c . y ; body . m_sweep . a = m_positions [ i ] . a ; body . m_linearVelocity . x = m_velocities [ i ] . v . x ; body . m_linearVelocity . y = m_velocities [ i ] . v . y ; body . m_angularVelocity = m_velocities [ i ] . w ; body . synchronizeTransform ( ) ; } profile . solvePosition . accum ( timer . getMilliseconds ( ) ) ; report ( contactSolver . m_velocityConstraints ) ; if ( allowSleep ) { float minSleepTime = Float . MAX_VALUE ; final float linTolSqr = Settings . linearSleepTolerance * Settings . linearSleepTolerance ; final float angTolSqr = Settings . angularSleepTolerance * Settings . angularSleepTolerance ; for ( int i = <int> ; i < m_bodyCount ; + + i ) { Body b = m_bodies [ i ] ; if ( b . getType ( ) = = BodyType . STATIC ) { continue ; } if ( ( b . m_flags & Body . e_autoSleepFlag ) = = <int> | | b . m_angularVelocity * b . m_angularVelocity > angTolSqr | | Vec2 . dot ( b . m_linearVelocity , b . m_linearVelocity ) > linTolSqr ) { b . m_sleepTime = <float> ; minSleepTime = <float> ; } else { b . m_sleepTime + = h ; minSleepTime = MathUtils . min ( minSleepTime , b . m_sleepTime ) ; } } if ( minSleepTime > = Settings . timeToSleep & & positionSolved ) { for ( int i = <int> ; i < m_bodyCount ; + + i ) { Body b = m_bodies [ i ] ; b . setAwake ( false ) ; } } } } private final ContactSolver toiContactSolver = new ContactSolver ( ) ; private final ContactSolverDef toiSolverDef = new ContactSolverDef ( ) ; public void solveTOI ( TimeStep subStep , int toiIndexA , int toiIndexB ) { assert ( toiIndexA < m_bodyCount ) ; assert ( toiIndexB < m_bodyCount ) ; for ( int i = <int> ; i < m_bodyCount ; + + i ) { m_positions [ i ] . c . x = m_bodies [ i ] . m_sweep . c . x ; m_positions [ i ] . c . y = m_bodies [ i ] . m_sweep . c . y ; m_positions [ i ] . a = m_bodies [ i ] . m_sweep . a ; m_velocities [ i ] . v . x = m_bodies [ i ] . m_linearVelocity . x ; m_velocities [ i ] . v . y = m_bodies [ i ] . m_linearVelocity . y ; m_velocities [ i ] . w = m_bodies [ i ] . m_angularVelocity ; } toiSolverDef . contacts = m_contacts ; toiSolverDef . count = m_contactCount ; toiSolverDef . step = subStep ; toiSolverDef . positions = m_positions ; toiSolverDef . velocities = m_velocities ; toiContactSolver . init ( toiSolverDef ) ; for ( int i = <int> ; i < subStep . positionIterations ; + + i ) { boolean contactsOkay = toiContactSolver . solveTOIPositionConstraints ( toiIndexA , toiIndexB ) ; if ( contactsOkay ) { break ; } } m_bodies [ toiIndexA ] . m_sweep . c0 . x = m_positions [ toiIndexA ] . c . x ; m_bodies [ toiIndexA ] . m_sweep . c0 . y = m_positions [ toiIndexA ] . c . y ; m_bodies [ toiIndexA ] . m_sweep . a0 = m_positions [ toiIndexA ] . a ; m_bodies [ toiIndexB ] . m_sweep . c0 . set ( m_positions [ toiIndexB ] . c ) ; m_bodies [ toiIndexB ] . m_sweep . a0 = m_positions [ toiIndexB ] . a ; toiContactSolver . initializeVelocityConstraints ( ) ; for ( int i = <int> ; i < subStep . velocityIterations ; + + i ) { toiContactSolver . solveVelocityConstraints ( ) ; } float h = subStep . dt ; for ( int i = <int> ; i < m_bodyCount ; + + i ) { Vec2 c = m_positions [ i ] . c ; float a = m_positions [ i ] . a ; Vec2 v = m_velocities [ i ] . v ; float w = m_velocities [ i ] . w ; float translationx = v . x * h ; float translationy = v . y * h ; if ( translationx * translationx + translationy * translationy > Settings . maxTranslationSquared ) { float ratio = Settings . maxTranslation / MathUtils . sqrt ( translationx * translationx + translationy * translationy ) ; v . mulLocal ( ratio ) ; } float rotation = h * w ; if ( rotation * rotation > Settings . maxRotationSquared ) { float ratio = Settings . maxRotation / MathUtils . abs ( rotation ) ; w * = ratio ; } c . x + = v . x * h ; c . y + = v . y * h ; a + = h * w ; m_positions [ i ] . c . x = c . x ; m_positions [ i ] . c . y = c . y ; m_positions [ i ] . a = a ; m_velocities [ i ] . v . x = v . x ; m_velocities [ i ] . v . y = v . y ; m_velocities [ i ] . w = w ; Body body = m_bodies [ i ] ; body . m_sweep . c . x = c . x ; body . m_sweep . c . y = c . y ; body . m_sweep . a = a ; body . m_linearVelocity . x = v . x ; body . m_linearVelocity . y = v . y ; body . m_angularVelocity = w ; body . synchronizeTransform ( ) ; } report ( toiContactSolver . m_velocityConstraints ) ; } public void add ( Body body ) { assert ( m_bodyCount < m_bodyCapacity ) ; body . m_islandIndex = m_bodyCount ; m_bodies [ m_bodyCount ] = body ; + + m_bodyCount ; } public void add ( Contact contact ) { assert ( m_contactCount < m_contactCapacity ) ; m_contacts [ m_contactCount + + ] = contact ; } public void add ( Joint joint ) { assert ( m_jointCount < m_jointCapacity ) ; m_joints [ m_jointCount + + ] = joint ; } private final ContactImpulse impulse = new ContactImpulse ( ) ; public void report ( ContactVelocityConstraint [ ] constraints ) { if ( m_listener = = null ) { return ; } for ( int i = <int> ; i < m_contactCount ; + + i ) { Contact c = m_contacts [ i ] ; ContactVelocityConstraint vc = constraints [ i ] ; impulse . count = vc . pointCount ; for ( int j = <int> ; j < vc . pointCount ; + + j ) { impulse . normalImpulses [ j ] = vc . points [ j ] . normalImpulse ; impulse . tangentImpulses [ j ] = vc . points [ j ] . tangentImpulse ; } m_listener . postSolve ( c , impulse ) ; } } } 
