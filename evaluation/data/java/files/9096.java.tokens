package org . eclipse . core . internal . variables ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . preferences . IEclipsePreferences ; import org . eclipse . core . runtime . preferences . IEclipsePreferences . IPreferenceChangeListener ; import org . eclipse . core . runtime . preferences . IEclipsePreferences . PreferenceChangeEvent ; import org . eclipse . core . runtime . preferences . InstanceScope ; import org . eclipse . core . variables . IDynamicVariable ; import org . eclipse . core . variables . IStringVariable ; import org . eclipse . core . variables . IStringVariableManager ; import org . eclipse . core . variables . IValueVariable ; import org . eclipse . core . variables . IValueVariableListener ; import org . eclipse . core . variables . VariablesPlugin ; import org . eclipse . osgi . util . NLS ; import org . osgi . service . prefs . BackingStoreException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . helpers . DefaultHandler ; public class StringVariableManager implements IStringVariableManager , IPreferenceChangeListener { private Map < String , IDynamicVariable > fDynamicVariables ; private Map < String , IStringVariable > fValueVariables ; private ListenerList fListeners ; private static final int ADDED = <int> ; private static final int CHANGED = <int> ; private static final int REMOVED = <int> ; private static StringVariableManager fgManager ; private boolean fInternalChange = false ; private static final String ATTR_NAME = <str> ; private static final String ATTR_DESCRIPTION = <str> ; private static final String ATTR_READ_ONLY = <str> ; private static final String VALUE_VARIABLES_TAG = <str> ; private static final String VALUE_VARIABLE_TAG = <str> ; private static final String NAME_TAG = <str> ; private static final String VALUE_TAG = <str> ; private static final String DESCRIPTION_TAG = <str> ; private static final String READ_ONLY_TAG = <str> ; private static final String TRUE_VALUE = <str> ; private static final String FALSE_VALUE = <str> ; private static final String PREF_VALUE_VARIABLES = VariablesPlugin . getUniqueIdentifier ( ) + <str> ; class StringVariableNotifier implements ISafeRunnable { private IValueVariableListener fListener ; private int fType ; private IValueVariable [ ] fVariables ; @Override public void handleException ( Throwable exception ) { IStatus status = new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . INTERNAL_ERROR , <str> , exception ) ; VariablesPlugin . log ( status ) ; } @Override public void run ( ) throws Exception { switch ( fType ) { case ADDED : fListener . variablesAdded ( fVariables ) ; break ; case REMOVED : fListener . variablesRemoved ( fVariables ) ; break ; case CHANGED : fListener . variablesChanged ( fVariables ) ; break ; default : break ; } } public void notify ( IValueVariable [ ] variables , int update ) { fVariables = variables ; fType = update ; Object [ ] copiedListeners = fListeners . getListeners ( ) ; for ( int i = <int> ; i < copiedListeners . length ; i + + ) { fListener = ( IValueVariableListener ) copiedListeners [ i ] ; SafeRunner . run ( this ) ; } fVariables = null ; fListener = null ; storeValueVariables ( ) ; } } private StringVariableNotifier getNotifier ( ) { return new StringVariableNotifier ( ) ; } public static StringVariableManager getDefault ( ) { if ( fgManager = = null ) { fgManager = new StringVariableManager ( ) ; } return fgManager ; } private StringVariableManager ( ) { fListeners = new ListenerList ( ) ; } private synchronized void initialize ( ) { if ( fDynamicVariables = = null ) { fInternalChange = true ; fDynamicVariables = new HashMap < String , IDynamicVariable > ( <int> ) ; fValueVariables = new HashMap < String , IStringVariable > ( <int> ) ; loadContributedValueVariables ( ) ; loadPersistedValueVariables ( ) ; loadDynamicVariables ( ) ; InstanceScope . INSTANCE . getNode ( VariablesPlugin . PI_CORE_VARIABLES ) . addPreferenceChangeListener ( this ) ; fInternalChange = false ; } } private void loadDynamicVariables ( ) { IExtensionPoint point = Platform . getExtensionRegistry ( ) . getExtensionPoint ( VariablesPlugin . PI_CORE_VARIABLES , EXTENSION_POINT_DYNAMIC_VARIABLES ) ; IConfigurationElement elements [ ] = point . getConfigurationElements ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { IConfigurationElement element = elements [ i ] ; String name = element . getAttribute ( ATTR_NAME ) ; if ( name = = null ) { VariablesPlugin . logMessage ( NLS . bind ( <str> , new String [ ] { element . getDeclaringExtension ( ) . getLabel ( ) } ) , null ) ; continue ; } String description = element . getAttribute ( ATTR_DESCRIPTION ) ; DynamicVariable variable = new DynamicVariable ( name , description , element ) ; Object old = fDynamicVariables . put ( variable . getName ( ) , variable ) ; if ( old ! = null ) { DynamicVariable oldVariable = ( DynamicVariable ) old ; VariablesPlugin . logMessage ( NLS . bind ( <str> , new String [ ] { element . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) , oldVariable . getName ( ) , oldVariable . getConfigurationElement ( ) . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) } ) , null ) ; } } } private void loadContributedValueVariables ( ) { IExtensionPoint point = Platform . getExtensionRegistry ( ) . getExtensionPoint ( VariablesPlugin . PI_CORE_VARIABLES , EXTENSION_POINT_VALUE_VARIABLES ) ; IConfigurationElement elements [ ] = point . getConfigurationElements ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { IConfigurationElement element = elements [ i ] ; String name = element . getAttribute ( ATTR_NAME ) ; if ( name = = null ) { VariablesPlugin . logMessage ( NLS . bind ( <str> , new String [ ] { element . getDeclaringExtension ( ) . getLabel ( ) } ) , null ) ; continue ; } String description = element . getAttribute ( ATTR_DESCRIPTION ) ; boolean isReadOnly = TRUE_VALUE . equals ( element . getAttribute ( ATTR_READ_ONLY ) ) ; IValueVariable variable = new ContributedValueVariable ( name , description , isReadOnly , element ) ; Object old = fValueVariables . put ( name , variable ) ; if ( old ! = null ) { StringVariable oldVariable = ( StringVariable ) old ; VariablesPlugin . logMessage ( NLS . bind ( <str> , new String [ ] { element . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) , oldVariable . getName ( ) , oldVariable . getConfigurationElement ( ) . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) } ) , null ) ; } } } private void loadPersistedValueVariables ( ) { String variablesString = Platform . getPreferencesService ( ) . getString ( VariablesPlugin . PI_CORE_VARIABLES , PREF_VALUE_VARIABLES , <str> , null ) ; if ( variablesString . length ( ) = = <int> ) { return ; } Element root = null ; try { ByteArrayInputStream stream = new ByteArrayInputStream ( variablesString . getBytes ( <str> ) ) ; DocumentBuilder parser = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; parser . setErrorHandler ( new DefaultHandler ( ) ) ; root = parser . parse ( stream ) . getDocumentElement ( ) ; } catch ( Exception e ) { VariablesPlugin . logMessage ( <str> , e ) ; return ; } if ( ! root . getNodeName ( ) . equals ( VALUE_VARIABLES_TAG ) ) { VariablesPlugin . logMessage ( <str> , null ) ; return ; } NodeList list = root . getChildNodes ( ) ; for ( int i = <int> , numItems = list . getLength ( ) ; i < numItems ; i + + ) { Node node = list . item ( i ) ; if ( node . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element element = ( Element ) node ; if ( ! element . getNodeName ( ) . equals ( VALUE_VARIABLE_TAG ) ) { VariablesPlugin . logMessage ( NLS . bind ( <str> , new String [ ] { node . getNodeName ( ) } ) , null ) ; continue ; } String name = element . getAttribute ( NAME_TAG ) ; if ( name . length ( ) > <int> ) { String value = element . getAttribute ( VALUE_TAG ) ; String description = element . getAttribute ( DESCRIPTION_TAG ) ; boolean readOnly = TRUE_VALUE . equals ( element . getAttribute ( READ_ONLY_TAG ) ) ; IValueVariable existing = getValueVariable ( name ) ; if ( existing = = null ) { ValueVariable variable = new ValueVariable ( name , description , readOnly , value ) ; fValueVariables . put ( name , variable ) ; } else if ( ! existing . isReadOnly ( ) & & value ! = null ) { existing . setValue ( value ) ; } } else { VariablesPlugin . logMessage ( <str> , null ) ; } } } } @Override public synchronized IStringVariable [ ] getVariables ( ) { initialize ( ) ; List < IStringVariable > list = new ArrayList < IStringVariable > ( fDynamicVariables . size ( ) + fValueVariables . size ( ) ) ; list . addAll ( fDynamicVariables . values ( ) ) ; list . addAll ( fValueVariables . values ( ) ) ; return list . toArray ( new IStringVariable [ list . size ( ) ] ) ; } @Override public synchronized IValueVariable [ ] getValueVariables ( ) { initialize ( ) ; return fValueVariables . values ( ) . toArray ( new IValueVariable [ fValueVariables . size ( ) ] ) ; } @Override public synchronized IDynamicVariable [ ] getDynamicVariables ( ) { initialize ( ) ; return fDynamicVariables . values ( ) . toArray ( new IDynamicVariable [ fDynamicVariables . size ( ) ] ) ; } @Override public String performStringSubstitution ( String expression ) throws CoreException { return performStringSubstitution ( expression , true ) ; } @Override public IValueVariable newValueVariable ( String name , String description ) { return newValueVariable ( name , description , false , null ) ; } @Override public IValueVariable newValueVariable ( String name , String description , boolean readOnly , String value ) { return new ValueVariable ( name , description , readOnly , value ) ; } @Override public synchronized void addVariables ( IValueVariable [ ] variables ) throws CoreException { initialize ( ) ; MultiStatus status = new MultiStatus ( VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . INTERNAL_ERROR , VariablesMessages . StringVariableManager_26 , null ) ; for ( int i = <int> ; i < variables . length ; i + + ) { IValueVariable variable = variables [ i ] ; if ( getValueVariable ( variable . getName ( ) ) ! = null ) { status . add ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , VariablesPlugin . INTERNAL_ERROR , NLS . bind ( VariablesMessages . StringVariableManager_27 , new String [ ] { variable . getName ( ) } ) , null ) ) ; } } if ( status . isOK ( ) ) { for ( int i = <int> ; i < variables . length ; i + + ) { IValueVariable variable = variables [ i ] ; fValueVariables . put ( variable . getName ( ) , variable ) ; } IValueVariable [ ] copy = new IValueVariable [ variables . length ] ; System . arraycopy ( variables , <int> , copy , <int> , variables . length ) ; getNotifier ( ) . notify ( copy , ADDED ) ; return ; } throw new CoreException ( status ) ; } @Override public synchronized void removeVariables ( IValueVariable [ ] variables ) { initialize ( ) ; List < IValueVariable > removed = new ArrayList < IValueVariable > ( variables . length ) ; for ( int i = <int> ; i < variables . length ; i + + ) { IValueVariable variable = variables [ i ] ; if ( fValueVariables . remove ( variable . getName ( ) ) ! = null ) { removed . add ( variable ) ; } } if ( removed . size ( ) > <int> ) { getNotifier ( ) . notify ( removed . toArray ( new IValueVariable [ removed . size ( ) ] ) , REMOVED ) ; } } @Override public synchronized IDynamicVariable getDynamicVariable ( String name ) { initialize ( ) ; return fDynamicVariables . get ( name ) ; } @Override public synchronized IValueVariable getValueVariable ( String name ) { initialize ( ) ; return ( IValueVariable ) fValueVariables . get ( name ) ; } @Override public void addValueVariableListener ( IValueVariableListener listener ) { fListeners . add ( listener ) ; } @Override public void removeValueVariableListener ( IValueVariableListener listener ) { fListeners . remove ( listener ) ; } private String getValueVariablesAsXML ( ) throws IOException , ParserConfigurationException , TransformerException { IValueVariable [ ] variables = getValueVariables ( ) ; Document document = getDocument ( ) ; Element rootElement = document . createElement ( VALUE_VARIABLES_TAG ) ; document . appendChild ( rootElement ) ; for ( int i = <int> ; i < variables . length ; i + + ) { IValueVariable variable = variables [ i ] ; if ( ! variable . isReadOnly ( ) ) { if ( ! variable . isContributed ( ) | | ( ( ContributedValueVariable ) variable ) . isInitialized ( ) ) { Element element = document . createElement ( VALUE_VARIABLE_TAG ) ; element . setAttribute ( NAME_TAG , variable . getName ( ) ) ; String value = variable . getValue ( ) ; if ( value ! = null ) { element . setAttribute ( VALUE_TAG , value ) ; } element . setAttribute ( READ_ONLY_TAG , variable . isReadOnly ( ) ? TRUE_VALUE : FALSE_VALUE ) ; String description = variable . getDescription ( ) ; if ( description ! = null ) { element . setAttribute ( DESCRIPTION_TAG , description ) ; } rootElement . appendChild ( element ) ; } } } return serializeDocument ( document ) ; } private Document getDocument ( ) throws ParserConfigurationException { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document doc = docBuilder . newDocument ( ) ; return doc ; } private String serializeDocument ( Document doc ) throws TransformerException , UnsupportedEncodingException { ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer transformer = factory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . METHOD , <str> ) ; transformer . setOutputProperty ( OutputKeys . INDENT , <str> ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult outputTarget = new StreamResult ( s ) ; transformer . transform ( source , outputTarget ) ; return s . toString ( <str> ) ; } private synchronized void storeValueVariables ( ) { String variableString = <str> ; if ( ! fValueVariables . isEmpty ( ) ) { try { variableString = getValueVariablesAsXML ( ) ; } catch ( IOException e ) { VariablesPlugin . log ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , IStatus . ERROR , <str> , e ) ) ; return ; } catch ( ParserConfigurationException e ) { VariablesPlugin . log ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , IStatus . ERROR , <str> , e ) ) ; return ; } catch ( TransformerException e ) { VariablesPlugin . log ( new Status ( IStatus . ERROR , VariablesPlugin . getUniqueIdentifier ( ) , IStatus . ERROR , <str> , e ) ) ; return ; } } fInternalChange = true ; try { IEclipsePreferences prefs = InstanceScope . INSTANCE . getNode ( VariablesPlugin . PI_CORE_VARIABLES ) ; prefs . put ( PREF_VALUE_VARIABLES , variableString ) ; prefs . flush ( ) ; } catch ( BackingStoreException bse ) { VariablesPlugin . log ( bse ) ; } fInternalChange = false ; } protected void notifyChanged ( IValueVariable variable ) { if ( ! fInternalChange ) { IValueVariable existing = getValueVariable ( variable . getName ( ) ) ; if ( variable . equals ( existing ) ) { getNotifier ( ) . notify ( new IValueVariable [ ] { variable } , CHANGED ) ; } } } @Override public String generateVariableExpression ( String varName , String arg ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( <str> ) ; buffer . append ( varName ) ; if ( arg ! = null ) { buffer . append ( <str> ) ; buffer . append ( arg ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } @Override public String performStringSubstitution ( String expression , boolean reportUndefinedVariables ) throws CoreException { return new StringSubstitutionEngine ( ) . performStringSubstitution ( expression , reportUndefinedVariables , true , this ) ; } @Override public void validateStringVariables ( String expression ) throws CoreException { new StringSubstitutionEngine ( ) . validateStringVariables ( expression , this ) ; } @Override public String getContributingPluginId ( IStringVariable variable ) { if ( variable instanceof StringVariable ) { return ( ( StringVariable ) variable ) . getConfigurationElement ( ) . getContributor ( ) . getName ( ) ; } return null ; } @Override public void preferenceChange ( PreferenceChangeEvent event ) { if ( PREF_VALUE_VARIABLES . equals ( event . getKey ( ) ) ) { synchronized ( this ) { if ( ! fInternalChange ) { fValueVariables . clear ( ) ; loadPersistedValueVariables ( ) ; loadContributedValueVariables ( ) ; } } } } }