package org . elasticsearch . common . settings ; import org . elasticsearch . Version ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . property . PropertyPlaceholder ; import org . elasticsearch . common . settings . loader . SettingsLoader ; import org . elasticsearch . common . settings . loader . SettingsLoaderFactory ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . MemorySizeValue ; import org . elasticsearch . common . unit . RatioValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Dictionary ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . SortedMap ; import java . util . TreeMap ; import java . util . concurrent . TimeUnit ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . Strings . toCamelCase ; import static org . elasticsearch . common . unit . ByteSizeValue . parseBytesSizeValue ; import static org . elasticsearch . common . unit . SizeValue . parseSizeValue ; import static org . elasticsearch . common . unit . TimeValue . parseTimeValue ; public final class Settings implements ToXContent { public static final Settings EMPTY = new Builder ( ) . build ( ) ; private static final Pattern ARRAY_PATTERN = Pattern . compile ( <str> ) ; public static final String SETTINGS_REQUIRE_UNITS = <str> ; private static boolean settingsRequireUnits = true ; public static void setSettingsRequireUnits ( boolean v ) { settingsRequireUnits = v ; } public static boolean getSettingsRequireUnits ( ) { return settingsRequireUnits ; } private final Map < String , String > forcedUnderscoreSettings ; private SortedMap < String , String > settings ; Settings ( Map < String , String > settings ) { this . settings = Collections . unmodifiableSortedMap ( new TreeMap < > ( settings ) ) ; Map < String , String > forcedUnderscoreSettings = null ; for ( Map . Entry < String , String > entry : settings . entrySet ( ) ) { String toUnderscoreCase = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; if ( ! toUnderscoreCase . equals ( entry . getKey ( ) ) ) { if ( forcedUnderscoreSettings = = null ) { forcedUnderscoreSettings = new HashMap < > ( ) ; } forcedUnderscoreSettings . put ( toUnderscoreCase , entry . getValue ( ) ) ; } } this . forcedUnderscoreSettings = forcedUnderscoreSettings = = null ? emptyMap ( ) : unmodifiableMap ( forcedUnderscoreSettings ) ; } public Map < String , String > getAsMap ( ) { return Collections . unmodifiableMap ( this . settings ) ; } public Map < String , Object > getAsStructuredMap ( ) { Map < String , Object > map = new HashMap < > ( <int> ) ; for ( Map . Entry < String , String > entry : settings . entrySet ( ) ) { processSetting ( map , <str> , entry . getKey ( ) , entry . getValue ( ) ) ; } for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) instanceof Map ) { @SuppressWarnings ( <str> ) Map < String , Object > valMap = ( Map < String , Object > ) entry . getValue ( ) ; entry . setValue ( convertMapsToArrays ( valMap ) ) ; } } return map ; } private void processSetting ( Map < String , Object > map , String prefix , String setting , String value ) { int prefixLength = setting . indexOf ( <str> ) ; if ( prefixLength = = - <int> ) { @SuppressWarnings ( <str> ) Map < String , Object > innerMap = ( Map < String , Object > ) map . get ( prefix + setting ) ; if ( innerMap ! = null ) { for ( Map . Entry < String , Object > entry : innerMap . entrySet ( ) ) { map . put ( prefix + setting + <str> + entry . getKey ( ) , entry . getValue ( ) ) ; } } map . put ( prefix + setting , value ) ; } else { String key = setting . substring ( <int> , prefixLength ) ; String rest = setting . substring ( prefixLength + <int> ) ; Object existingValue = map . get ( prefix + key ) ; if ( existingValue = = null ) { Map < String , Object > newMap = new HashMap < > ( <int> ) ; processSetting ( newMap , <str> , rest , value ) ; map . put ( key , newMap ) ; } else { if ( existingValue instanceof Map ) { @SuppressWarnings ( <str> ) Map < String , Object > innerMap = ( Map < String , Object > ) existingValue ; processSetting ( innerMap , <str> , rest , value ) ; map . put ( key , innerMap ) ; } else { processSetting ( map , prefix + key + <str> , rest , value ) ; } } } } private Object convertMapsToArrays ( Map < String , Object > map ) { if ( map . isEmpty ( ) ) { return map ; } boolean isArray = true ; int maxIndex = - <int> ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( isArray ) { try { int index = Integer . parseInt ( entry . getKey ( ) ) ; if ( index > = <int> ) { maxIndex = Math . max ( maxIndex , index ) ; } else { isArray = false ; } } catch ( NumberFormatException ex ) { isArray = false ; } } if ( entry . getValue ( ) instanceof Map ) { @SuppressWarnings ( <str> ) Map < String , Object > valMap = ( Map < String , Object > ) entry . getValue ( ) ; entry . setValue ( convertMapsToArrays ( valMap ) ) ; } } if ( isArray & & ( maxIndex + <int> ) = = map . size ( ) ) { ArrayList < Object > newValue = new ArrayList < > ( maxIndex + <int> ) ; for ( int i = <int> ; i < = maxIndex ; i + + ) { Object obj = map . get ( Integer . toString ( i ) ) ; if ( obj = = null ) { return map ; } newValue . add ( obj ) ; } return newValue ; } return map ; } public Settings getByPrefix ( String prefix ) { Builder builder = new Builder ( ) ; for ( Map . Entry < String , String > entry : getAsMap ( ) . entrySet ( ) ) { if ( entry . getKey ( ) . startsWith ( prefix ) ) { if ( entry . getKey ( ) . length ( ) < prefix . length ( ) ) { continue ; } builder . put ( entry . getKey ( ) . substring ( prefix . length ( ) ) , entry . getValue ( ) ) ; } } return builder . build ( ) ; } public Settings getAsSettings ( String setting ) { return getByPrefix ( setting + <str> ) ; } public String get ( String setting ) { String retVal = settings . get ( setting ) ; if ( retVal ! = null ) { return retVal ; } return forcedUnderscoreSettings . get ( setting ) ; } public String get ( String [ ] settings ) { for ( String setting : settings ) { String retVal = get ( setting ) ; if ( retVal ! = null ) { return retVal ; } } return null ; } public String get ( String setting , String defaultValue ) { String retVal = get ( setting ) ; return retVal = = null ? defaultValue : retVal ; } public String get ( String [ ] settings , String defaultValue ) { String retVal = get ( settings ) ; return retVal = = null ? defaultValue : retVal ; } public Float getAsFloat ( String setting , Float defaultValue ) { String sValue = get ( setting ) ; if ( sValue = = null ) { return defaultValue ; } try { return Float . parseFloat ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + setting + <str> + sValue + <str> , e ) ; } } public Float getAsFloat ( String [ ] settings , Float defaultValue ) throws SettingsException { String sValue = get ( settings ) ; if ( sValue = = null ) { return defaultValue ; } try { return Float . parseFloat ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + Arrays . toString ( settings ) + <str> + sValue + <str> , e ) ; } } public Double getAsDouble ( String setting , Double defaultValue ) { String sValue = get ( setting ) ; if ( sValue = = null ) { return defaultValue ; } try { return Double . parseDouble ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + setting + <str> + sValue + <str> , e ) ; } } public Double getAsDouble ( String [ ] settings , Double defaultValue ) { String sValue = get ( settings ) ; if ( sValue = = null ) { return defaultValue ; } try { return Double . parseDouble ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + Arrays . toString ( settings ) + <str> + sValue + <str> , e ) ; } } public Integer getAsInt ( String setting , Integer defaultValue ) { String sValue = get ( setting ) ; if ( sValue = = null ) { return defaultValue ; } try { return Integer . parseInt ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + setting + <str> + sValue + <str> , e ) ; } } public Integer getAsInt ( String [ ] settings , Integer defaultValue ) { String sValue = get ( settings ) ; if ( sValue = = null ) { return defaultValue ; } try { return Integer . parseInt ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + Arrays . toString ( settings ) + <str> + sValue + <str> , e ) ; } } public Long getAsLong ( String setting , Long defaultValue ) { String sValue = get ( setting ) ; if ( sValue = = null ) { return defaultValue ; } try { return Long . parseLong ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + setting + <str> + sValue + <str> , e ) ; } } public Long getAsLong ( String [ ] settings , Long defaultValue ) { String sValue = get ( settings ) ; if ( sValue = = null ) { return defaultValue ; } try { return Long . parseLong ( sValue ) ; } catch ( NumberFormatException e ) { throw new SettingsException ( <str> + Arrays . toString ( settings ) + <str> + sValue + <str> , e ) ; } } public Boolean getAsBoolean ( String setting , Boolean defaultValue ) { return Booleans . parseBoolean ( get ( setting ) , defaultValue ) ; } public Boolean getAsBoolean ( String [ ] settings , Boolean defaultValue ) { return Booleans . parseBoolean ( get ( settings ) , defaultValue ) ; } public TimeValue getAsTime ( String setting , TimeValue defaultValue ) { return parseTimeValue ( get ( setting ) , defaultValue , setting ) ; } public TimeValue getAsTime ( String [ ] settings , TimeValue defaultValue ) { for ( String setting : settings ) { String retVal = get ( setting ) ; if ( retVal ! = null ) { parseTimeValue ( get ( settings ) , defaultValue , setting ) ; } } return defaultValue ; } public ByteSizeValue getAsBytesSize ( String setting , ByteSizeValue defaultValue ) throws SettingsException { return parseBytesSizeValue ( get ( setting ) , defaultValue , setting ) ; } public ByteSizeValue getAsBytesSize ( String [ ] settings , ByteSizeValue defaultValue ) throws SettingsException { for ( String setting : settings ) { String retVal = get ( setting ) ; if ( retVal ! = null ) { parseBytesSizeValue ( get ( settings ) , defaultValue , setting ) ; } } return defaultValue ; } public ByteSizeValue getAsMemory ( String setting , String defaultValue ) throws SettingsException { return MemorySizeValue . parseBytesSizeValueOrHeapRatio ( get ( setting , defaultValue ) , setting ) ; } public ByteSizeValue getAsMemory ( String [ ] settings , String defaultValue ) throws SettingsException { for ( String setting : settings ) { String retVal = get ( setting ) ; if ( retVal ! = null ) { return MemorySizeValue . parseBytesSizeValueOrHeapRatio ( retVal , setting ) ; } } return MemorySizeValue . parseBytesSizeValueOrHeapRatio ( defaultValue , settings [ <int> ] ) ; } public RatioValue getAsRatio ( String setting , String defaultValue ) throws SettingsException { return RatioValue . parseRatioValue ( get ( setting , defaultValue ) ) ; } public RatioValue getAsRatio ( String [ ] settings , String defaultValue ) throws SettingsException { return RatioValue . parseRatioValue ( get ( settings , defaultValue ) ) ; } public SizeValue getAsSize ( String setting , SizeValue defaultValue ) throws SettingsException { return parseSizeValue ( get ( setting ) , defaultValue ) ; } public SizeValue getAsSize ( String [ ] settings , SizeValue defaultValue ) throws SettingsException { return parseSizeValue ( get ( settings ) , defaultValue ) ; } public String [ ] getAsArray ( String settingPrefix ) throws SettingsException { return getAsArray ( settingPrefix , Strings . EMPTY_ARRAY , true ) ; } public String [ ] getAsArray ( String settingPrefix , String [ ] defaultArray ) throws SettingsException { return getAsArray ( settingPrefix , defaultArray , true ) ; } public String [ ] getAsArray ( String settingPrefix , String [ ] defaultArray , Boolean commaDelimited ) throws SettingsException { List < String > result = new ArrayList < > ( ) ; if ( get ( settingPrefix ) ! = null ) { if ( commaDelimited ) { String [ ] strings = Strings . splitStringByCommaToArray ( get ( settingPrefix ) ) ; if ( strings . length > <int> ) { for ( String string : strings ) { result . add ( string . trim ( ) ) ; } } } else { result . add ( get ( settingPrefix ) . trim ( ) ) ; } } int counter = <int> ; while ( true ) { String value = get ( settingPrefix + <str> + ( counter + + ) ) ; if ( value = = null ) { break ; } result . add ( value . trim ( ) ) ; } if ( result . isEmpty ( ) ) { return defaultArray ; } return result . toArray ( new String [ result . size ( ) ] ) ; } public Map < String , Settings > getGroups ( String settingPrefix ) throws SettingsException { return getGroups ( settingPrefix , false ) ; } public Map < String , Settings > getGroups ( String settingPrefix , boolean ignoreNonGrouped ) throws SettingsException { if ( ! Strings . hasLength ( settingPrefix ) ) { throw new IllegalArgumentException ( <str> + settingPrefix ) ; } if ( settingPrefix . charAt ( settingPrefix . length ( ) - <int> ) ! = <str> ) { settingPrefix = settingPrefix + <str> ; } Map < String , Map < String , String > > map = new LinkedHashMap < > ( ) ; for ( Object o : settings . keySet ( ) ) { String setting = ( String ) o ; if ( setting . startsWith ( settingPrefix ) ) { String nameValue = setting . substring ( settingPrefix . length ( ) ) ; int dotIndex = nameValue . indexOf ( <str> ) ; if ( dotIndex = = - <int> ) { if ( ignoreNonGrouped ) { continue ; } throw new SettingsException ( <str> + settingPrefix + <str> + setting + <str> ) ; } String name = nameValue . substring ( <int> , dotIndex ) ; String value = nameValue . substring ( dotIndex + <int> ) ; Map < String , String > groupSettings = map . get ( name ) ; if ( groupSettings = = null ) { groupSettings = new LinkedHashMap < > ( ) ; map . put ( name , groupSettings ) ; } groupSettings . put ( value , get ( setting ) ) ; } } Map < String , Settings > retVal = new LinkedHashMap < > ( ) ; for ( Map . Entry < String , Map < String , String > > entry : map . entrySet ( ) ) { retVal . put ( entry . getKey ( ) , new Settings ( Collections . unmodifiableMap ( entry . getValue ( ) ) ) ) ; } return Collections . unmodifiableMap ( retVal ) ; } public Version getAsVersion ( String setting , Version defaultVersion ) throws SettingsException { String sValue = get ( setting ) ; if ( sValue = = null ) { return defaultVersion ; } try { return Version . fromId ( Integer . parseInt ( sValue ) ) ; } catch ( Exception e ) { throw new SettingsException ( <str> + setting + <str> + sValue + <str> , e ) ; } } public Set < String > names ( ) { Set < String > names = new HashSet < > ( ) ; for ( String key : settings . keySet ( ) ) { int i = key . indexOf ( <str> ) ; if ( i < <int> ) { names . add ( key ) ; } else { names . add ( key . substring ( <int> , i ) ) ; } } return names ; } public String toDelimitedString ( char delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < String , String > entry : settings . entrySet ( ) ) { sb . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) . append ( delimiter ) ; } return sb . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Settings that = ( Settings ) o ; if ( settings ! = null ? ! settings . equals ( that . settings ) : that . settings ! = null ) return false ; return true ; } @Override public int hashCode ( ) { int result = settings ! = null ? settings . hashCode ( ) : <int> ; return result ; } public static Settings readSettingsFromStream ( StreamInput in ) throws IOException { Builder builder = new Builder ( ) ; int numberOfSettings = in . readVInt ( ) ; for ( int i = <int> ; i < numberOfSettings ; i + + ) { builder . put ( in . readString ( ) , in . readString ( ) ) ; } return builder . build ( ) ; } public static void writeSettingsToStream ( Settings settings , StreamOutput out ) throws IOException { out . writeVInt ( settings . getAsMap ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : settings . getAsMap ( ) . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeString ( entry . getValue ( ) ) ; } } public static Builder builder ( ) { return new Builder ( ) ; } public static Builder settingsBuilder ( ) { return new Builder ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { Settings settings = SettingsFilter . filterSettings ( params , this ) ; if ( ! params . paramAsBoolean ( <str> , false ) ) { for ( Map . Entry < String , Object > entry : settings . getAsStructuredMap ( ) . entrySet ( ) ) { builder . field ( entry . getKey ( ) , entry . getValue ( ) ) ; } } else { for ( Map . Entry < String , String > entry : settings . getAsMap ( ) . entrySet ( ) ) { builder . field ( entry . getKey ( ) , entry . getValue ( ) , XContentBuilder . FieldCaseConversion . NONE ) ; } } return builder ; } public static class Builder { public static final Settings EMPTY_SETTINGS = new Builder ( ) . build ( ) ; private final Map < String , String > map = new LinkedHashMap < > ( ) ; private Builder ( ) { } public Map < String , String > internalMap ( ) { return this . map ; } public String remove ( String key ) { return map . remove ( key ) ; } public String get ( String key ) { String retVal = map . get ( key ) ; if ( retVal ! = null ) { return retVal ; } return map . get ( toCamelCase ( key ) ) ; } public Builder put ( Object . . . settings ) { if ( settings . length = = <int> ) { if ( settings [ <int> ] instanceof Map ) { return put ( ( Map ) settings [ <int> ] ) ; } else if ( settings [ <int> ] instanceof Settings ) { return put ( ( Settings ) settings [ <int> ] ) ; } } if ( ( settings . length % <int> ) ! = <int> ) { throw new IllegalArgumentException ( <str> + settings . length + <str> ) ; } for ( int i = <int> ; i < settings . length ; i + + ) { put ( settings [ i + + ] . toString ( ) , settings [ i ] . toString ( ) ) ; } return this ; } public Builder put ( String key , String value ) { map . put ( key , value ) ; return this ; } public Builder put ( String key , Class clazz ) { map . put ( key , clazz . getName ( ) ) ; return this ; } public Builder put ( String setting , boolean value ) { put ( setting , String . valueOf ( value ) ) ; return this ; } public Builder put ( String setting , int value ) { put ( setting , String . valueOf ( value ) ) ; return this ; } public Builder put ( String setting , Version version ) { put ( setting , version . id ) ; return this ; } public Builder put ( String setting , long value ) { put ( setting , String . valueOf ( value ) ) ; return this ; } public Builder put ( String setting , float value ) { put ( setting , String . valueOf ( value ) ) ; return this ; } public Builder put ( String setting , double value ) { put ( setting , String . valueOf ( value ) ) ; return this ; } public Builder put ( String setting , long value , TimeUnit timeUnit ) { put ( setting , timeUnit . toMillis ( value ) + <str> ) ; return this ; } public Builder put ( String setting , long value , ByteSizeUnit sizeUnit ) { put ( setting , sizeUnit . toBytes ( value ) + <str> ) ; return this ; } public Builder putArray ( String setting , String . . . values ) { remove ( setting ) ; int counter = <int> ; while ( true ) { String value = map . remove ( setting + <str> + ( counter + + ) ) ; if ( value = = null ) { break ; } } for ( int i = <int> ; i < values . length ; i + + ) { put ( setting + <str> + i , values [ i ] ) ; } return this ; } public Builder extendArray ( String setting , String . . . values ) { String oldSingle = remove ( setting ) ; int counter = <int> ; while ( map . containsKey ( setting + <str> + counter ) ) { + + counter ; } if ( oldSingle ! = null ) { put ( setting + <str> + counter + + , oldSingle ) ; } for ( String value : values ) { put ( setting + <str> + counter + + , value ) ; } return this ; } public Builder put ( String settingPrefix , String groupName , String [ ] settings , String [ ] values ) throws SettingsException { if ( settings . length ! = values . length ) { throw new SettingsException ( <str> ) ; } for ( int i = <int> ; i < settings . length ; i + + ) { if ( values [ i ] = = null ) { continue ; } put ( settingPrefix + <str> + groupName + <str> + settings [ i ] , values [ i ] ) ; } return this ; } public Builder put ( Settings settings ) { removeNonArraysFieldsIfNewSettingsContainsFieldAsArray ( settings . getAsMap ( ) ) ; map . putAll ( settings . getAsMap ( ) ) ; return this ; } public Builder put ( Map < String , String > settings ) { removeNonArraysFieldsIfNewSettingsContainsFieldAsArray ( settings ) ; map . putAll ( settings ) ; return this ; } private void removeNonArraysFieldsIfNewSettingsContainsFieldAsArray ( Map < String , String > settings ) { List < String > prefixesToRemove = new ArrayList < > ( ) ; for ( final Map . Entry < String , String > entry : settings . entrySet ( ) ) { final Matcher matcher = ARRAY_PATTERN . matcher ( entry . getKey ( ) ) ; if ( matcher . matches ( ) ) { prefixesToRemove . add ( matcher . group ( <int> ) ) ; } else if ( map . keySet ( ) . stream ( ) . anyMatch ( key - > key . startsWith ( entry . getKey ( ) + <str> ) ) ) { prefixesToRemove . add ( entry . getKey ( ) ) ; } } for ( String prefix : prefixesToRemove ) { Iterator < Map . Entry < String , String > > iterator = map . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , String > entry = iterator . next ( ) ; if ( entry . getKey ( ) . startsWith ( prefix + <str> ) | | entry . getKey ( ) . equals ( prefix ) ) { iterator . remove ( ) ; } } } } public Builder put ( Dictionary < Object , Object > properties ) { for ( Object key : Collections . list ( properties . keys ( ) ) ) { map . put ( Objects . toString ( key ) , Objects . toString ( properties . get ( key ) ) ) ; } return this ; } public Builder loadFromDelimitedString ( String value , char delimiter ) { String [ ] values = Strings . splitStringToArray ( value , delimiter ) ; for ( String s : values ) { int index = s . indexOf ( <str> ) ; if ( index = = - <int> ) { throw new IllegalArgumentException ( <str> + s + <str> + delimiter + <str> ) ; } map . put ( s . substring ( <int> , index ) , s . substring ( index + <int> ) ) ; } return this ; } public Builder loadFromSource ( String source ) { SettingsLoader settingsLoader = SettingsLoaderFactory . loaderFromSource ( source ) ; try { Map < String , String > loadedSettings = settingsLoader . load ( source ) ; put ( loadedSettings ) ; } catch ( Exception e ) { throw new SettingsException ( <str> + source + <str> , e ) ; } return this ; } public Builder loadFromPath ( Path path ) throws SettingsException { try { return loadFromStream ( path . getFileName ( ) . toString ( ) , Files . newInputStream ( path ) ) ; } catch ( IOException e ) { throw new SettingsException ( <str> + path + <str> , e ) ; } } public Builder loadFromStream ( String resourceName , InputStream is ) throws SettingsException { SettingsLoader settingsLoader = SettingsLoaderFactory . loaderFromResource ( resourceName ) ; try { Map < String , String > loadedSettings = settingsLoader . load ( Streams . copyToString ( new InputStreamReader ( is , StandardCharsets . UTF_8 ) ) ) ; put ( loadedSettings ) ; } catch ( Exception e ) { throw new SettingsException ( <str> + resourceName + <str> , e ) ; } return this ; } public Builder putProperties ( String prefix , Dictionary < Object , Object > properties ) { for ( Object key1 : Collections . list ( properties . keys ( ) ) ) { String key = Objects . toString ( key1 ) ; String value = Objects . toString ( properties . get ( key ) ) ; if ( key . startsWith ( prefix ) ) { map . put ( key . substring ( prefix . length ( ) ) , value ) ; } } return this ; } public Builder putProperties ( String prefix , Dictionary < Object , Object > properties , String [ ] ignorePrefixes ) { for ( Object key1 : Collections . list ( properties . keys ( ) ) ) { String key = Objects . toString ( key1 ) ; String value = Objects . toString ( properties . get ( key ) ) ; if ( key . startsWith ( prefix ) ) { boolean ignore = false ; for ( String ignorePrefix : ignorePrefixes ) { if ( key . startsWith ( ignorePrefix ) ) { ignore = true ; break ; } } if ( ! ignore ) { map . put ( key . substring ( prefix . length ( ) ) , value ) ; } } } return this ; } public Builder replacePropertyPlaceholders ( ) { PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder ( <str> , <str> , false ) ; PropertyPlaceholder . PlaceholderResolver placeholderResolver = new PropertyPlaceholder . PlaceholderResolver ( ) { @Override public String resolvePlaceholder ( String placeholderName ) { if ( placeholderName . startsWith ( <str> ) ) { return System . getenv ( placeholderName . substring ( <str> . length ( ) ) ) ; } String value = System . getProperty ( placeholderName ) ; if ( value ! = null ) { return value ; } value = System . getenv ( placeholderName ) ; if ( value ! = null ) { return value ; } return map . get ( placeholderName ) ; } @Override public boolean shouldIgnoreMissing ( String placeholderName ) { if ( placeholderName . startsWith ( <str> ) | | placeholderName . startsWith ( <str> ) ) { return true ; } return false ; } @Override public boolean shouldRemoveMissingPlaceholder ( String placeholderName ) { if ( placeholderName . startsWith ( <str> ) ) { return false ; } return true ; } } ; for ( Map . Entry < String , String > entry : new HashMap < > ( map ) . entrySet ( ) ) { String value = propertyPlaceholder . replacePlaceholders ( entry . getValue ( ) , placeholderResolver ) ; if ( Strings . hasLength ( value ) ) { map . put ( entry . getKey ( ) , value ) ; } else { map . remove ( entry . getKey ( ) ) ; } } return this ; } public Builder normalizePrefix ( String prefix ) { Map < String , String > replacements = new HashMap < > ( ) ; Iterator < Map . Entry < String , String > > iterator = map . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , String > entry = iterator . next ( ) ; if ( entry . getKey ( ) . startsWith ( prefix ) = = false ) { replacements . put ( prefix + entry . getKey ( ) , entry . getValue ( ) ) ; iterator . remove ( ) ; } } map . putAll ( replacements ) ; return this ; } public Settings build ( ) { return new Settings ( Collections . unmodifiableMap ( map ) ) ; } } } 
