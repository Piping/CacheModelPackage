package org . eclipse . debug . core ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . eclipse . core . resources . ISaveContext ; import org . eclipse . core . resources . ISaveParticipant ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IAdapterManager ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . core . runtime . Plugin ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDisconnect ; import org . eclipse . debug . core . model . IDropToFrame ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . IStep ; import org . eclipse . debug . core . model . IStepFilter ; import org . eclipse . debug . core . model . IStepFilters ; import org . eclipse . debug . core . model . ISuspendResume ; import org . eclipse . debug . core . model . ITerminate ; import org . eclipse . debug . core . model . IValue ; import org . eclipse . debug . core . model . RuntimeProcess ; import org . eclipse . debug . internal . core . BreakpointManager ; import org . eclipse . debug . internal . core . DebugCoreMessages ; import org . eclipse . debug . internal . core . DebugOptions ; import org . eclipse . debug . internal . core . ExpressionManager ; import org . eclipse . debug . internal . core . IConfigurationElementConstants ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . core . LaunchManager ; import org . eclipse . debug . internal . core . LogicalStructureManager ; import org . eclipse . debug . internal . core . MemoryBlockManager ; import org . eclipse . debug . internal . core . Preferences ; import org . eclipse . debug . internal . core . StepFilterManager ; import org . eclipse . debug . internal . core . commands . CommandAdapterFactory ; import org . eclipse . debug . internal . core . sourcelookup . SourceLookupUtils ; import org . eclipse . osgi . service . environment . Constants ; import org . osgi . framework . BundleContext ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import com . ibm . icu . text . MessageFormat ; public class DebugPlugin extends Plugin { private static final String PI_DEBUG_CORE = <str> ; public static final String EXTENSION_POINT_LAUNCH_CONFIGURATION_TYPES = <str> ; public static final String EXTENSION_POINT_LAUNCH_CONFIGURATION_COMPARATORS = <str> ; public static final String EXTENSION_POINT_BREAKPOINTS = <str> ; public static final String EXTENSION_POINT_STATUS_HANDLERS = <str> ; public static final String EXTENSION_POINT_SOURCE_LOCATORS = <str> ; public static final String EXTENSION_POINT_LAUNCH_MODES = <str> ; public static final String EXTENSION_POINT_LAUNCH_DELEGATES = <str> ; public static final String EXTENSION_POINT_PROCESS_FACTORIES = <str> ; public static final String EXTENSION_POINT_LOGICAL_STRUCTURE_TYPES = <str> ; public static final String EXTENSION_POINT_LOGICAL_STRUCTURE_PROVIDERS = <str> ; public static final String EXTENSION_POINT_SOURCE_CONTAINER_TYPES = <str> ; public static final String EXTENSION_POINT_SOURCE_PATH_COMPUTERS = <str> ; public static final String EXTENSION_POINT_LAUNCH_OPTIONS = <str> ; public static final String EXTENSION_POINT_BREAKPOINT_IMPORT_PARTICIPANTS = <str> ; public static final String EXTENSION_POINT_STEP_FILTERS = <str> ; public static final int ERROR = <int> ; public static final int INTERNAL_ERROR = <int> ; public static final int ERR_WORKING_DIRECTORY_NOT_SUPPORTED = <int> ; public static final String ATTR_PROCESS_FACTORY_ID = <str> ; public static final String ATTR_CAPTURE_OUTPUT = PI_DEBUG_CORE + <str> ; public static final String ATTR_LAUNCH_TIMESTAMP = PI_DEBUG_CORE + <str> ; public static final String ATTR_CONSOLE_ENCODING = <str> ; public static final String PREF_DELETE_CONFIGS_ON_PROJECT_DELETE = PI_DEBUG_CORE + <str> ; public static final String ATTR_BREAKPOINT_IS_DELETED = PI_DEBUG_CORE + <str> ; public static final String ATTR_ENVIRONMENT = PI_DEBUG_CORE + <str> ; public static final String ATTR_WORKING_DIRECTORY = PI_DEBUG_CORE + <str> ; public static final String ATTR_PATH = PI_DEBUG_CORE + <str> ; private static DebugPlugin fgDebugPlugin = null ; private BreakpointManager fBreakpointManager ; private ExpressionManager fExpressionManager ; private LaunchManager fLaunchManager ; private MemoryBlockManager fMemoryBlockManager ; private ListenerList fEventListeners = new ListenerList ( ) ; private ListenerList fEventFilters = new ListenerList ( ) ; private boolean fShuttingDown = false ; private HashMap < StatusHandlerKey , IConfigurationElement > fStatusHandlers = null ; private HashMap < String , IConfigurationElement > fProcessFactories = null ; private static final int NOTIFY_FILTERS = <int> ; private static final int NOTIFY_EVENTS = <int> ; private List < Object > fEventQueue = new ArrayList < Object > ( ) ; private EventDispatchJob fEventDispatchJob = new EventDispatchJob ( ) ; class EventDispatchJob extends Job { EventNotifier fNotifier = new EventNotifier ( ) ; AsynchRunner fRunner = new AsynchRunner ( ) ; public EventDispatchJob ( ) { super ( DebugCoreMessages . DebugPlugin_1 ) ; setPriority ( Job . INTERACTIVE ) ; setSystem ( true ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { while ( ! fEventQueue . isEmpty ( ) ) { Object next = null ; synchronized ( fEventQueue ) { if ( ! fEventQueue . isEmpty ( ) ) { next = fEventQueue . remove ( <int> ) ; } } if ( next instanceof Runnable ) { fRunner . async ( ( Runnable ) next ) ; } else if ( next ! = null ) { fNotifier . dispatch ( ( DebugEvent [ ] ) next ) ; } } return Status . OK_STATUS ; } @Override public boolean shouldRun ( ) { return shouldSchedule ( ) ; } @Override public boolean shouldSchedule ( ) { return ! ( isShuttingDown ( ) | | fEventListeners . isEmpty ( ) ) ; } } public static DebugPlugin getDefault ( ) { return fgDebugPlugin ; } private static void setDefault ( DebugPlugin plugin ) { fgDebugPlugin = plugin ; } public static String getUniqueIdentifier ( ) { return PI_DEBUG_CORE ; } public DebugPlugin ( ) { super ( ) ; setDefault ( this ) ; } public void addDebugEventListener ( IDebugEventSetListener listener ) { fEventListeners . add ( listener ) ; } public void fireDebugEventSet ( DebugEvent [ ] events ) { if ( isShuttingDown ( ) | | events = = null | | fEventListeners . isEmpty ( ) ) { return ; } synchronized ( fEventQueue ) { fEventQueue . add ( events ) ; } fEventDispatchJob . schedule ( ) ; } public void asyncExec ( Runnable r ) { synchronized ( fEventQueue ) { fEventQueue . add ( r ) ; } fEventDispatchJob . schedule ( ) ; } public synchronized IBreakpointManager getBreakpointManager ( ) { if ( fBreakpointManager = = null ) { fBreakpointManager = new BreakpointManager ( ) ; } return fBreakpointManager ; } public synchronized ILaunchManager getLaunchManager ( ) { if ( fLaunchManager = = null ) { fLaunchManager = new LaunchManager ( ) ; } return fLaunchManager ; } public synchronized IMemoryBlockManager getMemoryBlockManager ( ) { if ( fMemoryBlockManager = = null ) { fMemoryBlockManager = new MemoryBlockManager ( ) ; } return fMemoryBlockManager ; } public IStatusHandler getStatusHandler ( IStatus status ) { boolean enabled = Platform . getPreferencesService ( ) . getBoolean ( DebugPlugin . getUniqueIdentifier ( ) , IInternalDebugCoreConstants . PREF_ENABLE_STATUS_HANDLERS , true , null ) ; if ( ! enabled ) { return null ; } StatusHandlerKey key = new StatusHandlerKey ( status . getPlugin ( ) , status . getCode ( ) ) ; if ( fStatusHandlers = = null ) { initializeStatusHandlers ( ) ; } IConfigurationElement config = fStatusHandlers . get ( key ) ; if ( config ! = null ) { try { Object handler = config . createExecutableExtension ( IConfigurationElementConstants . CLASS ) ; if ( handler instanceof IStatusHandler ) { return ( IStatusHandler ) handler ; } invalidStatusHandler ( null , MessageFormat . format ( <str> , new Object [ ] { config . getDeclaringExtension ( ) . getUniqueIdentifier ( ) } ) ) ; } catch ( CoreException e ) { log ( e ) ; } } return null ; } public synchronized IExpressionManager getExpressionManager ( ) { if ( fExpressionManager = = null ) { fExpressionManager = new ExpressionManager ( ) ; } return fExpressionManager ; } public void removeDebugEventListener ( IDebugEventSetListener listener ) { fEventListeners . remove ( listener ) ; } @Override public void stop ( BundleContext context ) throws Exception { try { setShuttingDown ( true ) ; if ( fLaunchManager ! = null ) { fLaunchManager . shutdown ( ) ; } if ( fBreakpointManager ! = null ) { fBreakpointManager . shutdown ( ) ; } if ( fMemoryBlockManager ! = null ) { fMemoryBlockManager . shutdown ( ) ; } fEventListeners . clear ( ) ; fEventFilters . clear ( ) ; SourceLookupUtils . shutdown ( ) ; Preferences . savePreferences ( DebugPlugin . getUniqueIdentifier ( ) ) ; ResourcesPlugin . getWorkspace ( ) . removeSaveParticipant ( getUniqueIdentifier ( ) ) ; } finally { super . stop ( context ) ; setDefault ( null ) ; } } @Override public void start ( BundleContext context ) throws Exception { super . start ( context ) ; new DebugOptions ( context ) ; ResourcesPlugin . getWorkspace ( ) . addSaveParticipant ( getUniqueIdentifier ( ) , new ISaveParticipant ( ) { @Override public void saving ( ISaveContext saveContext ) throws CoreException { if ( fExpressionManager ! = null ) { fExpressionManager . storeWatchExpressions ( ) ; } Preferences . savePreferences ( DebugPlugin . getUniqueIdentifier ( ) ) ; } @Override public void rollback ( ISaveContext saveContext ) { } @Override public void prepareToSave ( ISaveContext saveContext ) throws CoreException { } @Override public void doneSaving ( ISaveContext saveContext ) { } } ) ; IAdapterManager manager = Platform . getAdapterManager ( ) ; CommandAdapterFactory actionFactory = new CommandAdapterFactory ( ) ; manager . registerAdapters ( actionFactory , IDisconnect . class ) ; manager . registerAdapters ( actionFactory , IDropToFrame . class ) ; manager . registerAdapters ( actionFactory , IStep . class ) ; manager . registerAdapters ( actionFactory , IStepFilters . class ) ; manager . registerAdapters ( actionFactory , ISuspendResume . class ) ; manager . registerAdapters ( actionFactory , ITerminate . class ) ; manager . registerAdapters ( actionFactory , ILaunch . class ) ; manager . registerAdapters ( actionFactory , IProcess . class ) ; manager . registerAdapters ( actionFactory , IDebugElement . class ) ; } public static IProcess newProcess ( ILaunch launch , Process process , String label ) { return newProcess ( launch , process , label , null ) ; } public static IProcess newProcess ( ILaunch launch , Process process , String label , Map < String , String > attributes ) { ILaunchConfiguration config = launch . getLaunchConfiguration ( ) ; String processFactoryID = null ; if ( config ! = null ) { try { processFactoryID = config . getAttribute ( ATTR_PROCESS_FACTORY_ID , ( String ) null ) ; } catch ( CoreException e ) { } } if ( processFactoryID ! = null ) { DebugPlugin plugin = DebugPlugin . getDefault ( ) ; if ( plugin . fProcessFactories = = null ) { plugin . initializeProcessFactories ( ) ; } IConfigurationElement element = plugin . fProcessFactories . get ( processFactoryID ) ; if ( element = = null ) { return null ; } IProcessFactory processFactory = null ; try { processFactory = ( IProcessFactory ) element . createExecutableExtension ( IConfigurationElementConstants . CLASS ) ; } catch ( CoreException exception ) { log ( exception ) ; return null ; } return processFactory . newProcess ( launch , process , label , attributes ) ; } return new RuntimeProcess ( launch , process , label , attributes ) ; } public static ILogicalStructureType [ ] getLogicalStructureTypes ( IValue value ) { return LogicalStructureManager . getDefault ( ) . getLogicalStructureTypes ( value ) ; } public static ILogicalStructureType getDefaultStructureType ( ILogicalStructureType [ ] types ) { return LogicalStructureManager . getDefault ( ) . getSelectedStructureType ( types ) ; } public static void setDefaultStructureType ( ILogicalStructureType [ ] types , ILogicalStructureType def ) { LogicalStructureManager . getDefault ( ) . setEnabledType ( types , def ) ; } public static Process exec ( String [ ] cmdLine , File workingDirectory ) throws CoreException { return exec ( cmdLine , workingDirectory , null ) ; } public static Process exec ( String [ ] cmdLine , File workingDirectory , String [ ] envp ) throws CoreException { Process p = null ; try { if ( workingDirectory = = null ) { p = Runtime . getRuntime ( ) . exec ( cmdLine , envp ) ; } else { p = Runtime . getRuntime ( ) . exec ( cmdLine , envp , workingDirectory ) ; } } catch ( IOException e ) { Status status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , DebugCoreMessages . DebugPlugin_0 , e ) ; throw new CoreException ( status ) ; } catch ( NoSuchMethodError e ) { IStatus status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERR_WORKING_DIRECTORY_NOT_SUPPORTED , DebugCoreMessages . DebugPlugin_Eclipse_runtime_does_not_support_working_directory_2 , e ) ; IStatusHandler handler = DebugPlugin . getDefault ( ) . getStatusHandler ( status ) ; if ( handler ! = null ) { Object result = handler . handleStatus ( status , null ) ; if ( result instanceof Boolean & & ( ( Boolean ) result ) . booleanValue ( ) ) { p = exec ( cmdLine , null ) ; } } } return p ; } private boolean isShuttingDown ( ) { return fShuttingDown ; } private void setShuttingDown ( boolean value ) { fShuttingDown = value ; } private Object [ ] getEventListeners ( ) { return fEventListeners . getListeners ( ) ; } public void addDebugEventFilter ( IDebugEventFilter filter ) { fEventFilters . add ( filter ) ; } public void removeDebugEventFilter ( IDebugEventFilter filter ) { fEventFilters . remove ( filter ) ; } public static void logDebugMessage ( String message ) { if ( getDefault ( ) . isDebugging ( ) ) { log ( new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , MessageFormat . format ( DebugCoreMessages . DebugPlugin_2 , new Object [ ] { message } ) , null ) ) ; } } public static void logMessage ( String message , Throwable throwable ) { log ( new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , message , throwable ) ) ; } public static void log ( IStatus status ) { getDefault ( ) . getLog ( ) . log ( status ) ; } public static void log ( Throwable t ) { IStatus status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , DebugCoreMessages . DebugPlugin_3 , t ) ; log ( status ) ; } private void initializeStatusHandlers ( ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugPlugin . PI_DEBUG_CORE , EXTENSION_POINT_STATUS_HANDLERS ) ; IConfigurationElement [ ] infos = extensionPoint . getConfigurationElements ( ) ; fStatusHandlers = new HashMap < StatusHandlerKey , IConfigurationElement > ( infos . length ) ; for ( int i = <int> ; i < infos . length ; i + + ) { IConfigurationElement configurationElement = infos [ i ] ; String id = configurationElement . getAttribute ( <str> ) ; String code = configurationElement . getAttribute ( <str> ) ; if ( id ! = null & & code ! = null ) { try { StatusHandlerKey key = new StatusHandlerKey ( id , Integer . parseInt ( code ) ) ; fStatusHandlers . put ( key , configurationElement ) ; } catch ( NumberFormatException e ) { invalidStatusHandler ( e , configurationElement . getAttribute ( <str> ) ) ; } } else { invalidStatusHandler ( null , configurationElement . getAttribute ( <str> ) ) ; } } } private void initializeProcessFactories ( ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugPlugin . PI_DEBUG_CORE , EXTENSION_POINT_PROCESS_FACTORIES ) ; IConfigurationElement [ ] infos = extensionPoint . getConfigurationElements ( ) ; fProcessFactories = new HashMap < String , IConfigurationElement > ( infos . length ) ; for ( int i = <int> ; i < infos . length ; i + + ) { IConfigurationElement configurationElement = infos [ i ] ; String id = configurationElement . getAttribute ( <str> ) ; String clss = configurationElement . getAttribute ( <str> ) ; if ( id ! = null & & clss ! = null ) { fProcessFactories . put ( id , configurationElement ) ; } else { String badDefiner = infos [ i ] . getContributor ( ) . getName ( ) ; log ( new Status ( IStatus . ERROR , DebugPlugin . PI_DEBUG_CORE , ERROR , MessageFormat . format ( DebugCoreMessages . DebugPlugin_4 , new Object [ ] { badDefiner , id } ) , null ) ) ; } } } private void invalidStatusHandler ( Exception e , String id ) { log ( new Status ( IStatus . ERROR , DebugPlugin . PI_DEBUG_CORE , ERROR , MessageFormat . format ( DebugCoreMessages . DebugPlugin_5 , new Object [ ] { id } ) , e ) ) ; } class StatusHandlerKey { String fPluginId ; int fCode ; StatusHandlerKey ( String pluginId , int code ) { fPluginId = pluginId ; fCode = code ; } @Override public int hashCode ( ) { return fPluginId . hashCode ( ) + fCode ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof StatusHandlerKey ) { StatusHandlerKey s = ( StatusHandlerKey ) obj ; return fCode = = s . fCode & & fPluginId . equals ( s . fPluginId ) ; } return false ; } } class AsynchRunner implements ISafeRunnable { private Runnable fRunnable = null ; void async ( Runnable runnable ) { fRunnable = runnable ; SafeRunner . run ( this ) ; fRunnable = null ; } @Override public void handleException ( Throwable exception ) { IStatus status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , DebugCoreMessages . DebugPlugin_6 , exception ) ; log ( status ) ; } @Override public void run ( ) throws Exception { fRunnable . run ( ) ; } } class EventNotifier implements ISafeRunnable { private DebugEvent [ ] fEvents ; private IDebugEventSetListener fListener ; private IDebugEventFilter fFilter ; private int fMode ; @Override public void handleException ( Throwable exception ) { switch ( fMode ) { case NOTIFY_FILTERS : IStatus status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , DebugCoreMessages . DebugPlugin_7 , exception ) ; log ( status ) ; break ; case NOTIFY_EVENTS : status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , ERROR , DebugCoreMessages . DebugPlugin_8 , exception ) ; log ( status ) ; break ; default : break ; } } @Override public void run ( ) throws Exception { switch ( fMode ) { case NOTIFY_FILTERS : fEvents = fFilter . filterDebugEvents ( fEvents ) ; break ; case NOTIFY_EVENTS : fListener . handleDebugEvents ( fEvents ) ; break ; default : break ; } } void dispatch ( DebugEvent [ ] events ) { fEvents = events ; Object [ ] filters = fEventFilters . getListeners ( ) ; if ( filters . length > <int> ) { fMode = NOTIFY_FILTERS ; for ( int i = <int> ; i < filters . length ; i + + ) { fFilter = ( IDebugEventFilter ) filters [ i ] ; SafeRunner . run ( this ) ; if ( fEvents = = null | | fEvents . length = = <int> ) { return ; } } } fMode = NOTIFY_EVENTS ; Object [ ] listeners = getEventListeners ( ) ; if ( DebugOptions . DEBUG_EVENTS ) { for ( int i = <int> ; i < fEvents . length ; i + + ) { DebugOptions . trace ( fEvents [ i ] . toString ( ) ) ; } } for ( int i = <int> ; i < listeners . length ; i + + ) { fListener = ( IDebugEventSetListener ) listeners [ i ] ; SafeRunner . run ( this ) ; } fEvents = null ; fFilter = null ; fListener = null ; } } public static Document newDocument ( ) throws CoreException { try { return LaunchManager . getDocument ( ) ; } catch ( ParserConfigurationException e ) { abort ( <str> , e ) ; } return null ; } public static String serializeDocument ( Document document ) throws CoreException { try { return LaunchManager . serializeDocument ( document ) ; } catch ( TransformerException e ) { abort ( <str> , e ) ; } catch ( IOException e ) { abort ( <str> , e ) ; } return null ; } public static Element parseDocument ( String document ) throws CoreException { Element root = null ; InputStream stream = null ; try { DocumentBuilder parser = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; parser . setErrorHandler ( new DefaultHandler ( ) ) ; stream = new ByteArrayInputStream ( document . getBytes ( <str> ) ) ; root = parser . parse ( stream ) . getDocumentElement ( ) ; } catch ( ParserConfigurationException e ) { abort ( <str> , e ) ; } catch ( FactoryConfigurationError e ) { abort ( <str> , e ) ; } catch ( SAXException e ) { abort ( <str> , e ) ; } catch ( IOException e ) { abort ( <str> , e ) ; } finally { try { if ( stream ! = null ) { stream . close ( ) ; } } catch ( IOException e ) { abort ( <str> , e ) ; } } return root ; } private static void abort ( String message , Throwable exception ) throws CoreException { IStatus status = new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugPlugin . ERROR , message , exception ) ; throw new CoreException ( status ) ; } private static String [ ] parseArgumentsWindows ( String args , boolean split ) { List < String > result = new ArrayList < String > ( ) ; final int DEFAULT = <int> ; final int ARG = <int> ; final int IN_DOUBLE_QUOTE = <int> ; int state = DEFAULT ; int backslashes = <int> ; StringBuffer buf = new StringBuffer ( ) ; int len = args . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { char ch = args . charAt ( i ) ; if ( ch = = <str> ) { backslashes + + ; continue ; } else if ( backslashes ! = <int> ) { if ( ch = = <str> ) { for ( ; backslashes > = <int> ; backslashes - = <int> ) { buf . append ( <str> ) ; if ( split ) { buf . append ( <str> ) ; } } if ( backslashes = = <int> ) { if ( state = = DEFAULT ) { state = ARG ; } if ( split ) { buf . append ( <str> ) ; } buf . append ( <str> ) ; backslashes = <int> ; continue ; } } else { if ( state = = DEFAULT ) { state = ARG ; } for ( ; backslashes > <int> ; backslashes - - ) { buf . append ( <str> ) ; } } } if ( Character . isWhitespace ( ch ) ) { if ( state = = DEFAULT ) { continue ; } else if ( state = = ARG ) { state = DEFAULT ; result . add ( buf . toString ( ) ) ; buf . setLength ( <int> ) ; continue ; } } switch ( state ) { case DEFAULT : case ARG : if ( ch = = <str> ) { state = IN_DOUBLE_QUOTE ; if ( split ) { buf . append ( ch ) ; } } else { state = ARG ; buf . append ( ch ) ; } break ; case IN_DOUBLE_QUOTE : if ( ch = = <str> ) { if ( i + <int> < len & & args . charAt ( i + <int> ) = = <str> ) { buf . append ( <str> ) ; i + + ; if ( split ) { buf . append ( ch ) ; } } else if ( buf . length ( ) = = <int> ) { result . add ( <str> ) ; state = DEFAULT ; } else { state = ARG ; if ( split ) { buf . append ( ch ) ; } } } else { buf . append ( ch ) ; } break ; default: throw new IllegalStateException ( ) ; } } if ( buf . length ( ) > <int> | | state ! = DEFAULT ) { result . add ( buf . toString ( ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; } private static String [ ] parseArgumentsImpl ( String args , boolean split ) { List < String > result = new ArrayList < String > ( ) ; final int DEFAULT = <int> ; final int ARG = <int> ; final int IN_DOUBLE_QUOTE = <int> ; final int IN_SINGLE_QUOTE = <int> ; int state = DEFAULT ; StringBuffer buf = new StringBuffer ( ) ; int len = args . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { char ch = args . charAt ( i ) ; if ( Character . isWhitespace ( ch ) ) { if ( state = = DEFAULT ) { continue ; } else if ( state = = ARG ) { state = DEFAULT ; result . add ( buf . toString ( ) ) ; buf . setLength ( <int> ) ; continue ; } } switch ( state ) { case DEFAULT : case ARG : if ( ch = = <str> ) { if ( split ) { buf . append ( ch ) ; } state = IN_DOUBLE_QUOTE ; } else if ( ch = = <str> ) { if ( split ) { buf . append ( ch ) ; } state = IN_SINGLE_QUOTE ; } else if ( ch = = <str> & & i + <int> < len ) { if ( split ) { buf . append ( ch ) ; } state = ARG ; ch = args . charAt ( + + i ) ; buf . append ( ch ) ; } else { state = ARG ; buf . append ( ch ) ; } break ; case IN_DOUBLE_QUOTE : if ( ch = = <str> ) { if ( split ) { buf . append ( ch ) ; } state = ARG ; } else if ( ch = = <str> & & i + <int> < len & & ( args . charAt ( i + <int> ) = = <str> | | args . charAt ( i + <int> ) = = <str> ) ) { if ( split ) { buf . append ( ch ) ; } ch = args . charAt ( + + i ) ; buf . append ( ch ) ; } else { buf . append ( ch ) ; } break ; case IN_SINGLE_QUOTE : if ( ch = = <str> ) { if ( split ) { buf . append ( ch ) ; } state = ARG ; } else { buf . append ( ch ) ; } break ; default: throw new IllegalStateException ( ) ; } } if ( buf . length ( ) > <int> | | state ! = DEFAULT ) { result . add ( buf . toString ( ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; } public static String [ ] parseArguments ( String args ) { if ( args = = null ) { return new String [ <int> ] ; } if ( Constants . OS_WIN32 . equals ( Platform . getOS ( ) ) ) { return parseArgumentsWindows ( args , false ) ; } return parseArgumentsImpl ( args , false ) ; } public static String [ ] splitArguments ( String args ) { if ( args = = null ) { return new String [ <int> ] ; } if ( Constants . OS_WIN32 . equals ( Platform . getOS ( ) ) ) { return parseArgumentsWindows ( args , true ) ; } return parseArgumentsImpl ( args , true ) ; } public static String renderArguments ( String [ ] arguments , int [ ] segments ) { boolean isWin32 = Platform . getOS ( ) . equals ( Constants . OS_WIN32 ) ; StringBuffer buf = new StringBuffer ( ) ; int count = arguments . length ; for ( int i = <int> ; i < count ; i + + ) { if ( i > <int> ) { buf . append ( <str> ) ; } boolean containsSpace = false ; char [ ] characters = arguments [ i ] . toCharArray ( ) ; for ( int j = <int> ; j < characters . length ; j + + ) { char ch = characters [ j ] ; if ( ch = = <str> | | ch = = <str> ) { containsSpace = true ; buf . append ( <str> ) ; break ; } } int backslashes = <int> ; for ( int j = <int> ; j < characters . length ; j + + ) { char ch = characters [ j ] ; if ( ch = = <str> ) { if ( isWin32 ) { if ( j = = <int> & & characters . length = = <int> & & characters [ <int> ] = = <str> ) { buf . append ( <str> ) ; break ; } if ( backslashes > <int> ) { for ( ; backslashes > <int> ; backslashes - - ) { buf . append ( <str> ) ; } } } buf . append ( <str> ) ; } else if ( ch = = <str> ) { if ( isWin32 ) { backslashes + + ; } else { buf . append ( <str> ) ; } } buf . append ( ch ) ; } if ( containsSpace ) { buf . append ( <str> ) ; } else if ( characters . length = = <int> ) { buf . append ( <str> ) ; } if ( segments ! = null & & i < count - <int> ) { segments [ i ] = buf . length ( ) + <int> ; } } return buf . toString ( ) ; } public static void setUseStepFilters ( boolean useStepFilters ) { getStepFilterManager ( ) . setUseStepFilters ( useStepFilters ) ; } public static boolean isUseStepFilters ( ) { return getStepFilterManager ( ) . isUseStepFilters ( ) ; } public static IStepFilter [ ] getStepFilters ( String modelIdentifier ) { return getStepFilterManager ( ) . getStepFilters ( modelIdentifier ) ; } private static StepFilterManager getStepFilterManager ( ) { return ( ( LaunchManager ) getDefault ( ) . getLaunchManager ( ) ) . getStepFilterManager ( ) ; } public static Object getAdapter ( Object element , Class < ? > type ) { Object adapter = null ; if ( element ! = null ) { if ( type . isInstance ( element ) ) { return element ; } else { if ( element instanceof IAdaptable ) { adapter = ( ( IAdaptable ) element ) . getAdapter ( type ) ; } if ( adapter = = null & & ! ( element instanceof PlatformObject ) ) { adapter = Platform . getAdapterManager ( ) . getAdapter ( element , type ) ; } if ( adapter = = null ) { adapter = Platform . getAdapterManager ( ) . loadAdapter ( element , type . getName ( ) ) ; } } } return adapter ; } }