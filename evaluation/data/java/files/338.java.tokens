package org . elasticsearch . index . indexing ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . mapper . ParsedDocument ; import java . io . IOException ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; public final class IndexingSlowLog { private boolean reformat ; private long indexWarnThreshold ; private long indexInfoThreshold ; private long indexDebugThreshold ; private long indexTraceThreshold ; private int maxSourceCharsToLog ; private String level ; private final ESLogger indexLogger ; private final ESLogger deleteLogger ; private static final String INDEX_INDEXING_SLOWLOG_PREFIX = <str> ; public static final String INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_WARN = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_INFO = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_DEBUG = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_TRACE = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_REFORMAT = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_LEVEL = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; public static final String INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG = INDEX_INDEXING_SLOWLOG_PREFIX + <str> ; IndexingSlowLog ( Settings indexSettings ) { this ( indexSettings , Loggers . getLogger ( INDEX_INDEXING_SLOWLOG_PREFIX + <str> ) , Loggers . getLogger ( INDEX_INDEXING_SLOWLOG_PREFIX + <str> ) ) ; } IndexingSlowLog ( Settings indexSettings , ESLogger indexLogger , ESLogger deleteLogger ) { this . indexLogger = indexLogger ; this . deleteLogger = deleteLogger ; this . reformat = indexSettings . getAsBoolean ( INDEX_INDEXING_SLOWLOG_REFORMAT , true ) ; this . indexWarnThreshold = indexSettings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_WARN , TimeValue . timeValueNanos ( - <int> ) ) . nanos ( ) ; this . indexInfoThreshold = indexSettings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_INFO , TimeValue . timeValueNanos ( - <int> ) ) . nanos ( ) ; this . indexDebugThreshold = indexSettings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_DEBUG , TimeValue . timeValueNanos ( - <int> ) ) . nanos ( ) ; this . indexTraceThreshold = indexSettings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_TRACE , TimeValue . timeValueNanos ( - <int> ) ) . nanos ( ) ; this . level = indexSettings . get ( INDEX_INDEXING_SLOWLOG_LEVEL , <str> ) . toUpperCase ( Locale . ROOT ) ; this . maxSourceCharsToLog = readSourceToLog ( indexSettings ) ; indexLogger . setLevel ( level ) ; deleteLogger . setLevel ( level ) ; } synchronized void onRefreshSettings ( Settings settings ) { long indexWarnThreshold = settings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_WARN , TimeValue . timeValueNanos ( this . indexWarnThreshold ) ) . nanos ( ) ; if ( indexWarnThreshold ! = this . indexWarnThreshold ) { this . indexWarnThreshold = indexWarnThreshold ; } long indexInfoThreshold = settings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_INFO , TimeValue . timeValueNanos ( this . indexInfoThreshold ) ) . nanos ( ) ; if ( indexInfoThreshold ! = this . indexInfoThreshold ) { this . indexInfoThreshold = indexInfoThreshold ; } long indexDebugThreshold = settings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_DEBUG , TimeValue . timeValueNanos ( this . indexDebugThreshold ) ) . nanos ( ) ; if ( indexDebugThreshold ! = this . indexDebugThreshold ) { this . indexDebugThreshold = indexDebugThreshold ; } long indexTraceThreshold = settings . getAsTime ( INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_TRACE , TimeValue . timeValueNanos ( this . indexTraceThreshold ) ) . nanos ( ) ; if ( indexTraceThreshold ! = this . indexTraceThreshold ) { this . indexTraceThreshold = indexTraceThreshold ; } String level = settings . get ( INDEX_INDEXING_SLOWLOG_LEVEL , this . level ) ; if ( ! level . equals ( this . level ) ) { this . indexLogger . setLevel ( level . toUpperCase ( Locale . ROOT ) ) ; this . deleteLogger . setLevel ( level . toUpperCase ( Locale . ROOT ) ) ; this . level = level ; } boolean reformat = settings . getAsBoolean ( INDEX_INDEXING_SLOWLOG_REFORMAT , this . reformat ) ; if ( reformat ! = this . reformat ) { this . reformat = reformat ; } int maxSourceCharsToLog = readSourceToLog ( settings ) ; if ( maxSourceCharsToLog ! = this . maxSourceCharsToLog ) { this . maxSourceCharsToLog = maxSourceCharsToLog ; } } void postIndex ( Engine . Index index , long tookInNanos ) { postIndexing ( index . parsedDoc ( ) , tookInNanos ) ; } private int readSourceToLog ( Settings settings ) { String sourceToLog = settings . get ( INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG , <str> ) ; try { return Integer . parseInt ( sourceToLog , <int> ) ; } catch ( NumberFormatException e ) { return Booleans . parseBoolean ( sourceToLog , true ) ? Integer . MAX_VALUE : <int> ; } } private void postIndexing ( ParsedDocument doc , long tookInNanos ) { if ( indexWarnThreshold > = <int> & & tookInNanos > indexWarnThreshold ) { indexLogger . warn ( <str> , new SlowLogParsedDocumentPrinter ( doc , tookInNanos , reformat , maxSourceCharsToLog ) ) ; } else if ( indexInfoThreshold > = <int> & & tookInNanos > indexInfoThreshold ) { indexLogger . info ( <str> , new SlowLogParsedDocumentPrinter ( doc , tookInNanos , reformat , maxSourceCharsToLog ) ) ; } else if ( indexDebugThreshold > = <int> & & tookInNanos > indexDebugThreshold ) { indexLogger . debug ( <str> , new SlowLogParsedDocumentPrinter ( doc , tookInNanos , reformat , maxSourceCharsToLog ) ) ; } else if ( indexTraceThreshold > = <int> & & tookInNanos > indexTraceThreshold ) { indexLogger . trace ( <str> , new SlowLogParsedDocumentPrinter ( doc , tookInNanos , reformat , maxSourceCharsToLog ) ) ; } } static final class SlowLogParsedDocumentPrinter { private final ParsedDocument doc ; private final long tookInNanos ; private final boolean reformat ; private final int maxSourceCharsToLog ; SlowLogParsedDocumentPrinter ( ParsedDocument doc , long tookInNanos , boolean reformat , int maxSourceCharsToLog ) { this . doc = doc ; this . tookInNanos = tookInNanos ; this . reformat = reformat ; this . maxSourceCharsToLog = maxSourceCharsToLog ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( TimeValue . timeValueNanos ( tookInNanos ) ) . append ( <str> ) . append ( TimeUnit . NANOSECONDS . toMillis ( tookInNanos ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( doc . type ( ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( doc . id ( ) ) . append ( <str> ) ; if ( doc . routing ( ) = = null ) { sb . append ( <str> ) ; } else { sb . append ( <str> ) . append ( doc . routing ( ) ) . append ( <str> ) ; } if ( maxSourceCharsToLog = = <int> | | doc . source ( ) = = null | | doc . source ( ) . length ( ) = = <int> ) { return sb . toString ( ) ; } try { String source = XContentHelper . convertToJson ( doc . source ( ) , reformat ) ; sb . append ( <str> ) . append ( Strings . cleanTruncate ( source , maxSourceCharsToLog ) ) . append ( <str> ) ; } catch ( IOException e ) { sb . append ( <str> ) ; } return sb . toString ( ) ; } } } 
