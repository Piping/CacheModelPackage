package io . netty . handler . codec . compression ; final class FastLz { private static final int MAX_DISTANCE = <int> ; private static final int MAX_FARDISTANCE = <int> + MAX_DISTANCE - <int> ; private static final int HASH_LOG = <int> ; private static final int HASH_SIZE = <int> < < HASH_LOG ; private static final int HASH_MASK = HASH_SIZE - <int> ; private static final int MAX_COPY = <int> ; private static final int MAX_LEN = <int> + <int> ; private static final int MIN_RECOMENDED_LENGTH_FOR_LEVEL_2 = <int> * <int> ; static final int MAGIC_NUMBER = <str> < < <int> | <str> < < <int> | <str> ; static final byte BLOCK_TYPE_NON_COMPRESSED = <hex> ; static final byte BLOCK_TYPE_COMPRESSED = <hex> ; static final byte BLOCK_WITHOUT_CHECKSUM = <hex> ; static final byte BLOCK_WITH_CHECKSUM = <hex> ; static final int OPTIONS_OFFSET = <int> ; static final int CHECKSUM_OFFSET = <int> ; static final int MAX_CHUNK_LENGTH = <hex> ; static final int MIN_LENGTH_TO_COMPRESSION = <int> ; static final int LEVEL_AUTO = <int> ; static final int LEVEL_1 = <int> ; static final int LEVEL_2 = <int> ; static int calculateOutputBufferLength ( int inputLength ) { final int outputLength = ( int ) ( inputLength * <float> ) ; return Math . max ( outputLength , <int> ) ; } static int compress ( final byte [ ] input , final int inOffset , final int inLength , final byte [ ] output , final int outOffset , final int proposedLevel ) { final int level ; if ( proposedLevel = = LEVEL_AUTO ) { level = inLength < MIN_RECOMENDED_LENGTH_FOR_LEVEL_2 ? LEVEL_1 : LEVEL_2 ; } else { level = proposedLevel ; } int ip = <int> ; int ipBound = ip + inLength - <int> ; int ipLimit = ip + inLength - <int> ; int op = <int> ; int [ ] htab = new int [ HASH_SIZE ] ; int hslot ; int hval ; int copy ; if ( inLength < <int> ) { if ( inLength ! = <int> ) { output [ outOffset + op + + ] = ( byte ) ( inLength - <int> ) ; ipBound + + ; while ( ip < = ipBound ) { output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; } return inLength + <int> ; } return <int> ; } for ( hslot = <int> ; hslot < HASH_SIZE ; hslot + + ) { htab [ hslot ] = ip ; } copy = <int> ; output [ outOffset + op + + ] = MAX_COPY - <int> ; output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; while ( ip < ipLimit ) { int ref = <int> ; long distance = <int> ; int len = <int> ; int anchor = ip ; boolean matchLabel = false ; if ( level = = LEVEL_2 ) { if ( input [ inOffset + ip ] = = input [ inOffset + ip - <int> ] & & readU16 ( input , inOffset + ip - <int> ) = = readU16 ( input , inOffset + ip + <int> ) ) { distance = <int> ; ip + = <int> ; ref = anchor - <int> + <int> ; matchLabel = true ; } } if ( ! matchLabel ) { hval = hashFunction ( input , inOffset + ip ) ; hslot = hval ; ref = htab [ hval ] ; distance = anchor - ref ; htab [ hslot ] = anchor ; if ( distance = = <int> | | ( level = = LEVEL_1 ? distance > = MAX_DISTANCE : distance > = MAX_FARDISTANCE ) | | input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] | | input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] | | input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { output [ outOffset + op + + ] = input [ inOffset + anchor + + ] ; ip = anchor ; copy + + ; if ( copy = = MAX_COPY ) { copy = <int> ; output [ outOffset + op + + ] = MAX_COPY - <int> ; } continue ; } if ( level = = LEVEL_2 ) { if ( distance > = MAX_DISTANCE ) { if ( input [ inOffset + ip + + ] ! = input [ inOffset + ref + + ] | | input [ inOffset + ip + + ] ! = input [ inOffset + ref + + ] ) { output [ outOffset + op + + ] = input [ inOffset + anchor + + ] ; ip = anchor ; copy + + ; if ( copy = = MAX_COPY ) { copy = <int> ; output [ outOffset + op + + ] = MAX_COPY - <int> ; } continue ; } len + = <int> ; } } } ip = anchor + len ; distance - - ; if ( distance = = <int> ) { byte x = input [ inOffset + ip - <int> ] ; while ( ip < ipBound ) { if ( input [ inOffset + ref + + ] ! = x ) { break ; } else { ip + + ; } } } else { for ( ; ; ) { if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } while ( ip < ipBound ) { if ( input [ inOffset + ref + + ] ! = input [ inOffset + ip + + ] ) { break ; } } break ; } } if ( copy ! = <int> ) { output [ outOffset + op - copy - <int> ] = ( byte ) ( copy - <int> ) ; } else { op - - ; } copy = <int> ; ip - = <int> ; len = ip - anchor ; if ( level = = LEVEL_2 ) { if ( distance < MAX_DISTANCE ) { if ( len < <int> ) { output [ outOffset + op + + ] = ( byte ) ( ( len < < <int> ) + ( distance > > > <int> ) ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } else { output [ outOffset + op + + ] = ( byte ) ( ( <int> < < <int> ) + ( distance > > > <int> ) ) ; for ( len - = <int> ; len > = <int> ; len - = <int> ) { output [ outOffset + op + + ] = ( byte ) <int> ; } output [ outOffset + op + + ] = ( byte ) len ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } } else { if ( len < <int> ) { distance - = MAX_DISTANCE ; output [ outOffset + op + + ] = ( byte ) ( ( len < < <int> ) + <int> ) ; output [ outOffset + op + + ] = ( byte ) <int> ; output [ outOffset + op + + ] = ( byte ) ( distance > > > <int> ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } else { distance - = MAX_DISTANCE ; output [ outOffset + op + + ] = ( byte ) ( ( <int> < < <int> ) + <int> ) ; for ( len - = <int> ; len > = <int> ; len - = <int> ) { output [ outOffset + op + + ] = ( byte ) <int> ; } output [ outOffset + op + + ] = ( byte ) len ; output [ outOffset + op + + ] = ( byte ) <int> ; output [ outOffset + op + + ] = ( byte ) ( distance > > > <int> ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } } } else { if ( len > MAX_LEN - <int> ) { while ( len > MAX_LEN - <int> ) { output [ outOffset + op + + ] = ( byte ) ( ( <int> < < <int> ) + ( distance > > > <int> ) ) ; output [ outOffset + op + + ] = ( byte ) ( MAX_LEN - <int> - <int> - <int> ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; len - = MAX_LEN - <int> ; } } if ( len < <int> ) { output [ outOffset + op + + ] = ( byte ) ( ( len < < <int> ) + ( distance > > > <int> ) ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } else { output [ outOffset + op + + ] = ( byte ) ( ( <int> < < <int> ) + ( distance > > > <int> ) ) ; output [ outOffset + op + + ] = ( byte ) ( len - <int> ) ; output [ outOffset + op + + ] = ( byte ) ( distance & <int> ) ; } } hval = hashFunction ( input , inOffset + ip ) ; htab [ hval ] = ip + + ; hval = hashFunction ( input , inOffset + ip ) ; htab [ hval ] = ip + + ; output [ outOffset + op + + ] = MAX_COPY - <int> ; continue ; } ipBound + + ; while ( ip < = ipBound ) { output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; copy + + ; if ( copy = = MAX_COPY ) { copy = <int> ; output [ outOffset + op + + ] = MAX_COPY - <int> ; } } if ( copy ! = <int> ) { output [ outOffset + op - copy - <int> ] = ( byte ) ( copy - <int> ) ; } else { op - - ; } if ( level = = LEVEL_2 ) { output [ outOffset ] | = <int> < < <int> ; } return op ; } static int decompress ( final byte [ ] input , final int inOffset , final int inLength , final byte [ ] output , final int outOffset , final int outLength ) { final int level = ( input [ inOffset ] > > <int> ) + <int> ; if ( level ! = LEVEL_1 & & level ! = LEVEL_2 ) { throw new DecompressionException ( String . format ( <str> , level , LEVEL_1 , LEVEL_2 ) ) ; } int ip = <int> ; int op = <int> ; long ctrl = input [ inOffset + ip + + ] & <int> ; int loop = <int> ; do { int ref = op ; long len = ctrl > > <int> ; long ofs = ( ctrl & <int> ) < < <int> ; if ( ctrl > = <int> ) { len - - ; ref - = ofs ; int code ; if ( len = = <int> ) { if ( level = = LEVEL_1 ) { len + = input [ inOffset + ip + + ] & <hex> ; } else { do { code = input [ inOffset + ip + + ] & <hex> ; len + = code ; } while ( code = = <int> ) ; } } if ( level = = LEVEL_1 ) { ref - = input [ inOffset + ip + + ] & <hex> ; } else { code = input [ inOffset + ip + + ] & <hex> ; ref - = code ; if ( code = = <int> & & ofs = = <int> < < <int> ) { ofs = ( input [ inOffset + ip + + ] & <hex> ) < < <int> ; ofs + = input [ inOffset + ip + + ] & <hex> ; ref = ( int ) ( op - ofs - MAX_DISTANCE ) ; } } if ( op + len + <int> > outLength ) { return <int> ; } if ( ref - <int> < <int> ) { return <int> ; } if ( ip < inLength ) { ctrl = input [ inOffset + ip + + ] & <hex> ; } else { loop = <int> ; } if ( ref = = op ) { byte b = output [ outOffset + ref - <int> ] ; output [ outOffset + op + + ] = b ; output [ outOffset + op + + ] = b ; output [ outOffset + op + + ] = b ; while ( len ! = <int> ) { output [ outOffset + op + + ] = b ; - - len ; } } else { ref - - ; output [ outOffset + op + + ] = output [ outOffset + ref + + ] ; output [ outOffset + op + + ] = output [ outOffset + ref + + ] ; output [ outOffset + op + + ] = output [ outOffset + ref + + ] ; while ( len ! = <int> ) { output [ outOffset + op + + ] = output [ outOffset + ref + + ] ; - - len ; } } } else { ctrl + + ; if ( op + ctrl > outLength ) { return <int> ; } if ( ip + ctrl > inLength ) { return <int> ; } output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; for ( - - ctrl ; ctrl ! = <int> ; ctrl - - ) { output [ outOffset + op + + ] = input [ inOffset + ip + + ] ; } loop = ip < inLength ? <int> : <int> ; if ( loop ! = <int> ) { ctrl = input [ inOffset + ip + + ] & <hex> ; } } } while ( loop ! = <int> ) ; return op ; } private static int hashFunction ( byte [ ] p , int offset ) { int v = readU16 ( p , offset ) ; v ^ = readU16 ( p , offset + <int> ) ^ v > > <int> - HASH_LOG ; v & = HASH_MASK ; return v ; } private static int readU16 ( byte [ ] data , int offset ) { if ( offset + <int> > = data . length ) { return data [ offset ] & <hex> ; } return ( data [ offset + <int> ] & <hex> ) < < <int> | data [ offset ] & <hex> ; } private FastLz ( ) { } } 
