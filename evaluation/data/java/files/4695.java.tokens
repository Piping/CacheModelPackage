package io . netty . channel . pool ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . Channel ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . OneTimeTask ; import java . nio . channels . ClosedChannelException ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public final class FixedChannelPool extends SimpleChannelPool { private static final IllegalStateException FULL_EXCEPTION = new IllegalStateException ( <str> ) ; private static final TimeoutException TIMEOUT_EXCEPTION = new TimeoutException ( <str> ) ; static { FULL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; TIMEOUT_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } public enum AcquireTimeoutAction { NEW , FAIL } private final EventExecutor executor ; private final long acquireTimeoutNanos ; private final Runnable timeoutTask ; private final Queue < AcquireTask > pendingAcquireQueue = new ArrayDeque < AcquireTask > ( ) ; private final int maxConnections ; private final int maxPendingAcquires ; private int acquiredChannelCount ; private int pendingAcquireCount ; private boolean closed ; public FixedChannelPool ( Bootstrap bootstrap , ChannelPoolHandler handler , int maxConnections ) { this ( bootstrap , handler , maxConnections , Integer . MAX_VALUE ) ; } public FixedChannelPool ( Bootstrap bootstrap , ChannelPoolHandler handler , int maxConnections , int maxPendingAcquires ) { this ( bootstrap , handler , ChannelHealthChecker . ACTIVE , null , - <int> , maxConnections , maxPendingAcquires ) ; } public FixedChannelPool ( Bootstrap bootstrap , ChannelPoolHandler handler , ChannelHealthChecker healthCheck , AcquireTimeoutAction action , final long acquireTimeoutMillis , int maxConnections , int maxPendingAcquires ) { this ( bootstrap , handler , healthCheck , action , acquireTimeoutMillis , maxConnections , maxPendingAcquires , true ) ; } public FixedChannelPool ( Bootstrap bootstrap , ChannelPoolHandler handler , ChannelHealthChecker healthCheck , AcquireTimeoutAction action , final long acquireTimeoutMillis , int maxConnections , int maxPendingAcquires , final boolean releaseHealthCheck ) { super ( bootstrap , handler , healthCheck , releaseHealthCheck ) ; if ( maxConnections < <int> ) { throw new IllegalArgumentException ( <str> + maxConnections + <str> ) ; } if ( maxPendingAcquires < <int> ) { throw new IllegalArgumentException ( <str> + maxPendingAcquires + <str> ) ; } if ( action = = null & & acquireTimeoutMillis = = - <int> ) { timeoutTask = null ; acquireTimeoutNanos = - <int> ; } else if ( action = = null & & acquireTimeoutMillis ! = - <int> ) { throw new NullPointerException ( <str> ) ; } else if ( action ! = null & & acquireTimeoutMillis < <int> ) { throw new IllegalArgumentException ( <str> + acquireTimeoutMillis + <str> ) ; } else { acquireTimeoutNanos = TimeUnit . MILLISECONDS . toNanos ( acquireTimeoutMillis ) ; switch ( action ) { case FAIL : timeoutTask = new TimeoutTask ( ) { @Override public void onTimeout ( AcquireTask task ) { task . promise . setFailure ( TIMEOUT_EXCEPTION ) ; } } ; break ; case NEW : timeoutTask = new TimeoutTask ( ) { @Override public void onTimeout ( AcquireTask task ) { task . acquired ( ) ; FixedChannelPool . super . acquire ( task . promise ) ; } } ; break ; default : throw new Error ( ) ; } } executor = bootstrap . group ( ) . next ( ) ; this . maxConnections = maxConnections ; this . maxPendingAcquires = maxPendingAcquires ; } @Override public Future < Channel > acquire ( final Promise < Channel > promise ) { try { if ( executor . inEventLoop ( ) ) { acquire0 ( promise ) ; } else { executor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { acquire0 ( promise ) ; } } ) ; } } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } return promise ; } private void acquire0 ( final Promise < Channel > promise ) { assert executor . inEventLoop ( ) ; if ( closed ) { promise . setFailure ( new IllegalStateException ( <str> ) ) ; return ; } if ( acquiredChannelCount < maxConnections ) { assert acquiredChannelCount > = <int> ; Promise < Channel > p = executor . newPromise ( ) ; AcquireListener l = new AcquireListener ( promise ) ; l . acquired ( ) ; p . addListener ( l ) ; super . acquire ( p ) ; } else { if ( pendingAcquireCount > = maxPendingAcquires ) { promise . setFailure ( FULL_EXCEPTION ) ; } else { AcquireTask task = new AcquireTask ( promise ) ; if ( pendingAcquireQueue . offer ( task ) ) { + + pendingAcquireCount ; if ( timeoutTask ! = null ) { task . timeoutFuture = executor . schedule ( timeoutTask , acquireTimeoutNanos , TimeUnit . NANOSECONDS ) ; } } else { promise . setFailure ( FULL_EXCEPTION ) ; } } assert pendingAcquireCount > <int> ; } } @Override public Future < Void > release ( final Channel channel , final Promise < Void > promise ) { final Promise < Void > p = executor . newPromise ( ) ; super . release ( channel , p . addListener ( new FutureListener < Void > ( ) { @Override public void operationComplete ( Future < Void > future ) throws Exception { assert executor . inEventLoop ( ) ; if ( closed ) { promise . setFailure ( new IllegalStateException ( <str> ) ) ; return ; } if ( future . isSuccess ( ) ) { decrementAndRunTaskQueue ( ) ; promise . setSuccess ( null ) ; } else { Throwable cause = future . cause ( ) ; if ( ! ( cause instanceof IllegalArgumentException ) ) { decrementAndRunTaskQueue ( ) ; } promise . setFailure ( future . cause ( ) ) ; } } } ) ) ; return p ; } private void decrementAndRunTaskQueue ( ) { - - acquiredChannelCount ; assert acquiredChannelCount > = <int> ; runTaskQueue ( ) ; } private void runTaskQueue ( ) { while ( acquiredChannelCount < maxConnections ) { AcquireTask task = pendingAcquireQueue . poll ( ) ; if ( task = = null ) { break ; } ScheduledFuture < ? > timeoutFuture = task . timeoutFuture ; if ( timeoutFuture ! = null ) { timeoutFuture . cancel ( false ) ; } - - pendingAcquireCount ; task . acquired ( ) ; super . acquire ( task . promise ) ; } assert pendingAcquireCount > = <int> ; assert acquiredChannelCount > = <int> ; } private final class AcquireTask extends AcquireListener { final Promise < Channel > promise ; final long expireNanoTime = System . nanoTime ( ) + acquireTimeoutNanos ; ScheduledFuture < ? > timeoutFuture ; public AcquireTask ( Promise < Channel > promise ) { super ( promise ) ; this . promise = executor . < Channel > newPromise ( ) . addListener ( this ) ; } } private abstract class TimeoutTask implements Runnable { @Override public final void run ( ) { assert executor . inEventLoop ( ) ; long nanoTime = System . nanoTime ( ) ; for ( ; ; ) { AcquireTask task = pendingAcquireQueue . peek ( ) ; if ( task = = null | | nanoTime - task . expireNanoTime < <int> ) { break ; } pendingAcquireQueue . remove ( ) ; - - pendingAcquireCount ; onTimeout ( task ) ; } } public abstract void onTimeout ( AcquireTask task ) ; } private class AcquireListener implements FutureListener < Channel > { private final Promise < Channel > originalPromise ; protected boolean acquired ; AcquireListener ( Promise < Channel > originalPromise ) { this . originalPromise = originalPromise ; } @Override public void operationComplete ( Future < Channel > future ) throws Exception { assert executor . inEventLoop ( ) ; if ( closed ) { originalPromise . setFailure ( new IllegalStateException ( <str> ) ) ; return ; } if ( future . isSuccess ( ) ) { originalPromise . setSuccess ( future . getNow ( ) ) ; } else { if ( acquired ) { decrementAndRunTaskQueue ( ) ; } else { runTaskQueue ( ) ; } originalPromise . setFailure ( future . cause ( ) ) ; } } public void acquired ( ) { if ( acquired ) { return ; } acquiredChannelCount + + ; acquired = true ; } } @Override public void close ( ) { executor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { if ( ! closed ) { closed = true ; for ( ; ; ) { AcquireTask task = pendingAcquireQueue . poll ( ) ; if ( task = = null ) { break ; } ScheduledFuture < ? > f = task . timeoutFuture ; if ( f ! = null ) { f . cancel ( false ) ; } task . promise . setFailure ( new ClosedChannelException ( ) ) ; } acquiredChannelCount = <int> ; pendingAcquireCount = <int> ; FixedChannelPool . super . close ( ) ; } } } ) ; } }