package rx . internal . operators ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . Arrays ; import java . util . concurrent . TimeUnit ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import rx . Observable ; import rx . Observer ; import rx . Scheduler ; import rx . Subscriber ; import rx . exceptions . TestException ; import rx . functions . Action0 ; import rx . functions . Func1 ; import rx . observers . TestSubscriber ; import rx . schedulers . TestScheduler ; import rx . subjects . PublishSubject ; public class OperatorDebounceTest { private TestScheduler scheduler ; private Observer < String > observer ; private Scheduler . Worker innerScheduler ; @Before @SuppressWarnings ( <str> ) public void before ( ) { scheduler = new TestScheduler ( ) ; observer = mock ( Observer . class ) ; innerScheduler = scheduler . createWorker ( ) ; } @Test public void testDebounceWithCompleted ( ) { Observable < String > source = Observable . create ( new Observable . OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishCompleted ( observer , <int> ) ; } } ) ; Observable < String > sampled = source . debounce ( <int> , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testDebounceNeverEmits ( ) { Observable < String > source = Observable . create ( new Observable . OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishCompleted ( observer , <int> ) ; } } ) ; Observable < String > sampled = source . debounce ( <int> , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( anyString ( ) ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testDebounceWithError ( ) { Observable < String > source = Observable . create ( new Observable . OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { Exception error = new TestException ( ) ; publishNext ( observer , <int> , <str> ) ; publishNext ( observer , <int> , <str> ) ; publishError ( observer , <int> , error ) ; } } ) ; Observable < String > sampled = source . debounce ( <int> , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer ) . onNext ( <str> ) ; scheduler . advanceTimeTo ( <int> , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } private < T > void publishCompleted ( final Observer < T > observer , long delay ) { innerScheduler . schedule ( new Action0 ( ) { @Override public void call ( ) { observer . onCompleted ( ) ; } } , delay , TimeUnit . MILLISECONDS ) ; } private < T > void publishError ( final Observer < T > observer , long delay , final Exception error ) { innerScheduler . schedule ( new Action0 ( ) { @Override public void call ( ) { observer . onError ( error ) ; } } , delay , TimeUnit . MILLISECONDS ) ; } private < T > void publishNext ( final Observer < T > observer , final long delay , final T value ) { innerScheduler . schedule ( new Action0 ( ) { @Override public void call ( ) { observer . onNext ( value ) ; } } , delay , TimeUnit . MILLISECONDS ) ; } @Test public void debounceSelectorNormal1 ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > debouncer = PublishSubject . create ( ) ; Func1 < Integer , Observable < Integer > > debounceSel = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { return debouncer ; } } ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( <int> ) ; debouncer . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onNext ( <int> ) ; debouncer . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; inOrder . verify ( o ) . onNext ( <int> ) ; inOrder . verify ( o ) . onNext ( <int> ) ; inOrder . verify ( o ) . onNext ( <int> ) ; inOrder . verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void debounceSelectorFuncThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; Func1 < Integer , Observable < Integer > > debounceSel = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { throw new TestException ( ) ; } } ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( <int> ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; } @Test public void debounceSelectorObservableThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; Func1 < Integer , Observable < Integer > > debounceSel = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { return Observable . error ( new TestException ( ) ) ; } } ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( <int> ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onCompleted ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; } @Test public void debounceTimedLastIsNotLost ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; source . debounce ( <int> , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( o ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; verify ( o ) . onNext ( <int> ) ; verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void debounceSelectorLastIsNotLost ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > debouncer = PublishSubject . create ( ) ; Func1 < Integer , Observable < Integer > > debounceSel = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { return debouncer ; } } ; @SuppressWarnings ( <str> ) Observer < Object > o = mock ( Observer . class ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; debouncer . onCompleted ( ) ; verify ( o ) . onNext ( <int> ) ; verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void debounceWithTimeBackpressure ( ) throws InterruptedException { TestScheduler scheduler = new TestScheduler ( ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; Observable . merge ( Observable . just ( <int> ) , Observable . just ( <int> ) . delay ( <int> , TimeUnit . MILLISECONDS , scheduler ) ) . debounce ( <int> , TimeUnit . MILLISECONDS , scheduler ) . take ( <int> ) . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; subscriber . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; subscriber . assertTerminalEvent ( ) ; subscriber . assertNoErrors ( ) ; } }