package org . gradle . internal . text ; import org . gradle . logging . StyledTextOutput ; import org . gradle . logging . internal . AbstractStyledTextOutput ; import org . gradle . logging . internal . LinePrefixingStyledTextOutput ; import org . gradle . util . TreeVisitor ; public class TreeFormatter extends TreeVisitor < String > { private final StringBuilder buffer = new StringBuilder ( ) ; private final AbstractStyledTextOutput original ; private Node current ; public TreeFormatter ( ) { original = new AbstractStyledTextOutput ( ) { @Override protected void doAppend ( String text ) { buffer . append ( text ) ; } } ; current = new Node ( ) ; } @Override public String toString ( ) { return buffer . toString ( ) ; } @Override public void node ( String node ) { if ( current . traversing ) { current = new Node ( current , node ) ; if ( current . isRoot ( ) ) { original . append ( node ) ; current . valueWritten = true ; } } else { current = new Node ( current . parent , node ) ; } } @Override public void startChildren ( ) { current . traversing = true ; } @Override public void endChildren ( ) { if ( current . parent = = null ) { throw new IllegalStateException ( <str> ) ; } if ( ! current . traversing ) { current = current . parent ; } if ( current . isRoot ( ) ) { writeNode ( current ) ; } current = current . parent ; } private void writeNode ( Node node ) { if ( node . prefix = = null ) { node . prefix = node . isRoot ( ) ? <str> : node . parent . prefix + <str> ; } StyledTextOutput output = new LinePrefixingStyledTextOutput ( original , node . prefix , false ) ; if ( ! node . valueWritten ) { output . append ( node . parent . prefix ) ; output . append ( <str> ) ; output . append ( node . value ) ; } if ( node . canCollapseFirstChild ( ) ) { output . append ( <str> ) ; Node firstChild = node . firstChild ; output . append ( firstChild . value ) ; firstChild . valueWritten = true ; firstChild . prefix = node . prefix ; writeNode ( firstChild ) ; } else if ( node . firstChild ! = null ) { original . format ( <str> ) ; writeNode ( node . firstChild ) ; } if ( node . nextSibling ! = null ) { original . format ( <str> ) ; writeNode ( node . nextSibling ) ; } } private static class Node { final Node parent ; final String value ; boolean written ; boolean traversing ; Node firstChild ; Node lastChild ; Node nextSibling ; String prefix ; public boolean valueWritten ; private Node ( ) { this . parent = null ; this . value = null ; traversing = true ; written = true ; prefix = <str> ; } private Node ( Node parent , String value ) { this . parent = parent ; this . value = value ; if ( parent . firstChild = = null ) { parent . firstChild = this ; parent . lastChild = this ; } else { parent . lastChild . nextSibling = this ; parent . lastChild = this ; } } boolean canCollapseFirstChild ( ) { return firstChild ! = null & & firstChild . nextSibling = = null & & ! firstChild . canCollapseFirstChild ( ) ; } boolean isRoot ( ) { return parent . parent = = null ; } } } 
