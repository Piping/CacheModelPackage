package org . apache . cassandra . io . util ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . WritableByteChannel ; import org . apache . cassandra . config . Config ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Preconditions ; public class DataOutputBuffer extends BufferedDataOutputStreamPlus { private static final long DOUBLING_THRESHOLD = Long . getLong ( Config . PROPERTY_PREFIX + <str> , <int> ) ; public DataOutputBuffer ( ) { this ( <int> ) ; } public DataOutputBuffer ( int size ) { super ( ByteBuffer . allocate ( size ) ) ; } protected DataOutputBuffer ( ByteBuffer buffer ) { super ( buffer ) ; } @Override public void flush ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @VisibleForTesting static final int MAX_ARRAY_SIZE = Integer . MAX_VALUE - <int> ; @VisibleForTesting static int saturatedArraySizeCast ( long size ) { Preconditions . checkArgument ( size > = <int> ) ; return ( int ) Math . min ( MAX_ARRAY_SIZE , size ) ; } @VisibleForTesting static int checkedArraySizeCast ( long size ) { Preconditions . checkArgument ( size > = <int> ) ; Preconditions . checkArgument ( size < = MAX_ARRAY_SIZE ) ; return ( int ) size ; } @Override protected void doFlush ( int count ) throws IOException { reallocate ( count ) ; } @VisibleForTesting long capacity ( ) { return buffer . capacity ( ) ; } @VisibleForTesting long validateReallocation ( long newSize ) { int saturatedSize = saturatedArraySizeCast ( newSize ) ; if ( saturatedSize < = capacity ( ) ) throw new RuntimeException ( ) ; return saturatedSize ; } @VisibleForTesting long calculateNewSize ( long count ) { long capacity = capacity ( ) ; long newSize = capacity + count ; if ( capacity > <int> * <int> * DOUBLING_THRESHOLD ) newSize = Math . max ( ( capacity * <int> ) / <int> , newSize ) ; else newSize = Math . max ( capacity * <int> , newSize ) ; return validateReallocation ( newSize ) ; } protected void reallocate ( long count ) { if ( count < = <int> ) return ; ByteBuffer newBuffer = ByteBuffer . allocate ( checkedArraySizeCast ( calculateNewSize ( count ) ) ) ; buffer . flip ( ) ; newBuffer . put ( buffer ) ; buffer = newBuffer ; } @Override protected WritableByteChannel newDefaultChannel ( ) { return new GrowingChannel ( ) ; } @VisibleForTesting final class GrowingChannel implements WritableByteChannel { public int write ( ByteBuffer src ) throws IOException { int count = src . remaining ( ) ; reallocate ( count ) ; buffer . put ( src ) ; return count ; } public boolean isOpen ( ) { return true ; } public void close ( ) { } } @Override public void close ( ) { } public ByteBuffer buffer ( ) { ByteBuffer result = buffer . duplicate ( ) ; result . flip ( ) ; return result ; } public byte [ ] getData ( ) { assert buffer . arrayOffset ( ) = = <int> ; return buffer . array ( ) ; } public int getLength ( ) { return buffer . position ( ) ; } public boolean hasPosition ( ) { return true ; } public long position ( ) { return getLength ( ) ; } public byte [ ] toByteArray ( ) { ByteBuffer buffer = buffer ( ) ; byte [ ] result = new byte [ buffer . remaining ( ) ] ; buffer . get ( result ) ; return result ; } }