package org . nd4j . linalg . util ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . MathContext ; import java . math . RoundingMode ; class Rational implements Cloneable { static BigInteger MAX_INT = new BigInteger ( <str> ) ; static BigInteger MIN_INT = new BigInteger ( <str> ) ; static Rational ONE = new Rational ( <int> , <int> ) ; static Rational ZERO = new Rational ( ) ; BigInteger a ; BigInteger b ; public Rational ( ) { a = BigInteger . ZERO ; b = BigInteger . ONE ; } public Rational ( BigInteger a , BigInteger b ) { this . a = a ; this . b = b ; normalize ( ) ; } public Rational ( BigInteger a ) { this . a = a ; b = new BigInteger ( <str> ) ; } public Rational ( int a , int b ) { this ( new BigInteger ( <str> + a ) , new BigInteger ( <str> + b ) ) ; } public Rational ( String str ) throws NumberFormatException { this ( str , <int> ) ; } public Rational ( String str , int radix ) throws NumberFormatException { int hasslah = str . indexOf ( <str> ) ; if ( hasslah = = - <int> ) { a = new BigInteger ( str , radix ) ; b = new BigInteger ( <str> , radix ) ; } else { a = new BigInteger ( str . substring ( <int> , hasslah ) , radix ) ; b = new BigInteger ( str . substring ( hasslah + <int> ) , radix ) ; normalize ( ) ; } } public static Rational binomial ( Rational n , BigInteger m ) { if ( m . compareTo ( BigInteger . ZERO ) = = <int> ) { return Rational . ONE ; } Rational bin = n ; for ( BigInteger i = new BigInteger ( <str> ) ; i . compareTo ( m ) ! = <int> ; i = i . add ( BigInteger . ONE ) ) { bin = bin . multiply ( n . subtract ( i . subtract ( BigInteger . ONE ) ) ) . divide ( i ) ; } return bin ; } public static Rational binomial ( Rational n , int m ) { if ( m = = <int> ) { return Rational . ONE ; } Rational bin = n ; for ( int i = <int> ; i < = m ; i + + ) { bin = bin . multiply ( n . subtract ( i - <int> ) ) . divide ( i ) ; } return bin ; } @Override public Rational clone ( ) { BigInteger aclon = new BigInteger ( <str> + a ) ; BigInteger bclon = new BigInteger ( <str> + b ) ; return new Rational ( aclon , bclon ) ; } public Rational multiply ( final Rational val ) { BigInteger num = a . multiply ( val . a ) ; BigInteger deno = b . multiply ( val . b ) ; return ( new Rational ( num , deno ) ) ; } public Rational multiply ( final BigInteger val ) { Rational val2 = new Rational ( val , BigInteger . ONE ) ; return ( multiply ( val2 ) ) ; } public Rational multiply ( final int val ) { BigInteger tmp = new BigInteger ( <str> + val ) ; return multiply ( tmp ) ; } public Rational pow ( int exponent ) { if ( exponent = = <int> ) { return new Rational ( <int> , <int> ) ; } BigInteger num = a . pow ( Math . abs ( exponent ) ) ; BigInteger deno = b . pow ( Math . abs ( exponent ) ) ; if ( exponent > <int> ) { return ( new Rational ( num , deno ) ) ; } else { return ( new Rational ( deno , num ) ) ; } } public Rational pow ( BigInteger exponent ) throws NumberFormatException { if ( exponent . compareTo ( MAX_INT ) = = <int> ) { throw new NumberFormatException ( <str> + exponent . toString ( ) + <str> ) ; } if ( exponent . compareTo ( MIN_INT ) = = - <int> ) { throw new NumberFormatException ( <str> + exponent . toString ( ) + <str> ) ; } return pow ( exponent . intValue ( ) ) ; } public Rational divide ( final Rational val ) { BigInteger num = a . multiply ( val . b ) ; BigInteger deno = b . multiply ( val . a ) ; return ( new Rational ( num , deno ) ) ; } public Rational divide ( BigInteger val ) { Rational val2 = new Rational ( val , BigInteger . ONE ) ; return ( divide ( val2 ) ) ; } public Rational divide ( int val ) { Rational val2 = new Rational ( val , <int> ) ; return ( divide ( val2 ) ) ; } public Rational add ( Rational val ) { BigInteger num = a . multiply ( val . b ) . add ( b . multiply ( val . a ) ) ; BigInteger deno = b . multiply ( val . b ) ; return ( new Rational ( num , deno ) ) ; } public Rational add ( BigInteger val ) { Rational val2 = new Rational ( val , BigInteger . ONE ) ; return ( add ( val2 ) ) ; } public Rational negate ( ) { return ( new Rational ( a . negate ( ) , b ) ) ; } public Rational subtract ( Rational val ) { Rational val2 = val . negate ( ) ; return ( add ( val2 ) ) ; } public Rational subtract ( BigInteger val ) { Rational val2 = new Rational ( val , BigInteger . ONE ) ; return ( subtract ( val2 ) ) ; } public Rational subtract ( int val ) { Rational val2 = new Rational ( val , <int> ) ; return ( subtract ( val2 ) ) ; } public BigInteger numer ( ) { return a ; } public BigInteger denom ( ) { return b ; } public Rational abs ( ) { return ( new Rational ( a . abs ( ) , b . abs ( ) ) ) ; } public BigInteger floor ( ) { if ( b . compareTo ( BigInteger . ONE ) = = <int> ) { return a ; } else if ( a . compareTo ( BigInteger . ZERO ) > <int> ) { return a . divide ( b ) ; } else { return a . divide ( b ) . subtract ( BigInteger . ONE ) ; } } public BigInteger trunc ( ) { if ( b . compareTo ( BigInteger . ONE ) = = <int> ) { return a ; } else { return a . divide ( b ) ; } } public int compareTo ( final Rational val ) { final BigInteger left = a . multiply ( val . b ) ; final BigInteger right = val . a . multiply ( b ) ; return left . compareTo ( right ) ; } public int compareTo ( final BigInteger val ) { final Rational val2 = new Rational ( val , BigInteger . ONE ) ; return ( compareTo ( val2 ) ) ; } @Override public String toString ( ) { if ( b . compareTo ( BigInteger . ONE ) ! = <int> ) { return ( a . toString ( ) + <str> + b . toString ( ) ) ; } else { return a . toString ( ) ; } } public double doubleValue ( ) { BigDecimal adivb = ( new BigDecimal ( a ) ) . divide ( new BigDecimal ( b ) , MathContext . DECIMAL128 ) ; return adivb . doubleValue ( ) ; } public float floatValue ( ) { BigDecimal adivb = ( new BigDecimal ( a ) ) . divide ( new BigDecimal ( b ) , MathContext . DECIMAL128 ) ; return adivb . floatValue ( ) ; } public BigDecimal BigDecimalValue ( MathContext mc ) { BigDecimal n = new BigDecimal ( a ) ; BigDecimal d = new BigDecimal ( b ) ; return n . divide ( d , mc ) ; } public String toFString ( int digits ) { if ( b . compareTo ( BigInteger . ONE ) ! = <int> ) { MathContext mc = new MathContext ( digits , RoundingMode . DOWN ) ; BigDecimal f = ( new BigDecimal ( a ) ) . divide ( new BigDecimal ( b ) , mc ) ; return ( f . toString ( ) ) ; } else { return a . toString ( ) ; } } public Rational max ( final Rational val ) { if ( compareTo ( val ) > <int> ) { return this ; } else { return val ; } } public Rational min ( final Rational val ) { if ( compareTo ( val ) < <int> ) { return this ; } else { return val ; } } public Rational Pochhammer ( final BigInteger n ) { if ( n . compareTo ( BigInteger . ZERO ) < <int> ) { return null ; } else if ( n . compareTo ( BigInteger . ZERO ) = = <int> ) { return Rational . ONE ; } else { Rational res = new Rational ( a , b ) ; BigInteger i = BigInteger . ONE ; for ( ; i . compareTo ( n ) < <int> ; i = i . add ( BigInteger . ONE ) ) { res = res . multiply ( add ( i ) ) ; } return res ; } } public Rational Pochhammer ( int n ) { return Pochhammer ( new BigInteger ( <str> + n ) ) ; } protected void normalize ( ) { final BigInteger g = a . gcd ( b ) ; if ( g . compareTo ( BigInteger . ONE ) > <int> ) { a = a . divide ( g ) ; b = b . divide ( g ) ; } if ( b . compareTo ( BigInteger . ZERO ) = = - <int> ) { a = a . negate ( ) ; b = b . negate ( ) ; } } } 
