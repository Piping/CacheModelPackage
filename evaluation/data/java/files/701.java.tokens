private boolean removeIf ( Predicate < ? super V > valuePredicate ) { return Iterables . removeIf ( unfiltered . entrySet ( ) , Predicates . < Entry < K , V > > and ( predicate , Maps . < V > valuePredicateOnEntries ( valuePredicate ) ) ) ; } @Override public boolean removeAll ( Collection < ? > collection ) { return removeIf ( in ( collection ) ) ; } @Override public boolean retainAll ( Collection < ? > collection ) { return removeIf ( not ( in ( collection ) ) ) ; } @Override public Object [ ] toArray ( ) { return Lists . newArrayList ( iterator ( ) ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return Lists . newArrayList ( iterator ( ) ) . toArray ( array ) ; } } private static class FilteredKeyMap < K , V > extends AbstractFilteredMap < K , V > { Predicate < ? super K > keyPredicate ; FilteredKeyMap ( Map < K , V > unfiltered , Predicate < ? super K > keyPredicate , Predicate < ? super Entry < K , V > > entryPredicate ) { super ( unfiltered , entryPredicate ) ; this . keyPredicate = keyPredicate ; } @Override protected Set < Entry < K , V > > createEntrySet ( ) { return Sets . filter ( unfiltered . entrySet ( ) , predicate ) ; } @Override Set < K > createKeySet ( ) { return Sets . filter ( unfiltered . keySet ( ) , keyPredicate ) ; } @Override @SuppressWarnings ( <str> ) public boolean containsKey ( Object key ) { return unfiltered . containsKey ( key ) & & keyPredicate . apply ( ( K ) key ) ; } } static class FilteredEntryMap < K , V > extends AbstractFilteredMap < K , V > { final Set < Entry < K , V > > filteredEntrySet ; FilteredEntryMap ( Map < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { super ( unfiltered , entryPredicate ) ; filteredEntrySet = Sets . filter ( unfiltered . entrySet ( ) , predicate ) ; } @Override protected Set < Entry < K , V > > createEntrySet ( ) { return new EntrySet ( ) ; } @WeakOuter private class EntrySet extends ForwardingSet < Entry < K , V > > { @Override protected Set < Entry < K , V > > delegate ( ) { return filteredEntrySet ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return new TransformedIterator < Entry < K , V > , Entry < K , V > > ( filteredEntrySet . iterator ( ) ) { @Override Entry < K , V > transform ( final Entry < K , V > entry ) { return new ForwardingMapEntry < K , V > ( ) { @Override protected Entry < K , V > delegate ( ) { return entry ; } @Override public V setValue ( V newValue ) { checkArgument ( apply ( getKey ( ) , newValue ) ) ; return super . setValue ( newValue ) ; } } ; } } ; } } @Override Set < K > createKeySet ( ) { return new KeySet ( ) ; } @WeakOuter class KeySet extends Maps . KeySet < K , V > { KeySet ( ) { super ( FilteredEntryMap . this ) ; } @Override public boolean remove ( Object o ) { if ( containsKey ( o ) ) { unfiltered . remove ( o ) ; return true ; } return false ; } private boolean removeIf ( Predicate < ? super K > keyPredicate ) { return Iterables . removeIf ( unfiltered . entrySet ( ) , Predicates . < Entry < K , V > > and ( predicate , Maps . < K > keyPredicateOnEntries ( keyPredicate ) ) ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return removeIf ( in ( c ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return removeIf ( not ( in ( c ) ) ) ; } @Override public Object [ ] toArray ( ) { return Lists . newArrayList ( iterator ( ) ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return Lists . newArrayList ( iterator ( ) ) . toArray ( array ) ; } } } private static < K , V > SortedMap < K , V > filterFiltered ( FilteredEntrySortedMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( map . predicate , entryPredicate ) ; return new FilteredEntrySortedMap < K , V > ( map . sortedMap ( ) , predicate ) ; } private static class FilteredEntrySortedMap < K , V > extends FilteredEntryMap < K , V > implements SortedMap < K , V > { FilteredEntrySortedMap ( SortedMap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { super ( unfiltered , entryPredicate ) ; } SortedMap < K , V > sortedMap ( ) { return ( SortedMap < K , V > ) unfiltered ; } @Override public SortedSet < K > keySet ( ) { return ( SortedSet < K > ) super . keySet ( ) ; } @Override SortedSet < K > createKeySet ( ) { return new SortedKeySet ( ) ; } @WeakOuter class SortedKeySet extends KeySet implements SortedSet < K > { @Override public Comparator < ? super K > comparator ( ) { return sortedMap ( ) . comparator ( ) ; } @Override public SortedSet < K > subSet ( K fromElement , K toElement ) { return ( SortedSet < K > ) subMap ( fromElement , toElement ) . keySet ( ) ; } @Override public SortedSet < K > headSet ( K toElement ) { return ( SortedSet < K > ) headMap ( toElement ) . keySet ( ) ; } @Override public SortedSet < K > tailSet ( K fromElement ) { return ( SortedSet < K > ) tailMap ( fromElement ) . keySet ( ) ; } @Override public K first ( ) { return firstKey ( ) ; } @Override public K last ( ) { return lastKey ( ) ; } } @Override public Comparator < ? super K > comparator ( ) { return sortedMap ( ) . comparator ( ) ; } @Override public K firstKey ( ) { return keySet ( ) . iterator ( ) . next ( ) ; } @Override public K lastKey ( ) { SortedMap < K , V > headMap = sortedMap ( ) ; while ( true ) { K key = headMap . lastKey ( ) ; if ( apply ( key , unfiltered . get ( key ) ) ) { return key ; } headMap = sortedMap ( ) . headMap ( key ) ; } } @Override public SortedMap < K , V > headMap ( K toKey ) { return new FilteredEntrySortedMap < K , V > ( sortedMap ( ) . headMap ( toKey ) , predicate ) ; } @Override public SortedMap < K , V > subMap ( K fromKey , K toKey ) { return new FilteredEntrySortedMap < K , V > ( sortedMap ( ) . subMap ( fromKey , toKey ) , predicate ) ; } @Override public SortedMap < K , V > tailMap ( K fromKey ) { return new FilteredEntrySortedMap < K , V > ( sortedMap ( ) . tailMap ( fromKey ) , predicate ) ; } } @GwtIncompatible ( <str> ) private static < K , V > NavigableMap < K , V > filterFiltered ( FilteredEntryNavigableMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( map . entryPredicate , entryPredicate ) ; return new FilteredEntryNavigableMap < K , V > ( map . unfiltered , predicate ) ; } @GwtIncompatible ( <str> ) private static class FilteredEntryNavigableMap < K , V > extends AbstractNavigableMap < K , V > { private final NavigableMap < K , V > unfiltered ; private final Predicate < ? super Entry < K , V > > entryPredicate ; private final Map < K , V > filteredDelegate ; FilteredEntryNavigableMap ( NavigableMap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { this . unfiltered = checkNotNull ( unfiltered ) ; this . entryPredicate = entryPredicate ; this . filteredDelegate = new FilteredEntryMap < K , V > ( unfiltered , entryPredicate ) ; } @Override public Comparator < ? super K > comparator ( ) { return unfiltered . comparator ( ) ; } @Override public NavigableSet < K > navigableKeySet ( ) { return new Maps . NavigableKeySet < K , V > ( this ) { @Override public boolean removeAll ( Collection < ? > c ) { return Iterators . removeIf ( unfiltered . entrySet ( ) . iterator ( ) , Predicates . < Entry < K , V > > and ( entryPredicate , Maps . < K > keyPredicateOnEntries ( in ( c ) ) ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return Iterators . removeIf ( unfiltered . entrySet ( ) . iterator ( ) , Predicates . < Entry < K , V > > and ( entryPredicate , Maps . < K > keyPredicateOnEntries ( not ( in ( c ) ) ) ) ) ; } } ; } @Override public Collection < V > values ( ) { return new FilteredMapValues < K , V > ( this , unfiltered , entryPredicate ) ; } @Override Iterator < Entry < K , V > > entryIterator ( ) { return Iterators . filter ( unfiltered . entrySet ( ) . iterator ( ) , entryPredicate ) ; } @Override Iterator < Entry < K , V > > descendingEntryIterator ( ) { return Iterators . filter ( unfiltered . descendingMap ( ) . entrySet ( ) . iterator ( ) , entryPredicate ) ; } @Override public int size ( ) { return filteredDelegate . size ( ) ; } @Override public boolean isEmpty ( ) { return ! Iterables . any ( unfiltered . entrySet ( ) , entryPredicate ) ; } @Override @Nullable public V get ( @Nullable Object key ) { return filteredDelegate . get ( key ) ; } @Override public boolean containsKey ( @Nullable Object key ) { return filteredDelegate . containsKey ( key ) ; } @Override public V put ( K key , V value ) { return filteredDelegate . put ( key , value ) ; } @Override public V remove ( @Nullable Object key ) { return filteredDelegate . remove ( key ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > m ) { filteredDelegate . putAll ( m ) ; } @Override public void clear ( ) { filteredDelegate . clear ( ) ; } @Override public Set < Entry < K , V > > entrySet ( ) { return filteredDelegate . entrySet ( ) ; } @Override public Entry < K , V > pollFirstEntry ( ) { return Iterables . removeFirstMatching ( unfiltered . entrySet ( ) , entryPredicate ) ; } @Override public Entry < K , V > pollLastEntry ( ) { return Iterables . removeFirstMatching ( unfiltered . descendingMap ( ) . entrySet ( ) , entryPredicate ) ; } @Override public NavigableMap < K , V > descendingMap ( ) { return filterEntries ( unfiltered . descendingMap ( ) , entryPredicate ) ; } @Override public NavigableMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { return filterEntries ( unfiltered . subMap ( fromKey , fromInclusive , toKey , toInclusive ) , entryPredicate ) ; } @Override public NavigableMap < K , V > headMap ( K toKey , boolean inclusive ) { return filterEntries ( unfiltered . headMap ( toKey , inclusive ) , entryPredicate ) ; } @Override public NavigableMap < K , V > tailMap ( K fromKey , boolean inclusive ) { return filterEntries ( unfiltered . tailMap ( fromKey , inclusive ) , entryPredicate ) ; } } private static < K , V > BiMap < K , V > filterFiltered ( FilteredEntryBiMap < K , V > map , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( map . predicate , entryPredicate ) ; return new FilteredEntryBiMap < K , V > ( map . unfiltered ( ) , predicate ) ; } static final class FilteredEntryBiMap < K , V > extends FilteredEntryMap < K , V > implements BiMap < K , V > { private final BiMap < V , K > inverse ; private static < K , V > Predicate < Entry < V , K > > inversePredicate ( final Predicate < ? super Entry < K , V > > forwardPredicate ) { return new Predicate < Entry < V , K > > ( ) { @Override public boolean apply ( Entry < V , K > input ) { return forwardPredicate . apply ( Maps . immutableEntry ( input . getValue ( ) , input . getKey ( ) ) ) ; } } ; } FilteredEntryBiMap ( BiMap < K , V > delegate , Predicate < ? super Entry < K , V > > predicate ) { super ( delegate , predicate ) ; this . inverse = new FilteredEntryBiMap < V , K > ( delegate . inverse ( ) , inversePredicate ( predicate ) , this ) ; } private FilteredEntryBiMap ( BiMap < K , V > delegate , Predicate < ? super Entry < K , V > > predicate , BiMap < V , K > inverse ) { super ( delegate , predicate ) ; this . inverse = inverse ; } BiMap < K , V > unfiltered ( ) { return ( BiMap < K , V > ) unfiltered ; } @Override public V forcePut ( @Nullable K key , @Nullable V value ) { checkArgument ( apply ( key , value ) ) ; return unfiltered ( ) . forcePut ( key , value ) ; } @Override public BiMap < V , K > inverse ( ) { return inverse ; } @Override public Set < V > values ( ) { return inverse . keySet ( ) ; } } @GwtIncompatible ( <str> ) public static < K , V > NavigableMap < K , V > unmodifiableNavigableMap ( NavigableMap < K , V > map ) { checkNotNull ( map ) ; if ( map instanceof UnmodifiableNavigableMap ) { return map ; } else { return new UnmodifiableNavigableMap < K , V > ( map ) ; } } @Nullable private static < K , V > Entry < K , V > unmodifiableOrNull ( @Nullable Entry < K , V > entry ) { return ( entry = = null ) ? null : Maps . unmodifiableEntry ( entry ) ; } @GwtIncompatible ( <str> ) static class UnmodifiableNavigableMap < K , V > extends ForwardingSortedMap < K , V > implements NavigableMap < K , V > , Serializable { private final NavigableMap < K , V > delegate ; UnmodifiableNavigableMap ( NavigableMap < K , V > delegate ) { this . delegate = delegate ; } UnmodifiableNavigableMap ( NavigableMap < K , V > delegate , UnmodifiableNavigableMap < K , V > descendingMap ) { this . delegate = delegate ; this . descendingMap = descendingMap ; } @Override protected SortedMap < K , V > delegate ( ) { return Collections . unmodifiableSortedMap ( delegate ) ; } @Override public Entry < K , V > lowerEntry ( K key ) { return unmodifiableOrNull ( delegate . lowerEntry ( key ) ) ; } @Override public K lowerKey ( K key ) { return delegate . lowerKey ( key ) ; } @Override public Entry < K , V > floorEntry ( K key ) { return unmodifiableOrNull ( delegate . floorEntry ( key ) ) ; } @Override public K floorKey ( K key ) { return delegate . floorKey ( key ) ; } @Override public Entry < K , V > ceilingEntry ( K key ) { return unmodifiableOrNull ( delegate . ceilingEntry ( key ) ) ; } @Override public K ceilingKey ( K key ) { return delegate . ceilingKey ( key ) ; } @Override public Entry < K , V > higherEntry ( K key ) { return unmodifiableOrNull ( delegate . higherEntry ( key ) ) ; } @Override public K higherKey ( K key ) { return delegate . higherKey ( key ) ; } @Override public Entry < K , V > firstEntry ( ) { return unmodifiableOrNull ( delegate . firstEntry ( ) ) ; } @Override public Entry < K , V > lastEntry ( ) { return unmodifiableOrNull ( delegate . lastEntry ( ) ) ; } @Override public final Entry < K , V > pollFirstEntry ( ) { throw new UnsupportedOperationException ( ) ; } @Override public final Entry < K , V > pollLastEntry ( ) { throw new UnsupportedOperationException ( ) ; } private transient UnmodifiableNavigableMap < K , V > descendingMap ; @Override public NavigableMap < K , V > descendingMap ( ) { UnmodifiableNavigableMap < K , V > result = descendingMap ; return ( result = = null ) ? descendingMap = new UnmodifiableNavigableMap < K , V > ( delegate . descendingMap ( ) , this ) : result ; } @Override public Set < K > keySet ( ) { return navigableKeySet ( ) ; } @Override public NavigableSet < K > navigableKeySet ( ) { return Sets . unmodifiableNavigableSet ( delegate . navigableKeySet ( ) ) ; } @Override public NavigableSet < K > descendingKeySet ( ) { return Sets . unmodifiableNavigableSet ( delegate . descendingKeySet ( ) ) ; } @Override public SortedMap < K , V > subMap ( K fromKey , K toKey ) { return subMap ( fromKey , true , toKey , false ) ; } @Override public SortedMap < K , V > headMap ( K toKey ) { return headMap ( toKey , false ) ; } @Override public SortedMap < K , V > tailMap ( K fromKey ) { return tailMap ( fromKey , true ) ; } @Override public NavigableMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { return Maps . unmodifiableNavigableMap ( delegate . subMap ( fromKey , fromInclusive , toKey , toInclusive ) ) ; } @Override public NavigableMap < K , V > headMap ( K toKey , boolean inclusive ) { return Maps . unmodifiableNavigableMap ( delegate . headMap ( toKey , inclusive ) ) ; } @Override public NavigableMap < K , V > tailMap ( K fromKey , boolean inclusive ) { return Maps . unmodifiableNavigableMap ( delegate . tailMap ( fromKey , inclusive ) ) ; } } @GwtIncompatible ( <str> ) public static < K , V > NavigableMap < K , V > synchronizedNavigableMap ( NavigableMap < K , V > navigableMap ) { return Synchronized . navigableMap ( navigableMap ) ; } @GwtCompatible abstract static class ViewCachingAbstractMap < K , V > extends AbstractMap < K , V > { abstract Set < Entry < K , V > > createEntrySet ( ) ; private transient Set < Entry < K , V > > entrySet ; @Override public Set < Entry < K , V > > entrySet ( ) { Set < Entry < K , V > > result = entrySet ; return ( result = = null ) ? entrySet = createEntrySet ( ) : result ; } private transient Set < K > keySet ; @Override public Set < K > keySet ( ) { Set < K > result = keySet ; return ( result = = null ) ? keySet = createKeySet ( ) : result ; } Set < K > createKeySet ( ) { return new KeySet < K , V > ( this ) ; } private transient Collection < V > values ; @Override public Collection < V > values ( ) { Collection < V > result = values ; return ( result = = null ) ? values = createValues ( ) : result ; } Collection < V > createValues ( ) { return new Values < K , V > ( this ) ; } } abstract static class IteratorBasedAbstractMap < K , V > extends AbstractMap < K , V > { @Override public abstract int size ( ) ; abstract Iterator < Entry < K , V > > entryIterator ( ) ; @Override public Set < Entry < K , V > > entrySet ( ) { return new EntrySet < K , V > ( ) { @Override Map < K , V > map ( ) { return IteratorBasedAbstractMap . this ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } } ; } @Override public void clear ( ) { Iterators . clear ( entryIterator ( ) ) ; } } static < V > V safeGet ( Map < ? , V > map , @Nullable Object key ) { checkNotNull ( map ) ; try { return map . get ( key ) ; } catch ( ClassCastException e ) { return null ; } catch ( NullPointerException e ) { return null ; } } static boolean safeContainsKey ( Map < ? , ? > map , Object key ) { checkNotNull ( map ) ; try { return map . containsKey ( key ) ; } catch ( ClassCastException e ) { return false ; } catch ( NullPointerException e ) { return false ; } } static < V > V safeRemove ( Map < ? , V > map , Object key ) { checkNotNull ( map ) ; try { return map . remove ( key ) ; } catch ( ClassCastException e ) { return null ; } catch ( NullPointerException e ) { return null ; } } static boolean containsKeyImpl ( Map < ? , ? > map , @Nullable Object key ) { return Iterators . contains ( keyIterator ( map . entrySet ( ) . iterator ( ) ) , key ) ; } static boolean containsValueImpl ( Map < ? , ? > map , @Nullable Object value ) { return Iterators . contains ( valueIterator ( map . entrySet ( ) . iterator ( ) ) , value ) ; } static < K , V > boolean containsEntryImpl ( Collection < Entry < K , V > > c , Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } return c . contains ( unmodifiableEntry ( ( Entry < ? , ? > ) o ) ) ; } static < K , V > boolean removeEntryImpl ( Collection < Entry < K , V > > c , Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } return c . remove ( unmodifiableEntry ( ( Entry < ? , ? > ) o ) ) ; } static boolean equalsImpl ( Map < ? , ? > map , Object object ) { if ( map = = object ) { return true ; } else if ( object instanceof Map ) { Map < ? , ? > o = ( Map < ? , ? > ) object ; return map . entrySet ( ) . equals ( o . entrySet ( ) ) ; } return false ; } static final MapJoiner STANDARD_JOINER = Collections2 . STANDARD_JOINER . withKeyValueSeparator ( <str> ) ; static String toStringImpl ( Map < ? , ? > map ) { StringBuilder sb = Collections2 . newStringBuilderForCollection ( map . size ( ) ) . append ( <str> ) ; STANDARD_JOINER . appendTo ( sb , map ) ; return sb . append ( <str> ) . toString ( ) ; } static < K , V > void putAllImpl ( Map < K , V > self , Map < ? extends K , ? extends V > map ) { for ( Map . Entry < ? extends K , ? extends V > entry : map . entrySet ( ) ) { self . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } static class KeySet < K , V > extends Sets . ImprovedAbstractSet < K > { @Weak final Map < K , V > map ; KeySet ( Map < K , V > map ) { this . map = checkNotNull ( map ) ; } Map < K , V > map ( ) { return map ; } @Override public Iterator < K > iterator ( ) { return keyIterator ( map ( ) . entrySet ( ) . iterator ( ) ) ; } @Override public int size ( ) { return map ( ) . size ( ) ; } @Override public boolean isEmpty ( ) { return map ( ) . isEmpty ( ) ; } @Override public boolean contains ( Object o ) { return map ( ) . containsKey ( o ) ; } @Override public boolean remove ( Object o ) { if ( contains ( o ) ) { map ( ) . remove ( o ) ; return true ; } return false ; } @Override public void clear ( ) { map ( ) . clear ( ) ; } } @Nullable static < K > K keyOrNull ( @Nullable Entry < K , ? > entry ) { return ( entry = = null ) ? null : entry . getKey ( ) ; } @Nullable static < V > V valueOrNull ( @Nullable Entry < ? , V > entry ) { return ( entry = = null ) ? null : entry . getValue ( ) ; } static class SortedKeySet < K , V > extends KeySet < K , V > implements SortedSet < K > { SortedKeySet ( SortedMap < K , V > map ) { super ( map ) ; } @Override SortedMap < K , V > map ( ) { return ( SortedMap < K , V > ) super . map ( ) ; } @Override public Comparator < ? super K > comparator ( ) { return map ( ) . comparator ( ) ; } @Override public SortedSet < K > subSet ( K fromElement , K toElement ) { return new SortedKeySet < K , V > ( map ( ) . subMap ( fromElement , toElement ) ) ; } @Override public SortedSet < K > headSet ( K toElement ) { return new SortedKeySet < K , V > ( map ( ) . headMap ( toElement ) ) ; } @Override public SortedSet < K > tailSet ( K fromElement ) { return new SortedKeySet < K , V > ( map ( ) . tailMap ( fromElement ) ) ; } @Override public K first ( ) { return map ( ) . firstKey ( ) ; } @Override public K last ( ) { return map ( ) . lastKey ( ) ; } } @GwtIncompatible ( <str> ) static class NavigableKeySet < K , V > extends SortedKeySet < K , V > implements NavigableSet < K > { NavigableKeySet ( NavigableMap < K , V > map ) { super ( map ) ; } @Override NavigableMap < K , V > map ( ) { return ( NavigableMap < K , V > ) map ; } @Override public K lower ( K e ) { return map ( ) . lowerKey ( e ) ; } @Override public K floor ( K e ) { return map ( ) . floorKey ( e ) ; } @Override public K ceiling ( K e ) { return map ( ) . ceilingKey ( e ) ; } @Override public K higher ( K e ) { return map ( ) . higherKey ( e ) ; } @Override public K pollFirst ( ) { return keyOrNull ( map ( ) . pollFirstEntry ( ) ) ; } @Override public K pollLast ( ) { return keyOrNull ( map ( ) . pollLastEntry ( ) ) ; } @Override public NavigableSet < K > descendingSet ( ) { return map ( ) . descendingKeySet ( ) ; } @Override public Iterator < K > descendingIterator ( ) { return descendingSet ( ) . iterator ( ) ; } @Override public NavigableSet < K > subSet ( K fromElement , boolean fromInclusive , K toElement , boolean toInclusive ) { return map ( ) . subMap ( fromElement , fromInclusive , toElement , toInclusive ) . navigableKeySet ( ) ; } @Override public NavigableSet < K > headSet ( K toElement , boolean inclusive ) { return map ( ) . headMap ( toElement , inclusive ) . navigableKeySet ( ) ; } @Override public NavigableSet < K > tailSet ( K fromElement , boolean inclusive ) { return map ( ) . tailMap ( fromElement , inclusive ) . navigableKeySet ( ) ; } @Override public SortedSet < K > subSet ( K fromElement , K toElement ) { return subSet ( fromElement , true , toElement , false ) ; } @Override public SortedSet < K > headSet ( K toElement ) { return headSet ( toElement , false ) ; } @Override public SortedSet < K > tailSet ( K fromElement ) { return tailSet ( fromElement , true ) ; } } static class Values < K , V > extends AbstractCollection < V > { @Weak final Map < K , V > map ; Values ( Map < K , V > map ) { this . map = checkNotNull ( map ) ; } final Map < K , V > map ( ) { return map ; } @Override public Iterator < V > iterator ( ) { return valueIterator ( map ( ) . entrySet ( ) . iterator ( ) ) ; } @Override public boolean remove ( Object o ) { try { return super . remove ( o ) ; } catch ( UnsupportedOperationException e ) { for ( Entry < K , V > entry : map ( ) . entrySet ( ) ) { if ( Objects . equal ( o , entry . getValue ( ) ) ) { map ( ) . remove ( entry . getKey ( ) ) ; return true ; } } return false ; } } @Override public boolean removeAll ( Collection < ? > c ) { try { return super . removeAll ( checkNotNull ( c ) ) ; } catch ( UnsupportedOperationException e ) { Set < K > toRemove = Sets . newHashSet ( ) ; for ( Entry < K , V > entry : map ( ) . entrySet ( ) ) { if ( c . contains ( entry . getValue ( ) ) ) { toRemove . add ( entry . getKey ( ) ) ; } } return map ( ) . keySet ( ) . removeAll ( toRemove ) ; } } @Override public boolean retainAll ( Collection < ? > c ) { try { return super . retainAll ( checkNotNull ( c ) ) ; } catch ( UnsupportedOperationException e ) { Set < K > toRetain = Sets . newHashSet ( ) ; for ( Entry < K , V > entry : map ( ) . entrySet ( ) ) { if ( c . contains ( entry . getValue ( ) ) ) { toRetain . add ( entry . getKey ( ) ) ; } } return map ( ) . keySet ( ) . retainAll ( toRetain ) ; } } @Override public int size ( ) { return map ( ) . size ( ) ; } @Override public boolean isEmpty ( ) { return map ( ) . isEmpty ( ) ; } @Override public boolean contains ( @Nullable Object o ) { return map ( ) . containsValue ( o ) ; } @Override public void clear ( ) { map ( ) . clear ( ) ; } } abstract static class EntrySet < K , V > extends Sets . ImprovedAbstractSet < Entry < K , V > > { abstract Map < K , V > map ( ) ; @Override public int size ( ) { return map ( ) . size ( ) ; } @Override public void clear ( ) { map ( ) . clear ( ) ; } @Override public boolean contains ( Object o ) { if ( o instanceof Entry ) { Entry < ? , ? > entry = ( Entry < ? , ? > ) o ; Object key = entry . getKey ( ) ; V value = Maps . safeGet ( map ( ) , key ) ; return Objects . equal ( value , entry . getValue ( ) ) & & ( value ! = null | | map ( ) . containsKey ( key ) ) ; } return false ; } @Override public boolean isEmpty ( ) { return map ( ) . isEmpty ( ) ; } @Override public boolean remove ( Object o ) { if ( contains ( o ) ) { Entry < ? , ? > entry = ( Entry < ? , ? > ) o ; return map ( ) . keySet ( ) . remove ( entry . getKey ( ) ) ; } return false ; } @Override public boolean removeAll ( Collection < ? > c ) { try { return super . removeAll ( checkNotNull ( c ) ) ; } catch ( UnsupportedOperationException e ) { return Sets . removeAllImpl ( this , c . iterator ( ) ) ; } } @Override public boolean retainAll ( Collection < ? > c ) { try { return super . retainAll ( checkNotNull ( c ) ) ; } catch ( UnsupportedOperationException e ) { Set < Object > keys = Sets . newHashSetWithExpectedSize ( c . size ( ) ) ; for ( Object o : c ) { if ( contains ( o ) ) { Entry < ? , ? > entry = ( Entry < ? , ? > ) o ; keys . add ( entry . getKey ( ) ) ; } } return map ( ) . keySet ( ) . retainAll ( keys ) ; } } } @GwtIncompatible ( <str> ) abstract static class DescendingMap < K , V > extends ForwardingMap < K , V > implements NavigableMap < K , V > { abstract NavigableMap < K , V > forward ( ) ; @Override protected final Map < K , V > delegate ( ) { return forward ( ) ; } private transient Comparator < ? super K > comparator ; @SuppressWarnings ( <str> ) @Override public Comparator < ? super K > comparator ( ) { Comparator < ? super K > result = comparator ; if ( result = = null ) { Comparator < ? super K > forwardCmp = forward ( ) . comparator ( ) ; if ( forwardCmp = = null ) { forwardCmp = ( Comparator ) Ordering . natural ( ) ; } result = comparator = reverse ( forwardCmp ) ; } return result ; } private static < T > Ordering < T > reverse ( Comparator < T > forward ) { return Ordering . from ( forward ) . reverse ( ) ; } @Override public K firstKey ( ) { return forward ( ) . lastKey ( ) ; } @Override public K lastKey ( ) { return forward ( ) . firstKey ( ) ; } @Override public Entry < K , V > lowerEntry ( K key ) { return forward ( ) . higherEntry ( key ) ; } @Override public K lowerKey ( K key ) { return forward ( ) . higherKey ( key ) ; } @Override public Entry < K , V > floorEntry ( K key ) { return forward ( ) . ceilingEntry ( key ) ; } @Override public K floorKey ( K key ) { return forward ( ) . ceilingKey ( key ) ; } @Override public Entry < K , V > ceilingEntry ( K key ) { return forward ( ) . floorEntry ( key ) ; } @Override public K ceilingKey ( K key ) { return forward ( ) . floorKey ( key ) ; } @Override public Entry < K , V > higherEntry ( K key ) { return forward ( ) . lowerEntry ( key ) ; } @Override public K higherKey ( K key ) { return forward ( ) . lowerKey ( key ) ; } @Override public Entry < K , V > firstEntry ( ) { return forward ( ) . lastEntry ( ) ; } @Override public Entry < K , V > lastEntry ( ) { return forward ( ) . firstEntry ( ) ; } @Override public Entry < K , V > pollFirstEntry ( ) { return forward ( ) . pollLastEntry ( ) ; } @Override public Entry < K , V > pollLastEntry ( ) { return forward ( ) . pollFirstEntry ( ) ; } @Override public NavigableMap < K , V > descendingMap ( ) { return forward ( ) ; } private transient Set < Entry < K , V > > entrySet ; @Override public Set < Entry < K , V > > entrySet ( ) { Set < Entry < K , V > > result = entrySet ; return ( result = = null ) ? entrySet = createEntrySet ( ) : result ; } abstract Iterator < Entry < K , V > > entryIterator ( ) ; Set < Entry < K , V > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends EntrySet < K , V > { @Override Map < K , V > map ( ) { return DescendingMap . this ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } } return new EntrySetImpl ( ) ; } @Override public Set < K > keySet ( ) { return navigableKeySet ( ) ; } private transient NavigableSet < K > navigableKeySet ; @Override public NavigableSet < K > navigableKeySet ( ) { NavigableSet < K > result = navigableKeySet ; return ( result = = null ) ? navigableKeySet = new NavigableKeySet < K , V > ( this ) : result ; } @Override public NavigableSet < K > descendingKeySet ( ) { return forward ( ) . navigableKeySet ( ) ; } @Override public NavigableMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { return forward ( ) . subMap ( toKey , toInclusive , fromKey , fromInclusive ) . descendingMap ( ) ; } @Override public NavigableMap < K , V > headMap ( K toKey , boolean inclusive ) { return forward ( ) . tailMap ( toKey , inclusive ) . descendingMap ( ) ; } @Override public NavigableMap < K , V > tailMap ( K fromKey , boolean inclusive ) { return forward ( ) . headMap ( fromKey , inclusive ) . descendingMap ( ) ; } @Override public SortedMap < K , V > subMap ( K fromKey , K toKey ) { return subMap ( fromKey , true , toKey , false ) ; } @Override public SortedMap < K , V > headMap ( K toKey ) { return headMap ( toKey , false ) ; } @Override public SortedMap < K , V > tailMap ( K fromKey ) { return tailMap ( fromKey , true ) ; } @Override public Collection < V > values ( ) { return new Values < K , V > ( this ) ; } @Override public String toString ( ) { return standardToString ( ) ; } } static < E > ImmutableMap < E , Integer > indexMap ( Collection < E > list ) { ImmutableMap . Builder < E , Integer > builder = new ImmutableMap . Builder < E , Integer > ( list . size ( ) ) ; int i = <int> ; for ( E e : list ) { builder . put ( e , i + + ) ; } return builder . build ( ) ; } @Beta @GwtIncompatible ( <str> ) public static < K extends Comparable < ? super K > , V > NavigableMap < K , V > subMap ( NavigableMap < K , V > map , Range < K > range ) { if ( map . comparator ( ) ! = null & & map . comparator ( ) ! = Ordering . natural ( ) & & range . hasLowerBound ( ) & & range . hasUpperBound ( ) ) { checkArgument ( map . comparator ( ) . compare ( range . lowerEndpoint ( ) , range . upperEndpoint ( ) ) < = <int> , <str> ) ; } if ( range . hasLowerBound ( ) & & range . hasUpperBound ( ) ) { return map . subMap ( range . lowerEndpoint ( ) , range . lowerBoundType ( ) = = BoundType . CLOSED , range . upperEndpoint ( ) , range . upperBoundType ( ) = = BoundType . CLOSED ) ; } else if ( range . hasLowerBound ( ) ) { return map . tailMap ( range . lowerEndpoint ( ) , range . lowerBoundType ( ) = = BoundType . CLOSED ) ; } else if ( range . hasUpperBound ( ) ) { return map . headMap ( range . upperEndpoint ( ) , range . upperBoundType ( ) = = BoundType . CLOSED ) ; } return checkNotNull ( map ) ; } } 
