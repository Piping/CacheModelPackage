package io . netty . handler . codec . dns ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . socket . DatagramPacket ; import io . netty . handler . codec . CorruptedFrameException ; import io . netty . handler . codec . MessageToMessageDecoder ; import java . net . InetSocketAddress ; import java . util . List ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; @ChannelHandler.Sharable public class DatagramDnsResponseDecoder extends MessageToMessageDecoder < DatagramPacket > { private final DnsRecordDecoder recordDecoder ; public DatagramDnsResponseDecoder ( ) { this ( DnsRecordDecoder . DEFAULT ) ; } public DatagramDnsResponseDecoder ( DnsRecordDecoder recordDecoder ) { this . recordDecoder = checkNotNull ( recordDecoder , <str> ) ; } @Override protected void decode ( ChannelHandlerContext ctx , DatagramPacket packet , List < Object > out ) throws Exception { final InetSocketAddress sender = packet . sender ( ) ; final ByteBuf buf = packet . content ( ) ; final DnsResponse response = newResponse ( sender , buf ) ; boolean success = false ; try { final int questionCount = buf . readUnsignedShort ( ) ; final int answerCount = buf . readUnsignedShort ( ) ; final int authorityRecordCount = buf . readUnsignedShort ( ) ; final int additionalRecordCount = buf . readUnsignedShort ( ) ; decodeQuestions ( response , buf , questionCount ) ; decodeRecords ( response , DnsSection . ANSWER , buf , answerCount ) ; decodeRecords ( response , DnsSection . AUTHORITY , buf , authorityRecordCount ) ; decodeRecords ( response , DnsSection . ADDITIONAL , buf , additionalRecordCount ) ; out . add ( response ) ; success = true ; } finally { if ( ! success ) { response . release ( ) ; } } } private static DnsResponse newResponse ( InetSocketAddress sender , ByteBuf buf ) { final int id = buf . readUnsignedShort ( ) ; final int flags = buf . readUnsignedShort ( ) ; if ( flags > > <int> = = <int> ) { throw new CorruptedFrameException ( <str> ) ; } final DnsResponse response = new DatagramDnsResponse ( sender , null , id , DnsOpCode . valueOf ( ( byte ) ( flags > > <int> & <hex> ) ) , DnsResponseCode . valueOf ( ( byte ) ( flags & <hex> ) ) ) ; response . setRecursionDesired ( ( flags > > <int> & <int> ) = = <int> ) ; response . setAuthoritativeAnswer ( ( flags > > <int> & <int> ) = = <int> ) ; response . setTruncated ( ( flags > > <int> & <int> ) = = <int> ) ; response . setRecursionAvailable ( ( flags > > <int> & <int> ) = = <int> ) ; response . setZ ( flags > > <int> & <hex> ) ; return response ; } private void decodeQuestions ( DnsResponse response , ByteBuf buf , int questionCount ) throws Exception { for ( int i = questionCount ; i > <int> ; i - - ) { response . addRecord ( DnsSection . QUESTION , recordDecoder . decodeQuestion ( buf ) ) ; } } private void decodeRecords ( DnsResponse response , DnsSection section , ByteBuf buf , int count ) throws Exception { for ( int i = count ; i > <int> ; i - - ) { final DnsRecord r = recordDecoder . decodeRecord ( buf ) ; if ( r = = null ) { break ; } response . addRecord ( section , r ) ; } } }