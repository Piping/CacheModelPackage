package org . apache . cassandra . index . internal . composites ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . IndexEntry ; import org . apache . cassandra . schema . IndexMetadata ; public class RegularColumnIndex extends CassandraIndex { public RegularColumnIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexDef ) { super ( baseCfs , indexDef ) ; } public ByteBuffer getIndexedValue ( ByteBuffer partitionKey , Clustering clustering , CellPath path , ByteBuffer cellValue ) { return cellValue ; } public CBuilder buildIndexClusteringPrefix ( ByteBuffer partitionKey , ClusteringPrefix prefix , CellPath path ) { CBuilder builder = CBuilder . create ( getIndexComparator ( ) ) ; builder . add ( partitionKey ) ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) builder . add ( prefix . get ( i ) ) ; return builder ; } public IndexEntry decodeEntry ( DecoratedKey indexedValue , Row indexEntry ) { Clustering clustering = indexEntry . clustering ( ) ; ClusteringComparator baseComparator = baseCfs . getComparator ( ) ; CBuilder builder = CBuilder . create ( baseComparator ) ; for ( int i = <int> ; i < baseComparator . size ( ) ; i + + ) builder . add ( clustering . get ( i + <int> ) ) ; return new IndexEntry ( indexedValue , clustering , indexEntry . primaryKeyLivenessInfo ( ) . timestamp ( ) , clustering . get ( <int> ) , builder . build ( ) ) ; } public boolean isStale ( Row data , ByteBuffer indexValue , int nowInSec ) { Cell cell = data . getCell ( indexedColumn ) ; return cell = = null | | ! cell . isLive ( nowInSec ) | | indexedColumn . type . compare ( indexValue , cell . value ( ) ) ! = <int> ; } }