package org . elasticsearch . mapper . attachments ; import org . apache . tika . io . IOUtils ; import org . apache . tika . metadata . Metadata ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . MapperTestUtils ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . ParseContext ; import org . junit . Before ; import java . io . IOException ; import java . io . InputStream ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . mapper . attachments . AttachmentMapper . FieldNames . * ; import static org . elasticsearch . test . StreamsUtils . copyToBytesFromClasspath ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . Matchers . isEmptyOrNullString ; import static org . hamcrest . Matchers . not ; public class VariousDocTests extends AttachmentUnitTestCase { protected DocumentMapper docMapper ; @Before public void createMapper ( ) throws IOException { DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . EMPTY , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; docMapper = mapperParser . parse ( mapping ) ; } public void testWordDocxDocument104 ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } public void testEncryptedPDFDocument ( ) throws Exception { assertException ( <str> , <str> ) ; testMapper ( <str> , true ) ; } public void testHtmlDocument ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } public void testXHtmlDocument ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } public void testTxtDocument ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } public void testEpubDocument ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } public void testAsciidocDocument ( ) throws Exception { assertParseable ( <str> ) ; testMapper ( <str> , false ) ; } void assertException ( String filename , String expectedMessage ) throws Exception { try ( InputStream is = VariousDocTests . class . getResourceAsStream ( <str> + filename ) ) { byte bytes [ ] = IOUtils . toByteArray ( is ) ; TikaImpl . parse ( bytes , new Metadata ( ) , - <int> ) ; fail ( <str> ) ; } catch ( Exception e ) { if ( e . getMessage ( ) ! = null & & e . getMessage ( ) . contains ( expectedMessage ) ) { } else { throw e ; } } } protected void assertParseable ( String filename ) throws Exception { try ( InputStream is = VariousDocTests . class . getResourceAsStream ( <str> + filename ) ) { byte bytes [ ] = IOUtils . toByteArray ( is ) ; String parsedContent = TikaImpl . parse ( bytes , new Metadata ( ) , - <int> ) ; assertThat ( parsedContent , not ( isEmptyOrNullString ( ) ) ) ; logger . debug ( <str> , parsedContent ) ; } } protected void testMapper ( String filename , boolean errorExpected ) throws IOException { byte [ ] html = copyToBytesFromClasspath ( <str> + filename ) ; BytesReference json = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , filename ) . field ( <str> , html ) . endObject ( ) . endObject ( ) . bytes ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , json ) . rootDoc ( ) ; if ( ! errorExpected ) { assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , not ( isEmptyOrNullString ( ) ) ) ; logger . debug ( <str> , doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) ) ; logger . debug ( <str> ) ; printMetadataContent ( doc , AUTHOR ) ; printMetadataContent ( doc , CONTENT_LENGTH ) ; printMetadataContent ( doc , CONTENT_TYPE ) ; printMetadataContent ( doc , DATE ) ; printMetadataContent ( doc , KEYWORDS ) ; printMetadataContent ( doc , LANGUAGE ) ; printMetadataContent ( doc , NAME ) ; printMetadataContent ( doc , TITLE ) ; } } private void printMetadataContent ( ParseContext . Document doc , String field ) { logger . debug ( <str> , field , doc . get ( docMapper . mappers ( ) . getMapper ( <str> + field ) . fieldType ( ) . names ( ) . indexName ( ) ) ) ; } } 
