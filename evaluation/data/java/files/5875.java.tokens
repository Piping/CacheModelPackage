package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . Test ; import rx . Observable ; import rx . Observable . OnSubscribe ; import rx . Observer ; import rx . Subscriber ; import rx . internal . util . RxRingBuffer ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; public class OperatorOnBackpressureDropTest { @Test public void testNoBackpressureSupport ( ) { TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) ; ts . requestMore ( <int> ) ; infinite . take ( <int> ) . subscribe ( ts ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; } @Test ( timeout = <int> ) public void testWithObserveOn ( ) throws InterruptedException { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . range ( <int> , RxRingBuffer . SIZE * <int> ) . onBackpressureDrop ( ) . observeOn ( Schedulers . io ( ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; } @Test ( timeout = <int> ) public void testFixBackpressureWithBuffer ( ) throws InterruptedException { final CountDownLatch l1 = new CountDownLatch ( <int> ) ; final CountDownLatch l2 = new CountDownLatch ( <int> ) ; TestSubscriber < Long > ts = new TestSubscriber < Long > ( new Observer < Long > ( ) { @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Long t ) { l1 . countDown ( ) ; l2 . countDown ( ) ; } } ) ; ts . requestMore ( <int> ) ; infinite . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureDrop ( ) . take ( <int> ) . subscribe ( ts ) ; l1 . await ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; ts . requestMore ( <int> ) ; l2 . await ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; ts . requestMore ( <int> ) ; ts . awaitTerminalEvent ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . get ( <int> ) . intValue ( ) ) ; } @Test public void testRequestOverflow ( ) throws InterruptedException { final AtomicInteger count = new AtomicInteger ( ) ; int n = <int> ; range ( n ) . onBackpressureDrop ( ) . subscribe ( new Subscriber < Long > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { throw new RuntimeException ( e ) ; } @Override public void onNext ( Long t ) { count . incrementAndGet ( ) ; request ( Long . MAX_VALUE - <int> ) ; } } ) ; assertEquals ( n , count . get ( ) ) ; } static final Observable < Long > infinite = Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > s ) { long i = <int> ; while ( ! s . isUnsubscribed ( ) ) { s . onNext ( i + + ) ; } } } ) ; private static final Observable < Long > range ( final long n ) { return Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > s ) { for ( long i = <int> ; i < n ; i + + ) { if ( s . isUnsubscribed ( ) ) { break ; } s . onNext ( i ) ; } s . onCompleted ( ) ; } } ) ; } }