package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterInfoService ; import org . elasticsearch . cluster . DiskUsage ; import org . elasticsearch . cluster . InternalClusterInfoService ; import org . elasticsearch . cluster . MockInternalClusterInfoService ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) public class MockDiskUsagesIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( InternalClusterInfoService . INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , <str> ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockInternalClusterInfoService . TestPlugin . class ) ; } public void testRerouteOccursOnDiskPassingHighWatermark ( ) throws Exception { List < String > nodes = internalCluster ( ) . startNodesAsync ( <int> ) . get ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { NodesStatsResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . get ( ) ; assertThat ( resp . getNodes ( ) . length , equalTo ( <int> ) ) ; } } ) ; final MockInternalClusterInfoService cis = ( MockInternalClusterInfoService ) internalCluster ( ) . getInstance ( ClusterInfoService . class , internalCluster ( ) . getMasterName ( ) ) ; cis . setN1Usage ( nodes . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN2Usage ( nodes . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN3Usage ( nodes . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , randomFrom ( <str> , <str> ) ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , randomFrom ( <str> , <str> ) ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL , <str> ) ) . get ( ) ; prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) ) . get ( ) ; ensureGreen ( <str> ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterInfo info = cis . getClusterInfo ( ) ; logger . info ( <str> , info . getNodeLeastAvailableDiskUsages ( ) . size ( ) ) ; assertThat ( info . getNodeLeastAvailableDiskUsages ( ) . size ( ) , greaterThan ( <int> ) ) ; } } ) ; final List < String > realNodeNames = new ArrayList < > ( ) ; ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; Iterator < RoutingNode > iter = resp . getState ( ) . getRoutingNodes ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { RoutingNode node = iter . next ( ) ; realNodeNames . add ( node . nodeId ( ) ) ; logger . info ( <str> , node . nodeId ( ) , resp . getState ( ) . getRoutingNodes ( ) . node ( node . nodeId ( ) ) . numberOfOwningShards ( ) ) ; } cis . setN1Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN2Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN3Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; final Map < String , Integer > nodesToShardCount = new HashMap < > ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; Iterator < RoutingNode > iter = resp . getState ( ) . getRoutingNodes ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { RoutingNode node = iter . next ( ) ; logger . info ( <str> , node . nodeId ( ) , resp . getState ( ) . getRoutingNodes ( ) . node ( node . nodeId ( ) ) . numberOfOwningShards ( ) ) ; nodesToShardCount . put ( node . nodeId ( ) , resp . getState ( ) . getRoutingNodes ( ) . node ( node . nodeId ( ) ) . numberOfOwningShards ( ) ) ; } assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , equalTo ( <int> ) ) ; assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , equalTo ( <int> ) ) ; assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , equalTo ( <int> ) ) ; } } ) ; cis . setN1Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN2Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; cis . setN3Usage ( realNodeNames . get ( <int> ) , new DiskUsage ( nodes . get ( <int> ) , <str> , <str> , <int> , <int> ) ) ; nodesToShardCount . clear ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; Iterator < RoutingNode > iter = resp . getState ( ) . getRoutingNodes ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { RoutingNode node = iter . next ( ) ; logger . info ( <str> , node . nodeId ( ) , resp . getState ( ) . getRoutingNodes ( ) . node ( node . nodeId ( ) ) . numberOfOwningShards ( ) ) ; nodesToShardCount . put ( node . nodeId ( ) , resp . getState ( ) . getRoutingNodes ( ) . node ( node . nodeId ( ) ) . numberOfOwningShards ( ) ) ; } assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( <str> , nodesToShardCount . get ( realNodeNames . get ( <int> ) ) , greaterThanOrEqualTo ( <int> ) ) ; } } ) ; } } 
