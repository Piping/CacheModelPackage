package org . eclipse . debug . internal . ui ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . source . Annotation ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . texteditor . IDocumentProvider ; import org . eclipse . ui . texteditor . ITextEditor ; public class InstructionPointerManager { private static InstructionPointerManager fgDefault ; private Set < InstructionPointerContext > fIPCSet = new HashSet < InstructionPointerContext > ( ) ; private Map < ITextEditor , Set < InstructionPointerContext > > fEditorMap = new HashMap < ITextEditor , Set < InstructionPointerContext > > ( ) ; private IPartListener2 fPartListener ; private IPageListener fPageListener ; private InstructionPointerManager ( ) { } public static InstructionPointerManager getDefault ( ) { if ( fgDefault = = null ) { fgDefault = new InstructionPointerManager ( ) ; } return fgDefault ; } public void addAnnotation ( ITextEditor textEditor , IStackFrame frame , Annotation annotation ) { IDocumentProvider docProvider = textEditor . getDocumentProvider ( ) ; IEditorInput editorInput = textEditor . getEditorInput ( ) ; IAnnotationModel annModel = docProvider . getAnnotationModel ( editorInput ) ; if ( annModel = = null ) { return ; } Position position = null ; int charStart = - <int> ; int length = - <int> ; try { charStart = frame . getCharStart ( ) ; length = frame . getCharEnd ( ) - charStart ; } catch ( DebugException de ) { } if ( charStart < <int> ) { IDocument doc = docProvider . getDocument ( editorInput ) ; if ( doc = = null ) { return ; } try { int lineNumber = frame . getLineNumber ( ) - <int> ; IRegion region = doc . getLineInformation ( lineNumber ) ; charStart = region . getOffset ( ) ; length = region . getLength ( ) ; } catch ( BadLocationException ble ) { return ; } catch ( DebugException de ) { return ; } } if ( charStart < <int> ) { return ; } position = new Position ( charStart , length ) ; if ( frame . isTerminated ( ) ) { return ; } synchronized ( fIPCSet ) { annModel . removeAnnotation ( annotation ) ; annModel . addAnnotation ( annotation , position ) ; InstructionPointerContext ipc = new InstructionPointerContext ( frame . getDebugTarget ( ) , frame . getThread ( ) , textEditor , annotation ) ; Set < InstructionPointerContext > editorIPCs = fEditorMap . get ( textEditor ) ; if ( editorIPCs = = null ) { editorIPCs = new HashSet < InstructionPointerContext > ( ) ; fEditorMap . put ( textEditor , editorIPCs ) ; } else { editorIPCs . remove ( ipc ) ; } editorIPCs . add ( ipc ) ; fIPCSet . remove ( ipc ) ; fIPCSet . add ( ipc ) ; textEditor . getSite ( ) . getPage ( ) . addPartListener ( getPartListener ( ) ) ; textEditor . getSite ( ) . getPage ( ) . getWorkbenchWindow ( ) . addPageListener ( getPageListener ( ) ) ; } } public void removeAnnotations ( IDebugTarget debugTarget ) { synchronized ( fIPCSet ) { Iterator < InstructionPointerContext > ipcIter = fIPCSet . iterator ( ) ; while ( ipcIter . hasNext ( ) ) { InstructionPointerContext currentIPC = ipcIter . next ( ) ; if ( currentIPC . getDebugTarget ( ) . equals ( debugTarget ) ) { removeAnnotationFromModel ( currentIPC ) ; ipcIter . remove ( ) ; removeAnnotationFromEditorMapping ( currentIPC ) ; } } } } public void removeAnnotations ( IThread thread ) { synchronized ( fIPCSet ) { Iterator < InstructionPointerContext > ipcIter = fIPCSet . iterator ( ) ; while ( ipcIter . hasNext ( ) ) { InstructionPointerContext currentIPC = ipcIter . next ( ) ; if ( currentIPC . getThread ( ) . equals ( thread ) ) { removeAnnotationFromModel ( currentIPC ) ; ipcIter . remove ( ) ; removeAnnotationFromEditorMapping ( currentIPC ) ; } } } } public void removeAnnotations ( ITextEditor editor ) { synchronized ( fIPCSet ) { Set < InstructionPointerContext > editorIPCs = fEditorMap . get ( editor ) ; if ( editorIPCs ! = null ) { Iterator < InstructionPointerContext > ipcIter = editorIPCs . iterator ( ) ; while ( ipcIter . hasNext ( ) ) { InstructionPointerContext currentIPC = ipcIter . next ( ) ; removeAnnotationFromModel ( currentIPC ) ; fIPCSet . remove ( currentIPC ) ; } fEditorMap . remove ( editor ) ; } } } private void removeAnnotationFromEditorMapping ( InstructionPointerContext ipc ) { Set < InstructionPointerContext > editorIPCs = fEditorMap . get ( ipc . getEditor ( ) ) ; if ( editorIPCs ! = null ) { editorIPCs . remove ( ipc ) ; if ( editorIPCs . isEmpty ( ) ) { fEditorMap . remove ( ipc . getEditor ( ) ) ; } } } private void removeAnnotationFromModel ( InstructionPointerContext ipc ) { IDocumentProvider docProvider = ipc . getEditor ( ) . getDocumentProvider ( ) ; if ( docProvider ! = null ) { IAnnotationModel annotationModel = docProvider . getAnnotationModel ( ipc . getEditor ( ) . getEditorInput ( ) ) ; if ( annotationModel ! = null ) { annotationModel . removeAnnotation ( ipc . getAnnotation ( ) ) ; } } } public int getInstructionPointerCount ( ) { return fIPCSet . size ( ) ; } public int getEditorMappingCount ( ) { return fEditorMap . size ( ) ; } private IPageListener getPageListener ( ) { if ( fPageListener = = null ) { fPageListener = new PageListener ( ) ; } return fPageListener ; } private IPartListener2 getPartListener ( ) { if ( fPartListener = = null ) { fPartListener = new PartListener ( ) ; } return fPartListener ; } class PartListener implements IPartListener2 { @Override public void partActivated ( IWorkbenchPartReference partRef ) { } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { } @Override public void partHidden ( IWorkbenchPartReference partRef ) { } @Override public void partOpened ( IWorkbenchPartReference partRef ) { } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { IWorkbenchPart part = partRef . getPart ( false ) ; if ( part instanceof ITextEditor ) { removeAnnotations ( ( ITextEditor ) part ) ; } } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { IWorkbenchPart part = partRef . getPart ( false ) ; if ( part instanceof ITextEditor ) { removeAnnotations ( ( ITextEditor ) part ) ; } } } class PageListener implements IPageListener { @Override public void pageActivated ( IWorkbenchPage page ) { } @Override public void pageOpened ( IWorkbenchPage page ) { } @Override public void pageClosed ( IWorkbenchPage page ) { page . removePartListener ( getPartListener ( ) ) ; page . getWorkbenchWindow ( ) . removePageListener ( getPageListener ( ) ) ; } } }