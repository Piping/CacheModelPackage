package com . google . common . collect ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . base . Preconditions ; import java . util . Random ; public class MultisetIteratorBenchmark { @Param ( { <str> , <str> , <str> , <str> , <str> , <str> } ) int size ; LinkedHashMultiset < Object > linkedHashMultiset ; HashMultiset < Object > hashMultiset ; TreeMultiset < Integer > treeMultiset ; @BeforeExperiment void setUp ( ) { hashMultiset = HashMultiset . create ( size ) ; linkedHashMultiset = LinkedHashMultiset . create ( size ) ; treeMultiset = TreeMultiset . create ( ) ; Random random = new Random ( ) ; int sizeRemaining = size ; for ( int i = <int> ; sizeRemaining > <int> ; i + + ) { Integer value = random . nextInt ( <int> ) + <int> ; int count = Math . min ( random . nextInt ( <int> ) + <int> , sizeRemaining ) ; sizeRemaining - = count ; hashMultiset . add ( value , count ) ; linkedHashMultiset . add ( value , count ) ; treeMultiset . add ( value , count ) ; } Preconditions . checkState ( hashMultiset . size ( ) = = size ) ; } @Benchmark int hashMultiset ( int reps ) { int sum = <int> ; for ( int i = <int> ; i < reps ; i + + ) { for ( Object value : hashMultiset ) { sum + = value . hashCode ( ) ; } } return sum ; } @Benchmark int linkedHashMultiset ( int reps ) { int sum = <int> ; for ( int i = <int> ; i < reps ; i + + ) { for ( Object value : linkedHashMultiset ) { sum + = value . hashCode ( ) ; } } return sum ; } @Benchmark int treeMultiset ( int reps ) { int sum = <int> ; for ( int i = <int> ; i < reps ; i + + ) { for ( Object value : treeMultiset ) { sum + = value . hashCode ( ) ; } } return sum ; } }