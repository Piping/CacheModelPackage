package org . apache . cassandra . utils . obs ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . util . Memory ; import org . apache . cassandra . utils . concurrent . Ref ; public class OffHeapBitSet implements IBitSet { private final Memory bytes ; public OffHeapBitSet ( long numBits ) { long wordCount = OpenBitSet . bits2words ( numBits ) ; if ( wordCount > Integer . MAX_VALUE ) throw new UnsupportedOperationException ( <str> ) ; try { long byteCount = wordCount * <int> ; bytes = Memory . allocate ( byteCount ) ; } catch ( OutOfMemoryError e ) { throw new RuntimeException ( <str> ) ; } clear ( ) ; } private OffHeapBitSet ( Memory bytes ) { this . bytes = bytes ; } public long capacity ( ) { return bytes . size ( ) * <int> ; } @Override public long offHeapSize ( ) { return bytes . size ( ) ; } public void addTo ( Ref . IdentityCollection identities ) { identities . add ( bytes ) ; } public boolean get ( long index ) { long i = index > > <int> ; long bit = index & <hex> ; int bitmask = <hex> < < bit ; return ( bytes . getByte ( i ) & bitmask ) ! = <int> ; } public void set ( long index ) { long i = index > > <int> ; long bit = index & <hex> ; int bitmask = <hex> < < bit ; bytes . setByte ( i , ( byte ) ( bitmask | bytes . getByte ( i ) ) ) ; } public void set ( long offset , byte b ) { bytes . setByte ( offset , b ) ; } public void clear ( long index ) { long i = index > > <int> ; long bit = index & <hex> ; int bitmask = <hex> < < bit ; int nativeByte = ( bytes . getByte ( i ) & <hex> ) ; nativeByte & = ~ bitmask ; bytes . setByte ( i , ( byte ) nativeByte ) ; } public void clear ( ) { bytes . setMemory ( <int> , bytes . size ( ) , ( byte ) <int> ) ; } public void serialize ( DataOutput out ) throws IOException { out . writeInt ( ( int ) ( bytes . size ( ) / <int> ) ) ; for ( long i = <int> ; i < bytes . size ( ) ; ) { long value = ( ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( long ) ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( long ) ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( long ) ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( long ) ( bytes . getByte ( i + + ) & <hex> ) < < <int> ) + ( ( long ) bytes . getByte ( i + + ) < < <int> ) ; out . writeLong ( value ) ; } } public long serializedSize ( ) { return TypeSizes . sizeof ( ( int ) bytes . size ( ) ) + bytes . size ( ) ; } @SuppressWarnings ( <str> ) public static OffHeapBitSet deserialize ( DataInput in ) throws IOException { long byteCount = in . readInt ( ) * <int> ; Memory memory = Memory . allocate ( byteCount ) ; for ( long i = <int> ; i < byteCount ; ) { long v = in . readLong ( ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; memory . setByte ( i + + , ( byte ) ( v > > > <int> ) ) ; } return new OffHeapBitSet ( memory ) ; } public void close ( ) { bytes . free ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof OffHeapBitSet ) ) return false ; OffHeapBitSet b = ( OffHeapBitSet ) o ; return bytes . equals ( b . bytes ) ; } @Override public int hashCode ( ) { long h = <int> ; for ( long i = bytes . size ( ) ; - - i > = <int> ; ) { h ^ = bytes . getByte ( i ) ; h = ( h < < <int> ) | ( h > > > <int> ) ; } return ( int ) ( ( h > > <int> ) ^ h ) + <hex> ; } public String toString ( ) { return <str> ; } } 
