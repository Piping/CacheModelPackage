package org . elasticsearch . plan . a ; import java . net . MalformedURLException ; import java . net . URL ; import java . security . CodeSource ; import java . security . SecureClassLoader ; import java . security . cert . Certificate ; import org . antlr . v4 . runtime . ANTLRInputStream ; import org . antlr . v4 . runtime . CommonTokenStream ; import org . antlr . v4 . runtime . ParserRuleContext ; import org . elasticsearch . bootstrap . BootstrapInfo ; final class Compiler { private static Definition DEFAULT_DEFINITION = new Definition ( new Definition ( ) ) ; private static final CodeSource CODESOURCE ; static { try { CODESOURCE = new CodeSource ( new URL ( <str> + BootstrapInfo . UNTRUSTED_CODEBASE ) , ( Certificate [ ] ) null ) ; } catch ( MalformedURLException impossible ) { throw new RuntimeException ( impossible ) ; } } static class Loader extends SecureClassLoader { Loader ( ClassLoader parent ) { super ( parent ) ; } Class < ? extends Executable > define ( String name , byte [ ] bytes ) { return defineClass ( name , bytes , <int> , bytes . length , CODESOURCE ) . asSubclass ( Executable . class ) ; } } static Executable compile ( Loader loader , final String name , final String source , final Definition custom , CompilerSettings settings ) { long start = System . currentTimeMillis ( ) ; final Definition definition = custom = = null ? DEFAULT_DEFINITION : new Definition ( custom ) ; final ANTLRInputStream stream = new ANTLRInputStream ( source ) ; final ErrorHandlingLexer lexer = new ErrorHandlingLexer ( stream ) ; final PlanAParser parser = new PlanAParser ( new CommonTokenStream ( lexer ) ) ; final ParserErrorStrategy strategy = new ParserErrorStrategy ( ) ; lexer . removeErrorListeners ( ) ; lexer . setTypes ( definition . structs . keySet ( ) ) ; parser . removeErrorListeners ( ) ; parser . setErrorHandler ( strategy ) ; ParserRuleContext root = parser . source ( ) ; final Adapter adapter = new Adapter ( definition , source , root , settings ) ; start = System . currentTimeMillis ( ) ; Analyzer . analyze ( adapter ) ; final byte [ ] bytes = Writer . write ( adapter ) ; final Executable executable = createExecutable ( loader , definition , name , source , bytes ) ; return executable ; } private static ParserRuleContext createParseTree ( String source , Definition definition ) { final ANTLRInputStream stream = new ANTLRInputStream ( source ) ; final ErrorHandlingLexer lexer = new ErrorHandlingLexer ( stream ) ; final PlanAParser parser = new PlanAParser ( new CommonTokenStream ( lexer ) ) ; final ParserErrorStrategy strategy = new ParserErrorStrategy ( ) ; lexer . removeErrorListeners ( ) ; lexer . setTypes ( definition . structs . keySet ( ) ) ; parser . removeErrorListeners ( ) ; parser . setErrorHandler ( strategy ) ; ParserRuleContext root = parser . source ( ) ; return root ; } private static Executable createExecutable ( Loader loader , Definition definition , String name , String source , byte [ ] bytes ) { try { final Class < ? extends Executable > clazz = loader . define ( Writer . CLASS_NAME , bytes ) ; final java . lang . reflect . Constructor < ? extends Executable > constructor = clazz . getConstructor ( Definition . class , String . class , String . class ) ; return constructor . newInstance ( definition , name , source ) ; } catch ( Exception exception ) { throw new IllegalStateException ( <str> + name + <str> , exception ) ; } } private Compiler ( ) { } } 
