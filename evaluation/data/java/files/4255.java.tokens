package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . SocketChannel ; import io . netty . handler . codec . spdy . SpdyFrameCodec ; import io . netty . handler . codec . spdy . SpdyVersion ; import io . netty . util . NetUtil ; import org . junit . Test ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . util . Random ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . * ; public class SocketSpdyEchoTest extends AbstractSocketTest { private static final Random random = new Random ( ) ; static final int ignoredBytes = <int> ; private static ByteBuf createFrames ( int version ) { ByteBuf frames = Unpooled . buffer ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <hex> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; frames . writeInt ( random . nextInt ( ) ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { frames . writeInt ( random . nextInt ( ) ) ; } frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; frames . writeInt ( random . nextInt ( ) & <hex> ) ; frames . writeShort ( <hex> ) ; if ( version < <int> ) { frames . writeShort ( <int> ) ; } frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; if ( version < <int> ) { frames . writeInt ( <int> ) ; } frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; frames . writeInt ( random . nextInt ( ) | <hex> ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( random . nextInt ( ) ) ; frames . writeInt ( random . nextInt ( ) ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeInt ( random . nextInt ( ) ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> ) ; frames . writeInt ( random . nextInt ( ) | <hex> ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeByte ( <hex> ) ; frames . writeMedium ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; frames . writeByte ( <hex> ) ; frames . writeByte ( version ) ; frames . writeShort ( <int> ) ; frames . writeInt ( <int> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; frames . writeInt ( random . nextInt ( ) & <hex> | <hex> ) ; return frames ; } @Test ( timeout = <int> ) public void testSpdyEcho ( ) throws Throwable { run ( ) ; } public void testSpdyEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { logger . info ( <str> ) ; testSpdyEcho ( sb , cb , SpdyVersion . SPDY_3_1 , true ) ; } @Test ( timeout = <int> ) public void testSpdyEchoNotAutoRead ( ) throws Throwable { run ( ) ; } public void testSpdyEchoNotAutoRead ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { logger . info ( <str> ) ; testSpdyEcho ( sb , cb , SpdyVersion . SPDY_3_1 , false ) ; } private static void testSpdyEcho ( ServerBootstrap sb , Bootstrap cb , final SpdyVersion version , boolean autoRead ) throws Throwable { ByteBuf frames ; switch ( version ) { case SPDY_3_1 : frames = createFrames ( <int> ) ; break ; default : throw new IllegalArgumentException ( <str> ) ; } sb . childOption ( ChannelOption . AUTO_READ , autoRead ) ; cb . option ( ChannelOption . AUTO_READ , autoRead ) ; final SpdyEchoTestServerHandler sh = new SpdyEchoTestServerHandler ( autoRead ) ; final SpdyEchoTestClientHandler ch = new SpdyEchoTestClientHandler ( frames . copy ( ) , autoRead ) ; sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { @Override public void initChannel ( SocketChannel channel ) throws Exception { channel . pipeline ( ) . addLast ( new SpdyFrameCodec ( version ) , sh ) ; } } ) ; cb . handler ( ch ) ; Channel sc = sb . localAddress ( <int> ) . bind ( ) . sync ( ) . channel ( ) ; int port = ( ( InetSocketAddress ) sc . localAddress ( ) ) . getPort ( ) ; Channel cc = cb . remoteAddress ( NetUtil . LOCALHOST , port ) . connect ( ) . sync ( ) . channel ( ) ; cc . writeAndFlush ( frames ) ; while ( ch . counter < frames . writerIndex ( ) - ignoredBytes ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } if ( sh . exception . get ( ) ! = null & & ! ( sh . exception . get ( ) instanceof IOException ) ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null & & ! ( ch . exception . get ( ) instanceof IOException ) ) { throw ch . exception . get ( ) ; } if ( sh . exception . get ( ) ! = null ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null ) { throw ch . exception . get ( ) ; } } private static class SpdyEchoTestServerHandler extends ChannelInboundHandlerAdapter { private final boolean autoRead ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; SpdyEchoTestServerHandler ( boolean autoRead ) { this . autoRead = autoRead ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { if ( ! autoRead ) { ctx . read ( ) ; } } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ctx . write ( msg ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { try { ctx . flush ( ) ; } finally { if ( ! autoRead ) { ctx . read ( ) ; } } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { ctx . close ( ) ; } } } private static class SpdyEchoTestClientHandler extends SimpleChannelInboundHandler < ByteBuf > { private final boolean autoRead ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; final ByteBuf frames ; volatile int counter ; SpdyEchoTestClientHandler ( ByteBuf frames , boolean autoRead ) { this . frames = frames ; this . autoRead = autoRead ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { if ( ! autoRead ) { ctx . read ( ) ; } } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { byte [ ] actual = new byte [ in . readableBytes ( ) ] ; in . readBytes ( actual ) ; int lastIdx = counter ; for ( int i = <int> ; i < actual . length ; i + + ) { assertEquals ( frames . getByte ( ignoredBytes + i + lastIdx ) , actual [ i ] ) ; } counter + = actual . length ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { ctx . close ( ) ; } } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { if ( ! autoRead ) { ctx . read ( ) ; } } } }