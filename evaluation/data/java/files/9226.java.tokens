package org . eclipse . debug . internal . core ; import java . io . BufferedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . filesystem . EFS ; import org . eclipse . core . filesystem . IFileStore ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRunnable ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubMonitor ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import com . ibm . icu . text . MessageFormat ; public class LaunchConfigurationWorkingCopy extends LaunchConfiguration implements ILaunchConfigurationWorkingCopy { private LaunchConfiguration fOriginal ; private LaunchConfigurationWorkingCopy fParent = null ; private LaunchConfigurationInfo fInfo ; private boolean fDirty ; private boolean fRenamed ; private boolean fSuppressChange ; protected LaunchConfigurationWorkingCopy ( LaunchConfiguration original ) throws CoreException { super ( original . getName ( ) , original . getContainer ( ) ) ; copyFrom ( original ) ; setOriginal ( original ) ; fSuppressChange = false ; } @Override protected void initialize ( ) { fDirty = false ; fRenamed = false ; fSuppressChange = true ; super . initialize ( ) ; } protected LaunchConfigurationWorkingCopy ( LaunchConfigurationWorkingCopy parent ) throws CoreException { super ( parent . getName ( ) , parent . getContainer ( ) ) ; copyFrom ( parent ) ; setOriginal ( ( LaunchConfiguration ) parent . getOriginal ( ) ) ; fParent = parent ; fSuppressChange = false ; } protected LaunchConfigurationWorkingCopy ( LaunchConfiguration original , String name ) throws CoreException { super ( name , original . getContainer ( ) ) ; copyFrom ( original ) ; fSuppressChange = false ; } protected LaunchConfigurationWorkingCopy ( IContainer container , String name , ILaunchConfigurationType type ) { super ( name , container ) ; setInfo ( new LaunchConfigurationInfo ( ) ) ; getInfo ( ) . setType ( type ) ; fSuppressChange = false ; } @Override public boolean isDirty ( ) { return fDirty ; } @Override public synchronized ILaunchConfiguration doSave ( ) throws CoreException { return doSave ( new NullProgressMonitor ( ) ) ; } public synchronized ILaunchConfiguration doSave ( IProgressMonitor monitor ) throws CoreException { SubMonitor lmonitor = SubMonitor . convert ( monitor , <int> ) ; try { if ( getParent ( ) ! = null ) { LaunchConfigurationWorkingCopy wc = ( LaunchConfigurationWorkingCopy ) getParent ( ) ; if ( isMoved ( ) ) { wc . rename ( getName ( ) ) ; wc . setContainer ( getContainer ( ) ) ; } wc . setAttributes ( getInfo ( ) . getAttributes ( ) ) ; updateMonitor ( lmonitor , <int> ) ; return wc ; } else { boolean useRunnable = true ; if ( isLocal ( ) ) { if ( isMoved ( ) ) { useRunnable = ! isNew ( ) & & ! getOriginal ( ) . isLocal ( ) ; } else { useRunnable = false ; } } if ( useRunnable ) { IWorkspaceRunnable wr = new IWorkspaceRunnable ( ) { @Override public void run ( IProgressMonitor pm ) throws CoreException { doSave0 ( pm ) ; } } ; ResourcesPlugin . getWorkspace ( ) . run ( wr , null , <int> , lmonitor . newChild ( <int> ) ) ; } else { doSave0 ( lmonitor . newChild ( <int> ) ) ; } getLaunchManager ( ) . setMovedFromTo ( null , null ) ; } } finally { if ( lmonitor ! = null ) { lmonitor . done ( ) ; } } return new LaunchConfiguration ( getName ( ) , getContainer ( ) ) ; } private void doSave0 ( IProgressMonitor monitor ) throws CoreException { SubMonitor lmonitor = SubMonitor . convert ( monitor , MessageFormat . format ( DebugCoreMessages . LaunchConfigurationWorkingCopy_0 , new Object [ ] { getName ( ) } ) , <int> ) ; try { boolean moved = ( ! isNew ( ) & & isMoved ( ) ) ; if ( moved ) { ILaunchConfiguration to = new LaunchConfiguration ( getName ( ) , getContainer ( ) ) ; ILaunchConfiguration from = getOriginal ( ) ; getLaunchManager ( ) . setMovedFromTo ( from , to ) ; } ILaunchConfiguration orig = getOriginal ( ) ; updateMonitor ( lmonitor , <int> ) ; writeNewFile ( lmonitor . newChild ( <int> ) ) ; if ( moved ) { orig . delete ( ) ; } fDirty = false ; } finally { if ( lmonitor ! = null ) { lmonitor . done ( ) ; } } } protected void writeNewFile ( IProgressMonitor monitor ) throws CoreException { String xml = null ; try { xml = getInfo ( ) . getAsXML ( ) ; } catch ( Exception e ) { throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , MessageFormat . format ( DebugCoreMessages . LaunchConfigurationWorkingCopy__0__occurred_generating_launch_configuration_XML__1 , new Object [ ] { e . toString ( ) } ) , null ) ) ; } SubMonitor lmonitor = SubMonitor . convert ( monitor , IInternalDebugCoreConstants . EMPTY_STRING , <int> ) ; try { boolean added = false ; if ( isLocal ( ) ) { try { lmonitor . subTask ( DebugCoreMessages . LaunchConfigurationWorkingCopy_1 ) ; IFileStore file = getFileStore ( ) ; if ( file = = null ) { throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , DebugCoreMessages . LaunchConfigurationWorkingCopy_4 , null ) ) ; } IFileStore dir = file . getParent ( ) ; dir . mkdir ( EFS . SHALLOW , null ) ; if ( ! file . fetchInfo ( ) . exists ( ) ) { added = true ; updateMonitor ( lmonitor , <int> ) ; } BufferedOutputStream stream = null ; try { stream = new BufferedOutputStream ( file . openOutputStream ( EFS . NONE , null ) ) ; stream . write ( xml . getBytes ( <str> ) ) ; } finally { if ( stream ! = null ) { stream . close ( ) ; } } updateMonitor ( lmonitor , <int> ) ; } catch ( IOException ie ) { lmonitor . done ( ) ; throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , MessageFormat . format ( DebugCoreMessages . LaunchConfigurationWorkingCopy__0__occurred_generating_launch_configuration_XML__1 , new Object [ ] { ie . toString ( ) } ) , null ) ) ; } } else { IFile file = getFile ( ) ; if ( file = = null ) { lmonitor . done ( ) ; throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , DebugCoreMessages . LaunchConfigurationWorkingCopy_5 , null ) ) ; } IContainer dir = file . getParent ( ) ; if ( ! dir . exists ( ) ) { lmonitor . done ( ) ; throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , DebugCoreMessages . LaunchConfigurationWorkingCopy_Specified_container_for_launch_configuration_does_not_exist_2 , null ) ) ; } ByteArrayInputStream stream = null ; try { stream = new ByteArrayInputStream ( xml . getBytes ( <str> ) ) ; } catch ( UnsupportedEncodingException ue ) { lmonitor . done ( ) ; throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , DebugCoreMessages . LaunchConfigurationWorkingCopy_5 , ue ) ) ; } SubMonitor smonitor = null ; if ( ! file . exists ( ) ) { added = true ; smonitor = lmonitor . newChild ( <int> ) ; smonitor . setTaskName ( MessageFormat . format ( DebugCoreMessages . LaunchConfigurationWorkingCopy_2 , new Object [ ] { getName ( ) } ) ) ; file . create ( stream , false , smonitor ) ; } else { if ( file . isReadOnly ( ) ) { IStatus status = ResourcesPlugin . getWorkspace ( ) . validateEdit ( new IFile [ ] { file } , null ) ; if ( ! status . isOK ( ) ) { lmonitor . done ( ) ; throw new CoreException ( status ) ; } } smonitor = lmonitor . newChild ( <int> ) ; smonitor . setTaskName ( MessageFormat . format ( DebugCoreMessages . LaunchConfigurationWorkingCopy_3 , new Object [ ] { getName ( ) } ) ) ; file . setContents ( stream , true , false , smonitor ) ; } } if ( added ) { getLaunchManager ( ) . launchConfigurationAdded ( new LaunchConfiguration ( getName ( ) , getContainer ( ) ) ) ; } else { getLaunchManager ( ) . launchConfigurationChanged ( new LaunchConfiguration ( getName ( ) , getContainer ( ) ) ) ; } } finally { if ( lmonitor ! = null ) { lmonitor . done ( ) ; } } } private void updateMonitor ( IProgressMonitor monitor , int ticks ) throws OperationCanceledException { if ( monitor ! = null ) { monitor . worked ( ticks ) ; if ( monitor . isCanceled ( ) ) { throw new OperationCanceledException ( ) ; } } } @Override public void setAttribute ( String attributeName , int value ) { getInfo ( ) . setAttribute ( attributeName , Integer . valueOf ( value ) ) ; setDirty ( ) ; } @Override public void setAttribute ( String attributeName , String value ) { getInfo ( ) . setAttribute ( attributeName , value ) ; setDirty ( ) ; } @Override public void setAttribute ( String attributeName , boolean value ) { getInfo ( ) . setAttribute ( attributeName , Boolean . valueOf ( value ) ) ; setDirty ( ) ; } @Override public void setAttribute ( String attributeName , List < String > value ) { getInfo ( ) . setAttribute ( attributeName , value ) ; setDirty ( ) ; } @Override public void setAttribute ( String attributeName , Map < String , String > value ) { getInfo ( ) . setAttribute ( attributeName , value ) ; setDirty ( ) ; } @Override public void setAttribute ( String attributeName , Set < String > value ) { getInfo ( ) . setAttribute ( attributeName , value ) ; setDirty ( ) ; } @Override public ILaunchConfiguration getOriginal ( ) { ILaunchConfiguration config = fOriginal ; ILaunchConfigurationWorkingCopy parent = fParent ; while ( parent ! = null ) { config = parent . getOriginal ( ) ; parent = parent . getParent ( ) ; } return config ; } @Override public ILaunchConfigurationWorkingCopy getParent ( ) { return fParent ; } private void copyFrom ( LaunchConfiguration original ) throws CoreException { LaunchConfigurationInfo info = original . getInfo ( ) ; setInfo ( info . getCopy ( ) ) ; fDirty = false ; } private void setOriginal ( LaunchConfiguration original ) { fOriginal = original ; } protected void setInfo ( LaunchConfigurationInfo info ) { fInfo = info ; } @Override public boolean isWorkingCopy ( ) { return true ; } @Override protected LaunchConfigurationInfo getInfo ( ) { return fInfo ; } private void setDirty ( ) { fDirty = true ; if ( ! suppressChangeNotification ( ) ) { getLaunchManager ( ) . getConfigurationNotifier ( ) . notify ( this , LaunchManager . CHANGED ) ; } } @Override public void setModes ( Set < String > modes ) { getInfo ( ) . setAttribute ( ATTR_LAUNCH_MODES , ( modes . size ( ) > <int> ? modes : null ) ) ; setDirty ( ) ; } @Override public void addModes ( Set < String > modes ) { try { Set < String > opts = getModes ( ) ; if ( opts . addAll ( modes ) ) { getInfo ( ) . setAttribute ( ATTR_LAUNCH_MODES , opts ) ; setDirty ( ) ; } } catch ( CoreException e ) { DebugPlugin . log ( e ) ; } } @Override public void removeModes ( Set < String > options ) { try { Set < String > opts = getModes ( ) ; if ( opts . removeAll ( options ) ) { getInfo ( ) . setAttribute ( ATTR_LAUNCH_MODES , ( opts . size ( ) < <int> ? null : opts ) ) ; setDirty ( ) ; } } catch ( CoreException e ) { DebugPlugin . log ( e ) ; } } @Override public void rename ( String name ) { if ( ! getName ( ) . equals ( name ) ) { setName ( name ) ; fRenamed = isNew ( ) | | ! ( getOriginal ( ) . getName ( ) . equals ( name ) ) ; } } @Override protected void setName ( String name ) { super . setName ( name ) ; setDirty ( ) ; } protected boolean isNew ( ) { return getOriginal ( ) = = null ; } protected boolean isMoved ( ) { if ( isNew ( ) | | fRenamed ) { return true ; } IContainer newContainer = getContainer ( ) ; IContainer originalContainer = ( ( LaunchConfiguration ) getOriginal ( ) ) . getContainer ( ) ; if ( newContainer = = originalContainer ) { return false ; } if ( newContainer = = null ) { return ! originalContainer . equals ( newContainer ) ; } return ! newContainer . equals ( originalContainer ) ; } @Override public String getMemento ( ) { return null ; } protected boolean suppressChangeNotification ( ) { return fSuppressChange ; } @Override public void setContainer ( IContainer container ) { if ( equalOrNull ( getContainer ( ) , container ) ) { return ; } super . setContainer ( container ) ; setDirty ( ) ; } @Override public void setAttributes ( Map < String , ? extends Object > attributes ) { getInfo ( ) . setAttributes ( attributes ) ; setDirty ( ) ; } @Override public void setMappedResources ( IResource [ ] resources ) { ArrayList < String > paths = null ; ArrayList < String > types = null ; if ( resources ! = null & & resources . length > <int> ) { paths = new ArrayList < String > ( resources . length ) ; types = new ArrayList < String > ( resources . length ) ; for ( int i = <int> ; i < resources . length ; i + + ) { IResource resource = resources [ i ] ; if ( resource ! = null ) { paths . add ( resource . getFullPath ( ) . toPortableString ( ) ) ; types . add ( Integer . valueOf ( resource . getType ( ) ) . toString ( ) ) ; } } } setAttribute ( LaunchConfiguration . ATTR_MAPPED_RESOURCE_PATHS , paths ) ; setAttribute ( LaunchConfiguration . ATTR_MAPPED_RESOURCE_TYPES , types ) ; } @Override public void setPreferredLaunchDelegate ( Set < String > modes , String delegateId ) { if ( modes ! = null ) { try { Map < String , String > delegates = getAttribute ( LaunchConfiguration . ATTR_PREFERRED_LAUNCHERS , ( Map < String , String > ) null ) ; Map < String , String > map = new HashMap < String , String > ( ) ; if ( delegates ! = null ) { map . putAll ( delegates ) ; } if ( delegateId = = null ) { map . remove ( modes . toString ( ) ) ; } else { map . put ( modes . toString ( ) , delegateId ) ; } setAttribute ( LaunchConfiguration . ATTR_PREFERRED_LAUNCHERS , map ) ; } catch ( CoreException ce ) { DebugPlugin . log ( ce ) ; } } } @Override public ILaunchConfigurationWorkingCopy getWorkingCopy ( ) throws CoreException { return new LaunchConfigurationWorkingCopy ( this ) ; } @Override public Object removeAttribute ( String attributeName ) { return getInfo ( ) . removeAttribute ( attributeName ) ; } }