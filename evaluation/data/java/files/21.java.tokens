package org . apache . cassandra . db . filter ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . transform . BasePartitions ; import org . apache . cassandra . db . transform . BaseRows ; import org . apache . cassandra . db . transform . StoppingTransformation ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class DataLimits { public static final Serializer serializer = new Serializer ( ) ; public static final int NO_LIMIT = Integer . MAX_VALUE ; public static final DataLimits NONE = new CQLLimits ( NO_LIMIT ) { @Override public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) { return false ; } @Override public UnfilteredPartitionIterator filter ( UnfilteredPartitionIterator iter , int nowInSec ) { return iter ; } @Override public UnfilteredRowIterator filter ( UnfilteredRowIterator iter , int nowInSec ) { return iter ; } } ; public static final DataLimits DISTINCT_NONE = new CQLLimits ( NO_LIMIT , <int> , true ) ; public enum Kind { CQL_LIMIT , CQL_PAGING_LIMIT , THRIFT_LIMIT , SUPER_COLUMN_COUNTING_LIMIT } public static DataLimits cqlLimits ( int cqlRowLimit ) { return new CQLLimits ( cqlRowLimit ) ; } public static DataLimits cqlLimits ( int cqlRowLimit , int perPartitionLimit ) { return new CQLLimits ( cqlRowLimit , perPartitionLimit ) ; } public static DataLimits distinctLimits ( int cqlRowLimit ) { return CQLLimits . distinct ( cqlRowLimit ) ; } public static DataLimits thriftLimits ( int partitionLimit , int cellPerPartitionLimit ) { return new ThriftLimits ( partitionLimit , cellPerPartitionLimit ) ; } public static DataLimits superColumnCountingLimits ( int partitionLimit , int cellPerPartitionLimit ) { return new SuperColumnCountingLimits ( partitionLimit , cellPerPartitionLimit ) ; } public abstract Kind kind ( ) ; public abstract boolean isUnlimited ( ) ; public abstract DataLimits forPaging ( int pageSize ) ; public abstract DataLimits forPaging ( int pageSize , ByteBuffer lastReturnedKey , int lastReturnedKeyRemaining ) ; public abstract DataLimits forShortReadRetry ( int toFetch ) ; public abstract boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) ; public abstract Counter newCounter ( int nowInSec , boolean assumeLiveData ) ; public abstract int count ( ) ; public abstract int perPartitionCount ( ) ; public UnfilteredPartitionIterator filter ( UnfilteredPartitionIterator iter , int nowInSec ) { return this . newCounter ( nowInSec , false ) . applyTo ( iter ) ; } public UnfilteredRowIterator filter ( UnfilteredRowIterator iter , int nowInSec ) { return this . newCounter ( nowInSec , false ) . applyTo ( iter ) ; } public PartitionIterator filter ( PartitionIterator iter , int nowInSec ) { return this . newCounter ( nowInSec , true ) . applyTo ( iter ) ; } public abstract float estimateTotalResults ( ColumnFamilyStore cfs ) ; public static abstract class Counter extends StoppingTransformation < BaseRowIterator < ? > > { private boolean enforceLimits = true ; public Counter onlyCount ( ) { this . enforceLimits = false ; return this ; } public PartitionIterator applyTo ( PartitionIterator partitions ) { return Transformation . apply ( partitions , this ) ; } public UnfilteredPartitionIterator applyTo ( UnfilteredPartitionIterator partitions ) { return Transformation . apply ( partitions , this ) ; } public UnfilteredRowIterator applyTo ( UnfilteredRowIterator partition ) { return ( UnfilteredRowIterator ) applyToPartition ( partition ) ; } public RowIterator applyTo ( RowIterator partition ) { return ( RowIterator ) applyToPartition ( partition ) ; } public abstract int counted ( ) ; public abstract int countedInCurrentPartition ( ) ; public abstract boolean isDone ( ) ; public abstract boolean isDoneForPartition ( ) ; @Override protected BaseRowIterator < ? > applyToPartition ( BaseRowIterator < ? > partition ) { return partition instanceof UnfilteredRowIterator ? Transformation . apply ( ( UnfilteredRowIterator ) partition , this ) : Transformation . apply ( ( RowIterator ) partition , this ) ; } protected abstract void applyToPartition ( DecoratedKey partitionKey , Row staticRow ) ; @Override protected void attachTo ( BasePartitions partitions ) { if ( enforceLimits ) super . attachTo ( partitions ) ; if ( isDone ( ) ) stop ( ) ; } @Override protected void attachTo ( BaseRows rows ) { if ( enforceLimits ) super . attachTo ( rows ) ; applyToPartition ( rows . partitionKey ( ) , rows . staticRow ( ) ) ; if ( isDoneForPartition ( ) ) stopInPartition ( ) ; } } private static class CQLLimits extends DataLimits { protected final int rowLimit ; protected final int perPartitionLimit ; protected final boolean isDistinct ; private CQLLimits ( int rowLimit ) { this ( rowLimit , NO_LIMIT ) ; } private CQLLimits ( int rowLimit , int perPartitionLimit ) { this ( rowLimit , perPartitionLimit , false ) ; } private CQLLimits ( int rowLimit , int perPartitionLimit , boolean isDistinct ) { this . rowLimit = rowLimit ; this . perPartitionLimit = perPartitionLimit ; this . isDistinct = isDistinct ; } private static CQLLimits distinct ( int rowLimit ) { return new CQLLimits ( rowLimit , <int> , true ) ; } public Kind kind ( ) { return Kind . CQL_LIMIT ; } public boolean isUnlimited ( ) { return rowLimit = = NO_LIMIT & & perPartitionLimit = = NO_LIMIT ; } public DataLimits forPaging ( int pageSize ) { return new CQLLimits ( pageSize , perPartitionLimit ) ; } public DataLimits forPaging ( int pageSize , ByteBuffer lastReturnedKey , int lastReturnedKeyRemaining ) { return new CQLPagingLimits ( pageSize , perPartitionLimit , isDistinct , lastReturnedKey , lastReturnedKeyRemaining ) ; } public DataLimits forShortReadRetry ( int toFetch ) { return new CQLLimits ( toFetch , NO_LIMIT , isDistinct ) ; } public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) { if ( cached . rowsWithNonExpiringCells ( ) > = rowLimit ) return true ; if ( cached . rowCount ( ) < rowLimit ) return false ; DataLimits . Counter counter = newCounter ( nowInSec , false ) ; try ( UnfilteredRowIterator cacheIter = cached . unfilteredIterator ( ColumnFilter . selection ( cached . columns ( ) ) , Slices . ALL , false ) ; UnfilteredRowIterator iter = counter . applyTo ( cacheIter ) ) { while ( iter . hasNext ( ) ) iter . next ( ) ; return counter . isDone ( ) ; } } public Counter newCounter ( int nowInSec , boolean assumeLiveData ) { return new CQLCounter ( nowInSec , assumeLiveData ) ; } public int count ( ) { return rowLimit ; } public int perPartitionCount ( ) { return perPartitionLimit ; } public float estimateTotalResults ( ColumnFamilyStore cfs ) { float rowsPerPartition = ( ( float ) cfs . getMeanColumns ( ) ) / cfs . metadata . partitionColumns ( ) . regulars . size ( ) ; return rowsPerPartition * ( cfs . estimateKeys ( ) ) ; } protected class CQLCounter extends Counter { protected final int nowInSec ; protected final boolean assumeLiveData ; protected int rowCounted ; protected int rowInCurrentPartition ; protected boolean hasLiveStaticRow ; public CQLCounter ( int nowInSec , boolean assumeLiveData ) { this . nowInSec = nowInSec ; this . assumeLiveData = assumeLiveData ; } @Override public void applyToPartition ( DecoratedKey partitionKey , Row staticRow ) { rowInCurrentPartition = <int> ; if ( ! staticRow . isEmpty ( ) & & ( assumeLiveData | | staticRow . hasLiveData ( nowInSec ) ) ) hasLiveStaticRow = true ; } @Override public Row applyToRow ( Row row ) { if ( assumeLiveData | | row . hasLiveData ( nowInSec ) ) incrementRowCount ( ) ; return row ; } @Override public void onPartitionClose ( ) { if ( hasLiveStaticRow & & rowInCurrentPartition = = <int> ) incrementRowCount ( ) ; super . onPartitionClose ( ) ; } private void incrementRowCount ( ) { if ( + + rowCounted > = rowLimit ) stop ( ) ; if ( + + rowInCurrentPartition > = perPartitionLimit ) stopInPartition ( ) ; } public int counted ( ) { return rowCounted ; } public int countedInCurrentPartition ( ) { return rowInCurrentPartition ; } public boolean isDone ( ) { return rowCounted > = rowLimit ; } public boolean isDoneForPartition ( ) { return isDone ( ) | | rowInCurrentPartition > = perPartitionLimit ; } } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( rowLimit ! = NO_LIMIT ) { sb . append ( <str> ) . append ( rowLimit ) ; if ( perPartitionLimit ! = NO_LIMIT ) sb . append ( <str> ) ; } if ( perPartitionLimit ! = NO_LIMIT ) sb . append ( <str> ) . append ( perPartitionLimit ) ; return sb . toString ( ) ; } } private static class CQLPagingLimits extends CQLLimits { private final ByteBuffer lastReturnedKey ; private final int lastReturnedKeyRemaining ; public CQLPagingLimits ( int rowLimit , int perPartitionLimit , boolean isDistinct , ByteBuffer lastReturnedKey , int lastReturnedKeyRemaining ) { super ( rowLimit , perPartitionLimit , isDistinct ) ; this . lastReturnedKey = lastReturnedKey ; this . lastReturnedKeyRemaining = lastReturnedKeyRemaining ; } @Override public Kind kind ( ) { return Kind . CQL_PAGING_LIMIT ; } @Override public DataLimits forPaging ( int pageSize ) { throw new UnsupportedOperationException ( ) ; } @Override public DataLimits forPaging ( int pageSize , ByteBuffer lastReturnedKey , int lastReturnedKeyRemaining ) { throw new UnsupportedOperationException ( ) ; } @Override public Counter newCounter ( int nowInSec , boolean assumeLiveData ) { return new PagingAwareCounter ( nowInSec , assumeLiveData ) ; } private class PagingAwareCounter extends CQLCounter { private PagingAwareCounter ( int nowInSec , boolean assumeLiveData ) { super ( nowInSec , assumeLiveData ) ; } @Override public void applyToPartition ( DecoratedKey partitionKey , Row staticRow ) { if ( partitionKey . getKey ( ) . equals ( lastReturnedKey ) ) { rowInCurrentPartition = perPartitionLimit - lastReturnedKeyRemaining ; hasLiveStaticRow = false ; } else { super . applyToPartition ( partitionKey , staticRow ) ; } } } } private static class ThriftLimits extends DataLimits { protected final int partitionLimit ; protected final int cellPerPartitionLimit ; private ThriftLimits ( int partitionLimit , int cellPerPartitionLimit ) { this . partitionLimit = partitionLimit ; this . cellPerPartitionLimit = cellPerPartitionLimit ; } public Kind kind ( ) { return Kind . THRIFT_LIMIT ; } public boolean isUnlimited ( ) { return partitionLimit = = NO_LIMIT & & cellPerPartitionLimit = = NO_LIMIT ; } public DataLimits forPaging ( int pageSize ) { assert partitionLimit = = <int> ; return new ThriftLimits ( partitionLimit , pageSize ) ; } public DataLimits forPaging ( int pageSize , ByteBuffer lastReturnedKey , int lastReturnedKeyRemaining ) { throw new UnsupportedOperationException ( ) ; } public DataLimits forShortReadRetry ( int toFetch ) { return new ThriftLimits ( <int> , toFetch ) ; } public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) { if ( cached . nonExpiringLiveCells ( ) > = cellPerPartitionLimit ) return true ; if ( cached . nonTombstoneCellCount ( ) < cellPerPartitionLimit ) return false ; DataLimits . Counter counter = newCounter ( nowInSec , false ) ; try ( UnfilteredRowIterator cacheIter = cached . unfilteredIterator ( ColumnFilter . selection ( cached . columns ( ) ) , Slices . ALL , false ) ; UnfilteredRowIterator iter = counter . applyTo ( cacheIter ) ) { while ( iter . hasNext ( ) ) iter . next ( ) ; return counter . isDone ( ) ; } } public Counter newCounter ( int nowInSec , boolean assumeLiveData ) { return new ThriftCounter ( nowInSec , assumeLiveData ) ; } public int count ( ) { return partitionLimit * cellPerPartitionLimit ; } public int perPartitionCount ( ) { return cellPerPartitionLimit ; } public float estimateTotalResults ( ColumnFamilyStore cfs ) { float cellsPerPartition = ( ( float ) cfs . getMeanColumns ( ) ) / cfs . metadata . partitionColumns ( ) . regulars . size ( ) ; return cellsPerPartition * cfs . estimateKeys ( ) ; } protected class ThriftCounter extends Counter { protected final int nowInSec ; protected final boolean assumeLiveData ; protected int partitionsCounted ; protected int cellsCounted ; protected int cellsInCurrentPartition ; public ThriftCounter ( int nowInSec , boolean assumeLiveData ) { this . nowInSec = nowInSec ; this . assumeLiveData = assumeLiveData ; } @Override public void applyToPartition ( DecoratedKey partitionKey , Row staticRow ) { cellsInCurrentPartition = <int> ; if ( ! staticRow . isEmpty ( ) ) applyToRow ( staticRow ) ; } @Override public Row applyToRow ( Row row ) { for ( Cell cell : row . cells ( ) ) { if ( assumeLiveData | | cell . isLive ( nowInSec ) ) { + + cellsCounted ; if ( + + cellsInCurrentPartition > = cellPerPartitionLimit ) stopInPartition ( ) ; } } return row ; } @Override public void onPartitionClose ( ) { if ( + + partitionsCounted > = partitionLimit ) stop ( ) ; super . onPartitionClose ( ) ; } public int counted ( ) { return cellsCounted ; } public int countedInCurrentPartition ( ) { return cellsInCurrentPartition ; } public boolean isDone ( ) { return partitionsCounted > = partitionLimit ; } public boolean isDoneForPartition ( ) { return isDone ( ) | | cellsInCurrentPartition > = cellPerPartitionLimit ; } } @Override public String toString ( ) { return String . format ( <str> , partitionLimit , cellPerPartitionLimit ) ; } } private static class SuperColumnCountingLimits extends ThriftLimits { private SuperColumnCountingLimits ( int partitionLimit , int cellPerPartitionLimit ) { super ( partitionLimit , cellPerPartitionLimit ) ; } public Kind kind ( ) { return Kind . SUPER_COLUMN_COUNTING_LIMIT ; } public DataLimits forPaging ( int pageSize ) { assert partitionLimit = = <int> ; return new SuperColumnCountingLimits ( partitionLimit , pageSize ) ; } public DataLimits forShortReadRetry ( int toFetch ) { return new SuperColumnCountingLimits ( <int> , toFetch ) ; } public Counter newCounter ( int nowInSec , boolean assumeLiveData ) { return new SuperColumnCountingCounter ( nowInSec , assumeLiveData ) ; } protected class SuperColumnCountingCounter extends ThriftCounter { public SuperColumnCountingCounter ( int nowInSec , boolean assumeLiveData ) { super ( nowInSec , assumeLiveData ) ; } @Override public Row applyToRow ( Row row ) { if ( assumeLiveData | | row . hasLiveData ( nowInSec ) ) { + + cellsCounted ; if ( + + cellsInCurrentPartition > = cellPerPartitionLimit ) stopInPartition ( ) ; } return row ; } } } public static class Serializer { public void serialize ( DataLimits limits , DataOutputPlus out , int version ) throws IOException { out . writeByte ( limits . kind ( ) . ordinal ( ) ) ; switch ( limits . kind ( ) ) { case CQL_LIMIT : case CQL_PAGING_LIMIT : CQLLimits cqlLimits = ( CQLLimits ) limits ; out . writeUnsignedVInt ( cqlLimits . rowLimit ) ; out . writeUnsignedVInt ( cqlLimits . perPartitionLimit ) ; out . writeBoolean ( cqlLimits . isDistinct ) ; if ( limits . kind ( ) = = Kind . CQL_PAGING_LIMIT ) { CQLPagingLimits pagingLimits = ( CQLPagingLimits ) cqlLimits ; ByteBufferUtil . writeWithVIntLength ( pagingLimits . lastReturnedKey , out ) ; out . writeUnsignedVInt ( pagingLimits . lastReturnedKeyRemaining ) ; } break ; case THRIFT_LIMIT : case SUPER_COLUMN_COUNTING_LIMIT : ThriftLimits thriftLimits = ( ThriftLimits ) limits ; out . writeUnsignedVInt ( thriftLimits . partitionLimit ) ; out . writeUnsignedVInt ( thriftLimits . cellPerPartitionLimit ) ; break ; } } public DataLimits deserialize ( DataInputPlus in , int version ) throws IOException { Kind kind = Kind . values ( ) [ in . readUnsignedByte ( ) ] ; switch ( kind ) { case CQL_LIMIT : case CQL_PAGING_LIMIT : int rowLimit = ( int ) in . readUnsignedVInt ( ) ; int perPartitionLimit = ( int ) in . readUnsignedVInt ( ) ; boolean isDistinct = in . readBoolean ( ) ; if ( kind = = Kind . CQL_LIMIT ) return new CQLLimits ( rowLimit , perPartitionLimit , isDistinct ) ; ByteBuffer lastKey = ByteBufferUtil . readWithVIntLength ( in ) ; int lastRemaining = ( int ) in . readUnsignedVInt ( ) ; return new CQLPagingLimits ( rowLimit , perPartitionLimit , isDistinct , lastKey , lastRemaining ) ; case THRIFT_LIMIT : case SUPER_COLUMN_COUNTING_LIMIT : int partitionLimit = ( int ) in . readUnsignedVInt ( ) ; int cellPerPartitionLimit = ( int ) in . readUnsignedVInt ( ) ; return kind = = Kind . THRIFT_LIMIT ? new ThriftLimits ( partitionLimit , cellPerPartitionLimit ) : new SuperColumnCountingLimits ( partitionLimit , cellPerPartitionLimit ) ; } throw new AssertionError ( ) ; } public long serializedSize ( DataLimits limits , int version ) { long size = TypeSizes . sizeof ( ( byte ) limits . kind ( ) . ordinal ( ) ) ; switch ( limits . kind ( ) ) { case CQL_LIMIT : case CQL_PAGING_LIMIT : CQLLimits cqlLimits = ( CQLLimits ) limits ; size + = TypeSizes . sizeofUnsignedVInt ( cqlLimits . rowLimit ) ; size + = TypeSizes . sizeofUnsignedVInt ( cqlLimits . perPartitionLimit ) ; size + = TypeSizes . sizeof ( cqlLimits . isDistinct ) ; if ( limits . kind ( ) = = Kind . CQL_PAGING_LIMIT ) { CQLPagingLimits pagingLimits = ( CQLPagingLimits ) cqlLimits ; size + = ByteBufferUtil . serializedSizeWithVIntLength ( pagingLimits . lastReturnedKey ) ; size + = TypeSizes . sizeofUnsignedVInt ( pagingLimits . lastReturnedKeyRemaining ) ; } break ; case THRIFT_LIMIT : case SUPER_COLUMN_COUNTING_LIMIT : ThriftLimits thriftLimits = ( ThriftLimits ) limits ; size + = TypeSizes . sizeofUnsignedVInt ( thriftLimits . partitionLimit ) ; size + = TypeSizes . sizeofUnsignedVInt ( thriftLimits . cellPerPartitionLimit ) ; break ; default : throw new AssertionError ( ) ; } return size ; } } } 
