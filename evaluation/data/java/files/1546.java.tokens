package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . locks . AbstractQueuedSynchronizer ; import javax . annotation . Nullable ; final class AbstractFutureBenchmarks { private AbstractFutureBenchmarks ( ) { } interface Facade < T > extends ListenableFuture < T > { boolean set ( T t ) ; boolean setException ( Throwable t ) ; } private static class NewAbstractFutureFacade < T > extends AbstractFuture < T > implements Facade < T > { @Override public boolean set ( T t ) { return super . set ( t ) ; } @Override public boolean setException ( Throwable t ) { return super . setException ( t ) ; } } private static class OldAbstractFutureFacade < T > extends OldAbstractFuture < T > implements Facade < T > { @Override public boolean set ( T t ) { return super . set ( t ) ; } @Override public boolean setException ( Throwable t ) { return super . setException ( t ) ; } } enum Impl { NEW { @Override < T > Facade < T > newFacade ( ) { return new NewAbstractFutureFacade < T > ( ) ; } } , OLD { @Override < T > Facade < T > newFacade ( ) { return new OldAbstractFutureFacade < T > ( ) ; } } ; abstract < T > Facade < T > newFacade ( ) ; } static void awaitWaiting ( Thread t ) { while ( true ) { Thread . State state = t . getState ( ) ; switch ( state ) { case RUNNABLE : case BLOCKED : Thread . yield ( ) ; break ; case WAITING : return ; default : throw new AssertionError ( <str> + state ) ; } } } abstract static class OldAbstractFuture < V > implements ListenableFuture < V > { private final Sync < V > sync = new Sync < V > ( ) ; private final ExecutionList executionList = new ExecutionList ( ) ; protected OldAbstractFuture ( ) { } @Override public V get ( long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException , ExecutionException { return sync . get ( unit . toNanos ( timeout ) ) ; } @Override public V get ( ) throws InterruptedException , ExecutionException { return sync . get ( ) ; } @Override public boolean isDone ( ) { return sync . isDone ( ) ; } @Override public boolean isCancelled ( ) { return sync . isCancelled ( ) ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { if ( ! sync . cancel ( mayInterruptIfRunning ) ) { return false ; } executionList . execute ( ) ; if ( mayInterruptIfRunning ) { interruptTask ( ) ; } return true ; } protected void interruptTask ( ) { } protected final boolean wasInterrupted ( ) { return sync . wasInterrupted ( ) ; } @Override public void addListener ( Runnable listener , Executor exec ) { executionList . add ( listener , exec ) ; } protected boolean set ( @Nullable V value ) { boolean result = sync . set ( value ) ; if ( result ) { executionList . execute ( ) ; } return result ; } protected boolean setException ( Throwable throwable ) { boolean result = sync . setException ( checkNotNull ( throwable ) ) ; if ( result ) { executionList . execute ( ) ; } return result ; } static final class Sync < V > extends AbstractQueuedSynchronizer { private static final long serialVersionUID = <int> ; static final int RUNNING = <int> ; static final int COMPLETING = <int> ; static final int COMPLETED = <int> ; static final int CANCELLED = <int> ; static final int INTERRUPTED = <int> ; private V value ; private Throwable exception ; @Override protected int tryAcquireShared ( int ignored ) { if ( isDone ( ) ) { return <int> ; } return - <int> ; } @Override protected boolean tryReleaseShared ( int finalState ) { setState ( finalState ) ; return true ; } V get ( long nanos ) throws TimeoutException , CancellationException , ExecutionException , InterruptedException { if ( ! tryAcquireSharedNanos ( - <int> , nanos ) ) { throw new TimeoutException ( <str> ) ; } return getValue ( ) ; } V get ( ) throws CancellationException , ExecutionException , InterruptedException { acquireSharedInterruptibly ( - <int> ) ; return getValue ( ) ; } private V getValue ( ) throws CancellationException , ExecutionException { int state = getState ( ) ; switch ( state ) { case COMPLETED : if ( exception ! = null ) { throw new ExecutionException ( exception ) ; } else { return value ; } case CANCELLED : case INTERRUPTED : throw cancellationExceptionWithCause ( <str> , exception ) ; default: throw new IllegalStateException ( <str> + state ) ; } } boolean isDone ( ) { return ( getState ( ) & ( COMPLETED | CANCELLED | INTERRUPTED ) ) ! = <int> ; } boolean isCancelled ( ) { return ( getState ( ) & ( CANCELLED | INTERRUPTED ) ) ! = <int> ; } boolean wasInterrupted ( ) { return getState ( ) = = INTERRUPTED ; } boolean set ( @Nullable V v ) { return complete ( v , null , COMPLETED ) ; } boolean setException ( Throwable t ) { return complete ( null , t , COMPLETED ) ; } boolean cancel ( boolean interrupt ) { return complete ( null , null , interrupt ? INTERRUPTED : CANCELLED ) ; } private boolean complete ( @Nullable V v , @Nullable Throwable t , int finalState ) { boolean doCompletion = compareAndSetState ( RUNNING , COMPLETING ) ; if ( doCompletion ) { this . value = v ; this . exception = ( ( finalState & ( CANCELLED | INTERRUPTED ) ) ! = <int> ) ? new CancellationException ( <str> ) : t ; releaseShared ( finalState ) ; } else if ( getState ( ) = = COMPLETING ) { acquireShared ( - <int> ) ; } return doCompletion ; } } static final CancellationException cancellationExceptionWithCause ( @Nullable String message , @Nullable Throwable cause ) { CancellationException exception = new CancellationException ( message ) ; exception . initCause ( cause ) ; return exception ; } } }