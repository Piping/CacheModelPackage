package io . netty . example . http2 . helloworld . client ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http2 . HttpConversionUtil ; import io . netty . util . CharsetUtil ; import java . util . AbstractMap . SimpleEntry ; import java . util . Iterator ; import java . util . Map . Entry ; import java . util . SortedMap ; import java . util . TreeMap ; import java . util . concurrent . TimeUnit ; public class HttpResponseHandler extends SimpleChannelInboundHandler < FullHttpResponse > { private SortedMap < Integer , Entry < ChannelFuture , ChannelPromise > > streamidPromiseMap ; public HttpResponseHandler ( ) { streamidPromiseMap = new TreeMap < Integer , Entry < ChannelFuture , ChannelPromise > > ( ) ; } public Entry < ChannelFuture , ChannelPromise > put ( int streamId , ChannelFuture writeFuture , ChannelPromise promise ) { return streamidPromiseMap . put ( streamId , new SimpleEntry < ChannelFuture , ChannelPromise > ( writeFuture , promise ) ) ; } public void awaitResponses ( long timeout , TimeUnit unit ) { Iterator < Entry < Integer , Entry < ChannelFuture , ChannelPromise > > > itr = streamidPromiseMap . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Entry < Integer , Entry < ChannelFuture , ChannelPromise > > entry = itr . next ( ) ; ChannelFuture writeFuture = entry . getValue ( ) . getKey ( ) ; if ( ! writeFuture . awaitUninterruptibly ( timeout , unit ) ) { throw new IllegalStateException ( <str> + entry . getKey ( ) ) ; } if ( ! writeFuture . isSuccess ( ) ) { throw new RuntimeException ( writeFuture . cause ( ) ) ; } ChannelPromise promise = entry . getValue ( ) . getValue ( ) ; if ( ! promise . awaitUninterruptibly ( timeout , unit ) ) { throw new IllegalStateException ( <str> + entry . getKey ( ) ) ; } if ( ! promise . isSuccess ( ) ) { throw new RuntimeException ( promise . cause ( ) ) ; } System . out . println ( <str> + entry . getKey ( ) + <str> ) ; itr . remove ( ) ; } } @Override protected void channelRead0 ( ChannelHandlerContext ctx , FullHttpResponse msg ) throws Exception { Integer streamId = msg . headers ( ) . getInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) ) ; if ( streamId = = null ) { System . err . println ( <str> + msg ) ; return ; } Entry < ChannelFuture , ChannelPromise > entry = streamidPromiseMap . get ( streamId ) ; if ( entry = = null ) { System . err . println ( <str> + streamId ) ; } else { ByteBuf content = msg . content ( ) ; if ( content . isReadable ( ) ) { int contentLength = content . readableBytes ( ) ; byte [ ] arr = new byte [ contentLength ] ; content . readBytes ( arr ) ; System . out . println ( new String ( arr , <int> , contentLength , CharsetUtil . UTF_8 ) ) ; } entry . getValue ( ) . setSuccess ( ) ; } } }