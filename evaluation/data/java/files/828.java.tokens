package com . google . common . io ; import static com . google . common . io . BaseEncoding . base16 ; import static com . google . common . io . BaseEncoding . base32 ; import static com . google . common . io . BaseEncoding . base32Hex ; import static com . google . common . io . BaseEncoding . base64 ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Ascii ; import com . google . common . base . Joiner ; import com . google . common . base . Splitter ; import com . google . common . collect . ImmutableList ; import com . google . common . io . BaseEncoding . DecodingException ; import junit . framework . TestCase ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class BaseEncodingTest extends TestCase { public static void assertEquals ( byte [ ] expected , byte [ ] actual ) { assertEquals ( expected . length , actual . length ) ; for ( int i = <int> ; i < expected . length ; i + + ) { assertEquals ( expected [ i ] , actual [ i ] ) ; } } public void testSeparatorsExplicitly ( ) { testEncodes ( base64 ( ) . withSeparator ( <str> , <int> ) , <str> , <str> ) ; testEncodes ( base64 ( ) . withSeparator ( <str> , <int> ) , <str> , <str> ) ; testEncodes ( base32 ( ) . withSeparator ( <str> , <int> ) , <str> , <str> ) ; } @SuppressWarnings ( <str> ) public void testSeparatorSameAsPadChar ( ) { try { base64 ( ) . withSeparator ( <str> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { base64 ( ) . withPadChar ( <str> ) . withSeparator ( <str> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testAtMostOneSeparator ( ) { BaseEncoding separated = base64 ( ) . withSeparator ( <str> , <int> ) ; try { separated . withSeparator ( <str> , <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } public void testBase64 ( ) { testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testBase64Streaming ( ) throws IOException { testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; testStreamingEncodingWithSeparators ( base64 ( ) , <str> , <str> ) ; } public void testBase64LenientPadding ( ) { testDecodes ( base64 ( ) , <str> , <str> ) ; testDecodes ( base64 ( ) , <str> , <str> ) ; testDecodes ( base64 ( ) , <str> , <str> ) ; testDecodes ( base64 ( ) , <str> , <str> ) ; testDecodes ( base64 ( ) , <str> , <str> ) ; } public void testBase64InvalidDecodings ( ) { assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; assertFailsToDecode ( base64 ( ) , <str> , <str> ) ; } @SuppressWarnings ( <str> ) public void testBase64CannotUpperCase ( ) { try { base64 ( ) . upperCase ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @SuppressWarnings ( <str> ) public void testBase64CannotLowerCase ( ) { try { base64 ( ) . lowerCase ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testBase64AlternatePadding ( ) { BaseEncoding enc = base64 ( ) . withPadChar ( <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testBase64StreamingAlternatePadding ( ) throws IOException { BaseEncoding enc = base64 ( ) . withPadChar ( <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; } public void testBase64OmitPadding ( ) { BaseEncoding enc = base64 ( ) . omitPadding ( ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; testEncodingWithSeparators ( enc , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testBase64StreamingOmitPadding ( ) throws IOException { BaseEncoding enc = base64 ( ) . omitPadding ( ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; testStreamingEncodingWithSeparators ( enc , <str> , <str> ) ; } public void testBase64Offset ( ) { testEncodesWithOffset ( base64 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base64 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base64 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base64 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base64 ( ) , <str> , <int> , <int> , <str> ) ; } public void testBase32 ( ) { testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testBase32Streaming ( ) throws IOException { testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32 ( ) , <str> , <str> ) ; } public void testBase32LenientPadding ( ) { testDecodes ( base32 ( ) , <str> , <str> ) ; testDecodes ( base32 ( ) , <str> , <str> ) ; testDecodes ( base32 ( ) , <str> , <str> ) ; testDecodes ( base32 ( ) , <str> , <str> ) ; testDecodes ( base32 ( ) , <str> , <str> ) ; testDecodes ( base32 ( ) , <str> , <str> ) ; } public void testBase32AlternatePadding ( ) { BaseEncoding enc = base32 ( ) . withPadChar ( <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; testEncodingWithCasing ( enc , <str> , <str> ) ; } public void testBase32InvalidDecodings ( ) { assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; assertFailsToDecode ( base32 ( ) , <str> , <str> ) ; } public void testBase32UpperCaseIsNoOp ( ) { assertSame ( base32 ( ) , base32 ( ) . upperCase ( ) ) ; } public void testBase32Offset ( ) { testEncodesWithOffset ( base32 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base32 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base32 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base32 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base32 ( ) , <str> , <int> , <int> , <str> ) ; } public void testBase32Hex ( ) { testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testBase32HexStreaming ( ) throws IOException { testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; testStreamingEncodingWithCasing ( base32Hex ( ) , <str> , <str> ) ; } public void testBase32HexLenientPadding ( ) { testDecodes ( base32Hex ( ) , <str> , <str> ) ; testDecodes ( base32Hex ( ) , <str> , <str> ) ; testDecodes ( base32Hex ( ) , <str> , <str> ) ; testDecodes ( base32Hex ( ) , <str> , <str> ) ; testDecodes ( base32Hex ( ) , <str> , <str> ) ; testDecodes ( base32Hex ( ) , <str> , <str> ) ; } public void testBase32HexInvalidDecodings ( ) { assertFailsToDecode ( base32Hex ( ) , <str> , <str> ) ; assertFailsToDecode ( base32Hex ( ) , <str> , <str> ) ; assertFailsToDecode ( base32Hex ( ) , <str> ) ; assertFailsToDecode ( base32Hex ( ) , <str> ) ; assertFailsToDecode ( base32Hex ( ) , <str> ) ; assertFailsToDecode ( base32Hex ( ) , <str> ) ; } public void testBase32HexUpperCaseIsNoOp ( ) { assertSame ( base32Hex ( ) , base32Hex ( ) . upperCase ( ) ) ; } public void testBase16 ( ) { testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; testEncodingWithCasing ( base16 ( ) , <str> , <str> ) ; } public void testBase16UpperCaseIsNoOp ( ) { assertSame ( base16 ( ) , base16 ( ) . upperCase ( ) ) ; } public void testBase16InvalidDecodings ( ) { assertFailsToDecode ( base16 ( ) , <str> , <str> ) ; assertFailsToDecode ( base16 ( ) , <str> , <str> ) ; assertFailsToDecode ( base16 ( ) , <str> , <str> ) ; assertFailsToDecode ( base16 ( ) , <str> ) ; assertFailsToDecode ( base16 ( ) , <str> , <str> ) ; } public void testBase16Offset ( ) { testEncodesWithOffset ( base16 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base16 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base16 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base16 ( ) , <str> , <int> , <int> , <str> ) ; testEncodesWithOffset ( base16 ( ) , <str> , <int> , <int> , <str> ) ; } private static void testEncodingWithCasing ( BaseEncoding encoding , String decoded , String encoded ) { testEncodingWithSeparators ( encoding , decoded , encoded ) ; testEncodingWithSeparators ( encoding . upperCase ( ) , decoded , Ascii . toUpperCase ( encoded ) ) ; testEncodingWithSeparators ( encoding . lowerCase ( ) , decoded , Ascii . toLowerCase ( encoded ) ) ; } private static void testEncodingWithSeparators ( BaseEncoding encoding , String decoded , String encoded ) { testEncoding ( encoding , decoded , encoded ) ; for ( int sepLength = <int> ; sepLength < = <int> ; sepLength + + ) { for ( String separator : ImmutableList . of ( <str> , <str> , <str> , <str> ) ) { testEncoding ( encoding . withSeparator ( separator , sepLength ) , decoded , Joiner . on ( separator ) . join ( Splitter . fixedLength ( sepLength ) . split ( encoded ) ) ) ; } } } private static void testEncoding ( BaseEncoding encoding , String decoded , String encoded ) { testEncodes ( encoding , decoded , encoded ) ; testDecodes ( encoding , encoded , decoded ) ; } private static void testEncodes ( BaseEncoding encoding , String decoded , String encoded ) { assertEquals ( encoded , encoding . encode ( getBytes ( decoded ) ) ) ; } private static void testEncodesWithOffset ( BaseEncoding encoding , String decoded , int offset , int len , String encoded ) { assertEquals ( encoded , encoding . encode ( getBytes ( decoded ) , offset , len ) ) ; } private static void testDecodes ( BaseEncoding encoding , String encoded , String decoded ) { assertEquals ( getBytes ( decoded ) , encoding . decode ( encoded ) ) ; } private static void assertFailsToDecode ( BaseEncoding encoding , String cannotDecode ) { assertFailsToDecode ( encoding , cannotDecode , null ) ; } @SuppressWarnings ( <str> ) private static void assertFailsToDecode ( BaseEncoding encoding , String cannotDecode , @Nullable String expectedMessage ) { try { encoding . decode ( cannotDecode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { if ( expectedMessage ! = null ) { assertThat ( expected . getCause ( ) ) . hasMessage ( expectedMessage ) ; } } try { encoding . decodeChecked ( cannotDecode ) ; fail ( <str> ) ; } catch ( DecodingException expected ) { if ( expectedMessage ! = null ) { assertThat ( expected ) . hasMessage ( expectedMessage ) ; } } } @GwtIncompatible ( <str> ) private static void testStreamingEncodingWithCasing ( BaseEncoding encoding , String decoded , String encoded ) throws IOException { testStreamingEncodingWithSeparators ( encoding , decoded , encoded ) ; testStreamingEncodingWithSeparators ( encoding . upperCase ( ) , decoded , Ascii . toUpperCase ( encoded ) ) ; testStreamingEncodingWithSeparators ( encoding . lowerCase ( ) , decoded , Ascii . toLowerCase ( encoded ) ) ; } @GwtIncompatible ( <str> ) private static void testStreamingEncodingWithSeparators ( BaseEncoding encoding , String decoded , String encoded ) throws IOException { testStreamingEncoding ( encoding , decoded , encoded ) ; for ( int sepLength = <int> ; sepLength < = <int> ; sepLength + + ) { for ( String separator : ImmutableList . of ( <str> , <str> , <str> , <str> ) ) { testStreamingEncoding ( encoding . withSeparator ( separator , sepLength ) , decoded , Joiner . on ( separator ) . join ( Splitter . fixedLength ( sepLength ) . split ( encoded ) ) ) ; } } } @GwtIncompatible ( <str> ) private static void testStreamingEncoding ( BaseEncoding encoding , String decoded , String encoded ) throws IOException { testStreamingEncodes ( encoding , decoded , encoded ) ; testStreamingDecodes ( encoding , encoded , decoded ) ; } @GwtIncompatible ( <str> ) private static void testStreamingEncodes ( BaseEncoding encoding , String decoded , String encoded ) throws IOException { StringWriter writer = new StringWriter ( ) ; OutputStream encodingStream = encoding . encodingStream ( writer ) ; encodingStream . write ( getBytes ( decoded ) ) ; encodingStream . close ( ) ; assertEquals ( encoded , writer . toString ( ) ) ; } @GwtIncompatible ( <str> ) private static void testStreamingDecodes ( BaseEncoding encoding , String encoded , String decoded ) throws IOException { byte [ ] bytes = getBytes ( decoded ) ; InputStream decodingStream = encoding . decodingStream ( new StringReader ( encoded ) ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { assertEquals ( bytes [ i ] & <hex> , decodingStream . read ( ) ) ; } assertEquals ( - <int> , decodingStream . read ( ) ) ; decodingStream . close ( ) ; } private static byte [ ] getBytes ( String decoded ) { try { return decoded . getBytes ( <str> ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } } public void testToString ( ) { assertEquals ( <str> , BaseEncoding . base64 ( ) . toString ( ) ) ; assertEquals ( <str> , BaseEncoding . base32Hex ( ) . omitPadding ( ) . toString ( ) ) ; assertEquals ( <str> , BaseEncoding . base32 ( ) . lowerCase ( ) . withPadChar ( <str> ) . toString ( ) ) ; assertEquals ( <str> , BaseEncoding . base16 ( ) . withSeparator ( <str> , <int> ) . toString ( ) ) ; } } 
