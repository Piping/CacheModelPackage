package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteCache ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . TimeUtils ; public class SpriteCacheTest extends GdxTest implements InputProcessor { int SPRITES = <int> / <int> ; long startTime = TimeUtils . nanoTime ( ) ; int frames = <int> ; Texture texture ; Texture texture2 ; SpriteCache spriteCache ; int normalCacheID , spriteCacheID ; int renderMethod = <int> ; private float [ ] sprites ; private float [ ] sprites2 ; @Override public void render ( ) { if ( renderMethod = = <int> ) renderNormal ( ) ; ; if ( renderMethod = = <int> ) renderSprites ( ) ; } private void renderNormal ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float begin = <int> ; float end = <int> ; float draw1 = <int> ; long start = TimeUtils . nanoTime ( ) ; spriteCache . begin ( ) ; begin = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteCache . draw ( normalCacheID ) ; draw1 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteCache . end ( ) ; end = ( TimeUtils . nanoTime ( ) - start ) / <float> ; if ( TimeUtils . nanoTime ( ) - startTime > <int> ) { frames = <int> ; startTime = TimeUtils . nanoTime ( ) ; } frames + + ; } private void renderSprites ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float begin = <int> ; float end = <int> ; float draw1 = <int> ; float draw2 = <int> ; float drawText = <int> ; long start = TimeUtils . nanoTime ( ) ; spriteCache . begin ( ) ; begin = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteCache . draw ( spriteCacheID ) ; draw1 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteCache . end ( ) ; end = ( TimeUtils . nanoTime ( ) - start ) / <float> ; if ( TimeUtils . nanoTime ( ) - startTime > <int> ) { frames = <int> ; startTime = TimeUtils . nanoTime ( ) ; } frames + + ; } @Override public void create ( ) { spriteCache = new SpriteCache ( <int> , true ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; texture . setFilter ( TextureFilter . Linear , TextureFilter . Linear ) ; Pixmap pixmap = new Pixmap ( <int> , <int> , Format . RGBA8888 ) ; pixmap . setColor ( <int> , <int> , <int> , <float> ) ; pixmap . fill ( ) ; texture2 = new Texture ( pixmap ) ; pixmap . dispose ( ) ; sprites = new float [ SPRITES * <int> ] ; sprites2 = new float [ SPRITES * <int> ] ; Sprite [ ] sprites3 = new Sprite [ SPRITES * <int> ] ; for ( int i = <int> ; i < sprites . length ; i + = <int> ) { sprites [ i ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; sprites [ i + <int> ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites2 [ i ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; sprites2 [ i + <int> ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; } for ( int i = <int> ; i < SPRITES * <int> ; i + + ) { int x = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; int y = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; if ( i > = SPRITES ) sprites3 [ i ] = new Sprite ( texture2 , <int> , <int> ) ; else sprites3 [ i ] = new Sprite ( texture , <int> , <int> ) ; sprites3 [ i ] . setPosition ( x , y ) ; sprites3 [ i ] . setOrigin ( <int> , <int> ) ; } float scale = <int> ; float angle = <int> ; spriteCache . beginCache ( ) ; for ( int i = <int> ; i < sprites2 . length ; i + = <int> ) spriteCache . add ( texture2 , sprites2 [ i ] , sprites2 [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; for ( int i = <int> ; i < sprites . length ; i + = <int> ) spriteCache . add ( texture , sprites [ i ] , sprites [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; normalCacheID = spriteCache . endCache ( ) ; angle = - <int> ; spriteCache . beginCache ( ) ; for ( int i = SPRITES ; i < SPRITES < < <int> ; i + + ) { sprites3 [ i ] . setRotation ( angle ) ; sprites3 [ i ] . setScale ( scale ) ; spriteCache . add ( sprites3 [ i ] ) ; } for ( int i = <int> ; i < SPRITES ; i + + ) { sprites3 [ i ] . setRotation ( angle ) ; sprites3 [ i ] . setScale ( scale ) ; spriteCache . add ( sprites3 [ i ] ) ; } spriteCacheID = spriteCache . endCache ( ) ; Gdx . input . setInputProcessor ( this ) ; } @Override public boolean keyDown ( int keycode ) { if ( keycode ! = Input . Keys . SPACE ) return false ; float scale = MathUtils . random ( <float> , <float> ) ; float angle = MathUtils . random ( <int> , <int> ) ; spriteCache . beginCache ( normalCacheID ) ; for ( int i = <int> ; i < sprites2 . length ; i + = <int> ) spriteCache . add ( texture2 , sprites2 [ i ] , sprites2 [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; for ( int i = <int> ; i < sprites . length ; i + = <int> ) spriteCache . add ( texture , sprites [ i ] , sprites [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; spriteCache . endCache ( ) ; return false ; } @Override public boolean touchUp ( int x , int y , int pointer , int button ) { renderMethod = ( renderMethod + <int> ) % <int> ; return false ; } @Override public void dispose ( ) { texture . dispose ( ) ; texture2 . dispose ( ) ; spriteCache . dispose ( ) ; } }