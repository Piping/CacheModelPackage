package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . PixmapPacker ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; public class PixmapPackerTest extends GdxTest { OrthographicCamera camera ; SpriteBatch batch ; ShapeRenderer shapeRenderer ; TextureAtlas atlas ; int pageToShow = <int> ; Array < TextureRegion > textureRegions ; @Override public void create ( ) { batch = new SpriteBatch ( ) ; shapeRenderer = new ShapeRenderer ( ) ; camera = new OrthographicCamera ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; camera . position . set ( Gdx . graphics . getWidth ( ) / <int> , Gdx . graphics . getHeight ( ) / <int> , <int> ) ; camera . update ( ) ; Pixmap pixmap1 = new Pixmap ( Gdx . files . internal ( <str> ) ) ; Pixmap pixmap2 = new Pixmap ( Gdx . files . internal ( <str> ) ) ; Pixmap pixmap3 = new Pixmap ( Gdx . files . internal ( <str> ) ) ; PixmapPacker packer = new PixmapPacker ( <int> , <int> , Format . RGBA8888 , <int> , false ) ; for ( int count = <int> ; count < = <int> ; + + count ) { packer . pack ( <str> + count , pixmap1 ) ; packer . pack ( <str> + count , pixmap2 ) ; packer . pack ( <str> + count , pixmap3 ) ; } atlas = packer . generateTextureAtlas ( TextureFilter . Nearest , TextureFilter . Nearest , false ) ; Gdx . app . log ( <str> , <str> + atlas . getTextures ( ) . size ) ; packer . setPackToTexture ( true ) ; for ( int count = <int> ; count < = <int> ; + + count ) { packer . pack ( <str> + count , pixmap1 ) ; packer . pack ( <str> + count , pixmap2 ) ; packer . pack ( <str> + count , pixmap3 ) ; } pixmap1 . dispose ( ) ; pixmap2 . dispose ( ) ; pixmap3 . dispose ( ) ; packer . updateTextureAtlas ( atlas , TextureFilter . Nearest , TextureFilter . Nearest , false ) ; textureRegions = new Array < TextureRegion > ( ) ; packer . updateTextureRegions ( textureRegions , TextureFilter . Nearest , TextureFilter . Nearest , false ) ; Gdx . app . log ( <str> , <str> + atlas . getTextures ( ) . size ) ; Gdx . input . setInputProcessor ( new InputAdapter ( ) { @Override public boolean keyDown ( int keycode ) { if ( keycode > = Input . Keys . NUM_0 & & keycode < = Input . Keys . NUM_9 ) { int number = keycode - Input . Keys . NUM_0 ; if ( number < textureRegions . size ) { pageToShow = number ; } } return super . keyDown ( keycode ) ; } } ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; int size = Math . min ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; batch . begin ( ) ; batch . draw ( textureRegions . get ( pageToShow ) , <int> , <int> , size , size ) ; batch . end ( ) ; shapeRenderer . begin ( ShapeRenderer . ShapeType . Line ) ; shapeRenderer . setColor ( Color . GREEN ) ; shapeRenderer . rect ( <int> , <int> , size , size ) ; shapeRenderer . end ( ) ; } @Override public void dispose ( ) { atlas . dispose ( ) ; } }