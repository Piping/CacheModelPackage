package org . elasticsearch . action . admin . cluster . settings ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeAction ; import org . elasticsearch . cluster . AckedClusterStateUpdateTask ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . settings . ClusterDynamicSettings ; import org . elasticsearch . cluster . settings . DynamicSettings ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . Map ; import static org . elasticsearch . cluster . ClusterState . builder ; public class TransportClusterUpdateSettingsAction extends TransportMasterNodeAction < ClusterUpdateSettingsRequest , ClusterUpdateSettingsResponse > { private final AllocationService allocationService ; private final DynamicSettings dynamicSettings ; @Inject public TransportClusterUpdateSettingsAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , AllocationService allocationService , @ClusterDynamicSettings DynamicSettings dynamicSettings , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , ClusterUpdateSettingsAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , ClusterUpdateSettingsRequest : : new ) ; this . allocationService = allocationService ; this . dynamicSettings = dynamicSettings ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected ClusterBlockException checkBlock ( ClusterUpdateSettingsRequest request , ClusterState state ) { if ( ( request . transientSettings ( ) . getAsMap ( ) . isEmpty ( ) & & request . persistentSettings ( ) . getAsMap ( ) . size ( ) = = <int> & & request . persistentSettings ( ) . get ( MetaData . SETTING_READ_ONLY ) ! = null ) | | request . persistentSettings ( ) . getAsMap ( ) . isEmpty ( ) & & request . transientSettings ( ) . getAsMap ( ) . size ( ) = = <int> & & request . transientSettings ( ) . get ( MetaData . SETTING_READ_ONLY ) ! = null ) { return null ; } return state . blocks ( ) . globalBlockedException ( ClusterBlockLevel . METADATA_WRITE ) ; } @Override protected ClusterUpdateSettingsResponse newResponse ( ) { return new ClusterUpdateSettingsResponse ( ) ; } @Override protected void masterOperation ( final ClusterUpdateSettingsRequest request , final ClusterState state , final ActionListener < ClusterUpdateSettingsResponse > listener ) { final Settings . Builder transientUpdates = Settings . settingsBuilder ( ) ; final Settings . Builder persistentUpdates = Settings . settingsBuilder ( ) ; clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < ClusterUpdateSettingsResponse > ( Priority . IMMEDIATE , request , listener ) { private volatile boolean changed = false ; @Override protected ClusterUpdateSettingsResponse newResponse ( boolean acknowledged ) { return new ClusterUpdateSettingsResponse ( acknowledged , transientUpdates . build ( ) , persistentUpdates . build ( ) ) ; } @Override public void onAllNodesAcked ( @Nullable Throwable t ) { if ( changed ) { reroute ( true ) ; } else { super . onAllNodesAcked ( t ) ; } } @Override public void onAckTimeout ( ) { if ( changed ) { reroute ( false ) ; } else { super . onAckTimeout ( ) ; } } private void reroute ( final boolean updateSettingsAcked ) { if ( ! clusterService . state ( ) . nodes ( ) . localNodeMaster ( ) ) { logger . debug ( <str> ) ; listener . onResponse ( new ClusterUpdateSettingsResponse ( updateSettingsAcked , transientUpdates . build ( ) , persistentUpdates . build ( ) ) ) ; return ; } clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < ClusterUpdateSettingsResponse > ( Priority . URGENT , request , listener ) { @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return updateSettingsAcked ; } @Override protected ClusterUpdateSettingsResponse newResponse ( boolean acknowledged ) { return new ClusterUpdateSettingsResponse ( updateSettingsAcked & & acknowledged , transientUpdates . build ( ) , persistentUpdates . build ( ) ) ; } @Override public void onNoLongerMaster ( String source ) { logger . debug ( <str> ) ; listener . onResponse ( new ClusterUpdateSettingsResponse ( updateSettingsAcked , transientUpdates . build ( ) , persistentUpdates . build ( ) ) ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . debug ( <str> , t , source ) ; listener . onFailure ( new ElasticsearchException ( <str> , t ) ) ; } @Override public ClusterState execute ( final ClusterState currentState ) { RoutingAllocation . Result routingResult = allocationService . reroute ( currentState , <str> ) ; if ( ! routingResult . changed ( ) ) { return currentState ; } return ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; } } ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . debug ( <str> , t , source ) ; super . onFailure ( source , t ) ; } @Override public ClusterState execute ( final ClusterState currentState ) { Settings . Builder transientSettings = Settings . settingsBuilder ( ) ; transientSettings . put ( currentState . metaData ( ) . transientSettings ( ) ) ; for ( Map . Entry < String , String > entry : request . transientSettings ( ) . getAsMap ( ) . entrySet ( ) ) { if ( dynamicSettings . isDynamicOrLoggingSetting ( entry . getKey ( ) ) ) { String error = dynamicSettings . validateDynamicSetting ( entry . getKey ( ) , entry . getValue ( ) , clusterService . state ( ) ) ; if ( error = = null ) { transientSettings . put ( entry . getKey ( ) , entry . getValue ( ) ) ; transientUpdates . put ( entry . getKey ( ) , entry . getValue ( ) ) ; changed = true ; } else { logger . warn ( <str> , entry . getKey ( ) , error ) ; } } else { logger . warn ( <str> , entry . getKey ( ) ) ; } } Settings . Builder persistentSettings = Settings . settingsBuilder ( ) ; persistentSettings . put ( currentState . metaData ( ) . persistentSettings ( ) ) ; for ( Map . Entry < String , String > entry : request . persistentSettings ( ) . getAsMap ( ) . entrySet ( ) ) { if ( dynamicSettings . isDynamicOrLoggingSetting ( entry . getKey ( ) ) ) { String error = dynamicSettings . validateDynamicSetting ( entry . getKey ( ) , entry . getValue ( ) , clusterService . state ( ) ) ; if ( error = = null ) { persistentSettings . put ( entry . getKey ( ) , entry . getValue ( ) ) ; persistentUpdates . put ( entry . getKey ( ) , entry . getValue ( ) ) ; changed = true ; } else { logger . warn ( <str> , entry . getKey ( ) , error ) ; } } else { logger . warn ( <str> , entry . getKey ( ) ) ; } } if ( ! changed ) { return currentState ; } MetaData . Builder metaData = MetaData . builder ( currentState . metaData ( ) ) . persistentSettings ( persistentSettings . build ( ) ) . transientSettings ( transientSettings . build ( ) ) ; ClusterBlocks . Builder blocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) ; boolean updatedReadOnly = metaData . persistentSettings ( ) . getAsBoolean ( MetaData . SETTING_READ_ONLY , false ) | | metaData . transientSettings ( ) . getAsBoolean ( MetaData . SETTING_READ_ONLY , false ) ; if ( updatedReadOnly ) { blocks . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ; } else { blocks . removeGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ; } return builder ( currentState ) . metaData ( metaData ) . blocks ( blocks ) . build ( ) ; } } ) ; } } 
