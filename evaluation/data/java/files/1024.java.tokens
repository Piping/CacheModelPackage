package org . elasticsearch . bwcompat ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . analyze . AnalyzeResponse ; import org . elasticsearch . indices . analysis . PreBuiltAnalyzers ; import org . elasticsearch . test . ESBackcompatTestCase ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . ExecutionException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; @ESIntegTestCase.ClusterScope ( numDataNodes = <int> , scope = ESIntegTestCase . Scope . SUITE , numClientNodes = <int> , transportClientRatio = <float> ) public class BasicAnalysisBackwardCompatibilityIT extends ESBackcompatTestCase { final static Pattern complexUnicodeChars = Pattern . compile ( <str> ) ; public void testAnalyzerTokensAfterUpgrade ( ) throws IOException , ExecutionException , InterruptedException { int numFields = randomIntBetween ( PreBuiltAnalyzers . values ( ) . length , PreBuiltAnalyzers . values ( ) . length * <int> ) ; String [ ] fields = new String [ numFields * <int> ] ; int fieldId = <int> ; for ( int i = <int> ; i < fields . length ; i + + ) { fields [ i + + ] = <str> + fieldId + + ; String analyzer = randomAnalyzer ( ) ; fields [ i ] = <str> + analyzer ; } assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , ( Object [ ] ) fields ) . setSettings ( indexSettings ( ) ) ) ; ensureYellow ( ) ; InputOutput [ ] inout = new InputOutput [ numFields ] ; for ( int i = <int> ; i < numFields ; i + + ) { String input ; Matcher matcher ; do { input = TestUtil . randomAnalysisString ( getRandom ( ) , <int> , false ) ; matcher = complexUnicodeChars . matcher ( input ) ; } while ( matcher . find ( ) ) ; AnalyzeResponse test = client ( ) . admin ( ) . indices ( ) . prepareAnalyze ( <str> , input ) . setField ( <str> + i ) . get ( ) ; inout [ i ] = new InputOutput ( test , input , <str> + i ) ; } logClusterState ( ) ; boolean upgraded ; do { logClusterState ( ) ; upgraded = backwardsCluster ( ) . upgradeOneNode ( ) ; ensureYellow ( ) ; } while ( upgraded ) ; for ( int i = <int> ; i < inout . length ; i + + ) { InputOutput inputOutput = inout [ i ] ; AnalyzeResponse test = client ( ) . admin ( ) . indices ( ) . prepareAnalyze ( <str> , inputOutput . input ) . setField ( inputOutput . field ) . get ( ) ; List < AnalyzeResponse . AnalyzeToken > tokens = test . getTokens ( ) ; List < AnalyzeResponse . AnalyzeToken > expectedTokens = inputOutput . response . getTokens ( ) ; assertThat ( <str> + fields [ i * <int> ] + <str> + fields [ i * <int> + <int> ] + <str> + BaseTokenStreamTestCase . escape ( inputOutput . input ) , expectedTokens . size ( ) , equalTo ( tokens . size ( ) ) ) ; for ( int j = <int> ; j < tokens . size ( ) ; j + + ) { String msg = <str> + expectedTokens . get ( j ) . getTerm ( ) + <str> + fields [ i * <int> ] + <str> + fields [ i * <int> + <int> ] + <str> + BaseTokenStreamTestCase . escape ( inputOutput . input ) ; assertThat ( msg , BaseTokenStreamTestCase . escape ( expectedTokens . get ( j ) . getTerm ( ) ) , equalTo ( BaseTokenStreamTestCase . escape ( tokens . get ( j ) . getTerm ( ) ) ) ) ; assertThat ( msg , expectedTokens . get ( j ) . getPosition ( ) , equalTo ( tokens . get ( j ) . getPosition ( ) ) ) ; assertThat ( msg , expectedTokens . get ( j ) . getStartOffset ( ) , equalTo ( tokens . get ( j ) . getStartOffset ( ) ) ) ; assertThat ( msg , expectedTokens . get ( j ) . getEndOffset ( ) , equalTo ( tokens . get ( j ) . getEndOffset ( ) ) ) ; assertThat ( msg , expectedTokens . get ( j ) . getType ( ) , equalTo ( tokens . get ( j ) . getType ( ) ) ) ; } } } private String randomAnalyzer ( ) { while ( true ) { PreBuiltAnalyzers preBuiltAnalyzers = RandomPicks . randomFrom ( getRandom ( ) , PreBuiltAnalyzers . values ( ) ) ; if ( preBuiltAnalyzers = = PreBuiltAnalyzers . SORANI & & compatibilityVersion ( ) . before ( Version . V_1_3_0 ) ) { continue ; } if ( preBuiltAnalyzers = = PreBuiltAnalyzers . LITHUANIAN & & compatibilityVersion ( ) . before ( Version . V_2_1_0 ) ) { continue ; } return preBuiltAnalyzers . name ( ) . toLowerCase ( Locale . ROOT ) ; } } private static final class InputOutput { final AnalyzeResponse response ; final String input ; final String field ; public InputOutput ( AnalyzeResponse response , String input , String field ) { this . response = response ; this . input = input ; this . field = field ; } } } 
