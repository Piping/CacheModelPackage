package com . badlogic . gdx . backends . lwjgl . audio ; import java . io . EOFException ; import java . io . FilterInputStream ; import java . io . IOException ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class Wav { static public class Music extends OpenALMusic { private WavInputStream input ; public Music ( OpenALAudio audio , FileHandle file ) { super ( audio , file ) ; input = new WavInputStream ( file ) ; if ( audio . noDevice ) return ; setup ( input . channels , input . sampleRate ) ; } public int read ( byte [ ] buffer ) { if ( input = = null ) { input = new WavInputStream ( file ) ; setup ( input . channels , input . sampleRate ) ; } try { return input . read ( buffer ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + file , ex ) ; } } public void reset ( ) { StreamUtils . closeQuietly ( input ) ; input = null ; } } static public class Sound extends OpenALSound { public Sound ( OpenALAudio audio , FileHandle file ) { super ( audio ) ; if ( audio . noDevice ) return ; WavInputStream input = null ; try { input = new WavInputStream ( file ) ; setup ( StreamUtils . copyStreamToByteArray ( input , input . dataRemaining ) , input . channels , input . sampleRate ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + file , ex ) ; } finally { StreamUtils . closeQuietly ( input ) ; } } } static private class WavInputStream extends FilterInputStream { int channels , sampleRate , dataRemaining ; WavInputStream ( FileHandle file ) { super ( file . read ( ) ) ; try { if ( read ( ) ! = <str> | | read ( ) ! = <str> | | read ( ) ! = <str> | | read ( ) ! = <str> ) throw new GdxRuntimeException ( <str> + file ) ; skipFully ( <int> ) ; if ( read ( ) ! = <str> | | read ( ) ! = <str> | | read ( ) ! = <str> | | read ( ) ! = <str> ) throw new GdxRuntimeException ( <str> + file ) ; int fmtChunkLength = seekToChunk ( <str> , <str> , <str> , <str> ) ; int type = read ( ) & <hex> | ( read ( ) & <hex> ) < < <int> ; if ( type ! = <int> ) throw new GdxRuntimeException ( <str> + type ) ; channels = read ( ) & <hex> | ( read ( ) & <hex> ) < < <int> ; if ( channels ! = <int> & & channels ! = <int> ) throw new GdxRuntimeException ( <str> + channels ) ; sampleRate = read ( ) & <hex> | ( read ( ) & <hex> ) < < <int> | ( read ( ) & <hex> ) < < <int> | ( read ( ) & <hex> ) < < <int> ; skipFully ( <int> ) ; int bitsPerSample = read ( ) & <hex> | ( read ( ) & <hex> ) < < <int> ; if ( bitsPerSample ! = <int> ) throw new GdxRuntimeException ( <str> + bitsPerSample ) ; skipFully ( fmtChunkLength - <int> ) ; dataRemaining = seekToChunk ( <str> , <str> , <str> , <str> ) ; } catch ( Throwable ex ) { StreamUtils . closeQuietly ( this ) ; throw new GdxRuntimeException ( <str> + file , ex ) ; } } private int seekToChunk ( char c1 , char c2 , char c3 , char c4 ) throws IOException { while ( true ) { boolean found = read ( ) = = c1 ; found & = read ( ) = = c2 ; found & = read ( ) = = c3 ; found & = read ( ) = = c4 ; int chunkLength = read ( ) & <hex> | ( read ( ) & <hex> ) < < <int> | ( read ( ) & <hex> ) < < <int> | ( read ( ) & <hex> ) < < <int> ; if ( chunkLength = = - <int> ) throw new IOException ( <str> + c1 + c2 + c3 + c4 ) ; if ( found ) return chunkLength ; skipFully ( chunkLength ) ; } } private void skipFully ( int count ) throws IOException { while ( count > <int> ) { long skipped = in . skip ( count ) ; if ( skipped < = <int> ) throw new EOFException ( <str> ) ; count - = skipped ; } } public int read ( byte [ ] buffer ) throws IOException { if ( dataRemaining = = <int> ) return - <int> ; int length = Math . min ( super . read ( buffer ) , dataRemaining ) ; if ( length = = - <int> ) return - <int> ; dataRemaining - = length ; return length ; } } }