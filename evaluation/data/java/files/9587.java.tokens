package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . environment . PointLight ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; public class LightsTest extends ModelTest { DirectionalLight dirLight ; PointLight pointLight ; Model lightModel ; Renderable pLight ; Vector3 center = new Vector3 ( ) , transformedCenter = new Vector3 ( ) , tmpV = new Vector3 ( ) ; float radius = <int> f ; @Override public void create ( ) { super . create ( ) ; environment . clear ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; environment . add ( dirLight = new DirectionalLight ( ) . set ( <float> , <float> , <float> , - <int> f , - <int> f , - <float> ) ) ; environment . add ( pointLight = new PointLight ( ) . set ( <float> , <float> , <float> , <int> f , <int> f , <int> f , <int> f ) ) ; ModelBuilder mb = new ModelBuilder ( ) ; lightModel = mb . createSphere ( <int> , <int> , <int> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( <int> , <int> , <int> , <int> ) ) , Usage . Position ) ; lightModel . nodes . get ( <int> ) . parts . get ( <int> ) . setRenderable ( pLight = new Renderable ( ) ) ; } @Override protected void onLoaded ( ) { super . onLoaded ( ) ; BoundingBox bounds = instances . get ( <int> ) . calculateBoundingBox ( new BoundingBox ( ) ) ; bounds . getCenter ( center ) ; radius = bounds . getDimensions ( tmpV ) . len ( ) * . <int> f ; pointLight . position . set ( <int> , radius , <int> ) . add ( transformedCenter . set ( center ) . mul ( transform ) ) ; pointLight . intensity = radius * radius ; ( ( ColorAttribute ) pLight . material . get ( ColorAttribute . Diffuse ) ) . color . set ( pointLight . color ) ; final float s = <float> * radius ; pLight . worldTransform . setToScaling ( s , s , s ) ; } @Override protected void render ( ModelBatch batch , Array < ModelInstance > instances ) { final float delta = Gdx . graphics . getDeltaTime ( ) ; dirLight . direction . rotate ( Vector3 . X , delta * <int> f ) ; dirLight . direction . rotate ( Vector3 . Y , delta * <int> f ) ; dirLight . direction . rotate ( Vector3 . Z , delta * <int> f ) ; pointLight . position . sub ( transformedCenter ) ; pointLight . position . rotate ( Vector3 . X , delta * <int> f ) ; pointLight . position . rotate ( Vector3 . Y , delta * <int> f ) ; pointLight . position . rotate ( Vector3 . Z , delta * <int> f ) ; pointLight . position . add ( transformedCenter . set ( center ) . mul ( transform ) ) ; pLight . worldTransform . setTranslation ( pointLight . position ) ; batch . render ( pLight ) ; super . render ( batch , instances ) ; } @Override public void dispose ( ) { lightModel . dispose ( ) ; super . dispose ( ) ; } }