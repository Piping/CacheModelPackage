package rx . internal . operators ; import java . util . concurrent . atomic . AtomicReference ; import rx . Observable ; import rx . Observable . Operator ; import rx . Subscriber ; import rx . observers . SerializedSubscriber ; public final class OperatorSampleWithObservable < T , U > implements Operator < T , T > { final Observable < U > sampler ; static final Object EMPTY_TOKEN = new Object ( ) ; public OperatorSampleWithObservable ( Observable < U > sampler ) { this . sampler = sampler ; } @Override public Subscriber < ? super T > call ( Subscriber < ? super T > child ) { final SerializedSubscriber < T > s = new SerializedSubscriber < T > ( child ) ; final AtomicReference < Object > value = new AtomicReference < Object > ( EMPTY_TOKEN ) ; Subscriber < U > samplerSub = new Subscriber < U > ( child ) { @Override public void onNext ( U t ) { Object localValue = value . getAndSet ( EMPTY_TOKEN ) ; if ( localValue ! = EMPTY_TOKEN ) { @SuppressWarnings ( <str> ) T v = ( T ) localValue ; s . onNext ( v ) ; } } @Override public void onError ( Throwable e ) { s . onError ( e ) ; unsubscribe ( ) ; } @Override public void onCompleted ( ) { s . onCompleted ( ) ; unsubscribe ( ) ; } } ; Subscriber < T > result = new Subscriber < T > ( child ) { @Override public void onNext ( T t ) { value . set ( t ) ; } @Override public void onError ( Throwable e ) { s . onError ( e ) ; unsubscribe ( ) ; } @Override public void onCompleted ( ) { s . onCompleted ( ) ; unsubscribe ( ) ; } } ; sampler . unsafeSubscribe ( samplerSub ) ; return result ; } } 
