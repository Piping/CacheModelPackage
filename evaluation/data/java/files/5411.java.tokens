package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . util . ReferenceCountUtil ; import java . util . ArrayDeque ; import java . util . Iterator ; import java . util . Map ; import java . util . Queue ; import java . util . TreeMap ; import static io . netty . handler . codec . http2 . Http2CodecUtil . SMALLEST_MAX_CONCURRENT_STREAMS ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder { public static final class Http2ChannelClosedException extends Http2Exception { private static final long serialVersionUID = <int> ; public Http2ChannelClosedException ( ) { super ( Http2Error . REFUSED_STREAM , <str> ) ; } } public static final class Http2GoAwayException extends Http2Exception { private static final long serialVersionUID = <int> ; private final int lastStreamId ; private final long errorCode ; private final byte [ ] debugData ; public Http2GoAwayException ( int lastStreamId , long errorCode , byte [ ] debugData ) { super ( Http2Error . STREAM_CLOSED ) ; this . lastStreamId = lastStreamId ; this . errorCode = errorCode ; this . debugData = debugData ; } public int lastStreamId ( ) { return lastStreamId ; } public long errorCode ( ) { return errorCode ; } public byte [ ] debugData ( ) { return debugData ; } } private final TreeMap < Integer , PendingStream > pendingStreams = new TreeMap < Integer , PendingStream > ( ) ; private int maxConcurrentStreams ; private boolean closed ; public StreamBufferingEncoder ( Http2ConnectionEncoder delegate ) { this ( delegate , SMALLEST_MAX_CONCURRENT_STREAMS ) ; } public StreamBufferingEncoder ( Http2ConnectionEncoder delegate , int initialMaxConcurrentStreams ) { super ( delegate ) ; this . maxConcurrentStreams = initialMaxConcurrentStreams ; connection ( ) . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onGoAwayReceived ( int lastStreamId , long errorCode , ByteBuf debugData ) { cancelGoAwayStreams ( lastStreamId , errorCode , debugData ) ; } @Override public void onStreamClosed ( Http2Stream stream ) { tryCreatePendingStreams ( ) ; } } ) ; } public int numBufferedStreams ( ) { return pendingStreams . size ( ) ; } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream , ChannelPromise promise ) { return writeHeaders ( ctx , streamId , headers , <int> , Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT , false , padding , endStream , promise ) ; } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream , ChannelPromise promise ) { if ( closed ) { return promise . setFailure ( new Http2ChannelClosedException ( ) ) ; } if ( isExistingStream ( streamId ) | | connection ( ) . goAwayReceived ( ) ) { return super . writeHeaders ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ; } if ( canCreateStream ( ) ) { return super . writeHeaders ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ; } PendingStream pendingStream = pendingStreams . get ( streamId ) ; if ( pendingStream = = null ) { pendingStream = new PendingStream ( ctx , streamId ) ; pendingStreams . put ( streamId , pendingStream ) ; } pendingStream . frames . add ( new HeadersFrame ( headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ) ; return promise ; } @Override public ChannelFuture writeRstStream ( ChannelHandlerContext ctx , int streamId , long errorCode , ChannelPromise promise ) { if ( isExistingStream ( streamId ) ) { return super . writeRstStream ( ctx , streamId , errorCode , promise ) ; } PendingStream stream = pendingStreams . remove ( streamId ) ; if ( stream ! = null ) { stream . close ( null ) ; promise . setSuccess ( ) ; } else { promise . setFailure ( connectionError ( PROTOCOL_ERROR , <str> , streamId ) ) ; } return promise ; } @Override public ChannelFuture writeData ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream , ChannelPromise promise ) { if ( isExistingStream ( streamId ) ) { return super . writeData ( ctx , streamId , data , padding , endOfStream , promise ) ; } PendingStream pendingStream = pendingStreams . get ( streamId ) ; if ( pendingStream ! = null ) { pendingStream . frames . add ( new DataFrame ( data , padding , endOfStream , promise ) ) ; } else { ReferenceCountUtil . safeRelease ( data ) ; promise . setFailure ( connectionError ( PROTOCOL_ERROR , <str> , streamId ) ) ; } return promise ; } @Override public void remoteSettings ( Http2Settings settings ) throws Http2Exception { super . remoteSettings ( settings ) ; maxConcurrentStreams = connection ( ) . local ( ) . maxActiveStreams ( ) ; tryCreatePendingStreams ( ) ; } @Override public void close ( ) { try { if ( ! closed ) { closed = true ; Http2ChannelClosedException e = new Http2ChannelClosedException ( ) ; while ( ! pendingStreams . isEmpty ( ) ) { PendingStream stream = pendingStreams . pollFirstEntry ( ) . getValue ( ) ; stream . close ( e ) ; } } } finally { super . close ( ) ; } } private void tryCreatePendingStreams ( ) { while ( ! pendingStreams . isEmpty ( ) & & canCreateStream ( ) ) { Map . Entry < Integer , PendingStream > entry = pendingStreams . pollFirstEntry ( ) ; PendingStream pendingStream = entry . getValue ( ) ; pendingStream . sendFrames ( ) ; } } private void cancelGoAwayStreams ( int lastStreamId , long errorCode , ByteBuf debugData ) { Iterator < PendingStream > iter = pendingStreams . values ( ) . iterator ( ) ; Exception e = new Http2GoAwayException ( lastStreamId , errorCode , ByteBufUtil . getBytes ( debugData ) ) ; while ( iter . hasNext ( ) ) { PendingStream stream = iter . next ( ) ; if ( stream . streamId > lastStreamId ) { iter . remove ( ) ; stream . close ( e ) ; } } } private boolean canCreateStream ( ) { return connection ( ) . local ( ) . numActiveStreams ( ) < maxConcurrentStreams ; } private boolean isExistingStream ( int streamId ) { return streamId < = connection ( ) . local ( ) . lastStreamCreated ( ) ; } private static final class PendingStream { final ChannelHandlerContext ctx ; final int streamId ; final Queue < Frame > frames = new ArrayDeque < Frame > ( <int> ) ; PendingStream ( ChannelHandlerContext ctx , int streamId ) { this . ctx = ctx ; this . streamId = streamId ; } void sendFrames ( ) { for ( Frame frame : frames ) { frame . send ( ctx , streamId ) ; } } void close ( Throwable t ) { for ( Frame frame : frames ) { frame . release ( t ) ; } } } private abstract static class Frame { final ChannelPromise promise ; Frame ( ChannelPromise promise ) { this . promise = promise ; } void release ( Throwable t ) { if ( t = = null ) { promise . setSuccess ( ) ; } else { promise . setFailure ( t ) ; } } abstract void send ( ChannelHandlerContext ctx , int streamId ) ; } private final class HeadersFrame extends Frame { final Http2Headers headers ; final int streamDependency ; final short weight ; final boolean exclusive ; final int padding ; final boolean endOfStream ; HeadersFrame ( Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream , ChannelPromise promise ) { super ( promise ) ; this . headers = headers ; this . streamDependency = streamDependency ; this . weight = weight ; this . exclusive = exclusive ; this . padding = padding ; this . endOfStream = endOfStream ; } @Override void send ( ChannelHandlerContext ctx , int streamId ) { writeHeaders ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ; } } private final class DataFrame extends Frame { final ByteBuf data ; final int padding ; final boolean endOfStream ; DataFrame ( ByteBuf data , int padding , boolean endOfStream , ChannelPromise promise ) { super ( promise ) ; this . data = data ; this . padding = padding ; this . endOfStream = endOfStream ; } @Override void release ( Throwable t ) { super . release ( t ) ; ReferenceCountUtil . safeRelease ( data ) ; } @Override void send ( ChannelHandlerContext ctx , int streamId ) { writeData ( ctx , streamId , data , padding , endOfStream , promise ) ; } } }