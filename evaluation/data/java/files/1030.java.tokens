package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . ObjectArrays . checkElementsNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import java . io . InvalidObjectException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; import java . util . NavigableSet ; import java . util . SortedSet ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) @SuppressWarnings ( <str> ) public abstract class ImmutableSortedSet < E > extends ImmutableSortedSetFauxverideShim < E > implements NavigableSet < E > , SortedIterable < E > { static < E > RegularImmutableSortedSet < E > emptySet ( Comparator < ? super E > comparator ) { if ( Ordering . natural ( ) . equals ( comparator ) ) { return ( RegularImmutableSortedSet < E > ) RegularImmutableSortedSet . NATURAL_EMPTY_SET ; } else { return new RegularImmutableSortedSet < E > ( ImmutableList . < E > of ( ) , comparator ) ; } } public static < E > ImmutableSortedSet < E > of ( ) { return ( ImmutableSortedSet < E > ) RegularImmutableSortedSet . NATURAL_EMPTY_SET ; } public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E element ) { return new RegularImmutableSortedSet < E > ( ImmutableList . of ( element ) , Ordering . natural ( ) ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 ) { return construct ( Ordering . natural ( ) , <int> , e1 , e2 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 ) { return construct ( Ordering . natural ( ) , <int> , e1 , e2 , e3 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { return construct ( Ordering . natural ( ) , <int> , e1 , e2 , e3 , e4 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( Ordering . natural ( ) , <int> , e1 , e2 , e3 , e4 , e5 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E . . . remaining ) { Comparable [ ] contents = new Comparable [ <int> + remaining . length ] ; contents [ <int> ] = e1 ; contents [ <int> ] = e2 ; contents [ <int> ] = e3 ; contents [ <int> ] = e4 ; contents [ <int> ] = e5 ; contents [ <int> ] = e6 ; System . arraycopy ( remaining , <int> , contents , <int> , remaining . length ) ; return construct ( Ordering . natural ( ) , contents . length , ( E [ ] ) contents ) ; } public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > copyOf ( E [ ] elements ) { return construct ( Ordering . natural ( ) , elements . length , elements . clone ( ) ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Iterable < ? extends E > elements ) { @SuppressWarnings ( <str> ) Ordering < E > naturalOrder = ( Ordering < E > ) Ordering . < Comparable > natural ( ) ; return copyOf ( naturalOrder , elements ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Collection < ? extends E > elements ) { @SuppressWarnings ( <str> ) Ordering < E > naturalOrder = ( Ordering < E > ) Ordering . < Comparable > natural ( ) ; return copyOf ( naturalOrder , elements ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Iterator < ? extends E > elements ) { @SuppressWarnings ( <str> ) Ordering < E > naturalOrder = ( Ordering < E > ) Ordering . < Comparable > natural ( ) ; return copyOf ( naturalOrder , elements ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Iterator < ? extends E > elements ) { return new Builder < E > ( comparator ) . addAll ( elements ) . build ( ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Iterable < ? extends E > elements ) { checkNotNull ( comparator ) ; boolean hasSameComparator = SortedIterables . hasSameComparator ( comparator , elements ) ; if ( hasSameComparator & & ( elements instanceof ImmutableSortedSet ) ) { @SuppressWarnings ( <str> ) ImmutableSortedSet < E > original = ( ImmutableSortedSet < E > ) elements ; if ( ! original . isPartialView ( ) ) { return original ; } } @SuppressWarnings ( <str> ) E [ ] array = ( E [ ] ) Iterables . toArray ( elements ) ; return construct ( comparator , array . length , array ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Collection < ? extends E > elements ) { return copyOf ( comparator , ( Iterable < ? extends E > ) elements ) ; } public static < E > ImmutableSortedSet < E > copyOfSorted ( SortedSet < E > sortedSet ) { Comparator < ? super E > comparator = SortedIterables . comparator ( sortedSet ) ; ImmutableList < E > list = ImmutableList . copyOf ( sortedSet ) ; if ( list . isEmpty ( ) ) { return emptySet ( comparator ) ; } else { return new RegularImmutableSortedSet < E > ( list , comparator ) ; } } static < E > ImmutableSortedSet < E > construct ( Comparator < ? super E > comparator , int n , E . . . contents ) { if ( n = = <int> ) { return emptySet ( comparator ) ; } checkElementsNotNull ( contents , n ) ; Arrays . sort ( contents , <int> , n , comparator ) ; int uniques = <int> ; for ( int i = <int> ; i < n ; i + + ) { E cur = contents [ i ] ; E prev = contents [ uniques - <int> ] ; if ( comparator . compare ( cur , prev ) ! = <int> ) { contents [ uniques + + ] = cur ; } } Arrays . fill ( contents , uniques , n , null ) ; return new RegularImmutableSortedSet < E > ( ImmutableList . < E > asImmutableList ( contents , uniques ) , comparator ) ; } public static < E > Builder < E > orderedBy ( Comparator < E > comparator ) { return new Builder < E > ( comparator ) ; } public static < E extends Comparable < ? > > Builder < E > reverseOrder ( ) { return new Builder < E > ( Ordering . natural ( ) . reverse ( ) ) ; } public static < E extends Comparable < ? > > Builder < E > naturalOrder ( ) { return new Builder < E > ( Ordering . natural ( ) ) ; } public static final class Builder < E > extends ImmutableSet . Builder < E > { private final Comparator < ? super E > comparator ; public Builder ( Comparator < ? super E > comparator ) { this . comparator = checkNotNull ( comparator ) ; } @Override public Builder < E > add ( E element ) { super . add ( element ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableSortedSet < E > build ( ) { @SuppressWarnings ( <str> ) E [ ] contentsArray = ( E [ ] ) contents ; ImmutableSortedSet < E > result = construct ( comparator , size , contentsArray ) ; this . size = result . size ( ) ; return result ; } } int unsafeCompare ( Object a , Object b ) { return unsafeCompare ( comparator , a , b ) ; } static int unsafeCompare ( Comparator < ? > comparator , Object a , Object b ) { @SuppressWarnings ( <str> ) Comparator < Object > unsafeComparator = ( Comparator < Object > ) comparator ; return unsafeComparator . compare ( a , b ) ; } final transient Comparator < ? super E > comparator ; ImmutableSortedSet ( Comparator < ? super E > comparator ) { this . comparator = comparator ; } @Override public Comparator < ? super E > comparator ( ) { return comparator ; } @Override public abstract UnmodifiableIterator < E > iterator ( ) ; @Override public ImmutableSortedSet < E > headSet ( E toElement ) { return headSet ( toElement , false ) ; } @GwtIncompatible ( <str> ) @Override public ImmutableSortedSet < E > headSet ( E toElement , boolean inclusive ) { return headSetImpl ( checkNotNull ( toElement ) , inclusive ) ; } @Override public ImmutableSortedSet < E > subSet ( E fromElement , E toElement ) { return subSet ( fromElement , true , toElement , false ) ; } @GwtIncompatible ( <str> ) @Override public ImmutableSortedSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { checkNotNull ( fromElement ) ; checkNotNull ( toElement ) ; checkArgument ( comparator . compare ( fromElement , toElement ) < = <int> ) ; return subSetImpl ( fromElement , fromInclusive , toElement , toInclusive ) ; } @Override public ImmutableSortedSet < E > tailSet ( E fromElement ) { return tailSet ( fromElement , true ) ; } @GwtIncompatible ( <str> ) @Override public ImmutableSortedSet < E > tailSet ( E fromElement , boolean inclusive ) { return tailSetImpl ( checkNotNull ( fromElement ) , inclusive ) ; } abstract ImmutableSortedSet < E > headSetImpl ( E toElement , boolean inclusive ) ; abstract ImmutableSortedSet < E > subSetImpl ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) ; abstract ImmutableSortedSet < E > tailSetImpl ( E fromElement , boolean inclusive ) ; @GwtIncompatible ( <str> ) @Override public E lower ( E e ) { return Iterators . getNext ( headSet ( e , false ) . descendingIterator ( ) , null ) ; } @GwtIncompatible ( <str> ) @Override public E floor ( E e ) { return Iterators . getNext ( headSet ( e , true ) . descendingIterator ( ) , null ) ; } @GwtIncompatible ( <str> ) @Override public E ceiling ( E e ) { return Iterables . getFirst ( tailSet ( e , true ) , null ) ; } @GwtIncompatible ( <str> ) @Override public E higher ( E e ) { return Iterables . getFirst ( tailSet ( e , false ) , null ) ; } @Override public E first ( ) { return iterator ( ) . next ( ) ; } @Override public E last ( ) { return descendingIterator ( ) . next ( ) ; } @Deprecated @GwtIncompatible ( <str> ) @Override public final E pollFirst ( ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @GwtIncompatible ( <str> ) @Override public final E pollLast ( ) { throw new UnsupportedOperationException ( ) ; } @GwtIncompatible ( <str> ) transient ImmutableSortedSet < E > descendingSet ; @GwtIncompatible ( <str> ) @Override public ImmutableSortedSet < E > descendingSet ( ) { ImmutableSortedSet < E > result = descendingSet ; if ( result = = null ) { result = descendingSet = createDescendingSet ( ) ; result . descendingSet = this ; } return result ; } @GwtIncompatible ( <str> ) ImmutableSortedSet < E > createDescendingSet ( ) { return new DescendingImmutableSortedSet < E > ( this ) ; } @GwtIncompatible ( <str> ) @Override public abstract UnmodifiableIterator < E > descendingIterator ( ) ; abstract int indexOf ( @Nullable Object target ) ; private static class SerializedForm < E > implements Serializable { final Comparator < ? super E > comparator ; final Object [ ] elements ; public SerializedForm ( Comparator < ? super E > comparator , Object [ ] elements ) { this . comparator = comparator ; this . elements = elements ; } @SuppressWarnings ( <str> ) Object readResolve ( ) { return new Builder < E > ( comparator ) . add ( ( E [ ] ) elements ) . build ( ) ; } private static final long serialVersionUID = <int> ; } private void readObject ( ObjectInputStream stream ) throws InvalidObjectException { throw new InvalidObjectException ( <str> ) ; } @Override Object writeReplace ( ) { return new SerializedForm < E > ( comparator , toArray ( ) ) ; } }