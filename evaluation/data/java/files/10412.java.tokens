package org . jbox2d . dynamics ; import org . jbox2d . callbacks . ContactFilter ; import org . jbox2d . callbacks . ContactListener ; import org . jbox2d . callbacks . DebugDraw ; import org . jbox2d . callbacks . DestructionListener ; import org . jbox2d . callbacks . ParticleDestructionListener ; import org . jbox2d . callbacks . ParticleQueryCallback ; import org . jbox2d . callbacks . ParticleRaycastCallback ; import org . jbox2d . callbacks . QueryCallback ; import org . jbox2d . callbacks . RayCastCallback ; import org . jbox2d . callbacks . TreeCallback ; import org . jbox2d . callbacks . TreeRayCastCallback ; import org . jbox2d . collision . AABB ; import org . jbox2d . collision . RayCastInput ; import org . jbox2d . collision . RayCastOutput ; import org . jbox2d . collision . TimeOfImpact . TOIInput ; import org . jbox2d . collision . TimeOfImpact . TOIOutput ; import org . jbox2d . collision . TimeOfImpact . TOIOutputState ; import org . jbox2d . collision . broadphase . BroadPhase ; import org . jbox2d . collision . broadphase . BroadPhaseStrategy ; import org . jbox2d . collision . broadphase . DefaultBroadPhaseBuffer ; import org . jbox2d . collision . broadphase . DynamicTree ; import org . jbox2d . collision . shapes . ChainShape ; import org . jbox2d . collision . shapes . CircleShape ; import org . jbox2d . collision . shapes . EdgeShape ; import org . jbox2d . collision . shapes . PolygonShape ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . collision . shapes . ShapeType ; import org . jbox2d . common . Color3f ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Sweep ; import org . jbox2d . common . Timer ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . contacts . Contact ; import org . jbox2d . dynamics . contacts . ContactEdge ; import org . jbox2d . dynamics . contacts . ContactRegister ; import org . jbox2d . dynamics . joints . Joint ; import org . jbox2d . dynamics . joints . JointDef ; import org . jbox2d . dynamics . joints . JointEdge ; import org . jbox2d . dynamics . joints . PulleyJoint ; import org . jbox2d . particle . ParticleBodyContact ; import org . jbox2d . particle . ParticleColor ; import org . jbox2d . particle . ParticleContact ; import org . jbox2d . particle . ParticleDef ; import org . jbox2d . particle . ParticleGroup ; import org . jbox2d . particle . ParticleGroupDef ; import org . jbox2d . particle . ParticleSystem ; import org . jbox2d . pooling . IDynamicStack ; import org . jbox2d . pooling . IWorldPool ; import org . jbox2d . pooling . arrays . Vec2Array ; import org . jbox2d . pooling . normal . DefaultWorldPool ; public class World { public static final int WORLD_POOL_SIZE = <int> ; public static final int WORLD_POOL_CONTAINER_SIZE = <int> ; public static final int NEW_FIXTURE = <hex> ; public static final int LOCKED = <hex> ; public static final int CLEAR_FORCES = <hex> ; public int activeContacts = <int> ; public int contactPoolCount = <int> ; protected int m_flags ; protected ContactManager m_contactManager ; private Body m_bodyList ; private Joint m_jointList ; private int m_bodyCount ; private int m_jointCount ; private final Vec2 m_gravity = new Vec2 ( ) ; private boolean m_allowSleep ; private DestructionListener m_destructionListener ; private ParticleDestructionListener m_particleDestructionListener ; private DebugDraw m_debugDraw ; private final IWorldPool pool ; private float m_inv_dt0 ; private boolean m_warmStarting ; private boolean m_continuousPhysics ; private boolean m_subStepping ; private boolean m_stepComplete ; private Profile m_profile ; private ParticleSystem m_particleSystem ; private ContactRegister [ ] [ ] contactStacks = new ContactRegister [ ShapeType . values ( ) . length ] [ ShapeType . values ( ) . length ] ; public World ( Vec2 gravity ) { this ( gravity , new DefaultWorldPool ( WORLD_POOL_SIZE , WORLD_POOL_CONTAINER_SIZE ) ) ; } public World ( Vec2 gravity , IWorldPool pool ) { this ( gravity , pool , new DynamicTree ( ) ) ; } public World ( Vec2 gravity , IWorldPool pool , BroadPhaseStrategy strategy ) { this ( gravity , pool , new DefaultBroadPhaseBuffer ( strategy ) ) ; } public World ( Vec2 gravity , IWorldPool pool , BroadPhase broadPhase ) { this . pool = pool ; m_destructionListener = null ; m_debugDraw = null ; m_bodyList = null ; m_jointList = null ; m_bodyCount = <int> ; m_jointCount = <int> ; m_warmStarting = true ; m_continuousPhysics = true ; m_subStepping = false ; m_stepComplete = true ; m_allowSleep = true ; m_gravity . set ( gravity ) ; m_flags = CLEAR_FORCES ; m_inv_dt0 = <int> f ; m_contactManager = new ContactManager ( this , broadPhase ) ; m_profile = new Profile ( ) ; m_particleSystem = new ParticleSystem ( this ) ; initializeRegisters ( ) ; } public void setAllowSleep ( boolean flag ) { if ( flag = = m_allowSleep ) { return ; } m_allowSleep = flag ; if ( m_allowSleep = = false ) { for ( Body b = m_bodyList ; b ! = null ; b = b . m_next ) { b . setAwake ( true ) ; } } } public void setSubStepping ( boolean subStepping ) { this . m_subStepping = subStepping ; } public boolean isSubStepping ( ) { return m_subStepping ; } public boolean isAllowSleep ( ) { return m_allowSleep ; } private void addType ( IDynamicStack < Contact > creator , ShapeType type1 , ShapeType type2 ) { ContactRegister register = new ContactRegister ( ) ; register . creator = creator ; register . primary = true ; contactStacks [ type1 . ordinal ( ) ] [ type2 . ordinal ( ) ] = register ; if ( type1 ! = type2 ) { ContactRegister register2 = new ContactRegister ( ) ; register2 . creator = creator ; register2 . primary = false ; contactStacks [ type2 . ordinal ( ) ] [ type1 . ordinal ( ) ] = register2 ; } } private void initializeRegisters ( ) { addType ( pool . getCircleContactStack ( ) , ShapeType . CIRCLE , ShapeType . CIRCLE ) ; addType ( pool . getPolyCircleContactStack ( ) , ShapeType . POLYGON , ShapeType . CIRCLE ) ; addType ( pool . getPolyContactStack ( ) , ShapeType . POLYGON , ShapeType . POLYGON ) ; addType ( pool . getEdgeCircleContactStack ( ) , ShapeType . EDGE , ShapeType . CIRCLE ) ; addType ( pool . getEdgePolyContactStack ( ) , ShapeType . EDGE , ShapeType . POLYGON ) ; addType ( pool . getChainCircleContactStack ( ) , ShapeType . CHAIN , ShapeType . CIRCLE ) ; addType ( pool . getChainPolyContactStack ( ) , ShapeType . CHAIN , ShapeType . POLYGON ) ; } public DestructionListener getDestructionListener ( ) { return m_destructionListener ; } public ParticleDestructionListener getParticleDestructionListener ( ) { return m_particleDestructionListener ; } public void setParticleDestructionListener ( ParticleDestructionListener listener ) { m_particleDestructionListener = listener ; } public Contact popContact ( Fixture fixtureA , int indexA , Fixture fixtureB , int indexB ) { final ShapeType type1 = fixtureA . getType ( ) ; final ShapeType type2 = fixtureB . getType ( ) ; final ContactRegister reg = contactStacks [ type1 . ordinal ( ) ] [ type2 . ordinal ( ) ] ; if ( reg ! = null ) { if ( reg . primary ) { Contact c = reg . creator . pop ( ) ; c . init ( fixtureA , indexA , fixtureB , indexB ) ; return c ; } else { Contact c = reg . creator . pop ( ) ; c . init ( fixtureB , indexB , fixtureA , indexA ) ; return c ; } } else { return null ; } } public void pushContact ( Contact contact ) { Fixture fixtureA = contact . getFixtureA ( ) ; Fixture fixtureB = contact . getFixtureB ( ) ; if ( contact . m_manifold . pointCount > <int> & & ! fixtureA . isSensor ( ) & & ! fixtureB . isSensor ( ) ) { fixtureA . getBody ( ) . setAwake ( true ) ; fixtureB . getBody ( ) . setAwake ( true ) ; } ShapeType type1 = fixtureA . getType ( ) ; ShapeType type2 = fixtureB . getType ( ) ; IDynamicStack < Contact > creator = contactStacks [ type1 . ordinal ( ) ] [ type2 . ordinal ( ) ] . creator ; creator . push ( contact ) ; } public IWorldPool getPool ( ) { return pool ; } public void setDestructionListener ( DestructionListener listener ) { m_destructionListener = listener ; } public void setContactFilter ( ContactFilter filter ) { m_contactManager . m_contactFilter = filter ; } public void setContactListener ( ContactListener listener ) { m_contactManager . m_contactListener = listener ; } public void setDebugDraw ( DebugDraw debugDraw ) { m_debugDraw = debugDraw ; } public Body createBody ( BodyDef def ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return null ; } Body b = new Body ( def , this ) ; b . m_prev = null ; b . m_next = m_bodyList ; if ( m_bodyList ! = null ) { m_bodyList . m_prev = b ; } m_bodyList = b ; + + m_bodyCount ; return b ; } public void destroyBody ( Body body ) { assert ( m_bodyCount > <int> ) ; assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return ; } JointEdge je = body . m_jointList ; while ( je ! = null ) { JointEdge je0 = je ; je = je . next ; if ( m_destructionListener ! = null ) { m_destructionListener . sayGoodbye ( je0 . joint ) ; } destroyJoint ( je0 . joint ) ; body . m_jointList = je ; } body . m_jointList = null ; ContactEdge ce = body . m_contactList ; while ( ce ! = null ) { ContactEdge ce0 = ce ; ce = ce . next ; m_contactManager . destroy ( ce0 . contact ) ; } body . m_contactList = null ; Fixture f = body . m_fixtureList ; while ( f ! = null ) { Fixture f0 = f ; f = f . m_next ; if ( m_destructionListener ! = null ) { m_destructionListener . sayGoodbye ( f0 ) ; } f0 . destroyProxies ( m_contactManager . m_broadPhase ) ; f0 . destroy ( ) ; body . m_fixtureList = f ; body . m_fixtureCount - = <int> ; } body . m_fixtureList = null ; body . m_fixtureCount = <int> ; if ( body . m_prev ! = null ) { body . m_prev . m_next = body . m_next ; } if ( body . m_next ! = null ) { body . m_next . m_prev = body . m_prev ; } if ( body = = m_bodyList ) { m_bodyList = body . m_next ; } - - m_bodyCount ; } public Joint createJoint ( JointDef def ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return null ; } Joint j = Joint . create ( this , def ) ; j . m_prev = null ; j . m_next = m_jointList ; if ( m_jointList ! = null ) { m_jointList . m_prev = j ; } m_jointList = j ; + + m_jointCount ; j . m_edgeA . joint = j ; j . m_edgeA . other = j . getBodyB ( ) ; j . m_edgeA . prev = null ; j . m_edgeA . next = j . getBodyA ( ) . m_jointList ; if ( j . getBodyA ( ) . m_jointList ! = null ) { j . getBodyA ( ) . m_jointList . prev = j . m_edgeA ; } j . getBodyA ( ) . m_jointList = j . m_edgeA ; j . m_edgeB . joint = j ; j . m_edgeB . other = j . getBodyA ( ) ; j . m_edgeB . prev = null ; j . m_edgeB . next = j . getBodyB ( ) . m_jointList ; if ( j . getBodyB ( ) . m_jointList ! = null ) { j . getBodyB ( ) . m_jointList . prev = j . m_edgeB ; } j . getBodyB ( ) . m_jointList = j . m_edgeB ; Body bodyA = def . bodyA ; Body bodyB = def . bodyB ; if ( def . collideConnected = = false ) { ContactEdge edge = bodyB . getContactList ( ) ; while ( edge ! = null ) { if ( edge . other = = bodyA ) { edge . contact . flagForFiltering ( ) ; } edge = edge . next ; } } return j ; } public void destroyJoint ( Joint j ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return ; } boolean collideConnected = j . getCollideConnected ( ) ; if ( j . m_prev ! = null ) { j . m_prev . m_next = j . m_next ; } if ( j . m_next ! = null ) { j . m_next . m_prev = j . m_prev ; } if ( j = = m_jointList ) { m_jointList = j . m_next ; } Body bodyA = j . getBodyA ( ) ; Body bodyB = j . getBodyB ( ) ; bodyA . setAwake ( true ) ; bodyB . setAwake ( true ) ; if ( j . m_edgeA . prev ! = null ) { j . m_edgeA . prev . next = j . m_edgeA . next ; } if ( j . m_edgeA . next ! = null ) { j . m_edgeA . next . prev = j . m_edgeA . prev ; } if ( j . m_edgeA = = bodyA . m_jointList ) { bodyA . m_jointList = j . m_edgeA . next ; } j . m_edgeA . prev = null ; j . m_edgeA . next = null ; if ( j . m_edgeB . prev ! = null ) { j . m_edgeB . prev . next = j . m_edgeB . next ; } if ( j . m_edgeB . next ! = null ) { j . m_edgeB . next . prev = j . m_edgeB . prev ; } if ( j . m_edgeB = = bodyB . m_jointList ) { bodyB . m_jointList = j . m_edgeB . next ; } j . m_edgeB . prev = null ; j . m_edgeB . next = null ; Joint . destroy ( j ) ; assert ( m_jointCount > <int> ) ; - - m_jointCount ; if ( collideConnected = = false ) { ContactEdge edge = bodyB . getContactList ( ) ; while ( edge ! = null ) { if ( edge . other = = bodyA ) { edge . contact . flagForFiltering ( ) ; } edge = edge . next ; } } } private final TimeStep step = new TimeStep ( ) ; private final Timer stepTimer = new Timer ( ) ; private final Timer tempTimer = new Timer ( ) ; public void step ( float dt , int velocityIterations , int positionIterations ) { stepTimer . reset ( ) ; tempTimer . reset ( ) ; if ( ( m_flags & NEW_FIXTURE ) = = NEW_FIXTURE ) { m_contactManager . findNewContacts ( ) ; m_flags & = ~ NEW_FIXTURE ; } m_flags | = LOCKED ; step . dt = dt ; step . velocityIterations = velocityIterations ; step . positionIterations = positionIterations ; if ( dt > <float> ) { step . inv_dt = <float> / dt ; } else { step . inv_dt = <float> ; } step . dtRatio = m_inv_dt0 * dt ; step . warmStarting = m_warmStarting ; m_profile . stepInit . record ( tempTimer . getMilliseconds ( ) ) ; tempTimer . reset ( ) ; m_contactManager . collide ( ) ; m_profile . collide . record ( tempTimer . getMilliseconds ( ) ) ; if ( m_stepComplete & & step . dt > <float> ) { tempTimer . reset ( ) ; m_particleSystem . solve ( step ) ; m_profile . solveParticleSystem . record ( tempTimer . getMilliseconds ( ) ) ; tempTimer . reset ( ) ; solve ( step ) ; m_profile . solve . record ( tempTimer . getMilliseconds ( ) ) ; } if ( m_continuousPhysics & & step . dt > <float> ) { tempTimer . reset ( ) ; solveTOI ( step ) ; m_profile . solveTOI . record ( tempTimer . getMilliseconds ( ) ) ; } if ( step . dt > <float> ) { m_inv_dt0 = step . inv_dt ; } if ( ( m_flags & CLEAR_FORCES ) = = CLEAR_FORCES ) { clearForces ( ) ; } m_flags & = ~ LOCKED ; m_profile . step . record ( stepTimer . getMilliseconds ( ) ) ; } public void clearForces ( ) { for ( Body body = m_bodyList ; body ! = null ; body = body . getNext ( ) ) { body . m_force . setZero ( ) ; body . m_torque = <float> ; } } private final Color3f color = new Color3f ( ) ; private final Transform xf = new Transform ( ) ; private final Vec2 cA = new Vec2 ( ) ; private final Vec2 cB = new Vec2 ( ) ; private final Vec2Array avs = new Vec2Array ( ) ; public void drawDebugData ( ) { if ( m_debugDraw = = null ) { return ; } int flags = m_debugDraw . getFlags ( ) ; boolean wireframe = ( flags & DebugDraw . e_wireframeDrawingBit ) ! = <int> ; if ( ( flags & DebugDraw . e_shapeBit ) ! = <int> ) { for ( Body b = m_bodyList ; b ! = null ; b = b . getNext ( ) ) { xf . set ( b . getTransform ( ) ) ; for ( Fixture f = b . getFixtureList ( ) ; f ! = null ; f = f . getNext ( ) ) { if ( b . isActive ( ) = = false ) { color . set ( <float> , <float> , <float> ) ; drawShape ( f , xf , color , wireframe ) ; } else if ( b . getType ( ) = = BodyType . STATIC ) { color . set ( <float> , <float> , <float> ) ; drawShape ( f , xf , color , wireframe ) ; } else if ( b . getType ( ) = = BodyType . KINEMATIC ) { color . set ( <float> , <float> , <float> ) ; drawShape ( f , xf , color , wireframe ) ; } else if ( b . isAwake ( ) = = false ) { color . set ( <float> , <float> , <float> ) ; drawShape ( f , xf , color , wireframe ) ; } else { color . set ( <float> , <float> , <float> ) ; drawShape ( f , xf , color , wireframe ) ; } } } drawParticleSystem ( m_particleSystem ) ; } if ( ( flags & DebugDraw . e_jointBit ) ! = <int> ) { for ( Joint j = m_jointList ; j ! = null ; j = j . getNext ( ) ) { drawJoint ( j ) ; } } if ( ( flags & DebugDraw . e_pairBit ) ! = <int> ) { color . set ( <float> , <float> , <float> ) ; for ( Contact c = m_contactManager . m_contactList ; c ! = null ; c = c . getNext ( ) ) { Fixture fixtureA = c . getFixtureA ( ) ; Fixture fixtureB = c . getFixtureB ( ) ; fixtureA . getAABB ( c . getChildIndexA ( ) ) . getCenterToOut ( cA ) ; fixtureB . getAABB ( c . getChildIndexB ( ) ) . getCenterToOut ( cB ) ; m_debugDraw . drawSegment ( cA , cB , color ) ; } } if ( ( flags & DebugDraw . e_aabbBit ) ! = <int> ) { color . set ( <float> , <float> , <float> ) ; for ( Body b = m_bodyList ; b ! = null ; b = b . getNext ( ) ) { if ( b . isActive ( ) = = false ) { continue ; } for ( Fixture f = b . getFixtureList ( ) ; f ! = null ; f = f . getNext ( ) ) { for ( int i = <int> ; i < f . m_proxyCount ; + + i ) { FixtureProxy proxy = f . m_proxies [ i ] ; AABB aabb = m_contactManager . m_broadPhase . getFatAABB ( proxy . proxyId ) ; if ( aabb ! = null ) { Vec2 [ ] vs = avs . get ( <int> ) ; vs [ <int> ] . set ( aabb . lowerBound . x , aabb . lowerBound . y ) ; vs [ <int> ] . set ( aabb . upperBound . x , aabb . lowerBound . y ) ; vs [ <int> ] . set ( aabb . upperBound . x , aabb . upperBound . y ) ; vs [ <int> ] . set ( aabb . lowerBound . x , aabb . upperBound . y ) ; m_debugDraw . drawPolygon ( vs , <int> , color ) ; } } } } } if ( ( flags & DebugDraw . e_centerOfMassBit ) ! = <int> ) { for ( Body b = m_bodyList ; b ! = null ; b = b . getNext ( ) ) { xf . set ( b . getTransform ( ) ) ; xf . p . set ( b . getWorldCenter ( ) ) ; m_debugDraw . drawTransform ( xf ) ; } } if ( ( flags & DebugDraw . e_dynamicTreeBit ) ! = <int> ) { m_contactManager . m_broadPhase . drawTree ( m_debugDraw ) ; } m_debugDraw . flush ( ) ; } private final WorldQueryWrapper wqwrapper = new WorldQueryWrapper ( ) ; public void queryAABB ( QueryCallback callback , AABB aabb ) { wqwrapper . broadPhase = m_contactManager . m_broadPhase ; wqwrapper . callback = callback ; m_contactManager . m_broadPhase . query ( wqwrapper , aabb ) ; } public void queryAABB ( QueryCallback callback , ParticleQueryCallback particleCallback , AABB aabb ) { wqwrapper . broadPhase = m_contactManager . m_broadPhase ; wqwrapper . callback = callback ; m_contactManager . m_broadPhase . query ( wqwrapper , aabb ) ; m_particleSystem . queryAABB ( particleCallback , aabb ) ; } public void queryAABB ( ParticleQueryCallback particleCallback , AABB aabb ) { m_particleSystem . queryAABB ( particleCallback , aabb ) ; } private final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper ( ) ; private final RayCastInput input = new RayCastInput ( ) ; public void raycast ( RayCastCallback callback , Vec2 point1 , Vec2 point2 ) { wrcwrapper . broadPhase = m_contactManager . m_broadPhase ; wrcwrapper . callback = callback ; input . maxFraction = <float> ; input . p1 . set ( point1 ) ; input . p2 . set ( point2 ) ; m_contactManager . m_broadPhase . raycast ( wrcwrapper , input ) ; } public void raycast ( RayCastCallback callback , ParticleRaycastCallback particleCallback , Vec2 point1 , Vec2 point2 ) { wrcwrapper . broadPhase = m_contactManager . m_broadPhase ; wrcwrapper . callback = callback ; input . maxFraction = <float> ; input . p1 . set ( point1 ) ; input . p2 . set ( point2 ) ; m_contactManager . m_broadPhase . raycast ( wrcwrapper , input ) ; m_particleSystem . raycast ( particleCallback , point1 , point2 ) ; } public void raycast ( ParticleRaycastCallback particleCallback , Vec2 point1 , Vec2 point2 ) { m_particleSystem . raycast ( particleCallback , point1 , point2 ) ; } public Body getBodyList ( ) { return m_bodyList ; } public Joint getJointList ( ) { return m_jointList ; } public Contact getContactList ( ) { return m_contactManager . m_contactList ; } public boolean isSleepingAllowed ( ) { return m_allowSleep ; } public void setSleepingAllowed ( boolean sleepingAllowed ) { m_allowSleep = sleepingAllowed ; } public void setWarmStarting ( boolean flag ) { m_warmStarting = flag ; } public boolean isWarmStarting ( ) { return m_warmStarting ; } public void setContinuousPhysics ( boolean flag ) { m_continuousPhysics = flag ; } public boolean isContinuousPhysics ( ) { return m_continuousPhysics ; } public int getProxyCount ( ) { return m_contactManager . m_broadPhase . getProxyCount ( ) ; } public int getBodyCount ( ) { return m_bodyCount ; } public int getJointCount ( ) { return m_jointCount ; } public int getContactCount ( ) { return m_contactManager . m_contactCount ; } public int getTreeHeight ( ) { return m_contactManager . m_broadPhase . getTreeHeight ( ) ; } public int getTreeBalance ( ) { return m_contactManager . m_broadPhase . getTreeBalance ( ) ; } public float getTreeQuality ( ) { return m_contactManager . m_broadPhase . getTreeQuality ( ) ; } public void setGravity ( Vec2 gravity ) { m_gravity . set ( gravity ) ; } public Vec2 getGravity ( ) { return m_gravity ; } public boolean isLocked ( ) { return ( m_flags & LOCKED ) = = LOCKED ; } public void setAutoClearForces ( boolean flag ) { if ( flag ) { m_flags | = CLEAR_FORCES ; } else { m_flags & = ~ CLEAR_FORCES ; } } public boolean getAutoClearForces ( ) { return ( m_flags & CLEAR_FORCES ) = = CLEAR_FORCES ; } public ContactManager getContactManager ( ) { return m_contactManager ; } public Profile getProfile ( ) { return m_profile ; } private final Island island = new Island ( ) ; private Body [ ] stack = new Body [ <int> ] ; private final Timer broadphaseTimer = new Timer ( ) ; private void solve ( TimeStep step ) { m_profile . solveInit . startAccum ( ) ; m_profile . solveVelocity . startAccum ( ) ; m_profile . solvePosition . startAccum ( ) ; for ( Body b = m_bodyList ; b ! = null ; b = b . m_next ) { b . m_xf0 . set ( b . m_xf ) ; } island . init ( m_bodyCount , m_contactManager . m_contactCount , m_jointCount , m_contactManager . m_contactListener ) ; for ( Body b = m_bodyList ; b ! = null ; b = b . m_next ) { b . m_flags & = ~ Body . e_islandFlag ; } for ( Contact c = m_contactManager . m_contactList ; c ! = null ; c = c . m_next ) { c . m_flags & = ~ Contact . ISLAND_FLAG ; } for ( Joint j = m_jointList ; j ! = null ; j = j . m_next ) { j . m_islandFlag = false ; } int stackSize = m_bodyCount ; if ( stack . length < stackSize ) { stack = new Body [ stackSize ] ; } for ( Body seed = m_bodyList ; seed ! = null ; seed = seed . m_next ) { if ( ( seed . m_flags & Body . e_islandFlag ) = = Body . e_islandFlag ) { continue ; } if ( seed . isAwake ( ) = = false | | seed . isActive ( ) = = false ) { continue ; } if ( seed . getType ( ) = = BodyType . STATIC ) { continue ; } island . clear ( ) ; int stackCount = <int> ; stack [ stackCount + + ] = seed ; seed . m_flags | = Body . e_islandFlag ; while ( stackCount > <int> ) { Body b = stack [ - - stackCount ] ; assert ( b . isActive ( ) = = true ) ; island . add ( b ) ; b . setAwake ( true ) ; if ( b . getType ( ) = = BodyType . STATIC ) { continue ; } for ( ContactEdge ce = b . m_contactList ; ce ! = null ; ce = ce . next ) { Contact contact = ce . contact ; if ( ( contact . m_flags & Contact . ISLAND_FLAG ) = = Contact . ISLAND_FLAG ) { continue ; } if ( contact . isEnabled ( ) = = false | | contact . isTouching ( ) = = false ) { continue ; } boolean sensorA = contact . m_fixtureA . m_isSensor ; boolean sensorB = contact . m_fixtureB . m_isSensor ; if ( sensorA | | sensorB ) { continue ; } island . add ( contact ) ; contact . m_flags | = Contact . ISLAND_FLAG ; Body other = ce . other ; if ( ( other . m_flags & Body . e_islandFlag ) = = Body . e_islandFlag ) { continue ; } assert ( stackCount < stackSize ) ; stack [ stackCount + + ] = other ; other . m_flags | = Body . e_islandFlag ; } for ( JointEdge je = b . m_jointList ; je ! = null ; je = je . next ) { if ( je . joint . m_islandFlag = = true ) { continue ; } Body other = je . other ; if ( other . isActive ( ) = = false ) { continue ; } island . add ( je . joint ) ; je . joint . m_islandFlag = true ; if ( ( other . m_flags & Body . e_islandFlag ) = = Body . e_islandFlag ) { continue ; } assert ( stackCount < stackSize ) ; stack [ stackCount + + ] = other ; other . m_flags | = Body . e_islandFlag ; } } island . solve ( m_profile , step , m_gravity , m_allowSleep ) ; for ( int i = <int> ; i < island . m_bodyCount ; + + i ) { Body b = island . m_bodies [ i ] ; if ( b . getType ( ) = = BodyType . STATIC ) { b . m_flags & = ~ Body . e_islandFlag ; } } } m_profile . solveInit . endAccum ( ) ; m_profile . solveVelocity . endAccum ( ) ; m_profile . solvePosition . endAccum ( ) ; broadphaseTimer . reset ( ) ; for ( Body b = m_bodyList ; b ! = null ; b = b . getNext ( ) ) { if ( ( b . m_flags & Body . e_islandFlag ) = = <int> ) { continue ; } if ( b . getType ( ) = = BodyType . STATIC ) { continue ; } b . synchronizeFixtures ( ) ; } m_contactManager . findNewContacts ( ) ; m_profile . broadphase . record ( broadphaseTimer . getMilliseconds ( ) ) ; } private final Island toiIsland = new Island ( ) ; private final TOIInput toiInput = new TOIInput ( ) ; private final TOIOutput toiOutput = new TOIOutput ( ) ; private final TimeStep subStep = new TimeStep ( ) ; private final Body [ ] tempBodies = new Body [ <int> ] ; private final Sweep backup1 = new Sweep ( ) ; private final Sweep backup2 = new Sweep ( ) ; private void solveTOI ( final TimeStep step ) { final Island island = toiIsland ; island . init ( <int> * Settings . maxTOIContacts , Settings . maxTOIContacts , <int> , m_contactManager . m_contactListener ) ; if ( m_stepComplete ) { for ( Body b = m_bodyList ; b ! = null ; b = b . m_next ) { b . m_flags & = ~ Body . e_islandFlag ; b . m_sweep . alpha0 = <float> ; } for ( Contact c = m_contactManager . m_contactList ; c ! = null ; c = c . m_next ) { c . m_flags & = ~ ( Contact . TOI_FLAG | Contact . ISLAND_FLAG ) ; c . m_toiCount = <int> ; c . m_toi = <float> ; } } for ( ; ; ) { Contact minContact = null ; float minAlpha = <float> ; for ( Contact c = m_contactManager . m_contactList ; c ! = null ; c = c . m_next ) { if ( c . isEnabled ( ) = = false ) { continue ; } if ( c . m_toiCount > Settings . maxSubSteps ) { continue ; } float alpha = <float> ; if ( ( c . m_flags & Contact . TOI_FLAG ) ! = <int> ) { alpha = c . m_toi ; } else { Fixture fA = c . getFixtureA ( ) ; Fixture fB = c . getFixtureB ( ) ; if ( fA . isSensor ( ) | | fB . isSensor ( ) ) { continue ; } Body bA = fA . getBody ( ) ; Body bB = fB . getBody ( ) ; BodyType typeA = bA . m_type ; BodyType typeB = bB . m_type ; assert ( typeA = = BodyType . DYNAMIC | | typeB = = BodyType . DYNAMIC ) ; boolean activeA = bA . isAwake ( ) & & typeA ! = BodyType . STATIC ; boolean activeB = bB . isAwake ( ) & & typeB ! = BodyType . STATIC ; if ( activeA = = false & & activeB = = false ) { continue ; } boolean collideA = bA . isBullet ( ) | | typeA ! = BodyType . DYNAMIC ; boolean collideB = bB . isBullet ( ) | | typeB ! = BodyType . DYNAMIC ; if ( collideA = = false & & collideB = = false ) { continue ; } float alpha0 = bA . m_sweep . alpha0 ; if ( bA . m_sweep . alpha0 < bB . m_sweep . alpha0 ) { alpha0 = bB . m_sweep . alpha0 ; bA . m_sweep . advance ( alpha0 ) ; } else if ( bB . m_sweep . alpha0 < bA . m_sweep . alpha0 ) { alpha0 = bA . m_sweep . alpha0 ; bB . m_sweep . advance ( alpha0 ) ; } assert ( alpha0 < <float> ) ; int indexA = c . getChildIndexA ( ) ; int indexB = c . getChildIndexB ( ) ; final TOIInput input = toiInput ; input . proxyA . set ( fA . getShape ( ) , indexA ) ; input . proxyB . set ( fB . getShape ( ) , indexB ) ; input . sweepA . set ( bA . m_sweep ) ; input . sweepB . set ( bB . m_sweep ) ; input . tMax = <float> ; pool . getTimeOfImpact ( ) . timeOfImpact ( toiOutput , input ) ; float beta = toiOutput . t ; if ( toiOutput . state = = TOIOutputState . TOUCHING ) { alpha = MathUtils . min ( alpha0 + ( <float> - alpha0 ) * beta , <float> ) ; } else { alpha = <float> ; } c . m_toi = alpha ; c . m_flags | = Contact . TOI_FLAG ; } if ( alpha < minAlpha ) { minContact = c ; minAlpha = alpha ; } } if ( minContact = = null | | <float> - <float> * Settings . EPSILON < minAlpha ) { m_stepComplete = true ; break ; } Fixture fA = minContact . getFixtureA ( ) ; Fixture fB = minContact . getFixtureB ( ) ; Body bA = fA . getBody ( ) ; Body bB = fB . getBody ( ) ; backup1 . set ( bA . m_sweep ) ; backup2 . set ( bB . m_sweep ) ; bA . advance ( minAlpha ) ; bB . advance ( minAlpha ) ; minContact . update ( m_contactManager . m_contactListener ) ; minContact . m_flags & = ~ Contact . TOI_FLAG ; + + minContact . m_toiCount ; if ( minContact . isEnabled ( ) = = false | | minContact . isTouching ( ) = = false ) { minContact . setEnabled ( false ) ; bA . m_sweep . set ( backup1 ) ; bB . m_sweep . set ( backup2 ) ; bA . synchronizeTransform ( ) ; bB . synchronizeTransform ( ) ; continue ; } bA . setAwake ( true ) ; bB . setAwake ( true ) ; island . clear ( ) ; island . add ( bA ) ; island . add ( bB ) ; island . add ( minContact ) ; bA . m_flags | = Body . e_islandFlag ; bB . m_flags | = Body . e_islandFlag ; minContact . m_flags | = Contact . ISLAND_FLAG ; tempBodies [ <int> ] = bA ; tempBodies [ <int> ] = bB ; for ( int i = <int> ; i < <int> ; + + i ) { Body body = tempBodies [ i ] ; if ( body . m_type = = BodyType . DYNAMIC ) { for ( ContactEdge ce = body . m_contactList ; ce ! = null ; ce = ce . next ) { if ( island . m_bodyCount = = island . m_bodyCapacity ) { break ; } if ( island . m_contactCount = = island . m_contactCapacity ) { break ; } Contact contact = ce . contact ; if ( ( contact . m_flags & Contact . ISLAND_FLAG ) ! = <int> ) { continue ; } Body other = ce . other ; if ( other . m_type = = BodyType . DYNAMIC & & body . isBullet ( ) = = false & & other . isBullet ( ) = = false ) { continue ; } boolean sensorA = contact . m_fixtureA . m_isSensor ; boolean sensorB = contact . m_fixtureB . m_isSensor ; if ( sensorA | | sensorB ) { continue ; } backup1 . set ( other . m_sweep ) ; if ( ( other . m_flags & Body . e_islandFlag ) = = <int> ) { other . advance ( minAlpha ) ; } contact . update ( m_contactManager . m_contactListener ) ; if ( contact . isEnabled ( ) = = false ) { other . m_sweep . set ( backup1 ) ; other . synchronizeTransform ( ) ; continue ; } if ( contact . isTouching ( ) = = false ) { other . m_sweep . set ( backup1 ) ; other . synchronizeTransform ( ) ; continue ; } contact . m_flags | = Contact . ISLAND_FLAG ; island . add ( contact ) ; if ( ( other . m_flags & Body . e_islandFlag ) ! = <int> ) { continue ; } other . m_flags | = Body . e_islandFlag ; if ( other . m_type ! = BodyType . STATIC ) { other . setAwake ( true ) ; } island . add ( other ) ; } } } subStep . dt = ( <float> - minAlpha ) * step . dt ; subStep . inv_dt = <float> / subStep . dt ; subStep . dtRatio = <float> ; subStep . positionIterations = <int> ; subStep . velocityIterations = step . velocityIterations ; subStep . warmStarting = false ; island . solveTOI ( subStep , bA . m_islandIndex , bB . m_islandIndex ) ; for ( int i = <int> ; i < island . m_bodyCount ; + + i ) { Body body = island . m_bodies [ i ] ; body . m_flags & = ~ Body . e_islandFlag ; if ( body . m_type ! = BodyType . DYNAMIC ) { continue ; } body . synchronizeFixtures ( ) ; for ( ContactEdge ce = body . m_contactList ; ce ! = null ; ce = ce . next ) { ce . contact . m_flags & = ~ ( Contact . TOI_FLAG | Contact . ISLAND_FLAG ) ; } } m_contactManager . findNewContacts ( ) ; if ( m_subStepping ) { m_stepComplete = false ; break ; } } } private void drawJoint ( Joint joint ) { Body bodyA = joint . getBodyA ( ) ; Body bodyB = joint . getBodyB ( ) ; Transform xf1 = bodyA . getTransform ( ) ; Transform xf2 = bodyB . getTransform ( ) ; Vec2 x1 = xf1 . p ; Vec2 x2 = xf2 . p ; Vec2 p1 = pool . popVec2 ( ) ; Vec2 p2 = pool . popVec2 ( ) ; joint . getAnchorA ( p1 ) ; joint . getAnchorB ( p2 ) ; color . set ( <float> , <float> , <float> ) ; switch ( joint . getType ( ) ) { case DISTANCE : m_debugDraw . drawSegment ( p1 , p2 , color ) ; break ; case PULLEY : { PulleyJoint pulley = ( PulleyJoint ) joint ; Vec2 s1 = pulley . getGroundAnchorA ( ) ; Vec2 s2 = pulley . getGroundAnchorB ( ) ; m_debugDraw . drawSegment ( s1 , p1 , color ) ; m_debugDraw . drawSegment ( s2 , p2 , color ) ; m_debugDraw . drawSegment ( s1 , s2 , color ) ; } break ; case CONSTANT_VOLUME : case MOUSE : break ; default : m_debugDraw . drawSegment ( x1 , p1 , color ) ; m_debugDraw . drawSegment ( p1 , p2 , color ) ; m_debugDraw . drawSegment ( x2 , p2 , color ) ; } pool . pushVec2 ( <int> ) ; } private static Integer LIQUID_INT = new Integer ( <int> ) ; private float liquidLength = . <int> f ; private float averageLinearVel = - <int> ; private final Vec2 liquidOffset = new Vec2 ( ) ; private final Vec2 circCenterMoved = new Vec2 ( ) ; private final Color3f liquidColor = new Color3f ( . <int> f , . <int> f , <int> f ) ; private final Vec2 center = new Vec2 ( ) ; private final Vec2 axis = new Vec2 ( ) ; private final Vec2 v1 = new Vec2 ( ) ; private final Vec2 v2 = new Vec2 ( ) ; private final Vec2Array tlvertices = new Vec2Array ( ) ; private void drawShape ( Fixture fixture , Transform xf , Color3f color , boolean wireframe ) { switch ( fixture . getType ( ) ) { case CIRCLE : { CircleShape circle = ( CircleShape ) fixture . getShape ( ) ; Transform . mulToOutUnsafe ( xf , circle . m_p , center ) ; float radius = circle . m_radius ; xf . q . getXAxis ( axis ) ; if ( fixture . getUserData ( ) ! = null & & fixture . getUserData ( ) . equals ( LIQUID_INT ) ) { Body b = fixture . getBody ( ) ; liquidOffset . set ( b . m_linearVelocity ) ; float linVelLength = b . m_linearVelocity . length ( ) ; if ( averageLinearVel = = - <int> ) { averageLinearVel = linVelLength ; } else { averageLinearVel = . <int> f * averageLinearVel + . <int> f * linVelLength ; } liquidOffset . mulLocal ( liquidLength / averageLinearVel / <int> ) ; circCenterMoved . set ( center ) . addLocal ( liquidOffset ) ; center . subLocal ( liquidOffset ) ; m_debugDraw . drawSegment ( center , circCenterMoved , liquidColor ) ; return ; } if ( wireframe ) { m_debugDraw . drawCircle ( center , radius , axis , color ) ; } else { m_debugDraw . drawSolidCircle ( center , radius , axis , color ) ; } } break ; case POLYGON : { PolygonShape poly = ( PolygonShape ) fixture . getShape ( ) ; int vertexCount = poly . m_count ; assert ( vertexCount < = Settings . maxPolygonVertices ) ; Vec2 [ ] vertices = tlvertices . get ( Settings . maxPolygonVertices ) ; for ( int i = <int> ; i < vertexCount ; + + i ) { Transform . mulToOutUnsafe ( xf , poly . m_vertices [ i ] , vertices [ i ] ) ; } if ( wireframe ) { m_debugDraw . drawPolygon ( vertices , vertexCount , color ) ; } else { m_debugDraw . drawSolidPolygon ( vertices , vertexCount , color ) ; } } break ; case EDGE : { EdgeShape edge = ( EdgeShape ) fixture . getShape ( ) ; Transform . mulToOutUnsafe ( xf , edge . m_vertex1 , v1 ) ; Transform . mulToOutUnsafe ( xf , edge . m_vertex2 , v2 ) ; m_debugDraw . drawSegment ( v1 , v2 , color ) ; } break ; case CHAIN : { ChainShape chain = ( ChainShape ) fixture . getShape ( ) ; int count = chain . m_count ; Vec2 [ ] vertices = chain . m_vertices ; Transform . mulToOutUnsafe ( xf , vertices [ <int> ] , v1 ) ; for ( int i = <int> ; i < count ; + + i ) { Transform . mulToOutUnsafe ( xf , vertices [ i ] , v2 ) ; m_debugDraw . drawSegment ( v1 , v2 , color ) ; m_debugDraw . drawCircle ( v1 , <float> , color ) ; v1 . set ( v2 ) ; } } break ; default : break ; } } private void drawParticleSystem ( ParticleSystem system ) { boolean wireframe = ( m_debugDraw . getFlags ( ) & DebugDraw . e_wireframeDrawingBit ) ! = <int> ; int particleCount = system . getParticleCount ( ) ; if ( particleCount ! = <int> ) { float particleRadius = system . getParticleRadius ( ) ; Vec2 [ ] positionBuffer = system . getParticlePositionBuffer ( ) ; ParticleColor [ ] colorBuffer = null ; if ( system . m_colorBuffer . data ! = null ) { colorBuffer = system . getParticleColorBuffer ( ) ; } if ( wireframe ) { m_debugDraw . drawParticlesWireframe ( positionBuffer , particleRadius , colorBuffer , particleCount ) ; } else { m_debugDraw . drawParticles ( positionBuffer , particleRadius , colorBuffer , particleCount ) ; } } } public int createParticle ( ParticleDef def ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return <int> ; } int p = m_particleSystem . createParticle ( def ) ; return p ; } public void destroyParticle ( int index ) { destroyParticle ( index , false ) ; } public void destroyParticle ( int index , boolean callDestructionListener ) { m_particleSystem . destroyParticle ( index , callDestructionListener ) ; } public int destroyParticlesInShape ( Shape shape , Transform xf ) { return destroyParticlesInShape ( shape , xf , false ) ; } public int destroyParticlesInShape ( Shape shape , Transform xf , boolean callDestructionListener ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return <int> ; } return m_particleSystem . destroyParticlesInShape ( shape , xf , callDestructionListener ) ; } public ParticleGroup createParticleGroup ( ParticleGroupDef def ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return null ; } ParticleGroup g = m_particleSystem . createParticleGroup ( def ) ; return g ; } public void joinParticleGroups ( ParticleGroup groupA , ParticleGroup groupB ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return ; } m_particleSystem . joinParticleGroups ( groupA , groupB ) ; } public void destroyParticlesInGroup ( ParticleGroup group , boolean callDestructionListener ) { assert ( isLocked ( ) = = false ) ; if ( isLocked ( ) ) { return ; } m_particleSystem . destroyParticlesInGroup ( group , callDestructionListener ) ; } public void destroyParticlesInGroup ( ParticleGroup group ) { destroyParticlesInGroup ( group , false ) ; } public ParticleGroup [ ] getParticleGroupList ( ) { return m_particleSystem . getParticleGroupList ( ) ; } public int getParticleGroupCount ( ) { return m_particleSystem . getParticleGroupCount ( ) ; } public int getParticleCount ( ) { return m_particleSystem . getParticleCount ( ) ; } public int getParticleMaxCount ( ) { return m_particleSystem . getParticleMaxCount ( ) ; } public void setParticleMaxCount ( int count ) { m_particleSystem . setParticleMaxCount ( count ) ; } public void setParticleDensity ( float density ) { m_particleSystem . setParticleDensity ( density ) ; } public float getParticleDensity ( ) { return m_particleSystem . getParticleDensity ( ) ; } public void setParticleGravityScale ( float gravityScale ) { m_particleSystem . setParticleGravityScale ( gravityScale ) ; } public float getParticleGravityScale ( ) { return m_particleSystem . getParticleGravityScale ( ) ; } public void setParticleDamping ( float damping ) { m_particleSystem . setParticleDamping ( damping ) ; } public float getParticleDamping ( ) { return m_particleSystem . getParticleDamping ( ) ; } public void setParticleRadius ( float radius ) { m_particleSystem . setParticleRadius ( radius ) ; } public float getParticleRadius ( ) { return m_particleSystem . getParticleRadius ( ) ; } public int [ ] getParticleFlagsBuffer ( ) { return m_particleSystem . getParticleFlagsBuffer ( ) ; } public Vec2 [ ] getParticlePositionBuffer ( ) { return m_particleSystem . getParticlePositionBuffer ( ) ; } public Vec2 [ ] getParticleVelocityBuffer ( ) { return m_particleSystem . getParticleVelocityBuffer ( ) ; } public ParticleColor [ ] getParticleColorBuffer ( ) { return m_particleSystem . getParticleColorBuffer ( ) ; } public ParticleGroup [ ] getParticleGroupBuffer ( ) { return m_particleSystem . getParticleGroupBuffer ( ) ; } public Object [ ] getParticleUserDataBuffer ( ) { return m_particleSystem . getParticleUserDataBuffer ( ) ; } public void setParticleFlagsBuffer ( int [ ] buffer , int capacity ) { m_particleSystem . setParticleFlagsBuffer ( buffer , capacity ) ; } public void setParticlePositionBuffer ( Vec2 [ ] buffer , int capacity ) { m_particleSystem . setParticlePositionBuffer ( buffer , capacity ) ; } public void setParticleVelocityBuffer ( Vec2 [ ] buffer , int capacity ) { m_particleSystem . setParticleVelocityBuffer ( buffer , capacity ) ; } public void setParticleColorBuffer ( ParticleColor [ ] buffer , int capacity ) { m_particleSystem . setParticleColorBuffer ( buffer , capacity ) ; } public void setParticleUserDataBuffer ( Object [ ] buffer , int capacity ) { m_particleSystem . setParticleUserDataBuffer ( buffer , capacity ) ; } public ParticleContact [ ] getParticleContacts ( ) { return m_particleSystem . m_contactBuffer ; } public int getParticleContactCount ( ) { return m_particleSystem . m_contactCount ; } public ParticleBodyContact [ ] getParticleBodyContacts ( ) { return m_particleSystem . m_bodyContactBuffer ; } public int getParticleBodyContactCount ( ) { return m_particleSystem . m_bodyContactCount ; } public float computeParticleCollisionEnergy ( ) { return m_particleSystem . computeParticleCollisionEnergy ( ) ; } } class WorldQueryWrapper implements TreeCallback { public boolean treeCallback ( int nodeId ) { FixtureProxy proxy = ( FixtureProxy ) broadPhase . getUserData ( nodeId ) ; return callback . reportFixture ( proxy . fixture ) ; } BroadPhase broadPhase ; QueryCallback callback ; } ; class WorldRayCastWrapper implements TreeRayCastCallback { private final RayCastOutput output = new RayCastOutput ( ) ; private final Vec2 temp = new Vec2 ( ) ; private final Vec2 point = new Vec2 ( ) ; public float raycastCallback ( RayCastInput input , int nodeId ) { Object userData = broadPhase . getUserData ( nodeId ) ; FixtureProxy proxy = ( FixtureProxy ) userData ; Fixture fixture = proxy . fixture ; int index = proxy . childIndex ; boolean hit = fixture . raycast ( output , input , index ) ; if ( hit ) { float fraction = output . fraction ; temp . set ( input . p2 ) . mulLocal ( fraction ) ; point . set ( input . p1 ) . mulLocal ( <int> - fraction ) . addLocal ( temp ) ; return callback . reportFixture ( fixture , point , output . normal , fraction ) ; } return input . maxFraction ; } BroadPhase broadPhase ; RayCastCallback callback ; } ;