package org . eclipse . debug . internal . ui ; import java . lang . reflect . InvocationTargetException ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Set ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . eclipse . core . expressions . EvaluationContext ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . resources . ISaveContext ; import org . eclipse . core . resources . ISaveParticipant ; import org . eclipse . core . resources . IncrementalProjectBuilder ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . core . runtime . jobs . IJobChangeEvent ; import org . eclipse . core . runtime . jobs . IJobChangeListener ; import org . eclipse . core . runtime . jobs . IJobManager ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . core . runtime . preferences . IEclipsePreferences ; import org . eclipse . core . runtime . preferences . InstanceScope ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchListener ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . core . IStatusHandler ; import org . eclipse . debug . core . Launch ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . contextlaunching . LaunchingResourceManager ; import org . eclipse . debug . internal . ui . launchConfigurations . ClosedProjectFilter ; import org . eclipse . debug . internal . ui . launchConfigurations . DeletedProjectFilter ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationEditDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationManager ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationPropertiesDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationTypeFilter ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationsDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchGroupExtension ; import org . eclipse . debug . internal . ui . launchConfigurations . PerspectiveManager ; import org . eclipse . debug . internal . ui . sourcelookup . SourceLookupFacility ; import org . eclipse . debug . internal . ui . sourcelookup . SourceLookupManager ; import org . eclipse . debug . internal . ui . stringsubstitution . SelectedResourceManager ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointOrganizerManager ; import org . eclipse . debug . internal . ui . views . console . ProcessConsoleManager ; import org . eclipse . debug . internal . ui . views . launch . DebugElementHelper ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugModelPresentation ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . ILaunchGroup ; import org . eclipse . jface . bindings . keys . KeyStroke ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialogWithToggle ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . window . Window ; import org . eclipse . osgi . service . debug . DebugOptions ; import org . eclipse . osgi . service . debug . DebugOptionsListener ; import org . eclipse . osgi . service . debug . DebugTrace ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . eclipse . ui . progress . IProgressConstants2 ; import org . eclipse . ui . progress . IProgressService ; import org . eclipse . ui . services . IEvaluationService ; import org . eclipse . ui . themes . IThemeManager ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . osgi . service . prefs . BackingStoreException ; import org . w3c . dom . Document ; import com . ibm . icu . text . MessageFormat ; public class DebugUIPlugin extends AbstractUIPlugin implements ILaunchListener , DebugOptionsListener { public static boolean DEBUG = false ; public static boolean DEBUG_BREAKPOINT_DELTAS = false ; public static boolean DEBUG_MODEL = false ; public static boolean DEBUG_VIEWER = false ; public static boolean DEBUG_BREADCRUMB = false ; public static boolean DEBUG_TREE_VIEWER_DROPDOWN = false ; public static boolean DEBUG_CONTENT_PROVIDER = false ; public static boolean DEBUG_UPDATE_SEQUENCE = false ; public static boolean DEBUG_DELTAS = false ; public static boolean DEBUG_STATE_SAVE_RESTORE = false ; public static String DEBUG_PRESENTATION_ID = null ; public static boolean DEBUG_DYNAMIC_LOADING = false ; static final String DEBUG_FLAG = <str> ; static final String DEBUG_BREAKPOINT_DELTAS_FLAG = <str> ; static final String DEBUG_MODEL_FLAG = <str> ; static final String DEBUG_VIEWER_FLAG = <str> ; static final String DEBUG_BREADCRUMB_FLAG = <str> ; static final String DEBUG_TREE_VIEWER_DROPDOWN_FLAG = <str> ; static final String DEBUG_CONTENT_PROVIDER_FLAG = <str> ; static final String DEBUG_UPDATE_SEQUENCE_FLAG = <str> ; static final String DEBUG_DELTAS_FLAG = <str> ; static final String DEBUG_STATE_SAVE_RESTORE_FLAG = <str> ; static final String DEBUG_PRESENTATION_ID_FLAG = <str> ; static final String DEBUG_DYNAMIC_LOADING_FLAG = <str> ; private static DebugTrace fgDebugTrace ; private static DebugUIPlugin fgDebugUIPlugin = null ; protected static IDebugModelPresentation fgPresentation = null ; private static DefaultLabelProvider fgDefaultLabelProvider ; public static String ATTR_LAUNCHING_CONFIG_HANDLE = getUniqueIdentifier ( ) + <str> ; private ProcessConsoleManager fProcessConsoleManager = null ; private PerspectiveManager fPerspectiveManager = null ; private LaunchConfigurationManager fLaunchConfigurationManager = null ; private LaunchingResourceManager fContextLaunchingManager = null ; private ImageDescriptorRegistry fImageDescriptorRegistry ; private Set < ISaveParticipant > fSaveParticipants = new HashSet < ISaveParticipant > ( ) ; private IPropertyChangeListener fThemeListener ; public static class PendingLaunch extends Launch { private Job fJob ; public PendingLaunch ( ILaunchConfiguration launchConfiguration , String mode , Job job ) { super ( launchConfiguration , mode , null ) ; fJob = job ; } @Override public boolean canTerminate ( ) { return true ; } @Override public void terminate ( ) throws DebugException { fJob . cancel ( ) ; } } public DebugUIPlugin ( ) { super ( ) ; fgDebugUIPlugin = this ; } public static void trace ( String option , String message , Throwable throwable ) { System . out . println ( message ) ; if ( fgDebugTrace ! = null ) { fgDebugTrace . trace ( option , message , throwable ) ; } } public static void trace ( String message ) { trace ( null , message , null ) ; } public static DebugUIPlugin getDefault ( ) { if ( fgDebugUIPlugin = = null ) { fgDebugUIPlugin = new DebugUIPlugin ( ) ; } return fgDebugUIPlugin ; } public static String getUniqueIdentifier ( ) { return IDebugUIConstants . PLUGIN_ID ; } public static IDebugModelPresentation getModelPresentation ( ) { if ( fgPresentation = = null ) { fgPresentation = new DelegatingModelPresentation ( ) ; } return fgPresentation ; } public LaunchConfigurationManager getLaunchConfigurationManager ( ) { if ( fLaunchConfigurationManager = = null ) { fLaunchConfigurationManager = new LaunchConfigurationManager ( ) ; } return fLaunchConfigurationManager ; } public LaunchingResourceManager getLaunchingResourceManager ( ) { if ( fContextLaunchingManager = = null ) { fContextLaunchingManager = new LaunchingResourceManager ( ) ; fContextLaunchingManager . startup ( ) ; } return fContextLaunchingManager ; } public static IWorkbenchWindow getActiveWorkbenchWindow ( ) { return getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; } public static Shell getShell ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window = = null ) { IWorkbenchWindow [ ] windows = PlatformUI . getWorkbench ( ) . getWorkbenchWindows ( ) ; if ( windows . length > <int> ) { return windows [ <int> ] . getShell ( ) ; } } else { return window . getShell ( ) ; } return null ; } public static ILabelProvider getDefaultLabelProvider ( ) { if ( fgDefaultLabelProvider = = null ) { fgDefaultLabelProvider = new DefaultLabelProvider ( ) ; } return fgDefaultLabelProvider ; } public static Object createExtension ( final IConfigurationElement element , final String classAttribute ) throws CoreException { Bundle bundle = Platform . getBundle ( element . getContributor ( ) . getName ( ) ) ; if ( bundle . getState ( ) = = Bundle . ACTIVE ) { return element . createExecutableExtension ( classAttribute ) ; } final Object [ ] ret = new Object [ <int> ] ; final CoreException [ ] exc = new CoreException [ <int> ] ; BusyIndicator . showWhile ( null , new Runnable ( ) { @Override public void run ( ) { try { ret [ <int> ] = element . createExecutableExtension ( classAttribute ) ; } catch ( CoreException e ) { exc [ <int> ] = e ; } } } ) ; if ( exc [ <int> ] ! = null ) { throw exc [ <int> ] ; } return ret [ <int> ] ; } @Override protected ImageRegistry createImageRegistry ( ) { return DebugPluginImages . initializeImageRegistry ( ) ; } @Override public void stop ( BundleContext context ) throws Exception { try { if ( fProcessConsoleManager ! = null ) { fProcessConsoleManager . shutdown ( ) ; } BreakpointOrganizerManager . getDefault ( ) . shutdown ( ) ; if ( fPerspectiveManager ! = null ) { fPerspectiveManager . shutdown ( ) ; } if ( fLaunchConfigurationManager ! = null ) { fLaunchConfigurationManager . shutdown ( ) ; } if ( fContextLaunchingManager ! = null ) { fContextLaunchingManager . shutdown ( ) ; } ColorManager . getDefault ( ) . dispose ( ) ; if ( fgPresentation ! = null ) { fgPresentation . dispose ( ) ; } if ( fImageDescriptorRegistry ! = null ) { fImageDescriptorRegistry . dispose ( ) ; } if ( fgDefaultLabelProvider ! = null ) { fgDefaultLabelProvider . dispose ( ) ; } SourceLookupFacility . shutdown ( ) ; DebugElementHelper . dispose ( ) ; fSaveParticipants . clear ( ) ; ResourcesPlugin . getWorkspace ( ) . removeSaveParticipant ( getUniqueIdentifier ( ) ) ; if ( fThemeListener ! = null ) { if ( PlatformUI . isWorkbenchRunning ( ) ) { PlatformUI . getWorkbench ( ) . getThemeManager ( ) . removePropertyChangeListener ( fThemeListener ) ; } fThemeListener = null ; } } finally { super . stop ( context ) ; } } public boolean addSaveParticipant ( ISaveParticipant participant ) { return fSaveParticipants . add ( participant ) ; } public boolean removeSaveParticipant ( ISaveParticipant participant ) { return fSaveParticipants . remove ( participant ) ; } @Override public void start ( BundleContext context ) throws Exception { super . start ( context ) ; Hashtable < String , String > props = new Hashtable < String , String > ( <int> ) ; props . put ( org . eclipse . osgi . service . debug . DebugOptions . LISTENER_SYMBOLICNAME , getUniqueIdentifier ( ) ) ; context . registerService ( DebugOptionsListener . class . getName ( ) , this , props ) ; ResourcesPlugin . getWorkspace ( ) . addSaveParticipant ( getUniqueIdentifier ( ) , new ISaveParticipant ( ) { @Override public void saving ( ISaveContext saveContext ) throws CoreException { IEclipsePreferences node = InstanceScope . INSTANCE . getNode ( getUniqueIdentifier ( ) ) ; if ( node ! = null ) { try { node . flush ( ) ; } catch ( BackingStoreException e ) { log ( e ) ; } } for ( ISaveParticipant sp : fSaveParticipants ) { sp . saving ( saveContext ) ; } } @Override public void rollback ( ISaveContext saveContext ) { for ( ISaveParticipant sp : fSaveParticipants ) { sp . rollback ( saveContext ) ; } } @Override public void prepareToSave ( ISaveContext saveContext ) throws CoreException { for ( ISaveParticipant sp : fSaveParticipants ) { sp . prepareToSave ( saveContext ) ; } } @Override public void doneSaving ( ISaveContext saveContext ) { for ( ISaveParticipant sp : fSaveParticipants ) { sp . doneSaving ( saveContext ) ; } } } ) ; fPerspectiveManager = new PerspectiveManager ( ) ; fPerspectiveManager . startup ( ) ; getLaunchingResourceManager ( ) ; ILaunchManager launchManager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunch [ ] launches = launchManager . getLaunches ( ) ; if ( launches . length > <int> ) { initializeLaunchListeners ( ) ; } else { launchManager . addLaunchListener ( this ) ; } BreakpointOrganizerManager . getDefault ( ) ; getLaunchConfigurationManager ( ) . startup ( ) ; if ( PlatformUI . isWorkbenchRunning ( ) ) { fThemeListener = new IPropertyChangeListener ( ) { @Override public void propertyChange ( PropertyChangeEvent event ) { if ( IThemeManager . CHANGE_CURRENT_THEME . equals ( event . getProperty ( ) ) ) { DebugUIPreferenceInitializer . setThemeBasedPreferences ( getPreferenceStore ( ) , true ) ; } } } ; PlatformUI . getWorkbench ( ) . getThemeManager ( ) . addPropertyChangeListener ( fThemeListener ) ; } getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { SelectedResourceManager . getDefault ( ) ; getLaunchConfigurationManager ( ) . getLaunchShortcuts ( ) ; } } ) ; } @Override public void optionsChanged ( DebugOptions options ) { fgDebugTrace = options . newDebugTrace ( getUniqueIdentifier ( ) ) ; DEBUG = options . getBooleanOption ( DEBUG_FLAG , false ) ; DEBUG_BREAKPOINT_DELTAS = DEBUG & & options . getBooleanOption ( DEBUG_BREAKPOINT_DELTAS_FLAG , false ) ; DEBUG_MODEL = DEBUG & & options . getBooleanOption ( DEBUG_MODEL_FLAG , false ) ; DEBUG_VIEWER = DEBUG & & options . getBooleanOption ( DEBUG_VIEWER_FLAG , false ) ; DEBUG_BREADCRUMB = DEBUG & & options . getBooleanOption ( DEBUG_BREADCRUMB_FLAG , false ) ; DEBUG_TREE_VIEWER_DROPDOWN = DEBUG & & options . getBooleanOption ( DEBUG_TREE_VIEWER_DROPDOWN_FLAG , false ) ; DEBUG_CONTENT_PROVIDER = DEBUG & & options . getBooleanOption ( DEBUG_CONTENT_PROVIDER_FLAG , false ) ; DEBUG_UPDATE_SEQUENCE = DEBUG & & options . getBooleanOption ( DEBUG_UPDATE_SEQUENCE_FLAG , false ) ; DEBUG_DELTAS = DEBUG & & options . getBooleanOption ( DEBUG_DELTAS_FLAG , false ) ; DEBUG_STATE_SAVE_RESTORE = DEBUG & & options . getBooleanOption ( DEBUG_STATE_SAVE_RESTORE_FLAG , false ) ; DEBUG_DYNAMIC_LOADING = DEBUG & & options . getBooleanOption ( DEBUG_DYNAMIC_LOADING_FLAG , false ) ; if ( DEBUG ) { DEBUG_PRESENTATION_ID = options . getOption ( DEBUG_PRESENTATION_ID_FLAG , IInternalDebugCoreConstants . EMPTY_STRING ) ; if ( IInternalDebugCoreConstants . EMPTY_STRING . equals ( DEBUG_PRESENTATION_ID ) ) { DEBUG_PRESENTATION_ID = null ; } } } public static void errorDialog ( Shell shell , String title , String message , IStatus s ) { if ( s ! = null & & message . equals ( s . getMessage ( ) ) ) { message = null ; } ErrorDialog . openError ( shell , title , message , s ) ; } public static void errorDialog ( Shell shell , String title , String message , Throwable t ) { IStatus status ; if ( t instanceof CoreException ) { status = ( ( CoreException ) t ) . getStatus ( ) ; if ( status ! = null & & message . equals ( status . getMessage ( ) ) ) { message = null ; } } else { status = new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , IDebugUIConstants . INTERNAL_ERROR , <str> , t ) ; log ( status ) ; } ErrorDialog . openError ( shell , title , message , status ) ; } public static void log ( IStatus status ) { getDefault ( ) . getLog ( ) . log ( status ) ; } public static void log ( Throwable t ) { log ( newErrorStatus ( <str> , t ) ) ; } public static void logErrorMessage ( String message ) { log ( newErrorStatus ( <str> + message , null ) ) ; } public static IStatus newErrorStatus ( String message , Throwable exception ) { return new Status ( IStatus . ERROR , getUniqueIdentifier ( ) , IDebugUIConstants . INTERNAL_ERROR , message , exception ) ; } public static int openLaunchConfigurationEditDialog ( Shell shell , ILaunchConfiguration configuration , String groupIdentifier , IStatus status , boolean showCancel ) { LaunchGroupExtension group = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( group ! = null ) { LaunchConfigurationEditDialog dialog = new LaunchConfigurationEditDialog ( shell , configuration , group , showCancel ) ; dialog . setInitialStatus ( status ) ; return dialog . open ( ) ; } return Window . CANCEL ; } public static int openLaunchConfigurationPropertiesDialog ( Shell shell , ILaunchConfiguration configuration , String groupIdentifier , Set < String > reservednames , IStatus status , boolean setDefaults ) { LaunchGroupExtension group = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( group ! = null ) { LaunchConfigurationPropertiesDialog dialog = new LaunchConfigurationPropertiesDialog ( shell , configuration , group , reservednames ) ; dialog . setInitialStatus ( status ) ; dialog . setDefaultsOnOpen ( setDefaults ) ; return dialog . open ( ) ; } return Window . CANCEL ; } public static int openLaunchConfigurationsDialog ( Shell shell , IStructuredSelection selection , String groupIdentifier , boolean setDefaults ) { LaunchGroupExtension group = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( group ! = null ) { LaunchConfigurationsDialog dialog = new LaunchConfigurationsDialog ( shell , group ) ; dialog . setOpenMode ( LaunchConfigurationsDialog . LAUNCH_CONFIGURATION_DIALOG_OPEN_ON_SELECTION ) ; dialog . setInitialSelection ( selection ) ; dialog . setDefaultsOnOpen ( setDefaults ) ; return dialog . open ( ) ; } return Window . CANCEL ; } @Deprecated protected static boolean saveAllEditors ( boolean confirm ) { if ( getActiveWorkbenchWindow ( ) = = null ) { return false ; } return PlatformUI . getWorkbench ( ) . saveAllEditors ( confirm ) ; } @Deprecated public static boolean saveAndBuild ( ) { boolean status = true ; String saveDirty = getDefault ( ) . getPreferenceStore ( ) . getString ( IInternalDebugUIConstants . PREF_SAVE_DIRTY_EDITORS_BEFORE_LAUNCH ) ; boolean buildBeforeLaunch = getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_BUILD_BEFORE_LAUNCH ) ; if ( saveDirty . equals ( MessageDialogWithToggle . NEVER ) ) { if ( buildBeforeLaunch ) { return doBuild ( ) ; } } else { status = saveAllEditors ( saveDirty . equals ( MessageDialogWithToggle . PROMPT ) ) ; if ( status & & buildBeforeLaunch ) { status = doBuild ( ) ; } } return status ; } private static boolean doBuild ( ) { try { PlatformUI . getWorkbench ( ) . getProgressService ( ) . busyCursorWhile ( new IRunnableWithProgress ( ) { @Override public void run ( IProgressMonitor monitor ) throws InvocationTargetException { try { ResourcesPlugin . getWorkspace ( ) . build ( IncrementalProjectBuilder . INCREMENTAL_BUILD , monitor ) ; } catch ( CoreException e ) { throw new InvocationTargetException ( e ) ; } } } ) ; } catch ( InterruptedException e ) { return false ; } catch ( InvocationTargetException e ) { String title = DebugUIMessages . DebugUIPlugin_Run_Debug_1 ; String message = DebugUIMessages . DebugUIPlugin_Build_error__Check_log_for_details__2 ; Throwable t = e . getTargetException ( ) ; errorDialog ( getShell ( ) , title , message , t ) ; return false ; } return true ; } public static Display getStandardDisplay ( ) { return PlatformUI . getWorkbench ( ) . getDisplay ( ) ; } public static Color getPreferenceColor ( String type ) { return ColorManager . getDefault ( ) . getColor ( PreferenceConverter . getColor ( getDefault ( ) . getPreferenceStore ( ) , type ) ) ; } public ProcessConsoleManager getProcessConsoleManager ( ) { if ( fProcessConsoleManager = = null ) { fProcessConsoleManager = new ProcessConsoleManager ( ) ; } return fProcessConsoleManager ; } public static Document getDocument ( ) throws ParserConfigurationException { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document doc = docBuilder . newDocument ( ) ; return doc ; } @Override public void launchAdded ( ILaunch launch ) { DebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunchListener ( this ) ; initializeLaunchListeners ( ) ; } private void initializeLaunchListeners ( ) { getProcessConsoleManager ( ) . startup ( ) ; SourceLookupManager . getDefault ( ) ; } public PerspectiveManager getPerspectiveManager ( ) { return fPerspectiveManager ; } @Override public void launchChanged ( ILaunch launch ) { } @Override public void launchRemoved ( ILaunch launch ) { } public static final String formatKeyBindingString ( int modifierKeys , String keyOrClick ) { return KeyStroke . getInstance ( modifierKeys , KeyStroke . NO_KEY ) . format ( ) + keyOrClick ; } public static boolean DEBUG_TEST_PRESENTATION_ID ( IPresentationContext context ) { if ( context = = null ) { return true ; } return DEBUG_PRESENTATION_ID = = null | | DEBUG_PRESENTATION_ID . equals ( context . getId ( ) ) ; } public static ILaunch getLaunch ( Object element ) { ILaunch launch = ( ILaunch ) DebugPlugin . getAdapter ( element , ILaunch . class ) ; if ( launch = = null ) { if ( element instanceof IDebugElement ) { launch = ( ( IDebugElement ) element ) . getLaunch ( ) ; } else if ( element instanceof ILaunch ) { launch = ( ( ILaunch ) element ) ; } else if ( element instanceof IProcess ) { launch = ( ( IProcess ) element ) . getLaunch ( ) ; } } return launch ; } @Deprecated public static boolean preLaunchSave ( ) { String saveDirty = getDefault ( ) . getPreferenceStore ( ) . getString ( IInternalDebugUIConstants . PREF_SAVE_DIRTY_EDITORS_BEFORE_LAUNCH ) ; if ( saveDirty . equals ( MessageDialogWithToggle . NEVER ) ) { return true ; } return saveAllEditors ( saveDirty . equals ( MessageDialogWithToggle . PROMPT ) ) ; } public static ILaunch buildAndLaunch ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { boolean buildBeforeLaunch = getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_BUILD_BEFORE_LAUNCH ) ; monitor . beginTask ( IInternalDebugCoreConstants . EMPTY_STRING , <int> ) ; try { return configuration . launch ( mode , new SubProgressMonitor ( monitor , <int> ) , buildBeforeLaunch ) ; } finally { monitor . done ( ) ; } } public static void launchInForeground ( final ILaunchConfiguration configuration , final String mode ) { final IJobManager jobManager = Job . getJobManager ( ) ; IPreferenceStore store = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean wait = false ; if ( jobManager . find ( ResourcesPlugin . FAMILY_AUTO_BUILD ) . length > <int> | | jobManager . find ( ResourcesPlugin . FAMILY_MANUAL_BUILD ) . length > <int> ) { String waitForBuild = store . getString ( IInternalDebugUIConstants . PREF_WAIT_FOR_BUILD ) ; if ( waitForBuild . equals ( MessageDialogWithToggle . PROMPT ) ) { MessageDialogWithToggle dialog = MessageDialogWithToggle . openYesNoCancelQuestion ( getShell ( ) , DebugUIMessages . DebugUIPlugin_23 , DebugUIMessages . DebugUIPlugin_24 , null , false , store , IInternalDebugUIConstants . PREF_WAIT_FOR_BUILD ) ; switch ( dialog . getReturnCode ( ) ) { case IDialogConstants . CANCEL_ID : return ; case IDialogConstants . YES_ID : wait = false ; break ; case IDialogConstants . NO_ID : wait = true ; break ; default : break ; } } else if ( waitForBuild . equals ( MessageDialogWithToggle . ALWAYS ) ) { wait = true ; } } if ( wait ) { IWorkbench workbench = DebugUIPlugin . getDefault ( ) . getWorkbench ( ) ; IProgressService progressService = workbench . getProgressService ( ) ; final IRunnableWithProgress runnable = new IRunnableWithProgress ( ) { @Override public void run ( IProgressMonitor monitor ) throws InvocationTargetException { monitor . beginTask ( MessageFormat . format ( DebugUIMessages . DebugUIPlugin_25 , new Object [ ] { configuration . getName ( ) } ) , <int> ) ; try { jobManager . join ( ResourcesPlugin . FAMILY_MANUAL_BUILD , new SubProgressMonitor ( monitor , <int> ) ) ; jobManager . join ( ResourcesPlugin . FAMILY_AUTO_BUILD , new SubProgressMonitor ( monitor , <int> ) ) ; } catch ( InterruptedException e ) { } if ( ! monitor . isCanceled ( ) ) { try { buildAndLaunch ( configuration , mode , new SubProgressMonitor ( monitor , <int> ) ) ; } catch ( CoreException e ) { throw new InvocationTargetException ( e ) ; } } } } ; try { progressService . busyCursorWhile ( runnable ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e2 ) { handleInvocationTargetException ( e2 , configuration , mode ) ; } } else { IRunnableWithProgress runnable = new IRunnableWithProgress ( ) { @Override public void run ( IProgressMonitor monitor ) throws InvocationTargetException { monitor . beginTask ( MessageFormat . format ( DebugUIMessages . DebugUIPlugin_25 , new Object [ ] { configuration . getName ( ) } ) , <int> ) ; try { buildAndLaunch ( configuration , mode , new SubProgressMonitor ( monitor , <int> ) ) ; } catch ( CoreException e ) { throw new InvocationTargetException ( e ) ; } } } ; try { PlatformUI . getWorkbench ( ) . getProgressService ( ) . busyCursorWhile ( runnable ) ; } catch ( InvocationTargetException e ) { handleInvocationTargetException ( e , configuration , mode ) ; } catch ( InterruptedException e ) { } } } private static void handleInvocationTargetException ( InvocationTargetException e , ILaunchConfiguration configuration , String mode ) { Throwable targetException = e . getTargetException ( ) ; Throwable t = e ; if ( targetException instanceof CoreException ) { t = targetException ; } if ( t instanceof CoreException ) { CoreException ce = ( CoreException ) t ; IStatusHandler handler = DebugPlugin . getDefault ( ) . getStatusHandler ( ce . getStatus ( ) ) ; if ( handler ! = null ) { ILaunchGroup group = DebugUITools . getLaunchGroup ( configuration , mode ) ; if ( group ! = null ) { DebugUITools . openLaunchConfigurationDialogOnGroup ( DebugUIPlugin . getShell ( ) , new StructuredSelection ( configuration ) , group . getIdentifier ( ) , ce . getStatus ( ) ) ; return ; } } if ( ( ce . getStatus ( ) . getSeverity ( ) & ( IStatus . ERROR | IStatus . WARNING ) ) = = <int> ) { return ; } } DebugUIPlugin . errorDialog ( DebugUIPlugin . getShell ( ) , DebugUIMessages . DebugUITools_Error_1 , DebugUIMessages . DebugUITools_Exception_occurred_during_launch_2 , t ) ; } public static void launchInBackground ( final ILaunchConfiguration configuration , final String mode ) { final IJobManager jobManager = Job . getJobManager ( ) ; IPreferenceStore store = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean wait = ( jobManager . find ( ResourcesPlugin . FAMILY_AUTO_BUILD ) . length > <int> & & ResourcesPlugin . getWorkspace ( ) . isAutoBuilding ( ) ) | | ( jobManager . find ( ResourcesPlugin . FAMILY_MANUAL_BUILD ) . length > <int> ) ; String waitPref = store . getString ( IInternalDebugUIConstants . PREF_WAIT_FOR_BUILD ) ; if ( wait ) { if ( waitPref . equals ( MessageDialogWithToggle . PROMPT ) ) { MessageDialogWithToggle dialog = MessageDialogWithToggle . openYesNoCancelQuestion ( getShell ( ) , DebugUIMessages . DebugUIPlugin_23 , DebugUIMessages . DebugUIPlugin_24 , null , false , store , IInternalDebugUIConstants . PREF_WAIT_FOR_BUILD ) ; switch ( dialog . getReturnCode ( ) ) { case IDialogConstants . CANCEL_ID : return ; case IDialogConstants . YES_ID : wait = true ; break ; case IDialogConstants . NO_ID : wait = false ; break ; default : break ; } } else { wait = waitPref . equals ( MessageDialogWithToggle . ALWAYS ) ; } } final boolean waitInJob = wait ; Job job = new Job ( MessageFormat . format ( DebugUIMessages . DebugUIPlugin_25 , new Object [ ] { configuration . getName ( ) } ) ) { @Override public IStatus run ( final IProgressMonitor monitor ) { monitor . beginTask ( DebugUIMessages . DebugUITools_3 , <int> ) ; try { if ( waitInJob ) { StringBuffer buffer = new StringBuffer ( configuration . getName ( ) ) ; buffer . append ( DebugUIMessages . DebugUIPlugin_0 ) ; ILaunchConfigurationWorkingCopy workingCopy = configuration . copy ( buffer . toString ( ) ) ; workingCopy . setAttribute ( ATTR_LAUNCHING_CONFIG_HANDLE , configuration . getMemento ( ) ) ; final ILaunch pendingLaunch = new PendingLaunch ( workingCopy , mode , this ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunch ( pendingLaunch ) ; IJobChangeListener listener = new IJobChangeListener ( ) { @Override public void sleeping ( IJobChangeEvent event ) { } @Override public void scheduled ( IJobChangeEvent event ) { } @Override public void running ( IJobChangeEvent event ) { } @Override public void awake ( IJobChangeEvent event ) { } @Override public void aboutToRun ( IJobChangeEvent event ) { } @Override public void done ( IJobChangeEvent event ) { DebugPlugin dp = DebugPlugin . getDefault ( ) ; if ( dp ! = null ) { dp . getLaunchManager ( ) . removeLaunch ( pendingLaunch ) ; } removeJobChangeListener ( this ) ; } } ; addJobChangeListener ( listener ) ; try { jobManager . join ( ResourcesPlugin . FAMILY_MANUAL_BUILD , new SubProgressMonitor ( monitor , <int> ) ) ; jobManager . join ( ResourcesPlugin . FAMILY_AUTO_BUILD , new SubProgressMonitor ( monitor , <int> ) ) ; } catch ( InterruptedException e ) { } DebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunch ( pendingLaunch ) ; } else { monitor . worked ( <int> ) ; } if ( ! monitor . isCanceled ( ) ) { buildAndLaunch ( configuration , mode , new SubProgressMonitor ( monitor , <int> ) ) ; } } catch ( CoreException e ) { final IStatus status = e . getStatus ( ) ; IStatusHandler handler = DebugPlugin . getDefault ( ) . getStatusHandler ( status ) ; if ( handler = = null ) { return status ; } final ILaunchGroup group = DebugUITools . getLaunchGroup ( configuration , mode ) ; if ( group = = null ) { return status ; } Runnable r = new Runnable ( ) { @Override public void run ( ) { DebugUITools . openLaunchConfigurationDialogOnGroup ( DebugUIPlugin . getShell ( ) , new StructuredSelection ( configuration ) , group . getIdentifier ( ) , status ) ; } } ; DebugUIPlugin . getStandardDisplay ( ) . asyncExec ( r ) ; } finally { monitor . done ( ) ; } return Status . OK_STATUS ; } } ; IWorkbench workbench = DebugUIPlugin . getDefault ( ) . getWorkbench ( ) ; IProgressService progressService = workbench . getProgressService ( ) ; job . setPriority ( Job . INTERACTIVE ) ; job . setProperty ( IProgressConstants2 . SHOW_IN_TASKBAR_ICON_PROPERTY , Boolean . TRUE ) ; job . setName ( MessageFormat . format ( DebugUIMessages . DebugUIPlugin_25 , new Object [ ] { configuration . getName ( ) } ) ) ; if ( wait ) { progressService . showInDialog ( workbench . getActiveWorkbenchWindow ( ) . getShell ( ) , job ) ; } job . schedule ( ) ; } public static String removeAccelerators ( String label ) { String title = label ; if ( title ! = null ) { int index = title . indexOf ( <str> ) ; if ( index = = <int> ) { title = title . substring ( <int> ) ; } else if ( index > <int> ) { if ( title . charAt ( index - <int> ) = = <str> & & title . length ( ) > = index + <int> & & title . charAt ( index + <int> ) = = <str> ) { String first = title . substring ( <int> , index - <int> ) ; String last = title . substring ( index + <int> ) ; title = first + last ; } else if ( index < ( title . length ( ) - <int> ) ) { String first = title . substring ( <int> , index ) ; String last = title . substring ( index + <int> ) ; title = first + last ; } } } return title ; } public static String adjustDBCSAccelerator ( String label ) { String title = label ; if ( title ! = null ) { int index = title . indexOf ( <str> ) ; if ( index > <int> ) { if ( title . charAt ( index - <int> ) = = <str> & & title . length ( ) > = index + <int> & & title . charAt ( index + <int> ) = = <str> ) { String first = title . substring ( <int> , index - <int> ) ; String accel = title . substring ( index - <int> , index + <int> ) ; String last = title . substring ( index + <int> ) ; title = first + last ; if ( title . endsWith ( <str> ) ) { title = title . substring ( <int> , title . length ( ) - <int> ) ; title = title + accel + <str> ; } else { title = title + accel ; } } } } return title ; } public static ImageDescriptorRegistry getImageDescriptorRegistry ( ) { if ( getDefault ( ) . fImageDescriptorRegistry = = null ) { getDefault ( ) . fImageDescriptorRegistry = new ImageDescriptorRegistry ( ) ; } return getDefault ( ) . fImageDescriptorRegistry ; } public static ImageDescriptor getImageDescriptor ( IConfigurationElement element , String attr ) { Bundle bundle = Platform . getBundle ( element . getContributor ( ) . getName ( ) ) ; String iconPath = element . getAttribute ( attr ) ; if ( iconPath ! = null ) { URL iconURL = FileLocator . find ( bundle , new Path ( iconPath ) , null ) ; if ( iconURL ! = null ) { return ImageDescriptor . createFromURL ( iconURL ) ; } else { try { iconURL = FileLocator . find ( new URL ( iconPath ) ) ; if ( iconURL ! = null ) { return ImageDescriptor . createFromURL ( iconURL ) ; } } catch ( MalformedURLException e ) { } } } return null ; } public static ImageDescriptor getImageDescriptor ( String name , String path ) { Bundle bundle = Platform . getBundle ( name ) ; if ( path ! = null ) { URL iconURL = FileLocator . find ( bundle , new Path ( path ) , null ) ; if ( iconURL ! = null ) { return ImageDescriptor . createFromURL ( iconURL ) ; } } return null ; } public static boolean doLaunchConfigurationFiltering ( ILaunchConfiguration config ) { boolean ret = true ; if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_FILTER_LAUNCH_CLOSED ) ) { ret & = new ClosedProjectFilter ( ) . select ( null , null , config ) ; } if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_FILTER_LAUNCH_DELETED ) ) { ret & = new DeletedProjectFilter ( ) . select ( null , null , config ) ; } if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_FILTER_LAUNCH_TYPES ) ) { try { ret & = new LaunchConfigurationTypeFilter ( ) . select ( null , null , config . getType ( ) ) ; } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } } return ret ; } public static IEvaluationContext createEvaluationContext ( Object defaultvar ) { IEvaluationContext parent = null ; IEvaluationService esrvc = PlatformUI . getWorkbench ( ) . getService ( IEvaluationService . class ) ; if ( esrvc ! = null ) { parent = esrvc . getCurrentState ( ) ; } return new EvaluationContext ( parent , defaultvar ) ; } }