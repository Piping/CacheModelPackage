package org . eclipse . ui . internal . console ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DocumentEvent ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentAdapter ; import org . eclipse . jface . text . IDocumentListener ; import org . eclipse . swt . custom . TextChangeListener ; import org . eclipse . swt . custom . TextChangedEvent ; import org . eclipse . swt . custom . TextChangingEvent ; public class ConsoleDocumentAdapter implements IDocumentAdapter , IDocumentListener { private int consoleWidth = - <int> ; private List < TextChangeListener > textChangeListeners ; private IDocument document ; int [ ] offsets = new int [ <int> ] ; int [ ] lengths = new int [ <int> ] ; private int regionCount = <int> ; private Pattern pattern = Pattern . compile ( <str> , Pattern . MULTILINE ) ; public ConsoleDocumentAdapter ( int width ) { textChangeListeners = new ArrayList < TextChangeListener > ( ) ; consoleWidth = width ; } private void repairLines ( int eventOffset ) { if ( document = = null ) { return ; } try { int docLine = document . getLineOfOffset ( eventOffset ) ; int docLineOffset = document . getLineOffset ( docLine ) ; int widgetLine = getLineAtOffset ( docLineOffset ) ; for ( int i = regionCount - <int> ; i > = widgetLine ; i - - ) { regionCount - - ; } int numLinesInDoc = document . getNumberOfLines ( ) ; int nextOffset = document . getLineOffset ( docLine ) ; for ( int i = docLine ; i < numLinesInDoc ; i + + ) { int offset = nextOffset ; int length = document . getLineLength ( i ) ; nextOffset + = length ; if ( length = = <int> ) { addRegion ( offset , <int> ) ; } else { while ( length > <int> ) { int trimmedLength = length ; String lineDelimiter = document . getLineDelimiter ( i ) ; int lineDelimiterLength = <int> ; if ( lineDelimiter ! = null ) { lineDelimiterLength = lineDelimiter . length ( ) ; trimmedLength - = lineDelimiterLength ; } if ( consoleWidth > <int> & & consoleWidth < trimmedLength ) { addRegion ( offset , consoleWidth ) ; offset + = consoleWidth ; length - = consoleWidth ; } else { addRegion ( offset , length ) ; offset + = length ; length - = length ; } } } } } catch ( BadLocationException e ) { } if ( regionCount = = <int> ) { addRegion ( <int> , document . getLength ( ) ) ; } } private void addRegion ( int offset , int length ) { if ( regionCount = = <int> ) { offsets [ <int> ] = offset ; lengths [ <int> ] = length ; } else { if ( regionCount = = offsets . length ) { growRegionArray ( regionCount * <int> ) ; } offsets [ regionCount ] = offset ; lengths [ regionCount ] = length ; } regionCount + + ; } @Override public void setDocument ( IDocument doc ) { if ( document ! = null ) { document . removeDocumentListener ( this ) ; } document = doc ; if ( document ! = null ) { document . addDocumentListener ( this ) ; repairLines ( <int> ) ; } } @Override public synchronized void addTextChangeListener ( TextChangeListener listener ) { Assert . isNotNull ( listener ) ; if ( ! textChangeListeners . contains ( listener ) ) { textChangeListeners . add ( listener ) ; } } @Override public synchronized void removeTextChangeListener ( TextChangeListener listener ) { if ( textChangeListeners ! = null ) { Assert . isNotNull ( listener ) ; textChangeListeners . remove ( listener ) ; } } @Override public int getCharCount ( ) { return document . getLength ( ) ; } @Override public String getLine ( int lineIndex ) { try { StringBuffer line = new StringBuffer ( document . get ( offsets [ lineIndex ] , lengths [ lineIndex ] ) ) ; int index = line . length ( ) - <int> ; while ( index > - <int> & & ( line . charAt ( index ) = = <str> | | line . charAt ( index ) = = <str> ) ) { index - - ; } return new String ( line . substring ( <int> , index + <int> ) ) ; } catch ( BadLocationException e ) { } return <str> ; } @Override public int getLineAtOffset ( int offset ) { if ( offset = = <int> | | regionCount < = <int> ) { return <int> ; } if ( offset = = document . getLength ( ) ) { return regionCount - <int> ; } int left = <int> ; int right = regionCount - <int> ; int midIndex = <int> ; while ( left < = right ) { if ( left = = right ) { return right ; } midIndex = ( left + right ) / <int> ; if ( offset < offsets [ midIndex ] ) { right = midIndex ; } else if ( offset > = offsets [ midIndex ] + lengths [ midIndex ] ) { left = midIndex + <int> ; } else { return midIndex ; } } return midIndex ; } @Override public int getLineCount ( ) { return regionCount ; } @Override public String getLineDelimiter ( ) { return System . getProperty ( <str> ) ; } @Override public int getOffsetAtLine ( int lineIndex ) { return offsets [ lineIndex ] ; } @Override public String getTextRange ( int start , int length ) { try { return document . get ( start , length ) ; } catch ( BadLocationException e ) { } return null ; } @Override public void replaceTextRange ( int start , int replaceLength , String text ) { try { document . replace ( start , replaceLength , text ) ; } catch ( BadLocationException e ) { } } @Override public synchronized void setText ( String text ) { TextChangedEvent changeEvent = new TextChangedEvent ( this ) ; for ( TextChangeListener listener : textChangeListeners ) { listener . textSet ( changeEvent ) ; } } @Override public synchronized void documentAboutToBeChanged ( DocumentEvent event ) { if ( document = = null ) { return ; } TextChangingEvent changeEvent = new TextChangingEvent ( this ) ; changeEvent . start = event . fOffset ; changeEvent . newText = ( event . fText = = null ? <str> : event . fText ) ; changeEvent . replaceCharCount = event . fLength ; changeEvent . newCharCount = ( event . fText = = null ? <int> : event . fText . length ( ) ) ; int first = getLineAtOffset ( event . fOffset ) ; int lOffset = Math . max ( event . fOffset + event . fLength - <int> , <int> ) ; int last = getLineAtOffset ( lOffset ) ; changeEvent . replaceLineCount = Math . max ( last - first , <int> ) ; int newLineCount = countNewLines ( event . fText ) ; changeEvent . newLineCount = newLineCount > = <int> ? newLineCount : <int> ; if ( changeEvent . newLineCount > offsets . length - regionCount ) { growRegionArray ( changeEvent . newLineCount ) ; } for ( TextChangeListener listener : textChangeListeners ) { listener . textChanging ( changeEvent ) ; } } private void growRegionArray ( int minSize ) { int size = Math . max ( offsets . length * <int> , minSize * <int> ) ; int [ ] newOffsets = new int [ size ] ; System . arraycopy ( offsets , <int> , newOffsets , <int> , regionCount ) ; offsets = newOffsets ; int [ ] newLengths = new int [ size ] ; System . arraycopy ( lengths , <int> , newLengths , <int> , regionCount ) ; lengths = newLengths ; } private int countNewLines ( String string ) { int count = <int> ; if ( string . length ( ) = = <int> ) { return <int> ; } int offset = string . length ( ) - <int> ; while ( offset > - <int> & & string . charAt ( offset ) = = <str> ) { offset - - ; count + + ; } if ( offset > - <int> ) { String str = string ; if ( offset < ( str . length ( ) - <int> ) ) { str = str . substring ( <int> , offset ) ; } int lastIndex = <int> ; int index = <int> ; Matcher matcher = pattern . matcher ( str ) ; while ( matcher . find ( ) ) { index = matcher . start ( ) ; if ( index = = <int> ) { count + + ; } else if ( index ! = str . length ( ) ) { count + + ; } if ( consoleWidth > <int> ) { int lineLen = index - lastIndex + <int> ; if ( index = = <int> ) { lineLen + = lengths [ regionCount - <int> ] ; } count + = lineLen / consoleWidth ; } lastIndex = index ; } } return count ; } @Override public synchronized void documentChanged ( DocumentEvent event ) { if ( document = = null ) { return ; } repairLines ( event . fOffset ) ; TextChangedEvent changeEvent = new TextChangedEvent ( this ) ; for ( TextChangeListener listener : textChangeListeners ) { listener . textChanged ( changeEvent ) ; } } public void setWidth ( int width ) { if ( width ! = consoleWidth ) { consoleWidth = width ; repairLines ( <int> ) ; TextChangedEvent changeEvent = new TextChangedEvent ( this ) ; for ( TextChangeListener listener : textChangeListeners ) { listener . textSet ( changeEvent ) ; } } } }