package org . elasticsearch . action . admin . cluster . snapshots . status ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . SnapshotsInProgress ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . snapshots . IndexShardSnapshotStatus ; import org . elasticsearch . snapshots . Snapshot ; import org . elasticsearch . snapshots . SnapshotsService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class TransportSnapshotsStatusAction extends TransportMasterNodeAction < SnapshotsStatusRequest , SnapshotsStatusResponse > { private final SnapshotsService snapshotsService ; private final TransportNodesSnapshotsStatus transportNodesSnapshotsStatus ; @Inject public TransportSnapshotsStatusAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , SnapshotsService snapshotsService , TransportNodesSnapshotsStatus transportNodesSnapshotsStatus , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , SnapshotsStatusAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , SnapshotsStatusRequest : : new ) ; this . snapshotsService = snapshotsService ; this . transportNodesSnapshotsStatus = transportNodesSnapshotsStatus ; } @Override protected String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override protected ClusterBlockException checkBlock ( SnapshotsStatusRequest request , ClusterState state ) { return state . blocks ( ) . globalBlockedException ( ClusterBlockLevel . METADATA_READ ) ; } @Override protected SnapshotsStatusResponse newResponse ( ) { return new SnapshotsStatusResponse ( ) ; } @Override protected void masterOperation ( final SnapshotsStatusRequest request , final ClusterState state , final ActionListener < SnapshotsStatusResponse > listener ) throws Exception { List < SnapshotsInProgress . Entry > currentSnapshots = snapshotsService . currentSnapshots ( request . repository ( ) , request . snapshots ( ) ) ; if ( currentSnapshots . isEmpty ( ) ) { listener . onResponse ( buildResponse ( request , currentSnapshots , null ) ) ; return ; } Set < String > nodesIds = new HashSet < > ( ) ; for ( SnapshotsInProgress . Entry entry : currentSnapshots ) { for ( ObjectCursor < SnapshotsInProgress . ShardSnapshotStatus > status : entry . shards ( ) . values ( ) ) { if ( status . value . nodeId ( ) ! = null ) { nodesIds . add ( status . value . nodeId ( ) ) ; } } } if ( ! nodesIds . isEmpty ( ) ) { SnapshotId [ ] snapshotIds = new SnapshotId [ currentSnapshots . size ( ) ] ; for ( int i = <int> ; i < currentSnapshots . size ( ) ; i + + ) { snapshotIds [ i ] = currentSnapshots . get ( i ) . snapshotId ( ) ; } TransportNodesSnapshotsStatus . Request nodesRequest = new TransportNodesSnapshotsStatus . Request ( request , nodesIds . toArray ( new String [ nodesIds . size ( ) ] ) ) . snapshotIds ( snapshotIds ) . timeout ( request . masterNodeTimeout ( ) ) ; transportNodesSnapshotsStatus . execute ( nodesRequest , new ActionListener < TransportNodesSnapshotsStatus . NodesSnapshotStatus > ( ) { @Override public void onResponse ( TransportNodesSnapshotsStatus . NodesSnapshotStatus nodeSnapshotStatuses ) { try { List < SnapshotsInProgress . Entry > currentSnapshots = snapshotsService . currentSnapshots ( request . repository ( ) , request . snapshots ( ) ) ; listener . onResponse ( buildResponse ( request , currentSnapshots , nodeSnapshotStatuses ) ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; } } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } ) ; } else { listener . onResponse ( buildResponse ( request , currentSnapshots , null ) ) ; } } private SnapshotsStatusResponse buildResponse ( SnapshotsStatusRequest request , List < SnapshotsInProgress . Entry > currentSnapshots , TransportNodesSnapshotsStatus . NodesSnapshotStatus nodeSnapshotStatuses ) throws IOException { List < SnapshotStatus > builder = new ArrayList < > ( ) ; Set < SnapshotId > currentSnapshotIds = new HashSet < > ( ) ; if ( ! currentSnapshots . isEmpty ( ) ) { Map < String , TransportNodesSnapshotsStatus . NodeSnapshotStatus > nodeSnapshotStatusMap ; if ( nodeSnapshotStatuses ! = null ) { nodeSnapshotStatusMap = nodeSnapshotStatuses . getNodesMap ( ) ; } else { nodeSnapshotStatusMap = new HashMap < > ( ) ; } for ( SnapshotsInProgress . Entry entry : currentSnapshots ) { currentSnapshotIds . add ( entry . snapshotId ( ) ) ; List < SnapshotIndexShardStatus > shardStatusBuilder = new ArrayList < > ( ) ; for ( ObjectObjectCursor < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shardEntry : entry . shards ( ) ) { SnapshotsInProgress . ShardSnapshotStatus status = shardEntry . value ; if ( status . nodeId ( ) ! = null ) { TransportNodesSnapshotsStatus . NodeSnapshotStatus nodeStatus = nodeSnapshotStatusMap . get ( status . nodeId ( ) ) ; if ( nodeStatus ! = null ) { Map < ShardId , SnapshotIndexShardStatus > shardStatues = nodeStatus . status ( ) . get ( entry . snapshotId ( ) ) ; if ( shardStatues ! = null ) { SnapshotIndexShardStatus shardStatus = shardStatues . get ( shardEntry . key ) ; if ( shardStatus ! = null ) { shardStatusBuilder . add ( shardStatus ) ; continue ; } } } } final SnapshotIndexShardStage stage ; switch ( shardEntry . value . state ( ) ) { case FAILED : case ABORTED : case MISSING : stage = SnapshotIndexShardStage . FAILURE ; break ; case INIT : case WAITING : case STARTED : stage = SnapshotIndexShardStage . STARTED ; break ; case SUCCESS : stage = SnapshotIndexShardStage . DONE ; break ; default : throw new IllegalArgumentException ( <str> + shardEntry . value . state ( ) ) ; } SnapshotIndexShardStatus shardStatus = new SnapshotIndexShardStatus ( shardEntry . key , stage ) ; shardStatusBuilder . add ( shardStatus ) ; } builder . add ( new SnapshotStatus ( entry . snapshotId ( ) , entry . state ( ) , Collections . unmodifiableList ( shardStatusBuilder ) ) ) ; } } if ( Strings . hasText ( request . repository ( ) ) ) { if ( request . snapshots ( ) ! = null & & request . snapshots ( ) . length > <int> ) { for ( String snapshotName : request . snapshots ( ) ) { SnapshotId snapshotId = new SnapshotId ( request . repository ( ) , snapshotName ) ; if ( currentSnapshotIds . contains ( snapshotId ) ) { continue ; } Snapshot snapshot = snapshotsService . snapshot ( snapshotId ) ; List < SnapshotIndexShardStatus > shardStatusBuilder = new ArrayList < > ( ) ; if ( snapshot . state ( ) . completed ( ) ) { Map < ShardId , IndexShardSnapshotStatus > shardStatues = snapshotsService . snapshotShards ( snapshotId ) ; for ( Map . Entry < ShardId , IndexShardSnapshotStatus > shardStatus : shardStatues . entrySet ( ) ) { shardStatusBuilder . add ( new SnapshotIndexShardStatus ( shardStatus . getKey ( ) , shardStatus . getValue ( ) ) ) ; } final SnapshotsInProgress . State state ; switch ( snapshot . state ( ) ) { case FAILED : state = SnapshotsInProgress . State . FAILED ; break ; case SUCCESS : case PARTIAL : state = SnapshotsInProgress . State . SUCCESS ; break ; default : throw new IllegalArgumentException ( <str> + snapshot . state ( ) ) ; } builder . add ( new SnapshotStatus ( snapshotId , state , Collections . unmodifiableList ( shardStatusBuilder ) ) ) ; } } } } return new SnapshotsStatusResponse ( Collections . unmodifiableList ( builder ) ) ; } } 
