package org . elasticsearch . action . admin . indices . create ; import java . nio . charset . StandardCharsets ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . master . AcknowledgedRequest ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import java . io . IOException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . action . ValidateActions . addValidationError ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; import static org . elasticsearch . common . settings . Settings . readSettingsFromStream ; import static org . elasticsearch . common . settings . Settings . writeSettingsToStream ; public class CreateIndexRequest extends AcknowledgedRequest < CreateIndexRequest > implements IndicesRequest { private String cause = <str> ; private String index ; private Settings settings = EMPTY_SETTINGS ; private final Map < String , String > mappings = new HashMap < > ( ) ; private final Set < Alias > aliases = new HashSet < > ( ) ; private final Map < String , IndexMetaData . Custom > customs = new HashMap < > ( ) ; private boolean updateAllTypes = false ; public CreateIndexRequest ( ) { } public CreateIndexRequest ( ActionRequest request ) { super ( request ) ; } public CreateIndexRequest ( String index ) { this ( index , EMPTY_SETTINGS ) ; } public CreateIndexRequest ( String index , Settings settings ) { this . index = index ; this . settings = settings ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( index = = null ) { validationException = addValidationError ( <str> , validationException ) ; } return validationException ; } @Override public String [ ] indices ( ) { return new String [ ] { index } ; } @Override public IndicesOptions indicesOptions ( ) { return IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ; } public String index ( ) { return index ; } public CreateIndexRequest index ( String index ) { this . index = index ; return this ; } public Settings settings ( ) { return settings ; } public String cause ( ) { return cause ; } public CreateIndexRequest settings ( Object . . . settings ) { this . settings = Settings . builder ( ) . put ( settings ) . build ( ) ; return this ; } public CreateIndexRequest settings ( Settings settings ) { this . settings = settings ; return this ; } public CreateIndexRequest settings ( Settings . Builder settings ) { this . settings = settings . build ( ) ; return this ; } public CreateIndexRequest settings ( String source ) { this . settings = Settings . settingsBuilder ( ) . loadFromSource ( source ) . build ( ) ; return this ; } public CreateIndexRequest settings ( XContentBuilder builder ) { try { settings ( builder . string ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } return this ; } @SuppressWarnings ( <str> ) public CreateIndexRequest settings ( Map source ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( source ) ; settings ( builder . string ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } return this ; } public CreateIndexRequest mapping ( String type , String source ) { if ( mappings . containsKey ( type ) ) { throw new IllegalStateException ( <str> + type + <str> ) ; } mappings . put ( type , source ) ; return this ; } public CreateIndexRequest cause ( String cause ) { this . cause = cause ; return this ; } public CreateIndexRequest mapping ( String type , XContentBuilder source ) { if ( mappings . containsKey ( type ) ) { throw new IllegalStateException ( <str> + type + <str> ) ; } try { mappings . put ( type , source . string ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } return this ; } @SuppressWarnings ( <str> ) public CreateIndexRequest mapping ( String type , Map source ) { if ( mappings . containsKey ( type ) ) { throw new IllegalStateException ( <str> + type + <str> ) ; } if ( source . size ( ) ! = <int> | | ! source . containsKey ( type ) ) { source = MapBuilder . < String , Object > newMapBuilder ( ) . put ( type , source ) . map ( ) ; } try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( source ) ; return mapping ( type , builder . string ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } } public CreateIndexRequest mapping ( String type , Object . . . source ) { mapping ( type , PutMappingRequest . buildFromSimplifiedDef ( type , source ) ) ; return this ; } @SuppressWarnings ( <str> ) public CreateIndexRequest aliases ( Map source ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; builder . map ( source ) ; return aliases ( builder . bytes ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } } public CreateIndexRequest aliases ( XContentBuilder source ) { return aliases ( source . bytes ( ) ) ; } public CreateIndexRequest aliases ( String source ) { return aliases ( new BytesArray ( source ) ) ; } public CreateIndexRequest aliases ( BytesReference source ) { try { XContentParser parser = XContentHelper . createParser ( source ) ; parser . nextToken ( ) ; while ( ( parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { alias ( Alias . fromXContent ( parser ) ) ; } return this ; } catch ( IOException e ) { throw new ElasticsearchParseException ( <str> , e ) ; } } public CreateIndexRequest alias ( Alias alias ) { this . aliases . add ( alias ) ; return this ; } public CreateIndexRequest source ( String source ) { return source ( source . getBytes ( StandardCharsets . UTF_8 ) ) ; } public CreateIndexRequest source ( XContentBuilder source ) { return source ( source . bytes ( ) ) ; } public CreateIndexRequest source ( byte [ ] source ) { return source ( source , <int> , source . length ) ; } public CreateIndexRequest source ( byte [ ] source , int offset , int length ) { return source ( new BytesArray ( source , offset , length ) ) ; } public CreateIndexRequest source ( BytesReference source ) { XContentType xContentType = XContentFactory . xContentType ( source ) ; if ( xContentType ! = null ) { try ( XContentParser parser = XContentFactory . xContent ( xContentType ) . createParser ( source ) ) { source ( parser . map ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchParseException ( <str> , e ) ; } } else { settings ( new String ( source . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; } return this ; } @SuppressWarnings ( <str> ) public CreateIndexRequest source ( Map < String , ? > source ) { boolean found = false ; for ( Map . Entry < String , ? > entry : source . entrySet ( ) ) { String name = entry . getKey ( ) ; if ( name . equals ( <str> ) ) { found = true ; settings ( ( Map < String , Object > ) entry . getValue ( ) ) ; } else if ( name . equals ( <str> ) ) { found = true ; Map < String , Object > mappings = ( Map < String , Object > ) entry . getValue ( ) ; for ( Map . Entry < String , Object > entry1 : mappings . entrySet ( ) ) { mapping ( entry1 . getKey ( ) , ( Map < String , Object > ) entry1 . getValue ( ) ) ; } } else if ( name . equals ( <str> ) ) { found = true ; aliases ( ( Map < String , Object > ) entry . getValue ( ) ) ; } else { IndexMetaData . Custom proto = IndexMetaData . lookupPrototype ( name ) ; if ( proto ! = null ) { found = true ; try { customs . put ( name , proto . fromMap ( ( Map < String , Object > ) entry . getValue ( ) ) ) ; } catch ( IOException e ) { throw new ElasticsearchParseException ( <str> , name ) ; } } } } if ( ! found ) { settings ( source ) ; } return this ; } public Map < String , String > mappings ( ) { return this . mappings ; } public Set < Alias > aliases ( ) { return this . aliases ; } public CreateIndexRequest custom ( IndexMetaData . Custom custom ) { customs . put ( custom . type ( ) , custom ) ; return this ; } public Map < String , IndexMetaData . Custom > customs ( ) { return this . customs ; } public boolean updateAllTypes ( ) { return updateAllTypes ; } public CreateIndexRequest updateAllTypes ( boolean updateAllTypes ) { this . updateAllTypes = updateAllTypes ; return this ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; cause = in . readString ( ) ; index = in . readString ( ) ; settings = readSettingsFromStream ( in ) ; readTimeout ( in ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { mappings . put ( in . readString ( ) , in . readString ( ) ) ; } int customSize = in . readVInt ( ) ; for ( int i = <int> ; i < customSize ; i + + ) { String type = in . readString ( ) ; IndexMetaData . Custom customIndexMetaData = IndexMetaData . lookupPrototypeSafe ( type ) . readFrom ( in ) ; customs . put ( type , customIndexMetaData ) ; } int aliasesSize = in . readVInt ( ) ; for ( int i = <int> ; i < aliasesSize ; i + + ) { aliases . add ( Alias . read ( in ) ) ; } updateAllTypes = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( cause ) ; out . writeString ( index ) ; writeSettingsToStream ( settings , out ) ; writeTimeout ( out ) ; out . writeVInt ( mappings . size ( ) ) ; for ( Map . Entry < String , String > entry : mappings . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeString ( entry . getValue ( ) ) ; } out . writeVInt ( customs . size ( ) ) ; for ( Map . Entry < String , IndexMetaData . Custom > entry : customs . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; entry . getValue ( ) . writeTo ( out ) ; } out . writeVInt ( aliases . size ( ) ) ; for ( Alias alias : aliases ) { alias . writeTo ( out ) ; } out . writeBoolean ( updateAllTypes ) ; } } 
