package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . glutils . FrameBuffer ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . tests . utils . GdxTest ; public class FrameBufferTest extends GdxTest { FrameBuffer stencilFrameBuffer ; FrameBuffer frameBuffer ; Mesh mesh ; Mesh stencilMesh ; ShaderProgram meshShader ; Texture texture ; SpriteBatch spriteBatch ; @Override public void render ( ) { frameBuffer . begin ( ) ; Gdx . gl20 . glViewport ( <int> , <int> , frameBuffer . getWidth ( ) , frameBuffer . getHeight ( ) ) ; Gdx . gl20 . glClearColor ( <int> f , <int> f , <int> f , <int> ) ; Gdx . gl20 . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; Gdx . gl20 . glEnable ( GL20 . GL_TEXTURE_2D ) ; texture . bind ( ) ; meshShader . begin ( ) ; meshShader . setUniformi ( <str> , <int> ) ; mesh . render ( meshShader , GL20 . GL_TRIANGLES ) ; meshShader . end ( ) ; frameBuffer . end ( ) ; stencilFrameBuffer . begin ( ) ; Gdx . gl20 . glViewport ( <int> , <int> , frameBuffer . getWidth ( ) , frameBuffer . getHeight ( ) ) ; Gdx . gl20 . glClearColor ( <int> f , <int> f , <int> f , <int> ) ; Gdx . gl20 . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_STENCIL_BUFFER_BIT ) ; Gdx . gl20 . glEnable ( GL20 . GL_TEXTURE_2D ) ; Gdx . gl20 . glEnable ( GL20 . GL_STENCIL_TEST ) ; Gdx . gl20 . glColorMask ( false , false , false , false ) ; Gdx . gl20 . glDepthMask ( false ) ; Gdx . gl20 . glStencilFunc ( GL20 . GL_NEVER , <int> , <hex> ) ; Gdx . gl20 . glStencilOp ( GL20 . GL_REPLACE , GL20 . GL_KEEP , GL20 . GL_KEEP ) ; Gdx . gl20 . glStencilMask ( <hex> ) ; Gdx . gl20 . glClear ( GL20 . GL_STENCIL_BUFFER_BIT ) ; meshShader . begin ( ) ; stencilMesh . render ( meshShader , GL20 . GL_TRIANGLES ) ; meshShader . end ( ) ; Gdx . gl20 . glColorMask ( true , true , true , true ) ; Gdx . gl20 . glDepthMask ( true ) ; Gdx . gl20 . glStencilMask ( <hex> ) ; Gdx . gl20 . glStencilFunc ( GL20 . GL_EQUAL , <int> , <hex> ) ; meshShader . begin ( ) ; mesh . render ( meshShader , GL20 . GL_TRIANGLES ) ; meshShader . end ( ) ; Gdx . gl20 . glDisable ( GL20 . GL_STENCIL_TEST ) ; stencilFrameBuffer . end ( ) ; Gdx . gl20 . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl20 . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl20 . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; spriteBatch . draw ( frameBuffer . getColorBufferTexture ( ) , <int> , <int> , <int> , <int> , <int> , <int> , frameBuffer . getColorBufferTexture ( ) . getWidth ( ) , frameBuffer . getColorBufferTexture ( ) . getHeight ( ) , false , true ) ; spriteBatch . draw ( stencilFrameBuffer . getColorBufferTexture ( ) , <int> , <int> , <int> , <int> , <int> , <int> , frameBuffer . getColorBufferTexture ( ) . getWidth ( ) , frameBuffer . getColorBufferTexture ( ) . getHeight ( ) , false , true ) ; spriteBatch . end ( ) ; } @Override public void create ( ) { mesh = new Mesh ( true , <int> , <int> , new VertexAttribute ( Usage . Position , <int> , <str> ) , new VertexAttribute ( Usage . ColorPacked , <int> , <str> ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , <str> ) ) ; float c1 = Color . toFloatBits ( <int> , <int> , <int> , <int> ) ; float c2 = Color . toFloatBits ( <int> , <int> , <int> , <int> ) ; float c3 = Color . toFloatBits ( <int> , <int> , <int> , <int> ) ; mesh . setVertices ( new float [ ] { - <float> , - <float> , <int> , c1 , <int> , <int> , <float> , - <float> , <int> , c2 , <int> , <int> , <int> , <float> , <int> , c3 , <float> , <int> } ) ; stencilMesh = new Mesh ( true , <int> , <int> , new VertexAttribute ( Usage . Position , <int> , <str> ) , new VertexAttribute ( Usage . ColorPacked , <int> , <str> ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , <str> ) ) ; stencilMesh . setVertices ( new float [ ] { - <float> , <float> , <int> , c1 , <int> , <int> , <float> , <float> , <int> , c2 , <int> , <int> , <int> , - <float> , <int> , c3 , <float> , <int> } ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; spriteBatch = new SpriteBatch ( ) ; frameBuffer = new FrameBuffer ( Format . RGB565 , <int> , <int> , false ) ; stencilFrameBuffer = new FrameBuffer ( Format . RGB565 , <int> , <int> , false , true ) ; createShader ( Gdx . graphics ) ; } private void createShader ( Graphics graphics ) { String vertexShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; String fragmentShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; meshShader = new ShaderProgram ( vertexShader , fragmentShader ) ; if ( meshShader . isCompiled ( ) = = false ) throw new IllegalStateException ( meshShader . getLog ( ) ) ; } @Override public void dispose ( ) { mesh . dispose ( ) ; texture . dispose ( ) ; frameBuffer . dispose ( ) ; stencilFrameBuffer . dispose ( ) ; stencilMesh . dispose ( ) ; spriteBatch . dispose ( ) ; meshShader . dispose ( ) ; } } 
