package com . badlogic . gdx . tests . box2d ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . Body ; import com . badlogic . gdx . physics . box2d . BodyDef ; import com . badlogic . gdx . physics . box2d . BodyDef . BodyType ; import com . badlogic . gdx . physics . box2d . EdgeShape ; import com . badlogic . gdx . physics . box2d . FixtureDef ; import com . badlogic . gdx . physics . box2d . PolygonShape ; import com . badlogic . gdx . physics . box2d . World ; import com . badlogic . gdx . physics . box2d . joints . PrismaticJointDef ; import com . badlogic . gdx . physics . box2d . joints . RevoluteJointDef ; public class BodyTypes extends Box2DTest { Body m_attachment ; Body m_platform ; float m_speed ; @Override protected void createWorld ( World world ) { Body ground ; { BodyDef bd = new BodyDef ( ) ; ground = world . createBody ( bd ) ; EdgeShape shape = new EdgeShape ( ) ; shape . set ( new Vector2 ( - <int> , <int> ) , new Vector2 ( <int> , <int> ) ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; ground . createFixture ( fd ) ; shape . dispose ( ) ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . position . set ( <int> , <float> ) ; m_attachment = world . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( <float> , <float> ) ; m_attachment . createFixture ( shape , <float> ) ; shape . dispose ( ) ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . position . set ( - <float> , <float> ) ; m_platform = world . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( <float> , <float> , new Vector2 ( <float> , <int> ) , <float> * ( float ) Math . PI ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; fd . friction = <float> ; fd . density = <float> ; m_platform . createFixture ( fd ) ; shape . dispose ( ) ; RevoluteJointDef rjd = new RevoluteJointDef ( ) ; rjd . initialize ( m_attachment , m_platform , new Vector2 ( <int> , <float> ) ) ; rjd . maxMotorTorque = <float> ; rjd . enableMotor = true ; world . createJoint ( rjd ) ; PrismaticJointDef pjd = new PrismaticJointDef ( ) ; pjd . initialize ( ground , m_platform , new Vector2 ( <int> , <float> ) , new Vector2 ( <int> , <int> ) ) ; pjd . maxMotorForce = <float> ; pjd . enableMotor = true ; pjd . lowerTranslation = - <int> f ; pjd . upperTranslation = <float> ; pjd . enableLimit = true ; world . createJoint ( pjd ) ; m_speed = <float> ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . position . set ( <int> , <float> ) ; Body body = world . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( <float> , <float> ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; fd . friction = <float> ; fd . density = <float> ; body . createFixture ( fd ) ; shape . dispose ( ) ; } } private final Vector2 tmp = new Vector2 ( ) ; @Override public boolean keyDown ( int keyCode ) { if ( keyCode = = Keys . D ) m_platform . setType ( BodyType . DynamicBody ) ; if ( keyCode = = Keys . S ) m_platform . setType ( BodyType . StaticBody ) ; if ( keyCode = = Keys . K ) { m_platform . setType ( BodyType . KinematicBody ) ; m_platform . setLinearVelocity ( tmp . set ( - m_speed , <int> ) ) ; m_platform . setAngularVelocity ( <int> ) ; } return false ; } @Override public void render ( ) { if ( m_platform . getType ( ) = = BodyType . KinematicBody ) { Vector2 p = m_platform . getTransform ( ) . getPosition ( ) ; Vector2 v = m_platform . getLinearVelocity ( ) ; if ( ( p . x < - <int> & & v . x < <int> ) | | ( p . x > <int> & & v . x > <int> ) ) { v . x = - v . x ; m_platform . setLinearVelocity ( v ) ; } } super . render ( ) ; } }