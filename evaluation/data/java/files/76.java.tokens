package com . netflix . hystrix ; import com . netflix . hystrix . HystrixCommandProperties . ExecutionIsolationStrategy ; import com . netflix . hystrix . collapser . CollapserTimer ; import com . netflix . hystrix . collapser . HystrixCollapserBridge ; import com . netflix . hystrix . collapser . RealCollapserTimer ; import com . netflix . hystrix . collapser . RequestCollapser ; import com . netflix . hystrix . collapser . RequestCollapserFactory ; import com . netflix . hystrix . exception . HystrixRuntimeException ; import com . netflix . hystrix . strategy . HystrixPlugins ; import com . netflix . hystrix . strategy . concurrency . HystrixRequestContext ; import com . netflix . hystrix . strategy . metrics . HystrixMetricsPublisherFactory ; import com . netflix . hystrix . strategy . properties . HystrixPropertiesFactory ; import com . netflix . hystrix . strategy . properties . HystrixPropertiesStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import rx . Observable ; import rx . Scheduler ; import rx . functions . Action1 ; import rx . schedulers . Schedulers ; import rx . subjects . ReplaySubject ; import java . util . Collection ; import java . util . Collections ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . Future ; public abstract class HystrixCollapser < BatchReturnType , ResponseType , RequestArgumentType > implements HystrixExecutable < ResponseType > , HystrixObservable < ResponseType > { static final Logger logger = LoggerFactory . getLogger ( HystrixCollapser . class ) ; private final RequestCollapserFactory < BatchReturnType , ResponseType , RequestArgumentType > collapserFactory ; private final HystrixRequestCache requestCache ; private final HystrixCollapserBridge < BatchReturnType , ResponseType , RequestArgumentType > collapserInstanceWrapper ; private final HystrixCollapserMetrics metrics ; public static enum Scope implements RequestCollapserFactory . Scope { REQUEST , GLOBAL } protected HystrixCollapser ( ) { this ( Setter . withCollapserKey ( null ) . andScope ( Scope . REQUEST ) ) ; } protected HystrixCollapser ( HystrixCollapserKey collapserKey ) { this ( Setter . withCollapserKey ( collapserKey ) . andScope ( Scope . REQUEST ) ) ; } protected HystrixCollapser ( Setter setter ) { this ( setter . collapserKey , setter . scope , new RealCollapserTimer ( ) , setter . propertiesSetter , null ) ; } HystrixCollapser ( HystrixCollapserKey collapserKey , Scope scope , CollapserTimer timer , HystrixCollapserProperties . Setter propertiesBuilder ) { this ( collapserKey , scope , timer , propertiesBuilder , null ) ; } HystrixCollapser ( HystrixCollapserKey collapserKey , Scope scope , CollapserTimer timer , HystrixCollapserProperties . Setter propertiesBuilder , HystrixCollapserMetrics metrics ) { if ( collapserKey = = null | | collapserKey . name ( ) . trim ( ) . equals ( <str> ) ) { String defaultKeyName = getDefaultNameFromClass ( getClass ( ) ) ; collapserKey = HystrixCollapserKey . Factory . asKey ( defaultKeyName ) ; } HystrixCollapserProperties properties = HystrixPropertiesFactory . getCollapserProperties ( collapserKey , propertiesBuilder ) ; this . collapserFactory = new RequestCollapserFactory < BatchReturnType , ResponseType , RequestArgumentType > ( collapserKey , scope , timer , properties ) ; this . requestCache = HystrixRequestCache . getInstance ( collapserKey , HystrixPlugins . getInstance ( ) . getConcurrencyStrategy ( ) ) ; if ( metrics = = null ) { this . metrics = HystrixCollapserMetrics . getInstance ( collapserKey , properties ) ; } else { this . metrics = metrics ; } final HystrixCollapser < BatchReturnType , ResponseType , RequestArgumentType > self = this ; HystrixMetricsPublisherFactory . createOrRetrievePublisherForCollapser ( collapserKey , this . metrics , properties ) ; collapserInstanceWrapper = new HystrixCollapserBridge < BatchReturnType , ResponseType , RequestArgumentType > ( ) { @Override public Collection < Collection < CollapsedRequest < ResponseType , RequestArgumentType > > > shardRequests ( Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) { Collection < Collection < CollapsedRequest < ResponseType , RequestArgumentType > > > shards = self . shardRequests ( requests ) ; self . metrics . markShards ( shards . size ( ) ) ; return shards ; } @Override public Observable < BatchReturnType > createObservableCommand ( Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) { final HystrixCommand < BatchReturnType > command = self . createCommand ( requests ) ; command . markAsCollapsedCommand ( this . getCollapserKey ( ) , requests . size ( ) ) ; self . metrics . markBatch ( requests . size ( ) ) ; return command . toObservable ( ) ; } @Override public Observable < Void > mapResponseToRequests ( Observable < BatchReturnType > batchResponse , final Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) { return batchResponse . single ( ) . doOnNext ( new Action1 < BatchReturnType > ( ) { @Override public void call ( BatchReturnType batchReturnType ) { self . mapResponseToRequests ( batchReturnType , requests ) ; } } ) . ignoreElements ( ) . cast ( Void . class ) ; } @Override public HystrixCollapserKey getCollapserKey ( ) { return self . getCollapserKey ( ) ; } } ; } private HystrixCollapserProperties getProperties ( ) { return collapserFactory . getProperties ( ) ; } public HystrixCollapserKey getCollapserKey ( ) { return collapserFactory . getCollapserKey ( ) ; } public Scope getScope ( ) { return Scope . valueOf ( collapserFactory . getScope ( ) . name ( ) ) ; } public HystrixCollapserMetrics getMetrics ( ) { return metrics ; } public abstract RequestArgumentType getRequestArgument ( ) ; protected abstract HystrixCommand < BatchReturnType > createCommand ( Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) ; protected Collection < Collection < CollapsedRequest < ResponseType , RequestArgumentType > > > shardRequests ( Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) { return Collections . singletonList ( requests ) ; } protected abstract void mapResponseToRequests ( BatchReturnType batchResponse , Collection < CollapsedRequest < ResponseType , RequestArgumentType > > requests ) ; public Observable < ResponseType > observe ( ) { ReplaySubject < ResponseType > subject = ReplaySubject . create ( ) ; toObservable ( ) . subscribe ( subject ) ; return subject ; } public Observable < ResponseType > toObservable ( ) { return toObservable ( Schedulers . computation ( ) ) ; } public Observable < ResponseType > toObservable ( Scheduler observeOn ) { final boolean isRequestCacheEnabled = getProperties ( ) . requestCacheEnabled ( ) . get ( ) ; if ( isRequestCacheEnabled ) { Observable < ResponseType > fromCache = requestCache . get ( getCacheKey ( ) ) ; if ( fromCache ! = null ) { metrics . markResponseFromCache ( ) ; return fromCache ; } } RequestCollapser < BatchReturnType , ResponseType , RequestArgumentType > requestCollapser = collapserFactory . getRequestCollapser ( collapserInstanceWrapper ) ; Observable < ResponseType > response = requestCollapser . submitRequest ( getRequestArgument ( ) ) ; metrics . markRequestBatched ( ) ; if ( isRequestCacheEnabled ) { Observable < ResponseType > o = response . cache ( ) ; Observable < ResponseType > fromCache = requestCache . putIfAbsent ( getCacheKey ( ) , o ) ; if ( fromCache = = null ) { response = o ; } else { response = fromCache ; } } return response ; } public ResponseType execute ( ) { try { return queue ( ) . get ( ) ; } catch ( Throwable e ) { if ( e instanceof HystrixRuntimeException ) { throw ( HystrixRuntimeException ) e ; } if ( e . getCause ( ) instanceof HystrixRuntimeException ) { throw ( HystrixRuntimeException ) e . getCause ( ) ; } String message = getClass ( ) . getSimpleName ( ) + <str> ; logger . debug ( message , e ) ; throw new RuntimeException ( message , e ) ; } } public Future < ResponseType > queue ( ) { final Observable < ResponseType > o = toObservable ( ) ; return o . toBlocking ( ) . toFuture ( ) ; } protected String getCacheKey ( ) { return null ; } static void reset ( ) { RequestCollapserFactory . reset ( ) ; } private static String getDefaultNameFromClass ( @SuppressWarnings ( <str> ) Class < ? extends HystrixCollapser > cls ) { String fromCache = defaultNameCache . get ( cls ) ; if ( fromCache ! = null ) { return fromCache ; } String name = cls . getSimpleName ( ) ; if ( name . equals ( <str> ) ) { name = cls . getName ( ) ; name = name . substring ( name . lastIndexOf ( <str> ) + <int> , name . length ( ) ) ; } defaultNameCache . put ( cls , name ) ; return name ; } public interface CollapsedRequest < ResponseType , RequestArgumentType > { public RequestArgumentType getArgument ( ) ; public void setResponse ( ResponseType response ) ; public void emitResponse ( ResponseType response ) ; public void setException ( Exception exception ) ; public void setComplete ( ) ; } public static class Setter { private final HystrixCollapserKey collapserKey ; private Scope scope = Scope . REQUEST ; private HystrixCollapserProperties . Setter propertiesSetter ; private Setter ( HystrixCollapserKey collapserKey ) { this . collapserKey = collapserKey ; } public static Setter withCollapserKey ( HystrixCollapserKey collapserKey ) { return new Setter ( collapserKey ) ; } public Setter andScope ( Scope scope ) { this . scope = scope ; return this ; } public Setter andCollapserPropertiesDefaults ( HystrixCollapserProperties . Setter propertiesSetter ) { this . propertiesSetter = propertiesSetter ; return this ; } } @SuppressWarnings ( <str> ) private static ConcurrentHashMap < Class < ? extends HystrixCollapser > , String > defaultNameCache = new ConcurrentHashMap < Class < ? extends HystrixCollapser > , String > ( ) ; }