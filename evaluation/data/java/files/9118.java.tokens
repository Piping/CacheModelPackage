package org . eclipse . debug . core ; import java . util . EventObject ; import org . eclipse . debug . internal . core . DebugCoreMessages ; public final class DebugEvent extends EventObject { private static final long serialVersionUID = <int> ; public static final int RESUME = <hex> ; public static final int SUSPEND = <hex> ; public static final int CREATE = <hex> ; public static final int TERMINATE = <hex> ; public static final int CHANGE = <hex> ; public static final int MODEL_SPECIFIC = <hex> ; public static final int STEP_INTO = <hex> ; public static final int STEP_OVER = <hex> ; public static final int STEP_RETURN = <hex> ; public static final int STEP_END = <hex> ; public static final int BREAKPOINT = <hex> ; public static final int CLIENT_REQUEST = <hex> ; public static final int EVALUATION = <hex> ; public static final int EVALUATION_IMPLICIT = <hex> ; public static final int STATE = <hex> ; public static final int CONTENT = <hex> ; public static final int UNSPECIFIED = <int> ; private int fKind = UNSPECIFIED ; private int fDetail = UNSPECIFIED ; private Object fData = null ; public DebugEvent ( Object eventSource , int kind ) { this ( eventSource , kind , UNSPECIFIED ) ; } public DebugEvent ( Object eventSource , int kind , int detail ) { super ( eventSource ) ; if ( ( kind & ( RESUME | SUSPEND | CREATE | TERMINATE | CHANGE | MODEL_SPECIFIC ) ) = = <int> ) { throw new IllegalArgumentException ( DebugCoreMessages . DebugEvent_illegal_kind ) ; } if ( kind ! = MODEL_SPECIFIC & & detail ! = UNSPECIFIED & & ( detail & ( STEP_END | STEP_INTO | STEP_OVER | STEP_RETURN | BREAKPOINT | CLIENT_REQUEST | EVALUATION | EVALUATION_IMPLICIT | STATE | CONTENT ) ) = = <int> ) { throw new IllegalArgumentException ( DebugCoreMessages . DebugEvent_illegal_detail ) ; } fKind = kind ; fDetail = detail ; } public int getDetail ( ) { return fDetail ; } public int getKind ( ) { return fKind ; } public boolean isStepStart ( ) { return ( getDetail ( ) & ( STEP_INTO | STEP_OVER | STEP_RETURN ) ) > <int> ; } public boolean isEvaluation ( ) { return ( getDetail ( ) & ( EVALUATION | EVALUATION_IMPLICIT ) ) > <int> ; } public void setData ( Object data ) { fData = data ; } public Object getData ( ) { return fData ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( <str> ) ; if ( getSource ( ) ! = null ) { buf . append ( getSource ( ) . toString ( ) ) ; } else { buf . append ( <str> ) ; } buf . append ( <str> ) ; switch ( getKind ( ) ) { case CREATE : buf . append ( <str> ) ; break ; case TERMINATE : buf . append ( <str> ) ; break ; case RESUME : buf . append ( <str> ) ; break ; case SUSPEND : buf . append ( <str> ) ; break ; case CHANGE : buf . append ( <str> ) ; break ; case UNSPECIFIED : buf . append ( <str> ) ; break ; case MODEL_SPECIFIC : buf . append ( <str> ) ; break ; default : break ; } buf . append ( <str> ) ; switch ( getDetail ( ) ) { case BREAKPOINT : buf . append ( <str> ) ; break ; case CLIENT_REQUEST : buf . append ( <str> ) ; break ; case STEP_END : buf . append ( <str> ) ; break ; case STEP_INTO : buf . append ( <str> ) ; break ; case STEP_OVER : buf . append ( <str> ) ; break ; case STEP_RETURN : buf . append ( <str> ) ; break ; case EVALUATION : buf . append ( <str> ) ; break ; case EVALUATION_IMPLICIT : buf . append ( <str> ) ; break ; case STATE : buf . append ( <str> ) ; break ; case CONTENT : buf . append ( <str> ) ; break ; case UNSPECIFIED : buf . append ( <str> ) ; break ; default : buf . append ( getDetail ( ) ) ; break ; } buf . append ( <str> ) ; return buf . toString ( ) ; } }