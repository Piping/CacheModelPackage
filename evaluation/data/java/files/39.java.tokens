package com . netflix . hystrix . metric . consumer ; import com . netflix . hystrix . HystrixCollapserKey ; import com . netflix . hystrix . HystrixCollapserMetrics ; import com . netflix . hystrix . HystrixEventType ; import com . netflix . hystrix . HystrixRequestLog ; import com . netflix . hystrix . metric . CommandStreamTest ; import com . netflix . hystrix . strategy . concurrency . HystrixRequestContext ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import rx . Subscriber ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static org . junit . Assert . * ; public class RollingCollapserEventCounterStreamTest extends CommandStreamTest { HystrixRequestContext context ; RollingCollapserEventCounterStream stream ; private static Subscriber < long [ ] > getSubscriber ( final CountDownLatch latch ) { return new Subscriber < long [ ] > ( ) { @Override public void onCompleted ( ) { latch . countDown ( ) ; } @Override public void onError ( Throwable e ) { fail ( e . getMessage ( ) ) ; } @Override public void onNext ( long [ ] eventCounts ) { System . out . println ( <str> + System . currentTimeMillis ( ) + <str> + collapserEventsToStr ( eventCounts ) ) ; } } ; } @Before public void setUp ( ) { context = HystrixRequestContext . initializeContext ( ) ; } @After public void tearDown ( ) { context . shutdown ( ) ; stream . unsubscribe ( ) ; RollingCollapserEventCounterStream . reset ( ) ; } protected static String collapserEventsToStr ( long [ ] eventCounts ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; for ( HystrixEventType . Collapser eventType : HystrixEventType . Collapser . values ( ) ) { if ( eventCounts [ eventType . ordinal ( ) ] > <int> ) { sb . append ( eventType . name ( ) ) . append ( <str> ) . append ( eventCounts [ eventType . ordinal ( ) ] ) . append ( <str> ) ; } } sb . append ( <str> ) ; return sb . toString ( ) ; } @Test public void testEmptyStreamProducesZeros ( ) { HystrixCollapserKey key = HystrixCollapserKey . Factory . asKey ( <str> ) ; stream = RollingCollapserEventCounterStream . getInstance ( key , <int> , <int> ) ; stream . startCachingStreamValuesIfUnstarted ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; stream . observe ( ) . take ( <int> ) . subscribe ( getSubscriber ( latch ) ) ; try { latch . await ( <int> , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ex ) { fail ( <str> ) ; } System . out . println ( <str> + HystrixRequestLog . getCurrentRequest ( ) . getExecutedCommandsAsString ( ) ) ; assertEquals ( HystrixEventType . Collapser . values ( ) . length , stream . getLatest ( ) . length ) ; assertEquals ( <int> , stream . getLatest ( HystrixEventType . Collapser . ADDED_TO_BATCH ) ) ; assertEquals ( <int> , stream . getLatest ( HystrixEventType . Collapser . BATCH_EXECUTED ) ) ; assertEquals ( <int> , stream . getLatest ( HystrixEventType . Collapser . RESPONSE_FROM_CACHE ) ) ; } @Test public void testCollapsed ( ) { HystrixCollapserKey key = HystrixCollapserKey . Factory . asKey ( <str> ) ; stream = RollingCollapserEventCounterStream . getInstance ( key , <int> , <int> ) ; stream . startCachingStreamValuesIfUnstarted ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; stream . observe ( ) . take ( <int> ) . subscribe ( getSubscriber ( latch ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; } try { latch . await ( <int> , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ex ) { fail ( <str> ) ; } assertEquals ( HystrixEventType . Collapser . values ( ) . length , stream . getLatest ( ) . length ) ; long [ ] expected = new long [ HystrixEventType . Collapser . values ( ) . length ] ; expected [ HystrixEventType . Collapser . BATCH_EXECUTED . ordinal ( ) ] = <int> ; expected [ HystrixEventType . Collapser . ADDED_TO_BATCH . ordinal ( ) ] = <int> ; System . out . println ( <str> + HystrixRequestLog . getCurrentRequest ( ) . getExecutedCommandsAsString ( ) ) ; assertArrayEquals ( expected , stream . getLatest ( ) ) ; } @Test public void testCollapsedAndResponseFromCache ( ) { HystrixCollapserKey key = HystrixCollapserKey . Factory . asKey ( <str> ) ; stream = RollingCollapserEventCounterStream . getInstance ( key , <int> , <int> ) ; stream . startCachingStreamValuesIfUnstarted ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; stream . observe ( ) . take ( <int> ) . subscribe ( getSubscriber ( latch ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; } try { latch . await ( <int> , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ex ) { fail ( <str> ) ; } assertEquals ( HystrixEventType . Collapser . values ( ) . length , stream . getLatest ( ) . length ) ; long [ ] expected = new long [ HystrixEventType . Collapser . values ( ) . length ] ; expected [ HystrixEventType . Collapser . BATCH_EXECUTED . ordinal ( ) ] = <int> ; expected [ HystrixEventType . Collapser . ADDED_TO_BATCH . ordinal ( ) ] = <int> ; expected [ HystrixEventType . Collapser . RESPONSE_FROM_CACHE . ordinal ( ) ] = <int> ; System . out . println ( <str> + HystrixRequestLog . getCurrentRequest ( ) . getExecutedCommandsAsString ( ) ) ; assertArrayEquals ( expected , stream . getLatest ( ) ) ; } @Test public void testCollapsedAndResponseFromCacheAgeOutOfRollingWindow ( ) { HystrixCollapserKey key = HystrixCollapserKey . Factory . asKey ( <str> ) ; stream = RollingCollapserEventCounterStream . getInstance ( key , <int> , <int> ) ; stream . startCachingStreamValuesIfUnstarted ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; stream . observe ( ) . take ( <int> ) . subscribe ( getSubscriber ( latch ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; CommandStreamTest . Collapser . from ( key , i ) . observe ( ) ; } try { latch . await ( <int> , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ex ) { fail ( <str> ) ; } assertEquals ( HystrixEventType . Collapser . values ( ) . length , stream . getLatest ( ) . length ) ; long [ ] expected = new long [ HystrixEventType . Collapser . values ( ) . length ] ; expected [ HystrixEventType . Collapser . BATCH_EXECUTED . ordinal ( ) ] = <int> ; expected [ HystrixEventType . Collapser . ADDED_TO_BATCH . ordinal ( ) ] = <int> ; expected [ HystrixEventType . Collapser . RESPONSE_FROM_CACHE . ordinal ( ) ] = <int> ; System . out . println ( <str> + HystrixRequestLog . getCurrentRequest ( ) . getExecutedCommandsAsString ( ) ) ; assertArrayEquals ( expected , stream . getLatest ( ) ) ; } }