package org . apache . cassandra . utils . concurrent ; import java . lang . ref . PhantomReference ; import java . lang . ref . ReferenceQueue ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . lifecycle . View ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . Memory ; import org . apache . cassandra . io . util . SafeMemory ; import org . apache . cassandra . utils . NoSpamLogger ; import static java . util . Collections . emptyList ; import static org . apache . cassandra . utils . Throwables . maybeFail ; import static org . apache . cassandra . utils . Throwables . merge ; public final class Ref < T > implements RefCounted < T > { static final Logger logger = LoggerFactory . getLogger ( Ref . class ) ; public static final boolean DEBUG_ENABLED = System . getProperty ( <str> , <str> ) . equalsIgnoreCase ( <str> ) ; final State state ; final T referent ; public Ref ( T referent , Tidy tidy ) { this . state = new State ( new GlobalState ( tidy ) , this , referenceQueue ) ; this . referent = referent ; } Ref ( T referent , GlobalState state ) { this . state = new State ( state , this , referenceQueue ) ; this . referent = referent ; } public void release ( ) { state . release ( false ) ; } public Throwable ensureReleased ( Throwable accumulate ) { return state . ensureReleased ( accumulate ) ; } public void ensureReleased ( ) { maybeFail ( state . ensureReleased ( null ) ) ; } public void close ( ) { ensureReleased ( ) ; } public T get ( ) { state . assertNotReleased ( ) ; return referent ; } public Ref < T > tryRef ( ) { return state . globalState . ref ( ) ? new Ref < > ( referent , state . globalState ) : null ; } public Ref < T > ref ( ) { Ref < T > ref = tryRef ( ) ; if ( ref = = null ) state . assertNotReleased ( ) ; return ref ; } public String printDebugInfo ( ) { if ( DEBUG_ENABLED ) { state . debug . log ( state . toString ( ) ) ; return <str> + state . debug . deallocateThread ; } return <str> ; } public int globalCount ( ) { return state . globalState . count ( ) ; } static final class State extends PhantomReference < Ref > { final Debug debug = DEBUG_ENABLED ? new Debug ( ) : null ; final GlobalState globalState ; private volatile int released ; private static final AtomicIntegerFieldUpdater < State > releasedUpdater = AtomicIntegerFieldUpdater . newUpdater ( State . class , <str> ) ; public State ( final GlobalState globalState , Ref reference , ReferenceQueue < ? super Ref > q ) { super ( reference , q ) ; this . globalState = globalState ; globalState . register ( this ) ; } void assertNotReleased ( ) { if ( DEBUG_ENABLED & & released = = <int> ) debug . log ( toString ( ) ) ; assert released = = <int> ; } Throwable ensureReleased ( Throwable accumulate ) { if ( releasedUpdater . getAndSet ( this , <int> ) = = <int> ) { accumulate = globalState . release ( this , accumulate ) ; if ( DEBUG_ENABLED ) debug . deallocate ( ) ; } return accumulate ; } void release ( boolean leak ) { if ( ! releasedUpdater . compareAndSet ( this , <int> , <int> ) ) { if ( ! leak ) { String id = this . toString ( ) ; logger . error ( <str> , id ) ; if ( DEBUG_ENABLED ) debug . log ( id ) ; throw new IllegalStateException ( <str> ) ; } return ; } Throwable fail = globalState . release ( this , null ) ; if ( leak ) { String id = this . toString ( ) ; logger . error ( <str> , id , globalState ) ; if ( DEBUG_ENABLED ) debug . log ( id ) ; } else if ( DEBUG_ENABLED ) { debug . deallocate ( ) ; } if ( fail ! = null ) logger . error ( <str> , globalState , fail ) ; } } static final class Debug { String allocateThread , deallocateThread ; StackTraceElement [ ] allocateTrace , deallocateTrace ; Debug ( ) { Thread thread = Thread . currentThread ( ) ; allocateThread = thread . toString ( ) ; allocateTrace = thread . getStackTrace ( ) ; } synchronized void deallocate ( ) { Thread thread = Thread . currentThread ( ) ; deallocateThread = thread . toString ( ) ; deallocateTrace = thread . getStackTrace ( ) ; } synchronized void log ( String id ) { logger . error ( <str> , id , print ( allocateThread , allocateTrace ) ) ; if ( deallocateThread ! = null ) logger . error ( <str> , id , print ( deallocateThread , deallocateTrace ) ) ; } String print ( String thread , StackTraceElement [ ] trace ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( thread ) ; sb . append ( <str> ) ; for ( StackTraceElement element : trace ) { sb . append ( <str> ) ; sb . append ( element ) ; sb . append ( <str> ) ; } return sb . toString ( ) ; } } static final class GlobalState { private final Collection < State > locallyExtant = new ConcurrentLinkedDeque < > ( ) ; private final AtomicInteger counts = new AtomicInteger ( ) ; private final Tidy tidy ; GlobalState ( Tidy tidy ) { this . tidy = tidy ; globallyExtant . add ( this ) ; } void register ( Ref . State ref ) { locallyExtant . add ( ref ) ; } boolean ref ( ) { while ( true ) { int cur = counts . get ( ) ; if ( cur < <int> ) return false ; if ( counts . compareAndSet ( cur , cur + <int> ) ) return true ; } } Throwable release ( Ref . State ref , Throwable accumulate ) { locallyExtant . remove ( ref ) ; if ( - <int> = = counts . decrementAndGet ( ) ) { globallyExtant . remove ( this ) ; try { if ( tidy ! = null ) tidy . tidy ( ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } } return accumulate ; } int count ( ) { return <int> + counts . get ( ) ; } public String toString ( ) { if ( tidy ! = null ) return tidy . getClass ( ) + <str> + System . identityHashCode ( tidy ) + <str> + tidy . name ( ) ; return <str> + System . identityHashCode ( this ) ; } } private static final Set < GlobalState > globallyExtant = Collections . newSetFromMap ( new ConcurrentHashMap < > ( ) ) ; static final ReferenceQueue < Object > referenceQueue = new ReferenceQueue < > ( ) ; private static final ExecutorService EXEC = Executors . newFixedThreadPool ( <int> , new NamedThreadFactory ( <str> ) ) ; private static final ScheduledExecutorService STRONG_LEAK_DETECTOR = ! DEBUG_ENABLED ? null : Executors . newScheduledThreadPool ( <int> , new NamedThreadFactory ( <str> ) ) ; static { EXEC . execute ( new ReferenceReaper ( ) ) ; if ( DEBUG_ENABLED ) { STRONG_LEAK_DETECTOR . scheduleAtFixedRate ( new Visitor ( ) , <int> , <int> , TimeUnit . MINUTES ) ; STRONG_LEAK_DETECTOR . scheduleAtFixedRate ( new StrongLeakDetector ( ) , <int> , <int> , TimeUnit . MINUTES ) ; } } static final class ReferenceReaper implements Runnable { public void run ( ) { try { while ( true ) { Object obj = referenceQueue . remove ( ) ; if ( obj instanceof Ref . State ) { ( ( Ref . State ) obj ) . release ( true ) ; } } } catch ( InterruptedException e ) { } finally { EXEC . execute ( this ) ; } } } static class Visitor implements Runnable { final Stack < Field > path = new Stack < > ( ) ; final Set < Object > visited = Collections . newSetFromMap ( new IdentityHashMap < > ( ) ) ; GlobalState visiting ; public void run ( ) { try { for ( GlobalState globalState : globallyExtant ) { if ( globalState . tidy = = null ) continue ; path . clear ( ) ; visited . clear ( ) ; visited . add ( globalState ) ; visiting = globalState ; visit ( globalState . tidy ) ; } } catch ( Throwable t ) { t . printStackTrace ( ) ; } finally { path . clear ( ) ; visited . clear ( ) ; } } void visit ( final Object object ) { for ( Field field : getFields ( object . getClass ( ) ) ) { path . push ( field ) ; try { Object child = field . get ( object ) ; if ( child ! = null & & visited . add ( child ) ) { visit ( child ) ; } else if ( visiting = = child ) { logger . error ( <str> , path ) ; } } catch ( IllegalAccessException e ) { NoSpamLogger . log ( logger , NoSpamLogger . Level . ERROR , <int> , TimeUnit . MINUTES , <str> , e ) ; } catch ( StackOverflowError e ) { logger . error ( <str> , path ) ; } path . pop ( ) ; } } } static final Map < Class < ? > , List < Field > > fieldMap = new HashMap < > ( ) ; static List < Field > getFields ( Class < ? > clazz ) { if ( clazz = = null | | clazz = = PhantomReference . class | | clazz = = Class . class | | java . lang . reflect . Member . class . isAssignableFrom ( clazz ) ) return emptyList ( ) ; List < Field > fields = fieldMap . get ( clazz ) ; if ( fields ! = null ) return fields ; fieldMap . put ( clazz , fields = new ArrayList < > ( ) ) ; for ( Field field : clazz . getDeclaredFields ( ) ) { if ( field . getType ( ) . isPrimitive ( ) | | Modifier . isStatic ( field . getModifiers ( ) ) ) continue ; field . setAccessible ( true ) ; fields . add ( field ) ; } fields . addAll ( getFields ( clazz . getSuperclass ( ) ) ) ; return fields ; } public static class IdentityCollection { final Set < Tidy > candidates ; public IdentityCollection ( Set < Tidy > candidates ) { this . candidates = candidates ; } public void add ( Ref < ? > ref ) { candidates . remove ( ref . state . globalState . tidy ) ; } public void add ( SelfRefCounted < ? > ref ) { add ( ref . selfRef ( ) ) ; } public void add ( SharedCloseable ref ) { if ( ref instanceof SharedCloseableImpl ) add ( ( SharedCloseableImpl ) ref ) ; } public void add ( SharedCloseableImpl ref ) { add ( ref . ref ) ; } public void add ( Memory memory ) { if ( memory instanceof SafeMemory ) ( ( SafeMemory ) memory ) . addTo ( this ) ; } } private static class StrongLeakDetector implements Runnable { Set < Tidy > candidates = new HashSet < > ( ) ; public void run ( ) { final Set < Tidy > candidates = Collections . newSetFromMap ( new IdentityHashMap < > ( ) ) ; for ( GlobalState state : globallyExtant ) candidates . add ( state . tidy ) ; removeExpected ( candidates ) ; this . candidates . retainAll ( candidates ) ; if ( ! this . candidates . isEmpty ( ) ) { List < String > names = new ArrayList < > ( ) ; for ( Tidy tidy : this . candidates ) names . add ( tidy . name ( ) ) ; logger . warn ( <str> , names ) ; } this . candidates = candidates ; } private void removeExpected ( Set < Tidy > candidates ) { final Ref . IdentityCollection expected = new Ref . IdentityCollection ( candidates ) ; for ( Keyspace ks : Keyspace . all ( ) ) { for ( ColumnFamilyStore cfs : ks . getColumnFamilyStores ( ) ) { View view = cfs . getTracker ( ) . getView ( ) ; for ( SSTableReader reader : view . allKnownSSTables ( ) ) reader . addTo ( expected ) ; } } } } } 
