package io . netty . microbench . buffer ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . SlicedByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . microbench . util . AbstractMicrobenchmark ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Measurement ; import org . openjdk . jmh . annotations . Scope ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . annotations . State ; import org . openjdk . jmh . annotations . TearDown ; import org . openjdk . jmh . annotations . Warmup ; @State ( Scope . Benchmark ) @Warmup ( iterations = <int> ) @Measurement ( iterations = <int> ) public class SlicedByteBufBenchmark extends AbstractMicrobenchmark { private ByteBuf slicedByteBuf ; private ByteBuf slicedAbstractByteBuf ; private String ascii ; @Setup public void setup ( ) { ByteBuf buffer = Unpooled . buffer ( <int> ) . retain ( ) ; slicedByteBuf = new SlicedByteBuf ( buffer , <int> , <int> ) ; slicedAbstractByteBuf = buffer . slice ( <int> , <int> ) ; if ( slicedByteBuf . getClass ( ) = = slicedAbstractByteBuf . getClass ( ) ) { throw new IllegalStateException ( ) ; } StringBuilder asciiSequence = new StringBuilder ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { asciiSequence . append ( <str> ) ; } ascii = asciiSequence . toString ( ) ; } @TearDown public void tearDown ( ) { slicedByteBuf . release ( ) ; slicedAbstractByteBuf . release ( ) ; } @Benchmark public void writeAsciiStringSlice ( ) { slicedByteBuf . resetWriterIndex ( ) ; ByteBufUtil . writeAscii ( slicedByteBuf , ascii ) ; } @Benchmark public void writeAsciiStringSliceAbstract ( ) { slicedAbstractByteBuf . resetWriterIndex ( ) ; ByteBufUtil . writeAscii ( slicedAbstractByteBuf , ascii ) ; } } 
