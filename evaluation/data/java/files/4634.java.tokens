package io . netty . channel ; import io . netty . util . AbstractReferenceCounted ; import io . netty . util . IllegalReferenceCountException ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; import java . nio . channels . WritableByteChannel ; public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DefaultFileRegion . class ) ; private final File f ; private final long position ; private final long count ; private long transfered ; private FileChannel file ; public DefaultFileRegion ( FileChannel file , long position , long count ) { if ( file = = null ) { throw new NullPointerException ( <str> ) ; } if ( position < <int> ) { throw new IllegalArgumentException ( <str> + position ) ; } if ( count < <int> ) { throw new IllegalArgumentException ( <str> + count ) ; } this . file = file ; this . position = position ; this . count = count ; f = null ; } public DefaultFileRegion ( File f , long position , long count ) { if ( f = = null ) { throw new NullPointerException ( <str> ) ; } if ( position < <int> ) { throw new IllegalArgumentException ( <str> + position ) ; } if ( count < <int> ) { throw new IllegalArgumentException ( <str> + count ) ; } this . position = position ; this . count = count ; this . f = f ; } public boolean isOpen ( ) { return file ! = null ; } public void open ( ) throws IOException { if ( ! isOpen ( ) & & refCnt ( ) > <int> ) { file = new RandomAccessFile ( f , <str> ) . getChannel ( ) ; } } @Override public long position ( ) { return position ; } @Override public long count ( ) { return count ; } @Override public long transfered ( ) { return transfered ; } @Override public long transferTo ( WritableByteChannel target , long position ) throws IOException { long count = this . count - position ; if ( count < <int> | | position < <int> ) { throw new IllegalArgumentException ( <str> + position + <str> + ( this . count - <int> ) + <str> ) ; } if ( count = = <int> ) { return <int> ; } if ( refCnt ( ) = = <int> ) { throw new IllegalReferenceCountException ( <int> ) ; } open ( ) ; long written = file . transferTo ( this . position + position , count , target ) ; if ( written > <int> ) { transfered + = written ; } return written ; } @Override protected void deallocate ( ) { FileChannel file = this . file ; if ( file = = null ) { return ; } this . file = null ; try { file . close ( ) ; } catch ( IOException e ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , e ) ; } } } @Override public FileRegion retain ( ) { super . retain ( ) ; return this ; } @Override public FileRegion retain ( int increment ) { super . retain ( increment ) ; return this ; } @Override public FileRegion touch ( ) { return this ; } @Override public FileRegion touch ( Object hint ) { return this ; } }