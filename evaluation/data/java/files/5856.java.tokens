package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . Arrays ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import org . junit . Test ; import rx . Observable ; import rx . Observer ; import rx . functions . Action1 ; import rx . observers . TestSubscriber ; public class OperatorSkipTest { @Test public void testSkipNegativeElements ( ) { Observable < String > skip = Observable . just ( <str> , <str> , <str> ) . lift ( new OperatorSkip < String > ( - <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipZeroElements ( ) { Observable < String > skip = Observable . just ( <str> , <str> , <str> ) . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipOneElement ( ) { Observable < String > skip = Observable . just ( <str> , <str> , <str> ) . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipTwoElements ( ) { Observable < String > skip = Observable . just ( <str> , <str> , <str> ) . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipEmptyStream ( ) { Observable < String > w = Observable . empty ( ) ; Observable < String > skip = w . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipMultipleObservers ( ) { Observable < String > skip = Observable . just ( <str> , <str> , <str> ) . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer1 = mock ( Observer . class ) ; skip . subscribe ( observer1 ) ; @SuppressWarnings ( <str> ) Observer < String > observer2 = mock ( Observer . class ) ; skip . subscribe ( observer2 ) ; verify ( observer1 , times ( <int> ) ) . onNext ( any ( String . class ) ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer1 , times ( <int> ) ) . onCompleted ( ) ; verify ( observer2 , times ( <int> ) ) . onNext ( any ( String . class ) ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer2 , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSkipError ( ) { Exception e = new Exception ( ) ; Observable < String > ok = Observable . just ( <str> ) ; Observable < String > error = Observable . error ( e ) ; Observable < String > skip = Observable . concat ( ok , error ) . lift ( new OperatorSkip < String > ( <int> ) ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , times ( <int> ) ) . onError ( e ) ; verify ( observer , never ( ) ) . onCompleted ( ) ; } @Test public void testBackpressureMultipleSmallAsyncRequests ( ) throws InterruptedException { final AtomicLong requests = new AtomicLong ( <int> ) ; TestSubscriber < Long > ts = new TestSubscriber < Long > ( <int> ) ; Observable . interval ( <int> , TimeUnit . MILLISECONDS ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { requests . addAndGet ( n ) ; } } ) . skip ( <int> ) . subscribe ( ts ) ; Thread . sleep ( <int> ) ; ts . requestMore ( <int> ) ; ts . requestMore ( <int> ) ; Thread . sleep ( <int> ) ; ts . unsubscribe ( ) ; ts . assertUnsubscribed ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , requests . get ( ) ) ; } @Test public void testRequestOverflowDoesNotOccur ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( Long . MAX_VALUE - <int> ) ; Observable . range ( <int> , <int> ) . skip ( <int> ) . subscribe ( ts ) ; ts . assertTerminalEvent ( ) ; ts . assertCompleted ( ) ; ts . assertNoErrors ( ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , ts . getOnNextEvents ( ) ) ; } }