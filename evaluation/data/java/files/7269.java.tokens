package org . apache . cassandra . cql3 . statements ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; import org . apache . cassandra . db . Clustering ; import org . apache . cassandra . db . CompactTables ; import org . apache . cassandra . db . Slice ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkContainsNoDuplicates ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; public class UpdateStatement extends ModificationStatement { private static final Constants . Value EMPTY = new Constants . Value ( ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; private UpdateStatement ( StatementType type , int boundTerms , CFMetaData cfm , Operations operations , StatementRestrictions restrictions , Conditions conditions , Attributes attrs ) { super ( type , boundTerms , cfm , operations , restrictions , conditions , attrs ) ; } public boolean requireFullClusteringKey ( ) { return true ; } @Override public void addUpdateForKey ( PartitionUpdate update , Clustering clustering , UpdateParameters params ) { if ( updatesRegularRows ( ) ) { params . newRow ( clustering ) ; if ( type . isInsert ( ) & & cfm . isCQLTable ( ) ) params . addPrimaryKeyLivenessInfo ( ) ; List < Operation > updates = getRegularOperations ( ) ; if ( cfm . isCompactTable ( ) & & updates . isEmpty ( ) ) { checkTrue ( CompactTables . hasEmptyCompactValue ( cfm ) , <str> , cfm . compactValueColumn ( ) . name ) ; updates = Collections . < Operation > singletonList ( new Constants . Setter ( cfm . compactValueColumn ( ) , EMPTY ) ) ; } for ( Operation op : updates ) op . execute ( update . partitionKey ( ) , params ) ; update . add ( params . buildRow ( ) ) ; } if ( updatesStaticRow ( ) ) { params . newRow ( Clustering . STATIC_CLUSTERING ) ; for ( Operation op : getStaticOperations ( ) ) op . execute ( update . partitionKey ( ) , params ) ; update . add ( params . buildRow ( ) ) ; } } @Override public void addUpdateForKey ( PartitionUpdate update , Slice slice , UpdateParameters params ) { throw new UnsupportedOperationException ( ) ; } public static class ParsedInsert extends ModificationStatement . Parsed { private final List < ColumnIdentifier . Raw > columnNames ; private final List < Term . Raw > columnValues ; public ParsedInsert ( CFName name , Attributes . Raw attrs , List < ColumnIdentifier . Raw > columnNames , List < Term . Raw > columnValues , boolean ifNotExists ) { super ( name , StatementType . INSERT , attrs , null , ifNotExists , false ) ; this . columnNames = columnNames ; this . columnValues = columnValues ; } @Override protected ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Conditions conditions , Attributes attrs ) { checkFalse ( cfm . isCounter ( ) , <str> ) ; checkFalse ( columnNames = = null , <str> ) ; checkFalse ( columnNames . isEmpty ( ) , <str> ) ; checkFalse ( columnNames . size ( ) ! = columnValues . size ( ) , <str> ) ; checkContainsNoDuplicates ( columnNames , <str> ) ; WhereClause . Builder whereClause = new WhereClause . Builder ( ) ; Operations operations = new Operations ( type ) ; boolean hasClusteringColumnsSet = false ; for ( int i = <int> ; i < columnNames . size ( ) ; i + + ) { ColumnDefinition def = getColumnDefinition ( cfm , columnNames . get ( i ) ) ; if ( def . isClusteringColumn ( ) ) hasClusteringColumnsSet = true ; Term . Raw value = columnValues . get ( i ) ; if ( def . isPrimaryKeyColumn ( ) ) { whereClause . add ( new SingleColumnRelation ( columnNames . get ( i ) , Operator . EQ , value ) ) ; } else { Operation operation = new Operation . SetValue ( value ) . prepare ( keyspace ( ) , def ) ; operation . collectMarkerSpecification ( boundNames ) ; operations . add ( operation ) ; } } boolean applyOnlyToStaticColumns = appliesOnlyToStaticColumns ( operations , conditions ) & & ! hasClusteringColumnsSet ; StatementRestrictions restrictions = new StatementRestrictions ( type , cfm , whereClause . build ( ) , boundNames , applyOnlyToStaticColumns , false , false , false ) ; return new UpdateStatement ( type , boundNames . size ( ) , cfm , operations , restrictions , conditions , attrs ) ; } } public static class ParsedInsertJson extends ModificationStatement . Parsed { private final Json . Raw jsonValue ; public ParsedInsertJson ( CFName name , Attributes . Raw attrs , Json . Raw jsonValue , boolean ifNotExists ) { super ( name , StatementType . INSERT , attrs , null , ifNotExists , false ) ; this . jsonValue = jsonValue ; } @Override protected ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Conditions conditions , Attributes attrs ) { checkFalse ( cfm . isCounter ( ) , <str> ) ; Collection < ColumnDefinition > defs = cfm . allColumns ( ) ; Json . Prepared prepared = jsonValue . prepareAndCollectMarkers ( cfm , defs , boundNames ) ; WhereClause . Builder whereClause = new WhereClause . Builder ( ) ; Operations operations = new Operations ( type ) ; boolean hasClusteringColumnsSet = false ; for ( ColumnDefinition def : defs ) { if ( def . isClusteringColumn ( ) ) hasClusteringColumnsSet = true ; Term . Raw raw = prepared . getRawTermForColumn ( def ) ; if ( def . isPrimaryKeyColumn ( ) ) { whereClause . add ( new SingleColumnRelation ( new ColumnIdentifier . ColumnIdentifierValue ( def . name ) , Operator . EQ , raw ) ) ; } else { Operation operation = new Operation . SetValue ( raw ) . prepare ( keyspace ( ) , def ) ; operation . collectMarkerSpecification ( boundNames ) ; operations . add ( operation ) ; } } boolean applyOnlyToStaticColumns = appliesOnlyToStaticColumns ( operations , conditions ) & & ! hasClusteringColumnsSet ; StatementRestrictions restrictions = new StatementRestrictions ( type , cfm , whereClause . build ( ) , boundNames , applyOnlyToStaticColumns , false , false , false ) ; return new UpdateStatement ( type , boundNames . size ( ) , cfm , operations , restrictions , conditions , attrs ) ; } } public static class ParsedUpdate extends ModificationStatement . Parsed { private final List < Pair < ColumnIdentifier . Raw , Operation . RawUpdate > > updates ; private final WhereClause whereClause ; public ParsedUpdate ( CFName name , Attributes . Raw attrs , List < Pair < ColumnIdentifier . Raw , Operation . RawUpdate > > updates , WhereClause whereClause , List < Pair < ColumnIdentifier . Raw , ColumnCondition . Raw > > conditions , boolean ifExists ) { super ( name , StatementType . UPDATE , attrs , conditions , false , ifExists ) ; this . updates = updates ; this . whereClause = whereClause ; } @Override protected ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Conditions conditions , Attributes attrs ) { Operations operations = new Operations ( type ) ; for ( Pair < ColumnIdentifier . Raw , Operation . RawUpdate > entry : updates ) { ColumnDefinition def = getColumnDefinition ( cfm , entry . left ) ; checkFalse ( def . isPrimaryKeyColumn ( ) , <str> , def . name ) ; Operation operation = entry . right . prepare ( keyspace ( ) , def ) ; operation . collectMarkerSpecification ( boundNames ) ; operations . add ( operation ) ; } StatementRestrictions restrictions = newRestrictions ( cfm , boundNames , operations , whereClause , conditions ) ; return new UpdateStatement ( type , boundNames . size ( ) , cfm , operations , restrictions , conditions , attrs ) ; } } }