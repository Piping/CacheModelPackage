if ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) = = STARTED ) { numStarted + + ; } else if ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) = = RELOCATING ) { numRelocating + + ; } } assertEquals ( numStarted , <int> ) ; assertEquals ( numRelocating , <int> ) ; } public void testRebalanceWhileShardFetching ( ) { final AtomicBoolean hasFetches = new AtomicBoolean ( true ) ; AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , ClusterRebalanceAllocationDecider . ClusterRebalanceType . ALWAYS . toString ( ) ) . build ( ) , new NoopGatewayAllocator ( ) { @Override public boolean allocateUnassigned ( RoutingAllocation allocation ) { if ( hasFetches . get ( ) ) { allocation . setHasPendingAsyncFetch ( ) ; } return super . allocateUnassigned ( allocation ) ; } } ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( FilterAllocationDecider . INDEX_ROUTING_EXCLUDE_GROUP + <str> , <str> ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( INITIALIZING ) ) ; } logger . debug ( <str> ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( <str> , INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; } logger . debug ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; logger . debug ( <str> ) ; RoutingAllocation . Result reroute = strategy . reroute ( clusterState , <str> ) ; assertFalse ( reroute . changed ( ) ) ; routingTable = reroute . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; } for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } logger . debug ( <str> ) ; hasFetches . set ( false ) ; reroute = strategy . reroute ( clusterState , <str> ) ; assertTrue ( reroute . changed ( ) ) ; routingTable = reroute . routingTable ( ) ; int numStarted = <int> ; int numRelocating = <int> ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; if ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) = = STARTED ) { numStarted + + ; } else if ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) = = RELOCATING ) { numRelocating + + ; } } for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } assertEquals ( numStarted , <int> ) ; assertEquals ( numRelocating , <int> ) ; } } 
