package jcuda . utils ; import java . util . Arrays ; import jcuda . CudaException ; public class Compare { private static final float MIN_EPSILON_ERROR = <int> e - <int> f ; private static boolean verbose = false ; public static void setVerbose ( boolean verbose ) { Compare . verbose = verbose ; } private Compare ( ) { } public static boolean compare ( float reference [ ] , float data [ ] ) { return Arrays . equals ( reference , data ) ; } public static boolean compare ( int reference [ ] , int data [ ] ) { return Arrays . equals ( reference , data ) ; } public static boolean compare ( byte reference [ ] , byte data [ ] ) { return Arrays . equals ( reference , data ) ; } public static boolean compare ( byte reference [ ] , byte data [ ] , float epsilon , float threshold ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } float maxError = Math . max ( ( float ) epsilon , MIN_EPSILON_ERROR ) ; int errorCount = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; i + + ) { float diff = Math . abs ( ( float ) reference [ i ] - ( float ) data [ i ] ) ; if ( diff > = maxError ) { errorCount + + ; if ( verbose ) { if ( errorCount < <int> ) { System . out . printf ( <str> + <str> , maxError , i , reference [ i ] , data [ i ] , ( int ) diff ) ; } } } } if ( threshold = = <float> ) { if ( errorCount > <int> ) { System . out . printf ( <str> , errorCount ) ; } return ( errorCount = = <int> ) ; } else { if ( errorCount > <int> ) { System . out . printf ( <str> , ( float ) errorCount * <int> / ( float ) len , errorCount ) ; } return ( len * threshold > errorCount ) ; } } public static boolean compare ( byte reference [ ] , byte data [ ] , float epsilon ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } float maxError = Math . max ( ( float ) epsilon , MIN_EPSILON_ERROR ) ; int errorCount = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; + + i ) { float diff = Math . abs ( ( float ) reference [ i ] - ( float ) data [ i ] ) ; if ( diff > = maxError ) { errorCount + + ; if ( verbose ) { if ( errorCount < <int> ) { System . out . printf ( <str> + <str> , maxError , i , reference [ i ] , data [ i ] , ( int ) diff ) ; } } } } if ( errorCount > <int> ) { System . out . printf ( <str> , errorCount ) ; } return ( errorCount = = <int> ) ; } public static boolean compare ( int reference [ ] , int data [ ] , float epsilon , float threshold ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } float maxError = Math . max ( ( float ) epsilon , MIN_EPSILON_ERROR ) ; int errorCount = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; i + + ) { float diff = Math . abs ( ( float ) reference [ i ] - ( float ) data [ i ] ) ; if ( diff > = maxError ) { errorCount + + ; if ( verbose ) { if ( errorCount < <int> ) { System . out . printf ( <str> + <str> , maxError , i , reference [ i ] , data [ i ] , ( int ) diff ) ; } } } } if ( threshold = = <float> ) { if ( errorCount > <int> ) { System . out . printf ( <str> , errorCount ) ; } return ( errorCount = = <int> ) ; } else { if ( errorCount > <int> ) { System . out . printf ( <str> , ( float ) errorCount * <int> / ( float ) len , errorCount ) ; } return ( len * threshold > errorCount ) ; } } public static boolean compare ( int reference [ ] , int data [ ] , float epsilon ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } float maxError = Math . max ( ( float ) epsilon , MIN_EPSILON_ERROR ) ; int errorCount = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; + + i ) { float diff = Math . abs ( ( float ) reference [ i ] - ( float ) data [ i ] ) ; if ( diff > = maxError ) { errorCount + + ; if ( verbose ) { if ( errorCount < <int> ) { System . out . printf ( <str> + <str> , maxError , i , reference [ i ] , data [ i ] , ( int ) diff ) ; } } } } if ( errorCount > <int> ) { System . out . printf ( <str> , errorCount ) ; } return ( errorCount = = <int> ) ; } public static boolean compare ( float reference [ ] , float data [ ] , float epsilon ) { return compare ( reference , data , epsilon , <float> ) ; } public static boolean compare ( float reference [ ] , float data [ ] , float epsilon , float threshold ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } boolean result = true ; int errorCount = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; + + i ) { float diff = reference [ i ] - data [ i ] ; boolean comp = ( diff < = epsilon ) & & ( diff > = - epsilon ) ; result & = comp ; if ( ! comp ) { errorCount + + ; } if ( verbose ) { if ( ! comp ) { System . out . println ( <str> + i + <str> + reference [ i ] + <str> + data [ i ] + <str> ) ; } } } if ( threshold = = <float> ) { return result ; } else { if ( errorCount > <int> ) { System . out . printf ( <str> , ( float ) errorCount * <int> / ( float ) len , errorCount ) ; } return ( len * threshold > errorCount ) ; } } public static boolean compareL2 ( float reference [ ] , float data [ ] , float epsilon ) { if ( epsilon < <int> ) { throw new CudaException ( <str> + epsilon ) ; } float error = <int> ; float ref = <int> ; int len = Math . min ( reference . length , data . length ) ; for ( int i = <int> ; i < len ; + + i ) { float diff = reference [ i ] - data [ i ] ; error + = diff * diff ; ref + = reference [ i ] * reference [ i ] ; } float normRef = ( float ) Math . sqrt ( ref ) ; if ( Math . abs ( ref ) < <int> e - <int> ) { if ( verbose ) { System . out . println ( <str> ) ; } return false ; } float normError = ( float ) Math . sqrt ( error ) ; error = normError / normRef ; boolean result = error < epsilon ; if ( verbose ) { if ( ! result ) { System . out . println ( <str> + error + <str> + epsilon + <str> ) ; } } return result ; } }