package org . apache . cassandra . db . compaction ; import java . util . List ; import java . util . UUID ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . PurgeFunction ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterators ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . index . transactions . CompactionTransaction ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . metrics . CompactionMetrics ; public class CompactionIterator extends CompactionInfo . Holder implements UnfilteredPartitionIterator { private static final Logger logger = LoggerFactory . getLogger ( CompactionIterator . class ) ; private static final long UNFILTERED_TO_UPDATE_PROGRESS = <int> ; private final OperationType type ; private final CompactionController controller ; private final List < ISSTableScanner > scanners ; private final int nowInSec ; private final UUID compactionId ; private final long totalBytes ; private long bytesRead ; private final long [ ] mergeCounters ; private final UnfilteredPartitionIterator compacted ; private final CompactionMetrics metrics ; public CompactionIterator ( OperationType type , List < ISSTableScanner > scanners , CompactionController controller , int nowInSec , UUID compactionId ) { this ( type , scanners , controller , nowInSec , compactionId , null ) ; } @SuppressWarnings ( <str> ) public CompactionIterator ( OperationType type , List < ISSTableScanner > scanners , CompactionController controller , int nowInSec , UUID compactionId , CompactionMetrics metrics ) { this . controller = controller ; this . type = type ; this . scanners = scanners ; this . nowInSec = nowInSec ; this . compactionId = compactionId ; this . bytesRead = <int> ; long bytes = <int> ; for ( ISSTableScanner scanner : scanners ) bytes + = scanner . getLengthInBytes ( ) ; this . totalBytes = bytes ; this . mergeCounters = new long [ scanners . size ( ) ] ; this . metrics = metrics ; if ( metrics ! = null ) metrics . beginCompaction ( this ) ; UnfilteredPartitionIterator merged = scanners . isEmpty ( ) ? EmptyIterators . unfilteredPartition ( controller . cfs . metadata , false ) : UnfilteredPartitionIterators . merge ( scanners , nowInSec , listener ( ) ) ; boolean isForThrift = merged . isForThrift ( ) ; this . compacted = Transformation . apply ( merged , new Purger ( isForThrift , controller ) ) ; } public boolean isForThrift ( ) { return false ; } public CFMetaData metadata ( ) { return controller . cfs . metadata ; } public CompactionInfo getCompactionInfo ( ) { return new CompactionInfo ( controller . cfs . metadata , type , bytesRead , totalBytes , compactionId ) ; } private void updateCounterFor ( int rows ) { assert rows > <int> & & rows - <int> < mergeCounters . length ; mergeCounters [ rows - <int> ] + = <int> ; } public long [ ] getMergedRowCounts ( ) { return mergeCounters ; } private UnfilteredPartitionIterators . MergeListener listener ( ) { return new UnfilteredPartitionIterators . MergeListener ( ) { public UnfilteredRowIterators . MergeListener getRowMergeListener ( DecoratedKey partitionKey , List < UnfilteredRowIterator > versions ) { int merged = <int> ; for ( UnfilteredRowIterator iter : versions ) { if ( iter ! = null ) merged + + ; } assert merged > <int> ; CompactionIterator . this . updateCounterFor ( merged ) ; if ( type ! = OperationType . COMPACTION | | ! controller . cfs . indexManager . hasIndexes ( ) ) return null ; Columns statics = Columns . NONE ; Columns regulars = Columns . NONE ; for ( UnfilteredRowIterator iter : versions ) { if ( iter ! = null ) { statics = statics . mergeTo ( iter . columns ( ) . statics ) ; regulars = regulars . mergeTo ( iter . columns ( ) . regulars ) ; } } final PartitionColumns partitionColumns = new PartitionColumns ( statics , regulars ) ; final CompactionTransaction indexTransaction = controller . cfs . indexManager . newCompactionTransaction ( partitionKey , partitionColumns , versions . size ( ) , nowInSec ) ; return new UnfilteredRowIterators . MergeListener ( ) { public void onMergedPartitionLevelDeletion ( DeletionTime mergedDeletion , DeletionTime [ ] versions ) { } public void onMergedRows ( Row merged , Row [ ] versions ) { indexTransaction . start ( ) ; indexTransaction . onRowMerge ( merged , versions ) ; indexTransaction . commit ( ) ; } public void onMergedRangeTombstoneMarkers ( RangeTombstoneMarker mergedMarker , RangeTombstoneMarker [ ] versions ) { } public void close ( ) { } } ; } public void close ( ) { } } ; } private void updateBytesRead ( ) { long n = <int> ; for ( ISSTableScanner scanner : scanners ) n + = scanner . getCurrentPosition ( ) ; bytesRead = n ; } public boolean hasNext ( ) { return compacted . hasNext ( ) ; } public UnfilteredRowIterator next ( ) { return compacted . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public void close ( ) { try { compacted . close ( ) ; } finally { if ( metrics ! = null ) metrics . finishCompaction ( this ) ; } } public String toString ( ) { return this . getCompactionInfo ( ) . toString ( ) ; } private class Purger extends PurgeFunction { private final CompactionController controller ; private DecoratedKey currentKey ; private long maxPurgeableTimestamp ; private boolean hasCalculatedMaxPurgeableTimestamp ; private long compactedUnfiltered ; private Purger ( boolean isForThrift , CompactionController controller ) { super ( isForThrift , controller . gcBefore , controller . compactingRepaired ( ) ? Integer . MIN_VALUE : Integer . MAX_VALUE , controller . cfs . getCompactionStrategyManager ( ) . onlyPurgeRepairedTombstones ( ) ) ; this . controller = controller ; } @Override protected void onEmptyPartitionPostPurge ( DecoratedKey key ) { if ( type = = OperationType . COMPACTION ) controller . cfs . invalidateCachedPartition ( key ) ; } @Override protected void onNewPartition ( DecoratedKey key ) { currentKey = key ; hasCalculatedMaxPurgeableTimestamp = false ; } @Override protected void updateProgress ( ) { if ( ( + + compactedUnfiltered ) % UNFILTERED_TO_UPDATE_PROGRESS = = <int> ) updateBytesRead ( ) ; } protected long getMaxPurgeableTimestamp ( ) { if ( ! hasCalculatedMaxPurgeableTimestamp ) { hasCalculatedMaxPurgeableTimestamp = true ; maxPurgeableTimestamp = controller . maxPurgeableTimestamp ( currentKey ) ; } return maxPurgeableTimestamp ; } } } 
