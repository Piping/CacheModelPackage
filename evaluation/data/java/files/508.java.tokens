package org . elasticsearch . index . query ; import org . apache . lucene . search . BoostQuery ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . spans . SpanBoostQuery ; import org . apache . lucene . search . spans . SpanMultiTermQueryWrapper ; import org . apache . lucene . search . spans . SpanQuery ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . Objects ; public class SpanMultiTermQueryBuilder extends AbstractQueryBuilder < SpanMultiTermQueryBuilder > implements SpanQueryBuilder < SpanMultiTermQueryBuilder > { public static final String NAME = <str> ; private final MultiTermQueryBuilder multiTermQueryBuilder ; static final SpanMultiTermQueryBuilder PROTOTYPE = new SpanMultiTermQueryBuilder ( RangeQueryBuilder . PROTOTYPE ) ; public SpanMultiTermQueryBuilder ( MultiTermQueryBuilder multiTermQueryBuilder ) { if ( multiTermQueryBuilder = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . multiTermQueryBuilder = multiTermQueryBuilder ; } public MultiTermQueryBuilder innerQuery ( ) { return this . multiTermQueryBuilder ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( SpanMultiTermQueryParser . MATCH_FIELD . getPreferredName ( ) ) ; multiTermQueryBuilder . toXContent ( builder , params ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { Query subQuery = multiTermQueryBuilder . toQuery ( context ) ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; if ( subQuery instanceof BoostQuery ) { BoostQuery boostQuery = ( BoostQuery ) subQuery ; subQuery = boostQuery . getQuery ( ) ; boost = boostQuery . getBoost ( ) ; } assert subQuery instanceof SpanBoostQuery = = false ; if ( subQuery instanceof MultiTermQuery = = false ) { throw new UnsupportedOperationException ( <str> + MultiTermQuery . class . getName ( ) + <str> + subQuery . getClass ( ) . getName ( ) ) ; } SpanQuery wrapper = new SpanMultiTermQueryWrapper < > ( ( MultiTermQuery ) subQuery ) ; if ( boost ! = AbstractQueryBuilder . DEFAULT_BOOST ) { wrapper = new SpanBoostQuery ( wrapper , boost ) ; } return wrapper ; } @Override protected SpanMultiTermQueryBuilder doReadFrom ( StreamInput in ) throws IOException { MultiTermQueryBuilder multiTermBuilder = ( MultiTermQueryBuilder ) in . readQuery ( ) ; return new SpanMultiTermQueryBuilder ( multiTermBuilder ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeQuery ( multiTermQueryBuilder ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( multiTermQueryBuilder ) ; } @Override protected boolean doEquals ( SpanMultiTermQueryBuilder other ) { return Objects . equals ( multiTermQueryBuilder , other . multiTermQueryBuilder ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
