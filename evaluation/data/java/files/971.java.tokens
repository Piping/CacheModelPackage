package org . gradle . api . internal . tasks . compile ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . tasks . WorkResult ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . ExecHandle ; import org . gradle . process . internal . ExecHandleBuilder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . Serializable ; public class CommandLineJavaCompiler implements Compiler < JavaCompileSpec > , Serializable { private static final Logger LOGGER = LoggerFactory . getLogger ( CommandLineJavaCompiler . class ) ; private final CompileSpecToArguments < JavaCompileSpec > argumentsGenerator = new CommandLineJavaCompilerArgumentsGenerator ( ) ; public WorkResult execute ( JavaCompileSpec spec ) { String executable = spec . getCompileOptions ( ) . getForkOptions ( ) . getExecutable ( ) ; LOGGER . info ( <str> , executable ) ; ExecHandle handle = createCompilerHandle ( executable , spec ) ; executeCompiler ( handle ) ; return new SimpleWorkResult ( true ) ; } private ExecHandle createCompilerHandle ( String executable , JavaCompileSpec spec ) { ExecHandleBuilder builder = new ExecHandleBuilder ( ) ; builder . setWorkingDir ( spec . getWorkingDir ( ) ) ; builder . setExecutable ( executable ) ; argumentsGenerator . collectArguments ( spec , new ExecSpecBackedArgCollector ( builder ) ) ; builder . setIgnoreExitValue ( true ) ; return builder . build ( ) ; } private void executeCompiler ( ExecHandle handle ) { handle . start ( ) ; ExecResult result = handle . waitForFinish ( ) ; if ( result . getExitValue ( ) ! = <int> ) { throw new CompilationFailedException ( result . getExitValue ( ) ) ; } } } 
