package org . apache . cassandra . io . sstable ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . cache . InstrumentingCache ; import org . apache . cassandra . cache . KeyCacheKey ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . RowIndexEntry ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableWriter ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . utils . CLibrary ; import org . apache . cassandra . utils . concurrent . Transactional ; public class SSTableRewriter extends Transactional . AbstractTransactional implements Transactional { @VisibleForTesting public static boolean disableEarlyOpeningForTests = false ; private final long preemptiveOpenInterval ; private final long maxAge ; private long repairedAt = - <int> ; private final LifecycleTransaction transaction ; private final List < SSTableReader > preparedForCommit = new ArrayList < > ( ) ; private long currentlyOpenedEarlyAt ; private final List < SSTableWriter > writers = new ArrayList < > ( ) ; private final boolean isOffline ; private final boolean keepOriginals ; private SSTableWriter writer ; private Map < DecoratedKey , RowIndexEntry > cachedKeys = new HashMap < > ( ) ; private boolean throwEarly , throwLate ; public SSTableRewriter ( LifecycleTransaction transaction , long maxAge , boolean isOffline ) { this ( transaction , maxAge , isOffline , true ) ; } public SSTableRewriter ( LifecycleTransaction transaction , long maxAge , boolean isOffline , boolean shouldOpenEarly ) { this ( transaction , maxAge , isOffline , calculateOpenInterval ( shouldOpenEarly ) , false ) ; } @VisibleForTesting public SSTableRewriter ( LifecycleTransaction transaction , long maxAge , boolean isOffline , long preemptiveOpenInterval , boolean keepOriginals ) { this . transaction = transaction ; this . maxAge = maxAge ; this . isOffline = isOffline ; this . keepOriginals = keepOriginals ; this . preemptiveOpenInterval = preemptiveOpenInterval ; } public static SSTableRewriter constructKeepingOriginals ( LifecycleTransaction transaction , boolean keepOriginals , long maxAge , boolean isOffline ) { return new SSTableRewriter ( transaction , maxAge , isOffline , calculateOpenInterval ( true ) , keepOriginals ) ; } private static long calculateOpenInterval ( boolean shouldOpenEarly ) { long interval = DatabaseDescriptor . getSSTablePreempiveOpenIntervalInMB ( ) * ( <int> < < <int> ) ; if ( disableEarlyOpeningForTests | | ! shouldOpenEarly | | interval < <int> ) interval = Long . MAX_VALUE ; return interval ; } public SSTableWriter currentWriter ( ) { return writer ; } public RowIndexEntry append ( UnfilteredRowIterator partition ) { DecoratedKey key = partition . partitionKey ( ) ; maybeReopenEarly ( key ) ; RowIndexEntry index = writer . append ( partition ) ; if ( ! isOffline & & index ! = null ) { boolean save = false ; for ( SSTableReader reader : transaction . originals ( ) ) { if ( reader . getCachedPosition ( key , false ) ! = null ) { save = true ; break ; } } if ( save ) cachedKeys . put ( key , index ) ; } return index ; } public RowIndexEntry tryAppend ( UnfilteredRowIterator partition ) { writer . mark ( ) ; try { return append ( partition ) ; } catch ( Throwable t ) { writer . resetAndTruncate ( ) ; throw t ; } } private void maybeReopenEarly ( DecoratedKey key ) { if ( writer . getFilePointer ( ) - currentlyOpenedEarlyAt > preemptiveOpenInterval ) { if ( isOffline ) { for ( SSTableReader reader : transaction . originals ( ) ) { RowIndexEntry index = reader . getPosition ( key , SSTableReader . Operator . GE ) ; CLibrary . trySkipCache ( reader . getFilename ( ) , <int> , index = = null ? <int> : index . position ) ; } } else { SSTableReader reader = writer . setMaxDataAge ( maxAge ) . openEarly ( ) ; if ( reader ! = null ) { transaction . update ( reader , false ) ; currentlyOpenedEarlyAt = writer . getFilePointer ( ) ; moveStarts ( reader , reader . last ) ; transaction . checkpoint ( ) ; } } } } protected Throwable doAbort ( Throwable accumulate ) { for ( SSTableWriter writer : writers ) accumulate = writer . abort ( accumulate ) ; accumulate = transaction . abort ( accumulate ) ; return accumulate ; } protected Throwable doCommit ( Throwable accumulate ) { for ( SSTableWriter writer : writers ) accumulate = writer . commit ( accumulate ) ; accumulate = transaction . commit ( accumulate ) ; return accumulate ; } private void moveStarts ( SSTableReader newReader , DecoratedKey lowerbound ) { if ( isOffline ) return ; if ( preemptiveOpenInterval = = Long . MAX_VALUE ) return ; final List < DecoratedKey > invalidateKeys = new ArrayList < > ( ) ; invalidateKeys . addAll ( cachedKeys . keySet ( ) ) ; newReader . setupOnline ( ) ; for ( Map . Entry < DecoratedKey , RowIndexEntry > cacheKey : cachedKeys . entrySet ( ) ) newReader . cacheKey ( cacheKey . getKey ( ) , cacheKey . getValue ( ) ) ; cachedKeys = new HashMap < > ( ) ; for ( SSTableReader sstable : transaction . originals ( ) ) { final SSTableReader latest = transaction . current ( sstable ) ; if ( latest . first . compareTo ( lowerbound ) > <int> ) continue ; Runnable runOnClose = new InvalidateKeys ( latest , invalidateKeys ) ; if ( lowerbound . compareTo ( latest . last ) > = <int> ) { if ( ! transaction . isObsolete ( latest ) ) { latest . runOnClose ( runOnClose ) ; transaction . obsolete ( latest ) ; } continue ; } DecoratedKey newStart = latest . firstKeyBeyond ( lowerbound ) ; assert newStart ! = null ; SSTableReader replacement = latest . cloneWithNewStart ( newStart , runOnClose ) ; transaction . update ( replacement , true ) ; } } private static final class InvalidateKeys implements Runnable { final List < KeyCacheKey > cacheKeys = new ArrayList < > ( ) ; final InstrumentingCache < KeyCacheKey , ? > cache ; private InvalidateKeys ( SSTableReader reader , Collection < DecoratedKey > invalidate ) { this . cache = reader . getKeyCache ( ) ; if ( cache ! = null ) { for ( DecoratedKey key : invalidate ) cacheKeys . add ( reader . getCacheKey ( key ) ) ; } } public void run ( ) { for ( KeyCacheKey key : cacheKeys ) cache . remove ( key ) ; } } public void switchWriter ( SSTableWriter newWriter ) { if ( newWriter ! = null ) writers . add ( newWriter . setMaxDataAge ( maxAge ) ) ; if ( writer = = null | | writer . getFilePointer ( ) = = <int> ) { if ( writer ! = null ) { writer . abort ( ) ; transaction . untrackNew ( writer ) ; writers . remove ( writer ) ; } writer = newWriter ; return ; } if ( preemptiveOpenInterval ! = Long . MAX_VALUE ) { SSTableReader reader = writer . setMaxDataAge ( maxAge ) . openFinalEarly ( ) ; transaction . update ( reader , false ) ; moveStarts ( reader , reader . last ) ; transaction . checkpoint ( ) ; } currentlyOpenedEarlyAt = <int> ; writer = newWriter ; } public SSTableRewriter setRepairedAt ( long repairedAt ) { this . repairedAt = repairedAt ; return this ; } public List < SSTableReader > finish ( ) { super . finish ( ) ; return finished ( ) ; } public List < SSTableReader > finished ( ) { assert state ( ) = = State . COMMITTED | | state ( ) = = State . READY_TO_COMMIT ; return preparedForCommit ; } protected void doPrepare ( ) { switchWriter ( null ) ; if ( throwEarly ) throw new RuntimeException ( <str> ) ; for ( SSTableWriter writer : writers ) { assert writer . getFilePointer ( ) > <int> ; writer . setRepairedAt ( repairedAt ) . setOpenResult ( true ) . prepareToCommit ( ) ; SSTableReader reader = writer . finished ( ) ; transaction . update ( reader , false ) ; preparedForCommit . add ( reader ) ; } transaction . checkpoint ( ) ; if ( throwLate ) throw new RuntimeException ( <str> ) ; if ( ! keepOriginals ) transaction . obsoleteOriginals ( ) ; transaction . prepareToCommit ( ) ; } public void throwDuringPrepare ( boolean earlyException ) { if ( earlyException ) throwEarly = true ; else throwLate = true ; } }