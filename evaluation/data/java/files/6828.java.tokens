package org . apache . cassandra . transport . messages ; import java . util . UUID ; import com . google . common . collect . ImmutableMap ; import io . netty . buffer . ByteBuf ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . transport . CBUtil ; import org . apache . cassandra . transport . Message ; import org . apache . cassandra . transport . ProtocolException ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . UUIDGen ; public class QueryMessage extends Message . Request { public static final Message . Codec < QueryMessage > codec = new Message . Codec < QueryMessage > ( ) { public QueryMessage decode ( ByteBuf body , int version ) { String query = CBUtil . readLongString ( body ) ; return new QueryMessage ( query , QueryOptions . codec . decode ( body , version ) ) ; } public void encode ( QueryMessage msg , ByteBuf dest , int version ) { CBUtil . writeLongString ( msg . query , dest ) ; if ( version = = <int> ) CBUtil . writeConsistencyLevel ( msg . options . getConsistency ( ) , dest ) ; else QueryOptions . codec . encode ( msg . options , dest , version ) ; } public int encodedSize ( QueryMessage msg , int version ) { int size = CBUtil . sizeOfLongString ( msg . query ) ; if ( version = = <int> ) { size + = CBUtil . sizeOfConsistencyLevel ( msg . options . getConsistency ( ) ) ; } else { size + = QueryOptions . codec . encodedSize ( msg . options , version ) ; } return size ; } } ; public final String query ; public final QueryOptions options ; public QueryMessage ( String query , QueryOptions options ) { super ( Type . QUERY ) ; this . query = query ; this . options = options ; } public Message . Response execute ( QueryState state ) { try { if ( options . getPageSize ( ) = = <int> ) throw new ProtocolException ( <str> ) ; UUID tracingId = null ; if ( isTracingRequested ( ) ) { tracingId = UUIDGen . getTimeUUID ( ) ; state . prepareTracingSession ( tracingId ) ; } if ( state . traceNextQuery ( ) ) { state . createTracingSession ( ) ; ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; builder . put ( <str> , query ) ; if ( options . getPageSize ( ) > <int> ) builder . put ( <str> , Integer . toString ( options . getPageSize ( ) ) ) ; if ( options . getConsistency ( ) ! = null ) builder . put ( <str> , options . getConsistency ( ) . name ( ) ) ; if ( options . getSerialConsistency ( ) ! = null ) builder . put ( <str> , options . getSerialConsistency ( ) . name ( ) ) ; Tracing . instance . begin ( <str> , state . getClientAddress ( ) , builder . build ( ) ) ; } Message . Response response = ClientState . getCQLQueryHandler ( ) . process ( query , state , options , getCustomPayload ( ) ) ; if ( options . skipMetadata ( ) & & response instanceof ResultMessage . Rows ) ( ( ResultMessage . Rows ) response ) . result . metadata . setSkipMetadata ( ) ; if ( tracingId ! = null ) response . setTracingId ( tracingId ) ; return response ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; if ( ! ( ( e instanceof RequestValidationException ) | | ( e instanceof RequestExecutionException ) ) ) logger . error ( <str> , e ) ; return ErrorMessage . fromException ( e ) ; } finally { Tracing . instance . stopSession ( ) ; } } @Override public String toString ( ) { return <str> + query + <str> + options . getPageSize ( ) + <str> ; } }