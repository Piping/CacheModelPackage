package org . elasticsearch . search . basic ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Priority ; import org . elasticsearch . search . SearchHits ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoTimeout ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; @ESIntegTestCase.ClusterScope ( minNumDataNodes = <int> ) public class SearchWhileRelocatingIT extends ESIntegTestCase { @Nightly public void testSearchAndRelocateConcurrently0Replicas ( ) throws Exception { testSearchAndRelocateConcurrently ( <int> ) ; } @Nightly public void testSearchAndRelocateConcurrently1Replicas ( ) throws Exception { testSearchAndRelocateConcurrently ( <int> ) ; } public void testSearchAndRelocateConcurrentlyRanodmReplicas ( ) throws Exception { testSearchAndRelocateConcurrently ( randomIntBetween ( <int> , <int> ) ) ; } private void testSearchAndRelocateConcurrently ( final int numberOfReplicas ) throws Exception { final int numShards = between ( <int> , <int> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , numShards ) . put ( <str> , numberOfReplicas ) ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; final int numDocs = between ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { indexBuilders . add ( client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) ; } indexRandom ( true , indexBuilders . toArray ( new IndexRequestBuilder [ indexBuilders . size ( ) ] ) ) ; assertHitCount ( client ( ) . prepareSearch ( ) . get ( ) , ( numDocs ) ) ; final int numIters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { final AtomicBoolean stop = new AtomicBoolean ( false ) ; final List < Throwable > thrownExceptions = new CopyOnWriteArrayList < > ( ) ; final List < Throwable > nonCriticalExceptions = new CopyOnWriteArrayList < > ( ) ; Thread [ ] threads = new Thread [ scaledRandomIntBetween ( <int> , <int> ) ] ; for ( int j = <int> ; j < threads . length ; j + + ) { threads [ j ] = new Thread ( ) { @Override public void run ( ) { boolean criticalException = true ; try { while ( ! stop . get ( ) ) { SearchResponse sr = client ( ) . prepareSearch ( ) . setSize ( numDocs ) . get ( ) ; criticalException = sr . getTotalShards ( ) = = sr . getSuccessfulShards ( ) | | sr . getFailedShards ( ) > <int> ; assertHitCount ( sr , ( numDocs ) ) ; criticalException = true ; final SearchHits sh = sr . getHits ( ) ; assertThat ( <str> , sh . getTotalHits ( ) , equalTo ( ( long ) ( sh . getHits ( ) . length ) ) ) ; } } catch ( SearchPhaseExecutionException ex ) { if ( numberOfReplicas = = <int> | | ! ex . getMessage ( ) . contains ( <str> ) ) { thrownExceptions . add ( ex ) ; } } catch ( Throwable t ) { if ( ! criticalException ) { nonCriticalExceptions . add ( t ) ; } else { thrownExceptions . add ( t ) ; } } } } ; } for ( int j = <int> ; j < threads . length ; j + + ) { threads [ j ] . start ( ) ; } allowNodes ( <str> , between ( <int> , <int> ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) ; stop . set ( true ) ; for ( int j = <int> ; j < threads . length ; j + + ) { threads [ j ] . join ( ) ; } ClusterHealthResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForYellowStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . get ( ) ; assertNoTimeout ( resp ) ; if ( ! thrownExceptions . isEmpty ( ) | | ! nonCriticalExceptions . isEmpty ( ) ) { Client client = client ( ) ; boolean postSearchOK = true ; String verified = <str> ; for ( int j = <int> ; j < <int> ; j + + ) { if ( client . prepareSearch ( ) . get ( ) . getHits ( ) . getTotalHits ( ) ! = numDocs ) { verified = <str> ; postSearchOK = false ; break ; } } assertThat ( <str> + numberOfReplicas + <str> + i + <str> + verified , thrownExceptions , Matchers . emptyIterable ( ) ) ; logger . info ( <str> + nonCriticalExceptions . toString ( ) ) ; assertThat ( <str> + numberOfReplicas + <str> + i + <str> + verified , postSearchOK , is ( true ) ) ; } } } } 
