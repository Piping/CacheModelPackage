package org . apache . cassandra . service ; import java . net . InetAddress ; import java . util . Collection ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . WriteType ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . net . IAsyncCallback ; import org . apache . cassandra . net . IAsyncCallbackWithFailure ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . utils . concurrent . SimpleCondition ; public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackWithFailure < T > { protected static final Logger logger = LoggerFactory . getLogger ( AbstractWriteResponseHandler . class ) ; private final SimpleCondition condition = new SimpleCondition ( ) ; protected final Keyspace keyspace ; protected final long start ; protected final Collection < InetAddress > naturalEndpoints ; public final ConsistencyLevel consistencyLevel ; protected final Runnable callback ; protected final Collection < InetAddress > pendingEndpoints ; protected final WriteType writeType ; private static final AtomicIntegerFieldUpdater < AbstractWriteResponseHandler > failuresUpdater = AtomicIntegerFieldUpdater . newUpdater ( AbstractWriteResponseHandler . class , <str> ) ; private volatile int failures = <int> ; protected AbstractWriteResponseHandler ( Keyspace keyspace , Collection < InetAddress > naturalEndpoints , Collection < InetAddress > pendingEndpoints , ConsistencyLevel consistencyLevel , Runnable callback , WriteType writeType ) { this . keyspace = keyspace ; this . pendingEndpoints = pendingEndpoints ; this . start = System . nanoTime ( ) ; this . consistencyLevel = consistencyLevel ; this . naturalEndpoints = naturalEndpoints ; this . callback = callback ; this . writeType = writeType ; } public void get ( ) throws WriteTimeoutException , WriteFailureException { long requestTimeout = writeType = = WriteType . COUNTER ? DatabaseDescriptor . getCounterWriteRpcTimeout ( ) : DatabaseDescriptor . getWriteRpcTimeout ( ) ; long timeout = TimeUnit . MILLISECONDS . toNanos ( requestTimeout ) - ( System . nanoTime ( ) - start ) ; boolean success ; try { success = condition . await ( timeout , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException ex ) { throw new AssertionError ( ex ) ; } if ( ! success ) { int blockedFor = totalBlockFor ( ) ; int acks = ackCount ( ) ; if ( acks > = blockedFor ) acks = blockedFor - <int> ; throw new WriteTimeoutException ( writeType , consistencyLevel , acks , blockedFor ) ; } if ( totalBlockFor ( ) + failures > totalEndpoints ( ) ) { throw new WriteFailureException ( consistencyLevel , ackCount ( ) , failures , totalBlockFor ( ) , writeType ) ; } } protected int totalBlockFor ( ) { return consistencyLevel . blockFor ( keyspace ) + pendingEndpoints . size ( ) ; } protected int totalEndpoints ( ) { return naturalEndpoints . size ( ) + pendingEndpoints . size ( ) ; } protected boolean waitingFor ( InetAddress from ) { return true ; } protected abstract int ackCount ( ) ; public abstract void response ( MessageIn < T > msg ) ; public void assureSufficientLiveNodes ( ) throws UnavailableException { consistencyLevel . assureSufficientLiveNodes ( keyspace , Iterables . filter ( Iterables . concat ( naturalEndpoints , pendingEndpoints ) , isAlive ) ) ; } protected void signal ( ) { condition . signalAll ( ) ; if ( callback ! = null ) callback . run ( ) ; } @Override public void onFailure ( InetAddress from ) { logger . trace ( <str> , from ) ; int n = waitingFor ( from ) ? failuresUpdater . incrementAndGet ( this ) : failures ; if ( totalBlockFor ( ) + n > totalEndpoints ( ) ) signal ( ) ; } } 
