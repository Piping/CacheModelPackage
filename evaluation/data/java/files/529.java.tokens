package com . netflix . hystrix . collapser ; import java . util . Collection ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import rx . Observable ; import rx . functions . Action0 ; import rx . functions . Action1 ; import com . netflix . hystrix . HystrixCollapser ; import com . netflix . hystrix . HystrixCollapser . CollapsedRequest ; import com . netflix . hystrix . HystrixCollapserProperties ; public class RequestBatch < BatchReturnType , ResponseType , RequestArgumentType > { private static final Logger logger = LoggerFactory . getLogger ( HystrixCollapser . class ) ; private final HystrixCollapserBridge < BatchReturnType , ResponseType , RequestArgumentType > commandCollapser ; final ConcurrentLinkedQueue < CollapsedRequest < ResponseType , RequestArgumentType > > requests = new ConcurrentLinkedQueue < CollapsedRequest < ResponseType , RequestArgumentType > > ( ) ; private final AtomicInteger count = new AtomicInteger ( <int> ) ; private final int maxBatchSize ; private final AtomicBoolean batchStarted = new AtomicBoolean ( ) ; private ReentrantReadWriteLock batchLock = new ReentrantReadWriteLock ( ) ; public RequestBatch ( HystrixCollapserProperties properties , HystrixCollapserBridge < BatchReturnType , ResponseType , RequestArgumentType > commandCollapser , int maxBatchSize ) { this . commandCollapser = commandCollapser ; this . maxBatchSize = maxBatchSize ; } public Observable < ResponseType > offer ( RequestArgumentType arg ) { if ( batchStarted . get ( ) ) { return null ; } if ( batchLock . readLock ( ) . tryLock ( ) ) { try { if ( batchStarted . get ( ) ) { return null ; } int s = count . incrementAndGet ( ) ; if ( s > maxBatchSize ) { return null ; } else { CollapsedRequestObservableFunction < ResponseType , RequestArgumentType > f = new CollapsedRequestObservableFunction < ResponseType , RequestArgumentType > ( arg ) ; requests . add ( f ) ; return Observable . create ( f ) ; } } finally { batchLock . readLock ( ) . unlock ( ) ; } } else { return null ; } } public void executeBatchIfNotAlreadyStarted ( ) { if ( batchStarted . compareAndSet ( false , true ) ) { batchLock . writeLock ( ) . lock ( ) ; try { Collection < Collection < CollapsedRequest < ResponseType , RequestArgumentType > > > shards = commandCollapser . shardRequests ( requests ) ; for ( final Collection < CollapsedRequest < ResponseType , RequestArgumentType > > shardRequests : shards ) { try { Observable < BatchReturnType > o = commandCollapser . createObservableCommand ( shardRequests ) ; commandCollapser . mapResponseToRequests ( o , shardRequests ) . doOnError ( new Action1 < Throwable > ( ) { @Override public void call ( Throwable e ) { Exception ee ; if ( e instanceof Exception ) { ee = ( Exception ) e ; } else { ee = new RuntimeException ( <str> , e ) ; } logger . debug ( <str> , e ) ; for ( CollapsedRequest < ResponseType , RequestArgumentType > request : requests ) { try { ( ( CollapsedRequestObservableFunction < ResponseType , RequestArgumentType > ) request ) . setExceptionIfResponseNotReceived ( ee ) ; } catch ( IllegalStateException e2 ) { logger . error ( <str> , e2 ) ; } } } } ) . doOnCompleted ( new Action0 ( ) { @Override public void call ( ) { Exception e = null ; for ( CollapsedRequest < ResponseType , RequestArgumentType > request : shardRequests ) { try { e = ( ( CollapsedRequestObservableFunction < ResponseType , RequestArgumentType > ) request ) . setExceptionIfResponseNotReceived ( e , <str> + commandCollapser . getCollapserKey ( ) . name ( ) + <str> ) ; } catch ( IllegalStateException e2 ) { logger . debug ( <str> , e2 ) ; } } } } ) . subscribe ( ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; for ( CollapsedRequest < ResponseType , RequestArgumentType > request : shardRequests ) { try { request . setException ( e ) ; } catch ( IllegalStateException e2 ) { logger . debug ( <str> , e2 ) ; } } } } } catch ( Exception e ) { logger . error ( <str> , e ) ; for ( CollapsedRequest < ResponseType , RequestArgumentType > request : requests ) { try { request . setException ( e ) ; } catch ( IllegalStateException e2 ) { logger . debug ( <str> , e2 ) ; } } } finally { batchLock . writeLock ( ) . unlock ( ) ; } } } public void shutdown ( ) { if ( batchStarted . compareAndSet ( false , true ) ) { batchLock . writeLock ( ) . lock ( ) ; try { if ( requests . size ( ) > <int> ) { logger . warn ( <str> + requests . size ( ) , new IllegalStateException ( ) ) ; for ( CollapsedRequest < ResponseType , RequestArgumentType > request : requests ) { try { ( ( CollapsedRequestObservableFunction < ResponseType , RequestArgumentType > ) request ) . setExceptionIfResponseNotReceived ( new IllegalStateException ( <str> ) ) ; } catch ( Exception e ) { logger . debug ( <str> , e ) ; } logger . warn ( <str> + request . getArgument ( ) + <str> + request , new IllegalStateException ( ) ) ; } } } finally { batchLock . writeLock ( ) . unlock ( ) ; } } } } 
