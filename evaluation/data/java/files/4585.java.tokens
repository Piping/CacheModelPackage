package io . netty . channel ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . LoggingHandler . Event ; import io . netty . channel . local . LocalAddress ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . GenericFutureListener ; import org . junit . Test ; import java . nio . channels . ClosedChannelException ; import static org . junit . Assert . * ; public class ReentrantChannelTest extends BaseChannelTest { @Test public void testWritabilityChanged ( ) throws Exception { LocalAddress addr = new LocalAddress ( <str> ) ; ServerBootstrap sb = getLocalServerBootstrap ( ) ; sb . bind ( addr ) . sync ( ) . channel ( ) ; Bootstrap cb = getLocalClientBootstrap ( ) ; setInterest ( Event . WRITE , Event . FLUSH , Event . WRITABILITY ) ; Channel clientChannel = cb . connect ( addr ) . sync ( ) . channel ( ) ; clientChannel . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; clientChannel . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ChannelFuture future = clientChannel . write ( createTestBuf ( <int> ) ) ; clientChannel . flush ( ) ; future . sync ( ) ; clientChannel . close ( ) . sync ( ) ; assertLog ( <str> + <str> + <str> + <str> + <str> + <str> , <str> + <str> + <str> + <str> + <str> + <str> ) ; } @Test public void testFlushInWritabilityChanged ( ) throws Exception { LocalAddress addr = new LocalAddress ( <str> ) ; ServerBootstrap sb = getLocalServerBootstrap ( ) ; sb . bind ( addr ) . sync ( ) . channel ( ) ; Bootstrap cb = getLocalClientBootstrap ( ) ; setInterest ( Event . WRITE , Event . FLUSH , Event . WRITABILITY ) ; Channel clientChannel = cb . connect ( addr ) . sync ( ) . channel ( ) ; clientChannel . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; clientChannel . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; clientChannel . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { if ( ! ctx . channel ( ) . isWritable ( ) ) { ctx . channel ( ) . flush ( ) ; } ctx . fireChannelWritabilityChanged ( ) ; } } ) ; assertTrue ( clientChannel . isWritable ( ) ) ; clientChannel . write ( createTestBuf ( <int> ) ) . sync ( ) ; clientChannel . close ( ) . sync ( ) ; assertLog ( <str> + <str> + <str> + <str> + <str> + <str> + <str> , <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; } @Test public void testWriteFlushPingPong ( ) throws Exception { LocalAddress addr = new LocalAddress ( <str> ) ; ServerBootstrap sb = getLocalServerBootstrap ( ) ; sb . bind ( addr ) . sync ( ) . channel ( ) ; Bootstrap cb = getLocalClientBootstrap ( ) ; setInterest ( Event . WRITE , Event . FLUSH , Event . CLOSE , Event . EXCEPTION ) ; Channel clientChannel = cb . connect ( addr ) . sync ( ) . channel ( ) ; clientChannel . pipeline ( ) . addLast ( new ChannelOutboundHandlerAdapter ( ) { int writeCount ; int flushCount ; @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( writeCount < <int> ) { writeCount + + ; ctx . channel ( ) . flush ( ) ; } super . write ( ctx , msg , promise ) ; } @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { if ( flushCount < <int> ) { flushCount + + ; ctx . channel ( ) . write ( createTestBuf ( <int> ) ) ; } super . flush ( ctx ) ; } } ) ; clientChannel . writeAndFlush ( createTestBuf ( <int> ) ) ; clientChannel . close ( ) . sync ( ) ; assertLog ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; } @Test public void testCloseInFlush ( ) throws Exception { LocalAddress addr = new LocalAddress ( <str> ) ; ServerBootstrap sb = getLocalServerBootstrap ( ) ; sb . bind ( addr ) . sync ( ) . channel ( ) ; Bootstrap cb = getLocalClientBootstrap ( ) ; setInterest ( Event . WRITE , Event . FLUSH , Event . CLOSE , Event . EXCEPTION ) ; Channel clientChannel = cb . connect ( addr ) . sync ( ) . channel ( ) ; clientChannel . pipeline ( ) . addLast ( new ChannelOutboundHandlerAdapter ( ) { @Override public void write ( final ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { promise . addListener ( new GenericFutureListener < Future < ? super Void > > ( ) { @Override public void operationComplete ( Future < ? super Void > future ) throws Exception { ctx . channel ( ) . close ( ) ; } } ) ; super . write ( ctx , msg , promise ) ; ctx . channel ( ) . flush ( ) ; } } ) ; clientChannel . write ( createTestBuf ( <int> ) ) . sync ( ) ; clientChannel . closeFuture ( ) . sync ( ) ; assertLog ( <str> ) ; } @Test public void testFlushFailure ( ) throws Exception { LocalAddress addr = new LocalAddress ( <str> ) ; ServerBootstrap sb = getLocalServerBootstrap ( ) ; sb . bind ( addr ) . sync ( ) . channel ( ) ; Bootstrap cb = getLocalClientBootstrap ( ) ; setInterest ( Event . WRITE , Event . FLUSH , Event . CLOSE , Event . EXCEPTION ) ; Channel clientChannel = cb . connect ( addr ) . sync ( ) . channel ( ) ; clientChannel . pipeline ( ) . addLast ( new ChannelOutboundHandlerAdapter ( ) { @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { throw new Exception ( <str> ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { ctx . close ( ) ; } } ) ; try { clientChannel . writeAndFlush ( createTestBuf ( <int> ) ) . sync ( ) ; fail ( ) ; } catch ( Throwable cce ) { assertEquals ( ClosedChannelException . class , cce . getClass ( ) ) ; } clientChannel . closeFuture ( ) . sync ( ) ; assertLog ( <str> ) ; } }