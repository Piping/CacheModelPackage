package rx . internal . operators ; import static org . junit . Assert . * ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . * ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . * ; import rx . * ; import rx . Observable . OnSubscribe ; import rx . Observable ; import rx . Observer ; import rx . functions . * ; import rx . internal . util . UtilityFunctions ; import rx . observers . TestSubscriber ; import rx . schedulers . Schedulers ; public class OperatorWindowWithSizeTest { private static < T > List < List < T > > toLists ( Observable < Observable < T > > observables ) { final List < List < T > > lists = new ArrayList < List < T > > ( ) ; Observable . concat ( observables . map ( new Func1 < Observable < T > , Observable < List < T > > > ( ) { @Override public Observable < List < T > > call ( Observable < T > xs ) { return xs . toList ( ) ; } } ) ) . toBlocking ( ) . forEach ( new Action1 < List < T > > ( ) { @Override public void call ( List < T > xs ) { lists . add ( xs ) ; } } ) ; return lists ; } @Test public void testNonOverlappingWindows ( ) { Observable < String > subject = Observable . just ( <str> , <str> , <str> , <str> , <str> ) ; Observable < Observable < String > > windowed = subject . window ( <int> ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( <int> , windows . size ( ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> ) , windows . get ( <int> ) ) ; } @Test public void testSkipAndCountGaplessWindows ( ) { Observable < String > subject = Observable . just ( <str> , <str> , <str> , <str> , <str> ) ; Observable < Observable < String > > windowed = subject . window ( <int> , <int> ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( <int> , windows . size ( ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> ) , windows . get ( <int> ) ) ; } @Test public void testOverlappingWindows ( ) { Observable < String > subject = Observable . from ( new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ) ; Observable < Observable < String > > windowed = subject . window ( <int> , <int> ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( <int> , windows . size ( ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> ) , windows . get ( <int> ) ) ; } @Test public void testSkipAndCountWindowsWithGaps ( ) { Observable < String > subject = Observable . just ( <str> , <str> , <str> , <str> , <str> ) ; Observable < Observable < String > > windowed = subject . window ( <int> , <int> ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( <int> , windows . size ( ) ) ; assertEquals ( list ( <str> , <str> ) , windows . get ( <int> ) ) ; assertEquals ( list ( <str> , <str> ) , windows . get ( <int> ) ) ; } @Test public void testWindowUnsubscribeNonOverlapping ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( <int> , <int> ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer t1 ) { count . incrementAndGet ( ) ; } } ) . window ( <int> ) . take ( <int> ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , count . get ( ) ) ; } @Test public void testWindowUnsubscribeNonOverlappingAsyncSource ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( <int> , <int> ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer t1 ) { count . incrementAndGet ( ) ; } } ) . observeOn ( Schedulers . computation ( ) ) . window ( <int> ) . take ( <int> ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( count . get ( ) < <int> ) ; } @Test public void testWindowUnsubscribeOverlapping ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( <int> , <int> ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer t1 ) { count . incrementAndGet ( ) ; } } ) . window ( <int> , <int> ) . take ( <int> ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , count . get ( ) ) ; } @Test public void testWindowUnsubscribeOverlappingAsyncSource ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( <int> , <int> ) . doOnNext ( new Action1 < Integer > ( ) { @Override public void call ( Integer t1 ) { count . incrementAndGet ( ) ; } } ) . observeOn ( Schedulers . computation ( ) ) . window ( <int> , <int> ) . take ( <int> ) ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( count . get ( ) < <int> ) ; } private List < String > list ( String . . . args ) { List < String > list = new ArrayList < String > ( ) ; for ( String arg : args ) { list . add ( arg ) ; } return list ; } @Test public void testBackpressureOuter ( ) { Observable < Observable < Integer > > source = Observable . range ( <int> , <int> ) . window ( <int> ) ; final List < Integer > list = new ArrayList < Integer > ( ) ; @SuppressWarnings ( <str> ) final Observer < Integer > o = mock ( Observer . class ) ; source . subscribe ( new Subscriber < Observable < Integer > > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onNext ( Observable < Integer > t ) { t . subscribe ( new Observer < Integer > ( ) { @Override public void onNext ( Integer t ) { list . add ( t ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ) ; } @Override public void onError ( Throwable e ) { o . onError ( e ) ; } @Override public void onCompleted ( ) { o . onCompleted ( ) ; } } ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> ) , list ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , times ( <int> ) ) . onCompleted ( ) ; } public static Observable < Integer > hotStream ( ) { return Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( Subscriber < ? super Integer > s ) { while ( ! s . isUnsubscribed ( ) ) { for ( int i = <int> ; i < Math . random ( ) * <int> ; i + + ) { s . onNext ( i ) ; } try { Thread . sleep ( ( long ) ( Math . random ( ) * <int> ) ) ; } catch ( Exception e ) { } } System . out . println ( <str> ) ; } } ) . subscribeOn ( Schedulers . newThread ( ) ) ; } @Test public void testTakeFlatMapCompletes ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; final int indicator = <int> ; hotStream ( ) . window ( <int> ) . take ( <int> ) . flatMap ( new Func1 < Observable < Integer > , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Observable < Integer > w ) { return w . startWith ( indicator ) ; } } ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertCompleted ( ) ; Assert . assertFalse ( ts . getOnNextEvents ( ) . isEmpty ( ) ) ; } @Test @SuppressWarnings ( <str> ) public void testBackpressureOuterInexact ( ) { TestSubscriber < List < Integer > > ts = new TestSubscriber < List < Integer > > ( <int> ) ; Observable . range ( <int> , <int> ) . window ( <int> , <int> ) . map ( new Func1 < Observable < Integer > , Observable < List < Integer > > > ( ) { @Override public Observable < List < Integer > > call ( Observable < Integer > t ) { return t . toList ( ) ; } } ) . concatMap ( UtilityFunctions . < Observable < List < Integer > > > identity ( ) ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotCompleted ( ) ; ts . requestMore ( <int> ) ; ts . assertValues ( Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> , <int> ) ) ; ts . assertNoErrors ( ) ; ts . assertNotCompleted ( ) ; ts . requestMore ( <int> ) ; System . out . println ( ts . getOnNextEvents ( ) ) ; ts . assertValues ( Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> ) ) ; ts . assertNoErrors ( ) ; ts . assertCompleted ( ) ; } } 
