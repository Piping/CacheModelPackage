package org . elasticsearch . client . transport ; import org . elasticsearch . action . admin . cluster . state . ClusterStateRequest ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . support . PlainListenableActionFuture ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ClusterScope ( scope = Scope . TEST , numClientNodes = <int> ) @TestLogging ( <str> ) public class TransportClientRetryIT extends ESIntegTestCase { public void testRetry ( ) throws IOException , ExecutionException , InterruptedException { Iterable < TransportService > instances = internalCluster ( ) . getInstances ( TransportService . class ) ; TransportAddress [ ] addresses = new TransportAddress [ internalCluster ( ) . size ( ) ] ; int i = <int> ; for ( TransportService instance : instances ) { addresses [ i + + ] = instance . boundAddress ( ) . publishAddress ( ) ; } Settings . Builder builder = settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , internalCluster ( ) . getNodeMode ( ) ) . put ( ClusterName . SETTING , internalCluster ( ) . getClusterName ( ) ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . put ( <str> , createTempDir ( ) ) ; try ( TransportClient transportClient = TransportClient . builder ( ) . settings ( builder . build ( ) ) . build ( ) ) { transportClient . addTransportAddresses ( addresses ) ; assertThat ( transportClient . connectedNodes ( ) . size ( ) , equalTo ( internalCluster ( ) . size ( ) ) ) ; int size = cluster ( ) . size ( ) ; for ( int j = <int> ; j < size ; j + + ) { internalCluster ( ) . stopRandomNode ( input - > true ) ; ClusterStateRequest clusterStateRequest = Requests . clusterStateRequest ( ) . local ( true ) ; ClusterState clusterState ; if ( randomBoolean ( ) ) { clusterState = transportClient . admin ( ) . cluster ( ) . state ( clusterStateRequest ) . get ( ) . getState ( ) ; } else { PlainListenableActionFuture < ClusterStateResponse > future = new PlainListenableActionFuture < > ( transportClient . threadPool ( ) ) ; transportClient . admin ( ) . cluster ( ) . state ( clusterStateRequest , future ) ; clusterState = future . get ( ) . getState ( ) ; } assertThat ( clusterState . nodes ( ) . size ( ) , greaterThanOrEqualTo ( size - j ) ) ; assertThat ( transportClient . connectedNodes ( ) . size ( ) , greaterThanOrEqualTo ( size - j ) ) ; } } } } 
