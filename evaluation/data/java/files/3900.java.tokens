package org . nd4j . linalg . fft ; import org . junit . Ignore ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . impl . transforms . VectorFFT ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; @Ignore public class FFTTests extends BaseNd4jTest { public FFTTests ( String name ) { super ( name ) ; } public FFTTests ( Nd4jBackend backend ) { super ( backend ) ; } public FFTTests ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public FFTTests ( ) { } @Test public void testVectorFftOnes ( ) { INDArray arr = Nd4j . ones ( <int> ) ; VectorFFT fft = new VectorFFT ( arr ) ; fft . exec ( ) ; INDArray assertion = Nd4j . create ( <int> ) ; assertion . putScalar ( <int> , <int> ) ; assertEquals ( getFailureMessage ( ) , assertion , fft . z ( ) ) ; } @Test public void testColumnVector ( ) { Nd4j . EPS_THRESHOLD = <int> e - <int> ; Nd4j . MAX_ELEMENTS_PER_SLICE = Integer . MAX_VALUE ; Nd4j . MAX_SLICES_TO_PRINT = Integer . MAX_VALUE ; IComplexNDArray complexLinSpace = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; IComplexNDArray n = ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( new VectorFFT ( complexLinSpace , <int> ) ) ; IComplexNDArray assertion = Nd4j . createComplex ( new double [ ] { <int> . , <int> . , - <int> . , <float> , - <int> . , <int> , - <int> . , <float> , - <int> . , <int> . , - <int> . , - <float> , - <int> . , - <int> . , - <int> . , - <float> } , new int [ ] { <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , n , assertion ) ; } @Test public void testWithOffset ( ) { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray swapped = n . swapAxes ( n . shape ( ) . length - <int> , <int> ) ; INDArray firstSlice = swapped . slice ( <int> ) . slice ( <int> ) ; IComplexNDArray test = Nd4j . createComplex ( firstSlice ) ; IComplexNDArray testNoOffset = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , Nd4j . getExecutioner ( ) . execAndReturn ( new VectorFFT ( testNoOffset , <int> ) ) , Nd4j . getExecutioner ( ) . execAndReturn ( new VectorFFT ( test , <int> ) ) ) ; } @Test public void testSimple ( ) { Nd4j . EPS_THRESHOLD = <int> e - <int> ; IComplexNDArray arr = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } ) ; IComplexNDArray arr2 = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } ) ; IComplexNDArray assertion = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } ) ; IComplexNDArray assertion2 = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( - <int> , <float> E - <int> ) } ) ; assertEquals ( getFailureMessage ( ) , assertion , Nd4j . getFFt ( ) . fft ( arr ) ) ; assertEquals ( getFailureMessage ( ) , assertion2 , Nd4j . getFFt ( ) . fft ( arr2 ) ) ; } @Test public void testMultiDimFFT ( ) { Nd4j . EPS_THRESHOLD = <int> e - <int> ; INDArray a = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray fftedAnswer = Nd4j . createComplex ( <int> , <int> , <int> ) ; IComplexNDArray matrix1 = Nd4j . createComplex ( new IComplexNumber [ ] [ ] { { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( - <int> , <int> ) } , { Nd4j . createComplexNumber ( - <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } } ) ; IComplexNDArray matrix2 = Nd4j . createComplex ( new IComplexNumber [ ] [ ] { { Nd4j . createComplexNumber ( - <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } , { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } } ) ; fftedAnswer . putSlice ( <int> , matrix1 ) ; fftedAnswer . putSlice ( <int> , matrix2 ) ; IComplexNDArray ffted = FFT . fftn ( a ) ; assertEquals ( getFailureMessage ( ) , fftedAnswer , ffted ) ; Nd4j . EPS_THRESHOLD = <int> e - <int> ; } @Test public void testOnes ( ) { Nd4j . EPS_THRESHOLD = <int> e - <int> ; IComplexNDArray ones = Nd4j . complexOnes ( <int> , <int> ) ; IComplexNDArray ffted = FFT . fftn ( ones ) ; IComplexNDArray zeros = Nd4j . createComplex ( <int> , <int> ) ; zeros . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( getFailureMessage ( ) , zeros , ffted ) ; } @Test public void testConv4d ( ) { IComplexNDArray test = Nd4j . complexOnes ( new int [ ] { <int> , <int> , <int> , <int> } ) ; Nd4j . getFFt ( ) . fftn ( test ) ; } @Test public void testRawfft ( ) { Nd4j . EPS_THRESHOLD = <int> e - <int> ; IComplexNDArray test = Nd4j . complexOnes ( <int> , <int> ) ; IComplexNDArray result = Nd4j . getFFt ( ) . rawfft ( test , <int> , <int> ) ; IComplexNDArray assertion = Nd4j . createComplex ( <int> , <int> ) ; for ( int i = <int> ; i < assertion . rows ( ) ; i + + ) assertion . slice ( i ) . putScalar ( <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; for ( int i = <int> ; i < result . slices ( ) ; i + + ) { IComplexNDArray assertionSlice = assertion . slice ( i ) ; IComplexNDArray resultSlice = result . slice ( i ) ; assertEquals ( getFailureMessage ( ) + <str> + i , assertionSlice , resultSlice ) ; } } @Override public char ordering ( ) { return <str> ; } }