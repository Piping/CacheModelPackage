package org . elasticsearch . indices . cache . query . terms ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . hamcrest . Matchers . containsString ; public class TermsLookupTests extends ESTestCase { public void testTermsLookup ( ) { String index = randomAsciiOfLengthBetween ( <int> , <int> ) ; String type = randomAsciiOfLengthBetween ( <int> , <int> ) ; String id = randomAsciiOfLengthBetween ( <int> , <int> ) ; String path = randomAsciiOfLengthBetween ( <int> , <int> ) ; String routing = randomAsciiOfLengthBetween ( <int> , <int> ) ; TermsLookup termsLookup = new TermsLookup ( index , type , id , path ) ; termsLookup . routing ( routing ) ; assertEquals ( index , termsLookup . index ( ) ) ; assertEquals ( type , termsLookup . type ( ) ) ; assertEquals ( id , termsLookup . id ( ) ) ; assertEquals ( path , termsLookup . path ( ) ) ; assertEquals ( routing , termsLookup . routing ( ) ) ; } public void testIllegalArguments ( ) { String type = randomAsciiOfLength ( <int> ) ; String id = randomAsciiOfLength ( <int> ) ; String path = randomAsciiOfLength ( <int> ) ; switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : type = null ; break ; case <int> : id = null ; break ; case <int> : path = null ; break ; } try { new TermsLookup ( null , type , id , path ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testSerialization ( ) throws IOException { TermsLookup termsLookup = randomTermsLookup ( ) ; try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { termsLookup . writeTo ( output ) ; try ( StreamInput in = StreamInput . wrap ( output . bytes ( ) ) ) { TermsLookup deserializedLookup = TermsLookup . readTermsLookupFrom ( in ) ; assertEquals ( deserializedLookup , termsLookup ) ; assertEquals ( deserializedLookup . hashCode ( ) , termsLookup . hashCode ( ) ) ; assertNotSame ( deserializedLookup , termsLookup ) ; } } } public static TermsLookup randomTermsLookup ( ) { return new TermsLookup ( randomBoolean ( ) ? randomAsciiOfLength ( <int> ) : null , randomAsciiOfLength ( <int> ) , randomAsciiOfLength ( <int> ) , randomAsciiOfLength ( <int> ) . replace ( <str> , <str> ) ) . routing ( randomBoolean ( ) ? randomAsciiOfLength ( <int> ) : null ) ; } } 
