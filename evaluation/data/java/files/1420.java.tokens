package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . collect . Maps . immutableEntry ; import static com . google . common . collect . Sets . newHashSet ; import static com . google . common . collect . testing . Helpers . nefariousMapEntry ; import static com . google . common . collect . testing . IteratorFeature . MODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . base . Predicates ; import com . google . common . base . Supplier ; import com . google . common . collect . Maps . EntryTransformer ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . collect . testing . google . UnmodifiableCollectionTests ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Queue ; import java . util . RandomAccess ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; import java . util . TreeSet ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class MultimapsTest extends TestCase { private static final Comparator < Integer > INT_COMPARATOR = Ordering . < Integer > natural ( ) . reverse ( ) . nullsFirst ( ) ; @SuppressWarnings ( <str> ) public void testUnmodifiableListMultimapShortCircuit ( ) { ListMultimap < String , Integer > mod = ArrayListMultimap . create ( ) ; ListMultimap < String , Integer > unmod = Multimaps . unmodifiableListMultimap ( mod ) ; assertNotSame ( mod , unmod ) ; assertSame ( unmod , Multimaps . unmodifiableListMultimap ( unmod ) ) ; ImmutableListMultimap < String , Integer > immutable = ImmutableListMultimap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( immutable , Multimaps . unmodifiableListMultimap ( immutable ) ) ; assertSame ( immutable , Multimaps . unmodifiableListMultimap ( ( ListMultimap < String , Integer > ) immutable ) ) ; } @SuppressWarnings ( <str> ) public void testUnmodifiableSetMultimapShortCircuit ( ) { SetMultimap < String , Integer > mod = HashMultimap . create ( ) ; SetMultimap < String , Integer > unmod = Multimaps . unmodifiableSetMultimap ( mod ) ; assertNotSame ( mod , unmod ) ; assertSame ( unmod , Multimaps . unmodifiableSetMultimap ( unmod ) ) ; ImmutableSetMultimap < String , Integer > immutable = ImmutableSetMultimap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( immutable , Multimaps . unmodifiableSetMultimap ( immutable ) ) ; assertSame ( immutable , Multimaps . unmodifiableSetMultimap ( ( SetMultimap < String , Integer > ) immutable ) ) ; } @SuppressWarnings ( <str> ) public void testUnmodifiableMultimapShortCircuit ( ) { Multimap < String , Integer > mod = HashMultimap . create ( ) ; Multimap < String , Integer > unmod = Multimaps . unmodifiableMultimap ( mod ) ; assertNotSame ( mod , unmod ) ; assertSame ( unmod , Multimaps . unmodifiableMultimap ( unmod ) ) ; ImmutableMultimap < String , Integer > immutable = ImmutableMultimap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( immutable , Multimaps . unmodifiableMultimap ( immutable ) ) ; assertSame ( immutable , Multimaps . unmodifiableMultimap ( ( Multimap < String , Integer > ) immutable ) ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableArrayListMultimap ( ) { checkUnmodifiableMultimap ( ArrayListMultimap . < String , Integer > create ( ) , true ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableArrayListMultimap ( ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( ArrayListMultimap . < String , Integer > create ( ) , true , null , null ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; } public void testUnmodifiableArrayListMultimapRandomAccess ( ) { ListMultimap < String , Integer > delegate = ArrayListMultimap . create ( ) ; delegate . put ( <str> , <int> ) ; delegate . put ( <str> , <int> ) ; ListMultimap < String , Integer > multimap = Multimaps . unmodifiableListMultimap ( delegate ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; } public void testUnmodifiableLinkedListMultimapRandomAccess ( ) { ListMultimap < String , Integer > delegate = LinkedListMultimap . create ( ) ; delegate . put ( <str> , <int> ) ; delegate . put ( <str> , <int> ) ; ListMultimap < String , Integer > multimap = Multimaps . unmodifiableListMultimap ( delegate ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableHashMultimap ( ) { checkUnmodifiableMultimap ( HashMultimap . < String , Integer > create ( ) , false ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableHashMultimap ( ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( HashMultimap . < String , Integer > create ( ) , false , null , null ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableTreeMultimap ( ) { checkUnmodifiableMultimap ( TreeMultimap . < String , Integer > create ( ) , false , <str> , <int> ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableTreeMultimap ( ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( TreeMultimap . < String , Integer > create ( ) , false , <str> , <int> ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableSynchronizedArrayListMultimap ( ) { checkUnmodifiableMultimap ( Multimaps . synchronizedListMultimap ( ArrayListMultimap . < String , Integer > create ( ) ) , true ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableSynchronizedArrayListMultimap ( ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( Multimaps . synchronizedListMultimap ( ArrayListMultimap . < String , Integer > create ( ) ) , true , null , null ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableSynchronizedHashMultimap ( ) { checkUnmodifiableMultimap ( Multimaps . synchronizedSetMultimap ( HashMultimap . < String , Integer > create ( ) ) , false ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableSynchronizedHashMultimap ( ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( Multimaps . synchronizedSetMultimap ( HashMultimap . < String , Integer > create ( ) ) , false , null , null ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; } @GwtIncompatible ( <str> ) public void testUnmodifiableSynchronizedTreeMultimap ( ) { TreeMultimap < String , Integer > delegate = TreeMultimap . create ( Ordering . < String > natural ( ) , INT_COMPARATOR ) ; SortedSetMultimap < String , Integer > multimap = Multimaps . synchronizedSortedSetMultimap ( delegate ) ; checkUnmodifiableMultimap ( multimap , false , <str> , <int> ) ; assertSame ( INT_COMPARATOR , multimap . valueComparator ( ) ) ; } @GwtIncompatible ( <str> ) public void testSerializingUnmodifiableSynchronizedTreeMultimap ( ) { TreeMultimap < String , Integer > delegate = TreeMultimap . create ( Ordering . < String > natural ( ) , INT_COMPARATOR ) ; SortedSetMultimap < String , Integer > multimap = Multimaps . synchronizedSortedSetMultimap ( delegate ) ; Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( multimap , false , <str> , <int> ) ; SerializableTester . reserializeAndAssert ( unmodifiable ) ; assertSame ( INT_COMPARATOR , multimap . valueComparator ( ) ) ; } public void testUnmodifiableMultimapIsView ( ) { Multimap < String , Integer > mod = HashMultimap . create ( ) ; Multimap < String , Integer > unmod = Multimaps . unmodifiableMultimap ( mod ) ; assertEquals ( mod , unmod ) ; mod . put ( <str> , <int> ) ; assertTrue ( unmod . containsEntry ( <str> , <int> ) ) ; assertEquals ( mod , unmod ) ; } @SuppressWarnings ( <str> ) public void testUnmodifiableMultimapEntries ( ) { Multimap < String , Integer > mod = HashMultimap . create ( ) ; Multimap < String , Integer > unmod = Multimaps . unmodifiableMultimap ( mod ) ; mod . put ( <str> , <int> ) ; Entry < String , Integer > entry = unmod . entries ( ) . iterator ( ) . next ( ) ; try { entry . setValue ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } entry = ( Entry < String , Integer > ) unmod . entries ( ) . toArray ( ) [ <int> ] ; try { entry . setValue ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } Entry < String , Integer > [ ] array = ( Entry < String , Integer > [ ] ) new Entry < ? , ? > [ <int> ] ; assertSame ( array , unmod . entries ( ) . toArray ( array ) ) ; try { array [ <int> ] . setValue ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertFalse ( unmod . entries ( ) . contains ( nefariousMapEntry ( <str> , <int> ) ) ) ; assertFalse ( unmod . keys ( ) . contains ( <str> ) ) ; } private static void checkUnmodifiableMultimap ( Multimap < String , Integer > multimap , boolean permitsDuplicates ) { checkUnmodifiableMultimap ( multimap , permitsDuplicates , null , null ) ; } private static void checkUnmodifiableMultimap ( Multimap < String , Integer > multimap , boolean permitsDuplicates , @Nullable String nullKey , @Nullable Integer nullValue ) { Multimap < String , Integer > unmodifiable = prepareUnmodifiableTests ( multimap , permitsDuplicates , nullKey , nullValue ) ; UnmodifiableCollectionTests . assertMultimapIsUnmodifiable ( unmodifiable , <str> , <int> ) ; assertUnmodifiableIterableInTandem ( unmodifiable . keys ( ) , multimap . keys ( ) ) ; assertUnmodifiableIterableInTandem ( unmodifiable . keySet ( ) , multimap . keySet ( ) ) ; assertUnmodifiableIterableInTandem ( unmodifiable . entries ( ) , multimap . entries ( ) ) ; assertUnmodifiableIterableInTandem ( unmodifiable . asMap ( ) . entrySet ( ) , multimap . asMap ( ) . entrySet ( ) ) ; assertEquals ( multimap . toString ( ) , unmodifiable . toString ( ) ) ; assertEquals ( multimap . hashCode ( ) , unmodifiable . hashCode ( ) ) ; assertEquals ( multimap , unmodifiable ) ; assertThat ( unmodifiable . asMap ( ) . get ( <str> ) ) . containsExactly ( <int> , - <int> ) ; assertNull ( unmodifiable . asMap ( ) . get ( <str> ) ) ; assertThat ( unmodifiable . entries ( ) ) . isNotInstanceOf ( Serializable . class ) ; } private static Multimap < String , Integer > prepareUnmodifiableTests ( Multimap < String , Integer > multimap , boolean permitsDuplicates , @Nullable String nullKey , @Nullable Integer nullValue ) { multimap . clear ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , - <int> ) ; multimap . put ( nullKey , nullValue ) ; multimap . put ( <str> , nullValue ) ; multimap . put ( nullKey , <int> ) ; multimap . put ( <str> , <int> ) ; if ( permitsDuplicates ) { assertEquals ( <int> , multimap . size ( ) ) ; } else { assertEquals ( <int> , multimap . size ( ) ) ; } Multimap < String , Integer > unmodifiable ; if ( multimap instanceof SortedSetMultimap ) { unmodifiable = Multimaps . unmodifiableSortedSetMultimap ( ( SortedSetMultimap < String , Integer > ) multimap ) ; } else if ( multimap instanceof SetMultimap ) { unmodifiable = Multimaps . unmodifiableSetMultimap ( ( SetMultimap < String , Integer > ) multimap ) ; } else if ( multimap instanceof ListMultimap ) { unmodifiable = Multimaps . unmodifiableListMultimap ( ( ListMultimap < String , Integer > ) multimap ) ; } else { unmodifiable = Multimaps . unmodifiableMultimap ( multimap ) ; } return unmodifiable ; } private static < T > void assertUnmodifiableIterableInTandem ( Iterable < T > unmodifiable , Iterable < T > modifiable ) { UnmodifiableCollectionTests . assertIteratorIsUnmodifiable ( unmodifiable . iterator ( ) ) ; UnmodifiableCollectionTests . assertIteratorsInOrder ( unmodifiable . iterator ( ) , modifiable . iterator ( ) ) ; } public void testInvertFrom ( ) { ImmutableMultimap < Integer , String > empty = ImmutableMultimap . of ( ) ; Multimap < String , Integer > multimap = Multimaps . invertFrom ( empty , ArrayListMultimap . < String , Integer > create ( ) ) ; assertTrue ( multimap . isEmpty ( ) ) ; ImmutableMultimap < Integer , String > single = new ImmutableMultimap . Builder < Integer , String > ( ) . put ( <int> , <str> ) . put ( <int> , <str> ) . build ( ) ; assertSame ( multimap , Multimaps . invertFrom ( single , multimap ) ) ; ImmutableMultimap < String , Integer > expected = new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertEquals ( expected , multimap ) ; } public void testAsMap_multimap ( ) { Multimap < String , Integer > multimap = Multimaps . newMultimap ( new HashMap < String , Collection < Integer > > ( ) , new QueueSupplier ( ) ) ; Map < String , Collection < Integer > > map = Multimaps . asMap ( multimap ) ; assertSame ( multimap . asMap ( ) , map ) ; } public void testAsMap_listMultimap ( ) { ListMultimap < String , Integer > listMultimap = ArrayListMultimap . create ( ) ; Map < String , List < Integer > > map = Multimaps . asMap ( listMultimap ) ; assertSame ( listMultimap . asMap ( ) , map ) ; } public void testAsMap_setMultimap ( ) { SetMultimap < String , Integer > setMultimap = LinkedHashMultimap . create ( ) ; Map < String , Set < Integer > > map = Multimaps . asMap ( setMultimap ) ; assertSame ( setMultimap . asMap ( ) , map ) ; } public void testAsMap_sortedSetMultimap ( ) { SortedSetMultimap < String , Integer > sortedSetMultimap = TreeMultimap . create ( ) ; Map < String , SortedSet < Integer > > map = Multimaps . asMap ( sortedSetMultimap ) ; assertSame ( sortedSetMultimap . asMap ( ) , map ) ; } public void testForMap ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Multimap < String , Integer > multimap = HashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; Multimap < String , Integer > multimapView = Multimaps . forMap ( map ) ; assertTrue ( multimap . equals ( multimapView ) ) ; assertTrue ( multimapView . equals ( multimap ) ) ; assertTrue ( multimapView . equals ( multimapView ) ) ; assertFalse ( multimapView . equals ( map ) ) ; Multimap < String , Integer > multimap2 = HashMultimap . create ( ) ; multimap2 . put ( <str> , <int> ) ; assertFalse ( multimapView . equals ( multimap2 ) ) ; multimap2 . put ( <str> , <int> ) ; assertFalse ( multimapView . equals ( multimap2 ) ) ; ListMultimap < String , Integer > listMultimap = new ImmutableListMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertFalse ( <str> , multimapView . equals ( listMultimap ) ) ; assertEquals ( multimap . toString ( ) , multimapView . toString ( ) ) ; assertEquals ( multimap . hashCode ( ) , multimapView . hashCode ( ) ) ; assertEquals ( multimap . size ( ) , multimapView . size ( ) ) ; assertTrue ( multimapView . containsKey ( <str> ) ) ; assertTrue ( multimapView . containsValue ( <int> ) ) ; assertTrue ( multimapView . containsEntry ( <str> , <int> ) ) ; assertEquals ( Collections . singleton ( <int> ) , multimapView . get ( <str> ) ) ; assertEquals ( Collections . singleton ( <int> ) , multimapView . get ( <str> ) ) ; try { multimapView . put ( <str> , <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { multimapView . putAll ( <str> , Collections . singleton ( <int> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { multimapView . putAll ( multimap ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { multimapView . replaceValues ( <str> , Collections . < Integer > emptySet ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } multimapView . remove ( <str> , <int> ) ; assertFalse ( multimapView . containsKey ( <str> ) ) ; assertFalse ( map . containsKey ( <str> ) ) ; assertEquals ( map . keySet ( ) , multimapView . keySet ( ) ) ; assertEquals ( map . keySet ( ) , multimapView . keys ( ) . elementSet ( ) ) ; assertThat ( multimapView . keys ( ) ) . contains ( <str> ) ; assertThat ( multimapView . values ( ) ) . contains ( <int> ) ; assertThat ( multimapView . entries ( ) ) . contains ( Maps . immutableEntry ( <str> , <int> ) ) ; assertThat ( multimapView . asMap ( ) . entrySet ( ) ) . contains ( Maps . immutableEntry ( <str> , ( Collection < Integer > ) Collections . singleton ( <int> ) ) ) ; multimapView . clear ( ) ; assertFalse ( multimapView . containsKey ( <str> ) ) ; assertFalse ( map . containsKey ( <str> ) ) ; assertTrue ( map . isEmpty ( ) ) ; assertTrue ( multimapView . isEmpty ( ) ) ; multimap . clear ( ) ; assertEquals ( multimap . toString ( ) , multimapView . toString ( ) ) ; assertEquals ( multimap . hashCode ( ) , multimapView . hashCode ( ) ) ; assertEquals ( multimap . size ( ) , multimapView . size ( ) ) ; assertEquals ( multimapView , ArrayListMultimap . create ( ) ) ; } @GwtIncompatible ( <str> ) public void testForMapSerialization ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Multimap < String , Integer > multimapView = Multimaps . forMap ( map ) ; SerializableTester . reserializeAndAssert ( multimapView ) ; } public void testForMapRemoveAll ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Multimap < String , Integer > multimap = Multimaps . forMap ( map ) ; assertEquals ( <int> , multimap . size ( ) ) ; assertEquals ( Collections . emptySet ( ) , multimap . removeAll ( <str> ) ) ; assertEquals ( <int> , multimap . size ( ) ) ; assertTrue ( multimap . containsKey ( <str> ) ) ; assertEquals ( Collections . singleton ( <int> ) , multimap . removeAll ( <str> ) ) ; assertEquals ( <int> , multimap . size ( ) ) ; assertFalse ( multimap . containsKey ( <str> ) ) ; } public void testForMapAsMap ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Map < String , Collection < Integer > > asMap = Multimaps . forMap ( map ) . asMap ( ) ; assertEquals ( Collections . singleton ( <int> ) , asMap . get ( <str> ) ) ; assertNull ( asMap . get ( <str> ) ) ; assertTrue ( asMap . containsKey ( <str> ) ) ; assertFalse ( asMap . containsKey ( <str> ) ) ; Set < Entry < String , Collection < Integer > > > entries = asMap . entrySet ( ) ; assertFalse ( entries . contains ( ( Object ) <float> ) ) ; assertFalse ( entries . remove ( ( Object ) <float> ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( <str> , Collections . singletonList ( <int> ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( <str> , Collections . singletonList ( <int> ) ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( <str> , Sets . newLinkedHashSet ( asList ( <int> , <int> ) ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( <str> , Sets . newLinkedHashSet ( asList ( <int> , <int> ) ) ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( <str> , Collections . singleton ( <int> ) ) ) ) ; assertFalse ( entries . remove ( Maps . immutableEntry ( <str> , Collections . singleton ( <int> ) ) ) ) ; assertTrue ( map . containsKey ( <str> ) ) ; assertTrue ( entries . contains ( Maps . immutableEntry ( <str> , Collections . singleton ( <int> ) ) ) ) ; assertTrue ( entries . remove ( Maps . immutableEntry ( <str> , Collections . singleton ( <int> ) ) ) ) ; assertFalse ( map . containsKey ( <str> ) ) ; } public void testForMapGetIteration ( ) { IteratorTester < Integer > tester = new IteratorTester < Integer > ( <int> , MODIFIABLE , newHashSet ( <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { private Multimap < String , Integer > multimap ; @Override protected Iterator < Integer > newTargetIterator ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; multimap = Multimaps . forMap ( map ) ; return multimap . get ( <str> ) . iterator ( ) ; } @Override protected void verify ( List < Integer > elements ) { assertEquals ( newHashSet ( elements ) , multimap . get ( <str> ) ) ; } } ; tester . test ( ) ; } private enum Color { BLUE , RED , YELLOW , GREEN } private abstract static class CountingSupplier < E > implements Supplier < E > , Serializable { int count ; abstract E getImpl ( ) ; @Override public E get ( ) { count + + ; return getImpl ( ) ; } } private static class QueueSupplier extends CountingSupplier < Queue < Integer > > { @Override public Queue < Integer > getImpl ( ) { return new LinkedList < Integer > ( ) ; } private static final long serialVersionUID = <int> ; } public void testNewMultimapWithCollectionRejectingNegativeElements ( ) { CountingSupplier < Set < Integer > > factory = new SetSupplier ( ) { @Override public Set < Integer > getImpl ( ) { final Set < Integer > backing = super . getImpl ( ) ; return new ForwardingSet < Integer > ( ) { @Override protected Set < Integer > delegate ( ) { return backing ; } @Override public boolean add ( Integer element ) { checkArgument ( element > = <int> ) ; return super . add ( element ) ; } @Override public boolean addAll ( Collection < ? extends Integer > collection ) { return standardAddAll ( collection ) ; } } ; } } ; Map < Color , Collection < Integer > > map = Maps . newEnumMap ( Color . class ) ; Multimap < Color , Integer > multimap = Multimaps . newMultimap ( map , factory ) ; try { multimap . put ( Color . BLUE , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } multimap . put ( Color . RED , <int> ) ; multimap . put ( Color . BLUE , <int> ) ; try { multimap . put ( Color . GREEN , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertThat ( multimap . entries ( ) ) . containsExactly ( Maps . immutableEntry ( Color . RED , <int> ) , Maps . immutableEntry ( Color . BLUE , <int> ) ) ; } public void testNewMultimap ( ) { CountingSupplier < Queue < Integer > > factory = new QueueSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newEnumMap ( Color . class ) ; Multimap < Color , Integer > multimap = Multimaps . newMultimap ( map , factory ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; assertEquals ( <str> , multimap . get ( Color . BLUE ) . toString ( ) ) ; Multimap < Color , Integer > ummodifiable = Multimaps . unmodifiableMultimap ( multimap ) ; assertEquals ( <str> , ummodifiable . get ( Color . BLUE ) . toString ( ) ) ; Collection < Integer > collection = multimap . get ( Color . BLUE ) ; assertEquals ( collection , collection ) ; assertThat ( multimap . keySet ( ) ) . isNotInstanceOf ( SortedSet . class ) ; assertThat ( multimap . asMap ( ) ) . isNotInstanceOf ( SortedMap . class ) ; } @GwtIncompatible ( <str> ) public void testNewMultimapSerialization ( ) { CountingSupplier < Queue < Integer > > factory = new QueueSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newEnumMap ( Color . class ) ; Multimap < Color , Integer > multimap = Multimaps . newMultimap ( map , factory ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; } private static class ListSupplier extends CountingSupplier < LinkedList < Integer > > { @Override public LinkedList < Integer > getImpl ( ) { return new LinkedList < Integer > ( ) ; } private static final long serialVersionUID = <int> ; } public void testNewListMultimap ( ) { CountingSupplier < LinkedList < Integer > > factory = new ListSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newTreeMap ( ) ; ListMultimap < Color , Integer > multimap = Multimaps . newListMultimap ( map , factory ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; assertEquals ( <str> , multimap . toString ( ) ) ; assertThat ( multimap . get ( Color . BLUE ) ) . isNotInstanceOf ( RandomAccess . class ) ; assertTrue ( multimap . keySet ( ) instanceof SortedSet ) ; assertTrue ( multimap . asMap ( ) instanceof SortedMap ) ; } @GwtIncompatible ( <str> ) public void testNewListMultimapSerialization ( ) { CountingSupplier < LinkedList < Integer > > factory = new ListSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newTreeMap ( ) ; ListMultimap < Color , Integer > multimap = Multimaps . newListMultimap ( map , factory ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> , <int> ) ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; } private static class SetSupplier extends CountingSupplier < Set < Integer > > { @Override public Set < Integer > getImpl ( ) { return new HashSet < Integer > ( <int> ) ; } private static final long serialVersionUID = <int> ; } public void testNewSetMultimap ( ) { CountingSupplier < Set < Integer > > factory = new SetSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newHashMap ( ) ; SetMultimap < Color , Integer > multimap = Multimaps . newSetMultimap ( map , factory ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; assertEquals ( Sets . newHashSet ( <int> , <int> , <int> ) , multimap . get ( Color . BLUE ) ) ; } @GwtIncompatible ( <str> ) public void testNewSetMultimapSerialization ( ) { CountingSupplier < Set < Integer > > factory = new SetSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newHashMap ( ) ; SetMultimap < Color , Integer > multimap = Multimaps . newSetMultimap ( map , factory ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; } private static class SortedSetSupplier extends CountingSupplier < TreeSet < Integer > > { @Override public TreeSet < Integer > getImpl ( ) { return Sets . newTreeSet ( INT_COMPARATOR ) ; } private static final long serialVersionUID = <int> ; } public void testNewSortedSetMultimap ( ) { CountingSupplier < TreeSet < Integer > > factory = new SortedSetSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newEnumMap ( Color . class ) ; SortedSetMultimap < Color , Integer > multimap = Multimaps . newSortedSetMultimap ( map , factory ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , factory . count ) ; assertEquals ( <str> , multimap . get ( Color . BLUE ) . toString ( ) ) ; assertEquals ( INT_COMPARATOR , multimap . valueComparator ( ) ) ; } @GwtIncompatible ( <str> ) public void testNewSortedSetMultimapSerialization ( ) { CountingSupplier < TreeSet < Integer > > factory = new SortedSetSupplier ( ) ; Map < Color , Collection < Integer > > map = Maps . newEnumMap ( Color . class ) ; SortedSetMultimap < Color , Integer > multimap = Multimaps . newSortedSetMultimap ( map , factory ) ; multimap . putAll ( Color . BLUE , asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( Color . RED , asList ( <int> , <int> , <int> , <int> ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; assertEquals ( INT_COMPARATOR , multimap . valueComparator ( ) ) ; } public void testIndex ( ) { final Multimap < String , Object > stringToObject = new ImmutableMultimap . Builder < String , Object > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; ImmutableMultimap < String , Object > outputMap = Multimaps . index ( stringToObject . values ( ) , Functions . toStringFunction ( ) ) ; assertEquals ( stringToObject , outputMap ) ; } public void testIndexIterator ( ) { final Multimap < String , Object > stringToObject = new ImmutableMultimap . Builder < String , Object > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; ImmutableMultimap < String , Object > outputMap = Multimaps . index ( stringToObject . values ( ) . iterator ( ) , Functions . toStringFunction ( ) ) ; assertEquals ( stringToObject , outputMap ) ; } public void testIndex_ordering ( ) { final Multimap < Integer , String > expectedIndex = new ImmutableListMultimap . Builder < Integer , String > ( ) . put ( <int> , <str> ) . put ( <int> , <str> ) . put ( <int> , <str> ) . put ( <int> , <str> ) . put ( <int> , <str> ) . build ( ) ; final List < String > badGuys = Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ; final Function < String , Integer > stringLengthFunction = new Function < String , Integer > ( ) { @Override public Integer apply ( String input ) { return input . length ( ) ; } } ; Multimap < Integer , String > index = Multimaps . index ( badGuys , stringLengthFunction ) ; assertEquals ( expectedIndex , index ) ; } public void testIndex_nullValue ( ) { List < Integer > values = Arrays . asList ( <int> , null ) ; try { Multimaps . index ( values , Functions . identity ( ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } } public void testIndex_nullKey ( ) { List < Integer > values = Arrays . asList ( <int> , <int> ) ; try { Multimaps . index ( values , Functions . constant ( null ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @GwtIncompatible ( value = <str> ) public void testTransformValues ( ) { SetMultimap < String , Integer > multimap = ImmutableSetMultimap . of ( <str> , <int> , <str> , - <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; Function < Integer , Integer > square = new Function < Integer , Integer > ( ) { @Override public Integer apply ( Integer in ) { return in * in ; } } ; Multimap < String , Integer > transformed = Multimaps . transformValues ( multimap , square ) ; assertThat ( transformed . entries ( ) ) . containsExactly ( immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @GwtIncompatible ( value = <str> ) public void testTransformValuesIsView ( ) { Multimap < String , String > multimap = LinkedListMultimap . create ( ) ; multimap . put ( <str> , <str> ) ; Multimap < String , Integer > transformed = Multimaps . transformValues ( multimap , new Function < String , Integer > ( ) { @Override public Integer apply ( String str ) { return str . length ( ) ; } } ) ; Entry < String , String > entry = multimap . entries ( ) . iterator ( ) . next ( ) ; entry . setValue ( <str> ) ; assertThat ( transformed . entries ( ) ) . containsExactly ( immutableEntry ( <str> , <int> ) ) ; } @GwtIncompatible ( value = <str> ) public void testTransformListValues ( ) { ListMultimap < String , Integer > multimap = ImmutableListMultimap . of ( <str> , <int> , <str> , - <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; Function < Integer , Integer > square = new Function < Integer , Integer > ( ) { @Override public Integer apply ( Integer in ) { return in * in ; } } ; ListMultimap < String , Integer > transformed = Multimaps . transformValues ( multimap , square ) ; assertThat ( transformed . entries ( ) ) . containsExactly ( immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) , immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @GwtIncompatible ( value = <str> ) public void testTransformEntries ( ) { SetMultimap < String , Integer > multimap = ImmutableSetMultimap . of ( <str> , <int> , <str> , <int> , <str> , - <int> ) ; EntryTransformer < String , Integer , String > transformer = new EntryTransformer < String , Integer , String > ( ) { @Override public String transformEntry ( String key , Integer value ) { return ( value > = <int> ) ? key : <str> + key ; } } ; Multimap < String , String > transformed = Multimaps . transformEntries ( multimap , transformer ) ; assertThat ( transformed . entries ( ) ) . containsExactly ( immutableEntry ( <str> , <str> ) , immutableEntry ( <str> , <str> ) , immutableEntry ( <str> , <str> ) ) . inOrder ( ) ; } @GwtIncompatible ( value = <str> ) public void testTransformListEntries ( ) { ListMultimap < String , Integer > multimap = ImmutableListMultimap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; EntryTransformer < String , Integer , String > transformer = new EntryTransformer < String , Integer , String > ( ) { @Override public String transformEntry ( String key , Integer value ) { return key + value ; } } ; ListMultimap < String , String > transformed = Multimaps . transformEntries ( multimap , transformer ) ; assertEquals ( ImmutableListMultimap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , transformed ) ; assertEquals ( <str> , transformed . toString ( ) ) ; } public < K , V > void testSynchronizedMultimapSampleCodeCompilation ( ) { K key = null ; Multimap < K , V > multimap = Multimaps . synchronizedMultimap ( HashMultimap . < K , V > create ( ) ) ; Collection < V > values = multimap . get ( key ) ; synchronized ( multimap ) { Iterator < V > i = values . iterator ( ) ; while ( i . hasNext ( ) ) { foo ( i . next ( ) ) ; } } } private static void foo ( Object o ) { } public void testFilteredKeysSetMultimapReplaceValues ( ) { SetMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; SetMultimap < String , Integer > filtered = Multimaps . filterKeys ( multimap , Predicates . in ( ImmutableSet . of ( <str> , <str> ) ) ) ; assertEquals ( ImmutableSet . of ( ) , filtered . replaceValues ( <str> , ImmutableSet . < Integer > of ( ) ) ) ; try { filtered . replaceValues ( <str> , ImmutableSet . of ( <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testFilteredKeysSetMultimapGetBadValue ( ) { SetMultimap < String , Integer > multimap = LinkedHashMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; SetMultimap < String , Integer > filtered = Multimaps . filterKeys ( multimap , Predicates . in ( ImmutableSet . of ( <str> , <str> ) ) ) ; Set < Integer > bazSet = filtered . get ( <str> ) ; assertThat ( bazSet ) . isEmpty ( ) ; try { bazSet . add ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { bazSet . addAll ( ImmutableSet . of ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testFilteredKeysListMultimapGetBadValue ( ) { ListMultimap < String , Integer > multimap = ArrayListMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; ListMultimap < String , Integer > filtered = Multimaps . filterKeys ( multimap , Predicates . in ( ImmutableSet . of ( <str> , <str> ) ) ) ; List < Integer > bazList = filtered . get ( <str> ) ; assertThat ( bazList ) . isEmpty ( ) ; try { bazList . add ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { bazList . add ( <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { bazList . addAll ( ImmutableList . of ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { bazList . addAll ( <int> , ImmutableList . of ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Multimaps . class ) ; } } 
