package org . apache . cassandra . stress . operations . predefined ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import org . apache . cassandra . stress . Operation ; import org . apache . cassandra . stress . generate . * ; import org . apache . cassandra . stress . settings . Command ; import org . apache . cassandra . stress . settings . CqlVersion ; import org . apache . cassandra . stress . settings . StressSettings ; import org . apache . cassandra . stress . util . Timer ; import org . apache . cassandra . thrift . SlicePredicate ; import org . apache . cassandra . thrift . SliceRange ; public abstract class PredefinedOperation extends Operation { public final Command type ; private final Distribution columnCount ; private Object cqlCache ; public PredefinedOperation ( Command type , Timer timer , PartitionGenerator generator , SeedManager seedManager , StressSettings settings ) { super ( timer , settings , spec ( generator , seedManager , settings . insert . rowPopulationRatio . get ( ) ) ) ; this . type = type ; this . columnCount = settings . columns . countDistribution . get ( ) ; } private static DataSpec spec ( PartitionGenerator generator , SeedManager seedManager , RatioDistribution rowPopulationCount ) { return new DataSpec ( generator , seedManager , new DistributionFixed ( <int> ) , rowPopulationCount , <int> ) ; } public boolean isCql3 ( ) { return settings . mode . cqlVersion = = CqlVersion . CQL3 ; } public Object getCqlCache ( ) { return cqlCache ; } public void storeCqlCache ( Object val ) { cqlCache = val ; } protected ByteBuffer getKey ( ) { return ( ByteBuffer ) partitions . get ( <int> ) . getPartitionKey ( <int> ) ; } final class ColumnSelection { final int [ ] indices ; final int lb , ub ; private ColumnSelection ( int [ ] indices , int lb , int ub ) { this . indices = indices ; this . lb = lb ; this . ub = ub ; } public < V > List < V > select ( List < V > in ) { List < V > out = new ArrayList < > ( ) ; if ( indices ! = null ) { for ( int i : indices ) out . add ( in . get ( i ) ) ; } else { out . addAll ( in . subList ( lb , ub ) ) ; } return out ; } int count ( ) { return indices ! = null ? indices . length : ub - lb ; } SlicePredicate predicate ( ) { final SlicePredicate predicate = new SlicePredicate ( ) ; if ( indices = = null ) { predicate . setSlice_range ( new SliceRange ( ) . setStart ( settings . columns . names . get ( lb ) ) . setFinish ( new byte [ ] { } ) . setReversed ( false ) . setCount ( count ( ) ) ) ; } else predicate . setColumn_names ( select ( settings . columns . names ) ) ; return predicate ; } } public String toString ( ) { return type . toString ( ) ; } ColumnSelection select ( ) { if ( settings . columns . slice ) { int count = ( int ) columnCount . next ( ) ; int start ; if ( count = = settings . columns . maxColumnsPerKey ) start = <int> ; else start = <int> + ThreadLocalRandom . current ( ) . nextInt ( settings . columns . maxColumnsPerKey - count ) ; return new ColumnSelection ( null , start , start + count ) ; } int count = ( int ) columnCount . next ( ) ; int totalCount = settings . columns . names . size ( ) ; if ( count = = settings . columns . names . size ( ) ) return new ColumnSelection ( null , <int> , count ) ; ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; int [ ] indices = new int [ count ] ; int c = <int> , o = <int> ; while ( c < count & & count + o < totalCount ) { int leeway = totalCount - ( count + o ) ; int spreadover = count - c ; o + = Math . round ( rnd . nextDouble ( ) * ( leeway / ( double ) spreadover ) ) ; indices [ c ] = o + c ; c + + ; } while ( c < count ) { indices [ c ] = o + c ; c + + ; } return new ColumnSelection ( indices , <int> , <int> ) ; } protected List < ByteBuffer > getColumnValues ( ) { return getColumnValues ( new ColumnSelection ( null , <int> , settings . columns . names . size ( ) ) ) ; } protected List < ByteBuffer > getColumnValues ( ColumnSelection columns ) { Row row = partitions . get ( <int> ) . next ( ) ; ByteBuffer [ ] r = new ByteBuffer [ columns . count ( ) ] ; int c = <int> ; if ( columns . indices ! = null ) for ( int i : columns . indices ) r [ c + + ] = ( ByteBuffer ) row . get ( i ) ; else for ( int i = columns . lb ; i < columns . ub ; i + + ) r [ c + + ] = ( ByteBuffer ) row . get ( i ) ; return Arrays . asList ( r ) ; } public static Operation operation ( Command type , Timer timer , PartitionGenerator generator , SeedManager seedManager , StressSettings settings , DistributionFactory counteradd ) { switch ( type ) { case READ : switch ( settings . mode . style ) { case THRIFT : return new ThriftReader ( timer , generator , seedManager , settings ) ; case CQL : case CQL_PREPARED : return new CqlReader ( timer , generator , seedManager , settings ) ; default : throw new UnsupportedOperationException ( ) ; } case COUNTER_READ : switch ( settings . mode . style ) { case THRIFT : return new ThriftCounterGetter ( timer , generator , seedManager , settings ) ; case CQL : case CQL_PREPARED : return new CqlCounterGetter ( timer , generator , seedManager , settings ) ; default : throw new UnsupportedOperationException ( ) ; } case WRITE : switch ( settings . mode . style ) { case THRIFT : return new ThriftInserter ( timer , generator , seedManager , settings ) ; case CQL : case CQL_PREPARED : return new CqlInserter ( timer , generator , seedManager , settings ) ; default : throw new UnsupportedOperationException ( ) ; } case COUNTER_WRITE : switch ( settings . mode . style ) { case THRIFT : return new ThriftCounterAdder ( counteradd , timer , generator , seedManager , settings ) ; case CQL : case CQL_PREPARED : return new CqlCounterAdder ( counteradd , timer , generator , seedManager , settings ) ; default : throw new UnsupportedOperationException ( ) ; } } throw new UnsupportedOperationException ( ) ; } } 
