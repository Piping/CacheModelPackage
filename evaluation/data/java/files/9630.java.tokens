package com . badlogic . gdx . tests . bullet ; import java . nio . FloatBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . Ray ; import com . badlogic . gdx . physics . bullet . collision . btBvhTriangleMeshShape ; import com . badlogic . gdx . physics . bullet . collision . btTriangleIndexVertexArray ; import com . badlogic . gdx . physics . bullet . collision . btTriangleRaycastCallback ; import com . badlogic . gdx . physics . bullet . collision . btTriangleRaycastCallback . EFlags ; import com . badlogic . gdx . physics . bullet . linearmath . btVector3 ; public class TriangleRaycastTest extends BaseBulletTest { private class MyTriangleRaycastCallback extends btTriangleRaycastCallback { public Vector3 hitNormalLocal = new Vector3 ( ) ; public float hitFraction = <int> ; public int partId = - <int> ; public int triangleIndex = - <int> ; private btVector3 tmpSetFrom = new btVector3 ( ) ; private btVector3 tmpSetTo = new btVector3 ( ) ; public MyTriangleRaycastCallback ( Vector3 from , Vector3 to ) { super ( from , to ) ; } public void clearReport ( ) { hitNormalLocal . setZero ( ) ; hitFraction = <int> ; partId = - <int> ; triangleIndex = - <int> ; } @Override public void setHitFraction ( float hitFraction ) { super . setHitFraction ( hitFraction ) ; this . hitFraction = hitFraction ; } @Override public float reportHit ( Vector3 hitNormalLocal , float hitFraction , int partId , int triangleIndex ) { if ( hitFraction < this . hitFraction ) { this . hitNormalLocal . set ( hitNormalLocal ) ; this . hitFraction = hitFraction ; this . partId = partId ; this . triangleIndex = triangleIndex ; } return hitFraction ; } public void setFrom ( Vector3 value ) { tmpSetFrom . setValue ( value . x , value . y , value . z ) ; super . setFrom ( tmpSetFrom ) ; } public void setTo ( Vector3 value ) { tmpSetTo . setValue ( value . x , value . y , value . z ) ; super . setTo ( tmpSetTo ) ; } @Override public void dispose ( ) { tmpSetFrom . dispose ( ) ; tmpSetTo . dispose ( ) ; super . dispose ( ) ; } } private Model model ; private btBvhTriangleMeshShape triangleShape ; private MyTriangleRaycastCallback triangleRaycastCallback ; private Vector3 [ ] selectedTriangleVertices = { new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) } ; private ShapeRenderer shapeRenderer ; private Vector3 rayFrom = new Vector3 ( ) ; private Vector3 rayTo = new Vector3 ( ) ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; shapeRenderer = new ShapeRenderer ( ) ; model = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; model . materials . get ( <int> ) . clear ( ) ; model . materials . get ( <int> ) . set ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) ) ; btTriangleIndexVertexArray vertexArray = new btTriangleIndexVertexArray ( model . meshParts ) ; triangleShape = new btBvhTriangleMeshShape ( vertexArray , true ) ; triangleRaycastCallback = new MyTriangleRaycastCallback ( Vector3 . Zero , Vector3 . Zero ) ; triangleRaycastCallback . setFlags ( EFlags . kF_FilterBackfaces ) ; world . addConstructor ( <str> , new BulletConstructor ( model , <int> , triangleShape ) ) ; world . add ( <str> , <int> , <int> , <int> ) ; disposables . add ( model ) ; disposables . add ( triangleRaycastCallback ) ; disposables . add ( triangleShape ) ; disposables . add ( vertexArray ) ; disposables . add ( shapeRenderer ) ; } @Override public void render ( ) { super . render ( ) ; Gdx . gl . glLineWidth ( <int> ) ; shapeRenderer . setProjectionMatrix ( camera . combined ) ; shapeRenderer . begin ( ShapeRenderer . ShapeType . Line ) ; shapeRenderer . setColor ( <int> , <int> , <int> , <int> f ) ; shapeRenderer . line ( selectedTriangleVertices [ <int> ] , selectedTriangleVertices [ <int> ] ) ; shapeRenderer . line ( selectedTriangleVertices [ <int> ] , selectedTriangleVertices [ <int> ] ) ; shapeRenderer . line ( selectedTriangleVertices [ <int> ] , selectedTriangleVertices [ <int> ] ) ; shapeRenderer . end ( ) ; Gdx . gl . glLineWidth ( <int> ) ; } @Override public boolean tap ( float screenX , float screenY , int count , int button ) { Ray ray = camera . getPickRay ( screenX , screenY ) ; rayFrom . set ( ray . origin ) ; rayTo . set ( ray . direction ) . scl ( <int> ) . add ( rayFrom ) ; triangleRaycastCallback . setHitFraction ( <int> ) ; triangleRaycastCallback . clearReport ( ) ; triangleRaycastCallback . setFrom ( rayFrom ) ; triangleRaycastCallback . setTo ( rayTo ) ; triangleShape . performRaycast ( triangleRaycastCallback , rayFrom , rayTo ) ; int currentTriangleIndex = triangleRaycastCallback . triangleIndex ; int currentPartId = triangleRaycastCallback . partId ; if ( currentTriangleIndex = = - <int> | | currentPartId = = - <int> ) { return false ; } Mesh mesh = model . meshParts . get ( currentPartId ) . mesh ; FloatBuffer verticesBuffer = mesh . getVerticesBuffer ( ) ; ShortBuffer indicesBuffer = mesh . getIndicesBuffer ( ) ; int posOffset = mesh . getVertexAttributes ( ) . findByUsage ( VertexAttributes . Usage . Position ) . offset / <int> ; int vertexSize = mesh . getVertexSize ( ) / <int> ; int currentTriangleFirstVertexIndex = currentTriangleIndex * <int> ; for ( int i = <int> ; i < <int> ; i + + ) { int currentVertexIndex = indicesBuffer . get ( currentTriangleFirstVertexIndex + i ) ; int j = currentVertexIndex * vertexSize + posOffset ; float x = verticesBuffer . get ( j + + ) ; float y = verticesBuffer . get ( j + + ) ; float z = verticesBuffer . get ( j ) ; selectedTriangleVertices [ i ] . set ( x , y , z ) ; } return true ; } }