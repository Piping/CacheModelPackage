package io . netty . handler . codec . http2 ; import static io . netty . buffer . Unpooled . EMPTY_BUFFER ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_MAX_FRAME_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . SMALLEST_MAX_CONCURRENT_STREAMS ; import static io . netty . handler . codec . http2 . Http2Error . CANCEL ; import static io . netty . handler . codec . http2 . Http2Stream . State . HALF_CLOSED_LOCAL ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelPromise ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . ImmediateEventExecutor ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import org . mockito . verification . VerificationMode ; import java . util . ArrayList ; import java . util . List ; public class StreamBufferingEncoderTest { private StreamBufferingEncoder encoder ; private Http2Connection connection ; @Mock private Http2FrameWriter writer ; @Mock private ChannelHandlerContext ctx ; @Mock private Channel channel ; @Mock private ChannelConfig config ; @Mock private EventExecutor executor ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; Http2FrameWriter . Configuration configuration = mock ( Http2FrameWriter . Configuration . class ) ; Http2FrameSizePolicy frameSizePolicy = mock ( Http2FrameSizePolicy . class ) ; when ( writer . configuration ( ) ) . thenReturn ( configuration ) ; when ( configuration . frameSizePolicy ( ) ) . thenReturn ( frameSizePolicy ) ; when ( frameSizePolicy . maxFrameSize ( ) ) . thenReturn ( DEFAULT_MAX_FRAME_SIZE ) ; when ( writer . writeData ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) , any ( ChannelPromise . class ) ) ) . thenAnswer ( successAnswer ( ) ) ; when ( writer . writeRstStream ( eq ( ctx ) , anyInt ( ) , anyLong ( ) , any ( ChannelPromise . class ) ) ) . thenAnswer ( successAnswer ( ) ) ; when ( writer . writeGoAway ( any ( ChannelHandlerContext . class ) , anyInt ( ) , anyLong ( ) , any ( ByteBuf . class ) , any ( ChannelPromise . class ) ) ) . thenAnswer ( successAnswer ( ) ) ; connection = new DefaultHttp2Connection ( false ) ; connection . remote ( ) . flowController ( new DefaultHttp2RemoteFlowController ( connection ) ) ; connection . local ( ) . flowController ( new DefaultHttp2LocalFlowController ( connection ) . frameWriter ( writer ) ) ; DefaultHttp2ConnectionEncoder defaultEncoder = new DefaultHttp2ConnectionEncoder ( connection , writer ) ; encoder = new StreamBufferingEncoder ( defaultEncoder ) ; DefaultHttp2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder ( connection , encoder , mock ( Http2FrameReader . class ) ) ; Http2ConnectionHandler handler = new Http2ConnectionHandler . Builder ( ) . frameListener ( mock ( Http2FrameListener . class ) ) . build ( decoder , encoder ) ; when ( ctx . channel ( ) ) . thenReturn ( channel ) ; when ( ctx . alloc ( ) ) . thenReturn ( UnpooledByteBufAllocator . DEFAULT ) ; when ( channel . alloc ( ) ) . thenReturn ( UnpooledByteBufAllocator . DEFAULT ) ; when ( executor . inEventLoop ( ) ) . thenReturn ( true ) ; doAnswer ( new Answer < ChannelPromise > ( ) { @Override public ChannelPromise answer ( InvocationOnMock invocation ) throws Throwable { return newPromise ( ) ; } } ) . when ( ctx ) . newPromise ( ) ; when ( ctx . executor ( ) ) . thenReturn ( executor ) ; when ( channel . isActive ( ) ) . thenReturn ( false ) ; when ( channel . config ( ) ) . thenReturn ( config ) ; when ( channel . isWritable ( ) ) . thenReturn ( true ) ; when ( channel . bytesBeforeUnwritable ( ) ) . thenReturn ( Long . MAX_VALUE ) ; when ( config . getWriteBufferHighWaterMark ( ) ) . thenReturn ( Integer . MAX_VALUE ) ; handler . handlerAdded ( ctx ) ; } @After public void teardown ( ) { encoder . close ( ) ; } @Test public void multipleWritesToActiveStream ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ByteBuf data = data ( ) ; final int expectedBytes = data . readableBytes ( ) * <int> ; encoder . writeData ( ctx , <int> , data , <int> , false , newPromise ( ) ) ; encoder . writeData ( ctx , <int> , data ( ) , <int> , false , newPromise ( ) ) ; encoder . writeData ( ctx , <int> , data ( ) , <int> , false , newPromise ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; ArgumentCaptor < ByteBuf > bufCaptor = ArgumentCaptor . forClass ( ByteBuf . class ) ; verify ( writer , times ( <int> ) ) . writeData ( eq ( ctx ) , eq ( <int> ) , bufCaptor . capture ( ) , eq ( <int> ) , eq ( false ) , any ( ChannelPromise . class ) ) ; assertEquals ( expectedBytes , bufCaptor . getValue ( ) . readableBytes ( ) ) ; } @Test public void ensureCanCreateNextStreamWhenStreamCloses ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; setMaxConcurrentStreams ( <int> ) ; connection . stream ( <int> ) . close ( ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; } @Test public void alternatingWritesToActiveAndBufferedStreams ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoder . writeData ( ctx , <int> , EMPTY_BUFFER , <int> , false , newPromise ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; encoder . writeData ( ctx , <int> , EMPTY_BUFFER , <int> , false , newPromise ( ) ) ; verify ( writer , never ( ) ) . writeData ( eq ( ctx ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( false ) , eq ( newPromise ( ) ) ) ; } @Test public void bufferingNewStreamFailsAfterGoAwayReceived ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; connection . goAwayReceived ( <int> , <int> , EMPTY_BUFFER ) ; ChannelPromise promise = newPromise ( ) ; encoderWriteHeaders ( <int> , promise ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; assertTrue ( promise . isDone ( ) ) ; assertFalse ( promise . isSuccess ( ) ) ; } @Test public void receivingGoAwayFailsBufferedStreams ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; int streamId = <int> ; List < ChannelFuture > futures = new ArrayList < ChannelFuture > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { futures . add ( encoderWriteHeaders ( streamId , newPromise ( ) ) ) ; streamId + = <int> ; } assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; connection . goAwayReceived ( <int> , <int> , EMPTY_BUFFER ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; int failCount = <int> ; for ( ChannelFuture f : futures ) { if ( f . cause ( ) ! = null ) { failCount + + ; } } assertEquals ( <int> , failCount ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; } @Test public void sendingGoAwayShouldNotFailStreams ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; ChannelFuture f1 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ChannelFuture f2 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ChannelFuture f3 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ByteBuf empty = Unpooled . buffer ( <int> ) ; encoder . writeGoAway ( ctx , <int> , CANCEL . code ( ) , empty , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; assertFalse ( f1 . isDone ( ) ) ; assertFalse ( f2 . isDone ( ) ) ; assertFalse ( f3 . isDone ( ) ) ; } @Test public void endStreamDoesNotFailBufferedStream ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoder . writeData ( ctx , <int> , EMPTY_BUFFER , <int> , true , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; assertEquals ( HALF_CLOSED_LOCAL , connection . stream ( <int> ) . state ( ) ) ; } @Test public void rstStreamClosesBufferedStream ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ChannelPromise rstStreamPromise = newPromise ( ) ; encoder . writeRstStream ( ctx , <int> , CANCEL . code ( ) , rstStreamPromise ) ; assertTrue ( rstStreamPromise . isSuccess ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; } @Test public void bufferUntilActiveStreamsAreReset ( ) throws Exception { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; encoder . writeRstStream ( ctx , <int> , CANCEL . code ( ) , newPromise ( ) ) ; connection . remote ( ) . flowController ( ) . writePendingBytes ( ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoder . writeRstStream ( ctx , <int> , CANCEL . code ( ) , newPromise ( ) ) ; connection . remote ( ) . flowController ( ) . writePendingBytes ( ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; encoder . writeRstStream ( ctx , <int> , CANCEL . code ( ) , newPromise ( ) ) ; assertEquals ( <int> , connection . numActiveStreams ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; } @Test public void bufferUntilMaxStreamsIncreased ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; writeVerifyWriteHeaders ( never ( ) , <int> ) ; setMaxConcurrentStreams ( <int> ) ; encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; encoderWriteHeaders ( <int> , newPromise ( ) ) ; writeVerifyWriteHeaders ( times ( <int> ) , <int> ) ; assertEquals ( <int> , connection . local ( ) . numActiveStreams ( ) ) ; } @Test public void bufferUntilSettingsReceived ( ) throws Http2Exception { int initialLimit = SMALLEST_MAX_CONCURRENT_STREAMS ; int numStreams = initialLimit * <int> ; for ( int ix = <int> , nextStreamId = <int> ; ix < numStreams ; + + ix , nextStreamId + = <int> ) { encoderWriteHeaders ( nextStreamId , newPromise ( ) ) ; if ( ix < initialLimit ) { writeVerifyWriteHeaders ( times ( <int> ) , nextStreamId ) ; } else { writeVerifyWriteHeaders ( never ( ) , nextStreamId ) ; } } assertEquals ( numStreams / <int> , encoder . numBufferedStreams ( ) ) ; setMaxConcurrentStreams ( initialLimit * <int> ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; assertEquals ( numStreams , connection . local ( ) . numActiveStreams ( ) ) ; } @Test public void bufferUntilSettingsReceivedWithNoMaxConcurrentStreamValue ( ) throws Http2Exception { int initialLimit = SMALLEST_MAX_CONCURRENT_STREAMS ; int numStreams = initialLimit * <int> ; for ( int ix = <int> , nextStreamId = <int> ; ix < numStreams ; + + ix , nextStreamId + = <int> ) { encoderWriteHeaders ( nextStreamId , newPromise ( ) ) ; if ( ix < initialLimit ) { writeVerifyWriteHeaders ( times ( <int> ) , nextStreamId ) ; } else { writeVerifyWriteHeaders ( never ( ) , nextStreamId ) ; } } assertEquals ( numStreams / <int> , encoder . numBufferedStreams ( ) ) ; encoder . remoteSettings ( new Http2Settings ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; assertEquals ( numStreams , connection . local ( ) . numActiveStreams ( ) ) ; } @Test public void exhaustedStreamsDoNotBuffer ( ) throws Http2Exception { encoderWriteHeaders ( Integer . MAX_VALUE , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; ChannelFuture f = encoderWriteHeaders ( - <int> , newPromise ( ) ) ; assertNotNull ( f . cause ( ) ) ; } @Test public void closedBufferedStreamReleasesByteBuf ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; setMaxConcurrentStreams ( <int> ) ; ByteBuf data = mock ( ByteBuf . class ) ; ChannelFuture f1 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; ChannelFuture f2 = encoder . writeData ( ctx , <int> , data , <int> , false , newPromise ( ) ) ; ChannelPromise rstPromise = mock ( ChannelPromise . class ) ; encoder . writeRstStream ( ctx , <int> , CANCEL . code ( ) , rstPromise ) ; assertEquals ( <int> , encoder . numBufferedStreams ( ) ) ; verify ( rstPromise ) . setSuccess ( ) ; assertTrue ( f1 . isSuccess ( ) ) ; assertTrue ( f2 . isSuccess ( ) ) ; verify ( data ) . release ( ) ; } @Test public void closeShouldCancelAllBufferedStreams ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; connection . local ( ) . maxActiveStreams ( <int> ) ; ChannelFuture f1 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; ChannelFuture f2 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; ChannelFuture f3 = encoderWriteHeaders ( <int> , newPromise ( ) ) ; encoder . close ( ) ; assertNotNull ( f1 . cause ( ) ) ; assertNotNull ( f2 . cause ( ) ) ; assertNotNull ( f3 . cause ( ) ) ; } @Test public void headersAfterCloseShouldImmediatelyFail ( ) { encoder . writeSettingsAck ( ctx , newPromise ( ) ) ; encoder . close ( ) ; ChannelFuture f = encoderWriteHeaders ( <int> , newPromise ( ) ) ; assertNotNull ( f . cause ( ) ) ; } private void setMaxConcurrentStreams ( int newValue ) { try { encoder . remoteSettings ( new Http2Settings ( ) . maxConcurrentStreams ( newValue ) ) ; encoder . flowController ( ) . writePendingBytes ( ) ; } catch ( Http2Exception e ) { throw new RuntimeException ( e ) ; } } private ChannelFuture encoderWriteHeaders ( int streamId , ChannelPromise promise ) { encoder . writeHeaders ( ctx , streamId , new DefaultHttp2Headers ( ) , <int> , DEFAULT_PRIORITY_WEIGHT , false , <int> , false , promise ) ; try { encoder . flowController ( ) . writePendingBytes ( ) ; return promise ; } catch ( Http2Exception e ) { throw new RuntimeException ( e ) ; } } private void writeVerifyWriteHeaders ( VerificationMode mode , int streamId ) { verify ( writer , mode ) . writeHeaders ( eq ( ctx ) , eq ( streamId ) , any ( Http2Headers . class ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( false ) , any ( ChannelPromise . class ) ) ; } private Answer < ChannelFuture > successAnswer ( ) { return new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock invocation ) throws Throwable { for ( Object a : invocation . getArguments ( ) ) { ReferenceCountUtil . safeRelease ( a ) ; } ChannelPromise future = newPromise ( ) ; future . setSuccess ( ) ; return future ; } } ; } private ChannelPromise newPromise ( ) { return new DefaultChannelPromise ( channel , ImmediateEventExecutor . INSTANCE ) ; } private static ByteBuf data ( ) { ByteBuf buf = Unpooled . buffer ( <int> ) ; for ( int i = <int> ; i < buf . writableBytes ( ) ; i + + ) { buf . writeByte ( i ) ; } return buf ; } }