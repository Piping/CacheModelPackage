package com . google . common . base ; import static com . google . common . base . Preconditions . checkNotNull ; import static java . util . Arrays . asList ; import static java . util . Collections . unmodifiableList ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . AbstractList ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; public final class Throwables { private Throwables ( ) { } public static < X extends Throwable > void propagateIfInstanceOf ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { if ( throwable ! = null & & declaredType . isInstance ( throwable ) ) { throw declaredType . cast ( throwable ) ; } } public static void propagateIfPossible ( @Nullable Throwable throwable ) { propagateIfInstanceOf ( throwable , Error . class ) ; propagateIfInstanceOf ( throwable , RuntimeException . class ) ; } public static < X extends Throwable > void propagateIfPossible ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { propagateIfInstanceOf ( throwable , declaredType ) ; propagateIfPossible ( throwable ) ; } public static < X1 extends Throwable , X2 extends Throwable > void propagateIfPossible ( @Nullable Throwable throwable , Class < X1 > declaredType1 , Class < X2 > declaredType2 ) throws X1 , X2 { checkNotNull ( declaredType2 ) ; propagateIfInstanceOf ( throwable , declaredType1 ) ; propagateIfPossible ( throwable , declaredType2 ) ; } public static RuntimeException propagate ( Throwable throwable ) { propagateIfPossible ( checkNotNull ( throwable ) ) ; throw new RuntimeException ( throwable ) ; } @CheckReturnValue public static Throwable getRootCause ( Throwable throwable ) { Throwable cause ; while ( ( cause = throwable . getCause ( ) ) ! = null ) { throwable = cause ; } return throwable ; } @Beta @CheckReturnValue public static List < Throwable > getCausalChain ( Throwable throwable ) { checkNotNull ( throwable ) ; List < Throwable > causes = new ArrayList < Throwable > ( <int> ) ; while ( throwable ! = null ) { causes . add ( throwable ) ; throwable = throwable . getCause ( ) ; } return Collections . unmodifiableList ( causes ) ; } @CheckReturnValue public static String getStackTraceAsString ( Throwable throwable ) { StringWriter stringWriter = new StringWriter ( ) ; throwable . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } @Beta @CheckReturnValue public static List < StackTraceElement > lazyStackTrace ( Throwable throwable ) { return lazyStackTraceIsLazy ( ) ? jlaStackTrace ( throwable ) : unmodifiableList ( asList ( throwable . getStackTrace ( ) ) ) ; } @Beta @CheckReturnValue public static boolean lazyStackTraceIsLazy ( ) { return getStackTraceElementMethod ! = null & getStackTraceDepthMethod ! = null ; } private static List < StackTraceElement > jlaStackTrace ( final Throwable t ) { checkNotNull ( t ) ; return new AbstractList < StackTraceElement > ( ) { @Override public StackTraceElement get ( int n ) { return ( StackTraceElement ) invokeAccessibleNonThrowingMethod ( getStackTraceElementMethod , jla , t , n ) ; } @Override public int size ( ) { return ( Integer ) invokeAccessibleNonThrowingMethod ( getStackTraceDepthMethod , jla , t ) ; } } ; } private static Object invokeAccessibleNonThrowingMethod ( Method method , Object receiver , Object . . . params ) { try { return method . invoke ( receiver , params ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw propagate ( e . getCause ( ) ) ; } } private static final String JAVA_LANG_ACCESS_CLASSNAME = <str> ; @VisibleForTesting static final String SHARED_SECRETS_CLASSNAME = <str> ; @Nullable private static final Object jla = getJLA ( ) ; @Nullable private static final Method getStackTraceElementMethod = ( jla = = null ) ? null : getGetMethod ( ) ; @Nullable private static final Method getStackTraceDepthMethod = ( jla = = null ) ? null : getSizeMethod ( ) ; @Nullable private static Object getJLA ( ) { try { Class < ? > sharedSecrets = Class . forName ( SHARED_SECRETS_CLASSNAME , false , null ) ; Method langAccess = sharedSecrets . getMethod ( <str> ) ; return langAccess . invoke ( null ) ; } catch ( ThreadDeath death ) { throw death ; } catch ( Throwable t ) { return null ; } } @Nullable private static Method getGetMethod ( ) { return getJlaMethod ( <str> , Throwable . class , int . class ) ; } @Nullable private static Method getSizeMethod ( ) { return getJlaMethod ( <str> , Throwable . class ) ; } @Nullable private static Method getJlaMethod ( String name , Class < ? > . . . parameterTypes ) throws ThreadDeath { try { return Class . forName ( JAVA_LANG_ACCESS_CLASSNAME , false , null ) . getMethod ( name , parameterTypes ) ; } catch ( ThreadDeath death ) { throw death ; } catch ( Throwable t ) { return null ; } } }