package com . badlogic . gdx . tests ; import java . util . LinkedList ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g3d . decals . CameraGroupStrategy ; import com . badlogic . gdx . graphics . g3d . decals . Decal ; import com . badlogic . gdx . graphics . g3d . decals . DecalBatch ; import com . badlogic . gdx . math . WindowedMean ; import com . badlogic . gdx . tests . utils . GdxTest ; public class DecalTest extends GdxTest { public static final int TARGET_FPS = <int> ; public static final int INITIAL_RENDERED = <int> ; private boolean willItBlend_that_is_the_question = true ; Texture egg ; Texture wheel ; LinkedList < Decal > toRender = new LinkedList < Decal > ( ) ; DecalBatch batch ; float timePassed = <int> ; int frames = <int> ; Camera cam ; WindowedMean fps = new WindowedMean ( <int> ) ; int idx = <int> ; float w ; float h ; @Override public void create ( ) { Gdx . gl . glEnable ( GL20 . GL_DEPTH_TEST ) ; Gdx . gl . glDepthFunc ( GL20 . GL_LESS ) ; egg = new Texture ( Gdx . files . internal ( <str> ) ) ; egg . setFilter ( Texture . TextureFilter . Linear , Texture . TextureFilter . Linear ) ; egg . setWrap ( Texture . TextureWrap . ClampToEdge , Texture . TextureWrap . ClampToEdge ) ; wheel = new Texture ( Gdx . files . internal ( <str> ) ) ; wheel . setFilter ( Texture . TextureFilter . Linear , Texture . TextureFilter . Linear ) ; wheel . setWrap ( Texture . TextureWrap . ClampToEdge , Texture . TextureWrap . ClampToEdge ) ; w = Gdx . graphics . getWidth ( ) / <float> ; h = Gdx . graphics . getHeight ( ) / <float> ; for ( int i = <int> ; i < INITIAL_RENDERED ; i + + ) { toRender . add ( makeDecal ( ) ) ; } cam = new OrthographicCamera ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; cam . near = <float> ; cam . far = <int> f ; cam . position . set ( <int> , <int> , <float> ) ; cam . direction . set ( <int> , <int> , - <int> f ) ; batch = new DecalBatch ( new CameraGroupStrategy ( cam ) ) ; Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; } @Override public void dispose ( ) { egg . dispose ( ) ; wheel . dispose ( ) ; batch . dispose ( ) ; } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; float elapsed = Gdx . graphics . getDeltaTime ( ) ; float scale = timePassed > <float> ? <int> - timePassed / <int> : <float> + timePassed / <int> ; for ( Decal decal : toRender ) { decal . rotateZ ( elapsed * <int> ) ; decal . setScale ( scale ) ; batch . add ( decal ) ; } batch . flush ( ) ; timePassed + = elapsed ; frames + + ; if ( timePassed > <float> ) { System . out . println ( <str> + frames + <str> + toRender . size ( ) ) ; fps . addValue ( frames ) ; if ( fps . hasEnoughData ( ) ) { float factor = fps . getMean ( ) / ( float ) TARGET_FPS ; int target = ( int ) ( toRender . size ( ) * factor ) ; if ( fps . getMean ( ) > TARGET_FPS ) { int start = toRender . size ( ) ; for ( int i = start ; toRender . size ( ) < target ; i + + ) { toRender . add ( makeDecal ( ) ) ; } fps . clear ( ) ; } else { while ( toRender . size ( ) > target ) { toRender . removeLast ( ) ; } fps . clear ( ) ; } } timePassed = <int> ; frames = <int> ; } } @Override public void resize ( int width , int height ) { w = Gdx . graphics . getWidth ( ) / <float> ; h = Gdx . graphics . getHeight ( ) / <float> ; cam = new OrthographicCamera ( width , height ) ; cam . near = <float> ; cam . far = <int> f ; cam . position . set ( <int> , <int> , <float> ) ; cam . direction . set ( <int> , <int> , - <int> f ) ; } private Decal makeDecal ( ) { Decal sprite = null ; switch ( idx % <int> ) { case <int> : sprite = Decal . newDecal ( new TextureRegion ( egg ) , willItBlend_that_is_the_question ) ; break ; case <int> : sprite = Decal . newDecal ( new TextureRegion ( wheel ) ) ; break ; } sprite . setPosition ( - w / <int> + ( float ) Math . random ( ) * w , h / <int> - ( float ) Math . random ( ) * h , ( float ) - Math . random ( ) * <int> ) ; idx + + ; return sprite ; } }