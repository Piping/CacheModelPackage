package rx . internal . operators ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import rx . Observable ; import rx . Observable . Operator ; import rx . exceptions . Exceptions ; import rx . Observer ; import rx . Subscriber ; import rx . functions . Func1 ; import rx . observers . SerializedSubscriber ; import rx . subscriptions . CompositeSubscription ; public final class OperatorBufferWithStartEndObservable < T , TOpening , TClosing > implements Operator < List < T > , T > { final Observable < ? extends TOpening > bufferOpening ; final Func1 < ? super TOpening , ? extends Observable < ? extends TClosing > > bufferClosing ; public OperatorBufferWithStartEndObservable ( Observable < ? extends TOpening > bufferOpenings , Func1 < ? super TOpening , ? extends Observable < ? extends TClosing > > bufferClosingSelector ) { this . bufferOpening = bufferOpenings ; this . bufferClosing = bufferClosingSelector ; } @Override public Subscriber < ? super T > call ( final Subscriber < ? super List < T > > child ) { final BufferingSubscriber bsub = new BufferingSubscriber ( new SerializedSubscriber < List < T > > ( child ) ) ; Subscriber < TOpening > openSubscriber = new Subscriber < TOpening > ( ) { @Override public void onNext ( TOpening t ) { bsub . startBuffer ( t ) ; } @Override public void onError ( Throwable e ) { bsub . onError ( e ) ; } @Override public void onCompleted ( ) { bsub . onCompleted ( ) ; } } ; child . add ( openSubscriber ) ; child . add ( bsub ) ; bufferOpening . unsafeSubscribe ( openSubscriber ) ; return bsub ; } final class BufferingSubscriber extends Subscriber < T > { final Subscriber < ? super List < T > > child ; final List < List < T > > chunks ; boolean done ; final CompositeSubscription closingSubscriptions ; public BufferingSubscriber ( Subscriber < ? super List < T > > child ) { this . child = child ; this . chunks = new LinkedList < List < T > > ( ) ; this . closingSubscriptions = new CompositeSubscription ( ) ; add ( this . closingSubscriptions ) ; } @Override public void onNext ( T t ) { synchronized ( this ) { for ( List < T > chunk : chunks ) { chunk . add ( t ) ; } } } @Override public void onError ( Throwable e ) { synchronized ( this ) { if ( done ) { return ; } done = true ; chunks . clear ( ) ; } child . onError ( e ) ; unsubscribe ( ) ; } @Override public void onCompleted ( ) { try { List < List < T > > toEmit ; synchronized ( this ) { if ( done ) { return ; } done = true ; toEmit = new LinkedList < List < T > > ( chunks ) ; chunks . clear ( ) ; } for ( List < T > chunk : toEmit ) { child . onNext ( chunk ) ; } } catch ( Throwable t ) { Exceptions . throwOrReport ( t , child ) ; return ; } child . onCompleted ( ) ; unsubscribe ( ) ; } void startBuffer ( TOpening v ) { final List < T > chunk = new ArrayList < T > ( ) ; synchronized ( this ) { if ( done ) { return ; } chunks . add ( chunk ) ; } Observable < ? extends TClosing > cobs ; try { cobs = bufferClosing . call ( v ) ; } catch ( Throwable t ) { Exceptions . throwOrReport ( t , this ) ; return ; } Subscriber < TClosing > closeSubscriber = new Subscriber < TClosing > ( ) { @Override public void onNext ( TClosing t ) { closingSubscriptions . remove ( this ) ; endBuffer ( chunk ) ; } @Override public void onError ( Throwable e ) { BufferingSubscriber . this . onError ( e ) ; } @Override public void onCompleted ( ) { closingSubscriptions . remove ( this ) ; endBuffer ( chunk ) ; } } ; closingSubscriptions . add ( closeSubscriber ) ; cobs . unsafeSubscribe ( closeSubscriber ) ; } void endBuffer ( List < T > toEnd ) { boolean canEnd = false ; synchronized ( this ) { if ( done ) { return ; } Iterator < List < T > > it = chunks . iterator ( ) ; while ( it . hasNext ( ) ) { List < T > chunk = it . next ( ) ; if ( chunk = = toEnd ) { canEnd = true ; it . remove ( ) ; break ; } } } if ( canEnd ) { child . onNext ( toEnd ) ; } } } } 
