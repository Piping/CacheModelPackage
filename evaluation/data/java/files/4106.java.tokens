package io . netty . handler . codec ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOutboundHandler ; import io . netty . channel . ChannelOutboundHandlerAdapter ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . ReferenceCounted ; import io . netty . util . internal . RecyclableArrayList ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . TypeParameterMatcher ; import java . util . List ; public abstract class MessageToMessageEncoder < I > extends ChannelOutboundHandlerAdapter { private final TypeParameterMatcher matcher ; protected MessageToMessageEncoder ( ) { matcher = TypeParameterMatcher . find ( this , MessageToMessageEncoder . class , <str> ) ; } protected MessageToMessageEncoder ( Class < ? extends I > outboundMessageType ) { matcher = TypeParameterMatcher . get ( outboundMessageType ) ; } public boolean acceptOutboundMessage ( Object msg ) throws Exception { return matcher . match ( msg ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { RecyclableArrayList out = null ; try { if ( acceptOutboundMessage ( msg ) ) { out = RecyclableArrayList . newInstance ( ) ; @SuppressWarnings ( <str> ) I cast = ( I ) msg ; try { encode ( ctx , cast , out ) ; } finally { ReferenceCountUtil . release ( cast ) ; } if ( out . isEmpty ( ) ) { out . recycle ( ) ; out = null ; throw new EncoderException ( StringUtil . simpleClassName ( this ) + <str> ) ; } } else { ctx . write ( msg , promise ) ; } } catch ( EncoderException e ) { throw e ; } catch ( Throwable t ) { throw new EncoderException ( t ) ; } finally { if ( out ! = null ) { final int sizeMinusOne = out . size ( ) - <int> ; if ( sizeMinusOne = = <int> ) { ctx . write ( out . get ( <int> ) , promise ) ; } else if ( sizeMinusOne > <int> ) { ChannelPromise voidPromise = ctx . voidPromise ( ) ; boolean isVoidPromise = promise = = voidPromise ; for ( int i = <int> ; i < sizeMinusOne ; i + + ) { ChannelPromise p ; if ( isVoidPromise ) { p = voidPromise ; } else { p = ctx . newPromise ( ) ; } ctx . write ( out . get ( i ) , p ) ; } ctx . write ( out . get ( sizeMinusOne ) , promise ) ; } out . recycle ( ) ; } } } protected abstract void encode ( ChannelHandlerContext ctx , I msg , List < Object > out ) throws Exception ; }