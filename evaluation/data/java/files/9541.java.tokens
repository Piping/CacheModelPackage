package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . PerspectiveCamController ; public class ShapeRendererTest extends GdxTest { ShapeRenderer renderer ; PerspectiveCamera cam ; PerspectiveCamController controller ; SpriteBatch batch ; BitmapFont font ; public void create ( ) { renderer = new ShapeRenderer ( ) ; cam = new PerspectiveCamera ( <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; cam . position . set ( <int> , <int> , <int> ) ; cam . near = <float> ; controller = new PerspectiveCamController ( cam ) ; Gdx . input . setInputProcessor ( controller ) ; batch = new SpriteBatch ( ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , false ) ; } public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; Gdx . gl . glEnable ( GL20 . GL_DEPTH_TEST ) ; cam . update ( ) ; renderer . setProjectionMatrix ( cam . combined ) ; renderer . identity ( ) ; renderer . rotate ( <int> , <int> , <int> , <int> ) ; renderer . translate ( - <float> , - <float> , <int> ) ; MathUtils . random . setSeed ( <int> ) ; renderer . begin ( ShapeType . Point ) ; renderer . setColor ( Color . PINK ) ; for ( int i = <int> ; i < <int> ; i + + ) renderer . point ( MathUtils . random ( <float> , <float> ) , MathUtils . random ( <float> , <float> ) , <int> ) ; renderer . end ( ) ; if ( Gdx . input . isKeyPressed ( Keys . F ) ) { renderer . begin ( ShapeType . Filled ) ; renderer . setColor ( Color . RED ) ; renderer . rect ( <int> , <int> , <int> , <int> ) ; renderer . setColor ( Color . BLUE ) ; renderer . circle ( <float> , <float> , <float> , <int> ) ; renderer . setColor ( Color . WHITE ) ; renderer . box ( <float> , <float> , <float> , <float> , <float> , <float> ) ; renderer . setColor ( Color . GREEN ) ; renderer . cone ( <float> , <float> , <int> , <float> , <float> , <int> ) ; renderer . setColor ( Color . MAGENTA ) ; renderer . triangle ( - <float> , <float> , - <float> , - <float> , - <float> , <float> ) ; renderer . end ( ) ; } else { renderer . begin ( ShapeType . Line ) ; renderer . setColor ( Color . RED ) ; renderer . rect ( <int> , <int> , <int> , <int> ) ; renderer . setColor ( Color . BLUE ) ; renderer . circle ( <float> , <float> , <float> , <int> ) ; renderer . setColor ( Color . YELLOW ) ; renderer . line ( <int> , <int> , <int> , <int> ) ; renderer . setColor ( Color . WHITE ) ; renderer . box ( <float> , <float> , <float> , <float> , <float> , <float> ) ; renderer . setColor ( Color . GREEN ) ; renderer . cone ( <float> , <float> , <int> , <float> , <float> , <int> ) ; renderer . setColor ( Color . MAGENTA ) ; renderer . triangle ( - <float> , <float> , - <float> , - <float> , - <float> , <float> ) ; renderer . setColor ( Color . CYAN ) ; renderer . curve ( <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <int> ) ; renderer . end ( ) ; } batch . begin ( ) ; font . draw ( batch , <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; batch . end ( ) ; } @Override public void dispose ( ) { batch . dispose ( ) ; font . dispose ( ) ; renderer . dispose ( ) ; } }