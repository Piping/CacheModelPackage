package rx . internal . operators ; import static org . junit . Assert . assertEquals ; import static org . mockito . Matchers . isA ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . spy ; import static org . mockito . Mockito . times ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . concurrent . atomic . AtomicLong ; import org . junit . Test ; import org . mockito . InOrder ; import rx . Observable ; import rx . Observer ; import rx . Subscriber ; import rx . functions . Action1 ; import rx . functions . Func1 ; import rx . functions . Func2 ; public class OperatorSingleTest { @Test public void testSingle ( ) { Observable < Integer > observable = Observable . just ( <int> ) . single ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleWithTooManyElements ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> ) . single ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleWithEmpty ( ) { Observable < Integer > observable = Observable . < Integer > empty ( ) . single ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( NoSuchElementException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleDoesNotRequestMoreThanItNeedsToEmitItem ( ) { final AtomicLong request = new AtomicLong ( ) ; Observable . just ( <int> ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { request . addAndGet ( n ) ; } } ) . toBlocking ( ) . single ( ) ; assertEquals ( <int> , request . get ( ) ) ; } @Test public void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromEmpty ( ) { final AtomicLong request = new AtomicLong ( ) ; try { Observable . empty ( ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { request . addAndGet ( n ) ; } } ) . toBlocking ( ) . single ( ) ; } catch ( NoSuchElementException e ) { assertEquals ( <int> , request . get ( ) ) ; } } @Test public void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromMoreThanOne ( ) { final AtomicLong request = new AtomicLong ( ) ; try { Observable . just ( <int> , <int> ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { request . addAndGet ( n ) ; } } ) . toBlocking ( ) . single ( ) ; } catch ( IllegalArgumentException e ) { assertEquals ( <int> , request . get ( ) ) ; } } @Test public void testSingleDoesNotRequestMoreThanItNeedsIf1Then2Requested ( ) { final List < Long > requests = new ArrayList < Long > ( ) ; Observable . just ( <int> ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { requests . add ( n ) ; } } ) . single ( ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer t ) { request ( <int> ) ; } } ) ; assertEquals ( Arrays . asList ( <int> ) , requests ) ; } @Test public void testSingleDoesNotRequestMoreThanItNeedsIf3Requested ( ) { final List < Long > requests = new ArrayList < Long > ( ) ; Observable . just ( <int> ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { requests . add ( n ) ; } } ) . single ( ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer t ) { } } ) ; assertEquals ( Arrays . asList ( <int> ) , requests ) ; } @Test public void testSingleRequestsExactlyWhatItNeedsIf1Requested ( ) { final List < Long > requests = new ArrayList < Long > ( ) ; Observable . just ( <int> ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { requests . add ( n ) ; } } ) . single ( ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer t ) { } } ) ; assertEquals ( Arrays . asList ( <int> ) , requests ) ; } @Test public void testSingleWithPredicate ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> ) . single ( new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleWithPredicateAndTooManyElements ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> ) . single ( new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleWithPredicateAndEmpty ( ) { Observable < Integer > observable = Observable . just ( <int> ) . single ( new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( NoSuchElementException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefault ( ) { Observable < Integer > observable = Observable . just ( <int> ) . singleOrDefault ( <int> ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefaultWithTooManyElements ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> ) . singleOrDefault ( <int> ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefaultWithEmpty ( ) { Observable < Integer > observable = Observable . < Integer > empty ( ) . singleOrDefault ( <int> ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefaultWithPredicate ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> ) . singleOrDefault ( <int> , new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefaultWithPredicateAndTooManyElements ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> ) . singleOrDefault ( <int> , new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleOrDefaultWithPredicateAndEmpty ( ) { Observable < Integer > observable = Observable . just ( <int> ) . singleOrDefault ( <int> , new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer t1 ) { return t1 % <int> = = <int> ; } } ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testSingleWithBackpressure ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> ) . single ( ) ; Subscriber < Integer > subscriber = spy ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { } @Override public void onNext ( Integer integer ) { request ( <int> ) ; } } ) ; observable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( <int> ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test ( timeout = <int> ) public void testIssue1527 ( ) throws InterruptedException { Observable < Integer > source = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> ) ; Observable < Integer > reduced = source . reduce ( new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer i1 , Integer i2 ) { return i1 + i2 ; } } ) ; Integer r = reduced . toBlocking ( ) . first ( ) ; assertEquals ( <int> , r . intValue ( ) ) ; } }