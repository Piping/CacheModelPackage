package com . badlogic . gdx . graphics . g2d ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; public class Animation { public enum PlayMode { NORMAL , REVERSED , LOOP , LOOP_REVERSED , LOOP_PINGPONG , LOOP_RANDOM , } final TextureRegion [ ] keyFrames ; private float frameDuration ; private float animationDuration ; private int lastFrameNumber ; private float lastStateTime ; private PlayMode playMode = PlayMode . NORMAL ; public Animation ( float frameDuration , Array < ? extends TextureRegion > keyFrames ) { this . frameDuration = frameDuration ; this . animationDuration = keyFrames . size * frameDuration ; this . keyFrames = new TextureRegion [ keyFrames . size ] ; for ( int i = <int> , n = keyFrames . size ; i < n ; i + + ) { this . keyFrames [ i ] = keyFrames . get ( i ) ; } this . playMode = PlayMode . NORMAL ; } public Animation ( float frameDuration , Array < ? extends TextureRegion > keyFrames , PlayMode playMode ) { this . frameDuration = frameDuration ; this . animationDuration = keyFrames . size * frameDuration ; this . keyFrames = new TextureRegion [ keyFrames . size ] ; for ( int i = <int> , n = keyFrames . size ; i < n ; i + + ) { this . keyFrames [ i ] = keyFrames . get ( i ) ; } this . playMode = playMode ; } public Animation ( float frameDuration , TextureRegion . . . keyFrames ) { this . frameDuration = frameDuration ; this . animationDuration = keyFrames . length * frameDuration ; this . keyFrames = keyFrames ; this . playMode = PlayMode . NORMAL ; } public TextureRegion getKeyFrame ( float stateTime , boolean looping ) { PlayMode oldPlayMode = playMode ; if ( looping & & ( playMode = = PlayMode . NORMAL | | playMode = = PlayMode . REVERSED ) ) { if ( playMode = = PlayMode . NORMAL ) playMode = PlayMode . LOOP ; else playMode = PlayMode . LOOP_REVERSED ; } else if ( ! looping & & ! ( playMode = = PlayMode . NORMAL | | playMode = = PlayMode . REVERSED ) ) { if ( playMode = = PlayMode . LOOP_REVERSED ) playMode = PlayMode . REVERSED ; else playMode = PlayMode . LOOP ; } TextureRegion frame = getKeyFrame ( stateTime ) ; playMode = oldPlayMode ; return frame ; } public TextureRegion getKeyFrame ( float stateTime ) { int frameNumber = getKeyFrameIndex ( stateTime ) ; return keyFrames [ frameNumber ] ; } public int getKeyFrameIndex ( float stateTime ) { if ( keyFrames . length = = <int> ) return <int> ; int frameNumber = ( int ) ( stateTime / frameDuration ) ; switch ( playMode ) { case NORMAL : frameNumber = Math . min ( keyFrames . length - <int> , frameNumber ) ; break ; case LOOP : frameNumber = frameNumber % keyFrames . length ; break ; case LOOP_PINGPONG : frameNumber = frameNumber % ( ( keyFrames . length * <int> ) - <int> ) ; if ( frameNumber > = keyFrames . length ) frameNumber = keyFrames . length - <int> - ( frameNumber - keyFrames . length ) ; break ; case LOOP_RANDOM : int lastFrameNumber = ( int ) ( ( lastStateTime ) / frameDuration ) ; if ( lastFrameNumber ! = frameNumber ) { frameNumber = MathUtils . random ( keyFrames . length - <int> ) ; } else { frameNumber = this . lastFrameNumber ; } break ; case REVERSED : frameNumber = Math . max ( keyFrames . length - frameNumber - <int> , <int> ) ; break ; case LOOP_REVERSED : frameNumber = frameNumber % keyFrames . length ; frameNumber = keyFrames . length - frameNumber - <int> ; break ; } lastFrameNumber = frameNumber ; lastStateTime = stateTime ; return frameNumber ; } public TextureRegion [ ] getKeyFrames ( ) { return keyFrames ; } public PlayMode getPlayMode ( ) { return playMode ; } public void setPlayMode ( PlayMode playMode ) { this . playMode = playMode ; } public boolean isAnimationFinished ( float stateTime ) { int frameNumber = ( int ) ( stateTime / frameDuration ) ; return keyFrames . length - <int> < frameNumber ; } public void setFrameDuration ( float frameDuration ) { this . frameDuration = frameDuration ; this . animationDuration = keyFrames . length * frameDuration ; } public float getFrameDuration ( ) { return frameDuration ; } public float getAnimationDuration ( ) { return animationDuration ; } }