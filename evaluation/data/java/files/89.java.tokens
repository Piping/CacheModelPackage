package org . elasticsearch . indices ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . util . CollectionUtil ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . indices . stats . CommonStats ; import org . elasticsearch . action . admin . indices . stats . CommonStatsFlags ; import org . elasticsearch . action . admin . indices . stats . CommonStatsFlags . Flag ; import org . elasticsearch . action . admin . indices . stats . IndexShardStats ; import org . elasticsearch . action . admin . indices . stats . ShardStats ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . ShardLock ; import org . elasticsearch . gateway . MetaDataStateFormat ; import org . elasticsearch . index . * ; import org . elasticsearch . index . analysis . AnalysisRegistry ; import org . elasticsearch . index . flush . FlushStats ; import org . elasticsearch . index . get . GetStats ; import org . elasticsearch . index . indexing . IndexingStats ; import org . elasticsearch . index . merge . MergeStats ; import org . elasticsearch . index . recovery . RecoveryStats ; import org . elasticsearch . index . refresh . RefreshStats ; import org . elasticsearch . index . search . stats . SearchStats ; import org . elasticsearch . index . shard . IllegalIndexShardStateException ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . IndexStoreConfig ; import org . elasticsearch . indices . mapper . MapperRegistry ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . plugins . PluginsService ; import java . io . IOException ; import java . nio . file . Files ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . function . Predicate ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . collect . MapBuilder . newMapBuilder ; import static org . elasticsearch . common . util . CollectionUtils . arrayAsArrayList ; public class IndicesService extends AbstractLifecycleComponent < IndicesService > implements Iterable < IndexService > , IndexService . ShardStoreDeleter { public static final String INDICES_SHARDS_CLOSED_TIMEOUT = <str> ; private final PluginsService pluginsService ; private final NodeEnvironment nodeEnv ; private final TimeValue shardsClosedTimeout ; private final AnalysisRegistry analysisRegistry ; private final IndicesQueriesRegistry indicesQueriesRegistry ; private final ClusterService clusterService ; private final IndexNameExpressionResolver indexNameExpressionResolver ; private volatile Map < String , IndexService > indices = emptyMap ( ) ; private final Map < Index , List < PendingDelete > > pendingDeletes = new HashMap < > ( ) ; private final OldShardsStats oldShardsStats = new OldShardsStats ( ) ; private final IndexStoreConfig indexStoreConfig ; private final MapperRegistry mapperRegistry ; @Override protected void doStart ( ) { } @Inject public IndicesService ( Settings settings , PluginsService pluginsService , NodeEnvironment nodeEnv , NodeSettingsService nodeSettingsService , AnalysisRegistry analysisRegistry , IndicesQueriesRegistry indicesQueriesRegistry , IndexNameExpressionResolver indexNameExpressionResolver , ClusterService clusterService , MapperRegistry mapperRegistry ) { super ( settings ) ; this . pluginsService = pluginsService ; this . nodeEnv = nodeEnv ; this . shardsClosedTimeout = settings . getAsTime ( INDICES_SHARDS_CLOSED_TIMEOUT , new TimeValue ( <int> , TimeUnit . DAYS ) ) ; this . indexStoreConfig = new IndexStoreConfig ( settings ) ; this . analysisRegistry = analysisRegistry ; this . indicesQueriesRegistry = indicesQueriesRegistry ; this . clusterService = clusterService ; this . indexNameExpressionResolver = indexNameExpressionResolver ; this . mapperRegistry = mapperRegistry ; nodeSettingsService . addListener ( indexStoreConfig ) ; } @Override protected void doStop ( ) { ExecutorService indicesStopExecutor = Executors . newFixedThreadPool ( <int> , EsExecutors . daemonThreadFactory ( <str> ) ) ; Set < String > indices = new HashSet < > ( this . indices . keySet ( ) ) ; final CountDownLatch latch = new CountDownLatch ( indices . size ( ) ) ; for ( final String index : indices ) { indicesStopExecutor . execute ( ( ) - > { try { removeIndex ( index , <str> , false ) ; } catch ( Throwable e ) { logger . warn ( <str> + index + <str> , e ) ; } finally { latch . countDown ( ) ; } } ) ; } try { if ( latch . await ( shardsClosedTimeout . seconds ( ) , TimeUnit . SECONDS ) = = false ) { logger . warn ( <str> , shardsClosedTimeout . seconds ( ) ) ; } } catch ( InterruptedException e ) { } finally { indicesStopExecutor . shutdown ( ) ; } } @Override protected void doClose ( ) { IOUtils . closeWhileHandlingException ( analysisRegistry ) ; } public NodeIndicesStats stats ( boolean includePrevious ) { return stats ( includePrevious , new CommonStatsFlags ( ) . all ( ) ) ; } public NodeIndicesStats stats ( boolean includePrevious , CommonStatsFlags flags ) { CommonStats oldStats = new CommonStats ( flags ) ; if ( includePrevious ) { Flag [ ] setFlags = flags . getFlags ( ) ; for ( Flag flag : setFlags ) { switch ( flag ) { case Get : oldStats . get . add ( oldShardsStats . getStats ) ; break ; case Indexing : oldStats . indexing . add ( oldShardsStats . indexingStats ) ; break ; case Search : oldStats . search . add ( oldShardsStats . searchStats ) ; break ; case Merge : oldStats . merge . add ( oldShardsStats . mergeStats ) ; break ; case Refresh : oldStats . refresh . add ( oldShardsStats . refreshStats ) ; break ; case Recovery : oldStats . recoveryStats . add ( oldShardsStats . recoveryStats ) ; break ; case Flush : oldStats . flush . add ( oldShardsStats . flushStats ) ; break ; } } } Map < Index , List < IndexShardStats > > statsByShard = new HashMap < > ( ) ; for ( IndexService indexService : indices . values ( ) ) { for ( IndexShard indexShard : indexService ) { try { if ( indexShard . routingEntry ( ) = = null ) { continue ; } IndexShardStats indexShardStats = new IndexShardStats ( indexShard . shardId ( ) , new ShardStats [ ] { new ShardStats ( indexShard . routingEntry ( ) , indexShard . shardPath ( ) , new CommonStats ( indexShard , flags ) , indexShard . commitStats ( ) ) } ) ; if ( ! statsByShard . containsKey ( indexService . index ( ) ) ) { statsByShard . put ( indexService . index ( ) , arrayAsArrayList ( indexShardStats ) ) ; } else { statsByShard . get ( indexService . index ( ) ) . add ( indexShardStats ) ; } } catch ( IllegalIndexShardStateException e ) { logger . trace ( <str> , e , indexShard . shardId ( ) ) ; } } } return new NodeIndicesStats ( oldStats , statsByShard ) ; } public boolean changesAllowed ( ) { return lifecycle . started ( ) ; } @Override public Iterator < IndexService > iterator ( ) { return indices . values ( ) . iterator ( ) ; } public boolean hasIndex ( String index ) { return indices . containsKey ( index ) ; } @Nullable public IndexService indexService ( String index ) { return indices . get ( index ) ; } public IndexService indexServiceSafe ( String index ) { IndexService indexService = indexService ( index ) ; if ( indexService = = null ) { throw new IndexNotFoundException ( index ) ; } return indexService ; } public synchronized IndexService createIndex ( final NodeServicesProvider nodeServicesProvider , IndexMetaData indexMetaData , List < IndexEventListener > builtInListeners ) throws IOException { if ( ! lifecycle . started ( ) ) { throw new IllegalStateException ( <str> + indexMetaData . getIndex ( ) + <str> ) ; } final String indexName = indexMetaData . getIndex ( ) ; final Predicate < String > indexNameMatcher = ( indexExpression ) - > indexNameExpressionResolver . matchesIndex ( indexName , indexExpression , clusterService . state ( ) ) ; final IndexSettings idxSettings = new IndexSettings ( indexMetaData , this . settings , Collections . emptyList ( ) , indexNameMatcher ) ; Index index = new Index ( indexMetaData . getIndex ( ) ) ; if ( indices . containsKey ( index . name ( ) ) ) { throw new IndexAlreadyExistsException ( index ) ; } logger . debug ( <str> , indexMetaData . getIndex ( ) , idxSettings . getNumberOfShards ( ) , idxSettings . getNumberOfReplicas ( ) , idxSettings . isShadowReplicaIndex ( ) ? <str> : <str> ) ; final IndexModule indexModule = new IndexModule ( idxSettings , indexStoreConfig , analysisRegistry ) ; pluginsService . onIndexModule ( indexModule ) ; for ( IndexEventListener listener : builtInListeners ) { indexModule . addIndexEventListener ( listener ) ; } indexModule . addIndexEventListener ( oldShardsStats ) ; final IndexEventListener listener = indexModule . freeze ( ) ; listener . beforeIndexCreated ( index , idxSettings . getSettings ( ) ) ; final IndexService indexService = indexModule . newIndexService ( nodeEnv , this , nodeServicesProvider , mapperRegistry ) ; boolean success = false ; try { assert indexService . getIndexEventListener ( ) = = listener ; listener . afterIndexCreated ( indexService ) ; indices = newMapBuilder ( indices ) . put ( index . name ( ) , indexService ) . immutableMap ( ) ; success = true ; return indexService ; } finally { if ( success = = false ) { indexService . close ( <str> , true ) ; } } } public void removeIndex ( String index , String reason ) { removeIndex ( index , reason , false ) ; } private void removeIndex ( String index , String reason , boolean delete ) { try { final IndexService indexService ; final IndexEventListener listener ; synchronized ( this ) { if ( indices . containsKey ( index ) = = false ) { return ; } logger . debug ( <str> , index , reason ) ; Map < String , IndexService > newIndices = new HashMap < > ( indices ) ; indexService = newIndices . remove ( index ) ; indices = unmodifiableMap ( newIndices ) ; listener = indexService . getIndexEventListener ( ) ; } listener . beforeIndexClosed ( indexService ) ; if ( delete ) { listener . beforeIndexDeleted ( indexService ) ; } logger . debug ( <str> , index , reason ) ; indexService . close ( reason , delete ) ; logger . debug ( <str> , index , reason ) ; listener . afterIndexClosed ( indexService . index ( ) , indexService . getIndexSettings ( ) . getSettings ( ) ) ; if ( delete ) { final IndexSettings indexSettings = indexService . getIndexSettings ( ) ; listener . afterIndexDeleted ( indexService . index ( ) , indexSettings . getSettings ( ) ) ; deleteIndexStore ( reason , indexService . index ( ) , indexSettings , false ) ; } } catch ( IOException ex ) { throw new ElasticsearchException ( <str> + index , ex ) ; } } static class OldShardsStats implements IndexEventListener { final SearchStats searchStats = new SearchStats ( ) ; final GetStats getStats = new GetStats ( ) ; final IndexingStats indexingStats = new IndexingStats ( ) ; final MergeStats mergeStats = new MergeStats ( ) ; final RefreshStats refreshStats = new RefreshStats ( ) ; final FlushStats flushStats = new FlushStats ( ) ; final RecoveryStats recoveryStats = new RecoveryStats ( ) ; @Override public synchronized void beforeIndexShardClosed ( ShardId shardId , @Nullable IndexShard indexShard , Settings indexSettings ) { if ( indexShard ! = null ) { getStats . addTotals ( indexShard . getStats ( ) ) ; indexingStats . addTotals ( indexShard . indexingStats ( ) ) ; searchStats . addTotals ( indexShard . searchStats ( ) ) ; mergeStats . addTotals ( indexShard . mergeStats ( ) ) ; refreshStats . addTotals ( indexShard . refreshStats ( ) ) ; flushStats . addTotals ( indexShard . flushStats ( ) ) ; recoveryStats . addTotals ( indexShard . recoveryStats ( ) ) ; } } } public void deleteIndex ( String index , String reason ) throws IOException { removeIndex ( index , reason , true ) ; } public void deleteClosedIndex ( String reason , IndexMetaData metaData , ClusterState clusterState ) { if ( nodeEnv . hasNodeFile ( ) ) { String indexName = metaData . getIndex ( ) ; try { if ( clusterState . metaData ( ) . hasIndex ( indexName ) ) { final IndexMetaData index = clusterState . metaData ( ) . index ( indexName ) ; throw new IllegalStateException ( <str> + indexName + <str> + index . getIndexUUID ( ) + <str> + metaData . getIndexUUID ( ) + <str> ) ; } deleteIndexStore ( reason , metaData , clusterState , true ) ; } catch ( IOException e ) { logger . warn ( <str> , e , metaData . getIndex ( ) ) ; } } } public void deleteIndexStore ( String reason , IndexMetaData metaData , ClusterState clusterState , boolean closed ) throws IOException { if ( nodeEnv . hasNodeFile ( ) ) { synchronized ( this ) { String indexName = metaData . getIndex ( ) ; if ( indices . containsKey ( indexName ) ) { String localUUid = indices . get ( indexName ) . indexUUID ( ) ; throw new IllegalStateException ( <str> + indexName + <str> + localUUid + <str> + metaData . getIndexUUID ( ) + <str> ) ; } if ( clusterState . metaData ( ) . hasIndex ( indexName ) & & ( clusterState . nodes ( ) . localNode ( ) . masterNode ( ) = = true ) ) { final IndexMetaData index = clusterState . metaData ( ) . index ( indexName ) ; throw new IllegalStateException ( <str> + indexName + <str> + index . getIndexUUID ( ) + <str> + metaData . getIndexUUID ( ) + <str> ) ; } } Index index = new Index ( metaData . getIndex ( ) ) ; final IndexSettings indexSettings = buildIndexSettings ( metaData ) ; deleteIndexStore ( reason , index , indexSettings , closed ) ; } } private void deleteIndexStore ( String reason , Index index , IndexSettings indexSettings , boolean closed ) throws IOException { boolean success = false ; try { logger . debug ( <str> , index , reason ) ; if ( canDeleteIndexContents ( index , indexSettings , closed ) ) { nodeEnv . deleteIndexDirectorySafe ( index , <int> , indexSettings ) ; } success = true ; } catch ( LockObtainFailedException ex ) { logger . debug ( <str> , ex , index ) ; } catch ( Exception ex ) { logger . warn ( <str> , ex , index ) ; } finally { if ( success = = false ) { addPendingDelete ( index , indexSettings ) ; } MetaDataStateFormat . deleteMetaState ( nodeEnv . indexPaths ( index ) ) ; } } public void deleteShardStore ( String reason , ShardLock lock , IndexSettings indexSettings ) throws IOException { ShardId shardId = lock . getShardId ( ) ; logger . trace ( <str> , shardId , reason ) ; nodeEnv . deleteShardDirectoryUnderLock ( lock , indexSettings ) ; } public void deleteShardStore ( String reason , ShardId shardId , ClusterState clusterState ) throws IOException { final IndexMetaData metaData = clusterState . getMetaData ( ) . indices ( ) . get ( shardId . getIndex ( ) ) ; final IndexSettings indexSettings = buildIndexSettings ( metaData ) ; if ( canDeleteShardContent ( shardId , indexSettings ) = = false ) { throw new IllegalStateException ( <str> + shardId ) ; } nodeEnv . deleteShardDirectorySafe ( shardId , indexSettings ) ; logger . debug ( <str> , shardId , reason ) ; if ( clusterState . nodes ( ) . localNode ( ) . isMasterNode ( ) = = false & & canDeleteIndexContents ( shardId . index ( ) , indexSettings , false ) ) { if ( nodeEnv . findAllShardIds ( shardId . index ( ) ) . isEmpty ( ) ) { try { deleteIndexStore ( <str> , metaData , clusterState , false ) ; } catch ( Exception e ) { throw new ElasticsearchException ( <str> + shardId + <str> , e ) ; } } else { logger . trace ( <str> , shardId . index ( ) ) ; } } } public boolean canDeleteIndexContents ( Index index , IndexSettings indexSettings , boolean closed ) { final IndexService indexService = this . indices . get ( index . name ( ) ) ; if ( indexSettings . isOnSharedFilesystem ( ) = = false | | closed ) { if ( indexService = = null & & nodeEnv . hasNodeFile ( ) ) { return true ; } } else { logger . trace ( <str> , index ) ; } return false ; } public boolean canDeleteShardContent ( ShardId shardId , IndexSettings indexSettings ) { assert shardId . getIndex ( ) . equals ( indexSettings . getIndex ( ) . name ( ) ) ; final IndexService indexService = this . indices . get ( shardId . getIndex ( ) ) ; if ( indexSettings . isOnSharedFilesystem ( ) = = false ) { if ( indexService ! = null & & nodeEnv . hasNodeFile ( ) ) { return indexService . hasShard ( shardId . id ( ) ) = = false ; } else if ( nodeEnv . hasNodeFile ( ) ) { if ( indexSettings . hasCustomDataPath ( ) ) { return Files . exists ( nodeEnv . resolveCustomLocation ( indexSettings , shardId ) ) ; } else { return FileSystemUtils . exists ( nodeEnv . availableShardPaths ( shardId ) ) ; } } } else { logger . trace ( <str> , shardId ) ; } return false ; } private IndexSettings buildIndexSettings ( IndexMetaData metaData ) { return new IndexSettings ( metaData , settings , Collections . emptyList ( ) ) ; } public void addPendingDelete ( ShardId shardId , IndexSettings settings ) { if ( shardId = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( settings = = null ) { throw new IllegalArgumentException ( <str> ) ; } PendingDelete pendingDelete = new PendingDelete ( shardId , settings ) ; addPendingDelete ( shardId . index ( ) , pendingDelete ) ; } public void addPendingDelete ( Index index , IndexSettings settings ) { PendingDelete pendingDelete = new PendingDelete ( index , settings ) ; addPendingDelete ( index , pendingDelete ) ; } private void addPendingDelete ( Index index , PendingDelete pendingDelete ) { synchronized ( pendingDeletes ) { List < PendingDelete > list = pendingDeletes . get ( index ) ; if ( list = = null ) { list = new ArrayList < > ( ) ; pendingDeletes . put ( index , list ) ; } list . add ( pendingDelete ) ; } } private static final class PendingDelete implements Comparable < PendingDelete > { final String index ; final int shardId ; final IndexSettings settings ; final boolean deleteIndex ; public PendingDelete ( ShardId shardId , IndexSettings settings ) { this . index = shardId . getIndex ( ) ; this . shardId = shardId . getId ( ) ; this . settings = settings ; this . deleteIndex = false ; } public PendingDelete ( Index index , IndexSettings settings ) { this . index = index . getName ( ) ; this . shardId = - <int> ; this . settings = settings ; this . deleteIndex = true ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( index ) . append ( <str> ) ; if ( shardId ! = - <int> ) { sb . append ( <str> ) . append ( shardId ) . append ( <str> ) ; } return sb . toString ( ) ; } @Override public int compareTo ( PendingDelete o ) { return Integer . compare ( shardId , o . shardId ) ; } } public void processPendingDeletes ( Index index , IndexSettings indexSettings , TimeValue timeout ) throws IOException , InterruptedException { logger . debug ( <str> , index ) ; final long startTimeNS = System . nanoTime ( ) ; final List < ShardLock > shardLocks = nodeEnv . lockAllForIndex ( index , indexSettings , timeout . millis ( ) ) ; try { Map < ShardId , ShardLock > locks = new HashMap < > ( ) ; for ( ShardLock lock : shardLocks ) { locks . put ( lock . getShardId ( ) , lock ) ; } final List < PendingDelete > remove ; synchronized ( pendingDeletes ) { remove = pendingDeletes . remove ( index ) ; } if ( remove ! = null & & remove . isEmpty ( ) = = false ) { CollectionUtil . timSort ( remove ) ; final long maxSleepTimeMs = <int> * <int> ; long sleepTime = <int> ; do { if ( remove . isEmpty ( ) ) { break ; } Iterator < PendingDelete > iterator = remove . iterator ( ) ; while ( iterator . hasNext ( ) ) { PendingDelete delete = iterator . next ( ) ; if ( delete . deleteIndex ) { assert delete . shardId = = - <int> ; logger . debug ( <str> , index , <str> ) ; try { nodeEnv . deleteIndexDirectoryUnderLock ( index , indexSettings ) ; iterator . remove ( ) ; } catch ( IOException ex ) { logger . debug ( <str> , ex , index ) ; } } else { assert delete . shardId ! = - <int> ; ShardLock shardLock = locks . get ( new ShardId ( delete . index , delete . shardId ) ) ; if ( shardLock ! = null ) { try { deleteShardStore ( <str> , shardLock , delete . settings ) ; iterator . remove ( ) ; } catch ( IOException ex ) { logger . debug ( <str> , ex , shardLock . getShardId ( ) ) ; } } else { logger . warn ( <str> , delete . shardId ) ; iterator . remove ( ) ; } } } if ( remove . isEmpty ( ) = = false ) { logger . warn ( <str> , index , remove . toString ( ) ) ; Thread . sleep ( sleepTime ) ; sleepTime = Math . min ( maxSleepTimeMs , sleepTime * <int> ) ; logger . debug ( <str> , index , sleepTime ) ; } } while ( ( System . nanoTime ( ) - startTimeNS ) < timeout . nanos ( ) ) ; } } finally { IOUtils . close ( shardLocks ) ; } } int numPendingDeletes ( Index index ) { synchronized ( pendingDeletes ) { List < PendingDelete > deleteList = pendingDeletes . get ( index ) ; if ( deleteList = = null ) { return <int> ; } return deleteList . size ( ) ; } } public IndicesQueriesRegistry getIndicesQueryRegistry ( ) { return indicesQueriesRegistry ; } public AnalysisRegistry getAnalysis ( ) { return analysisRegistry ; } } 
