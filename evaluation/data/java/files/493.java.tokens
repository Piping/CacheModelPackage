package rx . internal . operators ; import java . util . Queue ; import java . util . concurrent . atomic . * ; import rx . * ; import rx . exceptions . * ; import rx . functions . * ; import rx . internal . util . atomic . * ; import rx . internal . util . unsafe . * ; import rx . subjects . Subject ; import rx . subscriptions . Subscriptions ; public final class UnicastSubject < T > extends Subject < T , T > { public static < T > UnicastSubject < T > create ( ) { return create ( <int> ) ; } public static < T > UnicastSubject < T > create ( int capacityHint ) { State < T > state = new State < T > ( capacityHint ) ; return new UnicastSubject < T > ( state ) ; } final State < T > state ; private UnicastSubject ( State < T > state ) { super ( state ) ; this . state = state ; } @Override public void onNext ( T t ) { state . onNext ( t ) ; } @Override public void onError ( Throwable e ) { state . onError ( e ) ; } @Override public void onCompleted ( ) { state . onCompleted ( ) ; } @Override public boolean hasObservers ( ) { return state . subscriber . get ( ) ! = null ; } static final class State < T > extends AtomicLong implements Producer , Observer < T > , Action0 , OnSubscribe < T > { private static final long serialVersionUID = - <int> ; final AtomicReference < Subscriber < ? super T > > subscriber ; final Queue < Object > queue ; final NotificationLite < T > nl ; Throwable error ; volatile boolean done ; boolean emitting ; boolean missed ; volatile boolean caughtUp ; public State ( int capacityHint ) { this . nl = NotificationLite . instance ( ) ; this . subscriber = new AtomicReference < Subscriber < ? super T > > ( ) ; Queue < Object > q ; if ( capacityHint > <int> ) { q = UnsafeAccess . isUnsafeAvailable ( ) ? new SpscUnboundedArrayQueue < Object > ( capacityHint ) : new SpscUnboundedAtomicArrayQueue < Object > ( capacityHint ) ; } else { q = UnsafeAccess . isUnsafeAvailable ( ) ? new SpscLinkedQueue < Object > ( ) : new SpscLinkedAtomicQueue < Object > ( ) ; } this . queue = q ; } @Override public void onNext ( T t ) { if ( ! done ) { if ( ! caughtUp ) { boolean stillReplay = false ; synchronized ( this ) { if ( ! caughtUp ) { queue . offer ( nl . next ( t ) ) ; stillReplay = true ; } } if ( stillReplay ) { replay ( ) ; return ; } } Subscriber < ? super T > s = subscriber . get ( ) ; try { s . onNext ( t ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; s . onError ( OnErrorThrowable . addValueAsLastCause ( ex , t ) ) ; } } } @Override public void onError ( Throwable e ) { if ( ! done ) { error = e ; done = true ; if ( ! caughtUp ) { boolean stillReplay = false ; synchronized ( this ) { stillReplay = ! caughtUp ; } if ( stillReplay ) { replay ( ) ; return ; } } subscriber . get ( ) . onError ( e ) ; } } @Override public void onCompleted ( ) { if ( ! done ) { done = true ; if ( ! caughtUp ) { boolean stillReplay = false ; synchronized ( this ) { stillReplay = ! caughtUp ; } if ( stillReplay ) { replay ( ) ; return ; } } subscriber . get ( ) . onCompleted ( ) ; } } @Override public void request ( long n ) { if ( n < <int> ) { throw new IllegalArgumentException ( <str> ) ; } else if ( n > <int> ) { BackpressureUtils . getAndAddRequest ( this , n ) ; replay ( ) ; } else if ( done ) { replay ( ) ; } } @Override public void call ( Subscriber < ? super T > subscriber ) { if ( this . subscriber . compareAndSet ( null , subscriber ) ) { subscriber . add ( Subscriptions . create ( this ) ) ; subscriber . setProducer ( this ) ; } else { subscriber . onError ( new IllegalStateException ( <str> ) ) ; } } void replay ( ) { synchronized ( this ) { if ( emitting ) { missed = true ; return ; } emitting = true ; } Queue < Object > q = queue ; for ( ; ; ) { Subscriber < ? super T > s = subscriber . get ( ) ; boolean unlimited = false ; if ( s ! = null ) { boolean d = done ; boolean empty = q . isEmpty ( ) ; if ( checkTerminated ( d , empty , s ) ) { return ; } long r = get ( ) ; unlimited = r = = Long . MAX_VALUE ; long e = <int> ; while ( r ! = <int> ) { d = done ; Object v = q . poll ( ) ; empty = v = = null ; if ( checkTerminated ( d , empty , s ) ) { return ; } if ( empty ) { break ; } T value = nl . getValue ( v ) ; try { s . onNext ( value ) ; } catch ( Throwable ex ) { q . clear ( ) ; Exceptions . throwIfFatal ( ex ) ; s . onError ( OnErrorThrowable . addValueAsLastCause ( ex , value ) ) ; return ; } r - - ; e + + ; } if ( ! unlimited & & e ! = <int> ) { addAndGet ( - e ) ; } } synchronized ( this ) { if ( ! missed ) { if ( unlimited & & q . isEmpty ( ) ) { caughtUp = true ; } emitting = false ; return ; } missed = false ; } } } @Override public void call ( ) { done = true ; synchronized ( this ) { if ( emitting ) { return ; } emitting = true ; } queue . clear ( ) ; } boolean checkTerminated ( boolean done , boolean empty , Subscriber < ? super T > s ) { if ( s . isUnsubscribed ( ) ) { queue . clear ( ) ; return true ; } if ( done ) { Throwable e = error ; if ( e ! = null ) { queue . clear ( ) ; s . onError ( e ) ; return true ; } else if ( empty ) { s . onCompleted ( ) ; return true ; } } return false ; } } } 
