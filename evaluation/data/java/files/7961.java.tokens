package org . apache . cassandra . stress . operations . userdefined ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import com . datastax . driver . core . BoundStatement ; import com . datastax . driver . core . ColumnDefinitions ; import com . datastax . driver . core . PreparedStatement ; import com . datastax . driver . core . ResultSet ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . stress . Operation ; import org . apache . cassandra . stress . generate . Row ; import org . apache . cassandra . stress . settings . StressSettings ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . stress . util . Timer ; import org . apache . cassandra . thrift . CqlResult ; import org . apache . cassandra . transport . SimpleClient ; public abstract class SchemaStatement extends Operation { final PreparedStatement statement ; final Integer thriftId ; final ConsistencyLevel cl ; final int [ ] argumentIndex ; final Object [ ] bindBuffer ; public SchemaStatement ( Timer timer , StressSettings settings , DataSpec spec , PreparedStatement statement , Integer thriftId , ConsistencyLevel cl ) { super ( timer , settings , spec ) ; this . statement = statement ; this . thriftId = thriftId ; this . cl = cl ; argumentIndex = new int [ statement . getVariables ( ) . size ( ) ] ; bindBuffer = new Object [ argumentIndex . length ] ; int i = <int> ; for ( ColumnDefinitions . Definition definition : statement . getVariables ( ) ) argumentIndex [ i + + ] = spec . partitionGenerator . indexOf ( definition . getName ( ) ) ; statement . setConsistencyLevel ( JavaDriverClient . from ( cl ) ) ; } BoundStatement bindRow ( Row row ) { for ( int i = <int> ; i < argumentIndex . length ; i + + ) { bindBuffer [ i ] = row . get ( argumentIndex [ i ] ) ; if ( bindBuffer [ i ] = = null & & ! spec . partitionGenerator . permitNulls ( argumentIndex [ i ] ) ) throw new IllegalStateException ( ) ; } return statement . bind ( bindBuffer ) ; } List < ByteBuffer > thriftRowArgs ( Row row ) { List < ByteBuffer > args = new ArrayList < > ( ) ; for ( int i : argumentIndex ) args . add ( spec . partitionGenerator . convert ( i , row . get ( i ) ) ) ; return args ; } @Override public void run ( SimpleClient client ) throws IOException { throw new UnsupportedOperationException ( ) ; } abstract class Runner implements RunOp { int partitionCount ; int rowCount ; @Override public int partitionCount ( ) { return partitionCount ; } @Override public int rowCount ( ) { return rowCount ; } } }