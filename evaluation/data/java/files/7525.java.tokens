package org . apache . cassandra . utils . concurrent ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class OpOrder { private static final int FINISHED = - <int> ; private volatile Group current = new Group ( ) ; public Group start ( ) { while ( true ) { Group current = this . current ; if ( current . register ( ) ) return current ; } } public Barrier newBarrier ( ) { return new Barrier ( ) ; } public Group getCurrent ( ) { return current ; } public void awaitNewBarrier ( ) { Barrier barrier = newBarrier ( ) ; barrier . issue ( ) ; barrier . await ( ) ; } public static final class Group implements Comparable < Group > , AutoCloseable { private volatile Group prev , next ; private final long id ; private volatile int running = <int> ; private volatile boolean isBlocking ; private final WaitQueue isBlockingSignal = new WaitQueue ( ) ; private final WaitQueue waiting = new WaitQueue ( ) ; static final AtomicIntegerFieldUpdater < Group > runningUpdater = AtomicIntegerFieldUpdater . newUpdater ( Group . class , <str> ) ; private Group ( ) { this . id = <int> ; } private Group ( Group prev ) { this . id = prev . id + <int> ; this . prev = prev ; } private void expire ( ) { while ( true ) { int current = running ; if ( current < <int> ) throw new IllegalStateException ( ) ; if ( runningUpdater . compareAndSet ( this , current , - <int> - current ) ) { if ( current = = <int> ) unlink ( ) ; return ; } } } private boolean register ( ) { while ( true ) { int current = running ; if ( current < <int> ) return false ; if ( runningUpdater . compareAndSet ( this , current , current + <int> ) ) return true ; } } public void close ( ) { while ( true ) { int current = running ; if ( current < <int> ) { if ( runningUpdater . compareAndSet ( this , current , current + <int> ) ) { if ( current + <int> = = FINISHED ) { unlink ( ) ; } return ; } } else if ( runningUpdater . compareAndSet ( this , current , current - <int> ) ) { return ; } } } private void unlink ( ) { Group start = this ; while ( true ) { Group prev = start . prev ; if ( prev = = null ) break ; if ( prev . running ! = FINISHED ) return ; start = prev ; } Group end = this . next ; while ( end . running = = FINISHED ) end = end . next ; while ( start ! = end ) { Group next = start . next ; next . prev = null ; start . waiting . signalAll ( ) ; start = next ; } } public boolean isBlocking ( ) { return isBlocking ; } public WaitQueue . Signal isBlockingSignal ( ) { return isBlockingSignal . register ( ) ; } public WaitQueue . Signal isBlockingSignal ( WaitQueue . Signal signal ) { return WaitQueue . any ( signal , isBlockingSignal ( ) ) ; } public int compareTo ( Group that ) { long c = this . id - that . id ; if ( c > <int> ) return <int> ; else if ( c < <int> ) return - <int> ; else return <int> ; } } public final class Barrier { private volatile Group orderOnOrBefore ; public boolean isAfter ( Group group ) { if ( orderOnOrBefore = = null ) return true ; return orderOnOrBefore . id - group . id > = <int> ; } public void issue ( ) { if ( orderOnOrBefore ! = null ) throw new IllegalStateException ( <str> ) ; final Group current ; synchronized ( OpOrder . this ) { current = OpOrder . this . current ; orderOnOrBefore = current ; OpOrder . this . current = current . next = new Group ( current ) ; } current . expire ( ) ; } public void markBlocking ( ) { Group current = orderOnOrBefore ; while ( current ! = null ) { current . isBlocking = true ; current . isBlockingSignal . signalAll ( ) ; current = current . prev ; } } public WaitQueue . Signal register ( ) { return orderOnOrBefore . waiting . register ( ) ; } public boolean allPriorOpsAreFinished ( ) { Group current = orderOnOrBefore ; if ( current = = null ) throw new IllegalStateException ( <str> ) ; if ( current . next . prev = = null ) return true ; return false ; } public void await ( ) { while ( ! allPriorOpsAreFinished ( ) ) { WaitQueue . Signal signal = register ( ) ; if ( allPriorOpsAreFinished ( ) ) { signal . cancel ( ) ; return ; } else signal . awaitUninterruptibly ( ) ; } assert orderOnOrBefore . running = = FINISHED ; } public Group getSyncPoint ( ) { return orderOnOrBefore ; } } }