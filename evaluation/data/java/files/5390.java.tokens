package io . netty . handler . codec . http2 ; import static io . netty . buffer . Unpooled . EMPTY_BUFFER ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_MAX_HEADER_SIZE ; import static io . netty . handler . codec . http2 . Http2TestUtil . randomString ; import static io . netty . util . CharsetUtil . UTF_8 ; import static java . lang . Math . min ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyShort ; import static org . mockito . Matchers . eq ; import static org . mockito . Matchers . isA ; import static org . mockito . Mockito . atLeastOnce ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . EmptyByteBuf ; import io . netty . buffer . ReadOnlyByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelPromise ; import io . netty . util . AsciiString ; import io . netty . util . concurrent . EventExecutor ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . util . LinkedList ; import java . util . List ; public class Http2FrameRoundtripTest { private static final byte [ ] MESSAGE = <str> . getBytes ( UTF_8 ) ; private static final int STREAM_ID = <hex> ; private static final int WINDOW_UPDATE = <hex> ; private static final long ERROR_CODE = <hex> L ; @Mock private Http2FrameListener listener ; @Mock private ChannelHandlerContext ctx ; @Mock private EventExecutor executor ; @Mock private Channel channel ; @Mock private ByteBufAllocator alloc ; private Http2FrameWriter writer ; private Http2FrameReader reader ; private List < ByteBuf > needReleasing = new LinkedList < ByteBuf > ( ) ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; when ( ctx . alloc ( ) ) . thenReturn ( alloc ) ; when ( ctx . executor ( ) ) . thenReturn ( executor ) ; when ( ctx . channel ( ) ) . thenReturn ( channel ) ; doAnswer ( new Answer < ByteBuf > ( ) { @Override public ByteBuf answer ( InvocationOnMock in ) throws Throwable { return Unpooled . buffer ( ) ; } } ) . when ( alloc ) . buffer ( ) ; doAnswer ( new Answer < ByteBuf > ( ) { @Override public ByteBuf answer ( InvocationOnMock in ) throws Throwable { return Unpooled . buffer ( ( Integer ) in . getArguments ( ) [ <int> ] ) ; } } ) . when ( alloc ) . buffer ( anyInt ( ) ) ; doAnswer ( new Answer < ChannelPromise > ( ) { @Override public ChannelPromise answer ( InvocationOnMock invocation ) throws Throwable { return new DefaultChannelPromise ( channel ) ; } } ) . when ( ctx ) . newPromise ( ) ; writer = new DefaultHttp2FrameWriter ( ) ; reader = new DefaultHttp2FrameReader ( false ) ; } @After public void teardown ( ) { try { for ( ByteBuf buf : needReleasing ) { buf . release ( ) ; } for ( ByteBuf buf : needReleasing ) { int expectedFinalRefCount = <int> ; if ( buf instanceof ReadOnlyByteBuf | | buf instanceof EmptyByteBuf ) { expectedFinalRefCount = <int> ; } assertEquals ( expectedFinalRefCount , buf . refCnt ( ) ) ; } } finally { needReleasing . clear ( ) ; } } @Test public void emptyDataShouldMatch ( ) throws Exception { final ByteBuf data = EMPTY_BUFFER ; writer . writeData ( ctx , STREAM_ID , data . slice ( ) , <int> , false , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( data ) , eq ( <int> ) , eq ( false ) ) ; } @Test public void dataShouldMatch ( ) throws Exception { final ByteBuf data = data ( <int> ) ; writer . writeData ( ctx , STREAM_ID , data . slice ( ) , <int> , false , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( data ) , eq ( <int> ) , eq ( false ) ) ; } @Test public void dataWithPaddingShouldMatch ( ) throws Exception { final ByteBuf data = data ( <int> ) ; writer . writeData ( ctx , STREAM_ID , data . slice ( ) , <hex> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( data ) , eq ( <hex> ) , eq ( true ) ) ; } @Test public void largeDataFrameShouldMatch ( ) throws Exception { final ByteBuf originalData = data ( <int> * <int> ) ; final int originalPadding = <int> ; final boolean endOfStream = true ; writer . writeData ( ctx , STREAM_ID , originalData . slice ( ) , originalPadding , endOfStream , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener , atLeastOnce ( ) ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , any ( ByteBuf . class ) , anyInt ( ) , eq ( false ) ) ; verify ( listener ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , any ( ByteBuf . class ) , anyInt ( ) , eq ( true ) ) ; ArgumentCaptor < ByteBuf > dataCaptor = ArgumentCaptor . forClass ( ByteBuf . class ) ; ArgumentCaptor < Integer > paddingCaptor = ArgumentCaptor . forClass ( Integer . class ) ; verify ( listener , atLeastOnce ( ) ) . onDataRead ( eq ( ctx ) , eq ( STREAM_ID ) , dataCaptor . capture ( ) , paddingCaptor . capture ( ) , anyBoolean ( ) ) ; for ( ByteBuf chunk : dataCaptor . getAllValues ( ) ) { ByteBuf originalChunk = originalData . readSlice ( chunk . readableBytes ( ) ) ; assertEquals ( originalChunk , chunk ) ; } assertFalse ( originalData . isReadable ( ) ) ; int totalReadPadding = <int> ; for ( int framePadding : paddingCaptor . getAllValues ( ) ) { totalReadPadding + = framePadding ; } assertEquals ( originalPadding , totalReadPadding ) ; } @Test public void emptyHeadersShouldMatch ( ) throws Exception { final Http2Headers headers = EmptyHttp2Headers . INSTANCE ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void emptyHeadersWithPaddingShouldMatch ( ) throws Exception { final Http2Headers headers = EmptyHttp2Headers . INSTANCE ; writer . writeHeaders ( ctx , STREAM_ID , headers , <hex> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <hex> ) , eq ( true ) ) ; } @Test public void binaryHeadersWithoutPriorityShouldMatch ( ) throws Exception { final Http2Headers headers = binaryHeaders ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void headersFrameWithoutPriorityShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void headersFrameWithPriorityShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , ( short ) <int> , true , <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void headersWithPaddingWithoutPriorityShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <hex> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <hex> ) , eq ( true ) ) ; } @Test public void headersWithPaddingWithPriorityShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , ( short ) <int> , true , <hex> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( <hex> ) , eq ( true ) ) ; } @Test public void continuedHeadersShouldMatch ( ) throws Exception { final Http2Headers headers = largeHeaders ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , ( short ) <int> , true , <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void continuedHeadersWithPaddingShouldMatch ( ) throws Exception { final Http2Headers headers = largeHeaders ( ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , ( short ) <int> , true , <hex> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onHeadersRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( <hex> ) , eq ( true ) ) ; } @Test public void headersThatAreTooBigShouldFail ( ) throws Exception { final Http2Headers headers = headersOfSize ( DEFAULT_MAX_HEADER_SIZE + <int> ) ; writer . writeHeaders ( ctx , STREAM_ID , headers , <int> , ( short ) <int> , true , <hex> , true , ctx . newPromise ( ) ) ; try { readFrames ( ) ; fail ( ) ; } catch ( Http2Exception e ) { verify ( listener , never ( ) ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( Http2Headers . class ) , anyInt ( ) , anyShort ( ) , anyBoolean ( ) , anyInt ( ) , anyBoolean ( ) ) ; } } @Test public void emptyPushPromiseShouldMatch ( ) throws Exception { final Http2Headers headers = EmptyHttp2Headers . INSTANCE ; writer . writePushPromise ( ctx , STREAM_ID , <int> , headers , <int> , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPushPromiseRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) ) ; } @Test public void pushPromiseFrameShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writePushPromise ( ctx , STREAM_ID , <int> , headers , <int> , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPushPromiseRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) ) ; } @Test public void pushPromiseWithPaddingShouldMatch ( ) throws Exception { final Http2Headers headers = headers ( ) ; writer . writePushPromise ( ctx , STREAM_ID , <int> , headers , <hex> , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPushPromiseRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( headers ) , eq ( <hex> ) ) ; } @Test public void continuedPushPromiseShouldMatch ( ) throws Exception { final Http2Headers headers = largeHeaders ( ) ; writer . writePushPromise ( ctx , STREAM_ID , <int> , headers , <int> , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPushPromiseRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) ) ; } @Test public void continuedPushPromiseWithPaddingShouldMatch ( ) throws Exception { final Http2Headers headers = largeHeaders ( ) ; writer . writePushPromise ( ctx , STREAM_ID , <int> , headers , <hex> , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPushPromiseRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( headers ) , eq ( <hex> ) ) ; } @Test public void goAwayFrameShouldMatch ( ) throws Exception { final String text = <str> ; final ByteBuf data = buf ( text . getBytes ( ) ) ; writer . writeGoAway ( ctx , STREAM_ID , ERROR_CODE , data . slice ( ) , ctx . newPromise ( ) ) ; readFrames ( ) ; ArgumentCaptor < ByteBuf > captor = ArgumentCaptor . forClass ( ByteBuf . class ) ; verify ( listener ) . onGoAwayRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( ERROR_CODE ) , captor . capture ( ) ) ; assertEquals ( data , captor . getValue ( ) ) ; } @Test public void pingFrameShouldMatch ( ) throws Exception { final ByteBuf data = buf ( <str> . getBytes ( UTF_8 ) ) ; writer . writePing ( ctx , false , data . slice ( ) , ctx . newPromise ( ) ) ; readFrames ( ) ; ArgumentCaptor < ByteBuf > captor = ArgumentCaptor . forClass ( ByteBuf . class ) ; verify ( listener ) . onPingRead ( eq ( ctx ) , captor . capture ( ) ) ; assertEquals ( data , captor . getValue ( ) ) ; } @Test public void pingAckFrameShouldMatch ( ) throws Exception { final ByteBuf data = buf ( <str> . getBytes ( UTF_8 ) ) ; writer . writePing ( ctx , true , data . slice ( ) , ctx . newPromise ( ) ) ; readFrames ( ) ; ArgumentCaptor < ByteBuf > captor = ArgumentCaptor . forClass ( ByteBuf . class ) ; verify ( listener ) . onPingAckRead ( eq ( ctx ) , captor . capture ( ) ) ; assertEquals ( data , captor . getValue ( ) ) ; } @Test public void priorityFrameShouldMatch ( ) throws Exception { writer . writePriority ( ctx , STREAM_ID , <int> , ( short ) <int> , true , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onPriorityRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) ) ; } @Test public void rstStreamFrameShouldMatch ( ) throws Exception { writer . writeRstStream ( ctx , STREAM_ID , ERROR_CODE , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onRstStreamRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( ERROR_CODE ) ) ; } @Test public void emptySettingsFrameShouldMatch ( ) throws Exception { final Http2Settings settings = new Http2Settings ( ) ; writer . writeSettings ( ctx , settings , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onSettingsRead ( eq ( ctx ) , eq ( settings ) ) ; } @Test public void settingsShouldStripShouldMatch ( ) throws Exception { final Http2Settings settings = new Http2Settings ( ) ; settings . pushEnabled ( true ) ; settings . headerTableSize ( <int> ) ; settings . initialWindowSize ( <int> ) ; settings . maxConcurrentStreams ( <int> ) ; writer . writeSettings ( ctx , settings , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onSettingsRead ( eq ( ctx ) , eq ( settings ) ) ; } @Test public void settingsAckShouldMatch ( ) throws Exception { writer . writeSettingsAck ( ctx , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onSettingsAckRead ( eq ( ctx ) ) ; } @Test public void windowUpdateFrameShouldMatch ( ) throws Exception { writer . writeWindowUpdate ( ctx , STREAM_ID , WINDOW_UPDATE , ctx . newPromise ( ) ) ; readFrames ( ) ; verify ( listener ) . onWindowUpdateRead ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( WINDOW_UPDATE ) ) ; } private void readFrames ( ) throws Http2Exception { ByteBuf write = captureWrites ( ) ; reader . readFrame ( ctx , write , listener ) ; } private ByteBuf data ( int size ) { byte [ ] data = new byte [ size ] ; for ( int ix = <int> ; ix < data . length ; ) { int length = min ( MESSAGE . length , data . length - ix ) ; System . arraycopy ( MESSAGE , <int> , data , ix , length ) ; ix + = length ; } return buf ( data ) ; } private ByteBuf buf ( byte [ ] bytes ) { return Unpooled . wrappedBuffer ( bytes ) ; } private < T extends ByteBuf > T releaseLater ( T buf ) { needReleasing . add ( buf ) ; return buf ; } private ByteBuf captureWrites ( ) { ArgumentCaptor < ByteBuf > captor = ArgumentCaptor . forClass ( ByteBuf . class ) ; verify ( ctx , atLeastOnce ( ) ) . write ( captor . capture ( ) , isA ( ChannelPromise . class ) ) ; CompositeByteBuf composite = releaseLater ( Unpooled . compositeBuffer ( ) ) ; for ( ByteBuf buf : captor . getAllValues ( ) ) { buf = releaseLater ( buf . retain ( ) ) ; composite . addComponent ( buf ) ; composite . writerIndex ( composite . writerIndex ( ) + buf . readableBytes ( ) ) ; } return composite ; } private static Http2Headers headers ( ) { return new DefaultHttp2Headers ( false ) . method ( AsciiString . of ( <str> ) ) . scheme ( AsciiString . of ( <str> ) ) . authority ( AsciiString . of ( <str> ) ) . path ( AsciiString . of ( <str> ) ) . add ( randomString ( ) , randomString ( ) ) ; } private static Http2Headers largeHeaders ( ) { DefaultHttp2Headers headers = new DefaultHttp2Headers ( false ) ; for ( int i = <int> ; i < <int> ; + + i ) { String key = <str> + i ; String value = <str> + i ; headers . add ( AsciiString . of ( key ) , AsciiString . of ( value ) ) ; } return headers ; } private Http2Headers headersOfSize ( final int minSize ) { final AsciiString singleByte = new AsciiString ( new byte [ ] { <int> } , false ) ; DefaultHttp2Headers headers = new DefaultHttp2Headers ( false ) ; for ( int size = <int> ; size < minSize ; size + = <int> ) { headers . add ( singleByte , singleByte ) ; } return headers ; } private static Http2Headers binaryHeaders ( ) { DefaultHttp2Headers headers = new DefaultHttp2Headers ( false ) ; for ( int ix = <int> ; ix < <int> ; + + ix ) { headers . add ( randomString ( ) , randomString ( ) ) ; } return headers ; } }