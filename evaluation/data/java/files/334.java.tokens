package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . ObjectArrays . checkElementsNotNull ; import com . google . common . annotations . GwtCompatible ; import java . io . Serializable ; import java . util . AbstractCollection ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) @SuppressWarnings ( <str> ) public abstract class ImmutableCollection < E > extends AbstractCollection < E > implements Serializable { ImmutableCollection ( ) { } @Override public abstract UnmodifiableIterator < E > iterator ( ) ; @Override public final Object [ ] toArray ( ) { int size = size ( ) ; if ( size = = <int> ) { return ObjectArrays . EMPTY_ARRAY ; } Object [ ] result = new Object [ size ] ; copyIntoArray ( result , <int> ) ; return result ; } @Override public final < T > T [ ] toArray ( T [ ] other ) { checkNotNull ( other ) ; int size = size ( ) ; if ( other . length < size ) { other = ObjectArrays . newArray ( other , size ) ; } else if ( other . length > size ) { other [ size ] = null ; } copyIntoArray ( other , <int> ) ; return other ; } @Override public abstract boolean contains ( @Nullable Object object ) ; @Deprecated @Override public final boolean add ( E e ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final boolean remove ( Object object ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final boolean addAll ( Collection < ? extends E > newElements ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final boolean removeAll ( Collection < ? > oldElements ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final boolean retainAll ( Collection < ? > elementsToKeep ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final void clear ( ) { throw new UnsupportedOperationException ( ) ; } private transient ImmutableList < E > asList ; public ImmutableList < E > asList ( ) { ImmutableList < E > list = asList ; return ( list = = null ) ? ( asList = createAsList ( ) ) : list ; } ImmutableList < E > createAsList ( ) { switch ( size ( ) ) { case <int> : return ImmutableList . of ( ) ; case <int> : return ImmutableList . of ( iterator ( ) . next ( ) ) ; default : return new RegularImmutableAsList < E > ( this , toArray ( ) ) ; } } abstract boolean isPartialView ( ) ; int copyIntoArray ( Object [ ] dst , int offset ) { for ( E e : this ) { dst [ offset + + ] = e ; } return offset ; } Object writeReplace ( ) { return new ImmutableList . SerializedForm ( toArray ( ) ) ; } public abstract static class Builder < E > { static final int DEFAULT_INITIAL_CAPACITY = <int> ; static int expandedCapacity ( int oldCapacity , int minCapacity ) { if ( minCapacity < <int> ) { throw new AssertionError ( <str> ) ; } int newCapacity = oldCapacity + ( oldCapacity > > <int> ) + <int> ; if ( newCapacity < minCapacity ) { newCapacity = Integer . highestOneBit ( minCapacity - <int> ) < < <int> ; } if ( newCapacity < <int> ) { newCapacity = Integer . MAX_VALUE ; } return newCapacity ; } Builder ( ) { } public abstract Builder < E > add ( E element ) ; public Builder < E > add ( E . . . elements ) { for ( E element : elements ) { add ( element ) ; } return this ; } public Builder < E > addAll ( Iterable < ? extends E > elements ) { for ( E element : elements ) { add ( element ) ; } return this ; } public Builder < E > addAll ( Iterator < ? extends E > elements ) { while ( elements . hasNext ( ) ) { add ( elements . next ( ) ) ; } return this ; } public abstract ImmutableCollection < E > build ( ) ; } abstract static class ArrayBasedBuilder < E > extends ImmutableCollection . Builder < E > { Object [ ] contents ; int size ; ArrayBasedBuilder ( int initialCapacity ) { checkNonnegative ( initialCapacity , <str> ) ; this . contents = new Object [ initialCapacity ] ; this . size = <int> ; } private void ensureCapacity ( int minCapacity ) { if ( contents . length < minCapacity ) { this . contents = ObjectArrays . arraysCopyOf ( this . contents , expandedCapacity ( contents . length , minCapacity ) ) ; } } @Override public ArrayBasedBuilder < E > add ( E element ) { checkNotNull ( element ) ; ensureCapacity ( size + <int> ) ; contents [ size + + ] = element ; return this ; } @Override public Builder < E > add ( E . . . elements ) { checkElementsNotNull ( elements ) ; ensureCapacity ( size + elements . length ) ; System . arraycopy ( elements , <int> , contents , size , elements . length ) ; size + = elements . length ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { if ( elements instanceof Collection ) { Collection < ? > collection = ( Collection < ? > ) elements ; ensureCapacity ( size + collection . size ( ) ) ; } super . addAll ( elements ) ; return this ; } } } 
