package org . nd4j . linalg . shape . indexing ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . impl . scalar . ScalarAdd ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . indexing . SpecifiedIndex ; import static org . junit . Assert . * ; public class IndexingTestsC extends BaseNd4jTest { public IndexingTestsC ( ) { } public IndexingTestsC ( String name ) { super ( name ) ; } public IndexingTestsC ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public IndexingTestsC ( Nd4jBackend backend ) { super ( backend ) ; } @Test public void testExecSubArray ( ) { INDArray nd = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray sub = nd . get ( NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , <int> ) ) ; Nd4j . getExecutioner ( ) . exec ( new ScalarAdd ( sub , <int> ) ) ; assertEquals ( getFailureMessage ( ) , Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) , sub ) ; } @Test public void testLinearViewElementWiseMatching ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray dup = linspace . dup ( ) ; linspace . addi ( dup ) ; } @Test public void testGetRows ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray testAssertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; INDArray test = arr . get ( new SpecifiedIndex ( <int> , <int> ) , new SpecifiedIndex ( <int> , <int> ) ) ; assertEquals ( testAssertion , test ) ; } @Test public void testFirstColumn ( ) { INDArray arr = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <int> } ) ; INDArray test = arr . get ( NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) ) ; assertEquals ( assertion , test ) ; } @Test public void testMultiRow ( ) { INDArray matrix = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } } ) ; INDArray test = matrix . get ( new SpecifiedIndex ( <int> , <int> ) , NDArrayIndex . interval ( <int> , <int> ) ) ; assertEquals ( assertion , test ) ; } @Test public void testPointIndexes ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> ) ; INDArray get = arr . get ( NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , get . shape ( ) ) ; INDArray linspaced = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } } ) ; INDArray linspacedGet = linspaced . get ( NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) ) ; for ( int i = <int> ; i < linspacedGet . slices ( ) ; i + + ) { INDArray sliceI = linspacedGet . slice ( i ) ; assertEquals ( assertion . slice ( i ) , sliceI ) ; } assertArrayEquals ( new int [ ] { <int> , <int> } , linspacedGet . stride ( ) ) ; assertEquals ( assertion , linspacedGet ) ; } @Test public void testGetWithVariedStride ( ) { int ph = <int> ; int pw = <int> ; int sy = <int> ; int sx = <int> ; int iLim = <int> ; int jLim = <int> ; int i = <int> ; int j = <int> ; INDArray img = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; INDArray padded = Nd4j . pad ( img , new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { ph , ph + sy - <int> } , { pw , pw + sx - <int> } } , Nd4j . PadMode . CONSTANT ) ; INDArray get = padded . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( i , sy , iLim ) , NDArrayIndex . interval ( j , sx , jLim ) ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , get . stride ( ) ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; assertEquals ( assertion , get ) ; i = <int> ; iLim = <int> ; INDArray get3 = padded . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( i , sy , iLim ) , NDArrayIndex . interval ( j , sx , jLim ) ) ; INDArray assertion2 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> , <int> } ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , get3 . stride ( ) ) ; assertEquals ( assertion2 , get3 ) ; i = <int> ; iLim = <int> ; jLim = <int> ; j = <int> ; INDArray get2 = padded . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( i , sy , iLim ) , NDArrayIndex . interval ( j , sx , jLim ) ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , get2 . stride ( ) ) ; assertEquals ( assertion , get2 ) ; } @Test public void testRowVectorInterval ( ) { int len = <int> ; INDArray row = Nd4j . zeros ( len ) ; for ( int i = <int> ; i < len ; i + + ) { row . putScalar ( i , i ) ; } INDArray first10a = row . get ( NDArrayIndex . point ( <int> ) , NDArrayIndex . interval ( <int> , <int> ) ) ; assertArrayEquals ( first10a . shape ( ) , new int [ ] { <int> , <int> } ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( first10a . getDouble ( i ) = = i ) ; INDArray first10b = row . get ( NDArrayIndex . interval ( <int> , <int> ) ) ; assertArrayEquals ( first10b . shape ( ) , new int [ ] { <int> , <int> } ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( first10b . getDouble ( i ) = = i ) ; INDArray last10a = row . get ( NDArrayIndex . point ( <int> ) , NDArrayIndex . interval ( <int> , <int> ) ) ; assertArrayEquals ( last10a . shape ( ) , new int [ ] { <int> , <int> } ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( last10a . getDouble ( i ) = = <int> + i ) ; INDArray last10b = row . get ( NDArrayIndex . interval ( <int> , <int> ) ) ; assertArrayEquals ( last10b . shape ( ) , new int [ ] { <int> , <int> } ) ; for ( int i = <int> ; i < <int> ; i + + ) assertTrue ( last10b . getDouble ( i ) = = <int> + i ) ; } @Override public char ordering ( ) { return <str> ; } } 
