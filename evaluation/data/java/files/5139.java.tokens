package io . netty . channel . epoll ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . EventLoop ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . ServerChannel ; import io . netty . channel . unix . FileDescriptor ; import io . netty . channel . unix . Socket ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; public abstract class AbstractEpollServerChannel extends AbstractEpollChannel implements ServerChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( false , <int> ) ; protected AbstractEpollServerChannel ( int fd ) { this ( new Socket ( fd ) , false ) ; } @Deprecated protected AbstractEpollServerChannel ( FileDescriptor fd ) { this ( new Socket ( fd . intValue ( ) ) ) ; } @Deprecated protected AbstractEpollServerChannel ( Socket fd ) { this ( fd , fd . getSoError ( ) = = <int> ) ; } protected AbstractEpollServerChannel ( Socket fd , boolean active ) { super ( null , fd , Native . EPOLLIN , active ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof EpollEventLoop ; } @Override protected InetSocketAddress remoteAddress0 ( ) { return null ; } @Override protected AbstractEpollUnsafe newUnsafe ( ) { return new EpollServerSocketUnsafe ( ) ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected Object filterOutboundMessage ( Object msg ) throws Exception { throw new UnsupportedOperationException ( ) ; } abstract Channel newChildChannel ( int fd , byte [ ] remote , int offset , int len ) throws Exception ; final class EpollServerSocketUnsafe extends AbstractEpollUnsafe { private final byte [ ] acceptedAddress = new byte [ <int> ] ; @Override public void connect ( SocketAddress socketAddress , SocketAddress socketAddress2 , ChannelPromise channelPromise ) { channelPromise . setFailure ( new UnsupportedOperationException ( ) ) ; } @Override protected EpollRecvByteAllocatorHandle newEpollHandle ( RecvByteBufAllocator . Handle handle ) { return new EpollRecvByteAllocatorMessageHandle ( handle , isFlagSet ( Native . EPOLLET ) ) ; } @Override void epollInReady ( ) { assert eventLoop ( ) . inEventLoop ( ) ; if ( fd ( ) . isInputShutdown ( ) ) { return ; } boolean edgeTriggered = isFlagSet ( Native . EPOLLET ) ; final ChannelConfig config = config ( ) ; if ( ! readPending & & ! edgeTriggered & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; Throwable exception = null ; try { try { do { int socketFd = fd ( ) . accept ( acceptedAddress ) ; if ( socketFd = = - <int> ) { break ; } readPending = false ; allocHandle . incMessagesRead ( <int> ) ; int len = acceptedAddress [ <int> ] ; pipeline . fireChannelRead ( newChildChannel ( socketFd , acceptedAddress , <int> , len ) ) ; } while ( allocHandle . continueReading ( ) ) ; } catch ( Throwable t ) { exception = t ; } allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( exception ! = null ) { pipeline . fireExceptionCaught ( exception ) ; checkResetEpollIn ( edgeTriggered ) ; } } finally { if ( ! readPending & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; } } } } }