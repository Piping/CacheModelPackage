package com . badlogic . gdx . physics . box2d ; import java . util . Iterator ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . JointDef . JointType ; import com . badlogic . gdx . physics . box2d . joints . DistanceJoint ; import com . badlogic . gdx . physics . box2d . joints . DistanceJointDef ; import com . badlogic . gdx . physics . box2d . joints . FrictionJoint ; import com . badlogic . gdx . physics . box2d . joints . FrictionJointDef ; import com . badlogic . gdx . physics . box2d . joints . GearJoint ; import com . badlogic . gdx . physics . box2d . joints . GearJointDef ; import com . badlogic . gdx . physics . box2d . joints . MotorJoint ; import com . badlogic . gdx . physics . box2d . joints . MotorJointDef ; import com . badlogic . gdx . physics . box2d . joints . MouseJoint ; import com . badlogic . gdx . physics . box2d . joints . MouseJointDef ; import com . badlogic . gdx . physics . box2d . joints . PrismaticJoint ; import com . badlogic . gdx . physics . box2d . joints . PrismaticJointDef ; import com . badlogic . gdx . physics . box2d . joints . PulleyJoint ; import com . badlogic . gdx . physics . box2d . joints . PulleyJointDef ; import com . badlogic . gdx . physics . box2d . joints . RevoluteJoint ; import com . badlogic . gdx . physics . box2d . joints . RevoluteJointDef ; import com . badlogic . gdx . physics . box2d . joints . RopeJoint ; import com . badlogic . gdx . physics . box2d . joints . RopeJointDef ; import com . badlogic . gdx . physics . box2d . joints . WeldJoint ; import com . badlogic . gdx . physics . box2d . joints . WeldJointDef ; import com . badlogic . gdx . physics . box2d . joints . WheelJoint ; import com . badlogic . gdx . physics . box2d . joints . WheelJointDef ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . LongMap ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . SharedLibraryLoader ; public final class World implements Disposable { static { new SharedLibraryLoader ( ) . load ( <str> ) ; } protected final Pool < Body > freeBodies = new Pool < Body > ( <int> , <int> ) { @Override protected Body newObject ( ) { return new Body ( World . this , <int> ) ; } } ; protected final Pool < Fixture > freeFixtures = new Pool < Fixture > ( <int> , <int> ) { @Override protected Fixture newObject ( ) { return new Fixture ( null , <int> ) ; } } ; protected final long addr ; protected final LongMap < Body > bodies = new LongMap < Body > ( <int> ) ; protected final LongMap < Fixture > fixtures = new LongMap < Fixture > ( <int> ) ; protected final LongMap < Joint > joints = new LongMap < Joint > ( <int> ) ; protected ContactFilter contactFilter = null ; protected ContactListener contactListener = null ; public World ( Vector2 gravity , boolean doSleep ) { addr = newWorld ( gravity . x , gravity . y , doSleep ) ; contacts . ensureCapacity ( contactAddrs . length ) ; freeContacts . ensureCapacity ( contactAddrs . length ) ; for ( int i = <int> ; i < contactAddrs . length ; i + + ) freeContacts . add ( new Contact ( this , <int> ) ) ; } private native long newWorld ( float gravityX , float gravityY , boolean doSleep ) ; public void setDestructionListener ( DestructionListener listener ) { } public void setContactFilter ( ContactFilter filter ) { this . contactFilter = filter ; setUseDefaultContactFilter ( filter = = null ) ; } private native void setUseDefaultContactFilter ( boolean use ) ; public void setContactListener ( ContactListener listener ) { this . contactListener = listener ; } public Body createBody ( BodyDef def ) { long bodyAddr = jniCreateBody ( addr , def . type . getValue ( ) , def . position . x , def . position . y , def . angle , def . linearVelocity . x , def . linearVelocity . y , def . angularVelocity , def . linearDamping , def . angularDamping , def . allowSleep , def . awake , def . fixedRotation , def . bullet , def . active , def . gravityScale ) ; Body body = freeBodies . obtain ( ) ; body . reset ( bodyAddr ) ; this . bodies . put ( body . addr , body ) ; return body ; } private native long jniCreateBody ( long addr , int type , float positionX , float positionY , float angle , float linearVelocityX , float linearVelocityY , float angularVelocity , float linearDamping , float angularDamping , boolean allowSleep , boolean awake , boolean fixedRotation , boolean bullet , boolean active , float inertiaScale ) ; public void destroyBody ( Body body ) { Array < JointEdge > jointList = body . getJointList ( ) ; while ( jointList . size > <int> ) destroyJoint ( body . getJointList ( ) . get ( <int> ) . joint ) ; jniDestroyBody ( addr , body . addr ) ; body . setUserData ( null ) ; this . bodies . remove ( body . addr ) ; Array < Fixture > fixtureList = body . getFixtureList ( ) ; while ( fixtureList . size > <int> ) { Fixture fixtureToDelete = fixtureList . removeIndex ( <int> ) ; this . fixtures . remove ( fixtureToDelete . addr ) . setUserData ( null ) ; freeFixtures . free ( fixtureToDelete ) ; } freeBodies . free ( body ) ; } private native void jniDestroyBody ( long addr , long bodyAddr ) ; void destroyFixture ( Body body , Fixture fixture ) { jniDestroyFixture ( addr , body . addr , fixture . addr ) ; } private native void jniDestroyFixture ( long addr , long bodyAddr , long fixtureAddr ) ; void deactivateBody ( Body body ) { jniDeactivateBody ( addr , body . addr ) ; } private native void jniDeactivateBody ( long addr , long bodyAddr ) ; public Joint createJoint ( JointDef def ) { long jointAddr = createProperJoint ( def ) ; Joint joint = null ; if ( def . type = = JointType . DistanceJoint ) joint = new DistanceJoint ( this , jointAddr ) ; if ( def . type = = JointType . FrictionJoint ) joint = new FrictionJoint ( this , jointAddr ) ; if ( def . type = = JointType . GearJoint ) joint = new GearJoint ( this , jointAddr , ( ( GearJointDef ) def ) . joint1 , ( ( GearJointDef ) def ) . joint2 ) ; if ( def . type = = JointType . MotorJoint ) joint = new MotorJoint ( this , jointAddr ) ; if ( def . type = = JointType . MouseJoint ) joint = new MouseJoint ( this , jointAddr ) ; if ( def . type = = JointType . PrismaticJoint ) joint = new PrismaticJoint ( this , jointAddr ) ; if ( def . type = = JointType . PulleyJoint ) joint = new PulleyJoint ( this , jointAddr ) ; if ( def . type = = JointType . RevoluteJoint ) joint = new RevoluteJoint ( this , jointAddr ) ; if ( def . type = = JointType . RopeJoint ) joint = new RopeJoint ( this , jointAddr ) ; if ( def . type = = JointType . WeldJoint ) joint = new WeldJoint ( this , jointAddr ) ; if ( def . type = = JointType . WheelJoint ) joint = new WheelJoint ( this , jointAddr ) ; if ( joint ! = null ) joints . put ( joint . addr , joint ) ; JointEdge jointEdgeA = new JointEdge ( def . bodyB , joint ) ; JointEdge jointEdgeB = new JointEdge ( def . bodyA , joint ) ; joint . jointEdgeA = jointEdgeA ; joint . jointEdgeB = jointEdgeB ; def . bodyA . joints . add ( jointEdgeA ) ; def . bodyB . joints . add ( jointEdgeB ) ; return joint ; } private long createProperJoint ( JointDef def ) { if ( def . type = = JointType . DistanceJoint ) { DistanceJointDef d = ( DistanceJointDef ) def ; return jniCreateDistanceJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . length , d . frequencyHz , d . dampingRatio ) ; } if ( def . type = = JointType . FrictionJoint ) { FrictionJointDef d = ( FrictionJointDef ) def ; return jniCreateFrictionJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . maxForce , d . maxTorque ) ; } if ( def . type = = JointType . GearJoint ) { GearJointDef d = ( GearJointDef ) def ; return jniCreateGearJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . joint1 . addr , d . joint2 . addr , d . ratio ) ; } if ( def . type = = JointType . MotorJoint ) { MotorJointDef d = ( MotorJointDef ) def ; return jniCreateMotorJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . linearOffset . x , d . linearOffset . y , d . angularOffset , d . maxForce , d . maxTorque , d . correctionFactor ) ; } if ( def . type = = JointType . MouseJoint ) { MouseJointDef d = ( MouseJointDef ) def ; return jniCreateMouseJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . target . x , d . target . y , d . maxForce , d . frequencyHz , d . dampingRatio ) ; } if ( def . type = = JointType . PrismaticJoint ) { PrismaticJointDef d = ( PrismaticJointDef ) def ; return jniCreatePrismaticJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . localAxisA . x , d . localAxisA . y , d . referenceAngle , d . enableLimit , d . lowerTranslation , d . upperTranslation , d . enableMotor , d . maxMotorForce , d . motorSpeed ) ; } if ( def . type = = JointType . PulleyJoint ) { PulleyJointDef d = ( PulleyJointDef ) def ; return jniCreatePulleyJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . groundAnchorA . x , d . groundAnchorA . y , d . groundAnchorB . x , d . groundAnchorB . y , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . lengthA , d . lengthB , d . ratio ) ; } if ( def . type = = JointType . RevoluteJoint ) { RevoluteJointDef d = ( RevoluteJointDef ) def ; return jniCreateRevoluteJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . referenceAngle , d . enableLimit , d . lowerAngle , d . upperAngle , d . enableMotor , d . motorSpeed , d . maxMotorTorque ) ; } if ( def . type = = JointType . RopeJoint ) { RopeJointDef d = ( RopeJointDef ) def ; return jniCreateRopeJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . maxLength ) ; } if ( def . type = = JointType . WeldJoint ) { WeldJointDef d = ( WeldJointDef ) def ; return jniCreateWeldJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . referenceAngle , d . frequencyHz , d . dampingRatio ) ; } if ( def . type = = JointType . WheelJoint ) { WheelJointDef d = ( WheelJointDef ) def ; return jniCreateWheelJoint ( addr , d . bodyA . addr , d . bodyB . addr , d . collideConnected , d . localAnchorA . x , d . localAnchorA . y , d . localAnchorB . x , d . localAnchorB . y , d . localAxisA . x , d . localAxisA . y , d . enableMotor , d . maxMotorTorque , d . motorSpeed , d . frequencyHz , d . dampingRatio ) ; } return <int> ; } private native long jniCreateWheelJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float localAxisAX , float localAxisAY , boolean enableMotor , float maxMotorTorque , float motorSpeed , float frequencyHz , float dampingRatio ) ; private native long jniCreateRopeJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float maxLength ) ; private native long jniCreateDistanceJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float length , float frequencyHz , float dampingRatio ) ; private native long jniCreateFrictionJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float maxForce , float maxTorque ) ; private native long jniCreateGearJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , long joint1 , long joint2 , float ratio ) ; private native long jniCreateMotorJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float linearOffsetX , float linearOffsetY , float angularOffset , float maxForce , float maxTorque , float correctionFactor ) ; private native long jniCreateMouseJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float targetX , float targetY , float maxForce , float frequencyHz , float dampingRatio ) ; private native long jniCreatePrismaticJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float localAxisAX , float localAxisAY , float referenceAngle , boolean enableLimit , float lowerTranslation , float upperTranslation , boolean enableMotor , float maxMotorForce , float motorSpeed ) ; private native long jniCreatePulleyJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float groundAnchorAX , float groundAnchorAY , float groundAnchorBX , float groundAnchorBY , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float lengthA , float lengthB , float ratio ) ; private native long jniCreateRevoluteJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float referenceAngle , boolean enableLimit , float lowerAngle , float upperAngle , boolean enableMotor , float motorSpeed , float maxMotorTorque ) ; private native long jniCreateWeldJoint ( long addr , long bodyA , long bodyB , boolean collideConnected , float localAnchorAX , float localAnchorAY , float localAnchorBX , float localAnchorBY , float referenceAngle , float frequencyHz , float dampingRatio ) ; public void destroyJoint ( Joint joint ) { joint . setUserData ( null ) ; joints . remove ( joint . addr ) ; joint . jointEdgeA . other . joints . removeValue ( joint . jointEdgeB , true ) ; joint . jointEdgeB . other . joints . removeValue ( joint . jointEdgeA , true ) ; jniDestroyJoint ( addr , joint . addr ) ; } private native void jniDestroyJoint ( long addr , long jointAddr ) ; public void step ( float timeStep , int velocityIterations , int positionIterations ) { jniStep ( addr , timeStep , velocityIterations , positionIterations ) ; } private native void jniStep ( long addr , float timeStep , int velocityIterations , int positionIterations ) ; public void clearForces ( ) { jniClearForces ( addr ) ; } private native void jniClearForces ( long addr ) ; public void setWarmStarting ( boolean flag ) { jniSetWarmStarting ( addr , flag ) ; } private native void jniSetWarmStarting ( long addr , boolean flag ) ; public void setContinuousPhysics ( boolean flag ) { jniSetContiousPhysics ( addr , flag ) ; } private native void jniSetContiousPhysics ( long addr , boolean flag ) ; public int getProxyCount ( ) { return jniGetProxyCount ( addr ) ; } private native int jniGetProxyCount ( long addr ) ; public int getBodyCount ( ) { return jniGetBodyCount ( addr ) ; } private native int jniGetBodyCount ( long addr ) ; public int getFixtureCount ( ) { return fixtures . size ; } public int getJointCount ( ) { return jniGetJointcount ( addr ) ; } private native int jniGetJointcount ( long addr ) ; public int getContactCount ( ) { return jniGetContactCount ( addr ) ; } private native int jniGetContactCount ( long addr ) ; public void setGravity ( Vector2 gravity ) { jniSetGravity ( addr , gravity . x , gravity . y ) ; } private native void jniSetGravity ( long addr , float gravityX , float gravityY ) ; final float [ ] tmpGravity = new float [ <int> ] ; final Vector2 gravity = new Vector2 ( ) ; public Vector2 getGravity ( ) { jniGetGravity ( addr , tmpGravity ) ; gravity . x = tmpGravity [ <int> ] ; gravity . y = tmpGravity [ <int> ] ; return gravity ; } private native void jniGetGravity ( long addr , float [ ] gravity ) ; public boolean isLocked ( ) { return jniIsLocked ( addr ) ; } private native boolean jniIsLocked ( long addr ) ; public void setAutoClearForces ( boolean flag ) { jniSetAutoClearForces ( addr , flag ) ; } private native void jniSetAutoClearForces ( long addr , boolean flag ) ; public boolean getAutoClearForces ( ) { return jniGetAutoClearForces ( addr ) ; } private native boolean jniGetAutoClearForces ( long addr ) ; public void QueryAABB ( QueryCallback callback , float lowerX , float lowerY , float upperX , float upperY ) { queryCallback = callback ; jniQueryAABB ( addr , lowerX , lowerY , upperX , upperY ) ; } private QueryCallback queryCallback = null ; ; private native void jniQueryAABB ( long addr , float lowX , float lowY , float upX , float upY ) ; private long [ ] contactAddrs = new long [ <int> ] ; private final Array < Contact > contacts = new Array < Contact > ( ) ; private final Array < Contact > freeContacts = new Array < Contact > ( ) ; public Array < Contact > getContactList ( ) { int numContacts = getContactCount ( ) ; if ( numContacts > contactAddrs . length ) { int newSize = <int> * numContacts ; contactAddrs = new long [ newSize ] ; contacts . ensureCapacity ( newSize ) ; freeContacts . ensureCapacity ( newSize ) ; } if ( numContacts > freeContacts . size ) { int freeConts = freeContacts . size ; for ( int i = <int> ; i < numContacts - freeConts ; i + + ) freeContacts . add ( new Contact ( this , <int> ) ) ; } jniGetContactList ( addr , contactAddrs ) ; contacts . clear ( ) ; for ( int i = <int> ; i < numContacts ; i + + ) { Contact contact = freeContacts . get ( i ) ; contact . addr = contactAddrs [ i ] ; contacts . add ( contact ) ; } return contacts ; } public void getBodies ( Array < Body > bodies ) { bodies . clear ( ) ; bodies . ensureCapacity ( this . bodies . size ) ; for ( Iterator < Body > iter = this . bodies . values ( ) ; iter . hasNext ( ) ; ) { bodies . add ( iter . next ( ) ) ; } } public void getFixtures ( Array < Fixture > fixtures ) { fixtures . clear ( ) ; fixtures . ensureCapacity ( this . fixtures . size ) ; for ( Iterator < Fixture > iter = this . fixtures . values ( ) ; iter . hasNext ( ) ; ) { fixtures . add ( iter . next ( ) ) ; } } public void getJoints ( Array < Joint > joints ) { joints . clear ( ) ; joints . ensureCapacity ( this . joints . size ) ; for ( Iterator < Joint > iter = this . joints . values ( ) ; iter . hasNext ( ) ; ) { joints . add ( iter . next ( ) ) ; } } private native void jniGetContactList ( long addr , long [ ] contacts ) ; public void dispose ( ) { jniDispose ( addr ) ; } private native void jniDispose ( long addr ) ; private boolean contactFilter ( long fixtureA , long fixtureB ) { if ( contactFilter ! = null ) return contactFilter . shouldCollide ( fixtures . get ( fixtureA ) , fixtures . get ( fixtureB ) ) ; else { Filter filterA = fixtures . get ( fixtureA ) . getFilterData ( ) ; Filter filterB = fixtures . get ( fixtureB ) . getFilterData ( ) ; if ( filterA . groupIndex = = filterB . groupIndex & & filterA . groupIndex ! = <int> ) { return filterA . groupIndex > <int> ; } boolean collide = ( filterA . maskBits & filterB . categoryBits ) ! = <int> & & ( filterA . categoryBits & filterB . maskBits ) ! = <int> ; return collide ; } } private final Contact contact = new Contact ( this , <int> ) ; private final Manifold manifold = new Manifold ( <int> ) ; private final ContactImpulse impulse = new ContactImpulse ( this , <int> ) ; private void beginContact ( long contactAddr ) { contact . addr = contactAddr ; if ( contactListener ! = null ) contactListener . beginContact ( contact ) ; } private void endContact ( long contactAddr ) { contact . addr = contactAddr ; if ( contactListener ! = null ) contactListener . endContact ( contact ) ; } private void preSolve ( long contactAddr , long manifoldAddr ) { contact . addr = contactAddr ; manifold . addr = manifoldAddr ; if ( contactListener ! = null ) contactListener . preSolve ( contact , manifold ) ; } private void postSolve ( long contactAddr , long impulseAddr ) { contact . addr = contactAddr ; impulse . addr = impulseAddr ; if ( contactListener ! = null ) contactListener . postSolve ( contact , impulse ) ; } private boolean reportFixture ( long addr ) { if ( queryCallback ! = null ) return queryCallback . reportFixture ( fixtures . get ( addr ) ) ; else return false ; } public static native void setVelocityThreshold ( float threshold ) ; public static native float getVelocityThreshold ( ) ; public void rayCast ( RayCastCallback callback , Vector2 point1 , Vector2 point2 ) { rayCastCallback = callback ; jniRayCast ( addr , point1 . x , point1 . y , point2 . x , point2 . y ) ; } private RayCastCallback rayCastCallback = null ; private native void jniRayCast ( long addr , float aX , float aY , float bX , float bY ) ; private Vector2 rayPoint = new Vector2 ( ) ; private Vector2 rayNormal = new Vector2 ( ) ; private float reportRayFixture ( long addr , float pX , float pY , float nX , float nY , float fraction ) { if ( rayCastCallback ! = null ) { rayPoint . x = pX ; rayPoint . y = pY ; rayNormal . x = nX ; rayNormal . y = nY ; return rayCastCallback . reportRayFixture ( fixtures . get ( addr ) , rayPoint , rayNormal , fraction ) ; } else { return <float> ; } } }