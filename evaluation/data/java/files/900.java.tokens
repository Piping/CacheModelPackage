package com . google . common . collect ; import static com . google . common . base . Preconditions . checkElementIndex ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import static com . google . common . collect . ObjectArrays . arraysCopyOf ; import static com . google . common . collect . ObjectArrays . checkElementsNotNull ; import static com . google . common . collect . RegularImmutableList . EMPTY ; import com . google . common . annotations . GwtCompatible ; import java . io . InvalidObjectException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . RandomAccess ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) @SuppressWarnings ( <str> ) public abstract class ImmutableList < E > extends ImmutableCollection < E > implements List < E > , RandomAccess { @SuppressWarnings ( <str> ) public static < E > ImmutableList < E > of ( ) { return ( ImmutableList < E > ) EMPTY ; } public static < E > ImmutableList < E > of ( E element ) { return new SingletonImmutableList < E > ( element ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 ) { return construct ( e1 , e2 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 ) { return construct ( e1 , e2 , e3 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 ) { return construct ( e1 , e2 , e3 , e4 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( e1 , e2 , e3 , e4 , e5 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 , E e12 , E . . . others ) { Object [ ] array = new Object [ <int> + others . length ] ; array [ <int> ] = e1 ; array [ <int> ] = e2 ; array [ <int> ] = e3 ; array [ <int> ] = e4 ; array [ <int> ] = e5 ; array [ <int> ] = e6 ; array [ <int> ] = e7 ; array [ <int> ] = e8 ; array [ <int> ] = e9 ; array [ <int> ] = e10 ; array [ <int> ] = e11 ; array [ <int> ] = e12 ; System . arraycopy ( others , <int> , array , <int> , others . length ) ; return construct ( array ) ; } public static < E > ImmutableList < E > copyOf ( Iterable < ? extends E > elements ) { checkNotNull ( elements ) ; return ( elements instanceof Collection ) ? copyOf ( ( Collection < ? extends E > ) elements ) : copyOf ( elements . iterator ( ) ) ; } public static < E > ImmutableList < E > copyOf ( Collection < ? extends E > elements ) { if ( elements instanceof ImmutableCollection ) { @SuppressWarnings ( <str> ) ImmutableList < E > list = ( ( ImmutableCollection < E > ) elements ) . asList ( ) ; return list . isPartialView ( ) ? ImmutableList . < E > asImmutableList ( list . toArray ( ) ) : list ; } return construct ( elements . toArray ( ) ) ; } public static < E > ImmutableList < E > copyOf ( Iterator < ? extends E > elements ) { if ( ! elements . hasNext ( ) ) { return of ( ) ; } E first = elements . next ( ) ; if ( ! elements . hasNext ( ) ) { return of ( first ) ; } else { return new ImmutableList . Builder < E > ( ) . add ( first ) . addAll ( elements ) . build ( ) ; } } public static < E > ImmutableList < E > copyOf ( E [ ] elements ) { switch ( elements . length ) { case <int> : return ImmutableList . of ( ) ; case <int> : return new SingletonImmutableList < E > ( elements [ <int> ] ) ; default : return new RegularImmutableList < E > ( checkElementsNotNull ( elements . clone ( ) ) ) ; } } private static < E > ImmutableList < E > construct ( Object . . . elements ) { return asImmutableList ( checkElementsNotNull ( elements ) ) ; } static < E > ImmutableList < E > asImmutableList ( Object [ ] elements ) { return asImmutableList ( elements , elements . length ) ; } static < E > ImmutableList < E > asImmutableList ( Object [ ] elements , int length ) { switch ( length ) { case <int> : return of ( ) ; case <int> : @SuppressWarnings ( <str> ) ImmutableList < E > list = new SingletonImmutableList < E > ( ( E ) elements [ <int> ] ) ; return list ; default : if ( length < elements . length ) { elements = arraysCopyOf ( elements , length ) ; } return new RegularImmutableList < E > ( elements ) ; } } ImmutableList ( ) { } @Override public UnmodifiableIterator < E > iterator ( ) { return listIterator ( ) ; } @Override public UnmodifiableListIterator < E > listIterator ( ) { return listIterator ( <int> ) ; } @Override public UnmodifiableListIterator < E > listIterator ( int index ) { return new AbstractIndexedListIterator < E > ( size ( ) , index ) { @Override protected E get ( int index ) { return ImmutableList . this . get ( index ) ; } } ; } @Override public int indexOf ( @Nullable Object object ) { return ( object = = null ) ? - <int> : Lists . indexOfImpl ( this , object ) ; } @Override public int lastIndexOf ( @Nullable Object object ) { return ( object = = null ) ? - <int> : Lists . lastIndexOfImpl ( this , object ) ; } @Override public boolean contains ( @Nullable Object object ) { return indexOf ( object ) > = <int> ; } @Override public ImmutableList < E > subList ( int fromIndex , int toIndex ) { checkPositionIndexes ( fromIndex , toIndex , size ( ) ) ; int length = toIndex - fromIndex ; if ( length = = size ( ) ) { return this ; } switch ( length ) { case <int> : return of ( ) ; case <int> : return of ( get ( fromIndex ) ) ; default : return subListUnchecked ( fromIndex , toIndex ) ; } } ImmutableList < E > subListUnchecked ( int fromIndex , int toIndex ) { return new SubList ( fromIndex , toIndex - fromIndex ) ; } class SubList extends ImmutableList < E > { final transient int offset ; final transient int length ; SubList ( int offset , int length ) { this . offset = offset ; this . length = length ; } @Override public int size ( ) { return length ; } @Override public E get ( int index ) { checkElementIndex ( index , length ) ; return ImmutableList . this . get ( index + offset ) ; } @Override public ImmutableList < E > subList ( int fromIndex , int toIndex ) { checkPositionIndexes ( fromIndex , toIndex , length ) ; return ImmutableList . this . subList ( fromIndex + offset , toIndex + offset ) ; } @Override boolean isPartialView ( ) { return true ; } } @Deprecated @Override public final boolean addAll ( int index , Collection < ? extends E > newElements ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final E remove ( int index ) { throw new UnsupportedOperationException ( ) ; } @Override public final ImmutableList < E > asList ( ) { return this ; } @Override int copyIntoArray ( Object [ ] dst , int offset ) { int size = size ( ) ; for ( int i = <int> ; i < size ; i + + ) { dst [ offset + i ] = get ( i ) ; } return offset + size ; } public ImmutableList < E > reverse ( ) { return ( size ( ) < = <int> ) ? this : new ReverseImmutableList < E > ( this ) ; } private static class ReverseImmutableList < E > extends ImmutableList < E > { private final transient ImmutableList < E > forwardList ; ReverseImmutableList ( ImmutableList < E > backingList ) { this . forwardList = backingList ; } private int reverseIndex ( int index ) { return ( size ( ) - <int> ) - index ; } private int reversePosition ( int index ) { return size ( ) - index ; } @Override public ImmutableList < E > reverse ( ) { return forwardList ; } @Override public boolean contains ( @Nullable Object object ) { return forwardList . contains ( object ) ; } @Override public int indexOf ( @Nullable Object object ) { int index = forwardList . lastIndexOf ( object ) ; return ( index > = <int> ) ? reverseIndex ( index ) : - <int> ; } @Override public int lastIndexOf ( @Nullable Object object ) { int index = forwardList . indexOf ( object ) ; return ( index > = <int> ) ? reverseIndex ( index ) : - <int> ; } @Override public ImmutableList < E > subList ( int fromIndex , int toIndex ) { checkPositionIndexes ( fromIndex , toIndex , size ( ) ) ; return forwardList . subList ( reversePosition ( toIndex ) , reversePosition ( fromIndex ) ) . reverse ( ) ; } @Override public E get ( int index ) { checkElementIndex ( index , size ( ) ) ; return forwardList . get ( reverseIndex ( index ) ) ; } @Override public int size ( ) { return forwardList . size ( ) ; } @Override boolean isPartialView ( ) { return forwardList . isPartialView ( ) ; } } @Override public boolean equals ( @Nullable Object obj ) { return Lists . equalsImpl ( this , obj ) ; } @Override public int hashCode ( ) { int hashCode = <int> ; int n = size ( ) ; for ( int i = <int> ; i < n ; i + + ) { hashCode = <int> * hashCode + get ( i ) . hashCode ( ) ; hashCode = ~ ~ hashCode ; } return hashCode ; } static class SerializedForm implements Serializable { final Object [ ] elements ; SerializedForm ( Object [ ] elements ) { this . elements = elements ; } Object readResolve ( ) { return copyOf ( elements ) ; } private static final long serialVersionUID = <int> ; } private void readObject ( ObjectInputStream stream ) throws InvalidObjectException { throw new InvalidObjectException ( <str> ) ; } @Override Object writeReplace ( ) { return new SerializedForm ( toArray ( ) ) ; } public static < E > Builder < E > builder ( ) { return new Builder < E > ( ) ; } public static final class Builder < E > extends ImmutableCollection . ArrayBasedBuilder < E > { public Builder ( ) { this ( DEFAULT_INITIAL_CAPACITY ) ; } Builder ( int capacity ) { super ( capacity ) ; } @Override public Builder < E > add ( E element ) { super . add ( element ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableList < E > build ( ) { return asImmutableList ( contents , size ) ; } } }