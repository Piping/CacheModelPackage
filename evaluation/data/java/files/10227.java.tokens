package com . badlogic . gdx . scenes . scene2d . utils ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener . ChangeEvent ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . OrderedSet ; import com . badlogic . gdx . utils . Pools ; import java . util . Iterator ; public class Selection < T > implements Disableable , Iterable < T > { private Actor actor ; final OrderedSet < T > selected = new OrderedSet ( ) ; private final OrderedSet < T > old = new OrderedSet ( ) ; boolean isDisabled ; private boolean toggle ; boolean multiple ; boolean required ; private boolean programmaticChangeEvents = true ; T lastSelected ; public void setActor ( Actor actor ) { this . actor = actor ; } public void choose ( T item ) { if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( isDisabled ) return ; snapshot ( ) ; try { if ( ( toggle | | ( ! required & & selected . size = = <int> ) | | UIUtils . ctrl ( ) ) & & selected . contains ( item ) ) { if ( required & & selected . size = = <int> ) return ; selected . remove ( item ) ; lastSelected = null ; } else { boolean modified = false ; if ( ! multiple | | ( ! toggle & & ! UIUtils . ctrl ( ) ) ) { if ( selected . size = = <int> & & selected . contains ( item ) ) return ; modified = selected . size > <int> ; selected . clear ( ) ; } if ( ! selected . add ( item ) & & ! modified ) return ; lastSelected = item ; } if ( fireChangeEvent ( ) ) revert ( ) ; } finally { cleanup ( ) ; } } public boolean hasItems ( ) { return selected . size > <int> ; } public boolean isEmpty ( ) { return selected . size = = <int> ; } public int size ( ) { return selected . size ; } public OrderedSet < T > items ( ) { return selected ; } public T first ( ) { return selected . size = = <int> ? null : selected . first ( ) ; } void snapshot ( ) { old . clear ( ) ; old . addAll ( selected ) ; } void revert ( ) { selected . clear ( ) ; selected . addAll ( old ) ; } void cleanup ( ) { old . clear ( <int> ) ; } public void set ( T item ) { if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( selected . size = = <int> & & selected . first ( ) = = item ) return ; snapshot ( ) ; selected . clear ( ) ; selected . add ( item ) ; if ( programmaticChangeEvents & & fireChangeEvent ( ) ) revert ( ) ; else lastSelected = item ; cleanup ( ) ; } public void setAll ( Array < T > items ) { boolean added = false ; snapshot ( ) ; selected . clear ( ) ; for ( int i = <int> , n = items . size ; i < n ; i + + ) { T item = items . get ( i ) ; if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( selected . add ( item ) ) added = true ; } if ( added & & programmaticChangeEvents & & fireChangeEvent ( ) ) revert ( ) ; else lastSelected = items . peek ( ) ; cleanup ( ) ; } public void add ( T item ) { if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( ! selected . add ( item ) ) return ; if ( programmaticChangeEvents & & fireChangeEvent ( ) ) selected . remove ( item ) ; else lastSelected = item ; } public void addAll ( Array < T > items ) { boolean added = false ; snapshot ( ) ; for ( int i = <int> , n = items . size ; i < n ; i + + ) { T item = items . get ( i ) ; if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( selected . add ( item ) ) added = true ; } if ( added & & programmaticChangeEvents & & fireChangeEvent ( ) ) revert ( ) ; else lastSelected = items . peek ( ) ; cleanup ( ) ; } public void remove ( T item ) { if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( ! selected . remove ( item ) ) return ; if ( programmaticChangeEvents & & fireChangeEvent ( ) ) selected . add ( item ) ; else lastSelected = null ; } public void removeAll ( Array < T > items ) { boolean removed = false ; snapshot ( ) ; for ( int i = <int> , n = items . size ; i < n ; i + + ) { T item = items . get ( i ) ; if ( item = = null ) throw new IllegalArgumentException ( <str> ) ; if ( selected . remove ( item ) ) removed = true ; } if ( removed & & programmaticChangeEvents & & fireChangeEvent ( ) ) revert ( ) ; else lastSelected = null ; cleanup ( ) ; } public void clear ( ) { if ( selected . size = = <int> ) return ; snapshot ( ) ; selected . clear ( ) ; if ( programmaticChangeEvents & & fireChangeEvent ( ) ) revert ( ) ; else lastSelected = null ; cleanup ( ) ; } public boolean fireChangeEvent ( ) { if ( actor = = null ) return false ; ChangeEvent changeEvent = Pools . obtain ( ChangeEvent . class ) ; try { return actor . fire ( changeEvent ) ; } finally { Pools . free ( changeEvent ) ; } } public boolean contains ( T item ) { if ( item = = null ) return false ; return selected . contains ( item ) ; } public T getLastSelected ( ) { if ( lastSelected ! = null ) { return lastSelected ; } else if ( selected . size > <int> ) { return selected . first ( ) ; } return null ; } public Iterator < T > iterator ( ) { return selected . iterator ( ) ; } public Array < T > toArray ( ) { return selected . iterator ( ) . toArray ( ) ; } public Array < T > toArray ( Array < T > array ) { return selected . iterator ( ) . toArray ( array ) ; } public void setDisabled ( boolean isDisabled ) { this . isDisabled = isDisabled ; } public boolean isDisabled ( ) { return isDisabled ; } public boolean getToggle ( ) { return toggle ; } public void setToggle ( boolean toggle ) { this . toggle = toggle ; } public boolean getMultiple ( ) { return multiple ; } public void setMultiple ( boolean multiple ) { this . multiple = multiple ; } public boolean getRequired ( ) { return required ; } public void setRequired ( boolean required ) { this . required = required ; } public void setProgrammaticChangeEvents ( boolean programmaticChangeEvents ) { this . programmaticChangeEvents = programmaticChangeEvents ; } public String toString ( ) { return selected . toString ( ) ; } }