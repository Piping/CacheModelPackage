package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . utils . Array ; public class ButtonGroup < T extends Button > { private final Array < T > buttons = new Array ( ) ; private Array < T > checkedButtons = new Array ( <int> ) ; private int minCheckCount , maxCheckCount = <int> ; private boolean uncheckLast = true ; private T lastChecked ; public ButtonGroup ( ) { minCheckCount = <int> ; } public ButtonGroup ( T . . . buttons ) { minCheckCount = <int> ; add ( buttons ) ; minCheckCount = <int> ; } public void add ( T button ) { if ( button = = null ) throw new IllegalArgumentException ( <str> ) ; button . buttonGroup = null ; boolean shouldCheck = button . isChecked ( ) | | buttons . size < minCheckCount ; button . setChecked ( false ) ; button . buttonGroup = this ; buttons . add ( button ) ; button . setChecked ( shouldCheck ) ; } public void add ( T . . . buttons ) { if ( buttons = = null ) throw new IllegalArgumentException ( <str> ) ; for ( int i = <int> , n = buttons . length ; i < n ; i + + ) add ( buttons [ i ] ) ; } public void remove ( T button ) { if ( button = = null ) throw new IllegalArgumentException ( <str> ) ; button . buttonGroup = null ; buttons . removeValue ( button , true ) ; checkedButtons . removeValue ( button , true ) ; } public void remove ( T . . . buttons ) { if ( buttons = = null ) throw new IllegalArgumentException ( <str> ) ; for ( int i = <int> , n = buttons . length ; i < n ; i + + ) remove ( buttons [ i ] ) ; } public void clear ( ) { buttons . clear ( ) ; checkedButtons . clear ( ) ; } public void setChecked ( String text ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; for ( int i = <int> , n = buttons . size ; i < n ; i + + ) { T button = buttons . get ( i ) ; if ( button instanceof TextButton & & text . contentEquals ( ( ( TextButton ) button ) . getText ( ) ) ) { button . setChecked ( true ) ; return ; } } } protected boolean canCheck ( T button , boolean newState ) { if ( button . isChecked = = newState ) return false ; if ( ! newState ) { if ( checkedButtons . size < = minCheckCount ) return false ; checkedButtons . removeValue ( button , true ) ; } else { if ( maxCheckCount ! = - <int> & & checkedButtons . size > = maxCheckCount ) { if ( uncheckLast ) { int old = minCheckCount ; minCheckCount = <int> ; lastChecked . setChecked ( false ) ; minCheckCount = old ; } else return false ; } checkedButtons . add ( button ) ; lastChecked = button ; } return true ; } public void uncheckAll ( ) { int old = minCheckCount ; minCheckCount = <int> ; for ( int i = <int> , n = buttons . size ; i < n ; i + + ) { T button = buttons . get ( i ) ; button . setChecked ( false ) ; } minCheckCount = old ; } public T getChecked ( ) { if ( checkedButtons . size > <int> ) return checkedButtons . get ( <int> ) ; return null ; } public int getCheckedIndex ( ) { if ( checkedButtons . size > <int> ) return buttons . indexOf ( checkedButtons . get ( <int> ) , true ) ; return - <int> ; } public Array < T > getAllChecked ( ) { return checkedButtons ; } public Array < T > getButtons ( ) { return buttons ; } public void setMinCheckCount ( int minCheckCount ) { this . minCheckCount = minCheckCount ; } public void setMaxCheckCount ( int maxCheckCount ) { if ( maxCheckCount = = <int> ) maxCheckCount = - <int> ; this . maxCheckCount = maxCheckCount ; } public void setUncheckLast ( boolean uncheckLast ) { this . uncheckLast = uncheckLast ; } } 
