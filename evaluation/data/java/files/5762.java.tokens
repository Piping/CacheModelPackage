package rx . observables ; import static org . junit . Assert . assertEquals ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . Mock ; import org . mockito . runners . MockitoJUnitRunner ; import rx . Observable ; import rx . Observable . OnSubscribe ; import rx . Observer ; import rx . Subscription ; import rx . exceptions . TestException ; import rx . functions . Action0 ; import rx . functions . Action1 ; import rx . functions . Action2 ; import rx . functions . Func0 ; import rx . functions . Func3 ; import rx . internal . util . RxRingBuffer ; import rx . observers . TestSubscriber ; import rx . schedulers . TestScheduler ; @RunWith ( MockitoJUnitRunner . class ) public class AsyncOnSubscribeTest { @Mock public Observer < Integer > o ; TestSubscriber < Integer > subscriber ; @Before public void setup ( ) { subscriber = new TestSubscriber < Integer > ( o , <int> ) ; } @Test public void testSerializesConcurrentObservables ( ) throws InterruptedException { final TestScheduler scheduler = new TestScheduler ( ) ; OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { if ( state = = <int> ) { Observable < Integer > o1 = Observable . just ( <int> , <int> , <int> , <int> ) . delay ( <int> , TimeUnit . MILLISECONDS , scheduler ) ; observer . onNext ( o1 ) ; } else if ( state = = <int> ) { Observable < Integer > o = Observable . just ( <int> , <int> , <int> , <int> ) ; observer . onNext ( o ) ; } else observer . onCompleted ( ) ; return state + <int> ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValues ( <int> , <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValues ( <int> , <int> , <int> , <int> , <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValues ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; subscriber . assertCompleted ( ) ; } @Test public void testSubscribedByBufferingOperator ( ) { final TestScheduler scheduler = new TestScheduler ( ) ; OnSubscribe < Integer > os = AsyncOnSubscribe . createStateless ( new Action2 < Long , Observer < Observable < ? extends Integer > > > ( ) { @Override public void call ( Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onNext ( Observable . range ( <int> , requested . intValue ( ) ) ) ; } } ) ; Observable . create ( os ) . observeOn ( scheduler ) . subscribe ( subscriber ) ; subscriber . requestMore ( RxRingBuffer . SIZE ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . DAYS ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValueCount ( RxRingBuffer . SIZE ) ; subscriber . assertNotCompleted ( ) ; } @Test public void testOnUnsubscribeHasCorrectState ( ) throws InterruptedException { final AtomicInteger lastState = new AtomicInteger ( - <int> ) ; OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { if ( state < <int> ) { observer . onNext ( Observable . just ( state ) ) ; } else observer . onCompleted ( ) ; return state + <int> ; } } , new Action1 < Integer > ( ) { @Override public void call ( Integer t ) { lastState . set ( t ) ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertReceivedOnNext ( Arrays . asList ( new Integer [ ] { <int> , <int> } ) ) ; subscriber . assertCompleted ( ) ; assertEquals ( <str> , <int> , lastState . get ( ) ) ; } @Test public void testOnCompleteOuter ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateless ( new Action2 < Long , Observer < Observable < ? extends Integer > > > ( ) { @Override public void call ( Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onCompleted ( ) ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testTryOnNextTwice ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateless ( new Action2 < Long , Observer < Observable < ? extends Integer > > > ( ) { @Override public void call ( Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onNext ( Observable . just ( <int> ) ) ; observer . onNext ( Observable . just ( <int> ) ) ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertError ( IllegalStateException . class ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertReceivedOnNext ( Arrays . asList ( new Integer [ ] { <int> } ) ) ; } @Test public void testThrowException ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateless ( new Action2 < Long , Observer < Observable < ? extends Integer > > > ( ) { @Override public void call ( Long requested , Observer < Observable < ? extends Integer > > observer ) { throw new TestException ( ) ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertError ( TestException . class ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testThrowExceptionAfterTerminal ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onCompleted ( ) ; throw new TestException ( ) ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testOnNextAfterCompleted ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onCompleted ( ) ; observer . onNext ( Observable . just ( <int> ) ) ; return <int> ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testOnNextAfterError ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onError ( new TestException ( ) ) ; observer . onNext ( Observable . just ( <int> ) ) ; return <int> ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertError ( TestException . class ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testEmittingEmptyObservable ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onNext ( Observable . < Integer > empty ( ) ) ; observer . onCompleted ( ) ; return state ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testOnErrorOuter ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onError ( new TestException ( ) ) ; return state ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertError ( TestException . class ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testOnCompleteFollowedByOnErrorOuter ( ) throws InterruptedException { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { observer . onCompleted ( ) ; observer . onError ( new TestException ( ) ) ; return state ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertCompleted ( ) ; subscriber . assertNoErrors ( ) ; subscriber . assertNoValues ( ) ; } @Test public void testUnsubscribesFromAllSelfTerminatedObservables ( ) throws InterruptedException { final AtomicInteger l1 = new AtomicInteger ( ) ; final AtomicInteger l2 = new AtomicInteger ( ) ; OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { Observable < Integer > o1 ; switch ( state ) { case <int> : o1 = Observable . just ( <int> ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { l1 . incrementAndGet ( ) ; } } ) ; break ; case <int> : o1 = Observable . just ( <int> ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { l2 . incrementAndGet ( ) ; } } ) ; break ; default : observer . onCompleted ( ) ; return null ; } observer . onNext ( o1 ) ; return state + <int> ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . awaitTerminalEventAndUnsubscribeOnTimeout ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( <str> , <int> , l1 . get ( ) ) ; assertEquals ( <str> , <int> , l2 . get ( ) ) ; List < Integer > onNextEvents = subscriber . getOnNextEvents ( ) ; assertEquals ( <int> , onNextEvents . size ( ) ) ; assertEquals ( new Integer ( <int> ) , onNextEvents . get ( <int> ) ) ; assertEquals ( new Integer ( <int> ) , onNextEvents . get ( <int> ) ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; } @Test public void testUnsubscribesFromAllNonTerminatedObservables ( ) throws InterruptedException { final AtomicInteger l1 = new AtomicInteger ( ) ; final AtomicInteger l2 = new AtomicInteger ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final AtomicReference < Subscription > sub = new AtomicReference < Subscription > ( ) ; OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { switch ( state ) { case <int> : observer . onNext ( Observable . range ( <int> , requested . intValue ( ) ) . subscribeOn ( scheduler ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { l1 . incrementAndGet ( ) ; } } ) ) ; break ; case <int> : observer . onNext ( Observable . < Integer > never ( ) . subscribeOn ( scheduler ) . doOnUnsubscribe ( new Action0 ( ) { @Override public void call ( ) { l2 . incrementAndGet ( ) ; } } ) ) ; break ; case <int> : sub . get ( ) . unsubscribe ( ) ; } return state + <int> ; } } ) ; Subscription subscription = Observable . create ( os ) . observeOn ( scheduler ) . subscribe ( subscriber ) ; sub . set ( subscription ) ; subscriber . assertNoValues ( ) ; subscriber . requestMore ( <int> ) ; scheduler . triggerActions ( ) ; subscriber . requestMore ( <int> ) ; scheduler . triggerActions ( ) ; subscriber . assertValueCount ( <int> ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertNoErrors ( ) ; assertEquals ( <str> , <int> , l1 . get ( ) ) ; assertEquals ( <str> , <int> , l2 . get ( ) ) ; } private static class Foo { } private static class Bar extends Foo { } @Test public void testGenerics ( ) { AsyncOnSubscribe . createStateless ( new Action2 < Long , Observer < Observable < ? extends Foo > > > ( ) { @Override public void call ( Long state , Observer < Observable < ? extends Foo > > observer ) { if ( state = = null ) observer . onNext ( Observable . just ( new Foo ( ) ) ) ; else observer . onNext ( Observable . just ( new Bar ( ) ) ) ; } } ) ; } @Test public void testUnderdeliveryCorrection ( ) { OnSubscribe < Integer > os = AsyncOnSubscribe . createStateful ( new Func0 < Integer > ( ) { @Override public Integer call ( ) { return <int> ; } } , new Func3 < Integer , Long , Observer < Observable < ? extends Integer > > , Integer > ( ) { @Override public Integer call ( Integer state , Long requested , Observer < Observable < ? extends Integer > > observer ) { switch ( state ) { case <int> : observer . onNext ( Observable . just ( <int> ) ) ; break ; default : observer . onNext ( Observable . range ( <int> , requested . intValue ( ) ) ) ; break ; } return state + <int> ; } } ) ; Observable . create ( os ) . subscribe ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertNotCompleted ( ) ; subscriber . assertNoValues ( ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValueCount ( <int> ) ; subscriber . requestMore ( <int> ) ; subscriber . assertNoErrors ( ) ; subscriber . assertValueCount ( <int> ) ; subscriber . assertNotCompleted ( ) ; } }