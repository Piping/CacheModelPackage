package org . elasticsearch . gateway ; import org . elasticsearch . action . admin . indices . recovery . RecoveryResponse ; import org . elasticsearch . action . admin . indices . stats . IndexStats ; import org . elasticsearch . action . admin . indices . stats . ShardStats ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . ThrottlingAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . indices . flush . SyncedFlushUtil ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster . RestartCallback ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . store . MockFSDirectoryService ; import org . elasticsearch . test . store . MockFSIndexStore ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . notNullValue ; @ClusterScope ( numDataNodes = <int> , scope = Scope . TEST ) public class RecoveryFromGatewayIT extends ESIntegTestCase { public void testOneNodeRecoverFromGateway ( ) throws Exception { internalCluster ( ) . startNode ( ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , mapping ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . execute ( ) . actionGet ( ) , <int> ) ; ensureYellow ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . execute ( ) . actionGet ( ) , <int> ) ; internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . execute ( ) . actionGet ( ) , <int> ) ; } public void testSingleNodeNoFlush ( ) throws Exception { internalCluster ( ) . startNode ( ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; int numberOfShards = numberOfShards ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , numberOfShards ( ) , SETTING_NUMBER_OF_REPLICAS , randomIntBetween ( <int> , <int> ) ) . addMapping ( <str> , mapping ) ) ; int value1Docs ; int value2Docs ; boolean indexToAllShards = randomBoolean ( ) ; if ( indexToAllShards ) { value1Docs = randomIntBetween ( numberOfShards * <int> , numberOfShards * <int> ) ; value2Docs = randomIntBetween ( numberOfShards * <int> , numberOfShards * <int> ) ; } else { value1Docs = <int> ; value2Docs = <int> ; } for ( int i = <int> ; i < <int> + randomInt ( <int> ) ; i + + ) { for ( int id = <int> ; id < Math . max ( value1Docs , value2Docs ) ; id + + ) { if ( id < value1Docs ) { index ( <str> , <str> , <str> + id , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <int> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) ; } if ( id < value2Docs ) { index ( <str> , <str> , <str> + id , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <int> ) . endArray ( ) . endObject ( ) ) ; } } } refresh ( ) ; for ( int i = <int> ; i < = randomInt ( <int> ) ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , value1Docs + value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value1Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . get ( ) , value1Docs ) ; } if ( ! indexToAllShards ) { logger . info ( <str> ) ; ensureYellow ( ) ; } internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; for ( int i = <int> ; i < = randomInt ( <int> ) ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , value1Docs + value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value1Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . get ( ) , value1Docs ) ; } internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; for ( int i = <int> ; i < = randomInt ( <int> ) ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , value1Docs + value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value1Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <str> ) ) . get ( ) , value2Docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( termQuery ( <str> , <int> ) ) . get ( ) , value1Docs ) ; } } public void testSingleNodeWithFlush ( ) throws Exception { internalCluster ( ) . startNode ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; flush ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; ensureYellow ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } } public void testTwoNodeFirstNodeCleared ( ) throws Exception { final String firstNode = internalCluster ( ) . startNode ( ) ; internalCluster ( ) . startNode ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; flush ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; refresh ( ) ; logger . info ( <str> ) ; ensureGreen ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } internalCluster ( ) . fullRestart ( new RestartCallback ( ) { @Override public Settings onNodeStopped ( String nodeName ) throws Exception { return settingsBuilder ( ) . put ( <str> , <int> ) . build ( ) ; } @Override public boolean clearData ( String nodeName ) { return firstNode . equals ( nodeName ) ; } } ) ; logger . info ( <str> ) ; ensureGreen ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } } public void testLatestVersionLoaded ( ) throws Exception { internalCluster ( ) . startNodesAsync ( <int> , settingsBuilder ( ) . put ( <str> , <int> ) . build ( ) ) . get ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; ensureGreen ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } String metaDataUuid = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . get ( ) . getState ( ) . getMetaData ( ) . clusterUUID ( ) ; assertThat ( metaDataUuid , not ( equalTo ( <str> ) ) ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( new RestartCallback ( ) { @Override public void doAfterNodes ( int numNodes , Client client ) throws Exception { if ( numNodes = = <int> ) { logger . info ( <str> ) ; client . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForYellowStatus ( ) . get ( ) ; client . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } logger . info ( <str> ) ; client . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client . admin ( ) . indices ( ) . preparePutTemplate ( <str> ) . setTemplate ( <str> ) . setOrder ( <int> ) . addMapping ( <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; client . admin ( ) . indices ( ) . prepareAliases ( ) . addAlias ( <str> , <str> , QueryBuilders . termQuery ( <str> , <str> ) ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; } } } ) ; logger . info ( <str> ) ; ensureGreen ( ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . get ( ) . getState ( ) . getMetaData ( ) . clusterUUID ( ) , equalTo ( metaDataUuid ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . metaData ( ) . index ( <str> ) . mapping ( <str> ) , notNullValue ( ) ) ; assertThat ( state . metaData ( ) . templates ( ) . get ( <str> ) . template ( ) , equalTo ( <str> ) ) ; assertThat ( state . metaData ( ) . index ( <str> ) . getAliases ( ) . get ( <str> ) , notNullValue ( ) ) ; assertThat ( state . metaData ( ) . index ( <str> ) . getAliases ( ) . get ( <str> ) . filter ( ) , notNullValue ( ) ) ; } @TestLogging ( <str> ) public void testReusePeerRecovery ( ) throws Exception { final Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( MockFSIndexStore . CHECK_INDEX_ON_CLOSE , false ) . put ( <str> , <int> ) . put ( ThrottlingAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES , <int> ) . put ( MockFSDirectoryService . CRASH_INDEX , false ) . build ( ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; if ( ( i % <int> ) = = <int> ) { client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; } } if ( randomBoolean ( ) ) { client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; } logger . info ( <str> ) ; ensureGreen ( ) ; client ( ) . admin ( ) . indices ( ) . prepareForceMerge ( <str> ) . setMaxNumSegments ( <int> ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . setWaitIfOngoing ( true ) . setForce ( true ) . get ( ) ; boolean useSyncIds = randomBoolean ( ) ; if ( useSyncIds = = false ) { logger . info ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , EnableAllocationDecider . Allocation . NONE ) ) . get ( ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> ) ; ensureGreen ( ) ; } else { logger . info ( <str> ) ; assertEquals ( SyncedFlushUtil . attemptSyncedFlush ( internalCluster ( ) , <str> ) . failedShards ( ) , <int> ) ; assertSyncIdsNotNull ( ) ; } logger . info ( <str> , useSyncIds ? <str> : <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , EnableAllocationDecider . Allocation . NONE ) ) . get ( ) ; logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; logger . info ( <str> , useSyncIds ? <str> : <str> ) ; ensureGreen ( ) ; if ( useSyncIds ) { assertSyncIdsNotNull ( ) ; } RecoveryResponse recoveryResponse = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) ; for ( RecoveryState recoveryState : recoveryResponse . shardRecoveryStates ( ) . get ( <str> ) ) { long recovered = <int> ; for ( RecoveryState . File file : recoveryState . getIndex ( ) . fileDetails ( ) ) { if ( file . name ( ) . startsWith ( <str> ) ) { recovered + = file . length ( ) ; } } if ( ! recoveryState . getPrimary ( ) & & ( useSyncIds = = false ) ) { logger . info ( <str> , recoveryState . getShardId ( ) . getId ( ) , recoveryState . getSourceNode ( ) . name ( ) , recoveryState . getTargetNode ( ) . name ( ) , recoveryState . getIndex ( ) . recoveredBytes ( ) , recoveryState . getIndex ( ) . reusedBytes ( ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . recoveredBytes ( ) , equalTo ( recovered ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . reusedBytes ( ) , greaterThan ( <int> l ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . reusedBytes ( ) , equalTo ( recoveryState . getIndex ( ) . totalBytes ( ) - recovered ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . recoveredFileCount ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . reusedFileCount ( ) , equalTo ( recoveryState . getIndex ( ) . totalFileCount ( ) - <int> ) ) ; assertThat ( <str> , recoveryState . getIndex ( ) . reusedFileCount ( ) , greaterThan ( <int> ) ) ; } else { if ( useSyncIds & & ! recoveryState . getPrimary ( ) ) { logger . info ( <str> , recoveryState . getShardId ( ) . getId ( ) , recoveryState . getSourceNode ( ) . name ( ) , recoveryState . getTargetNode ( ) . name ( ) , recoveryState . getIndex ( ) . recoveredBytes ( ) , recoveryState . getIndex ( ) . reusedBytes ( ) ) ; } assertThat ( recoveryState . getIndex ( ) . recoveredBytes ( ) , equalTo ( <int> l ) ) ; assertThat ( recoveryState . getIndex ( ) . reusedBytes ( ) , equalTo ( recoveryState . getIndex ( ) . totalBytes ( ) ) ) ; assertThat ( recoveryState . getIndex ( ) . recoveredFileCount ( ) , equalTo ( <int> ) ) ; assertThat ( recoveryState . getIndex ( ) . reusedFileCount ( ) , equalTo ( recoveryState . getIndex ( ) . totalFileCount ( ) ) ) ; } } } public void assertSyncIdsNotNull ( ) { IndexStats indexStats = client ( ) . admin ( ) . indices ( ) . prepareStats ( <str> ) . get ( ) . getIndex ( <str> ) ; for ( ShardStats shardStats : indexStats . getShards ( ) ) { assertNotNull ( shardStats . getCommitStats ( ) . getUserData ( ) . get ( Engine . SYNC_COMMIT_ID ) ) ; } } public void testRecoveryDifferentNodeOrderStartup ( ) throws Exception { final String node_1 = internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , createTempDir ( ) ) . build ( ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , createTempDir ( ) ) . build ( ) ) ; ensureGreen ( ) ; internalCluster ( ) . fullRestart ( new RestartCallback ( ) { @Override public boolean doRestart ( String nodeName ) { return ! node_1 . equals ( nodeName ) ; } } ) ; ensureYellow ( ) ; assertThat ( client ( ) . admin ( ) . indices ( ) . prepareExists ( <str> ) . execute ( ) . actionGet ( ) . isExists ( ) , equalTo ( true ) ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } } 
