package rx . internal . operators ; import static org . junit . Assert . * ; import static org . mockito . Matchers . * ; import static org . mockito . Mockito . * ; import java . util . * ; import org . junit . Test ; import org . mockito . InOrder ; import rx . Observable ; import rx . Observer ; import rx . exceptions . TestException ; import rx . functions . Func2 ; import rx . observers . TestSubscriber ; import rx . subjects . PublishSubject ; public class OperatorWithLatestFromTest { static final Func2 < Integer , Integer , Integer > COMBINER = new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return ( t1 < < <int> ) + t2 ; } } ; static final Func2 < Integer , Integer , Integer > COMBINER_ERROR = new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { throw new TestException ( <str> ) ; } } ; @Test public void testSimple ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > o = mock ( Observer . class ) ; InOrder inOrder = inOrder ( o ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; result . subscribe ( o ) ; source . onNext ( <int> ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; other . onNext ( <int> ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; source . onNext ( <int> ) ; inOrder . verify ( o ) . onNext ( ( <int> < < <int> ) + <int> ) ; other . onNext ( <int> ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; other . onCompleted ( ) ; inOrder . verify ( o , never ( ) ) . onCompleted ( ) ; source . onNext ( <int> ) ; inOrder . verify ( o ) . onNext ( ( <int> < < <int> ) + <int> ) ; source . onCompleted ( ) ; inOrder . verify ( o ) . onCompleted ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testEmptySource ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( <int> ) ; source . onCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertTerminalEvent ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testEmptyOther ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; source . onNext ( <int> ) ; source . onCompleted ( ) ; ts . assertNoErrors ( ) ; ts . assertTerminalEvent ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testUnsubscription ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( <int> ) ; source . onNext ( <int> ) ; ts . unsubscribe ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( ( <int> < < <int> ) + <int> ) ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnCompletedEvents ( ) . size ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testSourceThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( <int> ) ; source . onNext ( <int> ) ; source . onError ( new TestException ( ) ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( ( <int> < < <int> ) + <int> ) ) ; assertEquals ( <int> , ts . getOnErrorEvents ( ) . size ( ) ) ; assertTrue ( ts . getOnErrorEvents ( ) . get ( <int> ) instanceof TestException ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testOtherThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( <int> ) ; source . onNext ( <int> ) ; other . onError ( new TestException ( ) ) ; ts . assertTerminalEvent ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( ( <int> < < <int> ) + <int> ) ) ; assertEquals ( <int> , ts . getOnErrorEvents ( ) . size ( ) ) ; assertTrue ( ts . getOnErrorEvents ( ) . get ( <int> ) instanceof TestException ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testFunctionThrows ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER_ERROR ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( <int> ) ; source . onNext ( <int> ) ; ts . assertTerminalEvent ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; assertEquals ( <int> , ts . getOnErrorEvents ( ) . size ( ) ) ; assertTrue ( ts . getOnErrorEvents ( ) . get ( <int> ) instanceof TestException ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; } @Test public void testNoDownstreamUnsubscribe ( ) { PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; result . unsafeSubscribe ( ts ) ; source . onCompleted ( ) ; assertFalse ( ts . isUnsubscribed ( ) ) ; } @Test public void testBackpressure ( ) { Observable < Integer > source = Observable . range ( <int> , <int> ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } } ; result . subscribe ( ts ) ; ts . requestMore ( <int> ) ; ts . assertReceivedOnNext ( Collections . < Integer > emptyList ( ) ) ; other . onNext ( <int> ) ; ts . requestMore ( <int> ) ; ts . assertReceivedOnNext ( Arrays . asList ( ( <int> < < <int> ) + <int> ) ) ; ts . requestMore ( <int> ) ; ts . assertReceivedOnNext ( Arrays . asList ( ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + <int> , ( <int> < < <int> ) + <int> ) ) ; ts . unsubscribe ( ) ; assertFalse ( <str> , other . hasObservers ( ) ) ; ts . assertNoErrors ( ) ; } }