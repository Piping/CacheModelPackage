package com . nostra13 . universalimageloader . core ; import android . content . Context ; import android . content . res . Resources ; import android . util . DisplayMetrics ; import com . nostra13 . universalimageloader . cache . disc . DiskCache ; import com . nostra13 . universalimageloader . cache . disc . naming . FileNameGenerator ; import com . nostra13 . universalimageloader . cache . memory . MemoryCache ; import com . nostra13 . universalimageloader . cache . memory . impl . FuzzyKeyMemoryCache ; import com . nostra13 . universalimageloader . core . assist . FlushedInputStream ; import com . nostra13 . universalimageloader . core . assist . ImageSize ; import com . nostra13 . universalimageloader . core . assist . QueueProcessingType ; import com . nostra13 . universalimageloader . core . decode . ImageDecoder ; import com . nostra13 . universalimageloader . core . download . ImageDownloader ; import com . nostra13 . universalimageloader . core . process . BitmapProcessor ; import com . nostra13 . universalimageloader . utils . L ; import com . nostra13 . universalimageloader . utils . MemoryCacheUtils ; import java . io . IOException ; import java . io . InputStream ; import java . util . concurrent . Executor ; public final class ImageLoaderConfiguration { final Resources resources ; final int maxImageWidthForMemoryCache ; final int maxImageHeightForMemoryCache ; final int maxImageWidthForDiskCache ; final int maxImageHeightForDiskCache ; final BitmapProcessor processorForDiskCache ; final Executor taskExecutor ; final Executor taskExecutorForCachedImages ; final boolean customExecutor ; final boolean customExecutorForCachedImages ; final int threadPoolSize ; final int threadPriority ; final QueueProcessingType tasksProcessingType ; final MemoryCache memoryCache ; final DiskCache diskCache ; final ImageDownloader downloader ; final ImageDecoder decoder ; final DisplayImageOptions defaultDisplayImageOptions ; final ImageDownloader networkDeniedDownloader ; final ImageDownloader slowNetworkDownloader ; private ImageLoaderConfiguration ( final Builder builder ) { resources = builder . context . getResources ( ) ; maxImageWidthForMemoryCache = builder . maxImageWidthForMemoryCache ; maxImageHeightForMemoryCache = builder . maxImageHeightForMemoryCache ; maxImageWidthForDiskCache = builder . maxImageWidthForDiskCache ; maxImageHeightForDiskCache = builder . maxImageHeightForDiskCache ; processorForDiskCache = builder . processorForDiskCache ; taskExecutor = builder . taskExecutor ; taskExecutorForCachedImages = builder . taskExecutorForCachedImages ; threadPoolSize = builder . threadPoolSize ; threadPriority = builder . threadPriority ; tasksProcessingType = builder . tasksProcessingType ; diskCache = builder . diskCache ; memoryCache = builder . memoryCache ; defaultDisplayImageOptions = builder . defaultDisplayImageOptions ; downloader = builder . downloader ; decoder = builder . decoder ; customExecutor = builder . customExecutor ; customExecutorForCachedImages = builder . customExecutorForCachedImages ; networkDeniedDownloader = new NetworkDeniedImageDownloader ( downloader ) ; slowNetworkDownloader = new SlowNetworkImageDownloader ( downloader ) ; L . writeDebugLogs ( builder . writeLogs ) ; } public static ImageLoaderConfiguration createDefault ( Context context ) { return new Builder ( context ) . build ( ) ; } ImageSize getMaxImageSize ( ) { DisplayMetrics displayMetrics = resources . getDisplayMetrics ( ) ; int width = maxImageWidthForMemoryCache ; if ( width < = <int> ) { width = displayMetrics . widthPixels ; } int height = maxImageHeightForMemoryCache ; if ( height < = <int> ) { height = displayMetrics . heightPixels ; } return new ImageSize ( width , height ) ; } public static class Builder { private static final String WARNING_OVERLAP_DISK_CACHE_PARAMS = <str> ; private static final String WARNING_OVERLAP_DISK_CACHE_NAME_GENERATOR = <str> ; private static final String WARNING_OVERLAP_MEMORY_CACHE = <str> ; private static final String WARNING_OVERLAP_EXECUTOR = <str> + <str> ; public static final int DEFAULT_THREAD_POOL_SIZE = <int> ; public static final int DEFAULT_THREAD_PRIORITY = Thread . NORM_PRIORITY - <int> ; public static final QueueProcessingType DEFAULT_TASK_PROCESSING_TYPE = QueueProcessingType . FIFO ; private Context context ; private int maxImageWidthForMemoryCache = <int> ; private int maxImageHeightForMemoryCache = <int> ; private int maxImageWidthForDiskCache = <int> ; private int maxImageHeightForDiskCache = <int> ; private BitmapProcessor processorForDiskCache = null ; private Executor taskExecutor = null ; private Executor taskExecutorForCachedImages = null ; private boolean customExecutor = false ; private boolean customExecutorForCachedImages = false ; private int threadPoolSize = DEFAULT_THREAD_POOL_SIZE ; private int threadPriority = DEFAULT_THREAD_PRIORITY ; private boolean denyCacheImageMultipleSizesInMemory = false ; private QueueProcessingType tasksProcessingType = DEFAULT_TASK_PROCESSING_TYPE ; private int memoryCacheSize = <int> ; private long diskCacheSize = <int> ; private int diskCacheFileCount = <int> ; private MemoryCache memoryCache = null ; private DiskCache diskCache = null ; private FileNameGenerator diskCacheFileNameGenerator = null ; private ImageDownloader downloader = null ; private ImageDecoder decoder ; private DisplayImageOptions defaultDisplayImageOptions = null ; private boolean writeLogs = false ; public Builder ( Context context ) { this . context = context . getApplicationContext ( ) ; } public Builder memoryCacheExtraOptions ( int maxImageWidthForMemoryCache , int maxImageHeightForMemoryCache ) { this . maxImageWidthForMemoryCache = maxImageWidthForMemoryCache ; this . maxImageHeightForMemoryCache = maxImageHeightForMemoryCache ; return this ; } @Deprecated public Builder discCacheExtraOptions ( int maxImageWidthForDiskCache , int maxImageHeightForDiskCache , BitmapProcessor processorForDiskCache ) { return diskCacheExtraOptions ( maxImageWidthForDiskCache , maxImageHeightForDiskCache , processorForDiskCache ) ; } public Builder diskCacheExtraOptions ( int maxImageWidthForDiskCache , int maxImageHeightForDiskCache , BitmapProcessor processorForDiskCache ) { this . maxImageWidthForDiskCache = maxImageWidthForDiskCache ; this . maxImageHeightForDiskCache = maxImageHeightForDiskCache ; this . processorForDiskCache = processorForDiskCache ; return this ; } public Builder taskExecutor ( Executor executor ) { if ( threadPoolSize ! = DEFAULT_THREAD_POOL_SIZE | | threadPriority ! = DEFAULT_THREAD_PRIORITY | | tasksProcessingType ! = DEFAULT_TASK_PROCESSING_TYPE ) { L . w ( WARNING_OVERLAP_EXECUTOR ) ; } this . taskExecutor = executor ; return this ; } public Builder taskExecutorForCachedImages ( Executor executorForCachedImages ) { if ( threadPoolSize ! = DEFAULT_THREAD_POOL_SIZE | | threadPriority ! = DEFAULT_THREAD_PRIORITY | | tasksProcessingType ! = DEFAULT_TASK_PROCESSING_TYPE ) { L . w ( WARNING_OVERLAP_EXECUTOR ) ; } this . taskExecutorForCachedImages = executorForCachedImages ; return this ; } public Builder threadPoolSize ( int threadPoolSize ) { if ( taskExecutor ! = null | | taskExecutorForCachedImages ! = null ) { L . w ( WARNING_OVERLAP_EXECUTOR ) ; } this . threadPoolSize = threadPoolSize ; return this ; } public Builder threadPriority ( int threadPriority ) { if ( taskExecutor ! = null | | taskExecutorForCachedImages ! = null ) { L . w ( WARNING_OVERLAP_EXECUTOR ) ; } if ( threadPriority < Thread . MIN_PRIORITY ) { this . threadPriority = Thread . MIN_PRIORITY ; } else { if ( threadPriority > Thread . MAX_PRIORITY ) { this . threadPriority = Thread . MAX_PRIORITY ; } else { this . threadPriority = threadPriority ; } } return this ; } public Builder denyCacheImageMultipleSizesInMemory ( ) { this . denyCacheImageMultipleSizesInMemory = true ; return this ; } public Builder tasksProcessingOrder ( QueueProcessingType tasksProcessingType ) { if ( taskExecutor ! = null | | taskExecutorForCachedImages ! = null ) { L . w ( WARNING_OVERLAP_EXECUTOR ) ; } this . tasksProcessingType = tasksProcessingType ; return this ; } public Builder memoryCacheSize ( int memoryCacheSize ) { if ( memoryCacheSize < = <int> ) throw new IllegalArgumentException ( <str> ) ; if ( memoryCache ! = null ) { L . w ( WARNING_OVERLAP_MEMORY_CACHE ) ; } this . memoryCacheSize = memoryCacheSize ; return this ; } public Builder memoryCacheSizePercentage ( int availableMemoryPercent ) { if ( availableMemoryPercent < = <int> | | availableMemoryPercent > = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( memoryCache ! = null ) { L . w ( WARNING_OVERLAP_MEMORY_CACHE ) ; } long availableMemory = Runtime . getRuntime ( ) . maxMemory ( ) ; memoryCacheSize = ( int ) ( availableMemory * ( availableMemoryPercent / <int> f ) ) ; return this ; } public Builder memoryCache ( MemoryCache memoryCache ) { if ( memoryCacheSize ! = <int> ) { L . w ( WARNING_OVERLAP_MEMORY_CACHE ) ; } this . memoryCache = memoryCache ; return this ; } @Deprecated public Builder discCacheSize ( int maxCacheSize ) { return diskCacheSize ( maxCacheSize ) ; } public Builder diskCacheSize ( int maxCacheSize ) { if ( maxCacheSize < = <int> ) throw new IllegalArgumentException ( <str> ) ; if ( diskCache ! = null ) { L . w ( WARNING_OVERLAP_DISK_CACHE_PARAMS ) ; } this . diskCacheSize = maxCacheSize ; return this ; } @Deprecated public Builder discCacheFileCount ( int maxFileCount ) { return diskCacheFileCount ( maxFileCount ) ; } public Builder diskCacheFileCount ( int maxFileCount ) { if ( maxFileCount < = <int> ) throw new IllegalArgumentException ( <str> ) ; if ( diskCache ! = null ) { L . w ( WARNING_OVERLAP_DISK_CACHE_PARAMS ) ; } this . diskCacheFileCount = maxFileCount ; return this ; } @Deprecated public Builder discCacheFileNameGenerator ( FileNameGenerator fileNameGenerator ) { return diskCacheFileNameGenerator ( fileNameGenerator ) ; } public Builder diskCacheFileNameGenerator ( FileNameGenerator fileNameGenerator ) { if ( diskCache ! = null ) { L . w ( WARNING_OVERLAP_DISK_CACHE_NAME_GENERATOR ) ; } this . diskCacheFileNameGenerator = fileNameGenerator ; return this ; } @Deprecated public Builder discCache ( DiskCache diskCache ) { return diskCache ( diskCache ) ; } public Builder diskCache ( DiskCache diskCache ) { if ( diskCacheSize > <int> | | diskCacheFileCount > <int> ) { L . w ( WARNING_OVERLAP_DISK_CACHE_PARAMS ) ; } if ( diskCacheFileNameGenerator ! = null ) { L . w ( WARNING_OVERLAP_DISK_CACHE_NAME_GENERATOR ) ; } this . diskCache = diskCache ; return this ; } public Builder imageDownloader ( ImageDownloader imageDownloader ) { this . downloader = imageDownloader ; return this ; } public Builder imageDecoder ( ImageDecoder imageDecoder ) { this . decoder = imageDecoder ; return this ; } public Builder defaultDisplayImageOptions ( DisplayImageOptions defaultDisplayImageOptions ) { this . defaultDisplayImageOptions = defaultDisplayImageOptions ; return this ; } public Builder writeDebugLogs ( ) { this . writeLogs = true ; return this ; } public ImageLoaderConfiguration build ( ) { initEmptyFieldsWithDefaultValues ( ) ; return new ImageLoaderConfiguration ( this ) ; } private void initEmptyFieldsWithDefaultValues ( ) { if ( taskExecutor = = null ) { taskExecutor = DefaultConfigurationFactory . createExecutor ( threadPoolSize , threadPriority , tasksProcessingType ) ; } else { customExecutor = true ; } if ( taskExecutorForCachedImages = = null ) { taskExecutorForCachedImages = DefaultConfigurationFactory . createExecutor ( threadPoolSize , threadPriority , tasksProcessingType ) ; } else { customExecutorForCachedImages = true ; } if ( diskCache = = null ) { if ( diskCacheFileNameGenerator = = null ) { diskCacheFileNameGenerator = DefaultConfigurationFactory . createFileNameGenerator ( ) ; } diskCache = DefaultConfigurationFactory . createDiskCache ( context , diskCacheFileNameGenerator , diskCacheSize , diskCacheFileCount ) ; } if ( memoryCache = = null ) { memoryCache = DefaultConfigurationFactory . createMemoryCache ( context , memoryCacheSize ) ; } if ( denyCacheImageMultipleSizesInMemory ) { memoryCache = new FuzzyKeyMemoryCache ( memoryCache , MemoryCacheUtils . createFuzzyKeyComparator ( ) ) ; } if ( downloader = = null ) { downloader = DefaultConfigurationFactory . createImageDownloader ( context ) ; } if ( decoder = = null ) { decoder = DefaultConfigurationFactory . createImageDecoder ( writeLogs ) ; } if ( defaultDisplayImageOptions = = null ) { defaultDisplayImageOptions = DisplayImageOptions . createSimple ( ) ; } } } private static class NetworkDeniedImageDownloader implements ImageDownloader { private final ImageDownloader wrappedDownloader ; public NetworkDeniedImageDownloader ( ImageDownloader wrappedDownloader ) { this . wrappedDownloader = wrappedDownloader ; } @Override public InputStream getStream ( String imageUri , Object extra ) throws IOException { switch ( Scheme . ofUri ( imageUri ) ) { case HTTP : case HTTPS : throw new IllegalStateException ( ) ; default : return wrappedDownloader . getStream ( imageUri , extra ) ; } } } private static class SlowNetworkImageDownloader implements ImageDownloader { private final ImageDownloader wrappedDownloader ; public SlowNetworkImageDownloader ( ImageDownloader wrappedDownloader ) { this . wrappedDownloader = wrappedDownloader ; } @Override public InputStream getStream ( String imageUri , Object extra ) throws IOException { InputStream imageStream = wrappedDownloader . getStream ( imageUri , extra ) ; switch ( Scheme . ofUri ( imageUri ) ) { case HTTP : case HTTPS : return new FlushedInputStream ( imageStream ) ; default : return imageStream ; } } } }