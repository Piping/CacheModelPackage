package org . elasticsearch . index . translog ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . index . Term ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . ByteArrayDataOutput ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import org . hamcrest . Matchers ; import org . junit . After ; import org . junit . Before ; import java . io . EOFException ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . charset . Charset ; import java . nio . file . Files ; import java . nio . file . InvalidPathException ; import java . nio . file . Path ; import java . nio . file . StandardOpenOption ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . * ; @LuceneTestCase.SuppressFileSystems ( <str> ) public class TranslogTests extends ESTestCase { protected final ShardId shardId = new ShardId ( new Index ( <str> ) , <int> ) ; protected Translog translog ; protected Path translogDir ; @Override protected void afterIfSuccessful ( ) throws Exception { super . afterIfSuccessful ( ) ; if ( translog . isOpen ( ) ) { if ( translog . currentFileGeneration ( ) > <int> ) { translog . commit ( ) ; assertFileDeleted ( translog , translog . currentFileGeneration ( ) - <int> ) ; } translog . close ( ) ; } assertFileIsPresent ( translog , translog . currentFileGeneration ( ) ) ; IOUtils . rm ( translog . location ( ) ) ; } @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; translogDir = createTempDir ( ) ; translog = create ( translogDir ) ; } @Override @After public void tearDown ( ) throws Exception { try { assertEquals ( <str> , <int> , translog . getNumOpenViews ( ) ) ; translog . close ( ) ; } finally { super . tearDown ( ) ; } } protected Translog create ( Path path ) throws IOException { Settings build = Settings . settingsBuilder ( ) . put ( TranslogConfig . INDEX_TRANSLOG_FS_TYPE , TranslogWriter . Type . SIMPLE . name ( ) ) . put ( IndexMetaData . SETTING_VERSION_CREATED , org . elasticsearch . Version . CURRENT ) . build ( ) ; TranslogConfig translogConfig = new TranslogConfig ( shardId , path , IndexSettingsModule . newIndexSettings ( shardId . index ( ) , build ) , Translog . Durabilty . REQUEST , BigArrays . NON_RECYCLING_INSTANCE , null ) ; return new Translog ( translogConfig ) ; } protected void addToTranslogAndList ( Translog translog , ArrayList < Translog . Operation > list , Translog . Operation op ) { list . add ( op ) ; translog . add ( op ) ; } public void testIdParsingFromFile ( ) { long id = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; Path file = translogDir . resolve ( Translog . TRANSLOG_FILE_PREFIX + id + <str> ) ; assertThat ( Translog . parseIdFromFileName ( file ) , equalTo ( id ) ) ; id = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; file = translogDir . resolve ( Translog . TRANSLOG_FILE_PREFIX + id ) ; try { Translog . parseIdFromFileName ( file ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } file = translogDir . resolve ( Translog . TRANSLOG_FILE_PREFIX + id + <str> ) ; try { Translog . parseIdFromFileName ( file ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } file = translogDir . resolve ( Translog . TRANSLOG_FILE_PREFIX + randomNonTranslogPatternString ( <int> , <int> ) + id ) ; try { Translog . parseIdFromFileName ( file ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } file = translogDir . resolve ( randomNonTranslogPatternString ( <int> , Translog . TRANSLOG_FILE_PREFIX . length ( ) - <int> ) ) ; try { Translog . parseIdFromFileName ( file ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } private String randomNonTranslogPatternString ( int min , int max ) { String string ; boolean validPathString ; do { validPathString = false ; string = randomRealisticUnicodeOfCodepointLength ( randomIntBetween ( min , max ) ) ; try { final Path resolved = translogDir . resolve ( string ) ; validPathString = resolved . getFileName ( ) ! = null ; } catch ( InvalidPathException ex ) { } } while ( Translog . PARSE_STRICT_ID_PATTERN . matcher ( string ) . matches ( ) | | validPathString = = false ) ; return string ; } public void testRead ( ) throws IOException { Translog . Location loc1 = translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; Translog . Location loc2 = translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; assertThat ( translog . read ( loc1 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; assertThat ( translog . read ( loc2 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; translog . sync ( ) ; assertThat ( translog . read ( loc1 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; assertThat ( translog . read ( loc2 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; Translog . Location loc3 = translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; assertThat ( translog . read ( loc3 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; translog . sync ( ) ; assertThat ( translog . read ( loc3 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; translog . prepareCommit ( ) ; assertThat ( translog . read ( loc3 ) . getSource ( ) . source . toBytesArray ( ) , equalTo ( new BytesArray ( new byte [ ] { <int> } ) ) ) ; translog . commit ( ) ; assertNull ( translog . read ( loc1 ) ) ; assertNull ( translog . read ( loc2 ) ) ; assertNull ( translog . read ( loc3 ) ) ; try { translog . read ( new Translog . Location ( translog . currentFileGeneration ( ) + <int> , <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } public void testSimpleOperations ( ) throws IOException { ArrayList < Translog . Operation > ops = new ArrayList < > ( ) ; Translog . Snapshot snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . size ( <int> ) ) ; snapshot . close ( ) ; addToTranslogAndList ( translog , ops , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( ops . size ( ) ) ) ; snapshot . close ( ) ; addToTranslogAndList ( translog , ops , new Translog . Delete ( newUid ( <str> ) ) ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( ops . size ( ) ) ) ; snapshot . close ( ) ; snapshot = translog . newSnapshot ( ) ; Translog . Index index = ( Translog . Index ) snapshot . next ( ) ; assertThat ( index ! = null , equalTo ( true ) ) ; assertThat ( index . source ( ) . toBytes ( ) , equalTo ( new byte [ ] { <int> } ) ) ; Translog . Delete delete = ( Translog . Delete ) snapshot . next ( ) ; assertThat ( delete ! = null , equalTo ( true ) ) ; assertThat ( delete . uid ( ) , equalTo ( newUid ( <str> ) ) ) ; assertThat ( snapshot . next ( ) , equalTo ( null ) ) ; snapshot . close ( ) ; long firstId = translog . currentFileGeneration ( ) ; translog . prepareCommit ( ) ; assertThat ( translog . currentFileGeneration ( ) , Matchers . not ( equalTo ( firstId ) ) ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( ops . size ( ) ) ) ; snapshot . close ( ) ; translog . commit ( ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . size ( <int> ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; snapshot . close ( ) ; } protected TranslogStats stats ( ) throws IOException { translog . sync ( ) ; TranslogStats stats = translog . stats ( ) ; if ( randomBoolean ( ) ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; stats . writeTo ( out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; stats = new TranslogStats ( ) ; stats . readFrom ( in ) ; } return stats ; } public void testStats ( ) throws IOException { final long firstOperationPosition = translog . getFirstOperationPosition ( ) ; TranslogStats stats = stats ( ) ; assertThat ( stats . estimatedNumberOfOperations ( ) , equalTo ( <int> l ) ) ; long lastSize = stats . getTranslogSizeInBytes ( ) ; assertThat ( ( int ) firstOperationPosition , greaterThan ( CodecUtil . headerLength ( TranslogWriter . TRANSLOG_CODEC ) ) ) ; assertThat ( lastSize , equalTo ( firstOperationPosition ) ) ; TranslogStats total = new TranslogStats ( ) ; translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; stats = stats ( ) ; total . add ( stats ) ; assertThat ( stats . estimatedNumberOfOperations ( ) , equalTo ( <int> l ) ) ; assertThat ( stats . getTranslogSizeInBytes ( ) , greaterThan ( lastSize ) ) ; lastSize = stats . getTranslogSizeInBytes ( ) ; translog . add ( new Translog . Delete ( newUid ( <str> ) ) ) ; stats = stats ( ) ; total . add ( stats ) ; assertThat ( stats . estimatedNumberOfOperations ( ) , equalTo ( <int> l ) ) ; assertThat ( stats . getTranslogSizeInBytes ( ) , greaterThan ( lastSize ) ) ; lastSize = stats . getTranslogSizeInBytes ( ) ; translog . add ( new Translog . Delete ( newUid ( <str> ) ) ) ; translog . prepareCommit ( ) ; stats = stats ( ) ; total . add ( stats ) ; assertThat ( stats . estimatedNumberOfOperations ( ) , equalTo ( <int> l ) ) ; assertThat ( stats . getTranslogSizeInBytes ( ) , greaterThan ( lastSize ) ) ; translog . commit ( ) ; stats = stats ( ) ; total . add ( stats ) ; assertThat ( stats . estimatedNumberOfOperations ( ) , equalTo ( <int> l ) ) ; assertThat ( stats . getTranslogSizeInBytes ( ) , equalTo ( firstOperationPosition ) ) ; assertEquals ( <int> , total . estimatedNumberOfOperations ( ) ) ; assertEquals ( <int> , total . getTranslogSizeInBytes ( ) ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; total . writeTo ( out ) ; TranslogStats copy = new TranslogStats ( ) ; copy . readFrom ( StreamInput . wrap ( out . bytes ( ) ) ) ; assertEquals ( <int> , copy . estimatedNumberOfOperations ( ) ) ; assertEquals ( <int> , copy . getTranslogSizeInBytes ( ) ) ; assertEquals ( <str> + <str> + <str> + <str> , copy . toString ( ) . trim ( ) ) ; try { new TranslogStats ( <int> , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { new TranslogStats ( - <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } public void testSnapshot ( ) { ArrayList < Translog . Operation > ops = new ArrayList < > ( ) ; Translog . Snapshot snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . size ( <int> ) ) ; snapshot . close ( ) ; addToTranslogAndList ( translog , ops , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; snapshot . close ( ) ; snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; Translog . Snapshot snapshot1 = translog . newSnapshot ( ) ; assertThat ( snapshot1 , SnapshotMatchers . size ( <int> ) ) ; assertThat ( snapshot1 . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; snapshot . close ( ) ; snapshot1 . close ( ) ; } public void testSnapshotWithNewTranslog ( ) throws IOException { ArrayList < Translog . Operation > ops = new ArrayList < > ( ) ; Translog . Snapshot snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . size ( <int> ) ) ; snapshot . close ( ) ; addToTranslogAndList ( translog , ops , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; Translog . Snapshot snapshot1 = translog . newSnapshot ( ) ; addToTranslogAndList ( translog , ops , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; translog . prepareCommit ( ) ; addToTranslogAndList ( translog , ops , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; Translog . Snapshot snapshot2 = translog . newSnapshot ( ) ; translog . commit ( ) ; assertThat ( snapshot2 , SnapshotMatchers . equalsTo ( ops ) ) ; assertThat ( snapshot2 . estimatedTotalOperations ( ) , equalTo ( ops . size ( ) ) ) ; assertThat ( snapshot1 , SnapshotMatchers . equalsTo ( ops . get ( <int> ) ) ) ; snapshot1 . close ( ) ; snapshot2 . close ( ) ; } public void testSnapshotOnClosedTranslog ( ) throws IOException { assertTrue ( Files . exists ( translogDir . resolve ( Translog . getFilename ( <int> ) ) ) ) ; translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; translog . close ( ) ; try { Translog . Snapshot snapshot = translog . newSnapshot ( ) ; fail ( <str> ) ; } catch ( AlreadyClosedException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } } public void testDeleteOnSnapshotRelease ( ) throws Exception { ArrayList < Translog . Operation > firstOps = new ArrayList < > ( ) ; addToTranslogAndList ( translog , firstOps , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; Translog . Snapshot firstSnapshot = translog . newSnapshot ( ) ; assertThat ( firstSnapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; translog . commit ( ) ; assertFileIsPresent ( translog , <int> ) ; ArrayList < Translog . Operation > secOps = new ArrayList < > ( ) ; addToTranslogAndList ( translog , secOps , new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; assertThat ( firstSnapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; Translog . Snapshot secondSnapshot = translog . newSnapshot ( ) ; translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; assertThat ( secondSnapshot , SnapshotMatchers . equalsTo ( secOps ) ) ; assertThat ( secondSnapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; assertFileIsPresent ( translog , <int> ) ; assertFileIsPresent ( translog , <int> ) ; firstSnapshot . close ( ) ; assertFileDeleted ( translog , <int> ) ; assertFileIsPresent ( translog , <int> ) ; secondSnapshot . close ( ) ; assertFileIsPresent ( translog , <int> ) ; translog . commit ( ) ; assertFileIsPresent ( translog , <int> ) ; assertFileDeleted ( translog , <int> ) ; } public void assertFileIsPresent ( Translog translog , long id ) { if ( Files . exists ( translogDir . resolve ( Translog . getFilename ( id ) ) ) ) { return ; } fail ( Translog . getFilename ( id ) + <str> + translog . location ( ) ) ; } public void assertFileDeleted ( Translog translog , long id ) { assertFalse ( <str> + id + <str> , Files . exists ( translog . location ( ) . resolve ( Translog . getFilename ( id ) ) ) ) ; } static class LocationOperation { final Translog . Operation operation ; final Translog . Location location ; public LocationOperation ( Translog . Operation operation , Translog . Location location ) { this . operation = operation ; this . location = location ; } } public void testConcurrentWritesWithVaryingSize ( ) throws Throwable { final int opsPerThread = randomIntBetween ( <int> , <int> ) ; int threadCount = <int> + randomInt ( <int> ) ; logger . info ( <str> , threadCount , opsPerThread ) ; final BlockingQueue < LocationOperation > writtenOperations = new ArrayBlockingQueue < > ( threadCount * opsPerThread ) ; Thread [ ] threads = new Thread [ threadCount ] ; final Throwable [ ] threadExceptions = new Throwable [ threadCount ] ; final CountDownLatch downLatch = new CountDownLatch ( <int> ) ; for ( int i = <int> ; i < threadCount ; i + + ) { final int threadId = i ; threads [ i ] = new TranslogThread ( translog , downLatch , opsPerThread , threadId , writtenOperations , threadExceptions ) ; threads [ i ] . setDaemon ( true ) ; threads [ i ] . start ( ) ; } downLatch . countDown ( ) ; for ( int i = <int> ; i < threadCount ; i + + ) { if ( threadExceptions [ i ] ! = null ) { throw threadExceptions [ i ] ; } threads [ i ] . join ( <int> * <int> ) ; } for ( LocationOperation locationOperation : writtenOperations ) { Translog . Operation op = translog . read ( locationOperation . location ) ; Translog . Operation expectedOp = locationOperation . operation ; assertEquals ( expectedOp . opType ( ) , op . opType ( ) ) ; switch ( op . opType ( ) ) { case INDEX : Translog . Index indexOp = ( Translog . Index ) op ; Translog . Index expIndexOp = ( Translog . Index ) expectedOp ; assertEquals ( expIndexOp . id ( ) , indexOp . id ( ) ) ; assertEquals ( expIndexOp . routing ( ) , indexOp . routing ( ) ) ; assertEquals ( expIndexOp . type ( ) , indexOp . type ( ) ) ; assertEquals ( expIndexOp . source ( ) , indexOp . source ( ) ) ; assertEquals ( expIndexOp . version ( ) , indexOp . version ( ) ) ; assertEquals ( expIndexOp . versionType ( ) , indexOp . versionType ( ) ) ; break ; case DELETE : Translog . Delete delOp = ( Translog . Delete ) op ; Translog . Delete expDelOp = ( Translog . Delete ) expectedOp ; assertEquals ( expDelOp . uid ( ) , delOp . uid ( ) ) ; assertEquals ( expDelOp . version ( ) , delOp . version ( ) ) ; assertEquals ( expDelOp . versionType ( ) , delOp . versionType ( ) ) ; break ; default : throw new ElasticsearchException ( <str> ) ; } } } public void testTranslogChecksums ( ) throws Exception { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { String ascii = randomAsciiOfLengthBetween ( <int> , <int> ) ; locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , ascii . getBytes ( <str> ) ) ) ) ; } translog . sync ( ) ; corruptTranslogs ( translogDir ) ; AtomicInteger corruptionsCaught = new AtomicInteger ( <int> ) ; for ( Translog . Location location : locations ) { try { translog . read ( location ) ; } catch ( TranslogCorruptedException e ) { corruptionsCaught . incrementAndGet ( ) ; } } assertThat ( <str> , corruptionsCaught . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; } public void testTruncatedTranslogs ( ) throws Exception { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { String ascii = randomAsciiOfLengthBetween ( <int> , <int> ) ; locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , ascii . getBytes ( <str> ) ) ) ) ; } translog . sync ( ) ; truncateTranslogs ( translogDir ) ; AtomicInteger truncations = new AtomicInteger ( <int> ) ; for ( Translog . Location location : locations ) { try { translog . read ( location ) ; } catch ( ElasticsearchException e ) { if ( e . getCause ( ) instanceof EOFException ) { truncations . incrementAndGet ( ) ; } else { throw e ; } } } assertThat ( <str> , truncations . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; } private void truncateTranslogs ( Path directory ) throws Exception { Path [ ] files = FileSystemUtils . files ( directory , <str> ) ; for ( Path file : files ) { try ( FileChannel f = FileChannel . open ( file , StandardOpenOption . READ , StandardOpenOption . WRITE ) ) { long prevSize = f . size ( ) ; long newSize = prevSize - randomIntBetween ( <int> , ( int ) prevSize / <int> ) ; logger . info ( <str> , file , prevSize , newSize ) ; f . truncate ( newSize ) ; } } } private void corruptTranslogs ( Path directory ) throws Exception { Path [ ] files = FileSystemUtils . files ( directory , <str> ) ; for ( Path file : files ) { logger . info ( <str> , file ) ; FileChannel f = FileChannel . open ( file , StandardOpenOption . READ , StandardOpenOption . WRITE ) ; int corruptions = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < corruptions ; i + + ) { long pos = randomIntBetween ( <int> , ( int ) f . size ( ) ) ; ByteBuffer junk = ByteBuffer . wrap ( new byte [ ] { randomByte ( ) } ) ; f . write ( junk , pos ) ; } f . close ( ) ; } } private Term newUid ( String id ) { return new Term ( <str> , id ) ; } public void testVerifyTranslogIsNotDeleted ( ) throws IOException { assertFileIsPresent ( translog , <int> ) ; translog . add ( new Translog . Index ( <str> , <str> , new byte [ ] { <int> } ) ) ; Translog . Snapshot snapshot = translog . newSnapshot ( ) ; assertThat ( snapshot , SnapshotMatchers . size ( <int> ) ) ; assertFileIsPresent ( translog , <int> ) ; assertThat ( snapshot . estimatedTotalOperations ( ) , equalTo ( <int> ) ) ; if ( randomBoolean ( ) ) { translog . close ( ) ; snapshot . close ( ) ; } else { snapshot . close ( ) ; translog . close ( ) ; } assertFileIsPresent ( translog , <int> ) ; } public void testConcurrentWriteViewsAndSnapshot ( ) throws Throwable { final Thread [ ] writers = new Thread [ randomIntBetween ( <int> , <int> ) ] ; final Thread [ ] readers = new Thread [ randomIntBetween ( <int> , <int> ) ] ; final int flushEveryOps = randomIntBetween ( <int> , <int> ) ; final AtomicReference < CountDownLatch > writtenOpsLatch = new AtomicReference < > ( new CountDownLatch ( <int> ) ) ; final AtomicLong idGenerator = new AtomicLong ( ) ; final CyclicBarrier barrier = new CyclicBarrier ( writers . length + readers . length + <int> ) ; final Map < Translog . Operation , Translog . Location > writtenOps = ConcurrentCollections . newConcurrentMap ( ) ; final AtomicBoolean run = new AtomicBoolean ( true ) ; final List < Throwable > errors = new CopyOnWriteArrayList < > ( ) ; logger . debug ( <str> , readers . length , writers . length , flushEveryOps ) ; for ( int i = <int> ; i < writers . length ; i + + ) { final String threadId = <str> + i ; writers [ i ] = new Thread ( new AbstractRunnable ( ) { @Override public void doRun ( ) throws BrokenBarrierException , InterruptedException { barrier . await ( ) ; int counter = <int> ; while ( run . get ( ) ) { long id = idGenerator . incrementAndGet ( ) ; final Translog . Operation op ; switch ( Translog . Operation . Type . values ( ) [ ( ( int ) ( id % Translog . Operation . Type . values ( ) . length ) ) ] ) { case CREATE : case INDEX : op = new Translog . Index ( <str> , <str> + id , new byte [ ] { ( byte ) id } ) ; break ; case DELETE : op = new Translog . Delete ( newUid ( <str> + id ) ) ; break ; default : throw new ElasticsearchException ( <str> ) ; } Translog . Location location = translog . add ( op ) ; Translog . Location existing = writtenOps . put ( op , location ) ; if ( existing ! = null ) { fail ( <str> + op + <str> + location ) ; } writtenOpsLatch . get ( ) . countDown ( ) ; counter + + ; } logger . debug ( <str> , threadId , counter ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t , threadId ) ; errors . add ( t ) ; } } , threadId ) ; writers [ i ] . start ( ) ; } for ( int i = <int> ; i < readers . length ; i + + ) { final String threadId = <str> + i ; readers [ i ] = new Thread ( new AbstractRunnable ( ) { Translog . View view = null ; Set < Translog . Operation > writtenOpsAtView ; @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t , threadId ) ; errors . add ( t ) ; closeView ( ) ; } void closeView ( ) { if ( view ! = null ) { view . close ( ) ; } } void newView ( ) { closeView ( ) ; view = translog . newView ( ) ; writtenOpsAtView = new HashSet < > ( writtenOps . keySet ( ) ) ; logger . debug ( <str> , threadId , view . minTranslogGeneration ( ) ) ; } @Override protected void doRun ( ) throws Exception { barrier . await ( ) ; int iter = <int> ; while ( run . get ( ) ) { if ( iter + + % <int> = = <int> ) { newView ( ) ; } Set < Translog . Operation > expectedOps = new HashSet < > ( writtenOps . keySet ( ) ) ; expectedOps . removeAll ( writtenOpsAtView ) ; try ( Translog . Snapshot snapshot = view . snapshot ( ) ) { Translog . Operation op ; while ( ( op = snapshot . next ( ) ) ! = null ) { expectedOps . remove ( op ) ; } } if ( expectedOps . isEmpty ( ) = = false ) { StringBuilder missed = new StringBuilder ( <str> ) . append ( expectedOps . size ( ) ) . append ( <str> ) ; boolean failed = false ; for ( Translog . Operation op : expectedOps ) { final Translog . Location loc = writtenOps . get ( op ) ; if ( loc . generation < view . minTranslogGeneration ( ) ) { continue ; } failed = true ; missed . append ( <str> ) . append ( op ) . append ( <str> ) . append ( loc ) ; } if ( failed ) { fail ( missed . toString ( ) ) ; } } writtenOpsLatch . get ( ) . await ( <int> , TimeUnit . MILLISECONDS ) ; } closeView ( ) ; logger . debug ( <str> , threadId , iter ) ; } } , threadId ) ; readers [ i ] . start ( ) ; } barrier . await ( ) ; try { for ( int iterations = scaledRandomIntBetween ( <int> , <int> ) ; iterations > <int> & & errors . isEmpty ( ) ; iterations - - ) { writtenOpsLatch . set ( new CountDownLatch ( flushEveryOps ) ) ; while ( writtenOpsLatch . get ( ) . await ( <int> , TimeUnit . MILLISECONDS ) = = false ) { if ( errors . size ( ) > <int> ) { break ; } } translog . commit ( ) ; } } finally { run . set ( false ) ; logger . debug ( <str> ) ; for ( Thread thread : writers ) { thread . join ( ) ; } for ( Thread thread : readers ) { thread . join ( ) ; } if ( errors . size ( ) > <int> ) { Throwable e = errors . get ( <int> ) ; for ( Throwable suppress : errors . subList ( <int> , errors . size ( ) ) ) { e . addSuppressed ( suppress ) ; } throw e ; } logger . info ( <str> , writtenOps . size ( ) ) ; } } public void testSyncUpTo ( ) throws IOException { int translogOperations = randomIntBetween ( <int> , <int> ) ; int count = <int> ; for ( int op = <int> ; op < translogOperations ; op + + ) { final Translog . Location location = translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( + + count ) . getBytes ( Charset . forName ( <str> ) ) ) ) ; if ( randomBoolean ( ) ) { assertTrue ( <str> , translog . syncNeeded ( ) ) ; assertTrue ( <str> , translog . ensureSynced ( location ) ) ; assertFalse ( <str> , translog . syncNeeded ( ) ) ; translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( + + count ) . getBytes ( Charset . forName ( <str> ) ) ) ) ; assertTrue ( <str> , translog . syncNeeded ( ) ) ; assertFalse ( <str> , translog . ensureSynced ( location ) ) ; assertTrue ( <str> , translog . syncNeeded ( ) ) ; } if ( rarely ( ) ) { translog . commit ( ) ; assertFalse ( <str> , translog . ensureSynced ( location ) ) ; assertFalse ( <str> , translog . syncNeeded ( ) ) ; } if ( randomBoolean ( ) ) { translog . sync ( ) ; assertFalse ( <str> , translog . ensureSynced ( location ) ) ; } } } public void testLocationComparison ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; int count = <int> ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( + + count ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( rarely ( ) & & translogOperations > op + <int> ) { translog . commit ( ) ; } } Collections . shuffle ( locations , random ( ) ) ; Translog . Location max = locations . get ( <int> ) ; for ( Translog . Location location : locations ) { max = max ( max , location ) ; } assertEquals ( max . generation , translog . currentFileGeneration ( ) ) ; final Translog . Operation read = translog . read ( max ) ; assertEquals ( read . getSource ( ) . source . toUtf8 ( ) , Integer . toString ( count ) ) ; } public static Translog . Location max ( Translog . Location a , Translog . Location b ) { if ( a . compareTo ( b ) > <int> ) { return a ; } return b ; } public void testBasicCheckpoint ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; int lastSynced = - <int> ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( frequently ( ) ) { translog . sync ( ) ; lastSynced = op ; } } assertEquals ( translogOperations , translog . totalOperations ( ) ) ; final Translog . Location lastLocation = translog . add ( new Translog . Index ( <str> , <str> + translogOperations , Integer . toString ( translogOperations ) . getBytes ( Charset . forName ( <str> ) ) ) ) ; final Checkpoint checkpoint = Checkpoint . read ( translog . location ( ) . resolve ( Translog . CHECKPOINT_FILE_NAME ) ) ; try ( final ImmutableTranslogReader reader = translog . openReader ( translog . location ( ) . resolve ( Translog . getFilename ( translog . currentFileGeneration ( ) ) ) , checkpoint ) ) { assertEquals ( lastSynced + <int> , reader . totalOperations ( ) ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { Translog . Location location = locations . get ( op ) ; if ( op < = lastSynced ) { final Translog . Operation read = reader . read ( location ) ; assertEquals ( Integer . toString ( op ) , read . getSource ( ) . source . toUtf8 ( ) ) ; } else { try { reader . read ( location ) ; fail ( <str> ) ; } catch ( EOFException ex ) { } } } try { reader . read ( lastLocation ) ; fail ( <str> ) ; } catch ( EOFException ex ) { } } assertEquals ( translogOperations + <int> , translog . totalOperations ( ) ) ; translog . close ( ) ; } public void testTranslogWriter ( ) throws IOException { final TranslogWriter writer = translog . createWriter ( <int> ) ; final int numOps = randomIntBetween ( <int> , <int> ) ; byte [ ] bytes = new byte [ <int> ] ; ByteArrayDataOutput out = new ByteArrayDataOutput ( bytes ) ; for ( int i = <int> ; i < numOps ; i + + ) { out . reset ( bytes ) ; out . writeInt ( i ) ; writer . add ( new BytesArray ( bytes ) ) ; } writer . sync ( ) ; final TranslogReader reader = randomBoolean ( ) ? writer : translog . openReader ( writer . path ( ) , Checkpoint . read ( translog . location ( ) . resolve ( Translog . CHECKPOINT_FILE_NAME ) ) ) ; for ( int i = <int> ; i < numOps ; i + + ) { ByteBuffer buffer = ByteBuffer . allocate ( <int> ) ; reader . readBytes ( buffer , reader . getFirstOperationOffset ( ) + <int> * i ) ; buffer . flip ( ) ; final int value = buffer . getInt ( ) ; assertEquals ( i , value ) ; } out . reset ( bytes ) ; out . writeInt ( <int> ) ; writer . add ( new BytesArray ( bytes ) ) ; if ( reader instanceof ImmutableTranslogReader ) { ByteBuffer buffer = ByteBuffer . allocate ( <int> ) ; try { reader . readBytes ( buffer , reader . getFirstOperationOffset ( ) + <int> * numOps ) ; fail ( <str> ) ; } catch ( EOFException ex ) { } } else { ByteBuffer buffer = ByteBuffer . allocate ( <int> ) ; final long pos = reader . getFirstOperationOffset ( ) + <int> * numOps ; reader . readBytes ( buffer , pos ) ; buffer . flip ( ) ; final int value = buffer . getInt ( ) ; assertEquals ( <int> , value ) ; } IOUtils . close ( writer , reader ) ; } public void testBasicRecovery ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; Translog . TranslogGeneration translogGeneration = null ; int minUncommittedOp = - <int> ; final boolean commitOften = randomBoolean ( ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; final boolean commit = commitOften ? frequently ( ) : rarely ( ) ; if ( commit & & op < translogOperations - <int> ) { translog . commit ( ) ; minUncommittedOp = op + <int> ; translogGeneration = translog . getGeneration ( ) ; } } translog . sync ( ) ; TranslogConfig config = translog . getConfig ( ) ; translog . close ( ) ; config . setTranslogGeneration ( translogGeneration ) ; translog = new Translog ( config ) ; if ( translogGeneration = = null ) { assertEquals ( <int> , translog . stats ( ) . estimatedNumberOfOperations ( ) ) ; assertEquals ( <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { assertNull ( snapshot . next ( ) ) ; } } else { assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { for ( int i = minUncommittedOp ; i < translogOperations ; i + + ) { assertEquals ( <str> + i + <str> , translog . currentFileGeneration ( ) - <int> , locations . get ( i ) . generation ) ; Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> , next ) ; assertEquals ( i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } } public void testRecoveryUncommitted ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; final int prepareOp = randomIntBetween ( <int> , translogOperations - <int> ) ; Translog . TranslogGeneration translogGeneration = null ; final boolean sync = randomBoolean ( ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( op = = prepareOp ) { translogGeneration = translog . getGeneration ( ) ; translog . prepareCommit ( ) ; assertEquals ( <str> , <int> l , translogGeneration . translogFileGeneration ) ; assertNotNull ( translogGeneration . translogUUID ) ; } } if ( sync ) { translog . sync ( ) ; } TranslogConfig config = translog . getConfig ( ) ; config . setTranslogGeneration ( translogGeneration ) ; try ( Translog translog = new Translog ( config ) ) { assertNotNull ( translogGeneration ) ; assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { int upTo = sync ? translogOperations : prepareOp ; for ( int i = <int> ; i < upTo ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> + sync , next ) ; assertEquals ( <str> + sync , i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } if ( randomBoolean ( ) ) { try ( Translog translog = new Translog ( config ) ) { assertNotNull ( translogGeneration ) ; assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { int upTo = sync ? translogOperations : prepareOp ; for ( int i = <int> ; i < upTo ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> + sync , next ) ; assertEquals ( <str> + sync , i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } } } public void testRecoveryUncommittedFileExists ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; final int prepareOp = randomIntBetween ( <int> , translogOperations - <int> ) ; Translog . TranslogGeneration translogGeneration = null ; final boolean sync = randomBoolean ( ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( op = = prepareOp ) { translogGeneration = translog . getGeneration ( ) ; translog . prepareCommit ( ) ; assertEquals ( <str> , <int> l , translogGeneration . translogFileGeneration ) ; assertNotNull ( translogGeneration . translogUUID ) ; } } if ( sync ) { translog . sync ( ) ; } TranslogConfig config = translog . getConfig ( ) ; config . setTranslogGeneration ( translogGeneration ) ; Path ckp = config . getTranslogPath ( ) . resolve ( Translog . CHECKPOINT_FILE_NAME ) ; Checkpoint read = Checkpoint . read ( ckp ) ; Files . copy ( ckp , config . getTranslogPath ( ) . resolve ( Translog . getCommitCheckpointFileName ( read . generation ) ) ) ; try ( Translog translog = new Translog ( config ) ) { assertNotNull ( translogGeneration ) ; assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { int upTo = sync ? translogOperations : prepareOp ; for ( int i = <int> ; i < upTo ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> + sync , next ) ; assertEquals ( <str> + sync , i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } if ( randomBoolean ( ) ) { try ( Translog translog = new Translog ( config ) ) { assertNotNull ( translogGeneration ) ; assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { int upTo = sync ? translogOperations : prepareOp ; for ( int i = <int> ; i < upTo ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> + sync , next ) ; assertEquals ( <str> + sync , i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } } } public void testRecoveryUncommittedCorryptedCheckpoint ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = <int> ; final int prepareOp = <int> ; Translog . TranslogGeneration translogGeneration = null ; final boolean sync = randomBoolean ( ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( op = = prepareOp ) { translogGeneration = translog . getGeneration ( ) ; translog . prepareCommit ( ) ; assertEquals ( <str> , <int> l , translogGeneration . translogFileGeneration ) ; assertNotNull ( translogGeneration . translogUUID ) ; } } translog . sync ( ) ; TranslogConfig config = translog . getConfig ( ) ; config . setTranslogGeneration ( translogGeneration ) ; Path ckp = config . getTranslogPath ( ) . resolve ( Translog . CHECKPOINT_FILE_NAME ) ; Checkpoint read = Checkpoint . read ( ckp ) ; Checkpoint corrupted = new Checkpoint ( <int> , <int> , <int> ) ; Checkpoint . write ( config . getTranslogPath ( ) . resolve ( Translog . getCommitCheckpointFileName ( read . generation ) ) , corrupted , StandardOpenOption . WRITE , StandardOpenOption . CREATE_NEW ) ; try ( Translog translog = new Translog ( config ) ) { fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertEquals ( ex . getMessage ( ) , <str> ) ; } Checkpoint . write ( config . getTranslogPath ( ) . resolve ( Translog . getCommitCheckpointFileName ( read . generation ) ) , read , StandardOpenOption . WRITE , StandardOpenOption . TRUNCATE_EXISTING ) ; try ( Translog translog = new Translog ( config ) ) { assertNotNull ( translogGeneration ) ; assertEquals ( <str> , translogGeneration . translogFileGeneration + <int> , translog . currentFileGeneration ( ) ) ; assertFalse ( translog . syncNeeded ( ) ) ; try ( Translog . Snapshot snapshot = translog . newSnapshot ( ) ) { int upTo = sync ? translogOperations : prepareOp ; for ( int i = <int> ; i < upTo ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i + <str> + sync , next ) ; assertEquals ( <str> + sync , i , Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) ) ; } } } } public void testSnapshotFromStreamInput ( ) throws IOException { BytesStreamOutput out = new BytesStreamOutput ( ) ; List < Translog . Operation > ops = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; for ( int op = <int> ; op < translogOperations ; op + + ) { Translog . Index test = new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ; ops . add ( test ) ; } Translog . writeOperations ( out , ops ) ; final List < Translog . Operation > readOperations = Translog . readOperations ( StreamInput . wrap ( out . bytes ( ) ) ) ; assertEquals ( ops . size ( ) , readOperations . size ( ) ) ; assertEquals ( ops , readOperations ) ; } public void testLocationHashCodeEquals ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; List < Translog . Location > locations2 = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; try ( Translog translog2 = create ( createTempDir ( ) ) ) { for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; locations2 . add ( translog2 . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; } int iters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Translog . Location location = RandomPicks . randomFrom ( random ( ) , locations ) ; for ( Translog . Location loc : locations ) { if ( loc = = location ) { assertTrue ( loc . equals ( location ) ) ; assertEquals ( loc . hashCode ( ) , location . hashCode ( ) ) ; } else { assertFalse ( loc . equals ( location ) ) ; } } for ( int j = <int> ; j < translogOperations ; j + + ) { assertTrue ( locations . get ( j ) . equals ( locations2 . get ( j ) ) ) ; assertEquals ( locations . get ( j ) . hashCode ( ) , locations2 . get ( j ) . hashCode ( ) ) ; } } } } public void testOpenForeignTranslog ( ) throws IOException { List < Translog . Location > locations = new ArrayList < > ( ) ; int translogOperations = randomIntBetween ( <int> , <int> ) ; int firstUncommitted = <int> ; for ( int op = <int> ; op < translogOperations ; op + + ) { locations . add ( translog . add ( new Translog . Index ( <str> , <str> + op , Integer . toString ( op ) . getBytes ( Charset . forName ( <str> ) ) ) ) ) ; if ( randomBoolean ( ) ) { translog . commit ( ) ; firstUncommitted = op + <int> ; } } TranslogConfig config = translog . getConfig ( ) ; Translog . TranslogGeneration translogGeneration = translog . getGeneration ( ) ; translog . close ( ) ; config . setTranslogGeneration ( new Translog . TranslogGeneration ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , translogGeneration . translogUUID . length ( ) ) , translogGeneration . translogFileGeneration ) ) ; try { new Translog ( config ) ; fail ( <str> ) ; } catch ( TranslogCorruptedException ex ) { } config . setTranslogGeneration ( translogGeneration ) ; this . translog = new Translog ( config ) ; try ( Translog . Snapshot snapshot = this . translog . newSnapshot ( ) ) { for ( int i = firstUncommitted ; i < translogOperations ; i + + ) { Translog . Operation next = snapshot . next ( ) ; assertNotNull ( <str> + i , next ) ; assertEquals ( Integer . parseInt ( next . getSource ( ) . source . toUtf8 ( ) ) , i ) ; } assertNull ( snapshot . next ( ) ) ; } } public void testFailOnClosedWrite ( ) throws IOException { translog . add ( new Translog . Index ( <str> , <str> , Integer . toString ( <int> ) . getBytes ( Charset . forName ( <str> ) ) ) ) ; translog . close ( ) ; try { translog . add ( new Translog . Index ( <str> , <str> , Integer . toString ( <int> ) . getBytes ( Charset . forName ( <str> ) ) ) ) ; fail ( <str> ) ; } catch ( AlreadyClosedException ex ) { } } public void testCloseConcurrently ( ) throws Throwable { final int opsPerThread = randomIntBetween ( <int> , <int> ) ; int threadCount = <int> + randomInt ( <int> ) ; logger . info ( <str> , threadCount , opsPerThread ) ; final BlockingQueue < LocationOperation > writtenOperations = new ArrayBlockingQueue < > ( threadCount * opsPerThread ) ; Thread [ ] threads = new Thread [ threadCount ] ; final Throwable [ ] threadExceptions = new Throwable [ threadCount ] ; final CountDownLatch downLatch = new CountDownLatch ( <int> ) ; for ( int i = <int> ; i < threadCount ; i + + ) { final int threadId = i ; threads [ i ] = new TranslogThread ( translog , downLatch , opsPerThread , threadId , writtenOperations , threadExceptions ) ; threads [ i ] . setDaemon ( true ) ; threads [ i ] . start ( ) ; } downLatch . countDown ( ) ; translog . close ( ) ; for ( int i = <int> ; i < threadCount ; i + + ) { if ( threadExceptions [ i ] ! = null ) { if ( ( threadExceptions [ i ] instanceof AlreadyClosedException ) = = false ) { throw threadExceptions [ i ] ; } } threads [ i ] . join ( <int> * <int> ) ; } } private static class TranslogThread extends Thread { private final CountDownLatch downLatch ; private final int opsPerThread ; private final int threadId ; private final BlockingQueue < LocationOperation > writtenOperations ; private final Throwable [ ] threadExceptions ; private final Translog translog ; public TranslogThread ( Translog translog , CountDownLatch downLatch , int opsPerThread , int threadId , BlockingQueue < LocationOperation > writtenOperations , Throwable [ ] threadExceptions ) { this . translog = translog ; this . downLatch = downLatch ; this . opsPerThread = opsPerThread ; this . threadId = threadId ; this . writtenOperations = writtenOperations ; this . threadExceptions = threadExceptions ; } @Override public void run ( ) { try { downLatch . await ( ) ; for ( int opCount = <int> ; opCount < opsPerThread ; opCount + + ) { Translog . Operation op ; 
