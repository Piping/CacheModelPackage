package org . apache . cassandra . io . util ; import java . io . DataOutput ; import java . io . IOException ; import java . io . UTFDataFormatException ; import java . nio . ByteBuffer ; import java . nio . channels . WritableByteChannel ; import org . apache . cassandra . utils . memory . MemoryUtil ; import com . google . common . base . Function ; public abstract class UnbufferedDataOutputStreamPlus extends DataOutputStreamPlus { private static final byte [ ] zeroBytes = new byte [ <int> ] ; protected UnbufferedDataOutputStreamPlus ( ) { super ( ) ; } protected UnbufferedDataOutputStreamPlus ( WritableByteChannel channel ) { super ( channel ) ; } public void write ( byte [ ] buffer ) throws IOException { write ( buffer , <int> , buffer . length ) ; } public abstract void write ( byte [ ] buffer , int offset , int count ) throws IOException ; public abstract void write ( int oneByte ) throws IOException ; public final void writeBoolean ( boolean val ) throws IOException { write ( val ? <int> : <int> ) ; } public final void writeByte ( int val ) throws IOException { write ( val & <hex> ) ; } public final void writeBytes ( String str ) throws IOException { byte bytes [ ] = new byte [ str . length ( ) ] ; for ( int index = <int> ; index < str . length ( ) ; index + + ) { bytes [ index ] = ( byte ) ( str . charAt ( index ) & <hex> ) ; } write ( bytes ) ; } public final void writeChar ( int val ) throws IOException { write ( ( val > > > <int> ) & <hex> ) ; write ( ( val > > > <int> ) & <hex> ) ; } public final void writeChars ( String str ) throws IOException { byte newBytes [ ] = new byte [ str . length ( ) * <int> ] ; for ( int index = <int> ; index < str . length ( ) ; index + + ) { int newIndex = index = = <int> ? index : index * <int> ; newBytes [ newIndex ] = ( byte ) ( ( str . charAt ( index ) > > <int> ) & <hex> ) ; newBytes [ newIndex + <int> ] = ( byte ) ( str . charAt ( index ) & <hex> ) ; } write ( newBytes ) ; } public final void writeDouble ( double val ) throws IOException { writeLong ( Double . doubleToLongBits ( val ) ) ; } public final void writeFloat ( float val ) throws IOException { writeInt ( Float . floatToIntBits ( val ) ) ; } public void writeInt ( int val ) throws IOException { write ( ( val > > > <int> ) & <hex> ) ; write ( ( val > > > <int> ) & <hex> ) ; write ( ( val > > > <int> ) & <hex> ) ; write ( ( val > > > <int> ) & <hex> ) ; } public void writeLong ( long val ) throws IOException { write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; write ( ( int ) ( val > > > <int> ) & <hex> ) ; } public void writeShort ( int val ) throws IOException { writeChar ( val ) ; } public static void writeUTF ( String str , DataOutput out ) throws IOException { int length = str . length ( ) ; if ( length = = <int> ) { out . write ( zeroBytes ) ; return ; } int utfCount = <int> ; int maxSize = <int> ; for ( int i = <int> ; i < length ; i + + ) { int ch = str . charAt ( i ) ; if ( ( ch > <int> ) & ( ch < = <int> ) ) utfCount + = <int> ; else if ( ch < = <int> ) utfCount + = <int> ; else utfCount + = maxSize = <int> ; } if ( utfCount > <int> ) throw new UTFDataFormatException ( ) ; byte [ ] utfBytes = retrieveTemporaryBuffer ( utfCount + <int> ) ; int bufferLength = utfBytes . length ; if ( utfCount = = length ) { utfBytes [ <int> ] = ( byte ) ( utfCount > > <int> ) ; utfBytes [ <int> ] = ( byte ) utfCount ; int firstIndex = <int> ; for ( int offset = <int> ; offset < length ; offset + = bufferLength ) { int runLength = Math . min ( bufferLength - firstIndex , length - offset ) + firstIndex ; offset - = firstIndex ; for ( int i = firstIndex ; i < runLength ; i + + ) utfBytes [ i ] = ( byte ) str . charAt ( offset + i ) ; out . write ( utfBytes , <int> , runLength ) ; firstIndex = <int> ; } } else { int utfIndex = <int> ; int offset = <int> ; utfBytes [ <int> ] = ( byte ) ( utfCount > > <int> ) ; utfBytes [ <int> ] = ( byte ) utfCount ; while ( length > <int> ) { int charRunLength = ( utfBytes . length - utfIndex ) / maxSize ; if ( charRunLength < <int> & & charRunLength < length ) { out . write ( utfBytes , <int> , utfIndex ) ; utfIndex = <int> ; } if ( charRunLength > length ) charRunLength = length ; for ( int i = <int> ; i < charRunLength ; i + + ) { char ch = str . charAt ( offset + i ) ; if ( ( ch > <int> ) & & ( ch < = <int> ) ) { utfBytes [ utfIndex + + ] = ( byte ) ch ; } else if ( ch < = <int> ) { utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( ch > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ch ) ) ; } else { utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( ch > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( ch > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ch ) ) ; } } offset + = charRunLength ; length - = charRunLength ; } out . write ( utfBytes , <int> , utfIndex ) ; } } public final void writeUTF ( String str ) throws IOException { writeUTF ( str , this ) ; } private final ByteBuffer hollowBufferD = MemoryUtil . getHollowDirectByteBuffer ( ) ; @Override public void write ( ByteBuffer buf ) throws IOException { if ( buf . hasArray ( ) ) { write ( buf . array ( ) , buf . arrayOffset ( ) + buf . position ( ) , buf . remaining ( ) ) ; } else { assert buf . isDirect ( ) ; MemoryUtil . duplicateDirectByteBuffer ( buf , hollowBufferD ) ; while ( hollowBufferD . hasRemaining ( ) ) channel . write ( hollowBufferD ) ; } } public void write ( Memory memory , long offset , long length ) throws IOException { for ( ByteBuffer buffer : memory . asByteBuffers ( offset , length ) ) write ( buffer ) ; } @Override public < R > R applyToChannel ( Function < WritableByteChannel , R > f ) throws IOException { return f . apply ( channel ) ; } }