package org . apache . cassandra . io . util ; import java . io . * ; import java . nio . channels . FileChannel ; import java . nio . file . StandardOpenOption ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . compress . BufferType ; import org . apache . cassandra . io . compress . CompressedSequentialWriter ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . utils . concurrent . Transactional ; import static org . apache . cassandra . utils . Throwables . merge ; import org . apache . cassandra . utils . SyncUtil ; public class SequentialWriter extends BufferedDataOutputStreamPlus implements Transactional { private static final int DEFAULT_BUFFER_SIZE = <int> * <int> ; private final String filePath ; protected long bufferOffset ; protected final FileChannel fchannel ; private boolean trickleFsync ; private int trickleFsyncByteInterval ; private int bytesSinceTrickleFsync = <int> ; protected long lastFlushOffset ; protected Runnable runPostFlush ; private final TransactionalProxy txnProxy = txnProxy ( ) ; private boolean finishOnClose ; protected Descriptor descriptor ; protected class TransactionalProxy extends AbstractTransactional { @Override protected Throwable doPreCleanup ( Throwable accumulate ) { try { channel . close ( ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } if ( buffer ! = null ) { try { FileUtils . clean ( buffer ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } buffer = null ; } return accumulate ; } protected void doPrepare ( ) { syncInternal ( ) ; } protected Throwable doCommit ( Throwable accumulate ) { return accumulate ; } protected Throwable doAbort ( Throwable accumulate ) { return accumulate ; } } private static FileChannel openChannel ( File file ) { try { if ( file . exists ( ) ) { return FileChannel . open ( file . toPath ( ) , StandardOpenOption . READ , StandardOpenOption . WRITE ) ; } else { FileChannel channel = FileChannel . open ( file . toPath ( ) , StandardOpenOption . READ , StandardOpenOption . WRITE , StandardOpenOption . CREATE_NEW ) ; try { SyncUtil . trySyncDir ( file . getParentFile ( ) ) ; } catch ( Throwable t ) { try { channel . close ( ) ; } catch ( Throwable t2 ) { t . addSuppressed ( t2 ) ; } } return channel ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public SequentialWriter ( File file , int bufferSize , BufferType bufferType ) { super ( openChannel ( file ) , bufferType . allocate ( bufferSize ) ) ; strictFlushing = true ; fchannel = ( FileChannel ) channel ; filePath = file . getAbsolutePath ( ) ; this . trickleFsync = DatabaseDescriptor . getTrickleFsync ( ) ; this . trickleFsyncByteInterval = DatabaseDescriptor . getTrickleFsyncIntervalInKb ( ) * <int> ; } public static SequentialWriter open ( File file ) { return new SequentialWriter ( file , DEFAULT_BUFFER_SIZE , BufferType . ON_HEAP ) ; } public static ChecksummedSequentialWriter open ( File file , File crcPath ) { return new ChecksummedSequentialWriter ( file , DEFAULT_BUFFER_SIZE , crcPath ) ; } public static CompressedSequentialWriter open ( String dataFilePath , String offsetsPath , CompressionParams parameters , MetadataCollector sstableMetadataCollector ) { return new CompressedSequentialWriter ( new File ( dataFilePath ) , offsetsPath , parameters , sstableMetadataCollector ) ; } public SequentialWriter finishOnClose ( ) { finishOnClose = true ; return this ; } public void sync ( ) { syncInternal ( ) ; } protected void syncDataOnlyInternal ( ) { try { SyncUtil . force ( fchannel , false ) ; } catch ( IOException e ) { throw new FSWriteError ( e , getPath ( ) ) ; } } protected void syncInternal ( ) { doFlush ( <int> ) ; syncDataOnlyInternal ( ) ; } @Override protected void doFlush ( int count ) { flushData ( ) ; if ( trickleFsync ) { bytesSinceTrickleFsync + = buffer . position ( ) ; if ( bytesSinceTrickleFsync > = trickleFsyncByteInterval ) { syncDataOnlyInternal ( ) ; bytesSinceTrickleFsync = <int> ; } } resetBuffer ( ) ; } public void setPostFlushListener ( Runnable runPostFlush ) { assert this . runPostFlush = = null ; this . runPostFlush = runPostFlush ; } protected void flushData ( ) { try { buffer . flip ( ) ; channel . write ( buffer ) ; lastFlushOffset + = buffer . position ( ) ; } catch ( IOException e ) { throw new FSWriteError ( e , getPath ( ) ) ; } if ( runPostFlush ! = null ) runPostFlush . run ( ) ; } public boolean hasPosition ( ) { return true ; } public long position ( ) { return current ( ) ; } public long getOnDiskFilePointer ( ) { return position ( ) ; } public long length ( ) { try { return Math . max ( current ( ) , fchannel . size ( ) ) ; } catch ( IOException e ) { throw new FSReadError ( e , getPath ( ) ) ; } } public String getPath ( ) { return filePath ; } protected void resetBuffer ( ) { bufferOffset = current ( ) ; buffer . clear ( ) ; } protected long current ( ) { return bufferOffset + ( buffer = = null ? <int> : buffer . position ( ) ) ; } public FileMark mark ( ) { return new BufferedFileWriterMark ( current ( ) ) ; } public void resetAndTruncate ( FileMark mark ) { assert mark instanceof BufferedFileWriterMark ; long previous = current ( ) ; long truncateTarget = ( ( BufferedFileWriterMark ) mark ) . pointer ; if ( previous - truncateTarget < = buffer . position ( ) ) { buffer . position ( buffer . position ( ) - ( ( int ) ( previous - truncateTarget ) ) ) ; return ; } syncInternal ( ) ; truncate ( truncateTarget ) ; try { fchannel . position ( truncateTarget ) ; } catch ( IOException e ) { throw new FSReadError ( e , getPath ( ) ) ; } resetBuffer ( ) ; } public long getLastFlushOffset ( ) { return lastFlushOffset ; } public void truncate ( long toSize ) { try { fchannel . truncate ( toSize ) ; } catch ( IOException e ) { throw new FSWriteError ( e , getPath ( ) ) ; } } public boolean isOpen ( ) { return channel . isOpen ( ) ; } public SequentialWriter setDescriptor ( Descriptor descriptor ) { this . descriptor = descriptor ; return this ; } public final void prepareToCommit ( ) { txnProxy . prepareToCommit ( ) ; } public final Throwable commit ( Throwable accumulate ) { return txnProxy . commit ( accumulate ) ; } public final Throwable abort ( Throwable accumulate ) { return txnProxy . abort ( accumulate ) ; } @Override public final void close ( ) { if ( finishOnClose ) txnProxy . finish ( ) ; else txnProxy . close ( ) ; } public final void finish ( ) { txnProxy . finish ( ) ; } protected TransactionalProxy txnProxy ( ) { return new TransactionalProxy ( ) ; } protected static class BufferedFileWriterMark implements FileMark { final long pointer ; public BufferedFileWriterMark ( long pointer ) { this . pointer = pointer ; } } } 
