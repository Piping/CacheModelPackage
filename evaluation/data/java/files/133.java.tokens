package org . apache . cassandra . dht ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . BufferDecoratedKey ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . marshal . PartitionerDefinedOrder ; import org . apache . cassandra . dht . KeyCollisionTest . BigIntegerToken ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; public class LengthPartitioner implements IPartitioner { public static final BigInteger ZERO = new BigInteger ( <str> ) ; public static final BigIntegerToken MINIMUM = new BigIntegerToken ( <str> ) ; public static LengthPartitioner instance = new LengthPartitioner ( ) ; public DecoratedKey decorateKey ( ByteBuffer key ) { return new BufferDecoratedKey ( getToken ( key ) , key ) ; } public BigIntegerToken midpoint ( Token ltoken , Token rtoken ) { BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , <int> ) ; return new BigIntegerToken ( midpair . left ) ; } public BigIntegerToken getMinimumToken ( ) { return MINIMUM ; } public BigIntegerToken getRandomToken ( ) { return new BigIntegerToken ( BigInteger . valueOf ( new Random ( ) . nextInt ( <int> ) ) ) ; } private final Token . TokenFactory tokenFactory = new Token . TokenFactory ( ) { public ByteBuffer toByteArray ( Token token ) { BigIntegerToken bigIntegerToken = ( BigIntegerToken ) token ; return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; } public Token fromByteArray ( ByteBuffer bytes ) { return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; } public String toString ( Token token ) { BigIntegerToken bigIntegerToken = ( BigIntegerToken ) token ; return bigIntegerToken . token . toString ( ) ; } public Token fromString ( String string ) { return new BigIntegerToken ( new BigInteger ( string ) ) ; } public void validate ( String token ) { } } ; public Token . TokenFactory getTokenFactory ( ) { return tokenFactory ; } public boolean preservesOrder ( ) { return false ; } public BigIntegerToken getToken ( ByteBuffer key ) { if ( key . remaining ( ) = = <int> ) return MINIMUM ; return new BigIntegerToken ( BigInteger . valueOf ( key . remaining ( ) ) ) ; } public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) { Map < Token , Float > allTokens = new HashMap < Token , Float > ( ) ; List < Range < Token > > sortedRanges = new ArrayList < Range < Token > > ( ) ; Token lastToken = sortedTokens . get ( sortedTokens . size ( ) - <int> ) ; for ( Token node : sortedTokens ) { allTokens . put ( node , new Float ( <float> ) ) ; sortedRanges . add ( new Range < Token > ( lastToken , node ) ) ; lastToken = node ; } for ( String ks : Schema . instance . getKeyspaces ( ) ) { for ( CFMetaData cfmd : Schema . instance . getTablesAndViews ( ks ) ) { for ( Range < Token > r : sortedRanges ) { allTokens . put ( r . right , allTokens . get ( r . right ) + StorageService . instance . getSplits ( ks , cfmd . cfName , r , <int> ) . size ( ) ) ; } } } Float total = new Float ( <float> ) ; for ( Float f : allTokens . values ( ) ) total + = f ; for ( Map . Entry < Token , Float > row : allTokens . entrySet ( ) ) allTokens . put ( row . getKey ( ) , row . getValue ( ) / total ) ; return allTokens ; } public AbstractType < ? > getTokenValidator ( ) { return IntegerType . instance ; } public AbstractType < ? > partitionOrdering ( ) { return new PartitionerDefinedOrder ( this ) ; } } 
