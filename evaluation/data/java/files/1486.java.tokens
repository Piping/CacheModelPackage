package org . gradle . api . internal . file . collections ; import org . gradle . api . file . FileVisitDetails ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . file . RelativePath ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . util . PatternSet ; import org . gradle . internal . Factory ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . gradle . testfixtures . internal . NativeServicesTestFixture ; import org . gradle . util . JUnit4GroovyMockery ; import org . hamcrest . BaseMatcher ; import org . hamcrest . Description ; import org . hamcrest . Matcher ; import org . jmock . Expectations ; import org . jmock . Mockery ; import org . jmock . Sequence ; import org . jmock . api . Action ; import org . jmock . api . Invocation ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class DefaultDirectoryWalkerTest { @Rule public final TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; private FileVisitor visitor ; private Factory < DirectoryWalker > directoryWalkerFactory = new Factory < DirectoryWalker > ( ) { DirectoryWalker directoryWalker = new DefaultDirectoryWalker ( ) ; @Override public DirectoryWalker create ( ) { return directoryWalker ; } } ; @Before public void setUp ( ) { NativeServicesTestFixture . initialize ( ) ; visitor = context . mock ( FileVisitor . class ) ; } @Test public void rootDirEmpty ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; root . setExpectations ( ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( root . getMock ( ) , new PatternSet ( ) , directoryWalkerFactory ) ; root . setExpectations ( ) ; fileTree . visit ( visitor ) ; } @Test public void testUsesSpecFromPatternSetToMatchFilesAndDirs ( ) { final PatternSet patternSet = context . mock ( PatternSet . class ) ; final Spec spec = context . mock ( Spec . class ) ; context . checking ( new Expectations ( ) { { one ( patternSet ) . getAsSpec ( ) ; will ( returnValue ( spec ) ) ; } } ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( new File ( <str> ) , patternSet , directoryWalkerFactory ) ; fileTree . visit ( visitor ) ; } @Test public void walkSingleFile ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; final MockFile fileToCopy = root . addFile ( <str> ) ; fileToCopy . setExpectations ( ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitFile ( with ( file ( fileToCopy ) ) ) ; } } ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( fileToCopy . getMock ( ) , new PatternSet ( ) , directoryWalkerFactory ) ; fileTree . visit ( visitor ) ; } @Test public void walkBreadthFirst ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; final MockFile rootFile1 = root . addFile ( <str> ) ; final MockFile dir1 = root . addDir ( <str> ) ; final MockFile dirFile1 = dir1 . addFile ( <str> ) ; final MockFile dirFile2 = dir1 . addFile ( <str> ) ; final MockFile rootFile2 = root . addFile ( <str> ) ; root . setExpectations ( ) ; final Sequence visiting = context . sequence ( <str> ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitFile ( with ( file ( rootFile1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( rootFile2 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitDir ( with ( file ( dir1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile2 ) ) ) ; inSequence ( visiting ) ; } } ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( root . getMock ( ) , new PatternSet ( ) , directoryWalkerFactory ) ; fileTree . visit ( visitor ) ; } @Test public void walkDepthFirst ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; final MockFile rootFile1 = root . addFile ( <str> ) ; final MockFile dir1 = root . addDir ( <str> ) ; final MockFile dirFile1 = dir1 . addFile ( <str> ) ; final MockFile dirFile2 = dir1 . addFile ( <str> ) ; final MockFile rootFile2 = root . addFile ( <str> ) ; root . setExpectations ( ) ; final Sequence visiting = context . sequence ( <str> ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitFile ( with ( file ( rootFile1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( rootFile2 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile2 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitDir ( with ( file ( dir1 ) ) ) ; inSequence ( visiting ) ; } } ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( root . getMock ( ) , new PatternSet ( ) , directoryWalkerFactory ) . postfix ( ) ; fileTree . visit ( visitor ) ; } @Test public void canApplyFilter ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; root . addFile ( <str> ) ; final MockFile dir1 = root . addDir ( <str> ) ; dir1 . addFile ( <str> ) ; final MockFile dirFile2 = dir1 . addFile ( <str> ) ; root . addFile ( <str> ) ; root . setExpectations ( ) ; final Sequence visiting = context . sequence ( <str> ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitDir ( with ( file ( dir1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile2 ) ) ) ; inSequence ( visiting ) ; } } ) ; PatternSet patterns = new PatternSet ( ) ; patterns . include ( <str> ) ; PatternSet filter = new PatternSet ( ) ; filter . include ( <str> ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( root . getMock ( ) , patterns , directoryWalkerFactory ) . filter ( filter ) ; fileTree . visit ( visitor ) ; } @Test public void canVisitorCanStopVisit ( ) throws IOException { final MockFile root = new MockFile ( context , <str> , false ) ; final MockFile rootFile1 = root . addFile ( <str> ) ; final MockFile dir1 = root . addDir ( <str> ) ; final MockFile dirFile1 = dir1 . addFile ( <str> ) ; dir1 . addFile ( <str> ) ; dir1 . addDir ( <str> ) . addFile ( <str> ) ; final MockFile rootFile2 = root . addFile ( <str> ) ; root . setExpectations ( ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitFile ( with ( file ( rootFile1 ) ) ) ; will ( stopVisiting ( ) ) ; } } ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( root . getMock ( ) , new PatternSet ( ) , directoryWalkerFactory ) ; fileTree . visit ( visitor ) ; final Sequence visiting = context . sequence ( <str> ) ; context . checking ( new Expectations ( ) { { one ( visitor ) . visitFile ( with ( file ( rootFile1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( rootFile2 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitDir ( with ( file ( dir1 ) ) ) ; inSequence ( visiting ) ; one ( visitor ) . visitFile ( with ( file ( dirFile1 ) ) ) ; will ( stopVisiting ( ) ) ; inSequence ( visiting ) ; } } ) ; fileTree . visit ( visitor ) ; } @Test public void canTestForFileMembership ( ) { TestFile rootDir = tmpDir . createDir ( <str> ) ; TestFile rootTextFile = rootDir . file ( <str> ) . createFile ( ) ; TestFile nestedTextFile = rootDir . file ( <str> ) . createFile ( ) ; TestFile notTextFile = rootDir . file ( <str> ) . createFile ( ) ; TestFile excludedFile = rootDir . file ( <str> ) . createFile ( ) ; TestFile notUnderRoot = tmpDir . createDir ( <str> ) . file ( <str> ) . createFile ( ) ; TestFile doesNotExist = rootDir . file ( <str> ) ; PatternSet patterns = new PatternSet ( ) ; patterns . include ( <str> ) ; patterns . exclude ( <str> ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( rootDir , patterns , directoryWalkerFactory ) ; assertTrue ( fileTree . contains ( rootTextFile ) ) ; assertTrue ( fileTree . contains ( nestedTextFile ) ) ; assertFalse ( fileTree . contains ( notTextFile ) ) ; assertFalse ( fileTree . contains ( excludedFile ) ) ; assertFalse ( fileTree . contains ( notUnderRoot ) ) ; assertFalse ( fileTree . contains ( doesNotExist ) ) ; } @Test public void hasUsefulDisplayName ( ) { DirectoryFileTree treeWithNoIncludesOrExcludes = new DirectoryFileTree ( tmpDir . getTestDirectory ( ) , new PatternSet ( ) , directoryWalkerFactory ) ; PatternSet includesOnly = new PatternSet ( ) ; includesOnly . include ( <str> , <str> ) ; DirectoryFileTree treeWithIncludes = new DirectoryFileTree ( tmpDir . getTestDirectory ( ) , includesOnly , directoryWalkerFactory ) ; PatternSet excludesOnly = new PatternSet ( ) ; excludesOnly . exclude ( <str> , <str> ) ; DirectoryFileTree treeWithExcludes = new DirectoryFileTree ( tmpDir . getTestDirectory ( ) , excludesOnly , directoryWalkerFactory ) ; assertThat ( treeWithNoIncludesOrExcludes . getDisplayName ( ) , equalTo ( String . format ( <str> , tmpDir . getTestDirectory ( ) ) ) ) ; assertThat ( treeWithIncludes . getDisplayName ( ) , equalTo ( String . format ( <str> , tmpDir . getTestDirectory ( ) ) ) ) ; assertThat ( treeWithExcludes . getDisplayName ( ) , equalTo ( String . format ( <str> , tmpDir . getTestDirectory ( ) ) ) ) ; } private Action stopVisiting ( ) { return new Action ( ) { public void describeTo ( Description description ) { description . appendText ( <str> ) ; } public Object invoke ( Invocation invocation ) throws Throwable { FileVisitDetails details = ( FileVisitDetails ) invocation . getParameter ( <int> ) ; details . stopVisiting ( ) ; return null ; } } ; } private Matcher < FileVisitDetails > file ( final MockFile file ) { return new BaseMatcher < FileVisitDetails > ( ) { public boolean matches ( Object o ) { FileVisitDetails details = ( FileVisitDetails ) o ; return details . getFile ( ) . equals ( file . getMock ( ) ) & & details . getRelativePath ( ) . equals ( file . getRelativePath ( ) ) ; } public void describeTo ( Description description ) { description . appendText ( <str> ) . appendValue ( file . getMock ( ) ) . appendText ( <str> ) . appendValue ( file . getRelativePath ( ) ) ; } } ; } public class MockFile { private boolean isFile ; private String name ; private Mockery context ; private List < MockFile > children ; private File mock ; private MockFile parent ; public MockFile ( Mockery context , String name , boolean isFile ) { this . context = context ; this . name = name ; this . isFile = isFile ; children = new ArrayList < MockFile > ( ) ; mock = context . mock ( File . class , name ) ; } public File getMock ( ) { return mock ; } public MockFile addFile ( String name ) { MockFile child = new MockFile ( context , name , true ) ; child . setParent ( this ) ; children . add ( child ) ; return child ; } public MockFile addDir ( String name ) { MockFile child = new MockFile ( context , name , false ) ; child . setParent ( this ) ; children . add ( child ) ; return child ; } public void setParent ( MockFile parent ) { this . parent = parent ; } public RelativePath getRelativePath ( ) { if ( parent = = null ) { return new RelativePath ( isFile ) ; } else { return parent . getRelativePath ( ) . append ( isFile , name ) ; } } public void setExpectations ( ) { Expectations expectations = new Expectations ( ) ; setExpectations ( expectations ) ; context . checking ( expectations ) ; } public void setExpectations ( Expectations expectations ) { try { expectations . allowing ( mock ) . getCanonicalFile ( ) ; expectations . will ( expectations . returnValue ( mock ) ) ; } catch ( IOException th ) { } expectations . allowing ( mock ) . isFile ( ) ; expectations . will ( expectations . returnValue ( isFile ) ) ; expectations . allowing ( mock ) . getName ( ) ; expectations . will ( expectations . returnValue ( name ) ) ; expectations . allowing ( mock ) . exists ( ) ; expectations . will ( expectations . returnValue ( true ) ) ; expectations . allowing ( mock ) . lastModified ( ) ; expectations . will ( expectations . returnValue ( <int> ) ) ; expectations . allowing ( mock ) . length ( ) ; expectations . will ( expectations . returnValue ( <int> ) ) ; ArrayList < File > mockChildren = new ArrayList < File > ( children . size ( ) ) ; for ( MockFile child : children ) { mockChildren . add ( child . getMock ( ) ) ; child . setExpectations ( expectations ) ; } expectations . allowing ( mock ) . listFiles ( ) ; expectations . will ( expectations . returnValue ( mockChildren . toArray ( new File [ mockChildren . size ( ) ] ) ) ) ; } } } 
