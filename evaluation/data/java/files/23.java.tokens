package org . apache . cassandra . io . sstable ; import java . io . File ; import java . io . IOException ; import java . util . Map ; import java . util . TreeMap ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . SynchronousQueue ; import java . util . concurrent . TimeUnit ; import com . google . common . base . Throwables ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . EncodingStats ; import org . apache . cassandra . db . rows . UnfilteredSerializer ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . utils . JVMStabilityInspector ; class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter { private static final Buffer SENTINEL = new Buffer ( ) ; private Buffer buffer = new Buffer ( ) ; private final long bufferSize ; private long currentSize ; private final SerializationHeader header ; private final BlockingQueue < Buffer > writeQueue = new SynchronousQueue < Buffer > ( ) ; private final DiskWriter diskWriter = new DiskWriter ( ) ; SSTableSimpleUnsortedWriter ( File directory , CFMetaData metadata , PartitionColumns columns , long bufferSizeInMB ) { super ( directory , metadata , columns ) ; this . bufferSize = bufferSizeInMB * <int> * <int> ; this . header = new SerializationHeader ( true , metadata , columns , EncodingStats . NO_STATS ) ; diskWriter . start ( ) ; } PartitionUpdate getUpdateFor ( DecoratedKey key ) { assert key ! = null ; PartitionUpdate previous = buffer . get ( key ) ; if ( previous = = null ) { previous = createPartitionUpdate ( key ) ; currentSize + = PartitionUpdate . serializer . serializedSize ( previous , formatType . info . getLatestVersion ( ) . correspondingMessagingVersion ( ) ) ; previous . allowNewUpdates ( ) ; buffer . put ( key , previous ) ; } return previous ; } private void countRow ( Row row ) { currentSize + = UnfilteredSerializer . serializer . serializedSize ( row , header , <int> , formatType . info . getLatestVersion ( ) . correspondingMessagingVersion ( ) ) ; } private void maybeSync ( ) throws SyncException { try { if ( currentSize > bufferSize ) sync ( ) ; } catch ( IOException e ) { throw new SyncException ( e ) ; } } private PartitionUpdate createPartitionUpdate ( DecoratedKey key ) { return new PartitionUpdate ( metadata , key , columns , <int> ) { @Override public void add ( Row row ) { super . add ( row ) ; countRow ( row ) ; maybeSync ( ) ; } } ; } @Override public void close ( ) throws IOException { sync ( ) ; put ( SENTINEL ) ; try { diskWriter . join ( ) ; checkForWriterException ( ) ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } checkForWriterException ( ) ; } protected void sync ( ) throws IOException { if ( buffer . isEmpty ( ) ) return ; put ( buffer ) ; buffer = new Buffer ( ) ; currentSize = <int> ; } private void put ( Buffer buffer ) throws IOException { while ( true ) { checkForWriterException ( ) ; try { if ( writeQueue . offer ( buffer , <int> , TimeUnit . SECONDS ) ) break ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } private void checkForWriterException ( ) throws IOException { if ( diskWriter . exception ! = null ) { if ( diskWriter . exception instanceof IOException ) throw ( IOException ) diskWriter . exception ; else throw Throwables . propagate ( diskWriter . exception ) ; } } static class SyncException extends RuntimeException { SyncException ( IOException ioe ) { super ( ioe ) ; } } static class Buffer extends TreeMap < DecoratedKey , PartitionUpdate > { } private class DiskWriter extends Thread { volatile Throwable exception = null ; public void run ( ) { while ( true ) { try { Buffer b = writeQueue . take ( ) ; if ( b = = SENTINEL ) return ; try ( SSTableTxnWriter writer = createWriter ( ) ) { for ( Map . Entry < DecoratedKey , PartitionUpdate > entry : b . entrySet ( ) ) writer . append ( entry . getValue ( ) . unfilteredIterator ( ) ) ; writer . finish ( false ) ; } } catch ( Throwable e ) { JVMStabilityInspector . inspectThrowable ( e ) ; if ( exception = = null ) exception = e ; } } } } } 
