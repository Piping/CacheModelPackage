package rx ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyString ; import static org . mockito . Matchers . isA ; import static org . mockito . Mockito . inOrder ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import rx . Observable . OnSubscribe ; import rx . Observable . Transformer ; import rx . exceptions . OnErrorNotImplementedException ; import rx . functions . Action1 ; import rx . functions . Action2 ; import rx . functions . Func0 ; import rx . functions . Func1 ; import rx . functions . Func2 ; import rx . observables . ConnectableObservable ; import rx . observers . TestSubscriber ; import rx . schedulers . TestScheduler ; import rx . subjects . ReplaySubject ; import rx . subjects . Subject ; import rx . subscriptions . BooleanSubscription ; public class ObservableTests { @Mock Observer < Integer > w ; private static final Func1 < Integer , Boolean > IS_EVEN = new Func1 < Integer , Boolean > ( ) { @Override public Boolean call ( Integer value ) { return value % <int> = = <int> ; } } ; @Before public void before ( ) { MockitoAnnotations . initMocks ( this ) ; } @Test public void fromArray ( ) { String [ ] items = new String [ ] { <str> , <str> , <str> } ; assertEquals ( new Integer ( <int> ) , Observable . from ( items ) . count ( ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , Observable . from ( items ) . skip ( <int> ) . take ( <int> ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , Observable . from ( items ) . takeLast ( <int> ) . toBlocking ( ) . single ( ) ) ; } @Test public void fromIterable ( ) { ArrayList < String > items = new ArrayList < String > ( ) ; items . add ( <str> ) ; items . add ( <str> ) ; items . add ( <str> ) ; assertEquals ( new Integer ( <int> ) , Observable . from ( items ) . count ( ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , Observable . from ( items ) . skip ( <int> ) . take ( <int> ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , Observable . from ( items ) . takeLast ( <int> ) . toBlocking ( ) . single ( ) ) ; } @Test public void fromArityArgs3 ( ) { Observable < String > items = Observable . just ( <str> , <str> , <str> ) ; assertEquals ( new Integer ( <int> ) , items . count ( ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , items . skip ( <int> ) . take ( <int> ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , items . takeLast ( <int> ) . toBlocking ( ) . single ( ) ) ; } @Test public void fromArityArgs1 ( ) { Observable < String > items = Observable . just ( <str> ) ; assertEquals ( new Integer ( <int> ) , items . count ( ) . toBlocking ( ) . single ( ) ) ; assertEquals ( <str> , items . takeLast ( <int> ) . toBlocking ( ) . single ( ) ) ; } @Test public void testCreate ( ) { Observable < String > observable = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > Observer ) { Observer . onNext ( <str> ) ; Observer . onNext ( <str> ) ; Observer . onNext ( <str> ) ; Observer . onCompleted ( ) ; } } ) ; @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testCountAFewItems ( ) { Observable < String > observable = Observable . just ( <str> , <str> , <str> , <str> ) ; observable . count ( ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testCountZeroItems ( ) { Observable < String > observable = Observable . empty ( ) ; observable . count ( ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testCountError ( ) { Observable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > obsv ) { obsv . onError ( new RuntimeException ( ) ) ; } } ) ; o . count ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onCompleted ( ) ; verify ( w , times ( <int> ) ) . onError ( any ( RuntimeException . class ) ) ; } public void testTakeFirstWithPredicateOfSome ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> ) ; observable . takeFirst ( IS_EVEN ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testTakeFirstWithPredicateOfNoneMatchingThePredicate ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; observable . takeFirst ( IS_EVEN ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testTakeFirstOfSome ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> ) ; observable . take ( <int> ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testTakeFirstOfNone ( ) { Observable < Integer > observable = Observable . empty ( ) ; observable . take ( <int> ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( <int> ) ) . onCompleted ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testFirstOfNone ( ) { Observable < Integer > observable = Observable . empty ( ) ; observable . first ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onCompleted ( ) ; verify ( w , times ( <int> ) ) . onError ( isA ( NoSuchElementException . class ) ) ; } @Test public void testFirstWithPredicateOfNoneMatchingThePredicate ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; observable . first ( IS_EVEN ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onCompleted ( ) ; verify ( w , times ( <int> ) ) . onError ( isA ( NoSuchElementException . class ) ) ; } @Test public void testReduce ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> ) ; observable . reduce ( new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; } @Test ( expected = NoSuchElementException . class ) public void testReduceWithEmptyObservable ( ) { Observable < Integer > observable = Observable . range ( <int> , <int> ) ; observable . reduce ( new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ) . toBlocking ( ) . forEach ( new Action1 < Integer > ( ) { @Override public void call ( Integer t1 ) { } } ) ; fail ( <str> ) ; } @Test public void testReduceWithEmptyObservableAndSeed ( ) { Observable < Integer > observable = Observable . range ( <int> , <int> ) ; int value = observable . reduce ( <int> , new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ) . toBlocking ( ) . last ( ) ; assertEquals ( <int> , value ) ; } @Test public void testReduceWithInitialValue ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> , <int> ) ; observable . reduce ( <int> , new Func2 < Integer , Integer , Integer > ( ) { @Override public Integer call ( Integer t1 , Integer t2 ) { return t1 + t2 ; } } ) . subscribe ( w ) ; verify ( w , times ( <int> ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( <int> ) ; } @Test public void testOnSubscribeFails ( ) { @SuppressWarnings ( <str> ) Observer < String > observer = mock ( Observer . class ) ; final RuntimeException re = new RuntimeException ( <str> ) ; Observable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > t1 ) { throw re ; } } ) ; o . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( anyString ( ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; verify ( observer , times ( <int> ) ) . onError ( re ) ; } @Test public void testMaterializeDematerializeChaining ( ) { Observable < Integer > obs = Observable . just ( <int> ) ; Observable < Integer > chained = obs . materialize ( ) . dematerialize ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; chained . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; verify ( observer , times ( <int> ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testCustomObservableWithErrorInObserverAsynchronous ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { final BooleanSubscription s = new BooleanSubscription ( ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { if ( ! s . isUnsubscribed ( ) ) { observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } finally { latch . countDown ( ) ; } } } ) . start ( ) ; } } ) . subscribe ( new Subscriber < String > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; } @Override public void onError ( Throwable e ) { error . set ( e ) ; System . out . println ( <str> ) ; e . printStackTrace ( ) ; } @Override public void onNext ( String v ) { int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; } } ) ; latch . await ( ) ; assertEquals ( <int> , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) { fail ( <str> ) ; } } @Test public void testCustomObservableWithErrorInObserverSynchronous ( ) { final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ) . subscribe ( new Subscriber < String > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; } @Override public void onError ( Throwable e ) { error . set ( e ) ; System . out . println ( <str> ) ; e . printStackTrace ( ) ; } @Override public void onNext ( String v ) { int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; } } ) ; assertEquals ( <int> , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) { fail ( <str> ) ; } } @Test public void testCustomObservableWithErrorInObservableSynchronous ( ) { final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > observer ) { observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; throw new NumberFormatException ( ) ; } } ) . subscribe ( new Subscriber < String > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; } @Override public void onError ( Throwable e ) { error . set ( e ) ; System . out . println ( <str> ) ; e . printStackTrace ( ) ; } @Override public void onNext ( String v ) { System . out . println ( v ) ; count . incrementAndGet ( ) ; } } ) ; assertEquals ( <int> , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) { fail ( <str> ) ; } } @Test public void testPublishLast ( ) throws InterruptedException { final AtomicInteger count = new AtomicInteger ( ) ; ConnectableObservable < String > connectable = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { count . incrementAndGet ( ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { observer . onNext ( <str> ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ) . start ( ) ; } } ) . takeLast ( <int> ) . publish ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; connectable . subscribe ( new Action1 < String > ( ) { @Override public void call ( String value ) { assertEquals ( <str> , value ) ; latch . countDown ( ) ; } } ) ; connectable . subscribe ( new Action1 < String > ( ) { @Override public void call ( String ignored ) { } } ) ; Subscription subscription = connectable . connect ( ) ; assertTrue ( latch . await ( <int> , TimeUnit . MILLISECONDS ) ) ; assertEquals ( <int> , count . get ( ) ) ; subscription . unsubscribe ( ) ; } @Test public void testReplay ( ) throws InterruptedException { final AtomicInteger counter = new AtomicInteger ( ) ; ConnectableObservable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { counter . incrementAndGet ( ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ) . start ( ) ; } } ) . replay ( ) ; Subscription s = o . connect ( ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } assertEquals ( <int> , counter . get ( ) ) ; } finally { s . unsubscribe ( ) ; } } @Test public void testCache ( ) throws InterruptedException { final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { counter . incrementAndGet ( ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ) . start ( ) ; } } ) . cache ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } assertEquals ( <int> , counter . get ( ) ) ; } @Test public void testCacheWithCapacity ( ) throws InterruptedException { final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { counter . incrementAndGet ( ) ; observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } ) . start ( ) ; } } ) . cacheWithInitialCapacity ( <int> ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; o . subscribe ( new Action1 < String > ( ) { @Override public void call ( String v ) { assertEquals ( <str> , v ) ; latch . countDown ( ) ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . MILLISECONDS ) ) { fail ( <str> ) ; } assertEquals ( <int> , counter . get ( ) ) ; } @Test public void testErrorThrownWithoutErrorHandlerSynchronous ( ) { try { Observable . error ( new RuntimeException ( <str> ) ) . subscribe ( new Action1 < Object > ( ) { @Override public void call ( Object t1 ) { } } ) ; fail ( <str> ) ; } catch ( Throwable e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } } @Test public void testErrorThrownWithoutErrorHandlerAsynchronous ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( final Subscriber < ? super String > observer ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { try { observer . onError ( new Error ( <str> ) ) ; } catch ( Throwable e ) { exception . set ( e ) ; } latch . countDown ( ) ; } } ) . start ( ) ; } } ) . subscribe ( new Action1 < String > ( ) { @Override public void call ( String t1 ) { } } ) ; latch . await ( <int> , TimeUnit . MILLISECONDS ) ; assertNotNull ( exception . get ( ) ) ; assertEquals ( <str> , exception . get ( ) . getMessage ( ) ) ; } @Test public void testTakeWithErrorInObserver ( ) { final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; Observable . just ( <str> , <str> , <str> , <str> ) . take ( <int> ) . subscribe ( new Subscriber < String > ( ) { @Override public void onCompleted ( ) { System . out . println ( <str> ) ; } @Override public void onError ( Throwable e ) { error . set ( e ) ; System . out . println ( <str> ) ; e . printStackTrace ( ) ; } @Override public void onNext ( String v ) { int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; } } ) ; assertEquals ( <int> , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) { fail ( <str> ) ; } } @Test public void testOfType ( ) { Observable < String > observable = Observable . just ( <int> , <str> , false , <int> ) . ofType ( String . class ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( <int> ) ; verify ( observer , times ( <int> ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( <int> ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testOfTypeWithPolymorphism ( ) { ArrayList < Integer > l1 = new ArrayList < Integer > ( ) ; l1 . add ( <int> ) ; LinkedList < Integer > l2 = new LinkedList < Integer > ( ) ; l2 . add ( <int> ) ; @SuppressWarnings ( <str> ) Observable < List > observable = Observable . < Object > just ( l1 , l2 , <str> ) . ofType ( List . class ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( l1 ) ; verify ( observer , times ( <int> ) ) . onNext ( l2 ) ; verify ( observer , never ( ) ) . onNext ( <str> ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testContains ( ) { Observable < Boolean > observable = Observable . just ( <str> , <str> , null ) . contains ( <str> ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testContainsWithInexistence ( ) { Observable < Boolean > observable = Observable . just ( <str> , <str> , null ) . contains ( <str> ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testContainsWithNull ( ) { Observable < Boolean > observable = Observable . just ( <str> , <str> , null ) . contains ( null ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testContainsWithEmptyObservable ( ) { Observable < Boolean > observable = Observable . < String > empty ( ) . contains ( <str> ) ; @SuppressWarnings ( <str> ) Observer < Object > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , times ( <int> ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( org . mockito . Matchers . any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testIgnoreElements ( ) { Observable < Integer > observable = Observable . just ( <int> , <int> , <int> ) . ignoreElements ( ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testJustWithScheduler ( ) { TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > observable = Observable . from ( Arrays . asList ( <int> , <int> ) ) . subscribeOn ( scheduler ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testStartWithWithScheduler ( ) { TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > observable = Observable . just ( <int> , <int> ) . startWith ( Arrays . asList ( <int> , <int> ) ) . subscribeOn ( scheduler ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testRangeWithScheduler ( ) { TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > observable = Observable . range ( <int> , <int> , scheduler ) ; @SuppressWarnings ( <str> ) Observer < Integer > observer = mock ( Observer . class ) ; observable . subscribe ( observer ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onNext ( <int> ) ; inOrder . verify ( observer , times ( <int> ) ) . onCompleted ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } @Test public void testCollectToList ( ) { Observable < List < Integer > > o = Observable . just ( <int> , <int> , <int> ) . collect ( new Func0 < List < Integer > > ( ) { @Override public List < Integer > call ( ) { return new ArrayList < Integer > ( ) ; } } , new Action2 < List < Integer > , Integer > ( ) { @Override public void call ( List < Integer > list , Integer v ) { list . add ( v ) ; } } ) ; List < Integer > list = o . toBlocking ( ) . last ( ) ; assertEquals ( <int> , list . size ( ) ) ; assertEquals ( <int> , list . get ( <int> ) . intValue ( ) ) ; assertEquals ( <int> , list . get ( <int> ) . intValue ( ) ) ; assertEquals ( <int> , list . get ( <int> ) . intValue ( ) ) ; List < Integer > list2 = o . toBlocking ( ) . last ( ) ; assertEquals ( <int> , list2 . size ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . intValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . intValue ( ) ) ; assertEquals ( <int> , list2 . get ( <int> ) . intValue ( ) ) ; } @Test public void testCollectToString ( ) { String value = Observable . just ( <int> , <int> , <int> ) . collect ( new Func0 < StringBuilder > ( ) { @Override public StringBuilder call ( ) { return new StringBuilder ( ) ; } } , new Action2 < StringBuilder , Integer > ( ) { @Override public void call ( StringBuilder sb , Integer v ) { if ( sb . length ( ) > <int> ) { sb . append ( <str> ) ; } sb . append ( v ) ; } } ) . toBlocking ( ) . last ( ) . toString ( ) ; assertEquals ( <str> , value ) ; } @Test public void testMergeWith ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . just ( <int> ) . mergeWith ( Observable . just ( <int> ) ) . subscribe ( ts ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> ) ) ; } @Test public void testConcatWith ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . just ( <int> ) . concatWith ( Observable . just ( <int> ) ) . subscribe ( ts ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> ) ) ; } @Test public void testAmbWith ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable . just ( <int> ) . ambWith ( Observable . just ( <int> ) ) . subscribe ( ts ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> ) ) ; } @Test ( expected = OnErrorNotImplementedException . class ) public void testSubscribeWithoutOnError ( ) { Observable < String > o = Observable . just ( <str> , <str> ) . flatMap ( new Func1 < String , Observable < String > > ( ) { @Override public Observable < String > call ( String s ) { return Observable . error ( new Exception ( <str> ) ) ; } } ) ; o . subscribe ( ) ; } @Test public void testTakeWhileToList ( ) { final int expectedCount = <int> ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = <int> ; i < expectedCount ; i + + ) { Observable . just ( Boolean . TRUE , Boolean . FALSE ) . takeWhile ( new Func1 < Boolean , Boolean > ( ) { @Override public Boolean call ( Boolean value ) { return value ; } } ) . toList ( ) . doOnNext ( new Action1 < List < Boolean > > ( ) { @Override public void call ( List < Boolean > booleans ) { count . incrementAndGet ( ) ; } } ) . subscribe ( ) ; } assertEquals ( expectedCount , count . get ( ) ) ; } @Test public void testCompose ( ) { TestSubscriber < String > ts = new TestSubscriber < String > ( ) ; Observable . just ( <int> , <int> , <int> ) . compose ( new Transformer < Integer , String > ( ) { @Override public Observable < String > call ( Observable < Integer > t1 ) { return t1 . map ( new Func1 < Integer , String > ( ) { @Override public String call ( Integer t1 ) { return String . valueOf ( t1 ) ; } } ) ; } } ) . subscribe ( ts ) ; ts . assertTerminalEvent ( ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <str> , <str> , <str> ) ) ; } @Test public void testErrorThrownIssue1685 ( ) { Subject < Object , Object > subject = ReplaySubject . create ( ) ; Observable . error ( new RuntimeException ( <str> ) ) . materialize ( ) . delay ( <int> , TimeUnit . SECONDS ) . dematerialize ( ) . subscribe ( subject ) ; subject . subscribe ( ) ; subject . materialize ( ) . toBlocking ( ) . first ( ) ; System . out . println ( <str> ) ; } @Test public void testEmptyIdentity ( ) { assertEquals ( Observable . empty ( ) , Observable . empty ( ) ) ; } @Test public void testEmptyIsEmpty ( ) { Observable . < Integer > empty ( ) . subscribe ( w ) ; verify ( w ) . onCompleted ( ) ; verify ( w , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; } @Test public void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain ( ) { TestSubscriber < Object > subscriber = new TestSubscriber < Object > ( ) ; Subscription subscription = Observable . just ( <str> ) . subscribe ( ( Observer < Object > ) subscriber ) ; subscription . unsubscribe ( ) ; subscriber . assertUnsubscribed ( ) ; } @Test ( expected = OnErrorNotImplementedException . class ) public void testForEachWithError ( ) { Observable . error ( new Exception ( <str> ) ) . forEach ( new Action1 < Object > ( ) { @Override public void call ( Object t ) { } } ) ; } @Test ( expected = IllegalArgumentException . class ) public void testForEachWithNull ( ) { Observable . error ( new Exception ( <str> ) ) . forEach ( null ) ; } @Test public void testExtend ( ) { final TestSubscriber < Object > subscriber = new TestSubscriber < Object > ( ) ; final Object value = new Object ( ) ; Observable . just ( value ) . extend ( new Func1 < OnSubscribe < Object > , Object > ( ) { @Override public Object call ( OnSubscribe < Object > onSubscribe ) { onSubscribe . call ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertCompleted ( ) ; subscriber . assertValue ( value ) ; return subscriber . getOnNextEvents ( ) . get ( <int> ) ; } } ) ; } } 
