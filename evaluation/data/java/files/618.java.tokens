package org . elasticsearch . common . unit ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public final class Fuzziness implements ToXContent , Writeable < Fuzziness > { public static final XContentBuilderString X_FIELD_NAME = new XContentBuilderString ( <str> ) ; public static final Fuzziness ZERO = new Fuzziness ( <int> ) ; public static final Fuzziness ONE = new Fuzziness ( <int> ) ; public static final Fuzziness TWO = new Fuzziness ( <int> ) ; public static final Fuzziness AUTO = new Fuzziness ( <str> ) ; public static final ParseField FIELD = new ParseField ( X_FIELD_NAME . camelCase ( ) . getValue ( ) ) ; private final String fuzziness ; static final Fuzziness PROTOTYPE = AUTO ; private Fuzziness ( int fuzziness ) { if ( fuzziness ! = <int> & & fuzziness ! = <int> & & fuzziness ! = <int> ) { throw new IllegalArgumentException ( <str> + fuzziness + <str> ) ; } this . fuzziness = Integer . toString ( fuzziness ) ; } private Fuzziness ( String fuzziness ) { if ( fuzziness = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . fuzziness = fuzziness . toUpperCase ( Locale . ROOT ) ; } public static Fuzziness fromEdits ( int edits ) { return new Fuzziness ( edits ) ; } public static Fuzziness build ( Object fuzziness ) { if ( fuzziness instanceof Fuzziness ) { return ( Fuzziness ) fuzziness ; } String string = fuzziness . toString ( ) ; if ( AUTO . asString ( ) . equalsIgnoreCase ( string ) ) { return AUTO ; } return new Fuzziness ( string ) ; } public static Fuzziness parse ( XContentParser parser ) throws IOException { XContentParser . Token token = parser . currentToken ( ) ; switch ( token ) { case VALUE_STRING : case VALUE_NUMBER : final String fuzziness = parser . text ( ) ; if ( AUTO . asString ( ) . equalsIgnoreCase ( fuzziness ) ) { return AUTO ; } try { final int minimumSimilarity = Integer . parseInt ( fuzziness ) ; switch ( minimumSimilarity ) { case <int> : return ZERO ; case <int> : return ONE ; case <int> : return TWO ; default : return build ( fuzziness ) ; } } catch ( NumberFormatException ex ) { return build ( fuzziness ) ; } default: throw new IllegalArgumentException ( <str> + token + <str> ) ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { return toXContent ( builder , params , true ) ; } public XContentBuilder toXContent ( XContentBuilder builder , Params params , boolean includeFieldName ) throws IOException { if ( includeFieldName ) { builder . field ( X_FIELD_NAME , fuzziness ) ; } else { builder . value ( fuzziness ) ; } return builder ; } public int asDistance ( ) { return asDistance ( null ) ; } public int asDistance ( String text ) { if ( this . equals ( AUTO ) ) { final int len = termLen ( text ) ; if ( len < = <int> ) { return <int> ; } else if ( len > <int> ) { return <int> ; } else { return <int> ; } } return Math . min ( <int> , asInt ( ) ) ; } public TimeValue asTimeValue ( ) { if ( this . equals ( AUTO ) ) { return TimeValue . timeValueMillis ( <int> ) ; } else { return TimeValue . parseTimeValue ( fuzziness . toString ( ) , null , <str> ) ; } } public long asLong ( ) { if ( this . equals ( AUTO ) ) { return <int> ; } try { return Long . parseLong ( fuzziness . toString ( ) ) ; } catch ( NumberFormatException ex ) { return ( long ) Double . parseDouble ( fuzziness . toString ( ) ) ; } } public int asInt ( ) { if ( this . equals ( AUTO ) ) { return <int> ; } try { return Integer . parseInt ( fuzziness . toString ( ) ) ; } catch ( NumberFormatException ex ) { return ( int ) Float . parseFloat ( fuzziness . toString ( ) ) ; } } public short asShort ( ) { if ( this . equals ( AUTO ) ) { return <int> ; } try { return Short . parseShort ( fuzziness . toString ( ) ) ; } catch ( NumberFormatException ex ) { return ( short ) Float . parseFloat ( fuzziness . toString ( ) ) ; } } public byte asByte ( ) { if ( this . equals ( AUTO ) ) { return <int> ; } try { return Byte . parseByte ( fuzziness . toString ( ) ) ; } catch ( NumberFormatException ex ) { return ( byte ) Float . parseFloat ( fuzziness . toString ( ) ) ; } } public double asDouble ( ) { if ( this . equals ( AUTO ) ) { return <int> d ; } return Double . parseDouble ( fuzziness . toString ( ) ) ; } public float asFloat ( ) { if ( this . equals ( AUTO ) ) { return <int> f ; } return Float . parseFloat ( fuzziness . toString ( ) ) ; } private int termLen ( String text ) { return text = = null ? <int> : text . codePointCount ( <int> , text . length ( ) ) ; } public String asString ( ) { return fuzziness . toString ( ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null | | getClass ( ) ! = obj . getClass ( ) ) { return false ; } Fuzziness other = ( Fuzziness ) obj ; return Objects . equals ( fuzziness , other . fuzziness ) ; } @Override public int hashCode ( ) { return fuzziness . hashCode ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( fuzziness ) ; } @Override public Fuzziness readFrom ( StreamInput in ) throws IOException { return new Fuzziness ( in . readString ( ) ) ; } public static Fuzziness readFuzzinessFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } } 
