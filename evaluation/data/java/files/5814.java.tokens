package rx . internal . operators ; import static java . util . Arrays . asList ; import static org . junit . Assert . * ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . * ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . * ; import org . junit . * ; import org . mockito . * ; import rx . * ; import rx . Observable . OnSubscribe ; import rx . Scheduler . Worker ; import rx . Observable ; import rx . Observer ; import rx . functions . * ; import rx . internal . util . RxRingBuffer ; import rx . observers . TestSubscriber ; import rx . schedulers . * ; import rx . subscriptions . Subscriptions ; public class OperatorMergeTest { @Mock Observer < String > stringObserver ; @Before public void before ( ) { MockitoAnnotations . initMocks ( this ) ; } @Test public void testMergeObservableOfObservables ( ) { final Observable < String > o1 = Observable . create ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . create ( new TestSynchronousObservable ( ) ) ; Observable < Observable < String > > observableOfObservables = Observable . create ( new Observable . OnSubscribe < Observable < String > > ( ) { @Override public void call ( Subscriber < ? super Observable < String > > observer ) { observer . onNext ( o1 ) ; observer . onNext ( o2 ) ; observer . onCompleted ( ) ; } } ) ; Observable < String > m = Observable . merge ( observableOfObservables ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; } @Test public void testMergeArray ( ) { final Observable < String > o1 = Observable . create ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . create ( new TestSynchronousObservable ( ) ) ; Observable < String > m = Observable . merge ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testMergeList ( ) { final Observable < String > o1 = Observable . create ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . create ( new TestSynchronousObservable ( ) ) ; List < Observable < String > > listOfObservables = new ArrayList < Observable < String > > ( ) ; listOfObservables . add ( o1 ) ; listOfObservables . add ( o2 ) ; Observable < String > m = Observable . merge ( listOfObservables ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; } @Test ( timeout = <int> ) public void testUnSubscribeObservableOfObservables ( ) throws InterruptedException { final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; Observable < Observable < Long > > source = Observable . create ( new Observable . OnSubscribe < Observable < Long > > ( ) { @Override public void call ( final Subscriber < ? super Observable < Long > > observer ) { final Subscription s = Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { System . out . println ( <str> ) ; unsubscribed . set ( true ) ; } } ) ; observer . add ( s ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { while ( ! unsubscribed . get ( ) ) { observer . onNext ( Observable . just ( <int> , <int> ) ) ; } System . out . println ( <str> + unsubscribed . get ( ) ) ; observer . onCompleted ( ) ; latch . countDown ( ) ; } } ) . start ( ) ; } } ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( source ) . take ( <int> ) . toBlocking ( ) . forEach ( new Action1 < Long > ( ) { @Override public void call ( Long v ) { System . out . println ( <str> + v ) ; int c = count . incrementAndGet ( ) ; if ( c > <int> ) { fail ( <str> ) ; } } } ) ; latch . await ( <int> , TimeUnit . MILLISECONDS ) ; System . out . println ( <str> + unsubscribed . get ( ) ) ; assertTrue ( unsubscribed . get ( ) ) ; } @Test public void testMergeArrayWithThreading ( ) { final TestASynchronousObservable o1 = new TestASynchronousObservable ( ) ; final TestASynchronousObservable o2 = new TestASynchronousObservable ( ) ; Observable < String > m = Observable . merge ( Observable . create ( o1 ) , Observable . create ( o2 ) ) ; TestSubscriber < String > ts = new TestSubscriber < String > ( stringObserver ) ; m . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onCompleted ( ) ; } @Test public void testSynchronizationOfMultipleSequences ( ) throws Throwable { final TestASynchronousObservable o1 = new TestASynchronousObservable ( ) ; final TestASynchronousObservable o2 = new TestASynchronousObservable ( ) ; final CountDownLatch endLatch = new CountDownLatch ( <int> ) ; final AtomicInteger concurrentCounter = new AtomicInteger ( ) ; final AtomicInteger totalCounter = new AtomicInteger ( ) ; Observable < String > m = Observable . merge ( Observable . create ( o1 ) , Observable . create ( o2 ) ) ; m . subscribe ( new Subscriber < String > ( ) { @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { throw new RuntimeException ( <str> , e ) ; } @Override public void onNext ( String v ) { totalCounter . incrementAndGet ( ) ; concurrentCounter . incrementAndGet ( ) ; try { endLatch . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( <str> , e ) ; } finally { concurrentCounter . decrementAndGet ( ) ; } } } ) ; o1 . onNextBeingSent . await ( ) ; o2 . onNextBeingSent . await ( ) ; Thread . sleep ( <int> ) ; try { assertEquals ( <int> , concurrentCounter . get ( ) ) ; } finally { endLatch . countDown ( ) ; } try { o1 . t . join ( ) ; o2 . t . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertEquals ( <int> , totalCounter . get ( ) ) ; assertEquals ( <int> , concurrentCounter . get ( ) ) ; } @Test public void testError1 ( ) { final Observable < String > o1 = Observable . create ( new TestErrorObservable ( <str> , null , <str> ) ) ; final Observable < String > o2 = Observable . create ( new TestErrorObservable ( <str> , <str> , <str> ) ) ; Observable < String > m = Observable . merge ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( <int> ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onCompleted ( ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; } @Test public void testError2 ( ) { final Observable < String > o1 = Observable . create ( new TestErrorObservable ( <str> , <str> , <str> ) ) ; final Observable < String > o2 = Observable . create ( new TestErrorObservable ( <str> , null , <str> ) ) ; final Observable < String > o3 = Observable . create ( new TestErrorObservable ( <str> , <str> , null ) ) ; final Observable < String > o4 = Observable . create ( new TestErrorObservable ( <str> ) ) ; Observable < String > m = Observable . merge ( o1 , o2 , o3 , o4 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( <int> ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onCompleted ( ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; verify ( stringObserver , times ( <int> ) ) . onNext ( <str> ) ; } @Test public void testThrownErrorHandling ( ) { TestSubscriber < String > ts = new TestSubscriber < String > ( ) ; Observable < String > o1 = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > s ) { throw new RuntimeException ( <str> ) ; } } ) ; Observable . merge ( o1 , o1 ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertTerminalEvent ( ) ; System . out . println ( <str> + ts . getOnErrorEvents ( ) ) ; } private static class TestSynchronousObservable implements Observable . OnSubscribe < String > { @Override public void call ( Subscriber < ? super String > observer ) { observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } } private static class TestASynchronousObservable implements Observable . OnSubscribe < String > { Thread t ; final CountDownLatch onNextBeingSent = new CountDownLatch ( <int> ) ; @Override public void call ( final Subscriber < ? super String > observer ) { t = new Thread ( new Runnable ( ) { @Override public void run ( ) { onNextBeingSent . countDown ( ) ; try { observer . onNext ( <str> ) ; observer . onCompleted ( ) ; } catch ( Exception e ) { observer . onError ( e ) ; } } } ) ; t . start ( ) ; } } private static class TestErrorObservable implements Observable . OnSubscribe < String > { String [ ] valuesToReturn ; TestErrorObservable ( String . . . values ) { valuesToReturn = values ; } @Override public void call ( Subscriber < ? super String > observer ) { for ( String s : valuesToReturn ) { if ( s = = null ) { System . out . println ( <str> ) ; observer . onError ( new NullPointerException ( ) ) ; } else { observer . onNext ( s ) ; } } observer . onCompleted ( ) ; } } @Test public void testUnsubscribeAsObservablesComplete ( ) { TestScheduler scheduler1 = Schedulers . test ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Observable < Long > o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = Schedulers . test ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Observable < Long > o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) ; Observable . merge ( o1 , o2 ) . subscribe ( ts ) ; ts . assertReceivedOnNext ( Collections . < Long > emptyList ( ) ) ; scheduler1 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler1 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler2 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; ts . assertTerminalEvent ( ) ; } @Test public void testEarlyUnsubscribe ( ) { for ( int i = <int> ; i < <int> ; i + + ) { TestScheduler scheduler1 = Schedulers . test ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Observable < Long > o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = Schedulers . test ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Observable < Long > o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) ; Subscription s = Observable . merge ( o1 , o2 ) . subscribe ( ts ) ; ts . assertReceivedOnNext ( Collections . < Long > emptyList ( ) ) ; scheduler1 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; s . unsubscribe ( ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; ts . assertReceivedOnNext ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ) ; ts . assertUnsubscribed ( ) ; } } private Observable < Long > createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( final Scheduler scheduler , final AtomicBoolean unsubscribed ) { return Observable . create ( new OnSubscribe < Long > ( ) { @Override public void call ( Subscriber < ? super Long > s ) { s . add ( Subscriptions . create ( new Action0 ( ) { @Override public void call ( ) { unsubscribed . set ( true ) ; } } ) ) ; Observable . interval ( <int> , TimeUnit . SECONDS , scheduler ) . take ( <int> ) . subscribe ( s ) ; } } ) ; } @Test public void testConcurrency ( ) { Observable < Integer > o = Observable . range ( <int> , <int> ) . subscribeOn ( Schedulers . newThread ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Observable < Integer > merge = Observable . merge ( o . onBackpressureBuffer ( ) , o . onBackpressureBuffer ( ) , o . onBackpressureBuffer ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; merge . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . SECONDS ) ; ts . assertTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnCompletedEvents ( ) . size ( ) ) ; List < Integer > onNextEvents = ts . getOnNextEvents ( ) ; assertEquals ( <int> , onNextEvents . size ( ) ) ; } } @Test public void testConcurrencyWithSleeping ( ) { Observable < Integer > o = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( final Subscriber < ? super Integer > s ) { Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; s . add ( inner ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { try { for ( int i = <int> ; i < <int> ; i + + ) { s . onNext ( <int> ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } catch ( Exception e ) { s . onError ( e ) ; } s . onCompleted ( ) ; } } ) ; } } ) ; for ( int i = <int> ; i < <int> ; i + + ) { Observable < Integer > merge = Observable . merge ( o , o , o ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; merge . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; assertEquals ( <int> , ts . getOnCompletedEvents ( ) . size ( ) ) ; List < Integer > onNextEvents = ts . getOnNextEvents ( ) ; assertEquals ( <int> , onNextEvents . size ( ) ) ; } } @Test public void testConcurrencyWithBrokenOnCompleteContract ( ) { Observable < Integer > o = Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( final Subscriber < ? super Integer > s ) { Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; s . add ( inner ) ; inner . schedule ( new Action0 ( ) { @Override public void call ( ) { try { for ( int i = <int> ; i < <int> ; i + + ) { s . onNext ( i ) ; } } catch ( Exception e ) { s . onError ( e ) ; } s . onCompleted ( ) ; s . onCompleted ( ) ; s . onCompleted ( ) ; } } ) ; } } ) ; for ( int i = <int> ; i < <int> ; i + + ) { Observable < Integer > merge = Observable . merge ( o . onBackpressureBuffer ( ) , o . onBackpressureBuffer ( ) , o . onBackpressureBuffer ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; merge . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnCompletedEvents ( ) . size ( ) ) ; List < Integer > onNextEvents = ts . getOnNextEvents ( ) ; assertEquals ( <int> , onNextEvents . size ( ) ) ; } } @Test public void testBackpressureUpstream ( ) throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Observable < Integer > o2 = createInfiniteObservable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) { @Override public void onNext ( Integer t ) { System . err . println ( <str> + t + <str> + Thread . currentThread ( ) ) ; super . onNext ( t ) ; } } ; Observable . merge ( o1 . take ( RxRingBuffer . SIZE * <int> ) , o2 . take ( RxRingBuffer . SIZE * <int> ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitTerminalEvent ( ) ; if ( testSubscriber . getOnErrorEvents ( ) . size ( ) > <int> ) { testSubscriber . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } testSubscriber . assertNoErrors ( ) ; System . err . println ( testSubscriber . getOnNextEvents ( ) ) ; assertEquals ( RxRingBuffer . SIZE * <int> , testSubscriber . getOnNextEvents ( ) . size ( ) ) ; System . out . println ( <str> + generated1 . get ( ) ) ; System . out . println ( <str> + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) > = RxRingBuffer . SIZE * <int> & & generated1 . get ( ) < = RxRingBuffer . SIZE * <int> ) ; } @Test public void testBackpressureUpstream2InLoop ( ) throws InterruptedException { for ( int i = <int> ; i < <int> ; i + + ) { System . err . flush ( ) ; System . out . println ( <str> ) ; System . out . flush ( ) ; testBackpressureUpstream2 ( ) ; } } @Test public void testBackpressureUpstream2 ( ) throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) { @Override public void onNext ( Integer t ) { super . onNext ( t ) ; } } ; Observable . merge ( o1 . take ( RxRingBuffer . SIZE * <int> ) , Observable . just ( - <int> ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitTerminalEvent ( ) ; List < Integer > onNextEvents = testSubscriber . getOnNextEvents ( ) ; System . out . println ( <str> + generated1 . get ( ) + <str> + onNextEvents . size ( ) ) ; System . out . println ( onNextEvents ) ; if ( testSubscriber . getOnErrorEvents ( ) . size ( ) > <int> ) { testSubscriber . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } testSubscriber . assertNoErrors ( ) ; assertEquals ( RxRingBuffer . SIZE * <int> + <int> , onNextEvents . size ( ) ) ; assertTrue ( generated1 . get ( ) > = RxRingBuffer . SIZE * <int> & & generated1 . get ( ) < = RxRingBuffer . SIZE * <int> ) ; } @Test ( timeout = <int> ) public void testBackpressureDownstreamWithConcurrentStreams ( ) throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Observable < Integer > o2 = createInfiniteObservable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) { @Override public void onNext ( Integer t ) { if ( t < <int> ) try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } super . onNext ( t ) ; } } ; Observable . merge ( o1 . take ( RxRingBuffer . SIZE * <int> ) , o2 . take ( RxRingBuffer . SIZE * <int> ) ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitTerminalEvent ( ) ; if ( testSubscriber . getOnErrorEvents ( ) . size ( ) > <int> ) { testSubscriber . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } testSubscriber . assertNoErrors ( ) ; System . err . println ( testSubscriber . getOnNextEvents ( ) ) ; assertEquals ( RxRingBuffer . SIZE * <int> , testSubscriber . getOnNextEvents ( ) . size ( ) ) ; System . out . println ( <str> + generated1 . get ( ) ) ; System . out . println ( <str> + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) > = RxRingBuffer . SIZE * <int> & & generated1 . get ( ) < = RxRingBuffer . SIZE * <int> ) ; } @Test public void testBackpressureBothUpstreamAndDownstreamWithSynchronousScalarObservables ( ) throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Observable < Integer > > o1 = createInfiniteObservable ( generated1 ) . map ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { return Observable . just ( t1 ) ; } } ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) { @Override public void onNext ( Integer t ) { if ( t < <int> ) try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } super . onNext ( t ) ; } } ; int limit = RxRingBuffer . SIZE ; Observable . merge ( o1 , limit ) . observeOn ( Schedulers . computation ( ) ) . take ( RxRingBuffer . SIZE * <int> ) . subscribe ( testSubscriber ) ; testSubscriber . awaitTerminalEvent ( ) ; if ( testSubscriber . getOnErrorEvents ( ) . size ( ) > <int> ) { testSubscriber . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } testSubscriber . assertNoErrors ( ) ; System . out . println ( <str> + generated1 . get ( ) ) ; System . err . println ( testSubscriber . getOnNextEvents ( ) ) ; assertEquals ( RxRingBuffer . SIZE * <int> , testSubscriber . getOnNextEvents ( ) . size ( ) ) ; assertTrue ( generated1 . get ( ) > = RxRingBuffer . SIZE * <int> & & generated1 . get ( ) < = RxRingBuffer . SIZE * <int> ) ; } @Test ( timeout = <int> ) public void testBackpressureBothUpstreamAndDownstreamWithRegularObservables ( ) throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Observable < Integer > > o1 = createInfiniteObservable ( generated1 ) . map ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t1 ) { return Observable . just ( <int> , <int> , <int> ) ; } } ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) { int i = <int> ; @Override public void onNext ( Integer t ) { if ( i + + < <int> ) try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } super . onNext ( t ) ; } } ; Observable . merge ( o1 ) . observeOn ( Schedulers . computation ( ) ) . take ( RxRingBuffer . SIZE * <int> ) . subscribe ( testSubscriber ) ; testSubscriber . awaitTerminalEvent ( ) ; if ( testSubscriber . getOnErrorEvents ( ) . size ( ) > <int> ) { testSubscriber . getOnErrorEvents ( ) . get ( <int> ) . printStackTrace ( ) ; } testSubscriber . assertNoErrors ( ) ; System . out . println ( <str> + generated1 . get ( ) ) ; System . err . println ( testSubscriber . getOnNextEvents ( ) ) ; System . out . println ( <str> ) ; assertEquals ( RxRingBuffer . SIZE * <int> , testSubscriber . getOnNextEvents ( ) . size ( ) ) ; System . out . println ( <str> ) ; } @Test public void mergeWithNullValues ( ) { System . out . println ( <str> ) ; TestSubscriber < String > ts = new TestSubscriber < String > ( ) ; Observable . merge ( Observable . just ( null , <str> ) , Observable . just ( <str> , null ) ) . subscribe ( ts ) ; ts . assertTerminalEvent ( ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( null , <str> , <str> , null ) ) ; } @Test public void mergeWithTerminalEventAfterUnsubscribe ( ) { System . out . println ( <str> ) ; TestSubscriber < String > ts = new TestSubscriber < String > ( ) ; Observable < String > bad = Observable . create ( new OnSubscribe < String > ( ) { @Override public void call ( Subscriber < ? super String > s ) { s . onNext ( <str> ) ; s . unsubscribe ( ) ; s . onCompleted ( ) ; } } ) ; Observable . merge ( Observable . just ( null , <str> ) , bad ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( null , <str> , <str> ) ) ; } @Test public void mergingNullObservable ( ) { TestSubscriber < String > ts = new TestSubscriber < String > ( ) ; Observable . merge ( Observable . just ( <str> ) , null ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( Arrays . asList ( <str> ) ) ; } @Test public void merge1AsyncStreamOf1 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge1AsyncStreamOf1000 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge10AsyncStreamOf1000 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge1000AsyncStreamOf1000 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge2000AsyncStreamOf100 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge100AsyncStreamOf1 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNAsyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } private Observable < Integer > mergeNAsyncStreamsOfN ( final int outerSize , final int innerSize ) { Observable < Observable < Integer > > os = Observable . range ( <int> , outerSize ) . map ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer i ) { return Observable . range ( <int> , innerSize ) . subscribeOn ( Schedulers . computation ( ) ) ; } } ) ; return Observable . merge ( os ) ; } @Test public void merge1SyncStreamOf1 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNSyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge1SyncStreamOf1000000 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNSyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge1000SyncStreamOf1000 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNSyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge10000SyncStreamOf10 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNSyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void merge1000000SyncStreamOf1 ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; mergeNSyncStreamsOfN ( <int> , <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } private Observable < Integer > mergeNSyncStreamsOfN ( final int outerSize , final int innerSize ) { Observable < Observable < Integer > > os = Observable . range ( <int> , outerSize ) . map ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer i ) { return Observable . range ( <int> , innerSize ) ; } } ) ; return Observable . merge ( os ) ; } private Observable < Integer > createInfiniteObservable ( final AtomicInteger generated ) { return Observable . from ( new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { @Override public void remove ( ) { } @Override public Integer next ( ) { return generated . getAndIncrement ( ) ; } @Override public boolean hasNext ( ) { return true ; } } ; } } ) ; } @Test public void mergeManyAsyncSingle ( ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) ; Observable < Observable < Integer > > os = Observable . range ( <int> , <int> ) . map ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( final Integer i ) { return Observable . create ( new OnSubscribe < Integer > ( ) { @Override public void call ( Subscriber < ? super Integer > s ) { if ( i < <int> ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } s . onNext ( i ) ; s . onCompleted ( ) ; } } ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) ; } } ) ; Observable . merge ( os ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( ) ; ts . assertNoErrors ( ) ; assertEquals ( <int> , ts . getOnNextEvents ( ) . size ( ) ) ; } @Test public void shouldCompleteAfterApplyingBackpressure_NormalPath ( ) { Observable < Integer > source = Observable . mergeDelayError ( Observable . just ( Observable . range ( <int> , <int> ) ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> ) ) ; subscriber . assertTerminalEvent ( ) ; } @Test public void shouldCompleteAfterApplyingBackpressure_FastPath ( ) { Observable < Integer > source = Observable . mergeDelayError ( Observable . just ( Observable . just ( <int> ) ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> ) ) ; subscriber . assertTerminalEvent ( ) ; } @Test public void shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes ( ) { TestScheduler scheduler = Schedulers . test ( ) ; Observable < Long > source = Observable . mergeDelayError ( Observable . just ( <int> ) , Observable . timer ( <int> , TimeUnit . SECONDS , scheduler ) . skip ( <int> ) ) ; TestSubscriber < Long > subscriber = new TestSubscriber < Long > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( <int> , TimeUnit . SECONDS ) ; subscriber . assertReceivedOnNext ( Collections . < Long > emptyList ( ) ) ; assertEquals ( Collections . < Notification < Long > > emptyList ( ) , subscriber . getOnCompletedEvents ( ) ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> ) ) ; subscriber . assertTerminalEvent ( ) ; } @Test public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_NormalPath ( ) { Throwable exception = new Throwable ( ) ; Observable < Integer > source = Observable . mergeDelayError ( Observable . range ( <int> , <int> ) , Observable . < Integer > error ( exception ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> ) ) ; subscriber . assertTerminalEvent ( ) ; assertEquals ( asList ( exception ) , subscriber . getOnErrorEvents ( ) ) ; } @Test public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_FastPath ( ) { Throwable exception = new Throwable ( ) ; Observable < Integer > source = Observable . mergeDelayError ( Observable . just ( <int> ) , Observable . < Integer > error ( exception ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> ) ) ; subscriber . assertTerminalEvent ( ) ; assertEquals ( asList ( exception ) , subscriber . getOnErrorEvents ( ) ) ; } @Test public void shouldNotCompleteWhileThereAreStillScalarSynchronousEmissionsInTheQueue ( ) { Observable < Integer > source = Observable . merge ( Observable . just ( <int> ) , Observable . just ( <int> ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . assertReceivedOnNext ( asList ( <int> ) ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> ) ) ; } @Test public void shouldNotReceivedDelayedErrorWhileThereAreStillScalarSynchronousEmissionsInTheQueue ( ) { Throwable exception = new Throwable ( ) ; Observable < Integer > source = Observable . mergeDelayError ( Observable . just ( <int> ) , Observable . just ( <int> ) , Observable . < Integer > error ( exception ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . assertReceivedOnNext ( asList ( <int> ) ) ; assertEquals ( Collections . < Throwable > emptyList ( ) , subscriber . getOnErrorEvents ( ) ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> ) ) ; assertEquals ( asList ( exception ) , subscriber . getOnErrorEvents ( ) ) ; } @Test public void shouldNotReceivedDelayedErrorWhileThereAreStillNormalEmissionsInTheQueue ( ) { Throwable exception = new Throwable ( ) ; Observable < Integer > source = Observable . mergeDelayError ( Observable . range ( <int> , <int> ) , Observable . range ( <int> , <int> ) , Observable . < Integer > error ( exception ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < Integer > ( ) ; subscriber . requestMore ( <int> ) ; source . subscribe ( subscriber ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> , <int> ) ) ; assertEquals ( Collections . < Throwable > emptyList ( ) , subscriber . getOnErrorEvents ( ) ) ; subscriber . requestMore ( <int> ) ; subscriber . assertReceivedOnNext ( asList ( <int> , <int> , <int> , <int> ) ) ; assertEquals ( asList ( exception ) , subscriber . getOnErrorEvents ( ) ) ; } @Test public void testMergeKeepsRequesting ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final ConcurrentLinkedQueue < String > messages = new ConcurrentLinkedQueue < String > ( ) ; Observable . range ( <int> , <int> ) . flatMap ( new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( final Integer number ) { return Observable . range ( <int> , Integer . MAX_VALUE ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { messages . add ( <str> + number + <str> + n ) ; } } ) . doOnNext ( pauseForMs ( <int> ) ) . onBackpressureBuffer ( ) . subscribeOn ( Schedulers . computation ( ) ) . doOnRequest ( new Action1 < Long > ( ) { @Override public void call ( Long n ) { messages . add ( <str> + number + <str> + n ) ; } } ) ; } } ) . take ( RxRingBuffer . SIZE * <int> + <int> ) . doOnNext ( printCount ( ) ) . doOnCompleted ( new Action0 ( ) { @Override public void call ( ) { latch . countDown ( ) ; } } ) . subscribe ( ) ; boolean a = latch . await ( <int> , TimeUnit . SECONDS ) ; if ( ! a ) { for ( String s : messages ) { System . out . println ( <str> + s ) ; } } assertTrue ( a ) ; } @Test public void testMergeRequestOverflow ( ) throws InterruptedException { Observable < Integer > o = Observable . from ( Arrays . asList ( <int> , <int> ) ) . mergeWith ( Observable . from ( Arrays . asList ( <int> , <int> ) ) ) ; final int expectedCount = <int> ; final CountDownLatch latch = new CountDownLatch ( expectedCount ) ; o . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( new Subscriber < Integer > ( ) { @Override public void onStart ( ) { request ( <int> ) ; } @Override public void onCompleted ( ) { } @Override public void onError ( Throwable e ) { throw new RuntimeException ( e ) ; } @Override public void onNext ( Integer t ) { latch . countDown ( ) ; request ( <int> ) ; request ( Long . MAX_VALUE - <int> ) ; } } ) ; assertTrue ( latch . await ( <int> , TimeUnit . SECONDS ) ) ; } private static Action1 < Integer > printCount ( ) { return new Action1 < Integer > ( ) { long count ; @Override public void call ( Integer t1 ) { count + + ; System . out . println ( <str> + count ) ; } } ; } private static Action1 < Integer > pauseForMs ( final long time ) { return new Action1 < Integer > ( ) { @Override public void call ( Integer s ) { try { Thread . sleep ( time ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } ; } Func1 < Integer , Observable < Integer > > toScalar = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t ) { return Observable . just ( t ) ; } } ; Func1 < Integer , Observable < Integer > > toHiddenScalar = new Func1 < Integer , Observable < Integer > > ( ) { @Override public Observable < Integer > call ( Integer t ) { return Observable . just ( t ) . asObservable ( ) ; } } ; void runMerge ( Func1 < Integer , Observable < Integer > > func , TestSubscriber < Integer > ts ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { list . add ( i ) ; } Observable < Integer > source = Observable . from ( list ) ; source . flatMap ( func ) . subscribe ( ts ) ; if ( ts . getOnNextEvents ( ) . size ( ) ! = <int> ) { System . out . println ( ts . getOnNextEvents ( ) ) ; } ts . assertTerminalEvent ( ) ; ts . assertNoErrors ( ) ; ts . assertReceivedOnNext ( list ) ; } @Test public void testFastMergeFullScalar ( ) { runMerge ( toScalar , new TestSubscriber < Integer > ( ) ) ; } @Test public void testFastMergeHiddenScalar ( ) { runMerge ( toHiddenScalar , new TestSubscriber < Integer > ( ) ) ; } @Test public void testSlowMergeFullScalar ( ) { for ( final int req : new int [ ] { <int> , <int> , <int> , <int> , <int> } ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) { int remaining = req ; @Override public void onStart ( ) { request ( req ) ; } @Override public void onNext ( Integer t ) { super . onNext ( t ) ; if ( - - remaining = = <int> ) { remaining = req ; request ( req ) ; } } } ; runMerge ( toScalar , ts ) ; } } @Test public void testSlowMergeHiddenScalar ( ) { for ( final int req : new int [ ] { <int> , <int> , <int> , <int> , <int> } ) { TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) { int remaining = req ; @Override public void onStart ( ) { request ( req ) ; } @Override public void onNext ( Integer t ) { super . onNext ( t ) ; if ( - - remaining = = <int> ) { remaining = req ; request ( req ) ; } } } ; runMerge ( toHiddenScalar , ts ) ; } } @Test public void testUnboundedDefaultConcurrency ( ) { List < Observable < Integer > > os = new ArrayList < Observable < Integer > > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { os . add ( Observable . < Integer > never ( ) ) ; } os . add ( Observable . range ( <int> , <int> ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Observable . merge ( os ) . take ( <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertValue ( <int> ) ; ts . assertCompleted ( ) ; } @Test public void testConcurrencyLimit ( ) { List < Observable < Integer > > os = new ArrayList < Observable < Integer > > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { os . add ( Observable . < Integer > never ( ) ) ; } os . add ( Observable . range ( <int> , <int> ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Observable . merge ( os , Integer . MAX_VALUE ) . take ( <int> ) . subscribe ( ts ) ; ts . awaitTerminalEvent ( <int> , TimeUnit . MILLISECONDS ) ; ts . assertValue ( <int> ) ; ts . assertCompleted ( ) ; } }