package org . jbox2d . collision ; import org . jbox2d . collision . shapes . ChainShape ; import org . jbox2d . collision . shapes . CircleShape ; import org . jbox2d . collision . shapes . EdgeShape ; import org . jbox2d . collision . shapes . PolygonShape ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Vec2 ; import org . jbox2d . common . Transform ; public class Distance { public static final int MAX_ITERS = <int> ; public static int GJK_CALLS = <int> ; public static int GJK_ITERS = <int> ; public static int GJK_MAX_ITERS = <int> ; private class SimplexVertex { public final Vec2 wA = new Vec2 ( ) ; public final Vec2 wB = new Vec2 ( ) ; public final Vec2 w = new Vec2 ( ) ; public float a ; public int indexA ; public int indexB ; public void set ( SimplexVertex sv ) { wA . set ( sv . wA ) ; wB . set ( sv . wB ) ; w . set ( sv . w ) ; a = sv . a ; indexA = sv . indexA ; indexB = sv . indexB ; } } public static class SimplexCache { public float metric ; public int count ; public final int indexA [ ] = new int [ <int> ] ; public final int indexB [ ] = new int [ <int> ] ; public SimplexCache ( ) { metric = <int> ; count = <int> ; indexA [ <int> ] = Integer . MAX_VALUE ; indexA [ <int> ] = Integer . MAX_VALUE ; indexA [ <int> ] = Integer . MAX_VALUE ; indexB [ <int> ] = Integer . MAX_VALUE ; indexB [ <int> ] = Integer . MAX_VALUE ; indexB [ <int> ] = Integer . MAX_VALUE ; } public void set ( SimplexCache sc ) { System . arraycopy ( sc . indexA , <int> , indexA , <int> , indexA . length ) ; System . arraycopy ( sc . indexB , <int> , indexB , <int> , indexB . length ) ; metric = sc . metric ; count = sc . count ; } } private class Simplex { public final SimplexVertex m_v1 = new SimplexVertex ( ) ; public final SimplexVertex m_v2 = new SimplexVertex ( ) ; public final SimplexVertex m_v3 = new SimplexVertex ( ) ; public final SimplexVertex vertices [ ] = { m_v1 , m_v2 , m_v3 } ; public int m_count ; public void readCache ( SimplexCache cache , DistanceProxy proxyA , Transform transformA , DistanceProxy proxyB , Transform transformB ) { assert ( cache . count < = <int> ) ; m_count = cache . count ; for ( int i = <int> ; i < m_count ; + + i ) { SimplexVertex v = vertices [ i ] ; v . indexA = cache . indexA [ i ] ; v . indexB = cache . indexB [ i ] ; Vec2 wALocal = proxyA . getVertex ( v . indexA ) ; Vec2 wBLocal = proxyB . getVertex ( v . indexB ) ; Transform . mulToOutUnsafe ( transformA , wALocal , v . wA ) ; Transform . mulToOutUnsafe ( transformB , wBLocal , v . wB ) ; v . w . set ( v . wB ) . subLocal ( v . wA ) ; v . a = <float> ; } if ( m_count > <int> ) { float metric1 = cache . metric ; float metric2 = getMetric ( ) ; if ( metric2 < <float> * metric1 | | <float> * metric1 < metric2 | | metric2 < Settings . EPSILON ) { m_count = <int> ; } } if ( m_count = = <int> ) { SimplexVertex v = vertices [ <int> ] ; v . indexA = <int> ; v . indexB = <int> ; Vec2 wALocal = proxyA . getVertex ( <int> ) ; Vec2 wBLocal = proxyB . getVertex ( <int> ) ; Transform . mulToOutUnsafe ( transformA , wALocal , v . wA ) ; Transform . mulToOutUnsafe ( transformB , wBLocal , v . wB ) ; v . w . set ( v . wB ) . subLocal ( v . wA ) ; m_count = <int> ; } } public void writeCache ( SimplexCache cache ) { cache . metric = getMetric ( ) ; cache . count = m_count ; for ( int i = <int> ; i < m_count ; + + i ) { cache . indexA [ i ] = ( vertices [ i ] . indexA ) ; cache . indexB [ i ] = ( vertices [ i ] . indexB ) ; } } private final Vec2 e12 = new Vec2 ( ) ; public final void getSearchDirection ( final Vec2 out ) { switch ( m_count ) { case <int> : out . set ( m_v1 . w ) . negateLocal ( ) ; return ; case <int> : e12 . set ( m_v2 . w ) . subLocal ( m_v1 . w ) ; out . set ( m_v1 . w ) . negateLocal ( ) ; float sgn = Vec2 . cross ( e12 , out ) ; if ( sgn > <int> f ) { Vec2 . crossToOutUnsafe ( <int> f , e12 , out ) ; return ; } else { Vec2 . crossToOutUnsafe ( e12 , <int> f , out ) ; return ; } default : assert ( false ) ; out . setZero ( ) ; return ; } } private final Vec2 case2 = new Vec2 ( ) ; private final Vec2 case22 = new Vec2 ( ) ; public void getClosestPoint ( final Vec2 out ) { switch ( m_count ) { case <int> : assert ( false ) ; out . setZero ( ) ; return ; case <int> : out . set ( m_v1 . w ) ; return ; case <int> : case22 . set ( m_v2 . w ) . mulLocal ( m_v2 . a ) ; case2 . set ( m_v1 . w ) . mulLocal ( m_v1 . a ) . addLocal ( case22 ) ; out . set ( case2 ) ; return ; case <int> : out . setZero ( ) ; return ; default : assert ( false ) ; out . setZero ( ) ; return ; } } private final Vec2 case3 = new Vec2 ( ) ; private final Vec2 case33 = new Vec2 ( ) ; public void getWitnessPoints ( Vec2 pA , Vec2 pB ) { switch ( m_count ) { case <int> : assert ( false ) ; break ; case <int> : pA . set ( m_v1 . wA ) ; pB . set ( m_v1 . wB ) ; break ; case <int> : case2 . set ( m_v1 . wA ) . mulLocal ( m_v1 . a ) ; pA . set ( m_v2 . wA ) . mulLocal ( m_v2 . a ) . addLocal ( case2 ) ; case2 . set ( m_v1 . wB ) . mulLocal ( m_v1 . a ) ; pB . set ( m_v2 . wB ) . mulLocal ( m_v2 . a ) . addLocal ( case2 ) ; break ; case <int> : pA . set ( m_v1 . wA ) . mulLocal ( m_v1 . a ) ; case3 . set ( m_v2 . wA ) . mulLocal ( m_v2 . a ) ; case33 . set ( m_v3 . wA ) . mulLocal ( m_v3 . a ) ; pA . addLocal ( case3 ) . addLocal ( case33 ) ; pB . set ( pA ) ; break ; default: assert ( false ) ; break ; } } public float getMetric ( ) { switch ( m_count ) { case <int> : assert ( false ) ; return <float> ; case <int> : return <float> ; case <int> : return MathUtils . distance ( m_v1 . w , m_v2 . w ) ; case <int> : case3 . set ( m_v2 . w ) . subLocal ( m_v1 . w ) ; case33 . set ( m_v3 . w ) . subLocal ( m_v1 . w ) ; return Vec2 . cross ( case3 , case33 ) ; default: assert ( false ) ; return <float> ; } } public void solve2 ( ) { final Vec2 w1 = m_v1 . w ; final Vec2 w2 = m_v2 . w ; e12 . set ( w2 ) . subLocal ( w1 ) ; float d12_2 = - Vec2 . dot ( w1 , e12 ) ; if ( d12_2 < = <float> ) { m_v1 . a = <float> ; m_count = <int> ; return ; } float d12_1 = Vec2 . dot ( w2 , e12 ) ; if ( d12_1 < = <float> ) { m_v2 . a = <float> ; m_count = <int> ; m_v1 . set ( m_v2 ) ; return ; } float inv_d12 = <float> / ( d12_1 + d12_2 ) ; m_v1 . a = d12_1 * inv_d12 ; m_v2 . a = d12_2 * inv_d12 ; m_count = <int> ; } private final Vec2 e13 = new Vec2 ( ) ; private final Vec2 e23 = new Vec2 ( ) ; private final Vec2 w1 = new Vec2 ( ) ; private final Vec2 w2 = new Vec2 ( ) ; private final Vec2 w3 = new Vec2 ( ) ; public void solve3 ( ) { w1 . set ( m_v1 . w ) ; w2 . set ( m_v2 . w ) ; w3 . set ( m_v3 . w ) ; e12 . set ( w2 ) . subLocal ( w1 ) ; float w1e12 = Vec2 . dot ( w1 , e12 ) ; float w2e12 = Vec2 . dot ( w2 , e12 ) ; float d12_1 = w2e12 ; float d12_2 = - w1e12 ; e13 . set ( w3 ) . subLocal ( w1 ) ; float w1e13 = Vec2 . dot ( w1 , e13 ) ; float w3e13 = Vec2 . dot ( w3 , e13 ) ; float d13_1 = w3e13 ; float d13_2 = - w1e13 ; e23 . set ( w3 ) . subLocal ( w2 ) ; float w2e23 = Vec2 . dot ( w2 , e23 ) ; float w3e23 = Vec2 . dot ( w3 , e23 ) ; float d23_1 = w3e23 ; float d23_2 = - w2e23 ; float n123 = Vec2 . cross ( e12 , e13 ) ; float d123_1 = n123 * Vec2 . cross ( w2 , w3 ) ; float d123_2 = n123 * Vec2 . cross ( w3 , w1 ) ; float d123_3 = n123 * Vec2 . cross ( w1 , w2 ) ; if ( d12_2 < = <float> & & d13_2 < = <float> ) { m_v1 . a = <float> ; m_count = <int> ; return ; } if ( d12_1 > <float> & & d12_2 > <float> & & d123_3 < = <float> ) { float inv_d12 = <float> / ( d12_1 + d12_2 ) ; m_v1 . a = d12_1 * inv_d12 ; m_v2 . a = d12_2 * inv_d12 ; m_count = <int> ; return ; } if ( d13_1 > <float> & & d13_2 > <float> & & d123_2 < = <float> ) { float inv_d13 = <float> / ( d13_1 + d13_2 ) ; m_v1 . a = d13_1 * inv_d13 ; m_v3 . a = d13_2 * inv_d13 ; m_count = <int> ; m_v2 . set ( m_v3 ) ; return ; } if ( d12_1 < = <float> & & d23_2 < = <float> ) { m_v2 . a = <float> ; m_count = <int> ; m_v1 . set ( m_v2 ) ; return ; } if ( d13_1 < = <float> & & d23_1 < = <float> ) { m_v3 . a = <float> ; m_count = <int> ; m_v1 . set ( m_v3 ) ; return ; } if ( d23_1 > <float> & & d23_2 > <float> & & d123_1 < = <float> ) { float inv_d23 = <float> / ( d23_1 + d23_2 ) ; m_v2 . a = d23_1 * inv_d23 ; m_v3 . a = d23_2 * inv_d23 ; m_count = <int> ; m_v1 . set ( m_v3 ) ; return ; } float inv_d123 = <float> / ( d123_1 + d123_2 + d123_3 ) ; m_v1 . a = d123_1 * inv_d123 ; m_v2 . a = d123_2 * inv_d123 ; m_v3 . a = d123_3 * inv_d123 ; m_count = <int> ; } } public static class DistanceProxy { public final Vec2 [ ] m_vertices ; public int m_count ; public float m_radius ; public final Vec2 [ ] m_buffer ; public DistanceProxy ( ) { m_vertices = new Vec2 [ Settings . maxPolygonVertices ] ; for ( int i = <int> ; i < m_vertices . length ; i + + ) { m_vertices [ i ] = new Vec2 ( ) ; } m_buffer = new Vec2 [ <int> ] ; m_count = <int> ; m_radius = <int> f ; } public final void set ( final Shape shape , int index ) { switch ( shape . getType ( ) ) { case CIRCLE : final CircleShape circle = ( CircleShape ) shape ; m_vertices [ <int> ] . set ( circle . m_p ) ; m_count = <int> ; m_radius = circle . m_radius ; break ; case POLYGON : final PolygonShape poly = ( PolygonShape ) shape ; m_count = poly . m_count ; m_radius = poly . m_radius ; for ( int i = <int> ; i < m_count ; i + + ) { m_vertices [ i ] . set ( poly . m_vertices [ i ] ) ; } break ; case CHAIN : final ChainShape chain = ( ChainShape ) shape ; assert ( <int> < = index & & index < chain . m_count ) ; m_buffer [ <int> ] = chain . m_vertices [ index ] ; if ( index + <int> < chain . m_count ) { m_buffer [ <int> ] = chain . m_vertices [ index + <int> ] ; } else { m_buffer [ <int> ] = chain . m_vertices [ <int> ] ; } m_vertices [ <int> ] . set ( m_buffer [ <int> ] ) ; m_vertices [ <int> ] . set ( m_buffer [ <int> ] ) ; m_count = <int> ; m_radius = chain . m_radius ; break ; case EDGE : EdgeShape edge = ( EdgeShape ) shape ; m_vertices [ <int> ] . set ( edge . m_vertex1 ) ; m_vertices [ <int> ] . set ( edge . m_vertex2 ) ; m_count = <int> ; m_radius = edge . m_radius ; break ; default : assert ( false ) ; } } public final int getSupport ( final Vec2 d ) { int bestIndex = <int> ; float bestValue = Vec2 . dot ( m_vertices [ <int> ] , d ) ; for ( int i = <int> ; i < m_count ; i + + ) { float value = Vec2 . dot ( m_vertices [ i ] , d ) ; if ( value > bestValue ) { bestIndex = i ; bestValue = value ; } } return bestIndex ; } public final Vec2 getSupportVertex ( final Vec2 d ) { int bestIndex = <int> ; float bestValue = Vec2 . dot ( m_vertices [ <int> ] , d ) ; for ( int i = <int> ; i < m_count ; i + + ) { float value = Vec2 . dot ( m_vertices [ i ] , d ) ; if ( value > bestValue ) { bestIndex = i ; bestValue = value ; } } return m_vertices [ bestIndex ] ; } public final int getVertexCount ( ) { return m_count ; } public final Vec2 getVertex ( int index ) { assert ( <int> < = index & & index < m_count ) ; return m_vertices [ index ] ; } } private Simplex simplex = new Simplex ( ) ; private int [ ] saveA = new int [ <int> ] ; private int [ ] saveB = new int [ <int> ] ; private Vec2 closestPoint = new Vec2 ( ) ; private Vec2 d = new Vec2 ( ) ; private Vec2 temp = new Vec2 ( ) ; private Vec2 normal = new Vec2 ( ) ; public final void distance ( final DistanceOutput output , final SimplexCache cache , final DistanceInput input ) { GJK_CALLS + + ; final DistanceProxy proxyA = input . proxyA ; final DistanceProxy proxyB = input . proxyB ; Transform transformA = input . transformA ; Transform transformB = input . transformB ; simplex . readCache ( cache , proxyA , transformA , proxyB , transformB ) ; SimplexVertex [ ] vertices = simplex . vertices ; int saveCount = <int> ; simplex . getClosestPoint ( closestPoint ) ; float distanceSqr1 = closestPoint . lengthSquared ( ) ; float distanceSqr2 = distanceSqr1 ; int iter = <int> ; while ( iter < MAX_ITERS ) { saveCount = simplex . m_count ; for ( int i = <int> ; i < saveCount ; i + + ) { saveA [ i ] = vertices [ i ] . indexA ; saveB [ i ] = vertices [ i ] . indexB ; } switch ( simplex . m_count ) { case <int> : break ; case <int> : simplex . solve2 ( ) ; break ; case <int> : simplex . solve3 ( ) ; break ; default : assert ( false ) ; } if ( simplex . m_count = = <int> ) { break ; } simplex . getClosestPoint ( closestPoint ) ; distanceSqr2 = closestPoint . lengthSquared ( ) ; if ( distanceSqr2 > = distanceSqr1 ) { } distanceSqr1 = distanceSqr2 ; simplex . getSearchDirection ( d ) ; if ( d . lengthSquared ( ) < Settings . EPSILON * Settings . EPSILON ) { break ; } SimplexVertex vertex = vertices [ simplex . m_count ] ; Rot . mulTransUnsafe ( transformA . q , d . negateLocal ( ) , temp ) ; vertex . indexA = proxyA . getSupport ( temp ) ; Transform . mulToOutUnsafe ( transformA , proxyA . getVertex ( vertex . indexA ) , vertex . wA ) ; Rot . mulTransUnsafe ( transformB . q , d . negateLocal ( ) , temp ) ; vertex . indexB = proxyB . getSupport ( temp ) ; Transform . mulToOutUnsafe ( transformB , proxyB . getVertex ( vertex . indexB ) , vertex . wB ) ; vertex . w . set ( vertex . wB ) . subLocal ( vertex . wA ) ; + + iter ; + + GJK_ITERS ; boolean duplicate = false ; for ( int i = <int> ; i < saveCount ; + + i ) { if ( vertex . indexA = = saveA [ i ] & & vertex . indexB = = saveB [ i ] ) { duplicate = true ; break ; } } if ( duplicate ) { break ; } + + simplex . m_count ; } GJK_MAX_ITERS = MathUtils . max ( GJK_MAX_ITERS , iter ) ; simplex . getWitnessPoints ( output . pointA , output . pointB ) ; output . distance = MathUtils . distance ( output . pointA , output . pointB ) ; output . iterations = iter ; simplex . writeCache ( cache ) ; if ( input . useRadii ) { float rA = proxyA . m_radius ; float rB = proxyB . m_radius ; if ( output . distance > rA + rB & & output . distance > Settings . EPSILON ) { output . distance - = rA + rB ; normal . set ( output . pointB ) . subLocal ( output . pointA ) ; normal . normalize ( ) ; temp . set ( normal ) . mulLocal ( rA ) ; output . pointA . addLocal ( temp ) ; temp . set ( normal ) . mulLocal ( rB ) ; output . pointB . subLocal ( temp ) ; } else { output . pointA . addLocal ( output . pointB ) . mulLocal ( . <int> f ) ; output . pointB . set ( output . pointA ) ; output . distance = <float> ; } } } } 
