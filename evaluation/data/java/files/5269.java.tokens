package io . netty . util ; import io . netty . util . internal . PlatformDependent ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . atomic . AtomicReferenceArray ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; public class DefaultAttributeMap implements AttributeMap { @SuppressWarnings ( <str> ) private static final AtomicReferenceFieldUpdater < DefaultAttributeMap , AtomicReferenceArray > updater ; static { @SuppressWarnings ( <str> ) AtomicReferenceFieldUpdater < DefaultAttributeMap , AtomicReferenceArray > referenceFieldUpdater = PlatformDependent . newAtomicReferenceFieldUpdater ( DefaultAttributeMap . class , <str> ) ; if ( referenceFieldUpdater = = null ) { referenceFieldUpdater = AtomicReferenceFieldUpdater . newUpdater ( DefaultAttributeMap . class , AtomicReferenceArray . class , <str> ) ; } updater = referenceFieldUpdater ; } private static final int BUCKET_SIZE = <int> ; private static final int MASK = BUCKET_SIZE - <int> ; @SuppressWarnings ( <str> ) private volatile AtomicReferenceArray < DefaultAttribute < ? > > attributes ; @SuppressWarnings ( <str> ) @Override public < T > Attribute < T > attr ( AttributeKey < T > key ) { if ( key = = null ) { throw new NullPointerException ( <str> ) ; } AtomicReferenceArray < DefaultAttribute < ? > > attributes = this . attributes ; if ( attributes = = null ) { attributes = new AtomicReferenceArray < DefaultAttribute < ? > > ( BUCKET_SIZE ) ; if ( ! updater . compareAndSet ( this , null , attributes ) ) { attributes = this . attributes ; } } int i = index ( key ) ; DefaultAttribute < ? > head = attributes . get ( i ) ; if ( head = = null ) { head = new DefaultAttribute ( key ) ; if ( attributes . compareAndSet ( i , null , head ) ) { return ( Attribute < T > ) head ; } else { head = attributes . get ( i ) ; } } synchronized ( head ) { DefaultAttribute < ? > curr = head ; for ( ; ; ) { if ( ! curr . removed & & curr . key = = key ) { return ( Attribute < T > ) curr ; } DefaultAttribute < ? > next = curr . next ; if ( next = = null ) { DefaultAttribute < T > attr = new DefaultAttribute < T > ( head , key ) ; curr . next = attr ; attr . prev = curr ; return attr ; } else { curr = next ; } } } } @Override public < T > boolean hasAttr ( AttributeKey < T > key ) { if ( key = = null ) { throw new NullPointerException ( <str> ) ; } AtomicReferenceArray < DefaultAttribute < ? > > attributes = this . attributes ; if ( attributes = = null ) { return false ; } int i = index ( key ) ; DefaultAttribute < ? > head = attributes . get ( i ) ; if ( head = = null ) { return false ; } if ( head . key = = key & & ! head . removed ) { return true ; } synchronized ( head ) { DefaultAttribute < ? > curr = head . next ; while ( curr ! = null ) { if ( ! curr . removed & & curr . key = = key ) { return true ; } curr = curr . next ; } return false ; } } private static int index ( AttributeKey < ? > key ) { return key . id ( ) & MASK ; } @SuppressWarnings ( <str> ) private static final class DefaultAttribute < T > extends AtomicReference < T > implements Attribute < T > { private static final long serialVersionUID = - <int> ; private final DefaultAttribute < ? > head ; private final AttributeKey < T > key ; private DefaultAttribute < ? > prev ; private DefaultAttribute < ? > next ; private volatile boolean removed ; DefaultAttribute ( DefaultAttribute < ? > head , AttributeKey < T > key ) { this . head = head ; this . key = key ; } DefaultAttribute ( AttributeKey < T > key ) { head = this ; this . key = key ; } @Override public AttributeKey < T > key ( ) { return key ; } @Override public T setIfAbsent ( T value ) { while ( ! compareAndSet ( null , value ) ) { T old = get ( ) ; if ( old ! = null ) { return old ; } } return null ; } @Override public T getAndRemove ( ) { removed = true ; T oldValue = getAndSet ( null ) ; remove0 ( ) ; return oldValue ; } @Override public void remove ( ) { removed = true ; set ( null ) ; remove0 ( ) ; } private void remove0 ( ) { synchronized ( head ) { if ( prev ! = null ) { prev . next = next ; if ( next ! = null ) { next . prev = prev ; } prev = null ; next = null ; } } } } }