package org . nd4j . linalg . fft ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . api . ops . impl . transforms . VectorFFT ; import org . nd4j . linalg . api . ops . impl . transforms . VectorIFFT ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . util . ComplexNDArrayUtil ; public class DefaultFFTInstance extends BaseFFTInstance { @Override public IComplexNDArray fft ( INDArray transform , int numElements , int dimension ) { IComplexNDArray inputC = Nd4j . createComplex ( transform ) ; if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getFftOp ( inputC , numElements ) ) ; else { int [ ] finalShape = ArrayUtil . replace ( transform . shape ( ) , dimension , numElements ) ; IComplexNDArray transform2 = Nd4j . createComplex ( transform ) ; IComplexNDArray result = transform2 . dup ( ) ; int desiredElementsAlongDimension = result . size ( dimension ) ; if ( numElements > desiredElementsAlongDimension ) { result = ComplexNDArrayUtil . padWithZeros ( result , finalShape ) ; } else if ( numElements < desiredElementsAlongDimension ) result = ComplexNDArrayUtil . truncate ( result , numElements , dimension ) ; return rawfft ( result , numElements , dimension ) ; } } @Override public IComplexNDArray fft ( IComplexNDArray inputC , int numElements , int dimension ) { if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getFftOp ( inputC , numElements ) ) ; else return rawfft ( inputC , numElements , dimension ) ; } @Override public IComplexNDArray ifft ( INDArray transform , int numElements , int dimension ) { IComplexNDArray inputC = Nd4j . createComplex ( transform ) ; if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getIfftOp ( inputC , numElements ) ) ; else return rawifft ( inputC , numElements , dimension ) ; } @Override public IComplexNDArray ifft ( IComplexNDArray inputC , int numElements , int dimension ) { if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getIfftOp ( inputC , numElements ) ) ; else { return rawifft ( inputC , numElements , dimension ) ; } } @Override public IComplexNDArray ifft ( INDArray transform , int numElements ) { IComplexNDArray inputC = Nd4j . createComplex ( transform ) ; if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getIfftOp ( inputC , numElements ) ) ; else { return rawifft ( inputC , numElements , inputC . shape ( ) . length - <int> ) ; } } @Override public IComplexNDArray ifft ( IComplexNDArray inputC ) { if ( inputC . isVector ( ) ) return ( IComplexNDArray ) Nd4j . getExecutioner ( ) . execAndReturn ( getIfftOp ( inputC , inputC . length ( ) ) ) ; else return rawifft ( inputC , inputC . size ( inputC . shape ( ) . length - <int> ) , inputC . shape ( ) . length - <int> ) ; } @Override public IComplexNDArray rawfft ( IComplexNDArray transform , int n , int dimension ) { IComplexNDArray result = transform . dup ( ) ; result = preProcess ( result , transform , n , dimension ) ; Nd4j . getExecutioner ( ) . iterateOverAllRows ( getFftOp ( result , n ) ) ; result = postProcess ( result , dimension ) ; return result ; } @Override public IComplexNDArray rawifft ( IComplexNDArray transform , int n , int dimension ) { IComplexNDArray result = transform . dup ( ) ; result = preProcess ( result , transform , n , dimension ) ; Nd4j . getExecutioner ( ) . iterateOverAllRows ( getIfftOp ( result , n ) ) ; result = postProcess ( result , dimension ) ; return result ; } protected IComplexNDArray postProcess ( IComplexNDArray result , int dimension ) { if ( dimension ! = result . shape ( ) . length - <int> ) result = result . swapAxes ( result . shape ( ) . length - <int> , dimension ) ; return result ; } protected IComplexNDArray preProcess ( IComplexNDArray result , IComplexNDArray transform , int n , int dimension ) { if ( dimension < <int> ) dimension = transform . shape ( ) . length - <int> - dimension ; if ( transform . size ( dimension ) ! = n ) { int [ ] shape = ArrayUtil . copy ( result . shape ( ) ) ; shape [ dimension ] = n ; if ( transform . size ( dimension ) > n ) { result = ComplexNDArrayUtil . truncate ( result , n , dimension ) ; } else result = ComplexNDArrayUtil . padWithZeros ( result , shape ) ; } if ( dimension ! = result . shape ( ) . length - <int> ) result = result . swapAxes ( result . shape ( ) . length - <int> , dimension ) ; return result ; } protected Op getIfftOp ( INDArray arr , int n ) { return new VectorIFFT ( arr , n ) ; } protected Op getFftOp ( INDArray arr , int n ) { return new VectorFFT ( arr , n ) ; } }