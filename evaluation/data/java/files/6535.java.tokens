package org . apache . cassandra . db . compaction ; import java . io . RandomAccessFile ; import java . util . * ; import org . junit . After ; import org . junit . BeforeClass ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . db . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . KeyspaceParams ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class BlacklistingCompactionsTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @After public void leakDetect ( ) throws InterruptedException { System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; Thread . sleep ( <int> ) ; } @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) ) ; closeStdErr ( ) ; } public static void closeStdErr ( ) { System . err . close ( ) ; } @Test public void testBlacklistingWithSizeTieredCompactionStrategy ( ) throws Exception { testBlacklisting ( SizeTieredCompactionStrategy . class . getCanonicalName ( ) ) ; } @Test public void testBlacklistingWithLeveledCompactionStrategy ( ) throws Exception { testBlacklisting ( LeveledCompactionStrategy . class . getCanonicalName ( ) ) ; } public void testBlacklisting ( String compactionStrategy ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; final ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; final int ROWS_PER_SSTABLE = <int> ; final int SSTABLES = cfs . metadata . params . minIndexInterval * <int> / ROWS_PER_SSTABLE ; cfs . disableAutoCompaction ( ) ; long maxTimestampExpected = Long . MIN_VALUE ; Set < DecoratedKey > inserted = new HashSet < > ( ) ; for ( int j = <int> ; j < SSTABLES ; j + + ) { for ( int i = <int> ; i < ROWS_PER_SSTABLE ; i + + ) { DecoratedKey key = Util . dk ( String . valueOf ( i ) ) ; long timestamp = j * ROWS_PER_SSTABLE + i ; new RowUpdateBuilder ( cfs . metadata , timestamp , key . getKey ( ) ) . clustering ( <str> + <str> ) . add ( <str> , <str> + i ) . build ( ) . applyUnsafe ( ) ; maxTimestampExpected = Math . max ( timestamp , maxTimestampExpected ) ; inserted . add ( key ) ; } cfs . forceBlockingFlush ( ) ; CompactionsTest . assertMaxTimestamp ( cfs , maxTimestampExpected ) ; assertEquals ( inserted . toString ( ) , inserted . size ( ) , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; } Collection < SSTableReader > sstables = cfs . getLiveSSTables ( ) ; int currentSSTable = <int> ; int sstablesToCorrupt = <int> ; for ( SSTableReader sstable : sstables ) { if ( currentSSTable + <int> > sstablesToCorrupt ) break ; RandomAccessFile raf = null ; try { int corruptionSize = <int> ; raf = new RandomAccessFile ( sstable . getFilename ( ) , <str> ) ; assertNotNull ( raf ) ; assertTrue ( raf . length ( ) > corruptionSize ) ; raf . seek ( new Random ( ) . nextInt ( ( int ) ( raf . length ( ) - corruptionSize ) ) ) ; byte [ ] corruption = new byte [ corruptionSize ] ; Arrays . fill ( corruption , ( byte ) <hex> ) ; raf . write ( corruption ) ; } finally { FileUtils . closeQuietly ( raf ) ; } currentSSTable + + ; } int failures = <int> ; for ( int i = <int> ; i < sstables . size ( ) ; i + + ) { try { cfs . forceMajorCompaction ( ) ; } catch ( Exception e ) { failures + + ; continue ; } break ; } cfs . truncateBlocking ( ) ; assertEquals ( sstablesToCorrupt , failures ) ; } }