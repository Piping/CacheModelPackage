package rx . internal . util . atomic ; public final class MpscLinkedAtomicQueue < E > extends BaseLinkedAtomicQueue < E > { public MpscLinkedAtomicQueue ( ) { super ( ) ; LinkedQueueNode < E > node = new LinkedQueueNode < E > ( ) ; spConsumerNode ( node ) ; xchgProducerNode ( node ) ; } @Override public final boolean offer ( final E nextValue ) { if ( nextValue = = null ) { throw new NullPointerException ( <str> ) ; } final LinkedQueueNode < E > nextNode = new LinkedQueueNode < E > ( nextValue ) ; final LinkedQueueNode < E > prevProducerNode = xchgProducerNode ( nextNode ) ; prevProducerNode . soNext ( nextNode ) ; return true ; } @Override public final E poll ( ) { LinkedQueueNode < E > currConsumerNode = lpConsumerNode ( ) ; LinkedQueueNode < E > nextNode = currConsumerNode . lvNext ( ) ; if ( nextNode ! = null ) { final E nextValue = nextNode . getAndNullValue ( ) ; spConsumerNode ( nextNode ) ; return nextValue ; } else if ( currConsumerNode ! = lvProducerNode ( ) ) { while ( ( nextNode = currConsumerNode . lvNext ( ) ) = = null ) ; final E nextValue = nextNode . getAndNullValue ( ) ; spConsumerNode ( nextNode ) ; return nextValue ; } return null ; } @Override public final E peek ( ) { LinkedQueueNode < E > currConsumerNode = lpConsumerNode ( ) ; LinkedQueueNode < E > nextNode = currConsumerNode . lvNext ( ) ; if ( nextNode ! = null ) { return nextNode . lpValue ( ) ; } else if ( currConsumerNode ! = lvProducerNode ( ) ) { while ( ( nextNode = currConsumerNode . lvNext ( ) ) = = null ) ; return nextNode . lpValue ( ) ; } return null ; } } 
