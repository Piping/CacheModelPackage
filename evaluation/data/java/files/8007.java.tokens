package org . apache . cassandra . stress . util ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ThreadLocalRandom ; public final class Timer { private ThreadLocalRandom rnd ; private long sampleStartNanos ; private final long [ ] sample ; private int opCount ; private long errorCount ; private long partitionCount ; private long rowCount ; private long total ; private long max ; private long maxStart ; private long upToDateAsOf ; private long lastSnap = System . nanoTime ( ) ; private volatile CountDownLatch reportRequest ; volatile TimingInterval report ; private volatile TimingInterval finalReport ; public Timer ( int sampleCount ) { int powerOf2 = <int> - Integer . numberOfLeadingZeros ( sampleCount - <int> ) ; this . sample = new long [ <int> < < powerOf2 ] ; } public void init ( ) { rnd = ThreadLocalRandom . current ( ) ; } public void start ( ) { sampleStartNanos = System . nanoTime ( ) ; } private int p ( int index ) { return <int> + ( index / sample . length ) ; } public boolean running ( ) { return finalReport = = null ; } public void stop ( long partitionCount , long rowCount , boolean error ) { maybeReport ( ) ; long now = System . nanoTime ( ) ; long time = now - sampleStartNanos ; if ( rnd . nextInt ( p ( opCount ) ) = = <int> ) sample [ index ( opCount ) ] = time ; if ( time > max ) { maxStart = sampleStartNanos ; max = time ; } total + = time ; opCount + = <int> ; this . partitionCount + = partitionCount ; this . rowCount + = rowCount ; if ( error ) this . errorCount + + ; upToDateAsOf = now ; } private int index ( int count ) { return count & ( sample . length - <int> ) ; } private TimingInterval buildReport ( ) { final List < SampleOfLongs > sampleLatencies = Arrays . asList ( new SampleOfLongs ( Arrays . copyOf ( sample , index ( opCount ) ) , p ( opCount ) ) , new SampleOfLongs ( Arrays . copyOfRange ( sample , index ( opCount ) , Math . min ( opCount , sample . length ) ) , p ( opCount ) - <int> ) ) ; final TimingInterval report = new TimingInterval ( lastSnap , upToDateAsOf , max , maxStart , max , partitionCount , rowCount , total , opCount , errorCount , SampleOfLongs . merge ( rnd , sampleLatencies , Integer . MAX_VALUE ) ) ; opCount = <int> ; partitionCount = <int> ; rowCount = <int> ; total = <int> ; max = <int> ; errorCount = <int> ; lastSnap = upToDateAsOf ; return report ; } private void maybeReport ( ) { if ( reportRequest ! = null ) { synchronized ( this ) { report = buildReport ( ) ; reportRequest . countDown ( ) ; reportRequest = null ; } } } synchronized void requestReport ( CountDownLatch signal ) { if ( finalReport ! = null ) { report = finalReport ; finalReport = new TimingInterval ( <int> ) ; signal . countDown ( ) ; } else reportRequest = signal ; } public synchronized void close ( ) { if ( reportRequest = = null ) finalReport = buildReport ( ) ; else { finalReport = new TimingInterval ( <int> ) ; report = buildReport ( ) ; reportRequest . countDown ( ) ; reportRequest = null ; } } }