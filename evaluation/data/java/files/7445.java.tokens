package org . apache . cassandra . utils ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . io . util . FileUtils ; import org . slf4j . Logger ; import java . io . File ; import java . io . RandomAccessFile ; import java . lang . reflect . Constructor ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel . MapMode ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . LockSupport ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Preconditions ; public class CoalescingStrategies { private static final String DEBUG_COALESCING_PROPERTY = Config . PROPERTY_PREFIX + <str> ; private static final boolean DEBUG_COALESCING = Boolean . getBoolean ( DEBUG_COALESCING_PROPERTY ) ; private static final String DEBUG_COALESCING_PATH_PROPERTY = Config . PROPERTY_PREFIX + <str> ; private static final String DEBUG_COALESCING_PATH = System . getProperty ( DEBUG_COALESCING_PATH_PROPERTY , <str> ) ; static { if ( DEBUG_COALESCING ) { File directory = new File ( DEBUG_COALESCING_PATH ) ; if ( directory . exists ( ) ) FileUtils . deleteRecursive ( directory ) ; if ( ! directory . mkdirs ( ) ) throw new ExceptionInInitializerError ( <str> ) ; } } @VisibleForTesting interface Clock { long nanoTime ( ) ; } @VisibleForTesting static Clock CLOCK = new Clock ( ) { public long nanoTime ( ) { return System . nanoTime ( ) ; } } ; public static interface Coalescable { long timestampNanos ( ) ; } @VisibleForTesting static void parkLoop ( long nanos ) { long now = System . nanoTime ( ) ; final long timer = now + nanos ; do { LockSupport . parkNanos ( timer - now ) ; } while ( timer - ( now = System . nanoTime ( ) ) > nanos / <int> ) ; } private static boolean maybeSleep ( int messages , long averageGap , long maxCoalesceWindow , Parker parker ) { long sleep = messages * averageGap ; if ( sleep > maxCoalesceWindow ) return false ; while ( sleep * <int> < maxCoalesceWindow ) sleep * = <int> ; parker . park ( sleep ) ; return true ; } public static abstract class CoalescingStrategy { protected final Parker parker ; protected final Logger logger ; protected volatile boolean shouldLogAverage = false ; protected final ByteBuffer logBuffer ; private RandomAccessFile ras ; private final String displayName ; protected CoalescingStrategy ( Parker parker , Logger logger , String displayName ) { this . parker = parker ; this . logger = logger ; this . displayName = displayName ; if ( DEBUG_COALESCING ) { new Thread ( displayName + <str> ) { @Override public void run ( ) { while ( true ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } shouldLogAverage = true ; } } } . start ( ) ; } RandomAccessFile rasTemp = null ; ByteBuffer logBufferTemp = null ; if ( DEBUG_COALESCING ) { try { File outFile = File . createTempFile ( <str> + this . displayName + <str> , <str> , new File ( DEBUG_COALESCING_PATH ) ) ; rasTemp = new RandomAccessFile ( outFile , <str> ) ; logBufferTemp = ras . getChannel ( ) . map ( MapMode . READ_WRITE , <int> , Integer . MAX_VALUE ) ; logBufferTemp . putLong ( <int> ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; } } ras = rasTemp ; logBuffer = logBufferTemp ; } final protected void debugGap ( long averageGap ) { if ( DEBUG_COALESCING & & shouldLogAverage ) { shouldLogAverage = false ; logger . info ( <str> , this , TimeUnit . NANOSECONDS . toMicros ( averageGap ) ) ; } } final protected void debugTimestamp ( long timestamp ) { if ( DEBUG_COALESCING & & logBuffer ! = null ) { logBuffer . putLong ( <int> , logBuffer . getLong ( <int> ) + <int> ) ; logBuffer . putLong ( timestamp ) ; } } final protected < C extends Coalescable > void debugTimestamps ( Collection < C > coalescables ) { if ( DEBUG_COALESCING ) { for ( C coalescable : coalescables ) { debugTimestamp ( coalescable . timestampNanos ( ) ) ; } } } public < C extends Coalescable > void coalesce ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException { Preconditions . checkArgument ( out . isEmpty ( ) , <str> ) ; coalesceInternal ( input , out , maxItems ) ; } protected abstract < C extends Coalescable > void coalesceInternal ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException ; } @VisibleForTesting interface Parker { void park ( long nanos ) ; } private static final Parker PARKER = new Parker ( ) { @Override public void park ( long nanos ) { parkLoop ( nanos ) ; } } ; @VisibleForTesting static class TimeHorizonMovingAverageCoalescingStrategy extends CoalescingStrategy { private static final int INDEX_SHIFT = <int> ; private static final long BUCKET_INTERVAL = <int> < < <int> ; private static final int BUCKET_COUNT = <int> ; private static final long INTERVAL = BUCKET_INTERVAL * BUCKET_COUNT ; private static final long MEASURED_INTERVAL = BUCKET_INTERVAL * ( BUCKET_COUNT - <int> ) ; private long epoch = CLOCK . nanoTime ( ) ; private final int samples [ ] = new int [ BUCKET_COUNT ] ; private long sum = <int> ; private final long maxCoalesceWindow ; public TimeHorizonMovingAverageCoalescingStrategy ( int maxCoalesceWindow , Parker parker , Logger logger , String displayName ) { super ( parker , logger , displayName ) ; this . maxCoalesceWindow = TimeUnit . MICROSECONDS . toNanos ( maxCoalesceWindow ) ; sum = <int> ; } private void logSample ( long nanos ) { debugTimestamp ( nanos ) ; long epoch = this . epoch ; long delta = nanos - epoch ; if ( delta < <int> ) return ; if ( delta > INTERVAL ) epoch = rollepoch ( delta , epoch , nanos ) ; int ix = ix ( nanos ) ; samples [ ix ] + + ; if ( ix ! = ix ( epoch - <int> ) ) sum + + ; } private long averageGap ( ) { if ( sum = = <int> ) return Integer . MAX_VALUE ; return MEASURED_INTERVAL / sum ; } private long rollepoch ( long delta , long epoch , long nanos ) { if ( delta > <int> * INTERVAL ) { epoch = epoch ( nanos ) ; sum = <int> ; Arrays . fill ( samples , <int> ) ; } else { sum + = samples [ ix ( epoch - <int> ) ] ; while ( epoch + INTERVAL < nanos ) { int index = ix ( epoch ) ; sum - = samples [ index ] ; samples [ index ] = <int> ; epoch + = BUCKET_INTERVAL ; } } this . epoch = epoch ; return epoch ; } private long epoch ( long latestNanos ) { return ( latestNanos - MEASURED_INTERVAL ) & ~ ( BUCKET_INTERVAL - <int> ) ; } private int ix ( long nanos ) { return ( int ) ( ( nanos > > > INDEX_SHIFT ) & <int> ) ; } @Override protected < C extends Coalescable > void coalesceInternal ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException { if ( input . drainTo ( out , maxItems ) = = <int> ) { out . add ( input . take ( ) ) ; input . drainTo ( out , maxItems - <int> ) ; } for ( Coalescable qm : out ) logSample ( qm . timestampNanos ( ) ) ; long averageGap = averageGap ( ) ; debugGap ( averageGap ) ; int count = out . size ( ) ; if ( maybeSleep ( count , averageGap , maxCoalesceWindow , parker ) ) { input . drainTo ( out , maxItems - out . size ( ) ) ; int prevCount = count ; count = out . size ( ) ; for ( int i = prevCount ; i < count ; i + + ) logSample ( out . get ( i ) . timestampNanos ( ) ) ; } } @Override public String toString ( ) { return <str> ; } } @VisibleForTesting static class MovingAverageCoalescingStrategy extends CoalescingStrategy { private final int samples [ ] = new int [ <int> ] ; private long lastSample = <int> ; private int index = <int> ; private long sum = <int> ; private final long maxCoalesceWindow ; public MovingAverageCoalescingStrategy ( int maxCoalesceWindow , Parker parker , Logger logger , String displayName ) { super ( parker , logger , displayName ) ; this . maxCoalesceWindow = TimeUnit . MICROSECONDS . toNanos ( maxCoalesceWindow ) ; for ( int ii = <int> ; ii < samples . length ; ii + + ) samples [ ii ] = Integer . MAX_VALUE ; sum = Integer . MAX_VALUE * ( long ) samples . length ; } private long logSample ( int value ) { sum - = samples [ index ] ; sum + = value ; samples [ index ] = value ; index + + ; index = index & ( ( <int> < < <int> ) - <int> ) ; return sum / <int> ; } private long notifyOfSample ( long sample ) { debugTimestamp ( sample ) ; if ( sample > lastSample ) { final int delta = ( int ) ( Math . min ( Integer . MAX_VALUE , sample - lastSample ) ) ; lastSample = sample ; return logSample ( delta ) ; } else { return logSample ( <int> ) ; } } @Override protected < C extends Coalescable > void coalesceInternal ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException { if ( input . drainTo ( out , maxItems ) = = <int> ) { out . add ( input . take ( ) ) ; } long average = notifyOfSample ( out . get ( <int> ) . timestampNanos ( ) ) ; debugGap ( average ) ; maybeSleep ( out . size ( ) , average , maxCoalesceWindow , parker ) ; input . drainTo ( out , maxItems - out . size ( ) ) ; for ( int ii = <int> ; ii < out . size ( ) ; ii + + ) notifyOfSample ( out . get ( ii ) . timestampNanos ( ) ) ; } @Override public String toString ( ) { return <str> ; } } @VisibleForTesting static class FixedCoalescingStrategy extends CoalescingStrategy { private final long coalesceWindow ; public FixedCoalescingStrategy ( int coalesceWindowMicros , Parker parker , Logger logger , String displayName ) { super ( parker , logger , displayName ) ; coalesceWindow = TimeUnit . MICROSECONDS . toNanos ( coalesceWindowMicros ) ; } @Override protected < C extends Coalescable > void coalesceInternal ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException { if ( input . drainTo ( out , maxItems ) = = <int> ) { out . add ( input . take ( ) ) ; parker . park ( coalesceWindow ) ; input . drainTo ( out , maxItems - <int> ) ; } debugTimestamps ( out ) ; } @Override public String toString ( ) { return <str> ; } } @VisibleForTesting static class DisabledCoalescingStrategy extends CoalescingStrategy { public DisabledCoalescingStrategy ( int coalesceWindowMicros , Parker parker , Logger logger , String displayName ) { super ( parker , logger , displayName ) ; } @Override protected < C extends Coalescable > void coalesceInternal ( BlockingQueue < C > input , List < C > out , int maxItems ) throws InterruptedException { if ( input . drainTo ( out , maxItems ) = = <int> ) { out . add ( input . take ( ) ) ; input . drainTo ( out , maxItems - <int> ) ; } debugTimestamps ( out ) ; } @Override public String toString ( ) { return <str> ; } } @VisibleForTesting static CoalescingStrategy newCoalescingStrategy ( String strategy , int coalesceWindow , Parker parker , Logger logger , String displayName ) { String classname = null ; String strategyCleaned = strategy . trim ( ) . toUpperCase ( ) ; switch ( strategyCleaned ) { case <str> : classname = MovingAverageCoalescingStrategy . class . getName ( ) ; break ; case <str> : classname = FixedCoalescingStrategy . class . getName ( ) ; break ; case <str> : classname = TimeHorizonMovingAverageCoalescingStrategy . class . getName ( ) ; break ; case <str> : classname = DisabledCoalescingStrategy . class . getName ( ) ; break ; default : classname = strategy ; } try { Class < ? > clazz = Class . forName ( classname ) ; if ( ! CoalescingStrategy . class . isAssignableFrom ( clazz ) ) { throw new RuntimeException ( classname + <str> ) ; } Constructor < ? > constructor = clazz . getConstructor ( int . class , Parker . class , Logger . class , String . class ) ; return ( CoalescingStrategy ) constructor . newInstance ( coalesceWindow , parker , logger , displayName ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static CoalescingStrategy newCoalescingStrategy ( String strategy , int coalesceWindow , Logger logger , String displayName ) { return newCoalescingStrategy ( strategy , coalesceWindow , PARKER , logger , displayName ) ; } }