package org . gradle . api . tasks . testing ; import groovy . lang . Closure ; import org . gradle . api . Action ; import org . gradle . api . GradleException ; import org . gradle . api . Incubating ; import org . gradle . api . file . * ; import org . gradle . api . internal . ConventionTask ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . internal . file . FileTreeElementComparator ; import org . gradle . api . internal . file . FileTreeElementHasher ; import org . gradle . api . internal . initialization . loadercache . ClassLoaderCache ; import org . gradle . api . internal . tasks . options . Option ; import org . gradle . api . internal . tasks . testing . DefaultTestTaskReports ; import org . gradle . api . internal . tasks . testing . NoMatchingTestsReporter ; import org . gradle . api . internal . tasks . testing . TestFramework ; import org . gradle . api . internal . tasks . testing . TestResultProcessor ; import org . gradle . api . internal . tasks . testing . detection . DefaultTestExecuter ; import org . gradle . api . internal . tasks . testing . detection . TestExecuter ; import org . gradle . api . internal . tasks . testing . filter . DefaultTestFilter ; import org . gradle . api . internal . tasks . testing . junit . JUnitTestFramework ; import org . gradle . api . internal . tasks . testing . junit . report . DefaultTestReport ; import org . gradle . api . internal . tasks . testing . junit . report . TestReporter ; import org . gradle . api . internal . tasks . testing . junit . result . * ; import org . gradle . api . internal . tasks . testing . logging . * ; import org . gradle . api . internal . tasks . testing . results . StateTrackingTestResultProcessor ; import org . gradle . api . internal . tasks . testing . results . TestListenerAdapter ; import org . gradle . api . internal . tasks . testing . results . TestListenerInternal ; import org . gradle . api . internal . tasks . testing . testng . TestNGTestFramework ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . reporting . DirectoryReport ; import org . gradle . api . reporting . Reporting ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . * ; import org . gradle . api . tasks . testing . logging . TestLogging ; import org . gradle . api . tasks . testing . logging . TestLoggingContainer ; import org . gradle . api . tasks . util . PatternFilterable ; import org . gradle . api . tasks . util . PatternSet ; import org . gradle . internal . Factory ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . event . ListenerBroadcast ; import org . gradle . internal . event . ListenerManager ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . listener . ClosureBackedMethodInvocationDispatch ; import org . gradle . logging . ConsoleRenderer ; import org . gradle . logging . ProgressLoggerFactory ; import org . gradle . logging . StyledTextOutputFactory ; import org . gradle . messaging . actor . ActorFactory ; import org . gradle . process . JavaForkOptions ; import org . gradle . process . ProcessForkOptions ; import org . gradle . process . internal . DefaultJavaForkOptions ; import org . gradle . process . internal . WorkerProcessBuilder ; import org . gradle . util . ConfigureUtil ; import javax . inject . Inject ; import java . io . File ; import java . util . * ; import java . util . concurrent . Callable ; @ParallelizableTask public class Test extends ConventionTask implements JavaForkOptions , PatternFilterable , VerificationTask , Reporting < TestTaskReports > { private final ListenerBroadcast < TestListener > testListenerBroadcaster ; private final ListenerBroadcast < TestOutputListener > testOutputListenerBroadcaster ; private final ListenerBroadcast < TestListenerInternal > testListenerInternalBroadcaster ; private final TestLoggingContainer testLogging ; private final DefaultJavaForkOptions forkOptions ; private final DefaultTestFilter filter ; private TestExecuter testExecuter ; private List < File > testSrcDirs = new ArrayList < File > ( ) ; private File testClassesDir ; private File binResultsDir ; private PatternFilterable patternSet = new PatternSet ( ) ; private boolean ignoreFailures ; private FileCollection classpath ; private TestFramework testFramework ; private boolean scanForTestClasses = true ; private long forkEvery ; private int maxParallelForks = <int> ; private TestReporter testReporter ; @Nested private final DefaultTestTaskReports reports ; public Test ( ) { ListenerManager listenerManager = getListenerManager ( ) ; testListenerInternalBroadcaster = listenerManager . createAnonymousBroadcaster ( TestListenerInternal . class ) ; testListenerBroadcaster = listenerManager . createAnonymousBroadcaster ( TestListener . class ) ; testOutputListenerBroadcaster = listenerManager . createAnonymousBroadcaster ( TestOutputListener . class ) ; forkOptions = new DefaultJavaForkOptions ( getFileResolver ( ) ) ; forkOptions . setEnableAssertions ( true ) ; Instantiator instantiator = getInstantiator ( ) ; testLogging = instantiator . newInstance ( DefaultTestLoggingContainer . class , instantiator ) ; reports = instantiator . newInstance ( DefaultTestTaskReports . class , this ) ; reports . getJunitXml ( ) . setEnabled ( true ) ; reports . getHtml ( ) . setEnabled ( true ) ; filter = instantiator . newInstance ( DefaultTestFilter . class ) ; addCandidateClassFilesHashProperty ( ) ; } @Inject protected ProgressLoggerFactory getProgressLoggerFactory ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected Instantiator getInstantiator ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected ActorFactory getActorFactory ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected ClassLoaderCache getClassLoaderCache ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected Factory < WorkerProcessBuilder > getProcessBuilderFactory ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected FileResolver getFileResolver ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected StyledTextOutputFactory getTextOutputFactory ( ) { throw new UnsupportedOperationException ( ) ; } @Inject protected ListenerManager getListenerManager ( ) { throw new UnsupportedOperationException ( ) ; } void setTestReporter ( TestReporter testReporter ) { this . testReporter = testReporter ; } void setTestExecuter ( TestExecuter testExecuter ) { this . testExecuter = testExecuter ; } ListenerBroadcast < TestListener > getTestListenerBroadcaster ( ) { return testListenerBroadcaster ; } ListenerBroadcast < TestListenerInternal > getTestListenerInternalBroadcaster ( ) { return testListenerInternalBroadcaster ; } ListenerBroadcast < TestOutputListener > getTestOutputListenerBroadcaster ( ) { return testOutputListenerBroadcaster ; } @Input public File getWorkingDir ( ) { return forkOptions . getWorkingDir ( ) ; } public void setWorkingDir ( Object dir ) { forkOptions . setWorkingDir ( dir ) ; } public Test workingDir ( Object dir ) { forkOptions . workingDir ( dir ) ; return this ; } @Input public String getExecutable ( ) { return forkOptions . getExecutable ( ) ; } public Test executable ( Object executable ) { forkOptions . executable ( executable ) ; return this ; } public void setExecutable ( Object executable ) { forkOptions . setExecutable ( executable ) ; } @Input public Map < String , Object > getSystemProperties ( ) { return forkOptions . getSystemProperties ( ) ; } public void setSystemProperties ( Map < String , ? > properties ) { forkOptions . setSystemProperties ( properties ) ; } public Test systemProperties ( Map < String , ? > properties ) { forkOptions . systemProperties ( properties ) ; return this ; } public Test systemProperty ( String name , Object value ) { forkOptions . systemProperty ( name , value ) ; return this ; } @Input public FileCollection getBootstrapClasspath ( ) { return forkOptions . getBootstrapClasspath ( ) ; } public void setBootstrapClasspath ( FileCollection classpath ) { forkOptions . setBootstrapClasspath ( classpath ) ; } public Test bootstrapClasspath ( Object . . . classpath ) { forkOptions . bootstrapClasspath ( classpath ) ; return this ; } public String getMinHeapSize ( ) { return forkOptions . getMinHeapSize ( ) ; } public String getDefaultCharacterEncoding ( ) { return forkOptions . getDefaultCharacterEncoding ( ) ; } public void setDefaultCharacterEncoding ( String defaultCharacterEncoding ) { forkOptions . setDefaultCharacterEncoding ( defaultCharacterEncoding ) ; } public void setMinHeapSize ( String heapSize ) { forkOptions . setMinHeapSize ( heapSize ) ; } public String getMaxHeapSize ( ) { return forkOptions . getMaxHeapSize ( ) ; } public void setMaxHeapSize ( String heapSize ) { forkOptions . setMaxHeapSize ( heapSize ) ; } @Input public List < String > getJvmArgs ( ) { return forkOptions . getJvmArgs ( ) ; } public void setJvmArgs ( Iterable < ? > arguments ) { forkOptions . setJvmArgs ( arguments ) ; } public Test jvmArgs ( Iterable < ? > arguments ) { forkOptions . jvmArgs ( arguments ) ; return this ; } public Test jvmArgs ( Object . . . arguments ) { forkOptions . jvmArgs ( arguments ) ; return this ; } @Input public boolean getEnableAssertions ( ) { return forkOptions . getEnableAssertions ( ) ; } public void setEnableAssertions ( boolean enabled ) { forkOptions . setEnableAssertions ( enabled ) ; } public boolean getDebug ( ) { return forkOptions . getDebug ( ) ; } @Option ( option = <str> , description = <str> ) public void setDebug ( boolean enabled ) { forkOptions . setDebug ( enabled ) ; } public List < String > getAllJvmArgs ( ) { return forkOptions . getAllJvmArgs ( ) ; } public void setAllJvmArgs ( Iterable < ? > arguments ) { forkOptions . setAllJvmArgs ( arguments ) ; } public Map < String , Object > getEnvironment ( ) { return forkOptions . getEnvironment ( ) ; } public Test environment ( Map < String , ? > environmentVariables ) { forkOptions . environment ( environmentVariables ) ; return this ; } public Test environment ( String name , Object value ) { forkOptions . environment ( name , value ) ; return this ; } public void setEnvironment ( Map < String , ? > environmentVariables ) { forkOptions . setEnvironment ( environmentVariables ) ; } public Test copyTo ( ProcessForkOptions target ) { forkOptions . copyTo ( target ) ; return this ; } public Test copyTo ( JavaForkOptions target ) { forkOptions . copyTo ( target ) ; return this ; } @TaskAction public void executeTests ( ) { LogLevel currentLevel = getCurrentLogLevel ( ) ; TestLogging levelLogging = testLogging . get ( currentLevel ) ; TestExceptionFormatter exceptionFormatter = getExceptionFormatter ( levelLogging ) ; TestEventLogger eventLogger = new TestEventLogger ( getTextOutputFactory ( ) , currentLevel , levelLogging , exceptionFormatter ) ; addTestListener ( eventLogger ) ; addTestOutputListener ( eventLogger ) ; if ( getFilter ( ) . isFailOnNoMatchingTests ( ) & & ! getFilter ( ) . getIncludePatterns ( ) . isEmpty ( ) ) { addTestListener ( new NoMatchingTestsReporter ( <str> + getFilter ( ) . getIncludePatterns ( ) ) ) ; } File binaryResultsDir = getBinResultsDir ( ) ; getProject ( ) . delete ( binaryResultsDir ) ; getProject ( ) . mkdir ( binaryResultsDir ) ; Map < String , TestClassResult > results = new HashMap < String , TestClassResult > ( ) ; TestOutputStore testOutputStore = new TestOutputStore ( binaryResultsDir ) ; TestOutputStore . Writer outputWriter = testOutputStore . writer ( ) ; TestReportDataCollector testReportDataCollector = new TestReportDataCollector ( results , outputWriter ) ; addTestListener ( testReportDataCollector ) ; addTestOutputListener ( testReportDataCollector ) ; TestCountLogger testCountLogger = new TestCountLogger ( getProgressLoggerFactory ( ) ) ; addTestListener ( testCountLogger ) ; testListenerInternalBroadcaster . add ( new TestListenerAdapter ( testListenerBroadcaster . getSource ( ) , testOutputListenerBroadcaster . getSource ( ) ) ) ; TestResultProcessor resultProcessor = new StateTrackingTestResultProcessor ( testListenerInternalBroadcaster . getSource ( ) ) ; if ( testExecuter = = null ) { testExecuter = new DefaultTestExecuter ( getProcessBuilderFactory ( ) , getActorFactory ( ) ) ; } try { testExecuter . execute ( this , resultProcessor ) ; } finally { testExecuter = null ; testListenerBroadcaster . removeAll ( ) ; testOutputListenerBroadcaster . removeAll ( ) ; testListenerInternalBroadcaster . removeAll ( ) ; outputWriter . close ( ) ; } new TestResultSerializer ( binaryResultsDir ) . write ( results . values ( ) ) ; TestResultsProvider testResultsProvider = new InMemoryTestResultsProvider ( results . values ( ) , testOutputStore . reader ( ) ) ; try { if ( testReporter = = null ) { testReporter = new DefaultTestReport ( ) ; } JUnitXmlReport junitXml = reports . getJunitXml ( ) ; if ( junitXml . isEnabled ( ) ) { TestOutputAssociation outputAssociation = junitXml . isOutputPerTestCase ( ) ? TestOutputAssociation . WITH_TESTCASE : TestOutputAssociation . WITH_SUITE ; Binary2JUnitXmlReportGenerator binary2JUnitXmlReportGenerator = new Binary2JUnitXmlReportGenerator ( junitXml . getDestination ( ) , testResultsProvider , outputAssociation ) ; binary2JUnitXmlReportGenerator . generate ( ) ; } DirectoryReport html = reports . getHtml ( ) ; if ( ! html . isEnabled ( ) ) { getLogger ( ) . info ( <str> ) ; } else { testReporter . generateReport ( testResultsProvider , html . getDestination ( ) ) ; } } finally { CompositeStoppable . stoppable ( testResultsProvider ) . stop ( ) ; testReporter = null ; testFramework = null ; } if ( testCountLogger . hadFailures ( ) ) { handleTestFailures ( ) ; } } public void addTestListener ( TestListener listener ) { testListenerBroadcaster . add ( listener ) ; } public void addTestOutputListener ( TestOutputListener listener ) { testOutputListenerBroadcaster . add ( listener ) ; } public void removeTestListener ( TestListener listener ) { testListenerBroadcaster . remove ( listener ) ; } public void removeTestOutputListener ( TestOutputListener listener ) { testOutputListenerBroadcaster . remove ( listener ) ; } public void beforeSuite ( Closure closure ) { testListenerBroadcaster . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void afterSuite ( Closure closure ) { testListenerBroadcaster . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void beforeTest ( Closure closure ) { testListenerBroadcaster . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void afterTest ( Closure closure ) { testListenerBroadcaster . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void onOutput ( Closure closure ) { testOutputListenerBroadcaster . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public Test include ( String . . . includes ) { patternSet . include ( includes ) ; return this ; } public Test include ( Iterable < String > includes ) { patternSet . include ( includes ) ; return this ; } public Test include ( Spec < FileTreeElement > includeSpec ) { patternSet . include ( includeSpec ) ; return this ; } public Test include ( Closure includeSpec ) { patternSet . include ( includeSpec ) ; return this ; } public Test exclude ( String . . . excludes ) { patternSet . exclude ( excludes ) ; return this ; } public Test exclude ( Iterable < String > excludes ) { patternSet . exclude ( excludes ) ; return this ; } public Test exclude ( Spec < FileTreeElement > excludeSpec ) { patternSet . exclude ( excludeSpec ) ; return this ; } public Test exclude ( Closure excludeSpec ) { patternSet . exclude ( excludeSpec ) ; return this ; } @Option ( option = <str> , description = <str> ) @Incubating public Test setTestNameIncludePattern ( String testNamePattern ) { filter . setIncludePatterns ( testNamePattern ) ; return this ; } public File getTestClassesDir ( ) { return testClassesDir ; } public void setTestClassesDir ( File testClassesDir ) { this . testClassesDir = testClassesDir ; } @OutputDirectory @Incubating public File getBinResultsDir ( ) { return binResultsDir ; } @Incubating public void setBinResultsDir ( File binResultsDir ) { this . binResultsDir = binResultsDir ; } public Set < String > getIncludes ( ) { return patternSet . getIncludes ( ) ; } public Test setIncludes ( Iterable < String > includes ) { patternSet . setIncludes ( includes ) ; return this ; } public Set < String > getExcludes ( ) { return patternSet . getExcludes ( ) ; } public Test setExcludes ( Iterable < String > excludes ) { patternSet . setExcludes ( excludes ) ; return this ; } @Input public boolean getIgnoreFailures ( ) { return ignoreFailures ; } public void setIgnoreFailures ( boolean ignoreFailures ) { this . ignoreFailures = ignoreFailures ; } public TestFramework getTestFramework ( ) { return testFramework ( null ) ; } public TestFramework testFramework ( Closure testFrameworkConfigure ) { if ( testFramework = = null ) { useJUnit ( testFrameworkConfigure ) ; } return testFramework ; } @Nested public TestFrameworkOptions getOptions ( ) { return options ( null ) ; } public TestFrameworkOptions options ( Closure testFrameworkConfigure ) { TestFrameworkOptions options = getTestFramework ( ) . getOptions ( ) ; ConfigureUtil . configure ( testFrameworkConfigure , options ) ; return options ; } TestFramework useTestFramework ( TestFramework testFramework ) { return useTestFramework ( testFramework , null ) ; } private TestFramework useTestFramework ( TestFramework testFramework , Closure testFrameworkConfigure ) { if ( testFramework = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . testFramework = testFramework ; if ( testFrameworkConfigure ! = null ) { ConfigureUtil . configure ( testFrameworkConfigure , this . testFramework . getOptions ( ) ) ; } return this . testFramework ; } public void useJUnit ( ) { useJUnit ( null ) ; } public void useJUnit ( Closure testFrameworkConfigure ) { useTestFramework ( new JUnitTestFramework ( this , filter , getClassLoaderCache ( ) ) , testFrameworkConfigure ) ; } public void useTestNG ( ) { useTestNG ( null ) ; } public void useTestNG ( Closure testFrameworkConfigure ) { useTestFramework ( new TestNGTestFramework ( this , this . filter , getInstantiator ( ) , getClassLoaderCache ( ) ) , testFrameworkConfigure ) ; } @InputFiles public FileCollection getClasspath ( ) { return classpath ; } public void setClasspath ( FileCollection classpath ) { this . classpath = classpath ; } @InputFiles public List < File > getTestSrcDirs ( ) { return testSrcDirs ; } public void setTestSrcDirs ( List < File > testSrcDir ) { this . testSrcDirs = testSrcDir ; } @Input public boolean isScanForTestClasses ( ) { return scanForTestClasses ; } public void setScanForTestClasses ( boolean scanForTestClasses ) { this . scanForTestClasses = scanForTestClasses ; } public long getForkEvery ( ) { return forkEvery ; } public void setForkEvery ( Long forkEvery ) { if ( forkEvery ! = null & & forkEvery < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . forkEvery = forkEvery = = null ? <int> : forkEvery ; } public int getMaxParallelForks ( ) { return getDebug ( ) ? <int> : maxParallelForks ; } public void setMaxParallelForks ( int maxParallelForks ) { if ( maxParallelForks < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxParallelForks = maxParallelForks ; } @InputFiles public FileTree getCandidateClassFiles ( ) { return getProject ( ) . fileTree ( getTestClassesDir ( ) ) . matching ( patternSet ) ; } private void addCandidateClassFilesHashProperty ( ) { getInputs ( ) . property ( <str> , new Callable < Integer > ( ) { Integer candidateClassFilesHash ; @Override public Integer call ( ) throws Exception { if ( candidateClassFilesHash = = null ) { candidateClassFilesHash = calculateCandidateClassFilesHash ( ) ; } return candidateClassFilesHash ; } } ) ; } private Integer calculateCandidateClassFilesHash ( ) { final SortedSet < FileTreeElement > sortedFiles = new TreeSet < FileTreeElement > ( FileTreeElementComparator . INSTANCE ) ; getCandidateClassFiles ( ) . visit ( new EmptyFileVisitor ( ) { @Override public void visitFile ( FileVisitDetails fileDetails ) { sortedFiles . add ( fileDetails ) ; } } ) ; return FileTreeElementHasher . calculateHashForFilePaths ( sortedFiles ) ; } public TestLoggingContainer getTestLogging ( ) { return testLogging ; } public void testLogging ( Closure closure ) { ConfigureUtil . configure ( closure , testLogging ) ; } public TestTaskReports getReports ( ) { return reports ; } public TestTaskReports reports ( Closure closure ) { reports . configure ( closure ) ; return reports ; } @Incubating @Nested public TestFilter getFilter ( ) { return filter ; } @Incubating public void filter ( Action < TestFilter > action ) { action . execute ( filter ) ; } private LogLevel getCurrentLogLevel ( ) { for ( LogLevel level : LogLevel . values ( ) ) { if ( getLogger ( ) . isEnabled ( level ) ) { return level ; } } throw new AssertionError ( <str> ) ; } private TestExceptionFormatter getExceptionFormatter ( TestLogging testLogging ) { switch ( testLogging . getExceptionFormat ( ) ) { case SHORT : return new ShortExceptionFormatter ( testLogging ) ; case FULL : return new FullExceptionFormatter ( testLogging ) ; default : throw new AssertionError ( ) ; } } private void handleTestFailures ( ) { String message = <str> ; DirectoryReport htmlReport = reports . getHtml ( ) ; if ( htmlReport . isEnabled ( ) ) { String reportUrl = new ConsoleRenderer ( ) . asClickableFileUrl ( htmlReport . getEntryPoint ( ) ) ; message = message . concat ( <str> + reportUrl ) ; } else { DirectoryReport junitXmlReport = reports . getJunitXml ( ) ; if ( junitXmlReport . isEnabled ( ) ) { String resultsUrl = new ConsoleRenderer ( ) . asClickableFileUrl ( junitXmlReport . getEntryPoint ( ) ) ; message = message . concat ( <str> + resultsUrl ) ; } } if ( getIgnoreFailures ( ) ) { getLogger ( ) . warn ( message ) ; } else { throw new GradleException ( message ) ; } } } 
