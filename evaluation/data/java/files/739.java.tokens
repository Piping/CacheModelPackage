package com . google . common . graph ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Maps ; import java . util . Map ; import javax . annotation . CheckReturnValue ; @Beta @CheckReturnValue public final class GraphProperties { private GraphProperties ( ) { } public static boolean isCyclic ( DirectedGraph < ? , ? > graph ) { checkNotNull ( graph , <str> ) ; Map < Object , NodeVisitState > nodeToVisitState = Maps . newHashMap ( ) ; for ( Object node : graph . nodes ( ) ) { if ( nodeToVisitState . get ( node ) = = null ) { if ( isSubgraphCyclic ( graph , nodeToVisitState , node ) ) { return true ; } } } return false ; } private static boolean isSubgraphCyclic ( DirectedGraph < ? , ? > graph , Map < Object , NodeVisitState > nodeToVisitState , Object node ) { nodeToVisitState . put ( node , NodeVisitState . PENDING ) ; for ( Object successor : graph . successors ( node ) ) { NodeVisitState nodeVisitState = nodeToVisitState . get ( successor ) ; if ( nodeVisitState = = NodeVisitState . PENDING ) { return true ; } else if ( nodeVisitState = = null ) { if ( isSubgraphCyclic ( graph , nodeToVisitState , successor ) ) { return true ; } } } nodeToVisitState . put ( node , NodeVisitState . COMPLETE ) ; return false ; } private enum NodeVisitState { PENDING , COMPLETE } public static < N > ImmutableSet < N > roots ( DirectedGraph < N , ? > directedGraph ) { ImmutableSet . Builder < N > builder = ImmutableSet . builder ( ) ; for ( N node : directedGraph . nodes ( ) ) { if ( directedGraph . predecessors ( node ) . isEmpty ( ) ) { builder . add ( node ) ; } } return builder . build ( ) ; } }