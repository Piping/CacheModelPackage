package org . elasticsearch . search . aggregations . pipeline . moving . avg ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . collect . EvictingQueue ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . EwmaModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . HoltLinearModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . HoltWintersModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . LinearModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . SimpleModel ; import org . elasticsearch . test . ESTestCase ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . hamcrest . Matchers . equalTo ; public class MovAvgUnitTests extends ESTestCase { public void testSimpleMovAvgModel ( ) { MovAvgModel model = new SimpleModel ( ) ; int numValues = randomIntBetween ( <int> , <int> ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < numValues ; i + + ) { double randValue = randomDouble ( ) ; double expected = <int> ; if ( i = = <int> ) { window . offer ( randValue ) ; continue ; } for ( double value : window ) { expected + = value ; } expected / = window . size ( ) ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; window . offer ( randValue ) ; } } public void testSimplePredictionModel ( ) { MovAvgModel model = new SimpleModel ( ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double t = <int> ; for ( double value : window ) { t + = value ; } t / = window . size ( ) ; Arrays . fill ( expected , t ) ; for ( int i = <int> ; i < numPredictions ; i + + ) { assertThat ( Double . compare ( expected [ i ] , actual [ i ] ) , equalTo ( <int> ) ) ; } } public void testLinearMovAvgModel ( ) { MovAvgModel model = new LinearModel ( ) ; int numValues = randomIntBetween ( <int> , <int> ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < numValues ; i + + ) { double randValue = randomDouble ( ) ; if ( i = = <int> ) { window . offer ( randValue ) ; continue ; } double avg = <int> ; long totalWeight = <int> ; long current = <int> ; for ( double value : window ) { avg + = value * current ; totalWeight + = current ; current + = <int> ; } double expected = avg / totalWeight ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; window . offer ( randValue ) ; } } public void testLinearPredictionModel ( ) { MovAvgModel model = new LinearModel ( ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double avg = <int> ; long totalWeight = <int> ; long current = <int> ; for ( double value : window ) { avg + = value * current ; totalWeight + = current ; current + = <int> ; } avg = avg / totalWeight ; Arrays . fill ( expected , avg ) ; for ( int i = <int> ; i < numPredictions ; i + + ) { assertThat ( Double . compare ( expected [ i ] , actual [ i ] ) , equalTo ( <int> ) ) ; } } public void testEWMAMovAvgModel ( ) { double alpha = randomDouble ( ) ; MovAvgModel model = new EwmaModel ( alpha ) ; int numValues = randomIntBetween ( <int> , <int> ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < numValues ; i + + ) { double randValue = randomDouble ( ) ; if ( i = = <int> ) { window . offer ( randValue ) ; continue ; } double avg = <int> ; boolean first = true ; for ( double value : window ) { if ( first ) { avg = value ; first = false ; } else { avg = ( value * alpha ) + ( avg * ( <int> - alpha ) ) ; } } double expected = avg ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; window . offer ( randValue ) ; } } public void testEWMAPredictionModel ( ) { double alpha = randomDouble ( ) ; MovAvgModel model = new EwmaModel ( alpha ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double avg = <int> ; boolean first = true ; for ( double value : window ) { if ( first ) { avg = value ; first = false ; } else { avg = ( value * alpha ) + ( avg * ( <int> - alpha ) ) ; } } Arrays . fill ( expected , avg ) ; for ( int i = <int> ; i < numPredictions ; i + + ) { assertThat ( Double . compare ( expected [ i ] , actual [ i ] ) , equalTo ( <int> ) ) ; } } public void testHoltLinearMovAvgModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; MovAvgModel model = new HoltLinearModel ( alpha , beta ) ; int numValues = randomIntBetween ( <int> , <int> ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < numValues ; i + + ) { double randValue = randomDouble ( ) ; if ( i = = <int> ) { window . offer ( randValue ) ; continue ; } double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; int counter = <int> ; double last ; for ( double value : window ) { last = value ; if ( counter = = <int> ) { s = value ; b = value - last ; } else { s = alpha * value + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; } counter + = <int> ; last_s = s ; last_b = b ; } double expected = s + ( <int> * b ) ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; window . offer ( randValue ) ; } } public void testHoltLinearPredictionModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; MovAvgModel model = new HoltLinearModel ( alpha , beta ) ; int windowSize = randomIntBetween ( <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; int counter = <int> ; double last ; for ( double value : window ) { last = value ; if ( counter = = <int> ) { s = value ; b = value - last ; } else { s = alpha * value + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; } counter + = <int> ; last_s = s ; last_b = b ; } for ( int i = <int> ; i < numPredictions ; i + + ) { expected [ i ] = s + ( i * b ) ; assertThat ( Double . compare ( expected [ i ] , actual [ i ] ) , equalTo ( <int> ) ) ; } } public void testHoltWintersMultiplicativePadModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; double gamma = randomDouble ( ) ; int period = randomIntBetween ( <int> , <int> ) ; MovAvgModel model = new HoltWintersModel ( alpha , beta , gamma , period , HoltWintersModel . SeasonalityType . MULTIPLICATIVE , true ) ; int windowSize = randomIntBetween ( period * <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ windowSize ] ; int counter = <int> ; double [ ] vs = new double [ windowSize ] ; for ( double v : window ) { vs [ counter ] = v + <float> ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = period ; b / = period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { s = alpha * ( vs [ i ] / seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; seasonal [ i ] = gamma * ( vs [ i ] / ( last_s + last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; last_s = s ; last_b = b ; } int idx = window . size ( ) - period + ( <int> % period ) ; double expected = ( s + ( <int> * b ) ) * seasonal [ idx ] ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; } public void testHoltWintersMultiplicativePadPredictionModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; double gamma = randomDouble ( ) ; int period = randomIntBetween ( <int> , <int> ) ; MovAvgModel model = new HoltWintersModel ( alpha , beta , gamma , period , HoltWintersModel . SeasonalityType . MULTIPLICATIVE , true ) ; int windowSize = randomIntBetween ( period * <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ windowSize ] ; int counter = <int> ; double [ ] vs = new double [ windowSize ] ; for ( double v : window ) { vs [ counter ] = v + <float> ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = period ; b / = period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { s = alpha * ( vs [ i ] / seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; seasonal [ i ] = gamma * ( vs [ i ] / ( last_s + last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; last_s = s ; last_b = b ; } for ( int i = <int> ; i < = numPredictions ; i + + ) { int idx = window . size ( ) - period + ( ( i - <int> ) % period ) ; expected [ i - <int> ] = ( s + ( i * b ) ) * seasonal [ idx ] ; assertThat ( Double . compare ( expected [ i - <int> ] , actual [ i - <int> ] ) , equalTo ( <int> ) ) ; } } public void testHoltWintersAdditiveModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; double gamma = randomDouble ( ) ; int period = randomIntBetween ( <int> , <int> ) ; MovAvgModel model = new HoltWintersModel ( alpha , beta , gamma , period , HoltWintersModel . SeasonalityType . ADDITIVE , false ) ; int windowSize = randomIntBetween ( period * <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ windowSize ] ; int counter = <int> ; double [ ] vs = new double [ windowSize ] ; for ( double v : window ) { vs [ counter ] = v ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = period ; b / = period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { s = alpha * ( vs [ i ] - seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; seasonal [ i ] = gamma * ( vs [ i ] - ( last_s - last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; last_s = s ; last_b = b ; } int idx = window . size ( ) - period + ( <int> % period ) ; double expected = s + ( <int> * b ) + seasonal [ idx ] ; double actual = model . next ( window ) ; assertThat ( Double . compare ( expected , actual ) , equalTo ( <int> ) ) ; } public void testHoltWintersAdditivePredictionModel ( ) { double alpha = randomDouble ( ) ; double beta = randomDouble ( ) ; double gamma = randomDouble ( ) ; int period = randomIntBetween ( <int> , <int> ) ; MovAvgModel model = new HoltWintersModel ( alpha , beta , gamma , period , HoltWintersModel . SeasonalityType . ADDITIVE , false ) ; int windowSize = randomIntBetween ( period * <int> , <int> ) ; int numPredictions = randomIntBetween ( <int> , <int> ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( int i = <int> ; i < windowSize ; i + + ) { window . offer ( randomDouble ( ) ) ; } double actual [ ] = model . predict ( window , numPredictions ) ; double expected [ ] = new double [ numPredictions ] ; double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ windowSize ] ; int counter = <int> ; double [ ] vs = new double [ windowSize ] ; for ( double v : window ) { vs [ counter ] = v ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = period ; b / = period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { s = alpha * ( vs [ i ] - seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; seasonal [ i ] = gamma * ( vs [ i ] - ( last_s - last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; last_s = s ; last_b = b ; } for ( int i = <int> ; i < = numPredictions ; i + + ) { int idx = window . size ( ) - period + ( ( i - <int> ) % period ) ; expected [ i - <int> ] = s + ( i * b ) + seasonal [ idx ] ; assertThat ( Double . compare ( expected [ i - <int> ] , actual [ i - <int> ] ) , equalTo ( <int> ) ) ; } } public void testNumericValidation ( ) { List < MovAvgModel . AbstractModelParser > parsers = new ArrayList < > ( <int> ) ; parsers . add ( new EwmaModel . SingleExpModelParser ( ) ) ; parsers . add ( new HoltWintersModel . HoltWintersModelParser ( ) ) ; parsers . add ( new HoltLinearModel . DoubleExpModelParser ( ) ) ; Object [ ] values = { ( byte ) <int> , <int> , <int> , ( short ) <int> , ( double ) <int> } ; Map < String , Object > settings = new HashMap < > ( <int> ) ; for ( MovAvgModel . AbstractModelParser parser : parsers ) { for ( Object v : values ) { settings . put ( <str> , v ) ; try { parser . parse ( settings , <str> , <int> , ParseFieldMatcher . STRICT ) ; } catch ( ParseException e ) { fail ( parser . getName ( ) + <str> + v . getClass ( ) . getSimpleName ( ) + <str> ) ; } } } for ( MovAvgModel . AbstractModelParser parser : parsers ) { settings . put ( <str> , <str> ) ; settings . put ( <str> , <str> ) ; settings . put ( <str> , <str> ) ; try { parser . parse ( settings , <str> , <int> , ParseFieldMatcher . STRICT ) ; } catch ( ParseException e ) { continue ; } fail ( parser . getName ( ) + <str> ) ; } } } 
