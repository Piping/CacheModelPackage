package com . google . common . graph ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . graph . GraphErrorMessageUtils . ADDING_PARALLEL_EDGE ; import static com . google . common . graph . GraphErrorMessageUtils . EDGE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . NODE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . REUSING_EDGE ; import static com . google . common . graph . GraphErrorMessageUtils . SELF_LOOPS_NOT_ALLOWED ; import static com . google . common . graph . Graphs . oppositeNode ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import java . util . Collections ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; final class IncidenceSetUndirectedGraph < N , E > implements UndirectedGraph < N , E > { private final Map < N , Set < E > > nodeToIncidentEdges ; private final Map < E , ImmutableSet < N > > edgeToIncidentNodes ; private final GraphConfig config ; IncidenceSetUndirectedGraph ( GraphConfig config ) { this . nodeToIncidentEdges = Maps . newLinkedHashMapWithExpectedSize ( config . getExpectedNodeCount ( ) . or ( <int> ) ) ; this . edgeToIncidentNodes = Maps . newLinkedHashMapWithExpectedSize ( config . getExpectedEdgeCount ( ) . or ( <int> ) ) ; this . config = config ; } @Override public Set < N > nodes ( ) { return Collections . unmodifiableSet ( nodeToIncidentEdges . keySet ( ) ) ; } @Override public Set < E > edges ( ) { return Collections . unmodifiableSet ( edgeToIncidentNodes . keySet ( ) ) ; } @Override public GraphConfig config ( ) { return config ; } @Override public Set < E > incidentEdges ( Object node ) { checkNotNull ( node , <str> ) ; Set < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return Collections . unmodifiableSet ( incidentEdges ) ; } @Override public Set < N > incidentNodes ( Object edge ) { checkNotNull ( edge , <str> ) ; Set < N > incidentNodes = edgeToIncidentNodes . get ( edge ) ; checkArgument ( incidentNodes ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return Collections . unmodifiableSet ( incidentNodes ) ; } @Override public Set < N > adjacentNodes ( final Object node ) { checkNotNull ( node , <str> ) ; final Set < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return new SetView < N > ( ) { @Override public boolean isEmpty ( ) { return incidentEdges . isEmpty ( ) ; } @Override Set < N > elements ( ) { Set < N > nodes = Sets . newLinkedHashSetWithExpectedSize ( incidentEdges . size ( ) ) ; for ( E edge : incidentEdges ) { nodes . add ( oppositeNode ( IncidenceSetUndirectedGraph . this , edge , node ) ) ; } return nodes ; } } ; } @Override public Set < E > adjacentEdges ( Object edge ) { checkNotNull ( edge , <str> ) ; Set < N > incidentNodes = edgeToIncidentNodes . get ( edge ) ; checkArgument ( incidentNodes ! = null , EDGE_NOT_IN_GRAPH , edge ) ; Object [ ] endpoints = incidentNodes . toArray ( ) ; Set < E > endpointsIncidentEdges = endpoints . length = = <int> ? incidentEdges ( endpoints [ <int> ] ) : Sets . union ( incidentEdges ( endpoints [ <int> ] ) , incidentEdges ( endpoints [ <int> ] ) ) ; return Sets . difference ( endpointsIncidentEdges , ImmutableSet . of ( edge ) ) ; } @Override public Set < E > edgesConnecting ( final Object node1 , Object node2 ) { checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; final Set < E > incidentEdgesN1 = nodeToIncidentEdges . get ( node1 ) ; checkArgument ( incidentEdgesN1 ! = null , NODE_NOT_IN_GRAPH , node1 ) ; if ( node1 . equals ( node2 ) ) { if ( ! config . isSelfLoopsAllowed ( ) ) { return ImmutableSet . of ( ) ; } return new SetView < E > ( ) { @Override Set < E > elements ( ) { Set < E > selfLoopEdges = Sets . newLinkedHashSet ( ) ; for ( E edge : incidentEdgesN1 ) { if ( edgeToIncidentNodes . get ( edge ) . size ( ) = = <int> ) { selfLoopEdges . add ( edge ) ; } } return selfLoopEdges ; } } ; } final Set < E > incidentEdgesN2 = nodeToIncidentEdges . get ( node2 ) ; checkArgument ( incidentEdgesN2 ! = null , NODE_NOT_IN_GRAPH , node2 ) ; return incidentEdgesN1 . size ( ) < = incidentEdgesN2 . size ( ) ? Sets . intersection ( incidentEdgesN1 , incidentEdgesN2 ) : Sets . intersection ( incidentEdgesN2 , incidentEdgesN1 ) ; } @Override public Set < E > inEdges ( Object node ) { return incidentEdges ( node ) ; } @Override public Set < E > outEdges ( Object node ) { return incidentEdges ( node ) ; } @Override public Set < N > predecessors ( Object node ) { return adjacentNodes ( node ) ; } @Override public Set < N > successors ( Object node ) { return adjacentNodes ( node ) ; } @Override public long degree ( Object node ) { checkNotNull ( node , <str> ) ; Set < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges . size ( ) ; } @Override public long inDegree ( Object node ) { return degree ( node ) ; } @Override public long outDegree ( Object node ) { return degree ( node ) ; } @Override public boolean addNode ( N node ) { checkNotNull ( node , <str> ) ; if ( containsNode ( node ) ) { return false ; } nodeToIncidentEdges . put ( node , new LinkedHashSet < E > ( ) ) ; return true ; } @Override public boolean addEdge ( E edge , N node1 , N node2 ) { checkNotNull ( edge , <str> ) ; checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; checkArgument ( config . isSelfLoopsAllowed ( ) | | ! node1 . equals ( node2 ) , SELF_LOOPS_NOT_ALLOWED , node1 ) ; ImmutableSet < N > endpoints = ImmutableSet . of ( node1 , node2 ) ; Set < N > incidentNodes = edgeToIncidentNodes . get ( edge ) ; if ( incidentNodes ! = null ) { checkArgument ( incidentNodes . equals ( endpoints ) , REUSING_EDGE , edge , incidentNodes , endpoints ) ; return false ; } else if ( ! config . isMultigraph ( ) & & containsNode ( node1 ) & & containsNode ( node2 ) ) { E edgeConnecting = Iterables . getOnlyElement ( edgesConnecting ( node1 , node2 ) , null ) ; checkArgument ( edgeConnecting = = null , ADDING_PARALLEL_EDGE , node1 , node2 , edgeConnecting ) ; } addNode ( node1 ) ; addNode ( node2 ) ; edgeToIncidentNodes . put ( edge , endpoints ) ; nodeToIncidentEdges . get ( node1 ) . add ( edge ) ; if ( ! node1 . equals ( node2 ) ) { nodeToIncidentEdges . get ( node2 ) . add ( edge ) ; } return true ; } @Override public boolean removeNode ( Object node ) { checkNotNull ( node , <str> ) ; Set < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; if ( incidentEdges = = null ) { return false ; } for ( Object edge : incidentEdges . toArray ( ) ) { removeEdge ( edge ) ; } nodeToIncidentEdges . remove ( node ) ; return true ; } @Override public boolean removeEdge ( Object edge ) { checkNotNull ( edge , <str> ) ; Set < N > incidentNodes = edgeToIncidentNodes . get ( edge ) ; if ( incidentNodes = = null ) { return false ; } for ( N node : incidentNodes ) { nodeToIncidentEdges . get ( node ) . remove ( edge ) ; } edgeToIncidentNodes . remove ( edge ) ; return true ; } @Override public boolean equals ( @Nullable Object object ) { return ( object instanceof UndirectedGraph ) & & Graphs . equal ( this , ( UndirectedGraph ) object ) ; } @Override public int hashCode ( ) { return nodeToIncidentEdges . hashCode ( ) ; } @Override public String toString ( ) { return String . format ( <str> , config , nodeToIncidentEdges . keySet ( ) , edgeToIncidentNodes ) ; } private boolean containsNode ( Object node ) { return nodeToIncidentEdges . containsKey ( node ) ; } }