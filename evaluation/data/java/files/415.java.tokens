package org . apache . cassandra . gms ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . * ; import java . util . concurrent . locks . ReentrantLock ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . ImmutableList ; import com . google . common . util . concurrent . Uninterruptibles ; import org . apache . cassandra . utils . Pair ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . DebuggableScheduledThreadPoolExecutor ; import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . net . IAsyncCallback ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . JVMStabilityInspector ; public class Gossiper implements IFailureDetectionEventListener , GossiperMBean { public static final String MBEAN_NAME = <str> ; private static final DebuggableScheduledThreadPoolExecutor executor = new DebuggableScheduledThreadPoolExecutor ( <str> ) ; static final ApplicationState [ ] STATES = ApplicationState . values ( ) ; static final List < String > DEAD_STATES = Arrays . asList ( VersionedValue . REMOVING_TOKEN , VersionedValue . REMOVED_TOKEN , VersionedValue . STATUS_LEFT , VersionedValue . HIBERNATE ) ; static ArrayList < String > SILENT_SHUTDOWN_STATES = new ArrayList < > ( ) ; static { SILENT_SHUTDOWN_STATES . addAll ( DEAD_STATES ) ; SILENT_SHUTDOWN_STATES . add ( VersionedValue . STATUS_BOOTSTRAPPING ) ; } private ScheduledFuture < ? > scheduledGossipTask ; private static final ReentrantLock taskLock = new ReentrantLock ( ) ; public final static int intervalInMillis = <int> ; public final static int QUARANTINE_DELAY = StorageService . RING_DELAY * <int> ; private static final Logger logger = LoggerFactory . getLogger ( Gossiper . class ) ; public static final Gossiper instance = new Gossiper ( ) ; public static final long aVeryLongTime = <int> * <int> ; private static final long MAX_GENERATION_DIFFERENCE = <int> * <int> ; private long fatClientTimeout ; private final Random random = new Random ( ) ; private final Comparator < InetAddress > inetcomparator = new Comparator < InetAddress > ( ) { public int compare ( InetAddress addr1 , InetAddress addr2 ) { return addr1 . getHostAddress ( ) . compareTo ( addr2 . getHostAddress ( ) ) ; } } ; private final List < IEndpointStateChangeSubscriber > subscribers = new CopyOnWriteArrayList < IEndpointStateChangeSubscriber > ( ) ; private final Set < InetAddress > liveEndpoints = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; private final Map < InetAddress , Long > unreachableEndpoints = new ConcurrentHashMap < InetAddress , Long > ( ) ; private final Set < InetAddress > seeds = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; final ConcurrentMap < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; private final Map < InetAddress , Long > justRemovedEndpoints = new ConcurrentHashMap < InetAddress , Long > ( ) ; private final Map < InetAddress , Long > expireTimeEndpointMap = new ConcurrentHashMap < InetAddress , Long > ( ) ; private boolean inShadowRound = false ; private volatile long lastProcessedMessageAt = System . currentTimeMillis ( ) ; private class GossipTask implements Runnable { public void run ( ) { try { MessagingService . instance ( ) . waitUntilListening ( ) ; taskLock . lock ( ) ; endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) . getHeartBeatState ( ) . updateHeartBeat ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) . getHeartBeatState ( ) . getHeartBeatVersion ( ) ) ; final List < GossipDigest > gDigests = new ArrayList < GossipDigest > ( ) ; Gossiper . instance . makeRandomGossipDigest ( gDigests ) ; if ( gDigests . size ( ) > <int> ) { GossipDigestSyn digestSynMessage = new GossipDigestSyn ( DatabaseDescriptor . getClusterName ( ) , DatabaseDescriptor . getPartitionerName ( ) , gDigests ) ; MessageOut < GossipDigestSyn > message = new MessageOut < GossipDigestSyn > ( MessagingService . Verb . GOSSIP_DIGEST_SYN , digestSynMessage , GossipDigestSyn . serializer ) ; boolean gossipedToSeed = doGossipToLiveMember ( message ) ; maybeGossipToUnreachableMember ( message ) ; if ( ! gossipedToSeed | | liveEndpoints . size ( ) < seeds . size ( ) ) maybeGossipToSeed ( message ) ; doStatusCheck ( ) ; } } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; logger . error ( <str> , e ) ; } finally { taskLock . unlock ( ) ; } } } private Gossiper ( ) { fatClientTimeout = ( QUARANTINE_DELAY / <int> ) ; FailureDetector . instance . registerFailureDetectionEventListener ( this ) ; try { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public void setLastProcessedMessageAt ( long timeInMillis ) { this . lastProcessedMessageAt = timeInMillis ; } public boolean seenAnySeed ( ) { for ( Map . Entry < InetAddress , EndpointState > entry : endpointStateMap . entrySet ( ) ) { if ( seeds . contains ( entry . getKey ( ) ) ) return true ; try { VersionedValue internalIp = entry . getValue ( ) . getApplicationState ( ApplicationState . INTERNAL_IP ) ; if ( internalIp ! = null & & seeds . contains ( InetAddress . getByName ( internalIp . value ) ) ) return true ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } return false ; } public void register ( IEndpointStateChangeSubscriber subscriber ) { subscribers . add ( subscriber ) ; } public void unregister ( IEndpointStateChangeSubscriber subscriber ) { subscribers . remove ( subscriber ) ; } public Set < InetAddress > getLiveMembers ( ) { Set < InetAddress > liveMembers = new HashSet < > ( liveEndpoints ) ; if ( ! liveMembers . contains ( FBUtilities . getBroadcastAddress ( ) ) ) liveMembers . add ( FBUtilities . getBroadcastAddress ( ) ) ; return liveMembers ; } public Set < InetAddress > getLiveTokenOwners ( ) { return StorageService . instance . getLiveRingMembers ( true ) ; } public Set < InetAddress > getUnreachableMembers ( ) { return unreachableEndpoints . keySet ( ) ; } public Set < InetAddress > getUnreachableTokenOwners ( ) { Set < InetAddress > tokenOwners = new HashSet < > ( ) ; for ( InetAddress endpoint : unreachableEndpoints . keySet ( ) ) { if ( StorageService . instance . getTokenMetadata ( ) . isMember ( endpoint ) ) tokenOwners . add ( endpoint ) ; } return tokenOwners ; } public long getEndpointDowntime ( InetAddress ep ) { Long downtime = unreachableEndpoints . get ( ep ) ; if ( downtime ! = null ) return TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - downtime ) ; else return <int> ; } private boolean isShutdown ( InetAddress endpoint ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null ) return false ; if ( epState . getApplicationState ( ApplicationState . STATUS ) = = null ) return false ; String value = epState . getApplicationState ( ApplicationState . STATUS ) . value ; String [ ] pieces = value . split ( VersionedValue . DELIMITER_STR , - <int> ) ; assert ( pieces . length > <int> ) ; String state = pieces [ <int> ] ; return state . equals ( VersionedValue . SHUTDOWN ) ; } public void convict ( InetAddress endpoint , double phi ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null ) return ; logger . debug ( <str> , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; if ( ! epState . isAlive ( ) ) return ; if ( isShutdown ( endpoint ) ) { markAsShutdown ( endpoint ) ; } else { markDead ( endpoint , epState ) ; } } protected void markAsShutdown ( InetAddress endpoint ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null ) return ; epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . shutdown ( true ) ) ; epState . getHeartBeatState ( ) . forceHighestPossibleVersionUnsafe ( ) ; markDead ( endpoint , epState ) ; FailureDetector . instance . forceConviction ( endpoint ) ; } int getMaxEndpointStateVersion ( EndpointState epState ) { int maxVersion = epState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; for ( Map . Entry < ApplicationState , VersionedValue > state : epState . states ( ) ) maxVersion = Math . max ( maxVersion , state . getValue ( ) . version ) ; return maxVersion ; } private void evictFromMembership ( InetAddress endpoint ) { unreachableEndpoints . remove ( endpoint ) ; endpointStateMap . remove ( endpoint ) ; expireTimeEndpointMap . remove ( endpoint ) ; quarantineEndpoint ( endpoint ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , endpoint ) ; } public void removeEndpoint ( InetAddress endpoint ) { for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onRemove ( endpoint ) ; if ( seeds . contains ( endpoint ) ) { buildSeedsList ( ) ; seeds . remove ( endpoint ) ; logger . info ( <str> , endpoint , seeds ) ; } liveEndpoints . remove ( endpoint ) ; unreachableEndpoints . remove ( endpoint ) ; FailureDetector . instance . remove ( endpoint ) ; MessagingService . instance ( ) . resetVersion ( endpoint ) ; quarantineEndpoint ( endpoint ) ; MessagingService . instance ( ) . destroyConnectionPool ( endpoint ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , endpoint ) ; } private void quarantineEndpoint ( InetAddress endpoint ) { quarantineEndpoint ( endpoint , System . currentTimeMillis ( ) ) ; } private void quarantineEndpoint ( InetAddress endpoint , long quarantineExpiration ) { justRemovedEndpoints . put ( endpoint , quarantineExpiration ) ; } public void replacementQuarantine ( InetAddress endpoint ) { logger . debug ( <str> ) ; quarantineEndpoint ( endpoint , System . currentTimeMillis ( ) + QUARANTINE_DELAY ) ; } public void replacedEndpoint ( InetAddress endpoint ) { removeEndpoint ( endpoint ) ; evictFromMembership ( endpoint ) ; replacementQuarantine ( endpoint ) ; } private void makeRandomGossipDigest ( List < GossipDigest > gDigests ) { EndpointState epState ; int generation = <int> ; int maxVersion = <int> ; List < InetAddress > endpoints = new ArrayList < InetAddress > ( endpointStateMap . keySet ( ) ) ; Collections . shuffle ( endpoints , random ) ; for ( InetAddress endpoint : endpoints ) { epState = endpointStateMap . get ( endpoint ) ; if ( epState ! = null ) { generation = epState . getHeartBeatState ( ) . getGeneration ( ) ; maxVersion = getMaxEndpointStateVersion ( epState ) ; } gDigests . add ( new GossipDigest ( endpoint , generation , maxVersion ) ) ; } if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( GossipDigest gDigest : gDigests ) { sb . append ( gDigest ) ; sb . append ( <str> ) ; } logger . trace ( <str> , sb ) ; } } public void advertiseRemoving ( InetAddress endpoint , UUID hostId , UUID localHostId ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; int generation = epState . getHeartBeatState ( ) . getGeneration ( ) ; logger . info ( <str> , hostId ) ; logger . info ( <str> , StorageService . RING_DELAY , endpoint ) ; Uninterruptibles . sleepUninterruptibly ( StorageService . RING_DELAY , TimeUnit . MILLISECONDS ) ; epState = endpointStateMap . get ( endpoint ) ; if ( epState . getHeartBeatState ( ) . getGeneration ( ) ! = generation ) throw new RuntimeException ( <str> + endpoint + <str> ) ; logger . info ( <str> , endpoint ) ; epState . updateTimestamp ( ) ; epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; states . put ( ApplicationState . STATUS , StorageService . instance . valueFactory . removingNonlocal ( hostId ) ) ; states . put ( ApplicationState . REMOVAL_COORDINATOR , StorageService . instance . valueFactory . removalCoordinator ( localHostId ) ) ; epState . addApplicationStates ( states ) ; endpointStateMap . put ( endpoint , epState ) ; } public void advertiseTokenRemoved ( InetAddress endpoint , UUID hostId ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; epState . updateTimestamp ( ) ; epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; long expireTime = computeExpireTime ( ) ; epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . removedNonlocal ( hostId , expireTime ) ) ; logger . info ( <str> , endpoint ) ; addExpireTimeForEndpoint ( endpoint , expireTime ) ; endpointStateMap . put ( endpoint , epState ) ; Uninterruptibles . sleepUninterruptibly ( intervalInMillis * <int> , TimeUnit . MILLISECONDS ) ; } public void unsafeAssassinateEndpoint ( String address ) throws UnknownHostException { logger . warn ( <str> ) ; assassinateEndpoint ( address ) ; } public void assassinateEndpoint ( String address ) throws UnknownHostException { InetAddress endpoint = InetAddress . getByName ( address ) ; EndpointState epState = endpointStateMap . get ( endpoint ) ; Collection < Token > tokens = null ; logger . warn ( <str> , endpoint ) ; if ( epState = = null ) { epState = new EndpointState ( new HeartBeatState ( ( int ) ( ( System . currentTimeMillis ( ) + <int> ) / <int> ) , <int> ) ) ; } else { int generation = epState . getHeartBeatState ( ) . getGeneration ( ) ; int heartbeat = epState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; logger . info ( <str> , StorageService . RING_DELAY , endpoint ) ; Uninterruptibles . sleepUninterruptibly ( StorageService . RING_DELAY , TimeUnit . MILLISECONDS ) ; EndpointState newState = endpointStateMap . get ( endpoint ) ; if ( newState = = null ) logger . warn ( <str> , endpoint ) ; else if ( newState . getHeartBeatState ( ) . getGeneration ( ) ! = generation ) throw new RuntimeException ( <str> + endpoint + <str> ) ; else if ( newState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ! = heartbeat ) throw new RuntimeException ( <str> + endpoint + <str> ) ; epState . updateTimestamp ( ) ; epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; } try { tokens = StorageService . instance . getTokenMetadata ( ) . getTokens ( endpoint ) ; } catch ( Throwable th ) { JVMStabilityInspector . inspectThrowable ( th ) ; logger . warn ( <str> , address ) ; tokens = Collections . singletonList ( StorageService . instance . getTokenMetadata ( ) . partitioner . getRandomToken ( ) ) ; } epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . left ( tokens , computeExpireTime ( ) ) ) ; handleMajorStateChange ( endpoint , epState ) ; Uninterruptibles . sleepUninterruptibly ( intervalInMillis * <int> , TimeUnit . MILLISECONDS ) ; logger . warn ( <str> , endpoint ) ; } public boolean isKnownEndpoint ( InetAddress endpoint ) { return endpointStateMap . containsKey ( endpoint ) ; } public int getCurrentGenerationNumber ( InetAddress endpoint ) { return endpointStateMap . get ( endpoint ) . getHeartBeatState ( ) . getGeneration ( ) ; } private boolean sendGossip ( MessageOut < GossipDigestSyn > message , Set < InetAddress > epSet ) { List < InetAddress > liveEndpoints = ImmutableList . copyOf ( epSet ) ; int size = liveEndpoints . size ( ) ; if ( size < <int> ) return false ; int index = ( size = = <int> ) ? <int> : random . nextInt ( size ) ; InetAddress to = liveEndpoints . get ( index ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , to ) ; MessagingService . instance ( ) . sendOneWay ( message , to ) ; return seeds . contains ( to ) ; } private boolean doGossipToLiveMember ( MessageOut < GossipDigestSyn > message ) { int size = liveEndpoints . size ( ) ; if ( size = = <int> ) return false ; return sendGossip ( message , liveEndpoints ) ; } private void maybeGossipToUnreachableMember ( MessageOut < GossipDigestSyn > message ) { double liveEndpointCount = liveEndpoints . size ( ) ; double unreachableEndpointCount = unreachableEndpoints . size ( ) ; if ( unreachableEndpointCount > <int> ) { double prob = unreachableEndpointCount / ( liveEndpointCount + <int> ) ; double randDbl = random . nextDouble ( ) ; if ( randDbl < prob ) sendGossip ( message , unreachableEndpoints . keySet ( ) ) ; } } private void maybeGossipToSeed ( MessageOut < GossipDigestSyn > prod ) { int size = seeds . size ( ) ; if ( size > <int> ) { if ( size = = <int> & & seeds . contains ( FBUtilities . getBroadcastAddress ( ) ) ) { return ; } if ( liveEndpoints . size ( ) = = <int> ) { sendGossip ( prod , seeds ) ; } else { double probability = seeds . size ( ) / ( double ) ( liveEndpoints . size ( ) + unreachableEndpoints . size ( ) ) ; double randDbl = random . nextDouble ( ) ; if ( randDbl < = probability ) sendGossip ( prod , seeds ) ; } } } public boolean isGossipOnlyMember ( InetAddress endpoint ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null ) { return false ; } return ! isDeadState ( epState ) & & ! StorageService . instance . getTokenMetadata ( ) . isMember ( endpoint ) ; } public boolean isSafeForBootstrap ( InetAddress endpoint ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null | | isDeadState ( epState ) ) return true ; String status = getGossipStatus ( epState ) ; final List < String > unsafeStatuses = new ArrayList < String > ( ) { { add ( <str> ) ; add ( VersionedValue . STATUS_NORMAL ) ; add ( VersionedValue . SHUTDOWN ) ; } } ; return ! unsafeStatuses . contains ( status ) ; } private void doStatusCheck ( ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> ) ; long now = System . currentTimeMillis ( ) ; long nowNano = System . nanoTime ( ) ; long pending = ( ( JMXEnabledThreadPoolExecutor ) StageManager . getStage ( Stage . GOSSIP ) ) . metrics . pendingTasks . getValue ( ) ; if ( pending > <int> & & lastProcessedMessageAt < now - <int> ) { Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; if ( lastProcessedMessageAt < now - <int> ) { logger . warn ( <str> , pending ) ; return ; } } Set < InetAddress > eps = endpointStateMap . keySet ( ) ; for ( InetAddress endpoint : eps ) { if ( endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ) continue ; FailureDetector . instance . interpret ( endpoint ) ; EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState ! = null ) { if ( isGossipOnlyMember ( endpoint ) & & ! justRemovedEndpoints . containsKey ( endpoint ) & & TimeUnit . NANOSECONDS . toMillis ( nowNano - epState . getUpdateTimestamp ( ) ) > fatClientTimeout ) { logger . info ( <str> , endpoint , fatClientTimeout ) ; removeEndpoint ( endpoint ) ; evictFromMembership ( endpoint ) ; } long expireTime = getExpireTimeForEndpoint ( endpoint ) ; if ( ! epState . isAlive ( ) & & ( now > expireTime ) & & ( ! StorageService . instance . getTokenMetadata ( ) . isMember ( endpoint ) ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , endpoint , expireTime ) ; } evictFromMembership ( endpoint ) ; } } } if ( ! justRemovedEndpoints . isEmpty ( ) ) { for ( Entry < InetAddress , Long > entry : justRemovedEndpoints . entrySet ( ) ) { if ( ( now - entry . getValue ( ) ) > QUARANTINE_DELAY ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , QUARANTINE_DELAY , entry . getKey ( ) ) ; justRemovedEndpoints . remove ( entry . getKey ( ) ) ; } } } } protected long getExpireTimeForEndpoint ( InetAddress endpoint ) { Long storedTime = expireTimeEndpointMap . get ( endpoint ) ; return storedTime = = null ? computeExpireTime ( ) : storedTime ; } public EndpointState getEndpointStateForEndpoint ( InetAddress ep ) { return endpointStateMap . get ( ep ) ; } public boolean valuesEqual ( InetAddress ep1 , InetAddress ep2 , ApplicationState as ) { EndpointState state1 = getEndpointStateForEndpoint ( ep1 ) ; EndpointState state2 = getEndpointStateForEndpoint ( ep2 ) ; if ( state1 = = null | | state2 = = null ) return false ; VersionedValue value1 = state1 . getApplicationState ( as ) ; VersionedValue value2 = state2 . getApplicationState ( as ) ; return ! ( value1 = = null | | value2 = = null ) & & value1 . value . equals ( value2 . value ) ; } public void resetEndpointStateMap ( ) { endpointStateMap . clear ( ) ; unreachableEndpoints . clear ( ) ; liveEndpoints . clear ( ) ; } public Set < Entry < InetAddress , EndpointState > > getEndpointStates ( ) { return endpointStateMap . entrySet ( ) ; } public UUID getHostId ( InetAddress endpoint ) { return UUID . fromString ( getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . HOST_ID ) . value ) ; } EndpointState getStateForVersionBiggerThan ( InetAddress forEndpoint , int version ) { EndpointState epState = endpointStateMap . get ( forEndpoint ) ; EndpointState reqdEndpointState = null ; if ( epState ! = null ) { int localHbVersion = epState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; if ( localHbVersion > version ) { reqdEndpointState = new EndpointState ( epState . getHeartBeatState ( ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , localHbVersion , version , forEndpoint ) ; } Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; for ( Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) { VersionedValue value = entry . getValue ( ) ; if ( value . version > version ) { if ( reqdEndpointState = = null ) { reqdEndpointState = new EndpointState ( epState . getHeartBeatState ( ) ) ; } final ApplicationState key = entry . getKey ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , key , value . value ) ; states . put ( key , value ) ; } } if ( reqdEndpointState ! = null ) reqdEndpointState . addApplicationStates ( states ) ; } return reqdEndpointState ; } public int compareEndpointStartup ( InetAddress addr1 , InetAddress addr2 ) { EndpointState ep1 = getEndpointStateForEndpoint ( addr1 ) ; EndpointState ep2 = getEndpointStateForEndpoint ( addr2 ) ; assert ep1 ! = null & & ep2 ! = null ; return ep1 . getHeartBeatState ( ) . getGeneration ( ) - ep2 . getHeartBeatState ( ) . getGeneration ( ) ; } void notifyFailureDetector ( Map < InetAddress , EndpointState > remoteEpStateMap ) { for ( Entry < InetAddress , EndpointState > entry : remoteEpStateMap . entrySet ( ) ) { notifyFailureDetector ( entry . getKey ( ) , entry . getValue ( ) ) ; } } void notifyFailureDetector ( InetAddress endpoint , EndpointState remoteEndpointState ) { EndpointState localEndpointState = endpointStateMap . get ( endpoint ) ; if ( localEndpointState ! = null ) { IFailureDetector fd = FailureDetector . instance ; int localGeneration = localEndpointState . getHeartBeatState ( ) . getGeneration ( ) ; int remoteGeneration = remoteEndpointState . getHeartBeatState ( ) . getGeneration ( ) ; if ( remoteGeneration > localGeneration ) { localEndpointState . updateTimestamp ( ) ; if ( ! localEndpointState . isAlive ( ) ) { logger . debug ( <str> , endpoint ) ; fd . remove ( endpoint ) ; } fd . report ( endpoint ) ; return ; } if ( remoteGeneration = = localGeneration ) { int localVersion = getMaxEndpointStateVersion ( localEndpointState ) ; int remoteVersion = remoteEndpointState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; if ( remoteVersion > localVersion ) { localEndpointState . updateTimestamp ( ) ; fd . report ( endpoint ) ; } } } } private void markAlive ( final InetAddress addr , final EndpointState localState ) { if ( MessagingService . instance ( ) . getVersion ( addr ) < MessagingService . VERSION_20 ) { realMarkAlive ( addr , localState ) ; return ; } localState . markDead ( ) ; MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . ECHO , EchoMessage . instance , EchoMessage . serializer ) ; logger . trace ( <str> , addr ) ; IAsyncCallback echoHandler = new IAsyncCallback ( ) { public boolean isLatencyForSnitch ( ) { return false ; } public void response ( MessageIn msg ) { realMarkAlive ( addr , localState ) ; } } ; MessagingService . instance ( ) . sendRR ( echoMessage , addr , echoHandler ) ; } @VisibleForTesting public void realMarkAlive ( final InetAddress addr , final EndpointState localState ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , addr ) ; localState . markAlive ( ) ; localState . updateTimestamp ( ) ; liveEndpoints . add ( addr ) ; unreachableEndpoints . remove ( addr ) ; expireTimeEndpointMap . remove ( addr ) ; logger . debug ( <str> , addr ) ; logger . info ( <str> , addr ) ; for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onAlive ( addr , localState ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , subscribers ) ; } @VisibleForTesting public void markDead ( InetAddress addr , EndpointState localState ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , addr ) ; localState . markDead ( ) ; liveEndpoints . remove ( addr ) ; unreachableEndpoints . put ( addr , System . nanoTime ( ) ) ; logger . info ( <str> , addr ) ; for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onDead ( addr , localState ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , subscribers ) ; } private void handleMajorStateChange ( InetAddress ep , EndpointState epState ) { EndpointState localEpState = endpointStateMap . get ( ep ) ; if ( ! isDeadState ( epState ) ) { if ( localEpState ! = null ) logger . info ( <str> , ep ) ; else logger . info ( <str> , ep ) ; } if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ep ) ; endpointStateMap . put ( ep , epState ) ; if ( localEpState ! = null ) { for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onRestart ( ep , localEpState ) ; } if ( ! isDeadState ( epState ) ) markAlive ( ep , epState ) ; else { logger . debug ( <str> , ep ) ; markDead ( ep , epState ) ; } for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onJoin ( ep , epState ) ; if ( isShutdown ( ep ) ) markAsShutdown ( ep ) ; } public boolean isAlive ( InetAddress endpoint ) { EndpointState epState = getEndpointStateForEndpoint ( endpoint ) ; if ( epState = = null ) return false ; return epState . isAlive ( ) & & ! isDeadState ( epState ) ; } public boolean isDeadState ( EndpointState epState ) { String status = getGossipStatus ( epState ) ; if ( status . isEmpty ( ) ) return false ; return DEAD_STATES . contains ( status ) ; } public boolean isSilentShutdownState ( EndpointState epState ) { String status = getGossipStatus ( epState ) ; if ( status . isEmpty ( ) ) return false ; return SILENT_SHUTDOWN_STATES . contains ( status ) ; } private static String getGossipStatus ( EndpointState epState ) { if ( epState = = null | | epState . getApplicationState ( ApplicationState . STATUS ) = = null ) return <str> ; String value = epState . getApplicationState ( ApplicationState . STATUS ) . value ; String [ ] pieces = value . split ( VersionedValue . DELIMITER_STR , - <int> ) ; assert ( pieces . length > <int> ) ; return pieces [ <int> ] ; } void applyStateLocally ( Map < InetAddress , EndpointState > epStateMap ) { for ( Entry < InetAddress , EndpointState > entry : epStateMap . entrySet ( ) ) { InetAddress ep = entry . getKey ( ) ; if ( ep . equals ( FBUtilities . getBroadcastAddress ( ) ) & & ! isInShadowRound ( ) ) continue ; if ( justRemovedEndpoints . containsKey ( ep ) ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ep ) ; continue ; } EndpointState localEpStatePtr = endpointStateMap . get ( ep ) ; EndpointState remoteState = entry . getValue ( ) ; if ( localEpStatePtr ! = null ) { int localGeneration = localEpStatePtr . getHeartBeatState ( ) . getGeneration ( ) ; int remoteGeneration = remoteState . getHeartBeatState ( ) . getGeneration ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ep , localGeneration , remoteGeneration ) ; if ( localGeneration ! = <int> & & remoteGeneration > localGeneration + MAX_GENERATION_DIFFERENCE ) { logger . warn ( <str> , ep , localGeneration , remoteGeneration ) ; } else if ( remoteGeneration > localGeneration ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , remoteGeneration , localGeneration , ep ) ; handleMajorStateChange ( ep , remoteState ) ; } else if ( remoteGeneration = = localGeneration ) { int localMaxVersion = getMaxEndpointStateVersion ( localEpStatePtr ) ; int remoteMaxVersion = getMaxEndpointStateVersion ( remoteState ) ; if ( remoteMaxVersion > localMaxVersion ) { applyNewStates ( ep , localEpStatePtr , remoteState ) ; } else if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , remoteMaxVersion , localMaxVersion , ep ) ; if ( ! localEpStatePtr . isAlive ( ) & & ! isDeadState ( localEpStatePtr ) ) markAlive ( ep , localEpStatePtr ) ; } else { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , remoteGeneration , localGeneration ) ; } } else { FailureDetector . instance . report ( ep ) ; handleMajorStateChange ( ep , remoteState ) ; } } } private void applyNewStates ( InetAddress addr , EndpointState localState , EndpointState remoteState ) { int oldVersion = localState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; localState . setHeartBeatState ( remoteState . getHeartBeatState ( ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , localState . getHeartBeatState ( ) . getHeartBeatVersion ( ) , oldVersion , addr ) ; Set < Entry < ApplicationState , VersionedValue > > remoteStates = remoteState . states ( ) ; assert remoteState . getHeartBeatState ( ) . getGeneration ( ) = = localState . getHeartBeatState ( ) . getGeneration ( ) ; localState . addApplicationStates ( remoteStates ) ; for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteStates ) doOnChangeNotifications ( addr , remoteEntry . getKey ( ) , remoteEntry . getValue ( ) ) ; } private void doBeforeChangeNotifications ( InetAddress addr , EndpointState epState , ApplicationState apState , VersionedValue newValue ) { for ( IEndpointStateChangeSubscriber subscriber : subscribers ) { subscriber . beforeChange ( addr , epState , apState , newValue ) ; } } private void doOnChangeNotifications ( InetAddress addr , ApplicationState state , VersionedValue value ) { for ( IEndpointStateChangeSubscriber subscriber : subscribers ) { subscriber . onChange ( addr , state , value ) ; } } private void requestAll ( GossipDigest gDigest , List < GossipDigest > deltaGossipDigestList , int remoteGeneration ) { deltaGossipDigestList . add ( new GossipDigest ( gDigest . getEndpoint ( ) , remoteGeneration , <int> ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , gDigest . getEndpoint ( ) ) ; } private void sendAll ( GossipDigest gDigest , Map < InetAddress , EndpointState > deltaEpStateMap , int maxRemoteVersion ) { EndpointState localEpStatePtr = getStateForVersionBiggerThan ( gDigest . getEndpoint ( ) , maxRemoteVersion ) ; if ( localEpStatePtr ! = null ) deltaEpStateMap . put ( gDigest . getEndpoint ( ) , localEpStatePtr ) ; } void examineGossiper ( List < GossipDigest > gDigestList , List < GossipDigest > deltaGossipDigestList , Map < InetAddress , EndpointState > deltaEpStateMap ) { if ( gDigestList . size ( ) = = <int> ) { logger . debug ( <str> ) ; for ( Map . Entry < InetAddress , EndpointState > entry : endpointStateMap . entrySet ( ) ) { gDigestList . add ( new GossipDigest ( entry . getKey ( ) , <int> , <int> ) ) ; } } for ( GossipDigest gDigest : gDigestList ) { int remoteGeneration = gDigest . getGeneration ( ) ; int maxRemoteVersion = gDigest . getMaxVersion ( ) ; EndpointState epStatePtr = endpointStateMap . get ( gDigest . getEndpoint ( ) ) ; if ( epStatePtr ! = null ) { int localGeneration = epStatePtr . getHeartBeatState ( ) . getGeneration ( ) ; int maxLocalVersion = getMaxEndpointStateVersion ( epStatePtr ) ; if ( remoteGeneration = = localGeneration & & maxRemoteVersion = = maxLocalVersion ) continue ; if ( remoteGeneration > localGeneration ) { requestAll ( gDigest , deltaGossipDigestList , remoteGeneration ) ; } else if ( remoteGeneration < localGeneration ) { sendAll ( gDigest , deltaEpStateMap , <int> ) ; } else if ( remoteGeneration = = localGeneration ) { if ( maxRemoteVersion > maxLocalVersion ) { deltaGossipDigestList . add ( new GossipDigest ( gDigest . getEndpoint ( ) , remoteGeneration , maxLocalVersion ) ) ; } else if ( maxRemoteVersion < maxLocalVersion ) { sendAll ( gDigest , deltaEpStateMap , maxRemoteVersion ) ; } } } else { requestAll ( gDigest , deltaGossipDigestList , remoteGeneration ) ; } } } public void start ( int generationNumber ) { start ( generationNumber , new EnumMap < ApplicationState , VersionedValue > ( ApplicationState . class ) ) ; } public void start ( int generationNbr , Map < ApplicationState , VersionedValue > preloadLocalStates ) { buildSeedsList ( ) ; maybeInitializeLocalState ( generationNbr ) ; EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; localState . addApplicationStates ( preloadLocalStates ) ; DatabaseDescriptor . getEndpointSnitch ( ) . gossiperStarting ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , localState . getHeartBeatState ( ) . getGeneration ( ) ) ; scheduledGossipTask = executor . scheduleWithFixedDelay ( new GossipTask ( ) , Gossiper . intervalInMillis , Gossiper . intervalInMillis , TimeUnit . MILLISECONDS ) ; } public void doShadowRound ( ) { buildSeedsList ( ) ; List < GossipDigest > gDigests = new ArrayList < GossipDigest > ( ) ; GossipDigestSyn digestSynMessage = new GossipDigestSyn ( DatabaseDescriptor . getClusterName ( ) , DatabaseDescriptor . getPartitionerName ( ) , gDigests ) ; MessageOut < GossipDigestSyn > message = new MessageOut < GossipDigestSyn > ( MessagingService . Verb . GOSSIP_DIGEST_SYN , digestSynMessage , GossipDigestSyn . serializer ) ; inShadowRound = true ; for ( InetAddress seed : seeds ) MessagingService . instance ( ) . sendOneWay ( message , seed ) ; int slept = <int> ; try { while ( true ) { Thread . sleep ( <int> ) ; if ( ! inShadowRound ) break ; slept + = <int> ; if ( slept > StorageService . RING_DELAY ) throw new RuntimeException ( <str> ) ; } } catch ( InterruptedException wtf ) { throw new RuntimeException ( wtf ) ; } } private void buildSeedsList ( ) { for ( InetAddress seed : DatabaseDescriptor . getSeeds ( ) ) { if ( seed . equals ( FBUtilities . getBroadcastAddress ( ) ) ) continue ; seeds . add ( seed ) ; } } public void maybeInitializeLocalState ( int generationNbr ) { HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; EndpointState localState = new EndpointState ( hbState ) ; localState . markAlive ( ) ; endpointStateMap . putIfAbsent ( FBUtilities . getBroadcastAddress ( ) , localState ) ; } public void forceNewerGeneration ( ) { EndpointState epstate = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; epstate . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; } public void addSavedEndpoint ( InetAddress ep ) { if ( ep . equals ( FBUtilities . getBroadcastAddress ( ) ) ) { logger . debug ( <str> ) ; return ; } EndpointState epState = endpointStateMap . get ( ep ) ; if ( epState ! = null ) { logger . debug ( <str> , ep , epState ) ; epState . setHeartBeatState ( new HeartBeatState ( <int> ) ) ; } else { epState = new EndpointState ( new HeartBeatState ( <int> ) ) ; } epState . markDead ( ) ; endpointStateMap . put ( ep , epState ) ; unreachableEndpoints . put ( ep , System . nanoTime ( ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ep , epState . getHeartBeatState ( ) . getGeneration ( ) ) ; } private void addLocalApplicationStateInternal ( ApplicationState state , VersionedValue value ) { assert taskLock . isHeldByCurrentThread ( ) ; EndpointState epState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; InetAddress epAddr = FBUtilities . getBroadcastAddress ( ) ; assert epState ! = null ; doBeforeChangeNotifications ( epAddr , epState , state , value ) ; value = StorageService . instance . valueFactory . cloneWithHigherVersion ( value ) ; epState . addApplicationState ( state , value ) ; doOnChangeNotifications ( epAddr , state , value ) ; } public void addLocalApplicationState ( ApplicationState applicationState , VersionedValue value ) { addLocalApplicationStates ( Arrays . asList ( Pair . create ( applicationState , value ) ) ) ; } public void addLocalApplicationStates ( List < Pair < ApplicationState , VersionedValue > > states ) { taskLock . lock ( ) ; try { for ( Pair < ApplicationState , VersionedValue > pair : states ) { addLocalApplicationStateInternal ( pair . left , pair . right ) ; } } finally { taskLock . unlock ( ) ; } } public void stop ( ) { EndpointState mystate = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; if ( mystate ! = null & & ! isSilentShutdownState ( mystate ) ) { logger . info ( <str> ) ; addLocalApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . shutdown ( true ) ) ; MessageOut message = new MessageOut ( MessagingService . Verb . GOSSIP_SHUTDOWN ) ; for ( InetAddress ep : liveEndpoints ) MessagingService . instance ( ) . sendOneWay ( message , ep ) ; Uninterruptibles . sleepUninterruptibly ( Integer . getInteger ( <str> , <int> ) , TimeUnit . MILLISECONDS ) ; } else logger . warn ( <str> ) ; if ( scheduledGossipTask ! = null ) scheduledGossipTask . cancel ( false ) ; } public boolean isEnabled ( ) { return ( scheduledGossipTask ! = null ) & & ( ! scheduledGossipTask . isCancelled ( ) ) ; } protected void finishShadowRound ( ) { if ( inShadowRound ) inShadowRound = false ; } protected boolean isInShadowRound ( ) { return inShadowRound ; } @VisibleForTesting public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) { HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; EndpointState newState = new EndpointState ( hbState ) ; newState . markAlive ( ) ; EndpointState oldState = endpointStateMap . putIfAbsent ( addr , newState ) ; EndpointState localState = oldState = = null ? newState : oldState ; Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; states . put ( ApplicationState . NET_VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; states . put ( ApplicationState . HOST_ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; localState . addApplicationStates ( states ) ; } @VisibleForTesting public void injectApplicationState ( InetAddress endpoint , ApplicationState state , VersionedValue value ) { EndpointState localState = endpointStateMap . get ( endpoint ) ; localState . addApplicationState ( state , value ) ; } public long getEndpointDowntime ( String address ) throws UnknownHostException { return getEndpointDowntime ( InetAddress . getByName ( address ) ) ; } public int getCurrentGenerationNumber ( String address ) throws UnknownHostException { return getCurrentGenerationNumber ( InetAddress . getByName ( address ) ) ; } public void addExpireTimeForEndpoint ( InetAddress endpoint , long expireTime ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , endpoint , expireTime ) ; } expireTimeEndpointMap . put ( endpoint , expireTime ) ; } public static long computeExpireTime ( ) { return System . currentTimeMillis ( ) + Gossiper . aVeryLongTime ; } } 
