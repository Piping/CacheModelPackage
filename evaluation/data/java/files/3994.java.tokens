package io . netty . buffer ; import io . netty . util . ByteProcessor ; import io . netty . util . IllegalReferenceCountException ; import io . netty . util . ResourceLeakDetector ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . ScatteringByteChannel ; import java . nio . charset . Charset ; import static io . netty . util . internal . MathUtil . isOutOfBounds ; public abstract class AbstractByteBuf extends ByteBuf { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractByteBuf . class ) ; private static final String PROP_MODE = <str> ; private static final boolean checkAccessible ; static { checkAccessible = SystemPropertyUtil . getBoolean ( PROP_MODE , true ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , PROP_MODE , checkAccessible ) ; } } static final ResourceLeakDetector < ByteBuf > leakDetector = new ResourceLeakDetector < ByteBuf > ( ByteBuf . class ) ; int readerIndex ; int writerIndex ; private int markedReaderIndex ; private int markedWriterIndex ; private int maxCapacity ; private SwappedByteBuf swappedBuf ; protected AbstractByteBuf ( int maxCapacity ) { if ( maxCapacity < <int> ) { throw new IllegalArgumentException ( <str> + maxCapacity + <str> ) ; } this . maxCapacity = maxCapacity ; } @Override public int maxCapacity ( ) { return maxCapacity ; } protected final void maxCapacity ( int maxCapacity ) { this . maxCapacity = maxCapacity ; } @Override public int readerIndex ( ) { return readerIndex ; } @Override public ByteBuf readerIndex ( int readerIndex ) { if ( readerIndex < <int> | | readerIndex > writerIndex ) { throw new IndexOutOfBoundsException ( String . format ( <str> , readerIndex , writerIndex ) ) ; } this . readerIndex = readerIndex ; return this ; } @Override public int writerIndex ( ) { return writerIndex ; } @Override public ByteBuf writerIndex ( int writerIndex ) { if ( writerIndex < readerIndex | | writerIndex > capacity ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , writerIndex , readerIndex , capacity ( ) ) ) ; } this . writerIndex = writerIndex ; return this ; } @Override public ByteBuf setIndex ( int readerIndex , int writerIndex ) { if ( readerIndex < <int> | | readerIndex > writerIndex | | writerIndex > capacity ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , readerIndex , writerIndex , capacity ( ) ) ) ; } setIndex0 ( readerIndex , writerIndex ) ; return this ; } @Override public ByteBuf clear ( ) { readerIndex = writerIndex = <int> ; return this ; } @Override public boolean isReadable ( ) { return writerIndex > readerIndex ; } @Override public boolean isReadable ( int numBytes ) { return writerIndex - readerIndex > = numBytes ; } @Override public boolean isWritable ( ) { return capacity ( ) > writerIndex ; } @Override public boolean isWritable ( int numBytes ) { return capacity ( ) - writerIndex > = numBytes ; } @Override public int readableBytes ( ) { return writerIndex - readerIndex ; } @Override public int writableBytes ( ) { return capacity ( ) - writerIndex ; } @Override public int maxWritableBytes ( ) { return maxCapacity ( ) - writerIndex ; } @Override public ByteBuf markReaderIndex ( ) { markedReaderIndex = readerIndex ; return this ; } @Override public ByteBuf resetReaderIndex ( ) { readerIndex ( markedReaderIndex ) ; return this ; } @Override public ByteBuf markWriterIndex ( ) { markedWriterIndex = writerIndex ; return this ; } @Override public ByteBuf resetWriterIndex ( ) { writerIndex = markedWriterIndex ; return this ; } @Override public ByteBuf discardReadBytes ( ) { ensureAccessible ( ) ; if ( readerIndex = = <int> ) { return this ; } if ( readerIndex ! = writerIndex ) { setBytes ( <int> , this , readerIndex , writerIndex - readerIndex ) ; writerIndex - = readerIndex ; adjustMarkers ( readerIndex ) ; readerIndex = <int> ; } else { adjustMarkers ( readerIndex ) ; writerIndex = readerIndex = <int> ; } return this ; } @Override public ByteBuf discardSomeReadBytes ( ) { ensureAccessible ( ) ; if ( readerIndex = = <int> ) { return this ; } if ( readerIndex = = writerIndex ) { adjustMarkers ( readerIndex ) ; writerIndex = readerIndex = <int> ; return this ; } if ( readerIndex > = capacity ( ) > > > <int> ) { setBytes ( <int> , this , readerIndex , writerIndex - readerIndex ) ; writerIndex - = readerIndex ; adjustMarkers ( readerIndex ) ; readerIndex = <int> ; } return this ; } protected final void adjustMarkers ( int decrement ) { int markedReaderIndex = this . markedReaderIndex ; if ( markedReaderIndex < = decrement ) { this . markedReaderIndex = <int> ; int markedWriterIndex = this . markedWriterIndex ; if ( markedWriterIndex < = decrement ) { this . markedWriterIndex = <int> ; } else { this . markedWriterIndex = markedWriterIndex - decrement ; } } else { this . markedReaderIndex = markedReaderIndex - decrement ; markedWriterIndex - = decrement ; } } @Override public ByteBuf ensureWritable ( int minWritableBytes ) { if ( minWritableBytes < <int> ) { throw new IllegalArgumentException ( String . format ( <str> , minWritableBytes ) ) ; } ensureWritable0 ( minWritableBytes ) ; return this ; } private void ensureWritable0 ( int minWritableBytes ) { if ( minWritableBytes < = writableBytes ( ) ) { return ; } if ( minWritableBytes > maxCapacity - writerIndex ) { throw new IndexOutOfBoundsException ( String . format ( <str> , writerIndex , minWritableBytes , maxCapacity , this ) ) ; } int newCapacity = alloc ( ) . calculateNewCapacity ( writerIndex + minWritableBytes , maxCapacity ) ; capacity ( newCapacity ) ; } @Override public int ensureWritable ( int minWritableBytes , boolean force ) { if ( minWritableBytes < <int> ) { throw new IllegalArgumentException ( String . format ( <str> , minWritableBytes ) ) ; } if ( minWritableBytes < = writableBytes ( ) ) { return <int> ; } if ( minWritableBytes > maxCapacity - writerIndex ) { if ( force ) { if ( capacity ( ) = = maxCapacity ( ) ) { return <int> ; } capacity ( maxCapacity ( ) ) ; return <int> ; } } int newCapacity = alloc ( ) . calculateNewCapacity ( writerIndex + minWritableBytes , maxCapacity ) ; capacity ( newCapacity ) ; return <int> ; } @Override public ByteBuf order ( ByteOrder endianness ) { if ( endianness = = null ) { throw new NullPointerException ( <str> ) ; } if ( endianness = = order ( ) ) { return this ; } SwappedByteBuf swappedBuf = this . swappedBuf ; if ( swappedBuf = = null ) { this . swappedBuf = swappedBuf = newSwappedByteBuf ( ) ; } return swappedBuf ; } protected SwappedByteBuf newSwappedByteBuf ( ) { return new SwappedByteBuf ( this ) ; } @Override public byte getByte ( int index ) { checkIndex ( index ) ; return _getByte ( index ) ; } protected abstract byte _getByte ( int index ) ; @Override public boolean getBoolean ( int index ) { return getByte ( index ) ! = <int> ; } @Override public short getUnsignedByte ( int index ) { return ( short ) ( getByte ( index ) & <hex> ) ; } @Override public short getShort ( int index ) { checkIndex ( index , <int> ) ; return _getShort ( index ) ; } protected abstract short _getShort ( int index ) ; @Override public short getShortLE ( int index ) { checkIndex ( index , <int> ) ; return _getShortLE ( index ) ; } protected abstract short _getShortLE ( int index ) ; @Override public int getUnsignedShort ( int index ) { return getShort ( index ) & <hex> ; } @Override public int getUnsignedShortLE ( int index ) { return getShortLE ( index ) & <hex> ; } @Override public int getUnsignedMedium ( int index ) { checkIndex ( index , <int> ) ; return _getUnsignedMedium ( index ) ; } protected abstract int _getUnsignedMedium ( int index ) ; @Override public int getUnsignedMediumLE ( int index ) { checkIndex ( index , <int> ) ; return _getUnsignedMediumLE ( index ) ; } protected abstract int _getUnsignedMediumLE ( int index ) ; @Override public int getMedium ( int index ) { int value = getUnsignedMedium ( index ) ; if ( ( value & <hex> ) ! = <int> ) { value | = <hex> ; } return value ; } @Override public int getMediumLE ( int index ) { int value = getUnsignedMediumLE ( index ) ; if ( ( value & <hex> ) ! = <int> ) { value | = <hex> ; } return value ; } @Override public int getInt ( int index ) { checkIndex ( index , <int> ) ; return _getInt ( index ) ; } protected abstract int _getInt ( int index ) ; @Override public int getIntLE ( int index ) { checkIndex ( index , <int> ) ; return _getIntLE ( index ) ; } protected abstract int _getIntLE ( int index ) ; @Override public long getUnsignedInt ( int index ) { return getInt ( index ) & <hex> L ; } @Override public long getUnsignedIntLE ( int index ) { return getIntLE ( index ) & <hex> L ; } @Override public long getLong ( int index ) { checkIndex ( index , <int> ) ; return _getLong ( index ) ; } protected abstract long _getLong ( int index ) ; @Override public long getLongLE ( int index ) { checkIndex ( index , <int> ) ; return _getLongLE ( index ) ; } protected abstract long _getLongLE ( int index ) ; @Override public char getChar ( int index ) { return ( char ) getShort ( index ) ; } @Override public float getFloat ( int index ) { return Float . intBitsToFloat ( getInt ( index ) ) ; } @Override public double getDouble ( int index ) { return Double . longBitsToDouble ( getLong ( index ) ) ; } @Override public ByteBuf getBytes ( int index , byte [ ] dst ) { getBytes ( index , dst , <int> , dst . length ) ; return this ; } @Override public ByteBuf getBytes ( int index , ByteBuf dst ) { getBytes ( index , dst , dst . writableBytes ( ) ) ; return this ; } @Override public ByteBuf getBytes ( int index , ByteBuf dst , int length ) { getBytes ( index , dst , dst . writerIndex ( ) , length ) ; dst . writerIndex ( dst . writerIndex ( ) + length ) ; return this ; } @Override public ByteBuf setByte ( int index , int value ) { checkIndex ( index ) ; _setByte ( index , value ) ; return this ; } protected abstract void _setByte ( int index , int value ) ; @Override public ByteBuf setBoolean ( int index , boolean value ) { setByte ( index , value ? <int> : <int> ) ; return this ; } @Override public ByteBuf setShort ( int index , int value ) { checkIndex ( index , <int> ) ; _setShort ( index , value ) ; return this ; } protected abstract void _setShort ( int index , int value ) ; @Override public ByteBuf setShortLE ( int index , int value ) { checkIndex ( index , <int> ) ; _setShortLE ( index , value ) ; return this ; } protected abstract void _setShortLE ( int index , int value ) ; @Override public ByteBuf setChar ( int index , int value ) { setShort ( index , value ) ; return this ; } @Override public ByteBuf setMedium ( int index , int value ) { checkIndex ( index , <int> ) ; _setMedium ( index , value ) ; return this ; } protected abstract void _setMedium ( int index , int value ) ; @Override public ByteBuf setMediumLE ( int index , int value ) { checkIndex ( index , <int> ) ; _setMediumLE ( index , value ) ; return this ; } protected abstract void _setMediumLE ( int index , int value ) ; @Override public ByteBuf setInt ( int index , int value ) { checkIndex ( index , <int> ) ; _setInt ( index , value ) ; return this ; } protected abstract void _setInt ( int index , int value ) ; @Override public ByteBuf setIntLE ( int index , int value ) { checkIndex ( index , <int> ) ; _setIntLE ( index , value ) ; return this ; } protected abstract void _setIntLE ( int index , int value ) ; @Override public ByteBuf setFloat ( int index , float value ) { setInt ( index , Float . floatToRawIntBits ( value ) ) ; return this ; } @Override public ByteBuf setLong ( int index , long value ) { checkIndex ( index , <int> ) ; _setLong ( index , value ) ; return this ; } protected abstract void _setLong ( int index , long value ) ; @Override public ByteBuf setLongLE ( int index , long value ) { checkIndex ( index , <int> ) ; _setLongLE ( index , value ) ; return this ; } protected abstract void _setLongLE ( int index , long value ) ; @Override public ByteBuf setDouble ( int index , double value ) { setLong ( index , Double . doubleToRawLongBits ( value ) ) ; return this ; } @Override public ByteBuf setBytes ( int index , byte [ ] src ) { setBytes ( index , src , <int> , src . length ) ; return this ; } @Override public ByteBuf setBytes ( int index , ByteBuf src ) { setBytes ( index , src , src . readableBytes ( ) ) ; return this ; } @Override public ByteBuf setBytes ( int index , ByteBuf src , int length ) { checkIndex ( index , length ) ; if ( src = = null ) { throw new NullPointerException ( <str> ) ; } if ( length > src . readableBytes ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , length , src . readableBytes ( ) , src ) ) ; } setBytes ( index , src , src . readerIndex ( ) , length ) ; src . readerIndex ( src . readerIndex ( ) + length ) ; return this ; } @Override public ByteBuf setZero ( int index , int length ) { if ( length = = <int> ) { return this ; } checkIndex ( index , length ) ; int nLong = length > > > <int> ; int nBytes = length & <int> ; for ( int i = nLong ; i > <int> ; i - - ) { _setLong ( index , <int> ) ; index + = <int> ; } if ( nBytes = = <int> ) { _setInt ( index , <int> ) ; } else if ( nBytes < <int> ) { for ( int i = nBytes ; i > <int> ; i - - ) { _setByte ( index , ( byte ) <int> ) ; index + + ; } } else { _setInt ( index , <int> ) ; index + = <int> ; for ( int i = nBytes - <int> ; i > <int> ; i - - ) { _setByte ( index , ( byte ) <int> ) ; index + + ; } } return this ; } @Override public byte readByte ( ) { checkReadableBytes0 ( <int> ) ; int i = readerIndex ; byte b = _getByte ( i ) ; readerIndex = i + <int> ; return b ; } @Override public boolean readBoolean ( ) { return readByte ( ) ! = <int> ; } @Override public short readUnsignedByte ( ) { return ( short ) ( readByte ( ) & <hex> ) ; } @Override public short readShort ( ) { checkReadableBytes0 ( <int> ) ; short v = _getShort ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public short readShortLE ( ) { checkReadableBytes0 ( <int> ) ; short v = _getShortLE ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public int readUnsignedShort ( ) { return readShort ( ) & <hex> ; } @Override public int readUnsignedShortLE ( ) { return readShortLE ( ) & <hex> ; } @Override public int readMedium ( ) { int value = readUnsignedMedium ( ) ; if ( ( value & <hex> ) ! = <int> ) { value | = <hex> ; } return value ; } @Override public int readMediumLE ( ) { int value = readUnsignedMediumLE ( ) ; if ( ( value & <hex> ) ! = <int> ) { value | = <hex> ; } return value ; } @Override public int readUnsignedMedium ( ) { checkReadableBytes0 ( <int> ) ; int v = _getUnsignedMedium ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public int readUnsignedMediumLE ( ) { checkReadableBytes0 ( <int> ) ; int v = _getUnsignedMediumLE ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public int readInt ( ) { checkReadableBytes0 ( <int> ) ; int v = _getInt ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public int readIntLE ( ) { checkReadableBytes0 ( <int> ) ; int v = _getIntLE ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public long readUnsignedInt ( ) { return readInt ( ) & <hex> L ; } @Override public long readUnsignedIntLE ( ) { return readIntLE ( ) & <hex> L ; } @Override public long readLong ( ) { checkReadableBytes0 ( <int> ) ; long v = _getLong ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public long readLongLE ( ) { checkReadableBytes0 ( <int> ) ; long v = _getLongLE ( readerIndex ) ; readerIndex + = <int> ; return v ; } @Override public char readChar ( ) { return ( char ) readShort ( ) ; } @Override public float readFloat ( ) { return Float . intBitsToFloat ( readInt ( ) ) ; } @Override public double readDouble ( ) { return Double . longBitsToDouble ( readLong ( ) ) ; } @Override public ByteBuf readBytes ( int length ) { checkReadableBytes ( length ) ; if ( length = = <int> ) { return Unpooled . EMPTY_BUFFER ; } ByteBuf buf = Unpooled . buffer ( length , maxCapacity ) ; buf . writeBytes ( this , readerIndex , length ) ; readerIndex + = length ; return buf ; } @Override public ByteBuf readSlice ( int length ) { ByteBuf slice = slice ( readerIndex , length ) ; readerIndex + = length ; return slice ; } @Override public ByteBuf readBytes ( byte [ ] dst , int dstIndex , int length ) { checkReadableBytes ( length ) ; getBytes ( readerIndex , dst , dstIndex , length ) ; readerIndex + = length ; return this ; } @Override public ByteBuf readBytes ( byte [ ] dst ) { readBytes ( dst , <int> , dst . length ) ; return this ; } @Override public ByteBuf readBytes ( ByteBuf dst ) { readBytes ( dst , dst . writableBytes ( ) ) ; return this ; } @Override public ByteBuf readBytes ( ByteBuf dst , int length ) { if ( length > dst . writableBytes ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , length , dst . writableBytes ( ) , dst ) ) ; } readBytes ( dst , dst . writerIndex ( ) , length ) ; dst . writerIndex ( dst . writerIndex ( ) + length ) ; return this ; } @Override public ByteBuf readBytes ( ByteBuf dst , int dstIndex , int length ) { checkReadableBytes ( length ) ; getBytes ( readerIndex , dst , dstIndex , length ) ; readerIndex + = length ; return this ; } @Override public ByteBuf readBytes ( ByteBuffer dst ) { int length = dst . remaining ( ) ; checkReadableBytes ( length ) ; getBytes ( readerIndex , dst ) ; readerIndex + = length ; return this ; } @Override public int readBytes ( GatheringByteChannel out , int length ) throws IOException { checkReadableBytes ( length ) ; int readBytes = getBytes ( readerIndex , out , length ) ; readerIndex + = readBytes ; return readBytes ; } @Override public ByteBuf readBytes ( OutputStream out , int length ) throws IOException { checkReadableBytes ( length ) ; getBytes ( readerIndex , out , length ) ; readerIndex + = length ; return this ; } @Override public ByteBuf skipBytes ( int length ) { checkReadableBytes ( length ) ; readerIndex + = length ; return this ; } @Override public ByteBuf writeBoolean ( boolean value ) { writeByte ( value ? <int> : <int> ) ; return this ; } @Override public ByteBuf writeByte ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setByte ( writerIndex + + , value ) ; return this ; } @Override public ByteBuf writeShort ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setShort ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeShortLE ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setShortLE ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeMedium ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setMedium ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeMediumLE ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setMediumLE ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeInt ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setInt ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeIntLE ( int value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setIntLE ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeLong ( long value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setLong ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeLongLE ( long value ) { ensureAccessible ( ) ; ensureWritable0 ( <int> ) ; _setLongLE ( writerIndex , value ) ; writerIndex + = <int> ; return this ; } @Override public ByteBuf writeChar ( int value ) { writeShort ( value ) ; return this ; } @Override public ByteBuf writeFloat ( float value ) { writeInt ( Float . floatToRawIntBits ( value ) ) ; return this ; } @Override public ByteBuf writeDouble ( double value ) { writeLong ( Double . doubleToRawLongBits ( value ) ) ; return this ; } @Override public ByteBuf writeBytes ( byte [ ] src , int srcIndex , int length ) { ensureAccessible ( ) ; ensureWritable ( length ) ; setBytes ( writerIndex , src , srcIndex , length ) ; writerIndex + = length ; return this ; } @Override public ByteBuf writeBytes ( byte [ ] src ) { writeBytes ( src , <int> , src . length ) ; return this ; } @Override public ByteBuf writeBytes ( ByteBuf src ) { writeBytes ( src , src . readableBytes ( ) ) ; return this ; } @Override public ByteBuf writeBytes ( ByteBuf src , int length ) { if ( length > src . readableBytes ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , length , src . readableBytes ( ) , src ) ) ; } writeBytes ( src , src . readerIndex ( ) , length ) ; src . readerIndex ( src . readerIndex ( ) + length ) ; return this ; } @Override public ByteBuf writeBytes ( ByteBuf src , int srcIndex , int length ) { ensureAccessible ( ) ; ensureWritable ( length ) ; setBytes ( writerIndex , src , srcIndex , length ) ; writerIndex + = length ; return this ; } @Override public ByteBuf writeBytes ( ByteBuffer src ) { ensureAccessible ( ) ; int length = src . remaining ( ) ; ensureWritable ( length ) ; setBytes ( writerIndex , src ) ; writerIndex + = length ; return this ; } @Override public int writeBytes ( InputStream in , int length ) throws IOException { ensureAccessible ( ) ; ensureWritable ( length ) ; int writtenBytes = setBytes ( writerIndex , in , length ) ; if ( writtenBytes > <int> ) { writerIndex + = writtenBytes ; } return writtenBytes ; } @Override public int writeBytes ( ScatteringByteChannel in , int length ) throws IOException { ensureAccessible ( ) ; ensureWritable ( length ) ; int writtenBytes = setBytes ( writerIndex , in , length ) ; if ( writtenBytes > <int> ) { writerIndex + = writtenBytes ; } return writtenBytes ; } @Override public ByteBuf writeZero ( int length ) { if ( length = = <int> ) { return this ; } ensureWritable ( length ) ; int wIndex = writerIndex ; checkIndex ( wIndex , length ) ; int nLong = length > > > <int> ; int nBytes = length & <int> ; for ( int i = nLong ; i > <int> ; i - - ) { _setLong ( wIndex , <int> ) ; wIndex + = <int> ; } if ( nBytes = = <int> ) { _setInt ( wIndex , <int> ) ; wIndex + = <int> ; } else if ( nBytes < <int> ) { for ( int i = nBytes ; i > <int> ; i - - ) { _setByte ( wIndex , ( byte ) <int> ) ; wIndex + + ; } } else { _setInt ( wIndex , <int> ) ; wIndex + = <int> ; for ( int i = nBytes - <int> ; i > <int> ; i - - ) { _setByte ( wIndex , ( byte ) <int> ) ; wIndex + + ; } } writerIndex = wIndex ; return this ; } @Override public ByteBuf copy ( ) { return copy ( readerIndex , readableBytes ( ) ) ; } @Override public ByteBuf duplicate ( ) { return new DuplicatedAbstractByteBuf ( this ) ; } @Override public ByteBuf slice ( ) { return slice ( readerIndex , readableBytes ( ) ) ; } @Override public ByteBuf slice ( int index , int length ) { return new SlicedAbstractByteBuf ( this , index , length ) ; } @Override public ByteBuffer nioBuffer ( ) { return nioBuffer ( readerIndex , readableBytes ( ) ) ; } @Override public ByteBuffer [ ] nioBuffers ( ) { return nioBuffers ( readerIndex , readableBytes ( ) ) ; } @Override public String toString ( Charset charset ) { return toString ( readerIndex , readableBytes ( ) , charset ) ; } @Override public String toString ( int index , int length , Charset charset ) { return ByteBufUtil . decodeString ( this , index , length , charset ) ; } @Override public int indexOf ( int fromIndex , int toIndex , byte value ) { return ByteBufUtil . indexOf ( this , fromIndex , toIndex , value ) ; } @Override public int bytesBefore ( byte value ) { return bytesBefore ( readerIndex ( ) , readableBytes ( ) , value ) ; } @Override public int bytesBefore ( int length , byte value ) { checkReadableBytes ( length ) ; return bytesBefore ( readerIndex ( ) , length , value ) ; } @Override public int bytesBefore ( int index , int length , byte value ) { int endIndex = indexOf ( index , index + length , value ) ; if ( endIndex < <int> ) { return - <int> ; } return endIndex - index ; } @Override public int forEachByte ( ByteProcessor processor ) { int index = readerIndex ; int length = writerIndex - index ; ensureAccessible ( ) ; return forEachByteAsc0 ( index , length , processor ) ; } @Override public int forEachByte ( int index , int length , ByteProcessor processor ) { checkIndex ( index , length ) ; return forEachByteAsc0 ( index , length , processor ) ; } private int forEachByteAsc0 ( int index , int length , ByteProcessor processor ) { if ( processor = = null ) { throw new NullPointerException ( <str> ) ; } if ( length = = <int> ) { return - <int> ; } final int endIndex = index + length ; int i = index ; try { do { if ( processor . process ( _getByte ( i ) ) ) { i + + ; } else { return i ; } } while ( i < endIndex ) ; } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; } return - <int> ; } @Override public int forEachByteDesc ( ByteProcessor processor ) { int index = readerIndex ; int length = writerIndex - index ; ensureAccessible ( ) ; return forEachByteDesc0 ( index , length , processor ) ; } @Override public int forEachByteDesc ( int index , int length , ByteProcessor processor ) { checkIndex ( index , length ) ; return forEachByteDesc0 ( index , length , processor ) ; } private int forEachByteDesc0 ( int index , int length , ByteProcessor processor ) { if ( processor = = null ) { throw new NullPointerException ( <str> ) ; } if ( length = = <int> ) { return - <int> ; } int i = index + length - <int> ; try { do { if ( processor . process ( _getByte ( i ) ) ) { i - - ; } else { return i ; } } while ( i > = index ) ; } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; } return - <int> ; } @Override public int hashCode ( ) { return ByteBufUtil . hashCode ( this ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o instanceof ByteBuf ) { return ByteBufUtil . equals ( this , ( ByteBuf ) o ) ; } return false ; } @Override public int compareTo ( ByteBuf that ) { return ByteBufUtil . compare ( this , that ) ; } @Override public String toString ( ) { if ( refCnt ( ) = = <int> ) { return StringUtil . simpleClassName ( this ) + <str> ; } StringBuilder buf = new StringBuilder ( ) . append ( StringUtil . simpleClassName ( this ) ) . append ( <str> ) . append ( readerIndex ) . append ( <str> ) . append ( writerIndex ) . append ( <str> ) . append ( capacity ( ) ) ; if ( maxCapacity ! = Integer . MAX_VALUE ) { buf . append ( <str> ) . append ( maxCapacity ) ; } ByteBuf unwrapped = unwrap ( ) ; if ( unwrapped ! = null ) { buf . append ( <str> ) . append ( unwrapped ) ; } buf . append ( <str> ) ; return buf . toString ( ) ; } protected final void checkIndex ( int index ) { checkIndex ( index , <int> ) ; } protected final void checkIndex ( int index , int fieldLength ) { ensureAccessible ( ) ; checkIndex0 ( index , fieldLength ) ; } final void checkIndex0 ( int index , int fieldLength ) { if ( isOutOfBounds ( index , fieldLength , capacity ( ) ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , index , fieldLength , capacity ( ) ) ) ; } } protected final void checkSrcIndex ( int index , int length , int srcIndex , int srcCapacity ) { checkIndex ( index , length ) ; if ( isOutOfBounds ( srcIndex , length , srcCapacity ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , srcIndex , length , srcCapacity ) ) ; } } protected final void checkDstIndex ( int index , int length , int dstIndex , int dstCapacity ) { checkIndex ( index , length ) ; if ( isOutOfBounds ( dstIndex , length , dstCapacity ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , dstIndex , length , dstCapacity ) ) ; } } protected final void checkReadableBytes ( int minimumReadableBytes ) { if ( minimumReadableBytes < <int> ) { throw new IllegalArgumentException ( <str> + minimumReadableBytes + <str> ) ; } checkReadableBytes0 ( minimumReadableBytes ) ; } private void checkReadableBytes0 ( int minimumReadableBytes ) { ensureAccessible ( ) ; if ( readerIndex > writerIndex - minimumReadableBytes ) { throw new IndexOutOfBoundsException ( String . format ( <str> , readerIndex , minimumReadableBytes , writerIndex , this ) ) ; } } protected final void ensureAccessible ( ) { if ( checkAccessible & & refCnt ( ) = = <int> ) { throw new IllegalReferenceCountException ( <int> ) ; } } final void setIndex0 ( int readerIndex , int writerIndex ) { this . readerIndex = readerIndex ; this . writerIndex = writerIndex ; } final void discardMarks ( ) { markedReaderIndex = markedWriterIndex = <int> ; } }